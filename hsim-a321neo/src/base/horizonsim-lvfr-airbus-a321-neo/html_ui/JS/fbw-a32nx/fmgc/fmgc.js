(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Fmgc = {}));
})(this, (function (exports) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  // Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
  let AltitudeDescriptor = /*#__PURE__*/function (AltitudeDescriptor) {
    AltitudeDescriptor[AltitudeDescriptor["Empty"] = 0] = "Empty";
    AltitudeDescriptor[AltitudeDescriptor["At"] = 1] = "At";
    AltitudeDescriptor[AltitudeDescriptor["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeDescriptor[AltitudeDescriptor["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeDescriptor[AltitudeDescriptor["Between"] = 4] = "Between";
    AltitudeDescriptor[AltitudeDescriptor["C"] = 5] = "C";
    AltitudeDescriptor[AltitudeDescriptor["G"] = 6] = "G";
    AltitudeDescriptor[AltitudeDescriptor["H"] = 7] = "H";
    AltitudeDescriptor[AltitudeDescriptor["I"] = 8] = "I";
    AltitudeDescriptor[AltitudeDescriptor["J"] = 9] = "J";
    AltitudeDescriptor[AltitudeDescriptor["V"] = 10] = "V";
    return AltitudeDescriptor;
  }({}); // X, not supported
  // Y, not supported
  let FixTypeFlags$1 = /*#__PURE__*/function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    return FixTypeFlags;
  }({});

  // ARINC424 names
  let LegType$1 = /*#__PURE__*/function (LegType) {
    LegType[LegType["Unknown"] = 0] = "Unknown";
    LegType[LegType["AF"] = 1] = "AF";
    LegType[LegType["CA"] = 2] = "CA";
    LegType[LegType["CD"] = 3] = "CD";
    LegType[LegType["CF"] = 4] = "CF";
    LegType[LegType["CI"] = 5] = "CI";
    LegType[LegType["CR"] = 6] = "CR";
    LegType[LegType["DF"] = 7] = "DF";
    LegType[LegType["FA"] = 8] = "FA";
    LegType[LegType["FC"] = 9] = "FC";
    LegType[LegType["FD"] = 10] = "FD";
    LegType[LegType["FM"] = 11] = "FM";
    LegType[LegType["HA"] = 12] = "HA";
    LegType[LegType["HF"] = 13] = "HF";
    LegType[LegType["HM"] = 14] = "HM";
    LegType[LegType["IF"] = 15] = "IF";
    LegType[LegType["PI"] = 16] = "PI";
    LegType[LegType["RF"] = 17] = "RF";
    LegType[LegType["TF"] = 18] = "TF";
    LegType[LegType["VA"] = 19] = "VA";
    LegType[LegType["VD"] = 20] = "VD";
    LegType[LegType["VI"] = 21] = "VI";
    LegType[LegType["VM"] = 22] = "VM";
    LegType[LegType["VR"] = 23] = "VR";
    return LegType;
  }({}); // Heading to a VOR radial
  let NearestSearchType = /*#__PURE__*/function (NearestSearchType) {
    NearestSearchType[NearestSearchType["None"] = 0] = "None";
    NearestSearchType[NearestSearchType["Airport"] = 1] = "Airport";
    NearestSearchType[NearestSearchType["Intersection"] = 2] = "Intersection";
    NearestSearchType[NearestSearchType["Vor"] = 3] = "Vor";
    NearestSearchType[NearestSearchType["Ndb"] = 4] = "Ndb";
    NearestSearchType[NearestSearchType["Boundary"] = 5] = "Boundary";
    return NearestSearchType;
  }({});
  let RunwayDesignatorChar = /*#__PURE__*/function (RunwayDesignatorChar) {
    RunwayDesignatorChar[RunwayDesignatorChar["L"] = 1] = "L";
    RunwayDesignatorChar[RunwayDesignatorChar["R"] = 2] = "R";
    RunwayDesignatorChar[RunwayDesignatorChar["C"] = 3] = "C";
    RunwayDesignatorChar[RunwayDesignatorChar["W"] = 4] = "W";
    RunwayDesignatorChar[RunwayDesignatorChar["A"] = 5] = "A";
    RunwayDesignatorChar[RunwayDesignatorChar["B"] = 6] = "B";
    return RunwayDesignatorChar;
  }({});
  let RunwaySurface = /*#__PURE__*/function (RunwaySurface) {
    RunwaySurface[RunwaySurface["Concrete"] = 0] = "Concrete";
    RunwaySurface[RunwaySurface["Grass"] = 1] = "Grass";
    RunwaySurface[RunwaySurface["WaterFsx"] = 2] = "WaterFsx";
    RunwaySurface[RunwaySurface["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurface[RunwaySurface["Asphalt"] = 4] = "Asphalt";
    RunwaySurface[RunwaySurface["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurface[RunwaySurface["LongGrass"] = 6] = "LongGrass";
    RunwaySurface[RunwaySurface["HardTurf"] = 7] = "HardTurf";
    RunwaySurface[RunwaySurface["Snow"] = 8] = "Snow";
    RunwaySurface[RunwaySurface["Ice"] = 9] = "Ice";
    RunwaySurface[RunwaySurface["Urban"] = 10] = "Urban";
    RunwaySurface[RunwaySurface["Forest"] = 11] = "Forest";
    RunwaySurface[RunwaySurface["Dirt"] = 12] = "Dirt";
    RunwaySurface[RunwaySurface["Coral"] = 13] = "Coral";
    RunwaySurface[RunwaySurface["Gravel"] = 14] = "Gravel";
    RunwaySurface[RunwaySurface["OilTreated"] = 15] = "OilTreated";
    RunwaySurface[RunwaySurface["SteelMats"] = 16] = "SteelMats";
    RunwaySurface[RunwaySurface["Bituminous"] = 17] = "Bituminous";
    RunwaySurface[RunwaySurface["Brick"] = 18] = "Brick";
    RunwaySurface[RunwaySurface["Macadam"] = 19] = "Macadam";
    RunwaySurface[RunwaySurface["Planks"] = 20] = "Planks";
    RunwaySurface[RunwaySurface["Sand"] = 21] = "Sand";
    RunwaySurface[RunwaySurface["Shale"] = 22] = "Shale";
    RunwaySurface[RunwaySurface["Tarmac"] = 23] = "Tarmac";
    RunwaySurface[RunwaySurface["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    RunwaySurface[RunwaySurface["Ocean"] = 26] = "Ocean";
    RunwaySurface[RunwaySurface["Water"] = 27] = "Water";
    RunwaySurface[RunwaySurface["Pond"] = 28] = "Pond";
    RunwaySurface[RunwaySurface["Lake"] = 29] = "Lake";
    RunwaySurface[RunwaySurface["River"] = 30] = "River";
    RunwaySurface[RunwaySurface["WasterWater"] = 31] = "WasterWater";
    RunwaySurface[RunwaySurface["Paint"] = 32] = "Paint";
    return RunwaySurface;
  }({});
  let TurnDirection = /*#__PURE__*/function (TurnDirection) {
    TurnDirection[TurnDirection["Unknown"] = 0] = "Unknown";
    TurnDirection[TurnDirection["Left"] = 1] = "Left";
    TurnDirection[TurnDirection["Right"] = 2] = "Right";
    TurnDirection[TurnDirection["Either"] = 3] = "Either";
    return TurnDirection;
  }({});
  let VorClass$1 = /*#__PURE__*/function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAltitude"] = 2] = "LowAltitude";
    VorClass[VorClass["HighAlttitude"] = 3] = "HighAlttitude";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
    return VorClass;
  }({});
  let VorType$1 = /*#__PURE__*/function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
    return VorType;
  }({});

  // Copyright (c) 2023 FlyByWire Simulations
  class RunwayUtils$1 {
    static runwayString(runwayNumber, runwayDesignator) {
      if (runwayNumber > 0) {
        return "".concat(runwayNumber.toFixed(0).padStart(2, '0')).concat(RunwayUtils$1.designatorString(runwayDesignator));
      }
      return '';
    }
    static designatorString(runwayDesignator) {
      switch (runwayDesignator) {
        case RunwayDesignatorChar.A:
          return 'A';
        case RunwayDesignatorChar.B:
          return 'B';
        case RunwayDesignatorChar.C:
          return 'C';
        case RunwayDesignatorChar.L:
          return 'L';
        case RunwayDesignatorChar.R:
          return 'R';
        case RunwayDesignatorChar.W:
          return 'W';
        default:
          return '';
      }
    }
  }

  class ApproachUtils {
    static parseApproachName(name) {
      var _match$, _match$2, _match$3;
      // L(eft), C(entre), R(ight), T(true North) are the possible runway designators (ARINC424)
      // If there are multiple procedures for the same type of approach, an alphanumeric suffix is added to their names (last subpattern)
      // We are a little more lenient than ARINC424 in an effort to match non-perfect navdata, so we allow dashes, spaces, or nothing before the suffix
      const match = name.trim().match(/^(ILS|LOC|RNAV|NDB|VOR|GPS)? ?(RW)?([0-9]{1,2}[LCRT]?)?([\s-]*([A-Z0-9]))?$/);
      if (!match) {
        return undefined;
      }
      return {
        type: (_match$ = match[1]) !== null && _match$ !== void 0 ? _match$ : '',
        runway: (_match$2 = match[3]) !== null && _match$2 !== void 0 ? _match$2 : '',
        designator: (_match$3 = match[5]) !== null && _match$3 !== void 0 ? _match$3 : ''
      };
    }
    static parseApproach(approach) {
      const type = ApproachUtils.approachTypeString(approach.approachType);
      const runway = RunwayUtils$1.runwayString(approach.runwayNumber, approach.runwayDesignator);
      const designator = approach.approachSuffix;
      return {
        type,
        runway,
        designator
      };
    }
    static formatShortApproachName(arg0) {
      let appr;
      if (typeof arg0 === 'string') {
        appr = ApproachUtils.parseApproachName(arg0);
      } else if ('finalLegs' in arg0) {
        appr = ApproachUtils.parseApproach(arg0);
      } else {
        appr = arg0;
      }
      if (!appr) {
        return typeof arg0 === 'string' ? arg0 : '';
      }
      const runway = Avionics.Utils.formatRunway(appr.runway);
      const suffix = appr.designator ? "".concat(runway.length > 2 ? '' : '-').concat(appr.designator) : '';
      return "".concat(appr.type.replace('RNAV', 'RNV')).concat(runway).concat(suffix);
    }
    static formatLongApproachName(arg0) {
      let appr;
      if (typeof arg0 === 'string') {
        appr = ApproachUtils.parseApproachName(arg0);
      } else if ('finalLegs' in arg0) {
        appr = ApproachUtils.parseApproach(arg0);
      } else {
        appr = arg0;
      }
      const runway = Avionics.Utils.formatRunway(appr.runway);
      const suffix = appr.designator ? "-".concat(appr.designator) : '';
      return "".concat(appr.type).concat(runway).concat(suffix);
    }
    static approachTypeString(type) {
      switch (type) {
        case ApproachType.APPROACH_TYPE_GPS:
          return 'GPS';
        case ApproachType.APPROACH_TYPE_ILS:
          return 'ILS';
        case ApproachType.APPROACH_TYPE_LDA:
          return 'LDA';
        case ApproachType.APPROACH_TYPE_LOCALIZER:
        case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
          return 'LOC';
        case ApproachType.APPROACH_TYPE_NDB:
        case ApproachType.APPROACH_TYPE_NDBDME:
          return 'NDB';
        case ApproachType.APPROACH_TYPE_RNAV:
          return 'RNAV';
        case ApproachType.APPROACH_TYPE_SDF:
          return 'SDF';
        case ApproachType.APPROACH_TYPE_VOR:
        case ApproachType.APPROACH_TYPE_VORDME:
          return 'VOR';
        default:
          return '';
      }
    }
  }
  _defineProperty(ApproachUtils, "shortApproachName", ApproachUtils.formatShortApproachName);
  _defineProperty(ApproachUtils, "longApproachName", ApproachUtils.formatLongApproachName);

  /**
   * Allows interacting with the persistent storage
   */
  class NXDataStore {
    static get listener() {
      if (this.mListener === undefined) {
        this.mListener = RegisterViewListener('JS_LISTENER_SIMVARS', null, true);
      }
      return this.mListener;
    }

    /**
     * Reads a value from persistent storage
     * @param key The property key
     * @param defaultVal The default value if the property is not set
     */

    static get(key, defaultVal) {
      const val = GetStoredData("A32NX_".concat(key));
      // GetStoredData returns null on error, or empty string for keys that don't exist (why isn't that an error??)
      // We could use SearchStoredData, but that spams the console with every key (somebody left their debug print in)
      if (val === null || val.length === 0) {
        return defaultVal;
      }
      return val;
    }

    /**
     * Sets a value in persistent storage
     *
     * @param key The property key
     * @param val The value to assign to the property
     */
    static set(key, val) {
      SetStoredData("A32NX_".concat(key), val);
      this.listener.triggerToAllSubscribers('A32NX_NXDATASTORE_UPDATE', key, val);
    }
    static subscribe(key, callback) {
      return Coherent.on('A32NX_NXDATASTORE_UPDATE', (updatedKey, value) => {
        if (key === '*' || key === updatedKey) {
          callback(updatedKey, value);
        }
      }).clear;
    }
    static getAndSubscribe(key, callback, defaultVal) {
      callback(key, NXDataStore.get(key, defaultVal));
      return NXDataStore.subscribe(key, callback);
    }
  }
  _defineProperty(NXDataStore, "mListener", void 0);

  // Copyright (c) 2021-2022 FlyByWire Simulations
  // Copyright (c) 2021-2022 Synaptic Simulations
  //
  // SPDX-License-Identifier: GPL-3.0

  const LnavConfig = {
    /* ========== PATHGEN CONFIG ========== */

    /**
     * The minimum TAS we ever compute guidables with
     */
    DEFAULT_MIN_PREDICTED_TAS: 160,
    /**
     * Coefficient applied to all transition turn radii
     */
    TURN_RADIUS_FACTOR: 1.0,
    /**
     * The number of transitions to compute after the active leg (-1: no limit, compute all transitions)
     */
    NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE: -1,
    /* ========== false INFO ========== */

    /**
     * Whether to print geometry generation / update debug info
     */
    DEBUG_GEOMETRY: false,
    /**
     * Whether to use the L:A32NX_DEBUG_TAS and L:A32NX_DEBUG_GS LVar for prediction speeds
     */
    DEBUG_USE_SPEED_LVARS: false,
    /**
     * Whether to force the drawing of course reversal (hold, proc turn) vectors at any point in the path
     */
    DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS: false,
    /**
     * Whether to print guidance debug information on the ND
     */
    DEBUG_GUIDANCE: false,
    /**
     * Whether to print guidable recomputation info
     */
    DEBUG_GUIDABLE_RECOMPUTATION: false,
    /**
     * Whether to draw path debug points and print them out
     */
    DEBUG_PREDICTED_PATH: false,
    /**
     * Whether to print SVG path generation debug info
     */
    DEBUG_PATH_DRAWING: false,
    /**
     * Whether to print FMS timing information
     */
    DEBUG_PERF: false,
    /**
     * Whether to save the flight plan to local storage (keeps flight plan over instrument reload)
     */
    DEBUG_SAVE_FPLN_LOCAL_STORAGE: false
  };

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  /**
   * Information about the current direct-to procedures in the flight plan.
   */
  class DirectTo {
    constructor() {
      /** Whether or not the current direct-to is in the flight plan. */
      _defineProperty(this, "waypointIsInFlightPlan", false);
      /** Whether or not direct-to is active. */
      _defineProperty(this, "isActive", false);
      /** The current direct-to waypoint, if not part of the flight plan. */
      _defineProperty(this, "waypoint", void 0);
      /** The current direct-to waypoint index, if part of the flight plan. */
      _defineProperty(this, "planWaypointIndex", 0);
      /** The intercept points towards the direct. */
      _defineProperty(this, "interceptPoints", void 0);
      /** The current active index in the direct to waypoints. */
      _defineProperty(this, "currentWaypointIndex", 0);
      /** The segments of the direct plan. */
      _defineProperty(this, "segments", void 0);
    }
  }

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  /**
   * A segment of a flight plan.
   */
  class FlightPlanSegment$1 {
    /**
    * Creates a new FlightPlanSegment.
    * @param type The type of the flight plan segment.
    * @param offset The offset within the original flight plan that
    * the segment starts at.
    * @param waypoints The waypoints in the flight plan segment.
    */
    constructor(type, offset, waypoints) {
      this.type = type;
      this.offset = offset;
      this.waypoints = waypoints;
      this.type = type;
      this.offset = offset;
      this.waypoints = waypoints;
    }

    /** An empty flight plan segment. */
  }

  /** Types of flight plan segments. */
  _defineProperty(FlightPlanSegment$1, "Empty", new FlightPlanSegment$1(-1, -1, []));
  let SegmentType = /*#__PURE__*/function (SegmentType) {
    SegmentType[SegmentType["Origin"] = 0] = "Origin";
    SegmentType[SegmentType["Departure"] = 1] = "Departure";
    SegmentType[SegmentType["Enroute"] = 2] = "Enroute";
    SegmentType[SegmentType["Arrival"] = 3] = "Arrival";
    SegmentType[SegmentType["Approach"] = 4] = "Approach";
    SegmentType[SegmentType["Missed"] = 5] = "Missed";
    SegmentType[SegmentType["Destination"] = 6] = "Destination";
    return SegmentType;
  }({});

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  /**
   * Methods for interacting with the FS9GPS subsystem.
   */
  class GPS {
    /**
    * Clears the FS9GPS flight plan.
    */
    static async clearPlan() {
      const totalGpsWaypoints = SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointsNumber', 'number');
      for (let i = 0; i < totalGpsWaypoints; i++) {
        // Always remove waypoint 0 here, which shifts the rest of the waypoints down one
        GPS.deleteWaypoint(0).catch(console.error);
      }
    }

    /**
    * Adds a waypoint to the FS9GPS flight plan by ICAO designation.
    * @param icao The MSFS ICAO to add to the flight plan.
    * @param index The index of the waypoint to add in the flight plan.
    */
    static async addIcaoWaypoint(icao, index) {
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointICAO', 'string', icao).catch(console.error);
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanAddWaypoint', 'number', index).catch(console.error);
    }

    /**
    * Adds a user waypoint to the FS9GPS flight plan.
    * @param lat The latitude of the user waypoint.
    * @param lon The longitude of the user waypoint.
    * @param index The index of the waypoint to add in the flight plan.
    * @param ident The ident of the waypoint.
    */
    static async addUserWaypoint(lat, lon, index, ident) {
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointLatitude', 'degrees', lat).catch(console.error);
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointLongitude', 'degrees', lon).catch(console.error);
      if (ident) {
        await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointIdent', 'string', ident).catch(console.error);
      }
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanAddWaypoint', 'number', index).catch(console.error);
    }

    /**
    * Deletes a waypoint from the FS9GPS flight plan.
    * @param index The index of the waypoint in the flight plan to delete.
    */
    static async deleteWaypoint(index) {
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanDeleteWaypoint', 'number', index).catch(console.error);
    }

    /**
    * Sets the active FS9GPS waypoint.
    * @param {Number} index The index of the waypoint to set active.
    */
    static async setActiveWaypoint(index) {
      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanActiveWaypoint', 'number', index).catch(console.error);
    }

    /**
    * Gets the active FS9GPS waypoint.
    */
    static getActiveWaypoint() {
      return SimVar.GetSimVarValue('C:fs9gps:FlightPlanActiveWaypoint', 'number');
    }

    /**
    * Logs the current FS9GPS flight plan.
    */
    static async logCurrentPlan() {
      const waypointIdents = [];
      const totalGpsWaypoints = SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointsNumber', 'number');
      for (let i = 0; i < totalGpsWaypoints; i++) {
        SimVar.SetSimVarValue('C:fs9gps:FlightPlanWaypointIndex', 'number', i);
        waypointIdents.push(SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointIdent', 'string'));
      }
      console.log("GPS Plan: ".concat(waypointIdents.join(' ')));
    }
  }

  //  Copyright (c) 2021 FlyByWire Simulations
  //  SPDX-License-Identifier: GPL-3.0

  let HoldType = /*#__PURE__*/function (HoldType) {
    HoldType[HoldType["Computed"] = 0] = "Computed";
    HoldType[HoldType["Database"] = 1] = "Database";
    HoldType[HoldType["Pilot"] = 2] = "Pilot";
    return HoldType;
  }({});

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var _extends_1 = createCommonjsModule(function (module) {
    function _extends() {
      module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends.apply(this, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });
  var _extends = /*@__PURE__*/getDefaultExportFromCjs(_extends_1);

  var DEFAULT_CONFIG = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,
    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: 'Matrix',
    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: 'number',
    // number of significant digits in BigNumbers
    precision: 64,
    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
    // predictable is false, and returns `NaN` when true.
    predictable: false,
    // random seed for seeded pseudo random number generation
    // null = randomly seed
    randomSeed: null
  };

  // type checks for all known types
  //
  // note that:
  //
  // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
  //   instanceof cannot be used because that would not allow to pass data from
  //   one instance of math.js to another since each has it's own instance of Unit.
  // - check the `isUnit` property via the constructor, so there will be no
  //   matches for "fake" instances like plain objects with a property `isUnit`.
  //   That is important for security reasons.
  // - It must not be possible to override the type checks used internally,
  //   for security reasons, so these functions are not exposed in the expression
  //   parser.
  function isNumber(x) {
    return typeof x === 'number';
  }
  function isBigNumber(x) {
    if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {
      return false;
    }
    if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {
      return true;
    }
    if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {
      return true;
    }
    return false;
  }
  function isComplex(x) {
    return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === 'string';
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  /**
   * Test whether a value is a collection: an Array or Matrix
   * @param {*} x
   * @returns {boolean} isCollection
   */

  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === 'boolean';
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === 'function';
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === undefined;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = typeof x;
    if (t === 'object') {
      // JavaScript types
      if (x === null) return 'null';
      if (Array.isArray(x)) return 'Array';
      if (x instanceof Date) return 'Date';
      if (x instanceof RegExp) return 'RegExp'; // math.js types

      if (isBigNumber(x)) return 'BigNumber';
      if (isComplex(x)) return 'Complex';
      if (isFraction(x)) return 'Fraction';
      if (isMatrix(x)) return 'Matrix';
      if (isUnit(x)) return 'Unit';
      if (isIndex(x)) return 'Index';
      if (isRange(x)) return 'Range';
      if (isResultSet(x)) return 'ResultSet';
      if (isNode(x)) return x.type;
      if (isChain(x)) return 'Chain';
      if (isHelp(x)) return 'Help';
      return 'Object';
    }
    if (t === 'function') return 'Function';
    return t; // can be 'string', 'number', 'boolean', ...
  }

  /**
   * Clone an object
   *
   *     clone(x)
   *
   * Can clone any primitive type, array, and object.
   * If x has a function clone, this function will be invoked to clone the object.
   *
   * @param {*} x
   * @return {*} clone
   */

  function clone$1(x) {
    var type = typeof x; // immutable primitive types

    if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {
      return x;
    } // use clone function of the object when available

    if (typeof x.clone === 'function') {
      return x.clone();
    } // array

    if (Array.isArray(x)) {
      return x.map(function (value) {
        return clone$1(value);
      });
    }
    if (x instanceof Date) return new Date(x.valueOf());
    if (isBigNumber(x)) return x; // bignumbers are immutable

    if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp
    // object

    return mapObject(x, clone$1);
  }
  /**
   * Apply map to all properties of an object
   * @param {Object} object
   * @param {function} callback
   * @return {Object} Returns a copy of the object with mapped properties
   */

  function mapObject(object, callback) {
    var clone = {};
    for (var key in object) {
      if (hasOwnProperty(object, key)) {
        clone[key] = callback(object[key]);
      }
    }
    return clone;
  }
  /**
   * Extend object a with the properties of object b
   * @param {Object} a
   * @param {Object} b
   * @return {Object} a
   */

  function extend(a, b) {
    for (var prop in b) {
      if (hasOwnProperty(b, prop)) {
        a[prop] = b[prop];
      }
    }
    return a;
  }
  /**
   * Deep test equality of all fields in two pairs of arrays or objects.
   * Compares values and functions strictly (ie. 2 is not the same as '2').
   * @param {Array | Object} a
   * @param {Array | Object} b
   * @returns {boolean}
   */

  function deepStrictEqual(a, b) {
    var prop, i, len;
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0, len = a.length; i < len; i++) {
        if (!deepStrictEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    } else if (typeof a === 'function') {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }
      for (prop in a) {
        // noinspection JSUnfilteredForInLoop
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      for (prop in b) {
        // noinspection JSUnfilteredForInLoop
        if (!(prop in a)) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  }
  /**
   * A safe hasOwnProperty
   * @param {Object} object
   * @param {string} property
   */

  function hasOwnProperty(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  /**
   * Shallow version of pick, creating an object composed of the picked object properties
   * but not for nested properties
   * @param {Object} object
   * @param {string[]} properties
   * @return {Object}
   */

  function pickShallow(object, properties) {
    var copy = {};
    for (var i = 0; i < properties.length; i++) {
      var key = properties[i];
      var value = object[key];
      if (value !== undefined) {
        copy[key] = value;
      }
    }
    return copy;
  }

  var MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix

  var NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number

  var config$1 = function config(options) {
    if (options) {
      throw new Error('The global config is readonly. \n' + 'Please create a mathjs instance if you want to change the default configuration. \n' + 'Example:\n' + '\n' + '  import { create, all } from \'mathjs\';\n' + '  const mathjs = create(all);\n' + '  mathjs.config({ number: \'BigNumber\' });\n');
    }
    return Object.freeze(DEFAULT_CONFIG);
  };
  _extends(config$1, DEFAULT_CONFIG, {
    MATRIX_OPTIONS,
    NUMBER_OPTIONS
  });

  var typedFunction = createCommonjsModule(function (module, exports) {

    (function (root, factory) {
      {
        // OldNode. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like OldNode.
        module.exports = factory();
      }
    })(commonjsGlobal, function () {
      function ok() {
        return true;
      }
      function notOk() {
        return false;
      }
      function undef() {
        return undefined;
      }

      /**
       * @typedef {{
       *   params: Param[],
       *   fn: function
       * }} Signature
       *
       * @typedef {{
       *   types: Type[],
       *   restParam: boolean
       * }} Param
       *
       * @typedef {{
       *   name: string,
       *   typeIndex: number,
       *   test: function,
       *   conversion?: ConversionDef,
       *   conversionIndex: number,
       * }} Type
       *
       * @typedef {{
       *   from: string,
       *   to: string,
       *   convert: function (*) : *
       * }} ConversionDef
       *
       * @typedef {{
       *   name: string,
       *   test: function(*) : boolean
       * }} TypeDef
       */

      // create a new instance of typed-function
      function create() {
        // data type tests
        var _types = [{
          name: 'number',
          test: function (x) {
            return typeof x === 'number';
          }
        }, {
          name: 'string',
          test: function (x) {
            return typeof x === 'string';
          }
        }, {
          name: 'boolean',
          test: function (x) {
            return typeof x === 'boolean';
          }
        }, {
          name: 'Function',
          test: function (x) {
            return typeof x === 'function';
          }
        }, {
          name: 'Array',
          test: Array.isArray
        }, {
          name: 'Date',
          test: function (x) {
            return x instanceof Date;
          }
        }, {
          name: 'RegExp',
          test: function (x) {
            return x instanceof RegExp;
          }
        }, {
          name: 'Object',
          test: function (x) {
            return typeof x === 'object' && x !== null && x.constructor === Object;
          }
        }, {
          name: 'null',
          test: function (x) {
            return x === null;
          }
        }, {
          name: 'undefined',
          test: function (x) {
            return x === undefined;
          }
        }];
        var anyType = {
          name: 'any',
          test: ok
        };

        // types which need to be ignored
        var _ignore = [];

        // type conversions
        var _conversions = [];

        // This is a temporary object, will be replaced with a typed function at the end
        var typed = {
          types: _types,
          conversions: _conversions,
          ignore: _ignore
        };

        /**
         * Find the test function for a type
         * @param {String} typeName
         * @return {TypeDef} Returns the type definition when found,
         *                    Throws a TypeError otherwise
         */
        function findTypeByName(typeName) {
          var entry = findInArray(typed.types, function (entry) {
            return entry.name === typeName;
          });
          if (entry) {
            return entry;
          }
          if (typeName === 'any') {
            // special baked-in case 'any'
            return anyType;
          }
          var hint = findInArray(typed.types, function (entry) {
            return entry.name.toLowerCase() === typeName.toLowerCase();
          });
          throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ''));
        }

        /**
         * Find the index of a type definition. Handles special case 'any'
         * @param {TypeDef} type
         * @return {number}
         */
        function findTypeIndex(type) {
          if (type === anyType) {
            return 999;
          }
          return typed.types.indexOf(type);
        }

        /**
         * Find a type that matches a value.
         * @param {*} value
         * @return {string} Returns the name of the first type for which
         *                  the type test matches the value.
         */
        function findTypeName(value) {
          var entry = findInArray(typed.types, function (entry) {
            return entry.test(value);
          });
          if (entry) {
            return entry.name;
          }
          throw new TypeError('Value has unknown type. Value: ' + value);
        }

        /**
         * Find a specific signature from a (composed) typed function, for example:
         *
         *   typed.find(fn, ['number', 'string'])
         *   typed.find(fn, 'number, string')
         *
         * Function find only only works for exact matches.
         *
         * @param {Function} fn                   A typed-function
         * @param {string | string[]} signature   Signature to be found, can be
         *                                        an array or a comma separated string.
         * @return {Function}                     Returns the matching signature, or
         *                                        throws an error when no signature
         *                                        is found.
         */
        function find(fn, signature) {
          if (!fn.signatures) {
            throw new TypeError('Function is no typed-function');
          }

          // normalize input
          var arr;
          if (typeof signature === 'string') {
            arr = signature.split(',');
            for (var i = 0; i < arr.length; i++) {
              arr[i] = arr[i].trim();
            }
          } else if (Array.isArray(signature)) {
            arr = signature;
          } else {
            throw new TypeError('String array or a comma separated string expected');
          }
          var str = arr.join(',');

          // find an exact match
          var match = fn.signatures[str];
          if (match) {
            return match;
          }

          // TODO: extend find to match non-exact signatures

          throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
        }

        /**
         * Convert a given value to another data type.
         * @param {*} value
         * @param {string} type
         */
        function convert(value, type) {
          var from = findTypeName(value);

          // check conversion is needed
          if (type === from) {
            return value;
          }
          for (var i = 0; i < typed.conversions.length; i++) {
            var conversion = typed.conversions[i];
            if (conversion.from === from && conversion.to === type) {
              return conversion.convert(value);
            }
          }
          throw new Error('Cannot convert from ' + from + ' to ' + type);
        }

        /**
         * Stringify parameters in a normalized way
         * @param {Param[]} params
         * @return {string}
         */
        function stringifyParams(params) {
          return params.map(function (param) {
            var typeNames = param.types.map(getTypeName);
            return (param.restParam ? '...' : '') + typeNames.join('|');
          }).join(',');
        }

        /**
         * Parse a parameter, like "...number | boolean"
         * @param {string} param
         * @param {ConversionDef[]} conversions
         * @return {Param} param
         */
        function parseParam(param, conversions) {
          var restParam = param.indexOf('...') === 0;
          var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';
          var typeNames = types.split('|').map(trim).filter(notEmpty).filter(notIgnore);
          var matchingConversions = filterConversions(conversions, typeNames);
          var exactTypes = typeNames.map(function (typeName) {
            var type = findTypeByName(typeName);
            return {
              name: typeName,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion: null,
              conversionIndex: -1
            };
          });
          var convertibleTypes = matchingConversions.map(function (conversion) {
            var type = findTypeByName(conversion.from);
            return {
              name: conversion.from,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion: conversion,
              conversionIndex: conversions.indexOf(conversion)
            };
          });
          return {
            types: exactTypes.concat(convertibleTypes),
            restParam: restParam
          };
        }

        /**
         * Parse a signature with comma separated parameters,
         * like "number | boolean, ...string"
         * @param {string} signature
         * @param {function} fn
         * @param {ConversionDef[]} conversions
         * @return {Signature | null} signature
         */
        function parseSignature(signature, fn, conversions) {
          var params = [];
          if (signature.trim() !== '') {
            params = signature.split(',').map(trim).map(function (param, index, array) {
              var parsedParam = parseParam(param, conversions);
              if (parsedParam.restParam && index !== array.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + param + '": ' + 'only allowed for the last parameter');
              }
              return parsedParam;
            });
          }
          if (params.some(isInvalidParam)) {
            // invalid signature: at least one parameter has no types
            // (they may have been filtered)
            return null;
          }
          return {
            params: params,
            fn: fn
          };
        }

        /**
         * Test whether a set of params contains a restParam
         * @param {Param[]} params
         * @return {boolean} Returns true when the last parameter is a restParam
         */
        function hasRestParam(params) {
          var param = last(params);
          return param ? param.restParam : false;
        }

        /**
         * Test whether a parameter contains conversions
         * @param {Param} param
         * @return {boolean} Returns true when at least one of the parameters
         *                   contains a conversion.
         */
        function hasConversions(param) {
          return param.types.some(function (type) {
            return type.conversion != null;
          });
        }

        /**
         * Create a type test for a single parameter, which can have one or multiple
         * types.
         * @param {Param} param
         * @return {function(x: *) : boolean} Returns a test function
         */
        function compileTest(param) {
          if (!param || param.types.length === 0) {
            // nothing to do
            return ok;
          } else if (param.types.length === 1) {
            return findTypeByName(param.types[0].name).test;
          } else if (param.types.length === 2) {
            var test0 = findTypeByName(param.types[0].name).test;
            var test1 = findTypeByName(param.types[1].name).test;
            return function or(x) {
              return test0(x) || test1(x);
            };
          } else {
            // param.types.length > 2
            var tests = param.types.map(function (type) {
              return findTypeByName(type.name).test;
            });
            return function or(x) {
              for (var i = 0; i < tests.length; i++) {
                if (tests[i](x)) {
                  return true;
                }
              }
              return false;
            };
          }
        }

        /**
         * Create a test for all parameters of a signature
         * @param {Param[]} params
         * @return {function(args: Array<*>) : boolean}
         */
        function compileTests(params) {
          var tests, test0, test1;
          if (hasRestParam(params)) {
            // variable arguments like '...number'
            tests = initial(params).map(compileTest);
            var varIndex = tests.length;
            var lastTest = compileTest(last(params));
            var testRestParam = function (args) {
              for (var i = varIndex; i < args.length; i++) {
                if (!lastTest(args[i])) {
                  return false;
                }
              }
              return true;
            };
            return function testArgs(args) {
              for (var i = 0; i < tests.length; i++) {
                if (!tests[i](args[i])) {
                  return false;
                }
              }
              return testRestParam(args) && args.length >= varIndex + 1;
            };
          } else {
            // no variable arguments
            if (params.length === 0) {
              return function testArgs(args) {
                return args.length === 0;
              };
            } else if (params.length === 1) {
              test0 = compileTest(params[0]);
              return function testArgs(args) {
                return test0(args[0]) && args.length === 1;
              };
            } else if (params.length === 2) {
              test0 = compileTest(params[0]);
              test1 = compileTest(params[1]);
              return function testArgs(args) {
                return test0(args[0]) && test1(args[1]) && args.length === 2;
              };
            } else {
              // arguments.length > 2
              tests = params.map(compileTest);
              return function testArgs(args) {
                for (var i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return args.length === tests.length;
              };
            }
          }
        }

        /**
         * Find the parameter at a specific index of a signature.
         * Handles rest parameters.
         * @param {Signature} signature
         * @param {number} index
         * @return {Param | null} Returns the matching parameter when found,
         *                        null otherwise.
         */
        function getParamAtIndex(signature, index) {
          return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
        }

        /**
         * Get all type names of a parameter
         * @param {Signature} signature
         * @param {number} index
         * @param {boolean} excludeConversions
         * @return {string[]} Returns an array with type names
         */
        function getExpectedTypeNames(signature, index, excludeConversions) {
          var param = getParamAtIndex(signature, index);
          var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
          return types.map(getTypeName);
        }

        /**
         * Returns the name of a type
         * @param {Type} type
         * @return {string} Returns the type name
         */
        function getTypeName(type) {
          return type.name;
        }

        /**
         * Test whether a type is an exact type or conversion
         * @param {Type} type
         * @return {boolean} Returns true when
         */
        function isExactType(type) {
          return type.conversion === null || type.conversion === undefined;
        }

        /**
         * Helper function for creating error messages: create an array with
         * all available types on a specific argument index.
         * @param {Signature[]} signatures
         * @param {number} index
         * @return {string[]} Returns an array with available types
         */
        function mergeExpectedParams(signatures, index) {
          var typeNames = uniq(flatMap(signatures, function (signature) {
            return getExpectedTypeNames(signature, index, false);
          }));
          return typeNames.indexOf('any') !== -1 ? ['any'] : typeNames;
        }

        /**
         * Create
         * @param {string} name             The name of the function
         * @param {array.<*>} args          The actual arguments passed to the function
         * @param {Signature[]} signatures  A list with available signatures
         * @return {TypeError} Returns a type error with additional data
         *                     attached to it in the property `data`
         */
        function createError(name, args, signatures) {
          var err, expected;
          var _name = name || 'unnamed';

          // test for wrong type at some index
          var matchingSignatures = signatures;
          var index;
          for (index = 0; index < args.length; index++) {
            var nextMatchingDefs = matchingSignatures.filter(function (signature) {
              var test = compileTest(getParamAtIndex(signature, index));
              return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
            });
            if (nextMatchingDefs.length === 0) {
              // no matching signatures anymore, throw error "wrong type"
              expected = mergeExpectedParams(matchingSignatures, index);
              if (expected.length > 0) {
                var actualType = findTypeName(args[index]);
                err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')');
                err.data = {
                  category: 'wrongType',
                  fn: _name,
                  index: index,
                  actual: actualType,
                  expected: expected
                };
                return err;
              }
            } else {
              matchingSignatures = nextMatchingDefs;
            }
          }

          // test for too few arguments
          var lengths = matchingSignatures.map(function (signature) {
            return hasRestParam(signature.params) ? Infinity : signature.params.length;
          });
          if (args.length < Math.min.apply(null, lengths)) {
            expected = mergeExpectedParams(matchingSignatures, index);
            err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');
            err.data = {
              category: 'tooFewArgs',
              fn: _name,
              index: args.length,
              expected: expected
            };
            return err;
          }

          // test for too many arguments
          var maxLength = Math.max.apply(null, lengths);
          if (args.length > maxLength) {
            err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');
            err.data = {
              category: 'tooManyArgs',
              fn: _name,
              index: args.length,
              expectedLength: maxLength
            };
            return err;
          }
          err = new TypeError('Arguments of type "' + args.join(', ') + '" do not match any of the defined signatures of function ' + _name + '.');
          err.data = {
            category: 'mismatch',
            actual: args.map(findTypeName)
          };
          return err;
        }

        /**
         * Find the lowest index of all exact types of a parameter (no conversions)
         * @param {Param} param
         * @return {number} Returns the index of the lowest type in typed.types
         */
        function getLowestTypeIndex(param) {
          var min = 999;
          for (var i = 0; i < param.types.length; i++) {
            if (isExactType(param.types[i])) {
              min = Math.min(min, param.types[i].typeIndex);
            }
          }
          return min;
        }

        /**
         * Find the lowest index of the conversion of all types of the parameter
         * having a conversion
         * @param {Param} param
         * @return {number} Returns the lowest index of the conversions of this type
         */
        function getLowestConversionIndex(param) {
          var min = 999;
          for (var i = 0; i < param.types.length; i++) {
            if (!isExactType(param.types[i])) {
              min = Math.min(min, param.types[i].conversionIndex);
            }
          }
          return min;
        }

        /**
         * Compare two params
         * @param {Param} param1
         * @param {Param} param2
         * @return {number} returns a negative number when param1 must get a lower
         *                  index than param2, a positive number when the opposite,
         *                  or zero when both are equal
         */
        function compareParams(param1, param2) {
          var c;

          // compare having a rest parameter or not
          c = param1.restParam - param2.restParam;
          if (c !== 0) {
            return c;
          }

          // compare having conversions or not
          c = hasConversions(param1) - hasConversions(param2);
          if (c !== 0) {
            return c;
          }

          // compare the index of the types
          c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
          if (c !== 0) {
            return c;
          }

          // compare the index of any conversion
          return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        }

        /**
         * Compare two signatures
         * @param {Signature} signature1
         * @param {Signature} signature2
         * @return {number} returns a negative number when param1 must get a lower
         *                  index than param2, a positive number when the opposite,
         *                  or zero when both are equal
         */
        function compareSignatures(signature1, signature2) {
          var len = Math.min(signature1.params.length, signature2.params.length);
          var i;
          var c;

          // compare whether the params have conversions at all or not
          c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
          if (c !== 0) {
            return c;
          }

          // next compare whether the params have conversions one by one
          for (i = 0; i < len; i++) {
            c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
            if (c !== 0) {
              return c;
            }
          }

          // compare the types of the params one by one
          for (i = 0; i < len; i++) {
            c = compareParams(signature1.params[i], signature2.params[i]);
            if (c !== 0) {
              return c;
            }
          }

          // compare the number of params
          return signature1.params.length - signature2.params.length;
        }

        /**
         * Get params containing all types that can be converted to the defined types.
         *
         * @param {ConversionDef[]} conversions
         * @param {string[]} typeNames
         * @return {ConversionDef[]} Returns the conversions that are available
         *                        for every type (if any)
         */
        function filterConversions(conversions, typeNames) {
          var matches = {};
          conversions.forEach(function (conversion) {
            if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
              matches[conversion.from] = conversion;
            }
          });
          return Object.keys(matches).map(function (from) {
            return matches[from];
          });
        }

        /**
         * Preprocess arguments before calling the original function:
         * - if needed convert the parameters
         * - in case of rest parameters, move the rest parameters into an Array
         * @param {Param[]} params
         * @param {function} fn
         * @return {function} Returns a wrapped function
         */
        function compileArgsPreprocessing(params, fn) {
          var fnConvert = fn;

          // TODO: can we make this wrapper function smarter/simpler?

          if (params.some(hasConversions)) {
            var restParam = hasRestParam(params);
            var compiledConversions = params.map(compileArgConversion);
            fnConvert = function convertArgs() {
              var args = [];
              var last = restParam ? arguments.length - 1 : arguments.length;
              for (var i = 0; i < last; i++) {
                args[i] = compiledConversions[i](arguments[i]);
              }
              if (restParam) {
                args[last] = arguments[last].map(compiledConversions[last]);
              }
              return fn.apply(this, args);
            };
          }
          var fnPreprocess = fnConvert;
          if (hasRestParam(params)) {
            var offset = params.length - 1;
            fnPreprocess = function preprocessRestParams() {
              return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
            };
          }
          return fnPreprocess;
        }

        /**
         * Compile conversion for a parameter to the right type
         * @param {Param} param
         * @return {function} Returns the wrapped function that will convert arguments
         *
         */
        function compileArgConversion(param) {
          var test0, test1, conversion0, conversion1;
          var tests = [];
          var conversions = [];
          param.types.forEach(function (type) {
            if (type.conversion) {
              tests.push(findTypeByName(type.conversion.from).test);
              conversions.push(type.conversion.convert);
            }
          });

          // create optimized conversion functions depending on the number of conversions
          switch (conversions.length) {
            case 0:
              return function convertArg(arg) {
                return arg;
              };
            case 1:
              test0 = tests[0];
              conversion0 = conversions[0];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg);
                }
                return arg;
              };
            case 2:
              test0 = tests[0];
              test1 = tests[1];
              conversion0 = conversions[0];
              conversion1 = conversions[1];
              return function convertArg(arg) {
                if (test0(arg)) {
                  return conversion0(arg);
                }
                if (test1(arg)) {
                  return conversion1(arg);
                }
                return arg;
              };
            default:
              return function convertArg(arg) {
                for (var i = 0; i < conversions.length; i++) {
                  if (tests[i](arg)) {
                    return conversions[i](arg);
                  }
                }
                return arg;
              };
          }
        }

        /**
         * Convert an array with signatures into a map with signatures,
         * where signatures with union types are split into separate signatures
         *
         * Throws an error when there are conflicting types
         *
         * @param {Signature[]} signatures
         * @return {Object.<string, function>}  Returns a map with signatures
         *                                      as key and the original function
         *                                      of this signature as value.
         */
        function createSignaturesMap(signatures) {
          var signaturesMap = {};
          signatures.forEach(function (signature) {
            if (!signature.params.some(hasConversions)) {
              splitParams(signature.params, true).forEach(function (params) {
                signaturesMap[stringifyParams(params)] = signature.fn;
              });
            }
          });
          return signaturesMap;
        }

        /**
         * Split params with union types in to separate params.
         *
         * For example:
         *
         *     splitParams([['Array', 'Object'], ['string', 'RegExp'])
         *     // returns:
         *     // [
         *     //   ['Array', 'string'],
         *     //   ['Array', 'RegExp'],
         *     //   ['Object', 'string'],
         *     //   ['Object', 'RegExp']
         *     // ]
         *
         * @param {Param[]} params
         * @param {boolean} ignoreConversionTypes
         * @return {Param[]}
         */
        function splitParams(params, ignoreConversionTypes) {
          function _splitParams(params, index, types) {
            if (index < params.length) {
              var param = params[index];
              var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
              var typeGroups;
              if (param.restParam) {
                // split the types of a rest parameter in two:
                // one with only exact types, and one with exact types and conversions
                var exactTypes = filteredTypes.filter(isExactType);
                typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
              } else {
                // split all the types of a regular parameter into one type per group
                typeGroups = filteredTypes.map(function (type) {
                  return [type];
                });
              }

              // recurse over the groups with types
              return flatMap(typeGroups, function (typeGroup) {
                return _splitParams(params, index + 1, types.concat([typeGroup]));
              });
            } else {
              // we've reached the end of the parameters. Now build a new Param
              var splittedParams = types.map(function (type, typeIndex) {
                return {
                  types: type,
                  restParam: typeIndex === params.length - 1 && hasRestParam(params)
                };
              });
              return [splittedParams];
            }
          }
          return _splitParams(params, 0, []);
        }

        /**
         * Test whether two signatures have a conflicting signature
         * @param {Signature} signature1
         * @param {Signature} signature2
         * @return {boolean} Returns true when the signatures conflict, false otherwise.
         */
        function hasConflictingParams(signature1, signature2) {
          var ii = Math.max(signature1.params.length, signature2.params.length);
          for (var i = 0; i < ii; i++) {
            var typesNames1 = getExpectedTypeNames(signature1, i, true);
            var typesNames2 = getExpectedTypeNames(signature2, i, true);
            if (!hasOverlap(typesNames1, typesNames2)) {
              return false;
            }
          }
          var len1 = signature1.params.length;
          var len2 = signature2.params.length;
          var restParam1 = hasRestParam(signature1.params);
          var restParam2 = hasRestParam(signature2.params);
          return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
        }

        /**
         * Create a typed function
         * @param {String} name               The name for the typed function
         * @param {Object.<string, function>} signaturesMap
         *                                    An object with one or
         *                                    multiple signatures as key, and the
         *                                    function corresponding to the
         *                                    signature as value.
         * @return {function}  Returns the created typed function.
         */
        function createTypedFunction(name, signaturesMap) {
          if (Object.keys(signaturesMap).length === 0) {
            throw new SyntaxError('No signatures provided');
          }

          // parse the signatures, and check for conflicts
          var parsedSignatures = [];
          Object.keys(signaturesMap).map(function (signature) {
            return parseSignature(signature, signaturesMap[signature], typed.conversions);
          }).filter(notNull).forEach(function (parsedSignature) {
            // check whether this parameter conflicts with already parsed signatures
            var conflictingSignature = findInArray(parsedSignatures, function (s) {
              return hasConflictingParams(s, parsedSignature);
            });
            if (conflictingSignature) {
              throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
            }
            parsedSignatures.push(parsedSignature);
          });

          // split and filter the types of the signatures, and then order them
          var signatures = flatMap(parsedSignatures, function (parsedSignature) {
            var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
            return params.map(function (params) {
              return {
                params: params,
                fn: parsedSignature.fn
              };
            });
          }).filter(notNull);
          signatures.sort(compareSignatures);

          // we create a highly optimized checks for the first couple of signatures with max 2 arguments
          var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
          var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
          var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
          var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
          var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
          var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
          var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;

          // compile the tests
          var tests = signatures.map(function (signature) {
            return compileTests(signature.params);
          });
          var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
          var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
          var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
          var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
          var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
          var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
          var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
          var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
          var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
          var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
          var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
          var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;

          // compile the functions
          var fns = signatures.map(function (signature) {
            return compileArgsPreprocessing(signature.params, signature.fn);
          });
          var fn0 = ok0 ? fns[0] : undef;
          var fn1 = ok1 ? fns[1] : undef;
          var fn2 = ok2 ? fns[2] : undef;
          var fn3 = ok3 ? fns[3] : undef;
          var fn4 = ok4 ? fns[4] : undef;
          var fn5 = ok5 ? fns[5] : undef;
          var len0 = ok0 ? signatures[0].params.length : -1;
          var len1 = ok1 ? signatures[1].params.length : -1;
          var len2 = ok2 ? signatures[2].params.length : -1;
          var len3 = ok3 ? signatures[3].params.length : -1;
          var len4 = ok4 ? signatures[4].params.length : -1;
          var len5 = ok5 ? signatures[5].params.length : -1;

          // simple and generic, but also slow
          var iStart = allOk ? 6 : 0;
          var iEnd = signatures.length;
          var generic = function generic() {

            for (var i = iStart; i < iEnd; i++) {
              if (tests[i](arguments)) {
                return fns[i].apply(this, arguments);
              }
            }
            return typed.onMismatch(name, arguments, signatures);
          };

          // create the typed function
          // fast, specialized version. Falls back to the slower, generic one if needed
          var fn = function fn(arg0, arg1) {

            if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
              return fn0.apply(fn, arguments);
            }
            if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
              return fn1.apply(fn, arguments);
            }
            if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
              return fn2.apply(fn, arguments);
            }
            if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
              return fn3.apply(fn, arguments);
            }
            if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
              return fn4.apply(fn, arguments);
            }
            if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
              return fn5.apply(fn, arguments);
            }
            return generic.apply(fn, arguments);
          };

          // attach name the typed function
          try {
            Object.defineProperty(fn, 'name', {
              value: name
            });
          } catch (err) {
            // old browsers do not support Object.defineProperty and some don't support setting the name property
            // the function name is not essential for the functioning, it's mostly useful for debugging,
            // so it's fine to have unnamed functions.
          }

          // attach signatures to the function
          fn.signatures = createSignaturesMap(signatures);
          return fn;
        }

        /**
         * Action to take on mismatch
         * @param {string} name      Name of function that was attempted to be called
         * @param {Array} args       Actual arguments to the call
         * @param {Array} signatures Known signatures of the named typed-function
         */
        function _onMismatch(name, args, signatures) {
          throw createError(name, args, signatures);
        }

        /**
         * Test whether a type should be NOT be ignored
         * @param {string} typeName
         * @return {boolean}
         */
        function notIgnore(typeName) {
          return typed.ignore.indexOf(typeName) === -1;
        }

        /**
         * trim a string
         * @param {string} str
         * @return {string}
         */
        function trim(str) {
          return str.trim();
        }

        /**
         * Test whether a string is not empty
         * @param {string} str
         * @return {boolean}
         */
        function notEmpty(str) {
          return !!str;
        }

        /**
         * test whether a value is not strict equal to null
         * @param {*} value
         * @return {boolean}
         */
        function notNull(value) {
          return value !== null;
        }

        /**
         * Test whether a parameter has no types defined
         * @param {Param} param
         * @return {boolean}
         */
        function isInvalidParam(param) {
          return param.types.length === 0;
        }

        /**
         * Return all but the last items of an array
         * @param {Array} arr
         * @return {Array}
         */
        function initial(arr) {
          return arr.slice(0, arr.length - 1);
        }

        /**
         * return the last item of an array
         * @param {Array} arr
         * @return {*}
         */
        function last(arr) {
          return arr[arr.length - 1];
        }

        /**
         * Slice an array or function Arguments
         * @param {Array | Arguments | IArguments} arr
         * @param {number} start
         * @param {number} [end]
         * @return {Array}
         */
        function slice(arr, start, end) {
          return Array.prototype.slice.call(arr, start, end);
        }

        /**
         * Test whether an array contains some item
         * @param {Array} array
         * @param {*} item
         * @return {boolean} Returns true if array contains item, false if not.
         */
        function contains(array, item) {
          return array.indexOf(item) !== -1;
        }

        /**
         * Test whether two arrays have overlapping items
         * @param {Array} array1
         * @param {Array} array2
         * @return {boolean} Returns true when at least one item exists in both arrays
         */
        function hasOverlap(array1, array2) {
          for (var i = 0; i < array1.length; i++) {
            if (contains(array2, array1[i])) {
              return true;
            }
          }
          return false;
        }

        /**
         * Return the first item from an array for which test(arr[i]) returns true
         * @param {Array} arr
         * @param {function} test
         * @return {* | undefined} Returns the first matching item
         *                         or undefined when there is no match
         */
        function findInArray(arr, test) {
          for (var i = 0; i < arr.length; i++) {
            if (test(arr[i])) {
              return arr[i];
            }
          }
          return undefined;
        }

        /**
         * Filter unique items of an array with strings
         * @param {string[]} arr
         * @return {string[]}
         */
        function uniq(arr) {
          var entries = {};
          for (var i = 0; i < arr.length; i++) {
            entries[arr[i]] = true;
          }
          return Object.keys(entries);
        }

        /**
         * Flat map the result invoking a callback for every item in an array.
         * https://gist.github.com/samgiles/762ee337dff48623e729
         * @param {Array} arr
         * @param {function} callback
         * @return {Array}
         */
        function flatMap(arr, callback) {
          return Array.prototype.concat.apply([], arr.map(callback));
        }

        /**
         * Retrieve the function name from a set of typed functions,
         * and check whether the name of all functions match (if given)
         * @param {function[]} fns
         */
        function getName(fns) {
          var name = '';
          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];

            // check whether the names are the same when defined
            if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {
              if (name === '') {
                name = fn.name;
              } else if (name !== fn.name) {
                var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
                err.data = {
                  actual: fn.name,
                  expected: name
                };
                throw err;
              }
            }
          }
          return name;
        }

        // extract and merge all signatures of a list with typed functions
        function extractSignatures(fns) {
          var err;
          var signaturesMap = {};
          function validateUnique(_signature, _fn) {
            if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
              err = new Error('Signature "' + _signature + '" is defined twice');
              err.data = {
                signature: _signature
              };
              throw err;
              // else: both signatures point to the same function, that's fine
            }
          }

          for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];

            // test whether this is a typed-function
            if (typeof fn.signatures === 'object') {
              // merge the signatures
              for (var signature in fn.signatures) {
                if (fn.signatures.hasOwnProperty(signature)) {
                  validateUnique(signature, fn.signatures[signature]);
                  signaturesMap[signature] = fn.signatures[signature];
                }
              }
            } else if (typeof fn.signature === 'string') {
              validateUnique(fn.signature, fn);
              signaturesMap[fn.signature] = fn;
            } else {
              err = new TypeError('Function is no typed-function (index: ' + i + ')');
              err.data = {
                index: i
              };
              throw err;
            }
          }
          return signaturesMap;
        }
        typed = createTypedFunction('typed', {
          'string, Object': createTypedFunction,
          'Object': function (signaturesMap) {
            // find existing name
            var fns = [];
            for (var signature in signaturesMap) {
              if (signaturesMap.hasOwnProperty(signature)) {
                fns.push(signaturesMap[signature]);
              }
            }
            var name = getName(fns);
            return createTypedFunction(name, signaturesMap);
          },
          '...Function': function (fns) {
            return createTypedFunction(getName(fns), extractSignatures(fns));
          },
          'string, ...Function': function (name, fns) {
            return createTypedFunction(name, extractSignatures(fns));
          }
        });
        typed.create = create;
        typed.types = _types;
        typed.conversions = _conversions;
        typed.ignore = _ignore;
        typed.onMismatch = _onMismatch;
        typed.throwMismatchError = _onMismatch;
        typed.createError = createError;
        typed.convert = convert;
        typed.find = find;

        /**
         * add a type
         * @param {{name: string, test: function}} type
         * @param {boolean} [beforeObjectTest=true]
         *                          If true, the new test will be inserted before
         *                          the test with name 'Object' (if any), since
         *                          tests for Object match Array and classes too.
         */
        typed.addType = function (type, beforeObjectTest) {
          if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
            throw new TypeError('Object with properties {name: string, test: function} expected');
          }
          if (beforeObjectTest !== false) {
            for (var i = 0; i < typed.types.length; i++) {
              if (typed.types[i].name === 'Object') {
                typed.types.splice(i, 0, type);
                return;
              }
            }
          }
          typed.types.push(type);
        };

        // add a conversion
        typed.addConversion = function (conversion) {
          if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {
            throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
          }
          typed.conversions.push(conversion);
        };
        return typed;
      }
      return create();
    });
  });

  /**
   * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue
   */

  /**
   * Check if a number is integer
   * @param {number | boolean} value
   * @return {boolean} isInteger
   */

  function isInteger(value) {
    if (typeof value === 'boolean') {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  /**
   * Calculate the sign of a number
   * @param {number} x
   * @returns {number}
   */

  var sign$2 = Math.sign || function (x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  /**
   * Formats a number in a given base
   * @param {number} n
   * @param {number} base
   * @param {number} size
   * @returns {string}
   */

  function formatNumberToBase(n, base, size) {
    var prefixes = {
      2: '0b',
      8: '0o',
      16: '0x'
    };
    var prefix = prefixes[base];
    var suffix = '';
    if (size) {
      if (size < 1) {
        throw new Error('size must be in greater than 0');
      }
      if (!isInteger(size)) {
        throw new Error('size must be an integer');
      }
      if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
        throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
      }
      if (!isInteger(n)) {
        throw new Error('Value must be an integer');
      }
      if (n < 0) {
        n = n + 2 ** size;
      }
      suffix = "i".concat(size);
    }
    var sign = '';
    if (n < 0) {
      n = -n;
      sign = '-';
    }
    return "".concat(sign).concat(prefix).concat(n.toString(base)).concat(suffix);
  }
  /**
   * Convert a number to a formatted string representation.
   *
   * Syntax:
   *
   *    format(value)
   *    format(value, options)
   *    format(value, precision)
   *    format(value, fn)
   *
   * Where:
   *
   *    {number} value   The value to be formatted
   *    {Object} options An object with formatting options. Available options:
   *                     {string} notation
   *                         Number notation. Choose from:
   *                         'fixed'          Always use regular number notation.
   *                                          For example '123.40' and '14000000'
   *                         'exponential'    Always use exponential notation.
   *                                          For example '1.234e+2' and '1.4e+7'
   *                         'engineering'    Always use engineering notation.
   *                                          For example '123.4e+0' and '14.0e+6'
   *                         'auto' (default) Regular number notation for numbers
   *                                          having an absolute value between
   *                                          `lowerExp` and `upperExp` bounds, and
   *                                          uses exponential notation elsewhere.
   *                                          Lower bound is included, upper bound
   *                                          is excluded.
   *                                          For example '123.4' and '1.4e7'.
   *                         'bin', 'oct, or
   *                         'hex'            Format the number using binary, octal,
   *                                          or hexadecimal notation.
   *                                          For example '0b1101' and '0x10fe'.
   *                     {number} wordSize    The word size in bits to use for formatting
   *                                          in binary, octal, or hexadecimal notation.
   *                                          To be used only with 'bin', 'oct', or 'hex'
   *                                          values for 'notation' option. When this option
   *                                          is defined the value is formatted as a signed
   *                                          twos complement integer of the given word size
   *                                          and the size suffix is appended to the output.
   *                                          For example
   *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
   *                                          Default value is undefined.
   *                     {number} precision   A number between 0 and 16 to round
   *                                          the digits of the number.
   *                                          In case of notations 'exponential',
   *                                          'engineering', and 'auto',
   *                                          `precision` defines the total
   *                                          number of significant digits returned.
   *                                          In case of notation 'fixed',
   *                                          `precision` defines the number of
   *                                          significant digits after the decimal
   *                                          point.
   *                                          `precision` is undefined by default,
   *                                          not rounding any digits.
   *                     {number} lowerExp    Exponent determining the lower boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `-3`.
   *                     {number} upperExp    Exponent determining the upper boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `5`.
   *    {Function} fn    A custom formatting function. Can be used to override the
   *                     built-in notations. Function `fn` is called with `value` as
   *                     parameter and must return a string. Is useful for example to
   *                     format all values inside a matrix in a particular way.
   *
   * Examples:
   *
   *    format(6.4)                                        // '6.4'
   *    format(1240000)                                    // '1.24e6'
   *    format(1/3)                                        // '0.3333333333333333'
   *    format(1/3, 3)                                     // '0.333'
   *    format(21385, 2)                                   // '21000'
   *    format(12.071, {notation: 'fixed'})                // '12'
   *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'
   *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'
   *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'
   *
   * @param {number} value
   * @param {Object | Function | number} [options]
   * @return {string} str The formatted value
   */

  function format$2(value, options) {
    if (typeof options === 'function') {
      // handle format(value, fn)
      return options(value);
    } // handle special cases

    if (value === Infinity) {
      return 'Infinity';
    } else if (value === -Infinity) {
      return '-Infinity';
    } else if (isNaN(value)) {
      return 'NaN';
    } // default values for options

    var notation = 'auto';
    var precision;
    var wordSize;
    if (options) {
      // determine notation from options
      if (options.notation) {
        notation = options.notation;
      } // determine precision from options

      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== 'number') {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    } // handle the various notations

    switch (notation) {
      case 'fixed':
        return toFixed$1(value, precision);
      case 'exponential':
        return toExponential$1(value, precision);
      case 'engineering':
        return toEngineering$1(value, precision);
      case 'bin':
        return formatNumberToBase(value, 2, wordSize);
      case 'oct':
        return formatNumberToBase(value, 8, wordSize);
      case 'hex':
        return formatNumberToBase(value, 16, wordSize);
      case 'auto':
        // remove trailing zeros after the decimal point
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function () {
          var digits = arguments[2];
          var e = arguments[4];
          return digits !== '.' ? digits + e : e;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  /**
   * Split a number into sign, coefficients, and exponent
   * @param {number | string} value
   * @return {SplitValue}
   *              Returns an object containing sign, coefficients, and exponent
   */

  function splitNumber(value) {
    // parse the input value
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError('Invalid number ' + value);
    }
    var sign = match[1];
    var digits = match[2];
    var exponent = parseFloat(match[4] || '0');
    var dot = digits.indexOf('.');
    exponent += dot !== -1 ? dot - 1 : digits.length - 1;
    var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)
    .replace(/^0*/, function (zeros) {
      // remove leading zeros, add their count to the exponent
      exponent -= zeros.length;
      return '';
    }).replace(/0*$/, '') // remove trailing zeros
    .split('').map(function (d) {
      return parseInt(d);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign,
      coefficients,
      exponent
    };
  }
  /**
   * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
   * @param {number | string} value
   * @param {number} [precision]        Optional number of significant figures to return.
   */

  function toEngineering$1(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e = rounded.exponent;
    var c = rounded.coefficients; // find nearest lower multiple of 3 for exponent

    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    if (isNumber(precision)) {
      // add zeroes to give correct sig figs
      while (precision > c.length || e - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      // concatenate coefficients with necessary zeros
      // add zeros if necessary (for example: 1e+8 -> 100e+6)
      var missingZeros = Math.abs(e - newExp) - (c.length - 1);
      for (var i = 0; i < missingZeros; i++) {
        c.push(0);
      }
    } // find difference in exponents

    var expDiff = Math.abs(e - newExp);
    var decimalIdx = 1; // push decimal index over by expDiff times

    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    } // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
    // otherwise concat with the rest of the coefficients

    var decimals = c.slice(decimalIdx).join('');
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';
    var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
    return rounded.sign + str;
  }
  /**
   * Format a number with fixed notation.
   * @param {number | string} value
   * @param {number} [precision=undefined]  Optional number of decimals after the
   *                                        decimal point. null by default.
   */

  function toFixed$1(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1; // exponent may have changed
    // append zeros if needed

    var pp = p + (precision || 0);
    if (c.length < pp) {
      c = c.concat(zeros$1(pp - c.length));
    } // prepend zeros if needed

    if (p < 0) {
      c = zeros$1(-p + 1).concat(c);
      p = 1;
    } // insert a dot if needed

    if (p < c.length) {
      c.splice(p, 0, p === 0 ? '0.' : '.');
    }
    return rounded.sign + c.join('');
  }
  /**
   * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
   * @param {number | string} value
   * @param {number} [precision]  Number of digits in formatted output.
   *                              If not provided, the maximum available digits
   *                              is used.
   */

  function toExponential$1(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    } // round if needed, else create a clone

    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e = rounded.exponent; // append zeros if needed

    if (c.length < precision) {
      c = c.concat(zeros$1(precision - c.length));
    } // format as `C.CCCe+EEE` or `C.CCCe-EEE`

    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;
  }
  /**
   * Format a number with a certain precision
   * @param {number | string} value
   * @param {number} [precision=undefined] Optional number of digits.
   * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]
   *                                       By default:
   *                                         lowerExp = -3 (incl)
   *                                         upper = +5 (excl)
   * @return {string}
   */

  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    } // determine lower and upper bound for exponential notation.

    var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      // exponential notation
      return toExponential$1(value, precision);
    } else {
      var c = rounded.coefficients;
      var e = rounded.exponent; // append trailing zeros

      if (c.length < precision) {
        c = c.concat(zeros$1(precision - c.length));
      } // append trailing zeros
      // TODO: simplify the next statement

      c = c.concat(zeros$1(e - c.length + 1 + (c.length < precision ? precision - c.length : 0))); // prepend zeros

      c = zeros$1(-e).concat(c);
      var dot = e > 0 ? e : 0;
      if (dot < c.length - 1) {
        c.splice(dot + 1, 0, '.');
      }
      return rounded.sign + c.join('');
    }
  }
  /**
   * Round the number of digits of a number *
   * @param {SplitValue} split       A value split with .splitNumber(value)
   * @param {number} precision  A positive integer
   * @return {SplitValue}
   *              Returns an object containing sign, coefficients, and exponent
   *              with rounded digits
   */

  function roundDigits(split, precision) {
    // create a clone
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients; // prepend zeros if needed

    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        var i = precision - 1;
        c[i]++;
        while (c[i] === 10) {
          c.pop();
          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }
          i--;
          c[i]++;
        }
      }
    }
    return rounded;
  }
  /**
   * Create an array filled with zeros.
   * @param {number} length
   * @return {Array}
   */

  function zeros$1(length) {
    var arr = [];
    for (var i = 0; i < length; i++) {
      arr.push(0);
    }
    return arr;
  }
  /**
   * Count the number of significant digits of a number.
   *
   * For example:
   *   2.34 returns 3
   *   0.0034 returns 2
   *   120.5e+30 returns 4
   *
   * @param {number} value
   * @return {number} digits   Number of significant digits
   */

  function digits(value) {
    return value.toExponential().replace(/e.*$/, '') // remove exponential notation
    .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
    .length;
  }
  /**
   * Minimum number added to one that makes the result different than one
   */

  var DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;
  /**
   * Compares two floating point numbers.
   * @param {number} x          First value to compare
   * @param {number} y          Second value to compare
   * @param {number} [epsilon]  The maximum relative difference between x and y
   *                            If epsilon is undefined or null, the function will
   *                            test whether x and y are exactly equal.
   * @return {boolean} whether the two numbers are nearly equal
  */

  function nearlyEqual$1(x, y, epsilon) {
    // if epsilon is null or undefined, test whether x and y are exactly equal
    if (epsilon === null || epsilon === undefined) {
      return x === y;
    }
    if (x === y) {
      return true;
    } // NaN

    if (isNaN(x) || isNaN(y)) {
      return false;
    } // at this point x and y should be finite

    if (isFinite(x) && isFinite(y)) {
      // check numbers are very close, needed when comparing numbers near zero
      var diff = Math.abs(x - y);
      if (diff < DBL_EPSILON) {
        return true;
      } else {
        // use relative error
        return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
      }
    } // Infinite and Number or negative Infinite and positive Infinite cases

    return false;
  }

  /**
   * Formats a BigNumber in a given base
   * @param {BigNumber} n
   * @param {number} base
   * @param {number} size
   * @returns {string}
   */

  function formatBigNumberToBase(n, base, size) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = '';
    if (size) {
      if (size < 1) {
        throw new Error('size must be in greater than 0');
      }
      if (!isInteger(size)) {
        throw new Error('size must be an integer');
      }
      if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
      }
      if (!n.isInteger()) {
        throw new Error('Value must be an integer');
      }
      if (n.lessThan(0)) {
        n = n.add(big2.pow(size));
      }
      suffix = "i".concat(size);
    }
    switch (base) {
      case 2:
        return "".concat(n.toBinary()).concat(suffix);
      case 8:
        return "".concat(n.toOctal()).concat(suffix);
      case 16:
        return "".concat(n.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  /**
   * Convert a BigNumber to a formatted string representation.
   *
   * Syntax:
   *
   *    format(value)
   *    format(value, options)
   *    format(value, precision)
   *    format(value, fn)
   *
   * Where:
   *
   *    {number} value   The value to be formatted
   *    {Object} options An object with formatting options. Available options:
   *                     {string} notation
   *                         Number notation. Choose from:
   *                         'fixed'          Always use regular number notation.
   *                                          For example '123.40' and '14000000'
   *                         'exponential'    Always use exponential notation.
   *                                          For example '1.234e+2' and '1.4e+7'
   *                         'auto' (default) Regular number notation for numbers
   *                                          having an absolute value between
   *                                          `lower` and `upper` bounds, and uses
   *                                          exponential notation elsewhere.
   *                                          Lower bound is included, upper bound
   *                                          is excluded.
   *                                          For example '123.4' and '1.4e7'.
   *                         'bin', 'oct, or
   *                         'hex'            Format the number using binary, octal,
   *                                          or hexadecimal notation.
   *                                          For example '0b1101' and '0x10fe'.
   *                     {number} wordSize    The word size in bits to use for formatting
   *                                          in binary, octal, or hexadecimal notation.
   *                                          To be used only with 'bin', 'oct', or 'hex'
   *                                          values for 'notation' option. When this option
   *                                          is defined the value is formatted as a signed
   *                                          twos complement integer of the given word size
   *                                          and the size suffix is appended to the output.
   *                                          For example
   *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
   *                                          Default value is undefined.
   *                     {number} precision   A number between 0 and 16 to round
   *                                          the digits of the number.
   *                                          In case of notations 'exponential',
   *                                          'engineering', and 'auto',
   *                                          `precision` defines the total
   *                                          number of significant digits returned.
   *                                          In case of notation 'fixed',
   *                                          `precision` defines the number of
   *                                          significant digits after the decimal
   *                                          point.
   *                                          `precision` is undefined by default.
   *                     {number} lowerExp    Exponent determining the lower boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `-3`.
   *                     {number} upperExp    Exponent determining the upper boundary
   *                                          for formatting a value with an exponent
   *                                          when `notation='auto`.
   *                                          Default value is `5`.
   *    {Function} fn    A custom formatting function. Can be used to override the
   *                     built-in notations. Function `fn` is called with `value` as
   *                     parameter and must return a string. Is useful for example to
   *                     format all values inside a matrix in a particular way.
   *
   * Examples:
   *
   *    format(6.4)                                        // '6.4'
   *    format(1240000)                                    // '1.24e6'
   *    format(1/3)                                        // '0.3333333333333333'
   *    format(1/3, 3)                                     // '0.333'
   *    format(21385, 2)                                   // '21000'
   *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'
   *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'
   *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'
   *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'
   *
   * @param {BigNumber} value
   * @param {Object | Function | number} [options]
   * @return {string} str The formatted value
   */

  function format$1(value, options) {
    if (typeof options === 'function') {
      // handle format(value, fn)
      return options(value);
    } // handle special cases

    if (!value.isFinite()) {
      return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';
    } // default values for options

    var notation = 'auto';
    var precision;
    var wordSize;
    if (options !== undefined) {
      // determine notation from options
      if (options.notation) {
        notation = options.notation;
      } // determine precision from options

      if (typeof options === 'number') {
        precision = options;
      } else if (options.precision) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== 'number') {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    } // handle the various notations

    switch (notation) {
      case 'fixed':
        return toFixed(value, precision);
      case 'exponential':
        return toExponential(value, precision);
      case 'engineering':
        return toEngineering(value, precision);
      case 'bin':
        return formatBigNumberToBase(value, 2, wordSize);
      case 'oct':
        return formatBigNumberToBase(value, 8, wordSize);
      case 'hex':
        return formatBigNumberToBase(value, 16, wordSize);
      case 'auto':
        {
          // determine lower and upper bound for exponential notation.
          // TODO: implement support for upper and lower to be BigNumbers themselves
          var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
          var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero

          if (value.isZero()) return '0'; // determine whether or not to output exponential notation

          var str;
          var rounded = value.toSignificantDigits(precision);
          var exp = rounded.e;
          if (exp >= lowerExp && exp < upperExp) {
            // normal number notation
            str = rounded.toFixed();
          } else {
            // exponential notation
            str = toExponential(value, precision);
          } // remove trailing zeros after the decimal point

          return str.replace(/((\.\d*?)(0+))($|e)/, function () {
            var digits = arguments[2];
            var e = arguments[4];
            return digits !== '.' ? digits + e : e;
          });
        }
      default:
        throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  /**
   * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
   * @param {BigNumber | string} value
   * @param {number} [precision]        Optional number of significant figures to return.
   */

  function toEngineering(value, precision) {
    // find nearest lower multiple of 3 for exponent
    var e = value.e;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3; // find difference in exponents, and calculate the value without exponent

    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.indexOf('e') !== -1) {
      valueStr = valueWithoutExp.toString();
    }
    return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
  }
  /**
   * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
   * @param {BigNumber} value
   * @param {number} [precision]  Number of digits in formatted output.
   *                              If not provided, the maximum available digits
   *                              is used.
   * @returns {string} str
   */

  function toExponential(value, precision) {
    if (precision !== undefined) {
      return value.toExponential(precision - 1); // Note the offset of one
    } else {
      return value.toExponential();
    }
  }
  /**
   * Format a number with fixed notation.
   * @param {BigNumber} value
   * @param {number} [precision=undefined] Optional number of decimals after the
   *                                       decimal point. Undefined by default.
   */

  function toFixed(value, precision) {
    return value.toFixed(precision);
  }

  /**
   * Format a value of any type into a string.
   *
   * Usage:
   *     math.format(value)
   *     math.format(value, precision)
   *     math.format(value, options)
   *
   * When value is a function:
   *
   * - When the function has a property `syntax`, it returns this
   *   syntax description.
   * - In other cases, a string `'function'` is returned.
   *
   * When `value` is an Object:
   *
   * - When the object contains a property `format` being a function, this
   *   function is invoked as `value.format(options)` and the result is returned.
   * - When the object has its own `toString` method, this method is invoked
   *   and the result is returned.
   * - In other cases the function will loop over all object properties and
   *   return JSON object notation like '{"a": 2, "b": 3}'.
   *
   * Example usage:
   *     math.format(2/7)                // '0.2857142857142857'
   *     math.format(math.pi, 3)         // '3.14'
   *     math.format(new Complex(2, 3))  // '2 + 3i'
   *     math.format('hello')            // '"hello"'
   *
   * @param {*} value             Value to be stringified
   * @param {Object | number | Function} [options]
   *     Formatting options. See src/utils/number.js:format for a
   *     description of the available options controlling number output.
   *     This generic "format" also supports the option property `truncate: NN`
   *     giving the maximum number NN of characters to return (if there would
   *     have been more, they are deleted and replaced by an ellipsis).
   * @return {string} str
   */

  function format(value, options) {
    var result = _format(value, options);
    if (options && typeof options === 'object' && 'truncate' in options && result.length > options.truncate) {
      return result.substring(0, options.truncate - 3) + '...';
    }
    return result;
  }
  function _format(value, options) {
    if (typeof value === 'number') {
      return format$2(value, options);
    }
    if (isBigNumber(value)) {
      return format$1(value, options);
    } // note: we use unsafe duck-typing here to check for Fractions, this is
    // ok here since we're only invoking toString or concatenating its values

    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== 'decimal') {
        // output as ratio, like '1/3'
        return value.s * value.n + '/' + value.d;
      } else {
        // output as decimal, like '0.(3)'
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return '"' + value + '"';
    }
    if (typeof value === 'function') {
      return value.syntax ? String(value.syntax) : 'function';
    }
    if (value && typeof value === 'object') {
      if (typeof value.format === 'function') {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        // this object has a non-native toString method, use that one
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map(key => {
          return '"' + key + '": ' + format(value[key], options);
        });
        return '{' + entries.join(', ') + '}';
      }
    }
    return String(value);
  }
  /**
   * Recursively format an n-dimensional matrix
   * Example output: "[[1, 2], [3, 4]]"
   * @param {Array} array
   * @param {Object | number | Function} [options]  Formatting options. See
   *                                                lib/utils/number:format for a
   *                                                description of the available
   *                                                options.
   * @returns {string} str
   */

  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = '[';
      var len = array.length;
      for (var i = 0; i < len; i++) {
        if (i !== 0) {
          str += ', ';
        }
        str += formatArray(array[i], options);
      }
      str += ']';
      return str;
    } else {
      return format(array, options);
    }
  }
  /**
   * Check whether a value looks like a Fraction (unsafe duck-type check)
   * @param {*} value
   * @return {boolean}
   */

  function looksLikeFraction(value) {
    return value && typeof value === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;
  }

  /**
   * Create a range error with the message:
   *     'Dimension mismatch (<actual size> != <expected size>)'
   * @param {number | number[]} actual        The actual size
   * @param {number | number[]} expected      The expected size
   * @param {string} [relation='!=']          Optional relation between actual
   *                                          and expected size: '!=', '<', etc.
   * @extends RangeError
   */
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = 'Dimension mismatch (' + (Array.isArray(actual) ? '[' + actual.join(', ') + ']' : actual) + ' ' + (this.relation || '!=') + ' ' + (Array.isArray(expected) ? '[' + expected.join(', ') + ']' : expected) + ')';
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = 'DimensionError';
  DimensionError.prototype.isDimensionError = true;

  /**
   * Create a range error with the message:
   *     'Index out of range (index < min)'
   *     'Index out of range (index < max)'
   *
   * @param {number} index     The actual index
   * @param {number} [min=0]   Minimum index (included)
   * @param {number} [max]     Maximum index (excluded)
   * @extends RangeError
   */
  function IndexError(index, min, max) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError('Constructor must be called with the new operator');
    }
    this.index = index;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min;
    } else {
      this.min = min;
      this.max = max;
    }
    if (this.min !== undefined && this.index < this.min) {
      this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
    } else if (this.max !== undefined && this.index >= this.max) {
      this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
    } else {
      this.message = 'Index out of range (' + this.index + ')';
    }
    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = 'IndexError';
  IndexError.prototype.isIndexError = true;

  /**
   * Calculate the size of a multi dimensional array.
   * This function checks the size of the first entry, it does not validate
   * whether all dimensions match. (use function `validate` for that)
   * @param {Array} x
   * @Return {Number[]} size
   */

  function arraySize(x) {
    var s = [];
    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }
    return s;
  }
  /**
   * Recursively validate whether each element in a multi dimensional array
   * has a size corresponding to the provided size array.
   * @param {Array} array    Array to be validated
   * @param {number[]} size  Array with the size of each dimension
   * @param {number} dim   Current dimension
   * @throws DimensionError
   * @private
   */

  function _validate(array, size, dim) {
    var i;
    var len = array.length;
    if (len !== size[dim]) {
      throw new DimensionError(len, size[dim]);
    }
    if (dim < size.length - 1) {
      // recursively validate each child array
      var dimNext = dim + 1;
      for (i = 0; i < len; i++) {
        var child = array[i];
        if (!Array.isArray(child)) {
          throw new DimensionError(size.length - 1, size.length, '<');
        }
        _validate(array[i], size, dimNext);
      }
    } else {
      // last dimension. none of the childs may be an array
      for (i = 0; i < len; i++) {
        if (Array.isArray(array[i])) {
          throw new DimensionError(size.length + 1, size.length, '>');
        }
      }
    }
  }
  /**
   * Validate whether each element in a multi dimensional array has
   * a size corresponding to the provided size array.
   * @param {Array} array    Array to be validated
   * @param {number[]} size  Array with the size of each dimension
   * @throws DimensionError
   */

  function validate(array, size) {
    var isScalar = size.length === 0;
    if (isScalar) {
      // scalar
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      // array
      _validate(array, size, 0);
    }
  }
  /**
   * Test whether index is an integer number with index >= 0 and index < length
   * when length is provided
   * @param {number} index    Zero-based index
   * @param {number} [length] Length of the array
   */

  function validateIndex(index, length) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError('Index must be an integer (value: ' + index + ')');
    }
    if (index < 0 || typeof length === 'number' && index >= length) {
      throw new IndexError(index, length);
    }
  }
  /**
   * Resize a multi dimensional array. The resized array is returned.
   * @param {Array} array         Array to be resized
   * @param {Array.<number>} size Array with the size of each dimension
   * @param {*} [defaultValue=0]  Value to be filled in in new entries,
   *                              zero by default. Specify for example `null`,
   *                              to clearly see entries that are not explicitly
   *                              set.
   * @return {Array} array         The resized array
   */

  function resize(array, size, defaultValue) {
    // TODO: add support for scalars, having size=[] ?
    // check the type of the arguments
    if (!Array.isArray(array) || !Array.isArray(size)) {
      throw new TypeError('Array expected');
    }
    if (size.length === 0) {
      throw new Error('Resizing to scalar is not supported');
    } // check whether size contains positive integers

    size.forEach(function (value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');
      }
    }); // recursively resize the array

    var _defaultValue = defaultValue !== undefined ? defaultValue : 0;
    _resize(array, size, 0, _defaultValue);
    return array;
  }
  /**
   * Recursively resize a multi dimensional array
   * @param {Array} array         Array to be resized
   * @param {number[]} size       Array with the size of each dimension
   * @param {number} dim          Current dimension
   * @param {*} [defaultValue]    Value to be filled in in new entries,
   *                              undefined by default.
   * @private
   */

  function _resize(array, size, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size[dim];
    var minLen = Math.min(oldLen, newLen); // apply new length

    array.length = newLen;
    if (dim < size.length - 1) {
      // non-last dimension
      var dimNext = dim + 1; // resize existing child arrays

      for (i = 0; i < minLen; i++) {
        // resize child array
        elem = array[i];
        if (!Array.isArray(elem)) {
          elem = [elem]; // add a dimension

          array[i] = elem;
        }
        _resize(elem, size, dimNext, defaultValue);
      } // create new child arrays

      for (i = minLen; i < newLen; i++) {
        // get child array
        elem = [];
        array[i] = elem; // resize new child array

        _resize(elem, size, dimNext, defaultValue);
      }
    } else {
      // last dimension
      // remove dimensions of existing values
      for (i = 0; i < minLen; i++) {
        while (Array.isArray(array[i])) {
          array[i] = array[i][0];
        }
      } // fill new elements with the default value

      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
  /**
   * Re-shape a multi dimensional array to fit the specified dimensions
   * @param {Array} array           Array to be reshaped
   * @param {Array.<number>} sizes  List of sizes for each dimension
   * @returns {Array}               Array whose data has been formatted to fit the
   *                                specified dimensions
   *
   * @throws {DimensionError}       If the product of the new dimension sizes does
   *                                not equal that of the old ones
   */

  function reshape(array, sizes) {
    var flatArray = flatten$1(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError('Array expected');
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, '!=');
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, '!=');
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e) {
      if (e instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, '!=');
      }
      throw e;
    }
  }
  /**
   * Replaces the wildcard -1 in the sizes array.
   * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.
   * @param {number} currentLength  Number of elements in the array.
   * @throws {Error}                If more than one wildcard or unable to replace it.
   * @returns {Array.<number>}      The sizes array with wildcard replaced.
   */

  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error('More than one wildcard in sizes');
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);
      }
    }
    return processedSizes;
  }
  /**
   * Computes the product of all array elements.
   * @param {Array<number>} array Array of factors
   * @returns {number}            Product of all elements
   */

  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  /**
   * Iteratively re-shape a multi dimensional array to fit the specified dimensions
   * @param {Array} array           Array to be reshaped
   * @param {Array.<number>} sizes  List of sizes for each dimension
   * @returns {Array}               Array whose data has been formatted to fit the
   *                                specified dimensions
   */

  function _reshape(array, sizes) {
    // testing if there are enough elements for the requested shape
    var tmpArray = array;
    var tmpArray2; // for each dimensions starting by the last one and ignoring the first one

    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size = sizes[sizeIndex];
      tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size

      var length = tmpArray.length / size;
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
      } // set it as the new tmpArray for the next loop turn or for return

      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  /**
   * Squeeze a multi dimensional array
   * @param {Array} array
   * @param {Array} [size]
   * @returns {Array} returns the array itself
   */

  function squeeze(array, size) {
    var s = size || arraySize(array); // squeeze outer dimensions

    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s.shift();
    } // find the first dimension to be squeezed

    var dims = s.length;
    while (s[dims - 1] === 1) {
      dims--;
    } // squeeze inner dimensions

    if (dims < s.length) {
      array = _squeeze(array, dims, 0);
      s.length = dims;
    }
    return array;
  }
  /**
   * Recursively squeeze a multi dimensional array
   * @param {Array} array
   * @param {number} dims Required number of dimensions
   * @param {number} dim  Current dimension
   * @returns {Array | *} Returns the squeezed array
   * @private
   */

  function _squeeze(array, dims, dim) {
    var i, ii;
    if (dim < dims) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _squeeze(array[i], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }
    return array;
  }
  /**
   * Unsqueeze a multi dimensional array: add dimensions when missing
   *
   * Paramter `size` will be mutated to match the new, unqueezed matrix size.
   *
   * @param {Array} array
   * @param {number} dims       Desired number of dimensions of the array
   * @param {number} [outer]    Number of outer dimensions to be added
   * @param {Array} [size] Current size of array.
   * @returns {Array} returns the array itself
   * @private
   */

  function unsqueeze(array, dims, outer, size) {
    var s = size || arraySize(array); // unsqueeze outer dimensions

    if (outer) {
      for (var i = 0; i < outer; i++) {
        array = [array];
        s.unshift(1);
      }
    } // unsqueeze inner dimensions

    array = _unsqueeze(array, dims, 0);
    while (s.length < dims) {
      s.push(1);
    }
    return array;
  }
  /**
   * Recursively unsqueeze a multi dimensional array
   * @param {Array} array
   * @param {number} dims Required number of dimensions
   * @param {number} dim  Current dimension
   * @returns {Array | *} Returns the squeezed array
   * @private
   */

  function _unsqueeze(array, dims, dim) {
    var i, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _unsqueeze(array[i], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }
    return array;
  }
  /**
   * Flatten a multi dimensional array, put all elements in a one dimensional
   * array
   * @param {Array} array   A multi dimensional array
   * @return {Array}        The flattened array (1 dimensional)
   */

  function flatten$1(array) {
    if (!Array.isArray(array)) {
      // if not an array, return as is
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback); // traverse through sub-arrays recursively
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  /**
   * Check the datatype of a given object
   * This is a low level implementation that should only be used by
   * parent Matrix classes such as SparseMatrix or DenseMatrix
   * This method does not validate Array Matrix shape
   * @param {Array} array
   * @param {function} typeOf   Callback function to use to determine the type of a value
   * @return {string}
   */

  function getArrayDataType(array, typeOf) {
    var type; // to hold type info

    var length = 0; // to hold length value to ensure it has consistent sizes

    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      var isArray = Array.isArray(item); // Saving the target matrix row size

      if (i === 0 && isArray) {
        length = item.length;
      } // If the current item is an array but the length does not equal the targetVectorSize

      if (isArray && item.length !== length) {
        return undefined;
      }
      var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array
      : typeOf(item);
      if (type === undefined) {
        type = itemType; // first item
      } else if (type !== itemType) {
        return 'mixed';
      } else ;
    }
    return type;
  }

  /**
   * Create a factory function, which can be used to inject dependencies.
   *
   * The created functions are memoized, a consecutive call of the factory
   * with the exact same inputs will return the same function instance.
   * The memoized cache is exposed on `factory.cache` and can be cleared
   * if needed.
   *
   * Example:
   *
   *     const name = 'log'
   *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']
   *
   *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {
   *       // ... create the function log here and return it
   *     }
   *
   * @param {string} name           Name of the function to be created
   * @param {string[]} dependencies The names of all required dependencies
   * @param {function} create       Callback function called with an object with all dependencies
   * @param {Object} [meta]         Optional object with meta information that will be attached
   *                                to the created factory function as property `meta`.
   * @returns {function}
   */

  function factory(name, dependencies, create, meta) {
    function assertAndCreate(scope) {
      // we only pass the requested dependencies to the factory function
      // to prevent functions to rely on dependencies that are not explicitly
      // requested.
      var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
      assertDependencies(name, dependencies, scope);
      return create(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name;
    assertAndCreate.dependencies = dependencies.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  /**
   * Assert that all dependencies of a list with dependencies are available in the provided scope.
   *
   * Will throw an exception when there are dependencies missing.
   *
   * @param {string} name   Name for the function to be created. Used to generate a useful error message
   * @param {string[]} dependencies
   * @param {Object} scope
   */

  function assertDependencies(name, dependencies, scope) {
    var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals
    .every(dependency => scope[dependency] !== undefined);
    if (!allDefined) {
      var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined); // TODO: create a custom error class for this, a MathjsError or something like that

      throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map(d => "\"".concat(d, "\"")).join(', '), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === '?';
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;
  }

  /**
   * Get a property of a plain object
   * Throws an error in case the object is not a plain object or the
   * property is not defined on the object itself
   * @param {Object} object
   * @param {string} prop
   * @return {*} Returns the property value when safe
   */

  function getSafeProperty(object, prop) {
    // only allow getting safe properties of a plain object
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  /**
   * Set a property on a plain object.
   * Throws an error in case the object is not a plain object or the
   * property would override an inherited property like .constructor or .toString
   * @param {Object} object
   * @param {string} prop
   * @param {*} value
   * @return {*} Returns the value
   */
  // TODO: merge this function into access.js?

  function setSafeProperty(object, prop, value) {
    // only allow setting safe properties of a plain object
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function hasSafeProperty(object, prop) {
    return prop in object;
  }
  /**
   * Test whether a property is safe to use for an object.
   * For example .toString and .constructor are not safe
   * @param {string} prop
   * @return {boolean} Returns true when safe
   */

  function isSafeProperty(object, prop) {
    if (!object || typeof object !== 'object') {
      return false;
    } // SAFE: whitelisted
    // e.g length

    if (hasOwnProperty(safeNativeProperties, prop)) {
      return true;
    } // UNSAFE: inherited from Object prototype
    // e.g constructor

    if (prop in Object.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Object.prototype is a root object
      return false;
    } // UNSAFE: inherited from Function prototype
    // e.g call, apply

    if (prop in Function.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Function.prototype is a root object
      return false;
    }
    return true;
  }
  /**
   * Check whether a method is safe.
   * Throws an error when that's not the case (for example for `constructor`).
   * @param {Object} object
   * @param {string} method
   * @return {boolean} Returns true when safe, false otherwise
   */

  function isSafeMethod(object, method) {
    if (object === null || object === undefined || typeof object[method] !== 'function') {
      return false;
    } // UNSAFE: ghosted
    // e.g overridden toString
    // Note that IE10 doesn't support __proto__ and we can't do this check there.

    if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    } // SAFE: whitelisted
    // e.g toString

    if (hasOwnProperty(safeNativeMethods, method)) {
      return true;
    } // UNSAFE: inherited from Object prototype
    // e.g constructor

    if (method in Object.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Object.prototype is a root object
      return false;
    } // UNSAFE: inherited from Function prototype
    // e.g call, apply

    if (method in Function.prototype) {
      // 'in' is used instead of hasOwnProperty for nodejs v0.10
      // which is inconsistent on root prototypes. It is safe
      // here because Function.prototype is a root object
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === 'object' && object && object.constructor === Object;
  }
  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  /**
   * A map facade on a bare object.
   *
   * The small number of methods needed to implement a scope,
   * forwarding on to the SafeProperty functions. Over time, the codebase
   * will stop using this method, as all objects will be Maps, rather than
   * more security prone objects.
   */

  class ObjectWrappingMap {
    constructor(object) {
      this.wrappedObject = object;
    }
    keys() {
      return Object.keys(this.wrappedObject);
    }
    get(key) {
      return getSafeProperty(this.wrappedObject, key);
    }
    set(key, value) {
      setSafeProperty(this.wrappedObject, key, value);
      return this;
    }
    has(key) {
      return hasSafeProperty(this.wrappedObject, key);
    }
  }
  /**
   * Returns `true` if the passed object appears to be a Map (i.e. duck typing).
   *
   * Methods looked for are `get`, `set`, `keys` and `has`.
   *
   * @param {Map | object} object
   * @returns
   */

  function isMap(object) {
    // We can use the fast instanceof, or a slower duck typing check.
    // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.
    if (!object) {
      return false;
    }
    return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';
  }

  /**
   * Create a typed-function which checks the types of the arguments and
   * can match them against multiple provided signatures. The typed-function
   * automatically converts inputs in order to find a matching signature.
   * Typed functions throw informative errors in case of wrong input arguments.
   *
   * See the library [typed-function](https://github.com/josdejong/typed-function)
   * for detailed documentation.
   *
   * Syntax:
   *
   *     math.typed(name, signatures) : function
   *     math.typed(signatures) : function
   *
   * Examples:
   *
   *     // create a typed function with multiple types per argument (type union)
   *     const fn2 = typed({
   *       'number | boolean': function (b) {
   *         return 'b is a number or boolean'
   *       },
   *       'string, number | boolean': function (a, b) {
   *         return 'a is a string, b is a number or boolean'
   *       }
   *     })
   *
   *     // create a typed function with an any type argument
   *     const log = typed({
   *       'string, any': function (event, data) {
   *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))
   *       }
   *     })
   *
   * @param {string} [name]                          Optional name for the typed-function
   * @param {Object<string, function>} signatures   Object with one or multiple function signatures
   * @returns {function} The created typed-function.
   */

  var _createTyped2 = function _createTyped() {
    // initially, return the original instance of typed-function
    // consecutively, return a new instance from typed.create.
    _createTyped2 = typedFunction.create;
    return typedFunction;
  };
  var dependencies$14 = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];
  /**
   * Factory function for creating a new typed instance
   * @param {Object} dependencies   Object with data types like Complex and BigNumber
   * @returns {Function}
   */

  var createTyped = /* #__PURE__ */factory('typed', dependencies$14, function createTyped(_ref) {
    var {
      BigNumber,
      Complex,
      DenseMatrix,
      Fraction
    } = _ref;

    // TODO: typed-function must be able to silently ignore signatures with unknown data types
    // get a new instance of typed-function
    var typed = _createTyped2(); // define all types. The order of the types determines in which order function
    // arguments are type-checked (so for performance it's important to put the
    // most used types first).

    typed.types = [{
      name: 'number',
      test: isNumber
    }, {
      name: 'Complex',
      test: isComplex
    }, {
      name: 'BigNumber',
      test: isBigNumber
    }, {
      name: 'Fraction',
      test: isFraction
    }, {
      name: 'Unit',
      test: isUnit
    }, {
      name: 'string',
      test: isString
    }, {
      name: 'Chain',
      test: isChain
    }, {
      name: 'Array',
      test: isArray
    }, {
      name: 'Matrix',
      test: isMatrix
    }, {
      name: 'DenseMatrix',
      test: isDenseMatrix
    }, {
      name: 'SparseMatrix',
      test: isSparseMatrix
    }, {
      name: 'Range',
      test: isRange
    }, {
      name: 'Index',
      test: isIndex
    }, {
      name: 'boolean',
      test: isBoolean
    }, {
      name: 'ResultSet',
      test: isResultSet
    }, {
      name: 'Help',
      test: isHelp
    }, {
      name: 'function',
      test: isFunction
    }, {
      name: 'Date',
      test: isDate
    }, {
      name: 'RegExp',
      test: isRegExp
    }, {
      name: 'null',
      test: isNull
    }, {
      name: 'undefined',
      test: isUndefined
    }, {
      name: 'AccessorNode',
      test: isAccessorNode
    }, {
      name: 'ArrayNode',
      test: isArrayNode
    }, {
      name: 'AssignmentNode',
      test: isAssignmentNode
    }, {
      name: 'BlockNode',
      test: isBlockNode
    }, {
      name: 'ConditionalNode',
      test: isConditionalNode
    }, {
      name: 'ConstantNode',
      test: isConstantNode
    }, {
      name: 'FunctionNode',
      test: isFunctionNode
    }, {
      name: 'FunctionAssignmentNode',
      test: isFunctionAssignmentNode
    }, {
      name: 'IndexNode',
      test: isIndexNode
    }, {
      name: 'Node',
      test: isNode
    }, {
      name: 'ObjectNode',
      test: isObjectNode
    }, {
      name: 'OperatorNode',
      test: isOperatorNode
    }, {
      name: 'ParenthesisNode',
      test: isParenthesisNode
    }, {
      name: 'RangeNode',
      test: isRangeNode
    }, {
      name: 'SymbolNode',
      test: isSymbolNode
    }, {
      name: 'Map',
      test: isMap
    }, {
      name: 'Object',
      test: isObject
    } // order 'Object' last, it matches on other classes too
    ];

    typed.conversions = [{
      from: 'number',
      to: 'BigNumber',
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        } // note: conversion from number to BigNumber can fail if x has >15 digits

        if (digits(x) > 15) {
          throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');
        }
        return new BigNumber(x);
      }
    }, {
      from: 'number',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }
        return new Complex(x, 0);
      }
    }, {
      from: 'number',
      to: 'string',
      convert: function convert(x) {
        return x + '';
      }
    }, {
      from: 'BigNumber',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }
        return new Complex(x.toNumber(), 0);
      }
    }, {
      from: 'Fraction',
      to: 'BigNumber',
      convert: function convert(x) {
        throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
      }
    }, {
      from: 'Fraction',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }
        return new Complex(x.valueOf(), 0);
      }
    }, {
      from: 'number',
      to: 'Fraction',
      convert: function convert(x) {
        if (!Fraction) {
          throwNoFraction(x);
        }
        var f = new Fraction(x);
        if (f.valueOf() !== x) {
          throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');
        }
        return f;
      }
    }, {
      // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
      //  from: 'Fraction',
      //  to: 'number',
      //  convert: function (x) {
      //    return x.valueOf()
      //  }
      // }, {
      from: 'string',
      to: 'number',
      convert: function convert(x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: 'string',
      to: 'BigNumber',
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        try {
          return new BigNumber(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: 'string',
      to: 'Fraction',
      convert: function convert(x) {
        if (!Fraction) {
          throwNoFraction(x);
        }
        try {
          return new Fraction(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: 'string',
      to: 'Complex',
      convert: function convert(x) {
        if (!Complex) {
          throwNoComplex(x);
        }
        try {
          return new Complex(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: 'boolean',
      to: 'number',
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: 'boolean',
      to: 'BigNumber',
      convert: function convert(x) {
        if (!BigNumber) {
          throwNoBignumber(x);
        }
        return new BigNumber(+x);
      }
    }, {
      from: 'boolean',
      to: 'Fraction',
      convert: function convert(x) {
        if (!Fraction) {
          throwNoFraction(x);
        }
        return new Fraction(+x);
      }
    }, {
      from: 'boolean',
      to: 'string',
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: 'Array',
      to: 'Matrix',
      convert: function convert(array) {
        if (!DenseMatrix) {
          throwNoMatrix();
        }
        return new DenseMatrix(array);
      }
    }, {
      from: 'Matrix',
      to: 'Array',
      convert: function convert(matrix) {
        return matrix.valueOf();
      }
    }];
    return typed;
  });
  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error('Cannot convert array into a Matrix: no class \'DenseMatrix\' provided');
  }
  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  /*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */


  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


    // The maximum exponent magnitude.
    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
  var EXP_LIMIT = 9e15,                      // 0 to 9e15

    // The limit on the value of `precision`, and on the value of the first argument to
    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
    MAX_DIGITS = 1e9,                        // 0 to 1e9

    // Base conversion alphabet.
    NUMERALS = '0123456789abcdef',

    // The natural logarithm of 10 (1025 digits).
    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

    // Pi (1025 digits).
    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


    // The initial configuration properties of the Decimal constructor.
    DEFAULTS = {

      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.

      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,                         // 1 to MAX_DIGITS

      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,                           // 0 to 8

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,                             // 0 to 9

      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,                          // 0 to -EXP_LIMIT

      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos:  21,                         // 0 to EXP_LIMIT

      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false                          // true/false
    },


  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


    inexact, quadrant,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    precisionLimitExceeded = decimalError + 'Precision limit exceeded',
    cryptoUnavailable = decimalError + 'crypto unavailable',
    tag = '[object Decimal]',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,

    LN10_PRECISION = LN10.length - 1,
    PI_PRECISION = PI.length - 1,

    // Decimal.prototype object
    P = { toStringTag: tag };


  // Decimal prototype methods


  /*
   *  absoluteValue             abs
   *  ceil
   *  clampedTo                 clamp
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf                   toJSON
   */


  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */
  P.absoluteValue = P.abs = function () {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */
  P.ceil = function () {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal clamped to the range
   * delineated by `min` and `max`.
   *
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */
  P.clampedTo = P.clamp = function (min, max) {
    var k,
      x = this,
      Ctor = x.constructor;
    min = new Ctor(min);
    max = new Ctor(max);
    if (!min.s || !max.s) return new Ctor(NaN);
    if (min.gt(max)) throw Error(invalidArgument + max);
    k = x.cmp(min);
    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
  };


  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */
  P.comparedTo = P.cmp = function (y) {
    var i, j, xdL, ydL,
      x = this,
      xd = x.d,
      yd = (y = new x.constructor(y)).d,
      xs = x.s,
      ys = y.s;

    // Either NaN or Infinity?
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }

    // Either zero?
    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

    // Signs differ?
    if (xs !== ys) return xs;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

    xdL = xd.length;
    ydL = yd.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };


  /*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */
  P.cosine = P.cos = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.d) return new Ctor(NaN);

    // cos(0) = cos(-0) = 1
    if (!x.d[0]) return new Ctor(1);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };


  /*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */
  P.cubeRoot = P.cbrt = function () {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false;

    // Initial estimate.
    s = x.s * mathpow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;

      // Adjust n exponent so it is a multiple of 3 away from x exponent.
      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
      s = mathpow(n, 1 / 3);

      // Rarely, e may be one less than the result exponent value.
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Halley's method.
    // TODO? Compare Newton's method.
    for (;;) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide$1(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
        // , i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */
  P.decimalPlaces = P.dp = function () {
    var w,
      d = this.d,
      n = NaN;

    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last word.
      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) n--;
      if (n < 0) n = 0;
    }

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedBy = P.div = function (y) {
    return divide$1(this, new this.constructor(y));
  };


  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedToIntegerBy = P.divToInt = function (y) {
    var x = this,
      Ctor = x.constructor;
    return finalise(divide$1(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };


  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */
  P.equals = P.eq = function (y) {
    return this.cmp(y) === 0;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */
  P.floor = function () {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };


  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */
  P.greaterThan = P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */
  P.greaterThanOrEqualTo = P.gte = function (y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */
  P.hyperbolicCosine = P.cosh = function () {
    var k, n, pr, rm, len,
      x = this,
      Ctor = x.constructor,
      one = new Ctor(1);

    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

    // Estimate the optimum number of times to use the argument reduction.
    // TODO? Estimation reused from cosine() and may not be optimal here.
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = '2.3283064365386962890625e-10';
    }

    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

    // Reverse argument reduction
    var cosh2_x,
      i = k,
      d8 = new Ctor(8);
    for (; i--;) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }

    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */
  P.hyperbolicSine = P.sinh = function () {
    var k, pr, rm, len,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {

      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
      // 3 multiplications and 1 addition

      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
      // 4 multiplications and 2 additions

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);

      // Reverse argument reduction
      var sinh2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */
  P.hyperbolicTangent = P.tanh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;

    return divide$1(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };


  /*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */
  P.inverseCosine = P.acos = function () {
    var halfPi,
      x = this,
      Ctor = x.constructor,
      k = x.abs().cmp(1),
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (k !== -1) {
      return k === 0
        // |x| is 1
        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
        // |x| > 1 or x is NaN
        : new Ctor(NaN);
    }

    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return halfPi.minus(x);
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */
  P.inverseHyperbolicCosine = P.acosh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).minus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */
  P.inverseHyperbolicSine = P.asinh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).plus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */
  P.inverseHyperbolicTangent = P.atanh = function () {
    var pr, rm, wpr, xsd,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();

    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

    Ctor.precision = wpr = xsd - x.e;

    x = divide$1(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

    Ctor.precision = pr + 4;
    Ctor.rounding = 1;

    x = x.ln();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(0.5);
  };


  /*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */
  P.inverseSine = P.asin = function () {
    var halfPi, k,
      pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.isZero()) return new Ctor(x);

    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (k !== -1) {

      // |x| is 1
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }

      // |x| > 1 or x is NaN
      return new Ctor(NaN);
    }

    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(2);
  };


  /*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */
  P.inverseTangent = P.atan = function () {
    var i, j, k, n, px, t, r, wpr, x2,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }

    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;

    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

    // Argument reduction
    // Ensure |x| < 0.42
    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

    k = Math.min(28, wpr / LOG_BASE + 2 | 0);

    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

    external = false;

    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;

    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    for (; i !== -1;) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));

      px = px.times(x2);
      r = t.plus(px.div(n += 2));

      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
    }

    if (k) r = r.times(2 << (k - 1));

    external = true;

    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */
  P.isFinite = function () {
    return !!this.d;
  };


  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */
  P.isInteger = P.isInt = function () {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };


  /*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */
  P.isNegative = P.isNeg = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */
  P.isPositive = P.isPos = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */
  P.isZero = function () {
    return !!this.d && this.d[0] === 0;
  };


  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */
  P.lessThan = P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */
  P.lessThanOrEqualTo = P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */
  P.logarithm = P.log = function (base) {
    var isBase10, d, denominator, k, inf, num, sd, r,
      arg = this,
      Ctor = arg.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding,
      guard = 5;

    // Default base is 10.
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;

      // Return NaN if base is negative, or non-finite, or is 0 or 1.
      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

      isBase10 = base.eq(10);
    }

    d = arg.d;

    // Is arg negative, non-finite, 0 or 1?
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }

    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
    // integer power of 10.
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0;) k /= 10;
        inf = k !== 1;
      }
    }

    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

    // The result will have 5 rounding digits.
    r = divide$1(num, denominator, sd, 1);

    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
    // calculate 10 further digits.
    //
    // If the result is known to have an infinite decimal expansion, repeat this until it is clear
    // that the result is above or below the boundary. Otherwise, if after calculating the 10
    // further digits, the last 14 are nines, round up and assume the result is exact.
    // Also assume the result is exact if the last 14 are zero.
    //
    // Example of a result that will be incorrectly rounded:
    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
    // place is still 2.6.
    if (checkRoundingDigits(r.d, k = pr, rm)) {

      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide$1(num, denominator, sd, 1);

        if (!inf) {

          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }

          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }

    external = true;

    return finalise(r, pr, rm);
  };


  /*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   */


  /*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   */


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.minus = P.sub = function (y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return y negated if x is finite and y is Infinity.
      else if (x.d) y.s = -y.s;

      // Return x if y is finite and x is Infinity.
      // Return x if both are Infinity with different signs.
      // Return NaN if both are Infinity with the same sign.
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

      return y;
    }

    // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return y negated if x is zero and y is non-zero.
      if (yd[0]) y.s = -y.s;

      // Return x if y is zero and x is non-zero.
      else if (xd[0]) y = new Ctor(x);

      // Return zero if both are zero.
      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
      else return new Ctor(rm === 3 ? -0 : 0);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);

    xd = xd.slice();
    k = xe - e;

    // If base 1e7 exponents differ...
    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }

      // Numbers with massively different exponents would result in a very high number of
      // zeros needing to be prepended, but this can be avoided while still ensuring correct
      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents.
      d.reverse();
      for (i = k; i--;) d.push(0);
      d.reverse();

    // Base 1e7 exponents equal.
    } else {

      // Check digits to determine which is the bigger number.

      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to `xd` if shorter.
    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {

      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */
  P.modulo = P.mod = function (y) {
    var q,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // Return NaN if x is Infinity or NaN, or y is NaN or 0.
    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

    // Return x if y is Infinity or x is 0.
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }

    // Prevent rounding of intermediate calculations.
    external = false;

    if (Ctor.modulo == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // result = x - q * y    where  0 <= result < abs(y)
      q = divide$1(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide$1(x, y, 0, Ctor.modulo, 1);
    }

    q = q.times(y);

    external = true;

    return x.minus(q);
  };


  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.naturalExponential = P.exp = function () {
    return naturalExponential(this);
  };


  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.naturalLogarithm = P.ln = function () {
    return naturalLogarithm(this);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */
  P.negated = P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.plus = P.add = function (y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return x if y is finite and x is Infinity.
      // Return x if both are Infinity with the same sign.
      // Return NaN if both are Infinity with different signs.
      // Return y if x is finite and y is Infinity.
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

      return y;
    }

     // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!yd[0]) y = new Ctor(x);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);

    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {

      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }

      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
      d.reverse();
      for (; i--;) d.push(0);
      d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */
  P.precision = P.sd = function (z) {
    var k,
      x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }

    return k;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */
  P.round = function () {
    var x = this,
      Ctor = x.constructor;

    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };


  /*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */
  P.sine = P.sin = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = sine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, sd, r, rep, t,
      x = this,
      d = x.d,
      e = x.e,
      s = x.s,
      Ctor = x.constructor;

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }

    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);

      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Newton-Raphson iteration.
    for (;;) {
      t = r;
      r = t.plus(divide$1(x, t, sd + 2, 1)).times(0.5);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */
  P.tangent = P.tan = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;

    x = x.sin();
    x.s = 1;
    x = divide$1(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */
  P.times = P.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
      x = this,
      Ctor = x.constructor,
      xd = x.d,
      yd = (y = new Ctor(y)).d;

    y.s *= x.s;

     // If either is NaN, Infinity or 0...
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

        // Return NaN if either is NaN.
        // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
        ? NaN

        // Return Infinity if either is Infinity.
        // Return 0 if either is 0.
        : !xd || !yd ? y.s / 0 : y.s * 0);
    }

    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
      carry = 0;
      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    y.d = r;
    y.e = getBase10Exponent(r, e);

    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };


  /*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toBinary = function (sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toDecimalPlaces = P.toDP = function (dp, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return finalise(x, dp + x.e + 1, rm);
  };


  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toExponential = function (dp, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */
  P.toFixed = function (dp, rm) {
    var str, y,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */
  P.toFraction = function (maxD) {
    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
      x = this,
      xd = x.d,
      Ctor = x.constructor;

    if (!xd) return new Ctor(x);

    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);

    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

    if (maxD == null) {

      // d is 10**e, the minimum max-denominator needed.
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
    }

    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;

    for (;;)  {
      q = divide$1(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }

    d2 = divide$1(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;

    // Determine which fraction is closer to x, n0/d0 or n1/d1?
    r = divide$1(n1, d1, e, 1).minus(x).abs().cmp(divide$1(n0, d0, e, 1).minus(x).abs()) < 1
        ? [n1, d1] : [n0, d0];

    Ctor.precision = pr;
    external = true;

    return r;
  };


  /*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toHexadecimal = P.toHex = function (sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };


  /*
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */
  P.toNearest = function (y, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);

    if (y == null) {

      // If x is not finite, return x.
      if (!x.d) return x;

      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }

      // If x is not finite, return x if y is not NaN, else NaN.
      if (!x.d) return y.s ? x : y;

      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    }

    // If y is not zero, calculate the nearest multiple of y to x.
    if (y.d[0]) {
      external = false;
      x = divide$1(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);

    // If y is zero, return zero with the sign of x.
    } else {
      y.s = x.s;
      x = y;
    }

    return x;
  };


  /*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */
  P.toNumber = function () {
    return +this;
  };


  /*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toOctal = function (sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, 0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */
  P.toPower = P.pow = function (y) {
    var e, k, pr, r, rm, s,
      x = this,
      Ctor = x.constructor,
      yn = +(y = new Ctor(y));

    // Either Infinity, NaN or 0?
    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

    x = new Ctor(x);

    if (x.eq(1)) return x;

    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (y.eq(1)) return finalise(x, pr, rm);

    // y exponent
    e = mathfloor(y.e / LOG_BASE);

    // If y is a small integer use the 'exponentiation by squaring' algorithm.
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }

    s = x.s;

    // if x is negative
    if (s < 0) {

      // if y is not an integer
      if (e < y.d.length - 1) return new Ctor(NaN);

      // Result is positive if x is negative and the last digit of integer y is even.
      if ((y.d[e] & 1) == 0) s = 1;

      // if x.eq(-1)
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }

    // Estimate result exponent.
    // x^y = 10^e,  where e = y * log10(x)
    // log10(x) = log10(x_significand) + x_exponent
    // log10(x_significand) = ln(x_significand) / ln(10)
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k)
      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
      : new Ctor(k + '').e;

    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

    // Overflow/underflow?
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

    external = false;
    Ctor.rounding = x.s = 1;

    // Estimate the extra guard digits needed to ensure five correct rounding digits from
    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
    // new Decimal(2.32456).pow('2087987436534566.46411')
    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
    k = Math.min(12, (e + '').length);

    // r = x^y = exp(y*ln(x))
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
    if (r.d) {

      // Truncate to the required precision plus five rounding digits.
      r = finalise(r, pr + 5, 1);

      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
      // the result.
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;

        // Truncate to the increased precision plus five rounding digits.
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }

    r.s = s;
    external = true;
    Ctor.rounding = rm;

    return finalise(r, pr, rm);
  };


  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toPrecision = function (sd, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */
  P.toSignificantDigits = P.toSD = function (sd, rm) {
    var x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }

    return finalise(new Ctor(x), sd, rm);
  };


  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */
  P.toString = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */
  P.truncated = P.trunc = function () {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };


  /*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */
  P.valueOf = P.toJSON = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() ? '-' + str : str;
  };


  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


  /*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
   *                           finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              toStringBinary, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, parseOther, random, Decimal
   */


  function digitsToString(d) {
    var i, k, ws,
      indexOfLastWord = d.length - 1,
      str = '',
      w = d[0];

    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
  }


  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }


  /*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;

    // Get the length of the first word of the array d.
    for (k = d[0]; k >= 10; k /= 10) --i;

    // Is the rounding digit in the first word of d?
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }

    // i is the index (0 - 6) of the rounding digit.
    // E.g. if within the word 3487563 the first rounding digit is 5,
    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;

    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;
        else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1000 | 0;
        else if (i == 1) rd = rd / 100 | 0;
        else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k ||
        (!repeating && rm > 3) && rd + 1 == k / 2) &&
          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
      }
    }

    return r;
  }


  // Convert string of `baseIn` to an array of numbers of `baseOut`.
  // Eg. convertBase('255', 10, 16) returns [15, 15].
  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
  function convertBase(str, baseIn, baseOut) {
    var j,
      arr = [0],
      arrL,
      i = 0,
      strL = str.length;

    for (; i < strL;) {
      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }

    return arr.reverse();
  }


  /*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */
  function cosine(Ctor, x) {
    var k, len, y;

    if (x.isZero()) return x;

    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

    // Estimate the optimum number of times to use the argument reduction.
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = '2.3283064365386962890625e-10';
    }

    Ctor.precision += k;

    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

    // Reverse argument reduction
    for (var i = k; i--;) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }

    Ctor.precision -= k;

    return x;
  }


  /*
   * Perform division in the specified base.
   */
  var divide$1 = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k, base) {
      var temp,
        carry = 0,
        i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }

      if (carry) x.unshift(carry);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
        yL, yz,
        Ctor = x.constructor,
        sign = x.s == y.s ? 1 : -1,
        xd = x.d,
        yd = y.d;

      // Either NaN, Infinity or 0?
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
      }

      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }

      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = [];

      // Result exponent may be one less than e.
      // The digit array of a Decimal from toStringBinary may have trailing zeros.
      for (i = 0; yd[i] == (xd[i] || 0); i++);

      if (yd[i] > (xd[i] || 0)) e--;

      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {

        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / logBase + 2 | 0;
        i = 0;

        // divisor < 1e7
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;

          // k is the carry.
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }

          more = k || i < xL;

        // divisor >= 1e7
        } else {

          // Normalise xd and yd so highest order digit of yd is >= base/2
          k = base / (yd[0] + 1) | 0;

          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }

          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL;) rem[remL++] = 0;

          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];

          if (yd[1] >= base / 2) ++yd0;

          do {
            k = 0;

            // Compare divisor and remainder.
            cmp = compare(yd, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, k.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // k will be how many times the divisor goes into the current remainder.
              k = rem0 / yd0 | 0;

              //  Algorithm:
              //  1. product = divisor * trial digit (k)
              //  2. if product > remainder: product -= divisor, k--
              //  3. remainder -= product
              //  4. if product was < remainder at 2:
              //    5. compare new remainder and divisor
              //    6. If remainder > divisor: remainder -= divisor, k++

              if (k > 1) {
                if (k >= base) k = base - 1;

                // product = divisor * trial digit.
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                cmp = compare(prod, rem, prodL, remL);

                // product > remainder.
                if (cmp == 1) {
                  k--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {

                // cmp is -1.
                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }

              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);

              // If product was < previous remainder.
              if (cmp == -1) {
                remL = rem.length;

                // Compare divisor and new remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < new remainder, subtract divisor from remainder.
                if (cmp < 1) {
                  k++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }

              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }    // if cmp === 1, k will be 0

            // Add the next digit, k, to the result array.
            qd[i++] = k;

            // Update the remainder.
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }

          } while ((xi++ < xL || rem[0] !== void 0) && sd--);

          more = rem[0] !== void 0;
        }

        // Leading zero?
        if (!qd[0]) qd.shift();
      }

      // logBase is 1 when divide is being used for base conversion.
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {

        // To calculate q.e, first get the number of digits of qd[0].
        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
        q.e = i + e * logBase - 1;

        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }

      return q;
    };
  })();


  /*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */
   function finalise(x, sd, rm, isTruncated) {
    var digits, i, j, k, rd, roundUp, w, xd, xdi,
      Ctor = x.constructor;

    // Don't round if sd is null or undefined.
    out: if (sd != null) {
      xd = x.d;

      // Infinity/NaN.
      if (!xd) return x;

      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
      // w: the word of xd containing rd, a base 1e7 number.
      // xdi: the index of w within xd.
      // digits: the number of digits of w.
      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
      // they had leading zeros)
      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

      // Get the length of the first word of the digits array xd.
      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
      i = sd - digits;

      // Is the rounding digit in the first word of xd?
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];

        // Get the rounding digit at index j of w.
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {

            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
            for (; k++ <= xdi;) xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];

          // Get the number of digits of w.
          for (digits = 1; k >= 10; k /= 10) digits++;

          // Get the index of rd within w.
          i %= LOG_BASE;

          // Get the index of rd within w, adjusted for leading zeros.
          // The number of leading zeros of w is given by LOG_BASE - digits.
          j = i - LOG_BASE + digits;

          // Get the rounding digit at index j of w.
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }

      // Are there any non-zero digits after the rounding digit?
      isTruncated = isTruncated || sd < 0 ||
        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
      // will give 714.

      roundUp = rm < 4
        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
            rm == (x.s < 0 ? 8 : 7));

      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {

          // Convert sd to decimal places.
          sd -= x.e + 1;

          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {

          // Zero.
          xd[0] = x.e = 0;
        }

        return x;
      }

      // Remove excess digits.
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);

        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }

      if (roundUp) {
        for (;;) {

          // Is the digit to be rounded up in the first word of xd?
          if (xdi == 0) {

            // i will be the length of xd[0] before k is added.
            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10) k++;

            // if i != k the length has increased.
            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }

            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }

      // Remove trailing zeros.
      for (i = xd.length; xd[--i] === 0;) xd.pop();
    }

    if (external) {

      // Overflow?
      if (x.e > Ctor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < Ctor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // Ctor.underflow = true;
      } // else Ctor.underflow = false;
    }

    return x;
  }


  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k,
      e = x.e,
      str = digitsToString(x.d),
      len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return str;
  }


  // Calculate the base 10 exponent from the base 1e7 exponent.
  function getBase10Exponent(digits, e) {
    var w = digits[0];

    // Add the number of digits of the first word of the digits array.
    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
    return e;
  }


  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {

      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }


  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }


  function getPrecision(digits) {
    var w = digits.length - 1,
      len = w * LOG_BASE + 1;

    w = digits[w];

    // If non-zero...
    if (w) {

      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) len--;

      // Add the number of digits of the first word.
      for (w = digits[0]; w >= 10; w /= 10) len++;
    }

    return len;
  }


  function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
  }


  /*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */
  function intPow(Ctor, x, n, pr) {
    var isTruncated,
      r = new Ctor(1),

      // Max n of 9007199254740991 takes 53 loop iterations.
      // Maximum digits array length; leaves [28, 34] guard digits.
      k = Math.ceil(pr / LOG_BASE + 4);

    external = false;

    for (;;) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }

      n = mathfloor(n / 2);
      if (n === 0) {

        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }

      x = x.times(x);
      truncate(x.d, k);
    }

    external = true;

    return r;
  }


  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }


  /*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */
  function maxOrMin(Ctor, args, ltgt) {
    var y,
      x = new Ctor(args[0]),
      i = 0;

    for (; ++i < args.length;) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow, sum, t, wpr,
      rep = 0,
      i = 0,
      k = 0,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // 0/NaN/Infinity?
    if (!x.d || !x.d[0] || x.e > 17) {

      return new Ctor(x.d
        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
        : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125);

    // while abs(x) >= 0.1
    while (x.e > -2) {

      // x = x / 2^5
      x = x.times(t);
      k += 5;
    }

    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
    // necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(1);
    Ctor.precision = wpr;

    for (;;) {
      pow = finalise(pow.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum.plus(divide$1(pow, denominator, wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        j = k;
        while (j--) sum = finalise(sum.times(sum), wpr, 1);

        // Check to see if the first 4 rounding digits are [49]999.
        // If so, repeat the summation with a higher precision, otherwise
        // e.g. with precision: 18, rounding: 1
        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {

          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
    }
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
      n = 1,
      guard = 10,
      x = y,
      xd = x.d,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // Is x negative or Infinity, NaN, 0 or 1?
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);

    if (Math.abs(e = x.e) < 1.5e15) {

      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).

      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = x.e;

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {

      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;

      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }

    // x1 is x reduced to a value near 1.
    x1 = x;

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide$1(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;

    for (;;) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum.plus(divide$1(numerator, new Ctor(denominator), wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);

        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide$1(sum, new Ctor(n), wpr, 1);

        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
        // been repeated previously) and the first 4 rounding digits 9999?
        // If so, restart the summation with a higher precision, otherwise
        // e.g. with precision: 12, rounding: 1
        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {
          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide$1(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
      denominator += 2;
    }
  }


  // Infinity, NaN.
  function nonFiniteToString(x) {
    // Unsigned.
    return String(x.s * x.s / 0);
  }


  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */
  function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
    str = str.slice(i, len);

    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];

      // Transform base

      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) str += '0';
      x.d.push(+str);

      if (external) {

        // Overflow?
        if (x.e > x.constructor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < x.constructor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // x.constructor.underflow = true;
        } // else x.constructor.underflow = false;
      }
    } else {

      // Zero.
      x.e = 0;
      x.d = [0];
    }

    return x;
  }


  /*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

    if (str.indexOf('_') > -1) {
      str = str.replace(/(\d)_(?=\d)/g, '$1');
      if (isDecimal.test(str)) return parseDecimal(x, str);
    } else if (str === 'Infinity' || str === 'NaN') {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }

    if (isHex.test(str))  {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str))  {
      base = 2;
    } else if (isOctal.test(str))  {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }

    // Is there a binary exponent part?
    i = str.search(/p/i);

    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }

    // Convert `str` as an integer then divide the result by `base` raised to a power such that the
    // fraction part will be restored.
    i = str.indexOf('.');
    isFloat = i >= 0;
    Ctor = x.constructor;

    if (isFloat) {
      str = str.replace('.', '');
      len = str.length;
      i = len - i;

      // log[10](16) = 1.2041... , log[10](88) = 1.9444....
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }

    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;

    // Remove trailing zeros.
    for (i = xe; xd[i] === 0; --i) xd.pop();
    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;

    // At what precision to perform the division to ensure exact conversion?
    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
    // Therefore using 4 * the number of digits of str will always be enough.
    if (isFloat) x = divide$1(x, divisor, len * 4);

    // Multiply by the binary exponent part if present.
    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;

    return x;
  }


  /*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */
  function sine(Ctor, x) {
    var k,
      len = x.d.length;

    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }

    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);

    // Reverse argument reduction
    var sin2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }

    return x;
  }


  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2,
      pr = Ctor.precision,
      k = Math.ceil(pr / LOG_BASE);

    external = false;
    x2 = x.times(x);
    u = new Ctor(y);

    for (;;) {
      t = divide$1(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide$1(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);

      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--;);
        if (j == -1) break;
      }

      j = u;
      u = y;
      y = t;
      t = j;
    }

    external = true;
    t.d.length = k + 1;

    return t;
  }


  // Exponent e must be positive and non-zero.
  function tinyPow(b, e) {
    var n = b;
    while (--e) n *= b;
    return n;
  }


  // Return the absolute value of `x` reduced to less than or equal to half pi.
  function toLessThanHalfPi(Ctor, x) {
    var t,
      isNeg = x.s < 0,
      pi = getPi(Ctor, Ctor.precision, 1),
      halfPi = pi.times(0.5);

    x = x.abs();

    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }

    t = x.divToInt(pi);

    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));

      // 0 <= x < pi
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
        return x;
      }

      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
    }

    return x.minus(pi).abs();
  }


  /*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y,
      Ctor = x.constructor,
      isExp = sd !== void 0;

    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }

    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf('.');

      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
      // minBinaryExponent = floor(decimalExponent * log[2](10))
      // log[2](10) = 3.321928094887362347870319429489390175864

      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }

      // Convert the number as an integer then divide the result by its base raised to a power such
      // that the fraction part will be restored.

      // Non-integer.
      if (i >= 0) {
        str = str.replace('.', '');
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }

      xd = convertBase(str, 10, base);
      e = len = xd.length;

      // Remove trailing zeros.
      for (; xd[--len] == 0;) xd.pop();

      if (!xd[0]) {
        str = isExp ? '0p+0' : '0';
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide$1(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }

        // The rounding digit, i.e. the digit after the digit that may be rounded up.
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;

        roundUp = rm < 4
          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
            rm === (x.s < 0 ? 8 : 7));

        xd.length = sd;

        if (roundUp) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (; ++xd[--sd] > base - 1;) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }

        // Determine trailing zeros.
        for (len = xd.length; !xd[len - 1]; --len);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

        // Add binary exponent suffix?
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++) str += '0';
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len);

              // xd[0] will always be be 1
              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + '.' + str.slice(1);
            }
          }

          str =  str + (e < 0 ? 'p' : 'p+') + e;
        } else if (e < 0) {
          for (; ++e;) str = '0' + str;
          str = '0.' + str;
        } else {
          if (++e > len) for (e -= len; e-- ;) str += '0';
          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
        }
      }

      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
    }

    return x.s < 0 ? '-' + str : str;
  }


  // Does not strip trailing zeros.
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }


  // Decimal methods


  /*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clamp
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  set
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  sum
   *  tan
   *  tanh
   *  trunc
   */


  /*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function abs$1(x) {
    return new this(x).abs();
  }


  /*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function acos$1(x) {
    return new this(x).acos();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function acosh(x) {
    return new this(x).acosh();
  }


  /*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function add$1(x, y) {
    return new this(x).plus(y);
  }


  /*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function asin$2(x) {
    return new this(x).asin();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function asinh(x) {
    return new this(x).asinh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function atan$1(x) {
    return new this(x).atan();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function atanh(x) {
    return new this(x).atanh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(0, -0)               = pi
   * atan2(0, +0)               = 0
   * atan2(0, -x)               = pi for x > 0
   * atan2(0, x)                = 0 for x > 0
   * atan2(-y, 0)               = -pi/2 for y > 0
   * atan2(y, 0)                = pi/2 for y > 0
   * atan2(y, -Infinity)        = pi for finite y > 0
   * atan2(y, +Infinity)        = 0 for finite y > 0
   * atan2(Infinity, x)         = pi/2 for finite x
   * atan2(Infinity, -Infinity) = 3*pi/4
   * atan2(Infinity, +Infinity) = pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */
  function atan2$1(y, x) {
    y = new this(y);
    x = new this(x);
    var r,
      pr = this.precision,
      rm = this.rounding,
      wpr = pr + 4;

    // Either NaN
    if (!y.s || !x.s) {
      r = new this(NaN);

    // Both Infinity
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;

    // x is Infinity or y is 0
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;

    // y is Infinity or x is 0
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;

    // Both non-zero and finite
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide$1(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide$1(y, x, wpr, 1));
    }

    return r;
  }


  /*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function cbrt(x) {
    return new this(x).cbrt();
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }


  /*
   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
   *
   * x {number|string|Decimal}
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */
  function clamp(x, min, max) {
    return new this(x).clamp(min, max);
  }


  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number}
   *   defaults   {true}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */
  function config(obj) {
    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
    var i, p, v,
      useDefaults = obj.defaults === true,
      ps = [
        'precision', 1, MAX_DIGITS,
        'rounding', 0, 8,
        'toExpNeg', -EXP_LIMIT, 0,
        'toExpPos', 0, EXP_LIMIT,
        'maxE', 0, EXP_LIMIT,
        'minE', -EXP_LIMIT, 0,
        'modulo', 0, 9
      ];

    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != 'undefined' && crypto &&
            (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ': ' + v);
      }
    }

    return this;
  }


  /*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cos$3(x) {
    return new this(x).cos();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cosh(x) {
    return new this(x).cosh();
  }


  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */
  function clone(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(v) {
      var e, i, t,
        x = this;

      // Decimal called without new.
      if (!(x instanceof Decimal)) return new Decimal(v);

      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.
      x.constructor = Decimal;

      // Duplicate.
      if (isDecimalInstance(v)) {
        x.s = v.s;

        if (external) {
          if (!v.d || v.e > Decimal.maxE) {

            // Infinity.
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }

        return;
      }

      t = typeof v;

      if (t === 'number') {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }

        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }

        // Fast path for small integers.
        if (v === ~~v && v < 1e7) {
          for (e = 0, i = v; i >= 10; i /= 10) e++;

          if (external) {
            if (e > Decimal.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }

          return;

        // Infinity, NaN.
        } else if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }

        return parseDecimal(x, v.toString());

      } else if (t !== 'string') {
        throw Error(invalidArgument + v);
      }

      // Minus sign?
      if ((i = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        // Plus sign?
        if (i === 43) v = v.slice(1);
        x.s = 1;
      }

      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }

    Decimal.prototype = P;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;
    Decimal.EUCLID = 9;

    Decimal.config = Decimal.set = config;
    Decimal.clone = clone;
    Decimal.isDecimal = isDecimalInstance;

    Decimal.abs = abs$1;
    Decimal.acos = acos$1;
    Decimal.acosh = acosh;        // ES6
    Decimal.add = add$1;
    Decimal.asin = asin$2;
    Decimal.asinh = asinh;        // ES6
    Decimal.atan = atan$1;
    Decimal.atanh = atanh;        // ES6
    Decimal.atan2 = atan2$1;
    Decimal.cbrt = cbrt;          // ES6
    Decimal.ceil = ceil;
    Decimal.clamp = clamp;
    Decimal.cos = cos$3;
    Decimal.cosh = cosh;          // ES6
    Decimal.div = div;
    Decimal.exp = exp;
    Decimal.floor = floor;
    Decimal.hypot = hypot;        // ES6
    Decimal.ln = ln;
    Decimal.log = log;
    Decimal.log10 = log10;        // ES6
    Decimal.log2 = log2;          // ES6
    Decimal.max = max;
    Decimal.min = min;
    Decimal.mod = mod$1;
    Decimal.mul = mul;
    Decimal.pow = pow$1;
    Decimal.random = random;
    Decimal.round = round;
    Decimal.sign = sign$1;          // ES6
    Decimal.sin = sin$3;
    Decimal.sinh = sinh;          // ES6
    Decimal.sqrt = sqrt$1;
    Decimal.sub = sub;
    Decimal.sum = sum;
    Decimal.tan = tan$4;
    Decimal.tanh = tanh;          // ES6
    Decimal.trunc = trunc;        // ES6

    if (obj === void 0) obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
      }
    }

    Decimal.config(obj);

    return Decimal;
  }


  /*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function div(x, y) {
    return new this(x).div(y);
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */
  function exp(x) {
    return new this(x).exp();
  }


  /*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }


  /*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   * arguments {number|string|Decimal}
   *
   */
  function hypot() {
    var i, n,
      t = new this(0);

    external = false;

    for (i = 0; i < arguments.length;) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }

    external = true;

    return t.sqrt();
  }


  /*
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
   * otherwise return false.
   *
   */
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function ln(x) {
    return new this(x).ln();
  }


  /*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */
  function log(x, y) {
    return new this(x).log(y);
  }


  /*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log2(x) {
    return new this(x).log(2);
  }


  /*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log10(x) {
    return new this(x).log(10);
  }


  /*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function max() {
    return maxOrMin(this, arguments, 'lt');
  }


  /*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function min() {
    return maxOrMin(this, arguments, 'gt');
  }


  /*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mod$1(x, y) {
    return new this(x).mod(y);
  }


  /*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mul(x, y) {
    return new this(x).mul(y);
  }


  /*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */
  function pow$1(x, y) {
    return new this(x).pow(y);
  }


  /*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */
  function random(sd) {
    var d, e, k, n,
      i = 0,
      r = new this(1),
      rd = [];

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));

      for (; i < k;) {
        n = d[i];

        // 0 <= n < 4294967296
        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
        if (n >= 4.29e9) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {

          // 0 <= n <= 4289999999
          // 0 <= (n % 1e7) <= 9999999
          rd[i++] = n % 1e7;
        }
      }

    // Node.js supporting crypto.randomBytes.
    } else if (crypto.randomBytes) {

      // buffer
      d = crypto.randomBytes(k *= 4);

      for (; i < k;) {

        // 0 <= n < 2147483648
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
        if (n >= 2.14e9) {
          crypto.randomBytes(4).copy(d, i);
        } else {

          // 0 <= n <= 2139999999
          // 0 <= (n % 1e7) <= 9999999
          rd.push(n % 1e7);
          i += 4;
        }
      }

      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }

    k = rd[--i];
    sd %= LOG_BASE;

    // Convert trailing digits to zeros according to sd.
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }

    // Remove trailing words which are zero.
    for (; rd[i] === 0; i--) rd.pop();

    // Zero?
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;

      // Remove leading words which are zero and adjust exponent accordingly.
      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

      // Count the digits of the first word of rd to determine leading zeros.
      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

      // Adjust the exponent for leading zeros of the first word of rd.
      if (k < LOG_BASE) e -= LOG_BASE - k;
    }

    r.e = e;
    r.d = rd;

    return r;
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }


  /*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   * x {number|string|Decimal}
   *
   */
  function sign$1(x) {
    x = new this(x);
    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
  }


  /*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sin$3(x) {
    return new this(x).sin();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sinh(x) {
    return new this(x).sinh();
  }


  /*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function sqrt$1(x) {
    return new this(x).sqrt();
  }


  /*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function sub(x, y) {
    return new this(x).sub(y);
  }


  /*
   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * Only the result is rounded, not the intermediate calculations.
   *
   * arguments {number|string|Decimal}
   *
   */
  function sum() {
    var i = 0,
      args = arguments,
      x = new this(args[i]);

    external = false;
    for (; x.s && ++i < args.length;) x = x.plus(args[i]);
    external = true;

    return finalise(x, this.precision, this.rounding);
  }


  /*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tan$4(x) {
    return new this(x).tan();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tanh(x) {
    return new this(x).tanh();
  }


  /*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }


  P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
  P[Symbol.toStringTag] = 'Decimal';

  // Create and configure initial Decimal constructor.
  var Decimal = P.constructor = clone(DEFAULTS);

  // Create the internal constants from their string values.
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);

  var name$13 = 'BigNumber';
  var dependencies$13 = ['?on', 'config'];
  var createBigNumberClass = /* #__PURE__ */factory(name$13, dependencies$13, _ref => {
    var {
      on,
      config
    } = _ref;
    var BigNumber = Decimal.clone({
      precision: config.precision,
      modulo: Decimal.EUCLID
    });
    BigNumber.prototype = Object.create(BigNumber.prototype);
    /**
     * Attach type information
     */

    BigNumber.prototype.type = 'BigNumber';
    BigNumber.prototype.isBigNumber = true;
    /**
     * Get a JSON representation of a BigNumber containing
     * type information
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "BigNumber", "value": "0.2"}`
     */

    BigNumber.prototype.toJSON = function () {
      return {
        mathjs: 'BigNumber',
        value: this.toString()
      };
    };
    /**
     * Instantiate a BigNumber from a JSON object
     * @param {Object} json  a JSON object structured as:
     *                       `{"mathjs": "BigNumber", "value": "0.2"}`
     * @return {BigNumber}
     */

    BigNumber.fromJSON = function (json) {
      return new BigNumber(json.value);
    };
    if (on) {
      // listen for changed in the configuration, automatically apply changed precision
      on('config', function (curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber.config({
            precision: curr.precision
          });
        }
      });
    }
    return BigNumber;
  }, {
    isClass: true
  });

  var complex$1 = createCommonjsModule(function (module, exports) {
    /**
     * @license Complex.js v2.1.1 12/05/2020
     *
     * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/

    /**
     *
     * This class allows the manipulation of complex numbers.
     * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
     *
     * Object form
     * { re: <real>, im: <imaginary> }
     * { arg: <angle>, abs: <radius> }
     * { phi: <angle>, r: <radius> }
     *
     * Array / Vector form
     * [ real, imaginary ]
     *
     * Double form
     * 99.3 - Single double value
     *
     * String form
     * '23.1337' - Simple real number
     * '15+3i' - a simple complex number
     * '3-i' - a simple complex number
     *
     * Example:
     *
     * var c = new Complex('99.3+8i');
     * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
     *
     */

    (function (root) {

      var cosh = Math.cosh || function (x) {
        return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
      };
      var sinh = Math.sinh || function (x) {
        return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
      };

      /**
       * Calculates cos(x) - 1 using Taylor series if x is small (-  x  ).
       *
       * @param {number} x
       * @returns {number} cos(x) - 1
       */
      var cosm1 = function (x) {
        var b = Math.PI / 4;
        if (-b > x || x > b) {
          return Math.cos(x) - 1.0;
        }

        /* Calculate horner form of polynomial of taylor series in Q
        var fac = 1, alt = 1, pol = {};
        for (var i = 0; i <= 16; i++) {
          fac*= i || 1;
          if (i % 2 == 0) {
            pol[i] = new Fraction(1, alt * fac);
            alt = -alt;
          }
        }
        console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1
        */

        var xx = x * x;
        return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888000 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
      };
      var hypot = function (x, y) {
        var a = Math.abs(x);
        var b = Math.abs(y);
        if (a < 3000 && b < 3000) {
          return Math.sqrt(a * a + b * b);
        }
        if (a < b) {
          a = b;
          b = x / y;
        } else {
          b = y / x;
        }
        return a * Math.sqrt(1 + b * b);
      };
      var parser_exit = function () {
        throw SyntaxError('Invalid Param');
      };

      /**
       * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
       *
       * @param {number} a
       * @param {number} b
       * @returns {number}
       */
      function logHypot(a, b) {
        var _a = Math.abs(a);
        var _b = Math.abs(b);
        if (a === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3000 && _b < 3000) {
          return Math.log(a * a + b * b) * 0.5;
        }

        /* I got 4 ideas to compute this property without overflow:
         *
         * Testing 1000000 times with random samples for a,b  [1, 1000000000] against a big decimal library to get an error estimate
         *
         * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)
          Math.log(a * a + b * b) / 2
          *
         *
         * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)
          var fn = function(a, b) {
         a = Math.abs(a);
         b = Math.abs(b);
         var t = Math.min(a, b);
         a = Math.max(a, b);
         t = t / a;
          return Math.log(a) + Math.log(1 + t * t) / 2;
         };
          * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)
          Math.log(a / Math.cos(Math.atan2(b, a)))
          * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)
          Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))
          */

        a = a / 2;
        b = b / 2;
        return 0.5 * Math.log(a * a + b * b) + Math.LN2;
      }
      var parse = function (a, b) {
        var z = {
          're': 0,
          'im': 0
        };
        if (a === undefined || a === null) {
          z['re'] = z['im'] = 0;
        } else if (b !== undefined) {
          z['re'] = a;
          z['im'] = b;
        } else switch (typeof a) {
          case 'object':
            if ('im' in a && 're' in a) {
              z['re'] = a['re'];
              z['im'] = a['im'];
            } else if ('abs' in a && 'arg' in a) {
              if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
                return Complex['INFINITY'];
              }
              z['re'] = a['abs'] * Math.cos(a['arg']);
              z['im'] = a['abs'] * Math.sin(a['arg']);
            } else if ('r' in a && 'phi' in a) {
              if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
                return Complex['INFINITY'];
              }
              z['re'] = a['r'] * Math.cos(a['phi']);
              z['im'] = a['r'] * Math.sin(a['phi']);
            } else if (a.length === 2) {
              // Quick array check
              z['re'] = a[0];
              z['im'] = a[1];
            } else {
              parser_exit();
            }
            break;
          case 'string':
            z['im'] = /* void */
            z['re'] = 0;
            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;
            if (tokens === null) {
              parser_exit();
            }
            for (var i = 0; i < tokens.length; i++) {
              var c = tokens[i];
              if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
                plus++;
              } else if (c === '-') {
                minus++;
              } else if (c === 'i' || c === 'I') {
                if (plus + minus === 0) {
                  parser_exit();
                }
                if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                  i++;
                } else {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
                }
                plus = minus = 0;
              } else {
                if (plus + minus === 0 || isNaN(c)) {
                  parser_exit();
                }
                if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
                  i++;
                } else {
                  z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
                }
                plus = minus = 0;
              }
            }

            // Still something on the stack
            if (plus + minus > 0) {
              parser_exit();
            }
            break;
          case 'number':
            z['im'] = 0;
            z['re'] = a;
            break;
          default:
            parser_exit();
        }
        if (isNaN(z['re']) || isNaN(z['im'])) ;
        return z;
      };

      /**
       * @constructor
       * @returns {Complex}
       */
      function Complex(a, b) {
        if (!(this instanceof Complex)) {
          return new Complex(a, b);
        }
        var z = parse(a, b);
        this['re'] = z['re'];
        this['im'] = z['im'];
      }
      Complex.prototype = {
        're': 0,
        'im': 0,
        /**
         * Calculates the sign of a complex number, which is a normalized complex
         *
         * @returns {Complex}
         */
        'sign': function () {
          var abs = this['abs']();
          return new Complex(this['re'] / abs, this['im'] / abs);
        },
        /**
         * Adds two complex numbers
         *
         * @returns {Complex}
         */
        'add': function (a, b) {
          var z = new Complex(a, b);

          // Infinity + Infinity = NaN
          if (this['isInfinite']() && z['isInfinite']()) {
            return Complex['NAN'];
          }

          // Infinity + z = Infinity { where z != Infinity }
          if (this['isInfinite']() || z['isInfinite']()) {
            return Complex['INFINITY'];
          }
          return new Complex(this['re'] + z['re'], this['im'] + z['im']);
        },
        /**
         * Subtracts two complex numbers
         *
         * @returns {Complex}
         */
        'sub': function (a, b) {
          var z = new Complex(a, b);

          // Infinity - Infinity = NaN
          if (this['isInfinite']() && z['isInfinite']()) {
            return Complex['NAN'];
          }

          // Infinity - z = Infinity { where z != Infinity }
          if (this['isInfinite']() || z['isInfinite']()) {
            return Complex['INFINITY'];
          }
          return new Complex(this['re'] - z['re'], this['im'] - z['im']);
        },
        /**
         * Multiplies two complex numbers
         *
         * @returns {Complex}
         */
        'mul': function (a, b) {
          var z = new Complex(a, b);

          // Infinity * 0 = NaN
          if (this['isInfinite']() && z['isZero']() || this['isZero']() && z['isInfinite']()) {
            return Complex['NAN'];
          }

          // Infinity * z = Infinity { where z != 0 }
          if (this['isInfinite']() || z['isInfinite']()) {
            return Complex['INFINITY'];
          }

          // Short circuit for real values
          if (z['im'] === 0 && this['im'] === 0) {
            return new Complex(this['re'] * z['re'], 0);
          }
          return new Complex(this['re'] * z['re'] - this['im'] * z['im'], this['re'] * z['im'] + this['im'] * z['re']);
        },
        /**
         * Divides two complex numbers
         *
         * @returns {Complex}
         */
        'div': function (a, b) {
          var z = new Complex(a, b);

          // 0 / 0 = NaN and Infinity / Infinity = NaN
          if (this['isZero']() && z['isZero']() || this['isInfinite']() && z['isInfinite']()) {
            return Complex['NAN'];
          }

          // Infinity / 0 = Infinity
          if (this['isInfinite']() || z['isZero']()) {
            return Complex['INFINITY'];
          }

          // 0 / Infinity = 0
          if (this['isZero']() || z['isInfinite']()) {
            return Complex['ZERO'];
          }
          a = this['re'];
          b = this['im'];
          var c = z['re'];
          var d = z['im'];
          var t, x;
          if (0 === d) {
            // Divisor is real
            return new Complex(a / c, b / c);
          }
          if (Math.abs(c) < Math.abs(d)) {
            x = c / d;
            t = c * x + d;
            return new Complex((a * x + b) / t, (b * x - a) / t);
          } else {
            x = d / c;
            t = d * x + c;
            return new Complex((a + b * x) / t, (b - a * x) / t);
          }
        },
        /**
         * Calculate the power of two complex numbers
         *
         * @returns {Complex}
         */
        'pow': function (a, b) {
          var z = new Complex(a, b);
          a = this['re'];
          b = this['im'];
          if (z['isZero']()) {
            return Complex['ONE'];
          }

          // If the exponent is real
          if (z['im'] === 0) {
            if (b === 0 && a > 0) {
              return new Complex(Math.pow(a, z['re']), 0);
            } else if (a === 0) {
              // If base is fully imaginary

              switch ((z['re'] % 4 + 4) % 4) {
                case 0:
                  return new Complex(Math.pow(b, z['re']), 0);
                case 1:
                  return new Complex(0, Math.pow(b, z['re']));
                case 2:
                  return new Complex(-Math.pow(b, z['re']), 0);
                case 3:
                  return new Complex(0, -Math.pow(b, z['re']));
              }
            }
          }

          /* I couldn't find a good formula, so here is a derivation and optimization
           *
           * z_1^z_2 = (a + bi)^(c + di)
           *         = exp((c + di) * log(a + bi)
           *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
           * =>...
           * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
           * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
           *
           * =>...
           * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
           * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
           *
           * =>
           * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
           * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
           *
           */

          if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
            return Complex['ZERO'];
          }
          var arg = Math.atan2(b, a);
          var loh = logHypot(a, b);
          a = Math.exp(z['re'] * loh - z['im'] * arg);
          b = z['im'] * loh + z['re'] * arg;
          return new Complex(a * Math.cos(b), a * Math.sin(b));
        },
        /**
         * Calculate the complex square root
         *
         * @returns {Complex}
         */
        'sqrt': function () {
          var a = this['re'];
          var b = this['im'];
          var r = this['abs']();
          var re, im;
          if (a >= 0) {
            if (b === 0) {
              return new Complex(Math.sqrt(a), 0);
            }
            re = 0.5 * Math.sqrt(2.0 * (r + a));
          } else {
            re = Math.abs(b) / Math.sqrt(2 * (r - a));
          }
          if (a <= 0) {
            im = 0.5 * Math.sqrt(2.0 * (r - a));
          } else {
            im = Math.abs(b) / Math.sqrt(2 * (r + a));
          }
          return new Complex(re, b < 0 ? -im : im);
        },
        /**
         * Calculate the complex exponent
         *
         * @returns {Complex}
         */
        'exp': function () {
          var tmp = Math.exp(this['re']);
          if (this['im'] === 0) ;
          return new Complex(tmp * Math.cos(this['im']), tmp * Math.sin(this['im']));
        },
        /**
         * Calculate the complex exponent and subtracts one.
         *
         * This may be more accurate than `Complex(x).exp().sub(1)` if
         * `x` is small.
         *
         * @returns {Complex}
         */
        'expm1': function () {
          /**
           * exp(a + i*b) - 1
           = exp(a) * (cos(b) + j*sin(b)) - 1
           = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
           */

          var a = this['re'];
          var b = this['im'];
          return new Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
        },
        /**
         * Calculate the natural log
         *
         * @returns {Complex}
         */
        'log': function () {
          var a = this['re'];
          var b = this['im'];
          return new Complex(logHypot(a, b), Math.atan2(b, a));
        },
        /**
         * Calculate the magnitude of the complex number
         *
         * @returns {number}
         */
        'abs': function () {
          return hypot(this['re'], this['im']);
        },
        /**
         * Calculate the angle of the complex number
         *
         * @returns {number}
         */
        'arg': function () {
          return Math.atan2(this['im'], this['re']);
        },
        /**
         * Calculate the sine of the complex number
         *
         * @returns {Complex}
         */
        'sin': function () {
          // sin(z) = ( e^iz - e^-iz ) / 2i 
          //        = sin(a)cosh(b) + i cos(a)sinh(b)

          var a = this['re'];
          var b = this['im'];
          return new Complex(Math.sin(a) * cosh(b), Math.cos(a) * sinh(b));
        },
        /**
         * Calculate the cosine
         *
         * @returns {Complex}
         */
        'cos': function () {
          // cos(z) = ( e^iz + e^-iz ) / 2 
          //        = cos(a)cosh(b) - i sin(a)sinh(b)

          var a = this['re'];
          var b = this['im'];
          return new Complex(Math.cos(a) * cosh(b), -Math.sin(a) * sinh(b));
        },
        /**
         * Calculate the tangent
         *
         * @returns {Complex}
         */
        'tan': function () {
          // tan(z) = sin(z) / cos(z) 
          //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )
          //        = ( e^2iz - 1 ) / i( e^2iz + 1 )
          //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = Math.cos(a) + cosh(b);
          return new Complex(Math.sin(a) / d, sinh(b) / d);
        },
        /**
         * Calculate the cotangent
         *
         * @returns {Complex}
         */
        'cot': function () {
          // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = Math.cos(a) - cosh(b);
          return new Complex(-Math.sin(a) / d, sinh(b) / d);
        },
        /**
         * Calculate the secant
         *
         * @returns {Complex}
         */
        'sec': function () {
          // sec(c) = 2 / (e^(ci) + e^(-ci))

          var a = this['re'];
          var b = this['im'];
          var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);
          return new Complex(Math.cos(a) * cosh(b) / d, Math.sin(a) * sinh(b) / d);
        },
        /**
         * Calculate the cosecans
         *
         * @returns {Complex}
         */
        'csc': function () {
          // csc(c) = 2i / (e^(ci) - e^(-ci))

          var a = this['re'];
          var b = this['im'];
          var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);
          return new Complex(Math.sin(a) * cosh(b) / d, -Math.cos(a) * sinh(b) / d);
        },
        /**
         * Calculate the complex arcus sinus
         *
         * @returns {Complex}
         */
        'asin': function () {
          // asin(c) = -i * log(ci + sqrt(1 - c^2))

          var a = this['re'];
          var b = this['im'];
          var t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();
          var t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();
          return new Complex(t2['im'], -t2['re']);
        },
        /**
         * Calculate the complex arcus cosinus
         *
         * @returns {Complex}
         */
        'acos': function () {
          // acos(c) = i * log(c - i * sqrt(1 - c^2))

          var a = this['re'];
          var b = this['im'];
          var t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();
          var t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();
          return new Complex(Math.PI / 2 - t2['im'], t2['re']);
        },
        /**
         * Calculate the complex arcus tangent
         *
         * @returns {Complex}
         */
        'atan': function () {
          // atan(c) = i / 2 log((i + x) / (i - x))

          var a = this['re'];
          var b = this['im'];
          if (a === 0) {
            if (b === 1) {
              return new Complex(0, Infinity);
            }
            if (b === -1) {
              return new Complex(0, -Infinity);
            }
          }
          var d = a * a + (1.0 - b) * (1.0 - b);
          var t1 = new Complex((1 - b * b - a * a) / d, -2 * a / d).log();
          return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
        },
        /**
         * Calculate the complex arcus cotangent
         *
         * @returns {Complex}
         */
        'acot': function () {
          // acot(c) = i / 2 log((c - i) / (c + i))

          var a = this['re'];
          var b = this['im'];
          if (b === 0) {
            return new Complex(Math.atan2(1, a), 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex(a / d, -b / d).atan() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
        },
        /**
         * Calculate the complex arcus secant
         *
         * @returns {Complex}
         */
        'asec': function () {
          // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

          var a = this['re'];
          var b = this['im'];
          if (a === 0 && b === 0) {
            return new Complex(0, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex(a / d, -b / d).acos() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
        },
        /**
         * Calculate the complex arcus cosecans
         *
         * @returns {Complex}
         */
        'acsc': function () {
          // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

          var a = this['re'];
          var b = this['im'];
          if (a === 0 && b === 0) {
            return new Complex(Math.PI / 2, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex(a / d, -b / d).asin() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
        },
        /**
         * Calculate the complex sinh
         *
         * @returns {Complex}
         */
        'sinh': function () {
          // sinh(c) = (e^c - e^-c) / 2

          var a = this['re'];
          var b = this['im'];
          return new Complex(sinh(a) * Math.cos(b), cosh(a) * Math.sin(b));
        },
        /**
         * Calculate the complex cosh
         *
         * @returns {Complex}
         */
        'cosh': function () {
          // cosh(c) = (e^c + e^-c) / 2

          var a = this['re'];
          var b = this['im'];
          return new Complex(cosh(a) * Math.cos(b), sinh(a) * Math.sin(b));
        },
        /**
         * Calculate the complex tanh
         *
         * @returns {Complex}
         */
        'tanh': function () {
          // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = cosh(a) + Math.cos(b);
          return new Complex(sinh(a) / d, Math.sin(b) / d);
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        'coth': function () {
          // coth(c) = (e^c + e^-c) / (e^c - e^-c)

          var a = 2 * this['re'];
          var b = 2 * this['im'];
          var d = cosh(a) - Math.cos(b);
          return new Complex(sinh(a) / d, -Math.sin(b) / d);
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        'csch': function () {
          // csch(c) = 2 / (e^c - e^-c)

          var a = this['re'];
          var b = this['im'];
          var d = Math.cos(2 * b) - cosh(2 * a);
          return new Complex(-2 * sinh(a) * Math.cos(b) / d, 2 * cosh(a) * Math.sin(b) / d);
        },
        /**
         * Calculate the complex sech
         *
         * @returns {Complex}
         */
        'sech': function () {
          // sech(c) = 2 / (e^c + e^-c)

          var a = this['re'];
          var b = this['im'];
          var d = Math.cos(2 * b) + cosh(2 * a);
          return new Complex(2 * cosh(a) * Math.cos(b) / d, -2 * sinh(a) * Math.sin(b) / d);
        },
        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        'asinh': function () {
          // asinh(c) = log(c + sqrt(c^2 + 1))

          var tmp = this['im'];
          this['im'] = -this['re'];
          this['re'] = tmp;
          var res = this['asin']();
          this['re'] = -this['im'];
          this['im'] = tmp;
          tmp = res['re'];
          res['re'] = -res['im'];
          res['im'] = tmp;
          return res;
        },
        /**
         * Calculate the complex acosh
         *
         * @returns {Complex}
         */
        'acosh': function () {
          // acosh(c) = log(c + sqrt(c^2 - 1))

          var res = this['acos']();
          if (res['im'] <= 0) {
            var tmp = res['re'];
            res['re'] = -res['im'];
            res['im'] = tmp;
          } else {
            var tmp = res['im'];
            res['im'] = -res['re'];
            res['re'] = tmp;
          }
          return res;
        },
        /**
         * Calculate the complex atanh
         *
         * @returns {Complex}
         */
        'atanh': function () {
          // atanh(c) = log((1+c) / (1-c)) / 2

          var a = this['re'];
          var b = this['im'];
          var noIM = a > 1 && b === 0;
          var oneMinus = 1 - a;
          var onePlus = 1 + a;
          var d = oneMinus * oneMinus + b * b;
          var x = d !== 0 ? new Complex((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
          var temp = x['re'];
          x['re'] = logHypot(x['re'], x['im']) / 2;
          x['im'] = Math.atan2(x['im'], temp) / 2;
          if (noIM) {
            x['im'] = -x['im'];
          }
          return x;
        },
        /**
         * Calculate the complex acoth
         *
         * @returns {Complex}
         */
        'acoth': function () {
          // acoth(c) = log((c+1) / (c-1)) / 2

          var a = this['re'];
          var b = this['im'];
          if (a === 0 && b === 0) {
            return new Complex(0, Math.PI / 2);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex(a / d, -b / d).atanh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
        },
        /**
         * Calculate the complex acsch
         *
         * @returns {Complex}
         */
        'acsch': function () {
          // acsch(c) = log((1+sqrt(1+c^2))/c)

          var a = this['re'];
          var b = this['im'];
          if (b === 0) {
            return new Complex(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex(a / d, -b / d).asinh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
        },
        /**
         * Calculate the complex asech
         *
         * @returns {Complex}
         */
        'asech': function () {
          // asech(c) = log((1+sqrt(1-c^2))/c)

          var a = this['re'];
          var b = this['im'];
          if (this['isZero']()) {
            return Complex['INFINITY'];
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex(a / d, -b / d).acosh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
        },
        /**
         * Calculate the complex inverse 1/z
         *
         * @returns {Complex}
         */
        'inverse': function () {
          // 1 / 0 = Infinity and 1 / Infinity = 0
          if (this['isZero']()) {
            return Complex['INFINITY'];
          }
          if (this['isInfinite']()) {
            return Complex['ZERO'];
          }
          var a = this['re'];
          var b = this['im'];
          var d = a * a + b * b;
          return new Complex(a / d, -b / d);
        },
        /**
         * Returns the complex conjugate
         *
         * @returns {Complex}
         */
        'conjugate': function () {
          return new Complex(this['re'], -this['im']);
        },
        /**
         * Gets the negated complex number
         *
         * @returns {Complex}
         */
        'neg': function () {
          return new Complex(-this['re'], -this['im']);
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        'ceil': function (places) {
          places = Math.pow(10, places || 0);
          return new Complex(Math.ceil(this['re'] * places) / places, Math.ceil(this['im'] * places) / places);
        },
        /**
         * Floors the actual complex number
         *
         * @returns {Complex}
         */
        'floor': function (places) {
          places = Math.pow(10, places || 0);
          return new Complex(Math.floor(this['re'] * places) / places, Math.floor(this['im'] * places) / places);
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        'round': function (places) {
          places = Math.pow(10, places || 0);
          return new Complex(Math.round(this['re'] * places) / places, Math.round(this['im'] * places) / places);
        },
        /**
         * Compares two complex numbers
         *
         * **Note:** new Complex(Infinity).equals(Infinity) === false
         *
         * @returns {boolean}
         */
        'equals': function (a, b) {
          var z = new Complex(a, b);
          return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] && Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
        },
        /**
         * Clones the actual object
         *
         * @returns {Complex}
         */
        'clone': function () {
          return new Complex(this['re'], this['im']);
        },
        /**
         * Gets a string of the actual complex number
         *
         * @returns {string}
         */
        'toString': function () {
          var a = this['re'];
          var b = this['im'];
          var ret = "";
          if (this['isNaN']()) {
            return 'NaN';
          }
          if (this['isInfinite']()) {
            return 'Infinity';
          }
          if (Math.abs(a) < Complex['EPSILON']) {
            a = 0;
          }
          if (Math.abs(b) < Complex['EPSILON']) {
            b = 0;
          }

          // If is real number
          if (b === 0) {
            return ret + a;
          }
          if (a !== 0) {
            ret += a;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (1 !== b) {
            // b is the absolute imaginary part
            ret += b;
          }
          return ret + "i";
        },
        /**
         * Returns the actual number as a vector
         *
         * @returns {Array}
         */
        'toVector': function () {
          return [this['re'], this['im']];
        },
        /**
         * Returns the actual real value of the current object
         *
         * @returns {number|null}
         */
        'valueOf': function () {
          if (this['im'] === 0) {
            return this['re'];
          }
          return null;
        },
        /**
         * Determines whether a complex number is not on the Riemann sphere.
         *
         * @returns {boolean}
         */
        'isNaN': function () {
          return isNaN(this['re']) || isNaN(this['im']);
        },
        /**
         * Determines whether or not a complex number is at the zero pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        'isZero': function () {
          return this['im'] === 0 && this['re'] === 0;
        },
        /**
         * Determines whether a complex number is not at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        'isFinite': function () {
          return isFinite(this['re']) && isFinite(this['im']);
        },
        /**
         * Determines whether or not a complex number is at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        'isInfinite': function () {
          return !(this['isNaN']() || this['isFinite']());
        }
      };
      Complex['ZERO'] = new Complex(0, 0);
      Complex['ONE'] = new Complex(1, 0);
      Complex['I'] = new Complex(0, 1);
      Complex['PI'] = new Complex(Math.PI, 0);
      Complex['E'] = new Complex(Math.E, 0);
      Complex['INFINITY'] = new Complex(Infinity, Infinity);
      Complex['NAN'] = new Complex(NaN, NaN);
      Complex['EPSILON'] = 1e-15;
      {
        Object.defineProperty(Complex, "__esModule", {
          'value': true
        });
        Complex['default'] = Complex;
        Complex['Complex'] = Complex;
        module['exports'] = Complex;
      }
    })();
  });
  var Complex$1 = /*@__PURE__*/getDefaultExportFromCjs(complex$1);

  var name$12 = 'Complex';
  var dependencies$12 = [];
  var createComplexClass = /* #__PURE__ */factory(name$12, dependencies$12, () => {
    /**
     * Attach type information
     */
    Complex$1.prototype.type = 'Complex';
    Complex$1.prototype.isComplex = true;
    /**
     * Get a JSON representation of the complex number
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
     */

    Complex$1.prototype.toJSON = function () {
      return {
        mathjs: 'Complex',
        re: this.re,
        im: this.im
      };
    };
    /*
     * Return the value of the complex number in polar notation
     * The angle phi will be set in the interval of [-pi, pi].
     * @return {{r: number, phi: number}} Returns and object with properties r and phi.
     */

    Complex$1.prototype.toPolar = function () {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    /**
     * Get a string representation of the complex number,
     * with optional formatting options.
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @return {string} str
     */

    Complex$1.prototype.format = function (options) {
      var str = '';
      var im = this.im;
      var re = this.re;
      var strRe = format$2(this.re, options);
      var strIm = format$2(this.im, options); // round either re or im when smaller than the configured precision

      var precision = isNumber(options) ? options : options ? options.precision : null;
      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);
        if (Math.abs(re / im) < epsilon) {
          re = 0;
        }
        if (Math.abs(im / re) < epsilon) {
          im = 0;
        }
      }
      if (im === 0) {
        // real value
        str = strRe;
      } else if (re === 0) {
        // purely complex value
        if (im === 1) {
          str = 'i';
        } else if (im === -1) {
          str = '-i';
        } else {
          str = strIm + 'i';
        }
      } else {
        // complex value
        if (im < 0) {
          if (im === -1) {
            str = strRe + ' - i';
          } else {
            str = strRe + ' - ' + strIm.substring(1) + 'i';
          }
        } else {
          if (im === 1) {
            str = strRe + ' + i';
          } else {
            str = strRe + ' + ' + strIm + 'i';
          }
        }
      }
      return str;
    };
    /**
     * Create a complex number from polar coordinates
     *
     * Usage:
     *
     *     Complex.fromPolar(r: number, phi: number) : Complex
     *     Complex.fromPolar({r: number, phi: number}) : Complex
     *
     * @param {*} args...
     * @return {Complex}
     */

    Complex$1.fromPolar = function (args) {
      switch (arguments.length) {
        case 1:
          {
            var arg = arguments[0];
            if (typeof arg === 'object') {
              return Complex$1(arg);
            } else {
              throw new TypeError('Input has to be an object with r and phi keys.');
            }
          }
        case 2:
          {
            var r = arguments[0];
            var phi = arguments[1];
            if (isNumber(r)) {
              if (isUnit(phi) && phi.hasBase('ANGLE')) {
                // convert unit to a number in radians
                phi = phi.toNumber('rad');
              }
              if (isNumber(phi)) {
                return new Complex$1({
                  r,
                  phi
                });
              }
              throw new TypeError('Phi is not a number nor an angle unit.');
            } else {
              throw new TypeError('Radius r is not a number.');
            }
          }
        default:
          throw new SyntaxError('Wrong number of arguments in function fromPolar');
      }
    };
    Complex$1.prototype.valueOf = Complex$1.prototype.toString;
    /**
     * Create a Complex number from a JSON object
     * @param {Object} json  A JSON Object structured as
     *                       {"mathjs": "Complex", "re": 2, "im": 3}
     *                       All properties are optional, default values
     *                       for `re` and `im` are 0.
     * @return {Complex} Returns a new Complex number
     */

    Complex$1.fromJSON = function (json) {
      return new Complex$1(json);
    };
    /**
     * Compare two complex numbers, `a` and `b`:
     *
     * - Returns 1 when the real part of `a` is larger than the real part of `b`
     * - Returns -1 when the real part of `a` is smaller than the real part of `b`
     * - Returns 1 when the real parts are equal
     *   and the imaginary part of `a` is larger than the imaginary part of `b`
     * - Returns -1 when the real parts are equal
     *   and the imaginary part of `a` is smaller than the imaginary part of `b`
     * - Returns 0 when both real and imaginary parts are equal.
     *
     * @params {Complex} a
     * @params {Complex} b
     * @returns {number} Returns the comparison result: -1, 0, or 1
     */

    Complex$1.compare = function (a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return Complex$1;
  }, {
    isClass: true
  });

  var fraction$1 = createCommonjsModule(function (module, exports) {
    /**
     * @license Fraction.js v4.2.0 05/03/2022
     * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
     *
     * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **/

    /**
     *
     * This class offers the possibility to calculate fractions.
     * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
     *
     * Array/Object form
     * [ 0 => <nominator>, 1 => <denominator> ]
     * [ n => <nominator>, d => <denominator> ]
     *
     * Integer form
     * - Single integer value
     *
     * Double form
     * - Single double value
     *
     * String form
     * 123.456 - a simple double
     * 123/456 - a string fraction
     * 123.'456' - a double with repeating decimal places
     * 123.(456) - synonym
     * 123.45'6' - a double with repeating last place
     * 123.45(6) - synonym
     *
     * Example:
     *
     * var f = new Fraction("9.4'31'");
     * f.mul([-4, 3]).div(4.9);
     *
     */

    (function (root) {

      // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
      // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
      // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
      var MAX_CYCLE_LEN = 2000;

      // Parsed data to avoid calling "new" all the time
      var P = {
        "s": 1,
        "n": 0,
        "d": 1
      };
      function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
          throw Fraction['InvalidParameter'];
        }
        return n * s;
      }

      // Creates a new Fraction internally without the need of the bulky constructor
      function newFraction(n, d) {
        if (d === 0) {
          throw Fraction['DivisionByZero'];
        }
        var f = Object.create(Fraction.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a = gcd(n, d);
        f["n"] = n / a;
        f["d"] = d / a;
        return f;
      }
      function factorize(num) {
        var factors = {};
        var n = num;
        var i = 2;
        var s = 4;
        while (s <= n) {
          while (n % i === 0) {
            n /= i;
            factors[i] = (factors[i] || 0) + 1;
          }
          s += 1 + 2 * i++;
        }
        if (n !== num) {
          if (n > 1) factors[n] = (factors[n] || 0) + 1;
        } else {
          factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
      }
      var parse = function (p1, p2) {
        var n = 0,
          d = 1,
          s = 1;
        var v = 0,
          w = 0,
          x = 0,
          y = 1,
          z = 1;
        var A = 0,
          B = 1;
        var C = 1,
          D = 1;
        var N = 10000000;
        var M;
        if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) {
          n = p1;
          d = p2;
          s = n * d;
          if (n % 1 !== 0 || d % 1 !== 0) {
            throw Fraction['NonIntegerParameter'];
          }
        } else switch (typeof p1) {
          case "object":
            {
              if ("d" in p1 && "n" in p1) {
                n = p1["n"];
                d = p1["d"];
                if ("s" in p1) n *= p1["s"];
              } else if (0 in p1) {
                n = p1[0];
                if (1 in p1) d = p1[1];
              } else {
                throw Fraction['InvalidParameter'];
              }
              s = n * d;
              break;
            }
          case "number":
            {
              if (p1 < 0) {
                s = p1;
                p1 = -p1;
              }
              if (p1 % 1 === 0) {
                n = p1;
              } else if (p1 > 0) {
                // check for != 0, scale would become NaN (log(0)), which converges really slow

                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }

                // Using Farey Sequences
                // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

                while (B <= N && D <= N) {
                  M = (A + C) / (B + D);
                  if (p1 === M) {
                    if (B + D <= N) {
                      n = A + C;
                      d = B + D;
                    } else if (D > B) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                    break;
                  } else {
                    if (p1 > M) {
                      A += C;
                      B += D;
                    } else {
                      C += A;
                      D += B;
                    }
                    if (B > N) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                  }
                }
                n *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d = n = NaN;
              }
              break;
            }
          case "string":
            {
              B = p1.match(/\d+|./g);
              if (B === null) throw Fraction['InvalidParameter'];
              if (B[A] === '-') {
                // Check for minus sign at the beginning
                s = -1;
                A++;
              } else if (B[A] === '+') {
                // Check for plus sign at the beginning
                A++;
              }
              if (B.length === A + 1) {
                // Check if it's just a simple number "1234"
                w = assign(B[A++], s);
              } else if (B[A + 1] === '.' || B[A] === '.') {
                // Check if it's a decimal number

                if (B[A] !== '.') {
                  // Handle 0.5 and .5
                  v = assign(B[A++], s);
                }
                A++;

                // Check for decimal places
                if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                  w = assign(B[A], s);
                  y = Math.pow(10, B[A].length);
                  A++;
                }

                // Check for repeating places
                if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                  x = assign(B[A + 1], s);
                  z = Math.pow(10, B[A + 1].length) - 1;
                  A += 3;
                }
              } else if (B[A + 1] === '/' || B[A + 1] === ':') {
                // Check for a simple fraction "123/456" or "123:456"
                w = assign(B[A], s);
                y = assign(B[A + 2], 1);
                A += 3;
              } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
                // Check for a complex fraction "123 1/2"
                v = assign(B[A], s);
                w = assign(B[A + 2], s);
                y = assign(B[A + 4], 1);
                A += 5;
              }
              if (B.length <= A) {
                // Check for more tokens on the stack
                d = y * z;
                s = /* void */
                n = x + d * v + z * w;
                break;
              }

              /* Fall through on error */
            }

          default:
            throw Fraction['InvalidParameter'];
        }
        if (d === 0) {
          throw Fraction['DivisionByZero'];
        }
        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
      };
      function modpow(b, e, m) {
        var r = 1;
        for (; e > 0; b = b * b % m, e >>= 1) {
          if (e & 1) {
            r = r * b % m;
          }
        }
        return r;
      }
      function cycleLen(n, d) {
        for (; d % 2 === 0; d /= 2) {}
        for (; d % 5 === 0; d /= 5) {}
        if (d === 1)
          // Catch non-cyclic numbers
          return 0;

        // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
        // 10^(d-1) % d == 1
        // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
        // as we want to translate the numbers to strings.

        var rem = 10 % d;
        var t = 1;
        for (; rem !== 1; t++) {
          rem = rem * 10 % d;
          if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
        }

        return t;
      }
      function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for (var t = 0; t < 300; t++) {
          // s < ~log10(Number.MAX_VALUE)
          // Solve 10^s == 10^(s+t) (mod d)

          if (rem1 === rem2) return t;
          rem1 = rem1 * 10 % d;
          rem2 = rem2 * 10 % d;
        }
        return 0;
      }
      function gcd(a, b) {
        if (!a) return b;
        if (!b) return a;
        while (1) {
          a %= b;
          if (!a) return b;
          b %= a;
          if (!b) return a;
        }
      }

      /**
       * Module constructor
       *
       * @constructor
       * @param {number|Fraction=} a
       * @param {number=} b
       */
      function Fraction(a, b) {
        parse(a, b);
        if (this instanceof Fraction) {
          a = gcd(P["d"], P["n"]); // Abuse variable a
          this["s"] = P["s"];
          this["n"] = P["n"] / a;
          this["d"] = P["d"] / a;
        } else {
          return newFraction(P['s'] * P['n'], P['d']);
        }
      }
      Fraction['DivisionByZero'] = new Error("Division by Zero");
      Fraction['InvalidParameter'] = new Error("Invalid argument");
      Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");
      Fraction.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
         * Calculates the absolute value
         *
         * Ex: new Fraction(-4).abs() => 4
         **/
        "abs": function () {
          return newFraction(this["n"], this["d"]);
        },
        /**
         * Inverts the sign of the current fraction
         *
         * Ex: new Fraction(-4).neg() => 4
         **/
        "neg": function () {
          return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
         * Adds two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
         **/
        "add": function (a, b) {
          parse(a, b);
          return newFraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
         * Subtracts two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
         **/
        "sub": function (a, b) {
          parse(a, b);
          return newFraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
         * Multiplies two rational numbers
         *
         * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
         **/
        "mul": function (a, b) {
          parse(a, b);
          return newFraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
        },
        /**
         * Divides two rational numbers
         *
         * Ex: new Fraction("-17.(345)").inverse().div(3)
         **/
        "div": function (a, b) {
          parse(a, b);
          return newFraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
        },
        /**
         * Clones the actual object
         *
         * Ex: new Fraction("-17.(345)").clone()
         **/
        "clone": function () {
          return newFraction(this['s'] * this['n'], this['d']);
        },
        /**
         * Calculates the modulo of two rational numbers - a more precise fmod
         *
         * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
         **/
        "mod": function (a, b) {
          if (isNaN(this['n']) || isNaN(this['d'])) {
            return new Fraction(NaN);
          }
          if (a === undefined) {
            return newFraction(this["s"] * this["n"] % this["d"], 1);
          }
          parse(a, b);
          if (0 === P["n"] && 0 === this["d"]) {
            throw Fraction['DivisionByZero'];
          }

          /*
           * First silly attempt, kinda slow
           *
           return that["sub"]({
           "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
           "d": num["d"],
           "s": this["s"]
           });*/

          /*
           * New attempt: a1 / b1 = a2 / b2 * q + r
           * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
           * => (b2 * a1 % a2 * b1) / (b1 * b2)
           */
          return newFraction(this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]), P["d"] * this["d"]);
        },
        /**
         * Calculates the fractional gcd of two rational numbers
         *
         * Ex: new Fraction(5,8).gcd(3,7) => 1/56
         */
        "gcd": function (a, b) {
          parse(a, b);

          // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

          return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
        },
        /**
         * Calculates the fractional lcm of two rational numbers
         *
         * Ex: new Fraction(5,8).lcm(3,7) => 15
         */
        "lcm": function (a, b) {
          parse(a, b);

          // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

          if (P["n"] === 0 && this["n"] === 0) {
            return newFraction(0, 1);
          }
          return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
        },
        /**
         * Calculates the ceil of a rational number
         *
         * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
         **/
        "ceil": function (places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Calculates the floor of a rational number
         *
         * Ex: new Fraction('4.(3)').floor() => (4 / 1)
         **/
        "floor": function (places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Rounds a rational numbers
         *
         * Ex: new Fraction('4.(3)').round() => (4 / 1)
         **/
        "round": function (places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Gets the inverse of the fraction, means numerator and denominator are exchanged
         *
         * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
         **/
        "inverse": function () {
          return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
         * Calculates the fraction to some rational exponent, if possible
         *
         * Ex: new Fraction(-1,2).pow(-3) => -8
         */
        "pow": function (a, b) {
          parse(a, b);

          // Trivial case when exp is an integer

          if (P['d'] === 1) {
            if (P['s'] < 0) {
              return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
            } else {
              return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
            }
          }

          // Negative roots become complex
          //     (-a/b)^(c/d) = x
          // <=> (-1)^(c/d) * (a/b)^(c/d) = x
          // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180
          // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
          // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
          if (this['s'] < 0) return null;

          // Now prime factor n and d
          var N = factorize(this['n']);
          var D = factorize(this['d']);

          // Exponentiate and take root for n and d individually
          var n = 1;
          var d = 1;
          for (var k in N) {
            if (k === '1') continue;
            if (k === '0') {
              n = 0;
              break;
            }
            N[k] *= P['n'];
            if (N[k] % P['d'] === 0) {
              N[k] /= P['d'];
            } else return null;
            n *= Math.pow(k, N[k]);
          }
          for (var k in D) {
            if (k === '1') continue;
            D[k] *= P['n'];
            if (D[k] % P['d'] === 0) {
              D[k] /= P['d'];
            } else return null;
            d *= Math.pow(k, D[k]);
          }
          if (P['s'] < 0) {
            return newFraction(d, n);
          }
          return newFraction(n, d);
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "equals": function (a, b) {
          parse(a, b);
          return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
        },

        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "compare": function (a, b) {
          parse(a, b);
          var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
          return (0 < t) - (t < 0);
        },
        "simplify": function (eps) {
          if (isNaN(this['n']) || isNaN(this['d'])) {
            return this;
          }
          eps = eps || 0.001;
          var thisABS = this['abs']();
          var cont = thisABS['toContinued']();
          for (var i = 1; i < cont.length; i++) {
            var s = newFraction(cont[i - 1], 1);
            for (var k = i - 2; k >= 0; k--) {
              s = s['inverse']()['add'](cont[k]);
            }
            if (s['sub'](thisABS)['abs']().valueOf() < eps) {
              return s['mul'](this['s']);
            }
          }
          return this;
        },
        /**
         * Check if two rational numbers are divisible
         *
         * Ex: new Fraction(19.6).divisible(1.5);
         */
        "divisible": function (a, b) {
          parse(a, b);
          return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
         * Returns a decimal representation of the fraction
         *
         * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
         **/
        'valueOf': function () {
          return this["s"] * this["n"] / this["d"];
        },
        /**
         * Returns a string-fraction representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
         **/
        'toFraction': function (excludeWhole) {
          var whole,
            str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += '-';
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              str += " ";
              n %= d;
            }
            str += n;
            str += '/';
            str += d;
          }
          return str;
        },
        /**
         * Returns a latex representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
         **/
        'toLatex': function (excludeWhole) {
          var whole,
            str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += '-';
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              n %= d;
            }
            str += "\\frac{";
            str += n;
            str += '}{';
            str += d;
            str += '}';
          }
          return str;
        },
        /**
         * Returns an array of continued fraction elements
         *
         * Ex: new Fraction("7/8").toContinued() => [0,1,7]
         */
        'toContinued': function () {
          var t;
          var a = this['n'];
          var b = this['d'];
          var res = [];
          if (isNaN(a) || isNaN(b)) {
            return res;
          }
          do {
            res.push(Math.floor(a / b));
            t = a % b;
            a = b;
            b = t;
          } while (a !== 1);
          return res;
        },
        /**
         * Creates a string representation of a fraction with all digits
         *
         * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
         **/
        'toString': function (dec) {
          var N = this["n"];
          var D = this["d"];
          if (isNaN(N) || isNaN(D)) {
            return "NaN";
          }
          dec = dec || 15; // 15 = decimal places when no repetation

          var cycLen = cycleLen(N, D); // Cycle length
          var cycOff = cycleStart(N, D, cycLen); // Cycle start

          var str = this['s'] < 0 ? "-" : "";
          str += N / D | 0;
          N %= D;
          N *= 10;
          if (N) str += ".";
          if (cycLen) {
            for (var i = cycOff; i--;) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += "(";
            for (var i = cycLen; i--;) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += ")";
          } else {
            for (var i = dec; N && i--;) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
          }
          return str;
        }
      };
      {
        Object.defineProperty(Fraction, "__esModule", {
          'value': true
        });
        Fraction['default'] = Fraction;
        Fraction['Fraction'] = Fraction;
        module['exports'] = Fraction;
      }
    })();
  });
  var Fraction$1 = /*@__PURE__*/getDefaultExportFromCjs(fraction$1);

  var name$11 = 'Fraction';
  var dependencies$11 = [];
  var createFractionClass = /* #__PURE__ */factory(name$11, dependencies$11, () => {
    /**
     * Attach type information
     */
    Fraction$1.prototype.type = 'Fraction';
    Fraction$1.prototype.isFraction = true;
    /**
     * Get a JSON representation of a Fraction containing type information
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
     */

    Fraction$1.prototype.toJSON = function () {
      return {
        mathjs: 'Fraction',
        n: this.s * this.n,
        d: this.d
      };
    };
    /**
     * Instantiate a Fraction from a JSON object
     * @param {Object} json  a JSON object structured as:
     *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
     * @return {BigNumber}
     */

    Fraction$1.fromJSON = function (json) {
      return new Fraction$1(json);
    };
    return Fraction$1;
  }, {
    isClass: true
  });

  var name$10 = 'Matrix';
  var dependencies$10 = [];
  var createMatrixClass = /* #__PURE__ */factory(name$10, dependencies$10, () => {
    /**
     * @constructor Matrix
     *
     * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
     * array. A matrix can be constructed as:
     *
     *     let matrix = math.matrix(data)
     *
     * Matrix contains the functions to resize, get and set values, get the size,
     * clone the matrix and to convert the matrix to a vector, array, or scalar.
     * Furthermore, one can iterate over the matrix using map and forEach.
     * The internal Array of the Matrix can be accessed using the function valueOf.
     *
     * Example usage:
     *
     *     let matrix = math.matrix([[1, 2], [3, 4]])
     *     matix.size()              // [2, 2]
     *     matrix.resize([3, 2], 5)
     *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
     *     matrix.subset([1,2])       // 3 (indexes are zero-based)
     *
     */
    function Matrix() {
      if (!(this instanceof Matrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
    }
    /**
     * Attach type information
     */

    Matrix.prototype.type = 'Matrix';
    Matrix.prototype.isMatrix = true;
    /**
     * Get the storage format used by the matrix.
     *
     * Usage:
     *     const format = matrix.storage()   // retrieve storage format
     *
     * @return {string}           The storage format.
     */

    Matrix.prototype.storage = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke storage on a Matrix interface');
    };
    /**
     * Get the datatype of the data stored in the matrix.
     *
     * Usage:
     *     const format = matrix.datatype()    // retrieve matrix datatype
     *
     * @return {string}           The datatype.
     */

    Matrix.prototype.datatype = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke datatype on a Matrix interface');
    };
    /**
     * Create a new Matrix With the type of the current matrix instance
     * @param {Array | Object} data
     * @param {string} [datatype]
     */

    Matrix.prototype.create = function (data, datatype) {
      throw new Error('Cannot invoke create on a Matrix interface');
    };
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @param {Index} index
     * @param {Array | Matrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */

    Matrix.prototype.subset = function (index, replacement, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke subset on a Matrix interface');
    };
    /**
     * Get a single element from the matrix.
     * @param {number[]} index   Zero-based index
     * @return {*} value
     */

    Matrix.prototype.get = function (index) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke get on a Matrix interface');
    };
    /**
     * Replace a single element in the matrix.
     * @param {number[]} index   Zero-based index
     * @param {*} value
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be left undefined.
     * @return {Matrix} self
     */

    Matrix.prototype.set = function (index, value, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke set on a Matrix interface');
    };
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @param {number[]} size           The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */

    Matrix.prototype.resize = function (size, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke resize on a Matrix interface');
    };
    /**
     * Reshape the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (reshape in place).
     *
     * @param {number[]} size           The new size the matrix should have.
     * @param {boolean} [copy]          Return a reshaped copy of the matrix
     *
     * @return {Matrix}                 The reshaped matrix
     */

    Matrix.prototype.reshape = function (size, defaultValue) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke reshape on a Matrix interface');
    };
    /**
     * Create a clone of the matrix
     * @return {Matrix} clone
     */

    Matrix.prototype.clone = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke clone on a Matrix interface');
    };
    /**
     * Retrieve the size of the matrix.
     * @returns {number[]} size
     */

    Matrix.prototype.size = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke size on a Matrix interface');
    };
    /**
     * Create a new matrix with the results of the callback function executed on
     * each entry of the matrix.
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     *
     * @return {Matrix} matrix
     */

    Matrix.prototype.map = function (callback, skipZeros) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke map on a Matrix interface');
    };
    /**
     * Execute a callback function on each entry of the matrix.
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     */

    Matrix.prototype.forEach = function (callback) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke forEach on a Matrix interface');
    };
    /**
     * Iterate over the matrix elements
     * @return {Iterable<{ value, index: number[] }>}
     */

    Matrix.prototype[Symbol.iterator] = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot iterate a Matrix interface');
    };
    /**
     * Create an Array with a copy of the data of the Matrix
     * @returns {Array} array
     */

    Matrix.prototype.toArray = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke toArray on a Matrix interface');
    };
    /**
     * Get the primitive value of the Matrix: a multidimensional array
     * @returns {Array} array
     */

    Matrix.prototype.valueOf = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke valueOf on a Matrix interface');
    };
    /**
     * Get a string representation of the matrix, with optional formatting options.
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */

    Matrix.prototype.format = function (options) {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke format on a Matrix interface');
    };
    /**
     * Get a string representation of the matrix
     * @returns {string} str
     */

    Matrix.prototype.toString = function () {
      // must be implemented by each of the Matrix implementations
      throw new Error('Cannot invoke toString on a Matrix interface');
    };
    return Matrix;
  }, {
    isClass: true
  });

  var name$$ = 'DenseMatrix';
  var dependencies$$ = ['Matrix'];
  var createDenseMatrixClass = /* #__PURE__ */factory(name$$, dependencies$$, _ref => {
    var {
      Matrix
    } = _ref;

    /**
     * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
     * @class DenseMatrix
     * @enum {{ value, index: number[] }}
     */
    function DenseMatrix(data, datatype) {
      if (!(this instanceof DenseMatrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
      if (datatype && !isString(datatype)) {
        throw new Error('Invalid datatype: ' + datatype);
      }
      if (isMatrix(data)) {
        // check data is a DenseMatrix
        if (data.type === 'DenseMatrix') {
          // clone data & size
          this._data = clone$1(data._data);
          this._size = clone$1(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          // build data from existing matrix
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        // initialize fields from JSON representation
        this._data = data.data;
        this._size = data.size; // verify the dimensions of the array

        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        // replace nested Matrices with Arrays
        this._data = preprocess(data); // get the dimensions of the array

        this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array

        validate(this._data, this._size); // data type unknown

        this._datatype = datatype;
      } else if (data) {
        // unsupported type
        throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
      } else {
        // nothing provided
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }
    DenseMatrix.prototype = new Matrix();
    /**
     * Create a new DenseMatrix
     */

    DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    /**
     * Attach type information
     */

    DenseMatrix.prototype.type = 'DenseMatrix';
    DenseMatrix.prototype.isDenseMatrix = true;
    /**
     * Get the matrix type
     *
     * Usage:
     *    const matrixType = matrix.getDataType()  // retrieves the matrix type
     *
     * @memberOf DenseMatrix
     * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
     */

    DenseMatrix.prototype.getDataType = function () {
      return getArrayDataType(this._data, typeOf);
    };
    /**
     * Get the storage format used by the matrix.
     *
     * Usage:
     *     const format = matrix.storage()  // retrieve storage format
     *
     * @memberof DenseMatrix
     * @return {string}           The storage format.
     */

    DenseMatrix.prototype.storage = function () {
      return 'dense';
    };
    /**
     * Get the datatype of the data stored in the matrix.
     *
     * Usage:
     *     const format = matrix.datatype()   // retrieve matrix datatype
     *
     * @memberof DenseMatrix
     * @return {string}           The datatype.
     */

    DenseMatrix.prototype.datatype = function () {
      return this._datatype;
    };
    /**
     * Create a new DenseMatrix
     * @memberof DenseMatrix
     * @param {Array} data
     * @param {string} [datatype]
     */

    DenseMatrix.prototype.create = function (data, datatype) {
      return new DenseMatrix(data, datatype);
    };
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @memberof DenseMatrix
     * @param {Index} index
     * @param {Array | Matrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */

    DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index);
        // intentional fall through

        case 2:
        case 3:
          return _set(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError('Wrong number of arguments');
      }
    };
    /**
     * Get a single element from the matrix.
     * @memberof DenseMatrix
     * @param {number[]} index   Zero-based index
     * @return {*} value
     */

    DenseMatrix.prototype.get = function (index) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      } // check index

      for (var x = 0; x < index.length; x++) {
        validateIndex(index[x], this._size[x]);
      }
      var data = this._data;
      for (var i = 0, ii = index.length; i < ii; i++) {
        var indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      return data;
    };
    /**
     * Replace a single element in the matrix.
     * @memberof DenseMatrix
     * @param {number[]} index   Zero-based index
     * @param {*} value
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be left undefined.
     * @return {DenseMatrix} self
     */

    DenseMatrix.prototype.set = function (index, value, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }
      if (index.length < this._size.length) {
        throw new DimensionError(index.length, this._size.length, '<');
      }
      var i, ii, indexI; // enlarge matrix when needed

      var size = index.map(function (i) {
        return i + 1;
      });
      _fit(this, size, defaultValue); // traverse over the dimensions

      var data = this._data;
      for (i = 0, ii = index.length - 1; i < ii; i++) {
        indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      } // set new value

      indexI = index[index.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    /**
     * Get a submatrix of this matrix
     * @memberof DenseMatrix
     * @param {DenseMatrix} matrix
     * @param {Index} index   Zero-based index
     * @private
     */

    function _get(matrix, index) {
      if (!isIndex(index)) {
        throw new TypeError('Invalid index');
      }
      var isScalar = index.isScalar();
      if (isScalar) {
        // return a scalar
        return matrix.get(index.min());
      } else {
        // validate dimensions
        var size = index.size();
        if (size.length !== matrix._size.length) {
          throw new DimensionError(size.length, matrix._size.length);
        } // validate if any of the ranges in the index is out of range

        var min = index.min();
        var max = index.max();
        for (var i = 0, ii = matrix._size.length; i < ii; i++) {
          validateIndex(min[i], matrix._size[i]);
          validateIndex(max[i], matrix._size[i]);
        } // retrieve submatrix
        // TODO: more efficient when creating an empty matrix and setting _data and _size manually

        return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
      }
    }
    /**
     * Recursively get a submatrix of a multi dimensional matrix.
     * Index is not checked for correct number or length of dimensions.
     * @memberof DenseMatrix
     * @param {Array} data
     * @param {Index} index
     * @param {number} dims   Total number of dimensions
     * @param {number} dim    Current dimension
     * @return {Array} submatrix
     * @private
     */

    function _getSubmatrix(data, index, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        return range.map(function (i) {
          validateIndex(i, data.length);
          return data[i];
        }).valueOf();
      } else {
        return range.map(function (i) {
          validateIndex(i, data.length);
          var child = data[i];
          return _getSubmatrix(child, index, dims, dim + 1);
        }).valueOf();
      }
    }
    /**
     * Replace a submatrix in this matrix
     * Indexes are zero-based.
     * @memberof DenseMatrix
     * @param {DenseMatrix} matrix
     * @param {Index} index
     * @param {DenseMatrix | Array | *} submatrix
     * @param {*} defaultValue          Default value, filled in on new entries when
     *                                  the matrix is resized.
     * @return {DenseMatrix} matrix
     * @private
     */

    function _set(matrix, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError('Invalid index');
      } // get index size and check whether the index contains a single value

      var iSize = index.size();
      var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        // set a scalar
        // check whether submatrix is a scalar
        if (sSize.length !== 0) {
          throw new TypeError('Scalar expected');
        }
        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        // set a submatrix
        // validate dimensions
        if (iSize.length < matrix._size.length) {
          throw new DimensionError(iSize.length, matrix._size.length, '<');
        }
        if (sSize.length < iSize.length) {
          // calculate number of missing outer dimensions
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          } // unsqueeze both outer and inner dimensions

          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        } // check whether the size of the submatrix matches the index size

        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, '>');
        } // enlarge matrix when needed

        var size = index.max().map(function (i) {
          return i + 1;
        });
        _fit(matrix, size, defaultValue); // insert the sub matrix

        var dims = iSize.length;
        var dim = 0;
        _setSubmatrix(matrix._data, index, submatrix, dims, dim);
      }
      return matrix;
    }
    /**
     * Replace a submatrix of a multi dimensional matrix.
     * @memberof DenseMatrix
     * @param {Array} data
     * @param {Index} index
     * @param {Array} submatrix
     * @param {number} dims   Total number of dimensions
     * @param {number} dim
     * @private
     */

    function _setSubmatrix(data, index, submatrix, dims, dim) {
      var last = dim === dims - 1;
      var range = index.dimension(dim);
      if (last) {
        range.forEach(function (dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range.forEach(function (dataIndex, subIndex) {
          validateIndex(dataIndex);
          _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @memberof DenseMatrix
     * @param {number[] || Matrix} size The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */

    DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
      // validate arguments
      if (!isCollection(size)) {
        throw new TypeError('Array or Matrix expected');
      } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector

      var sizeArray = size.valueOf().map(value => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      }); // matrix to resize

      var m = copy ? this.clone() : this; // resize matrix

      return _resize(m, sizeArray, defaultValue);
    };
    function _resize(matrix, size, defaultValue) {
      // check size
      if (size.length === 0) {
        // first value in matrix
        var v = matrix._data; // go deep

        while (isArray(v)) {
          v = v[0];
        }
        return v;
      } // resize matrix

      matrix._size = size.slice(0); // copy the array

      matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix

      return matrix;
    }
    /**
     * Reshape the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (reshape in place).
     *
     * NOTE: This might be better suited to copy by default, instead of modifying
     *       in place. For now, it operates in place to remain consistent with
     *       resize().
     *
     * @memberof DenseMatrix
     * @param {number[]} size           The new size the matrix should have.
     * @param {boolean} [copy]          Return a reshaped copy of the matrix
     *
     * @return {Matrix}                 The reshaped matrix
     */

    DenseMatrix.prototype.reshape = function (size, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size);
      var currentLength = m._size.reduce((length, size) => length * size);
      m._size = processSizesWildcard(size, currentLength);
      return m;
    };
    /**
     * Enlarge the matrix when it is smaller than given size.
     * If the matrix is larger or equal sized, nothing is done.
     * @memberof DenseMatrix
     * @param {DenseMatrix} matrix           The matrix to be resized
     * @param {number[]} size
     * @param {*} defaultValue          Default value, filled in on new entries.
     * @private
     */

    function _fit(matrix, size, defaultValue) {
      var
      // copy the array
      newSize = matrix._size.slice(0);
      var changed = false; // add dimensions when needed

      while (newSize.length < size.length) {
        newSize.push(0);
        changed = true;
      } // enlarge size when needed

      for (var i = 0, ii = size.length; i < ii; i++) {
        if (size[i] > newSize[i]) {
          newSize[i] = size[i];
          changed = true;
        }
      }
      if (changed) {
        // resize only when size is changed
        _resize(matrix, newSize, defaultValue);
      }
    }
    /**
     * Create a clone of the matrix
     * @memberof DenseMatrix
     * @return {DenseMatrix} clone
     */

    DenseMatrix.prototype.clone = function () {
      var m = new DenseMatrix({
        data: clone$1(this._data),
        size: clone$1(this._size),
        datatype: this._datatype
      });
      return m;
    };
    /**
     * Retrieve the size of the matrix.
     * @memberof DenseMatrix
     * @returns {number[]} size
     */

    DenseMatrix.prototype.size = function () {
      return this._size.slice(0); // return a clone of _size
    };
    /**
     * Create a new matrix with the results of the callback function executed on
     * each entry of the matrix.
     * @memberof DenseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     *
     * @return {DenseMatrix} matrix
     */

    DenseMatrix.prototype.map = function (callback) {
      // matrix instance
      var me = this;
      var recurse = function recurse(value, index) {
        if (isArray(value)) {
          return value.map(function (child, i) {
            return recurse(child, index.concat(i));
          });
        } else {
          return callback(value, index, me);
        }
      }; // determine the new datatype when the original matrix has datatype defined
      // TODO: should be done in matrix constructor instead

      var data = recurse(this._data, []);
      var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;
      return new DenseMatrix(data, datatype);
    };
    /**
     * Execute a callback function on each entry of the matrix.
     * @memberof DenseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     */

    DenseMatrix.prototype.forEach = function (callback) {
      // matrix instance
      var me = this;
      var recurse = function recurse(value, index) {
        if (isArray(value)) {
          value.forEach(function (child, i) {
            recurse(child, index.concat(i));
          });
        } else {
          callback(value, index, me);
        }
      };
      recurse(this._data, []);
    };
    /**
     * Iterate over the matrix elements
     * @return {Iterable<{ value, index: number[] }>}
     */

    DenseMatrix.prototype[Symbol.iterator] = function* () {
      var recurse = function* recurse(value, index) {
        if (isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            yield* recurse(value[i], index.concat(i));
          }
        } else {
          yield {
            value,
            index
          };
        }
      };
      yield* recurse(this._data, []);
    };
    /**
     * Returns an array containing the rows of a 2D matrix
     * @returns {Array<Matrix>}
     */

    DenseMatrix.prototype.rows = function () {
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError('Rows can only be returned for a 2D matrix.');
      }
      var data = this._data;
      for (var row of data) {
        result.push(new DenseMatrix([row], this._datatype));
      }
      return result;
    };
    /**
     * Returns an array containing the columns of a 2D matrix
     * @returns {Array<Matrix>}
     */

    DenseMatrix.prototype.columns = function () {
      var _this = this;
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError('Rows can only be returned for a 2D matrix.');
      }
      var data = this._data;
      var _loop = function _loop(i) {
        var col = data.map(row => [row[i]]);
        result.push(new DenseMatrix(col, _this._datatype));
      };
      for (var i = 0; i < s[1]; i++) {
        _loop(i);
      }
      return result;
    };
    /**
     * Create an Array with a copy of the data of the DenseMatrix
     * @memberof DenseMatrix
     * @returns {Array} array
     */

    DenseMatrix.prototype.toArray = function () {
      return clone$1(this._data);
    };
    /**
     * Get the primitive value of the DenseMatrix: a multidimensional array
     * @memberof DenseMatrix
     * @returns {Array} array
     */

    DenseMatrix.prototype.valueOf = function () {
      return this._data;
    };
    /**
     * Get a string representation of the matrix, with optional formatting options.
     * @memberof DenseMatrix
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */

    DenseMatrix.prototype.format = function (options) {
      return format(this._data, options);
    };
    /**
     * Get a string representation of the matrix
     * @memberof DenseMatrix
     * @returns {string} str
     */

    DenseMatrix.prototype.toString = function () {
      return format(this._data);
    };
    /**
     * Get a JSON representation of the matrix
     * @memberof DenseMatrix
     * @returns {Object}
     */

    DenseMatrix.prototype.toJSON = function () {
      return {
        mathjs: 'DenseMatrix',
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    /**
     * Get the kth Matrix diagonal.
     *
     * @memberof DenseMatrix
     * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
     *
     * @returns {Matrix}                     The matrix with the diagonal values.
     */

    DenseMatrix.prototype.diagonal = function (k) {
      // validate k if any
      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer

        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows & columns

      var rows = this._size[0];
      var columns = this._size[1]; // number diagonal values

      var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix

      var data = []; // loop rows

      for (var i = 0; i < n; i++) {
        data[i] = this._data[i + kSub][i + kSuper];
      } // create DenseMatrix

      return new DenseMatrix({
        data,
        size: [n],
        datatype: this._datatype
      });
    };
    /**
     * Create a diagonal matrix.
     *
     * @memberof DenseMatrix
     * @param {Array} size                     The matrix size.
     * @param {number | Matrix | Array } value The values for the diagonal.
     * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
     * @param {number} [defaultValue]          The default value for non-diagonal
     * @param {string} [datatype]              The datatype for the diagonal
     *
     * @returns {DenseMatrix}
     */

    DenseMatrix.diagonal = function (size, value, k, defaultValue) {
      if (!isArray(size)) {
        throw new TypeError('Array expected, size parameter');
      }
      if (size.length !== 2) {
        throw new Error('Only two dimensions matrix are supported');
      } // map size & validate

      size = size.map(function (s) {
        // check it is a big number
        if (isBigNumber(s)) {
          // convert it
          s = s.toNumber();
        } // validate arguments

        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error('Size values must be positive integers');
        }
        return s;
      }); // validate k if any

      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer

        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows and columns

      var rows = size[0];
      var columns = size[1]; // number of non-zero items

      var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

      var _value; // check value

      if (isArray(value)) {
        // validate array
        if (value.length !== n) {
          // number of values in array must be n
          throw new Error('Invalid value array length');
        } // define function

        _value = function _value(i) {
          // return value @ i
          return value[i];
        };
      } else if (isMatrix(value)) {
        // matrix size
        var ms = value.size(); // validate matrix

        if (ms.length !== 1 || ms[0] !== n) {
          // number of values in array must be n
          throw new Error('Invalid matrix length');
        } // define function

        _value = function _value(i) {
          // return value @ i
          return value.get([i]);
        };
      } else {
        // define function
        _value = function _value() {
          // return value
          return value;
        };
      } // discover default value if needed

      if (!defaultValue) {
        // check first value in array
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero
        : 0;
      } // empty array

      var data = []; // check we need to resize array

      if (size.length > 0) {
        // resize array
        data = resize(data, size, defaultValue); // fill diagonal

        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      } // create DenseMatrix

      return new DenseMatrix({
        data,
        size: [rows, columns]
      });
    };
    /**
     * Generate a matrix from a JSON object
     * @memberof DenseMatrix
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
     *                       where mathjs is optional
     * @returns {DenseMatrix}
     */

    DenseMatrix.fromJSON = function (json) {
      return new DenseMatrix(json);
    };
    /**
     * Swap rows i and j in Matrix.
     *
     * @memberof DenseMatrix
     * @param {number} i       Matrix row index 1
     * @param {number} j       Matrix row index 2
     *
     * @return {Matrix}        The matrix reference
     */

    DenseMatrix.prototype.swapRows = function (i, j) {
      // check index
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error('Row index must be positive integers');
      } // check dimensions

      if (this._size.length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      } // validate index

      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]); // swap rows

      DenseMatrix._swapRows(i, j, this._data); // return current instance

      return this;
    };
    /**
     * Swap rows i and j in Dense Matrix data structure.
     *
     * @param {number} i       Matrix row index 1
     * @param {number} j       Matrix row index 2
     * @param {Array} data     Matrix data
     */

    DenseMatrix._swapRows = function (i, j, data) {
      // swap values i <-> j
      var vi = data[i];
      data[i] = data[j];
      data[j] = vi;
    };
    /**
     * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
     * Matrices. Replaces all nested Matrices with Arrays
     * @memberof DenseMatrix
     * @param {Array} data
     * @return {Array} data
     */

    function preprocess(data) {
      for (var i = 0, ii = data.length; i < ii; i++) {
        var elem = data[i];
        if (isArray(elem)) {
          data[i] = preprocess(elem);
        } else if (elem && elem.isMatrix === true) {
          data[i] = preprocess(elem.valueOf());
        }
      }
      return data;
    }
    return DenseMatrix;
  }, {
    isClass: true
  });

  /**
   * Execute the callback function element wise for each element in array and any
   * nested array
   * Returns an array with the results
   * @param {Array | Matrix} array
   * @param {Function} callback   The callback is called with two parameters:
   *                              value1 and value2, which contain the current
   *                              element of both arrays.
   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
   *
   * @return {Array | Matrix} res
   */

  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === 'function') {
      // TODO: replace array.map with a for loop to improve performance
      return array.map(function (x) {
        return deepMap(x, callback);
      });
    } else {
      return callback(array);
    }
  }

  var n1$1 = 'number';
  var n2 = 'number, number';
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1$1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1$1;

  function signNumber(x) {
    return sign$2(x);
  }
  signNumber.signature = n1$1;
  /**
   * Calculates the power of x to y, x^y, for two numbers.
   * @param {number} x
   * @param {number} y
   * @return {number} res
   */

  function powNumber(x, y) {
    // x^Infinity === 0 if -1 < x < 1
    // A real number 0 is returned instead of complex(0)
    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
      return 0;
    }
    return Math.pow(x, y);
  }
  powNumber.signature = n2;

  var n1 = 'number';
  function isZeroNumber(x) {
    return x === 0;
  }
  isZeroNumber.signature = n1;

  var name$_ = 'isZero';
  var dependencies$_ = ['typed'];
  var createIsZero = /* #__PURE__ */factory(name$_, dependencies$_, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Test whether a value is zero.
     * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
     * `Complex`, and `Unit`.
     *
     * The function is evaluated element-wise in case of Array or Matrix input.
     *
     * Syntax:
     *
     *     math.isZero(x)
     *
     * Examples:
     *
     *    math.isZero(0)                     // returns true
     *    math.isZero(2)                     // returns false
     *    math.isZero(0.5)                   // returns false
     *    math.isZero(math.bignumber(0))     // returns true
     *    math.isZero(math.fraction(0))      // returns true
     *    math.isZero(math.fraction(1,3))    // returns false
     *    math.isZero(math.complex('2 - 4i') // returns false
     *    math.isZero(math.complex('0i')     // returns true
     *    math.isZero('0')                   // returns true
     *    math.isZero('2')                   // returns false
     *    math.isZero([2, 0, -3]')           // returns [false, true, false]
     *
     * See also:
     *
     *    isNumeric, isPositive, isNegative, isInteger
     *
     * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
     * @return {boolean}  Returns true when `x` is zero.
     *                    Throws an error in case of an unknown data type.
     */
    return typed(name$_, {
      number: isZeroNumber,
      BigNumber: function BigNumber(x) {
        return x.isZero();
      },
      Complex: function Complex(x) {
        return x.re === 0 && x.im === 0;
      },
      Fraction: function Fraction(x) {
        return x.d === 1 && x.n === 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  /**
   * Compares two BigNumbers.
   * @param {BigNumber} x       First value to compare
   * @param {BigNumber} y       Second value to compare
   * @param {number} [epsilon]  The maximum relative difference between x and y
   *                            If epsilon is undefined or null, the function will
   *                            test whether x and y are exactly equal.
   * @return {boolean} whether the two numbers are nearly equal
   */
  function nearlyEqual(x, y, epsilon) {
    // if epsilon is null or undefined, test whether x and y are exactly equal
    if (epsilon === null || epsilon === undefined) {
      return x.eq(y);
    } // use "==" operator, handles infinities

    if (x.eq(y)) {
      return true;
    } // NaN

    if (x.isNaN() || y.isNaN()) {
      return false;
    } // at this point x and y should be finite

    if (x.isFinite() && y.isFinite()) {
      // check numbers are very close, needed when comparing numbers near zero
      var diff = x.minus(y).abs();
      if (diff.isZero()) {
        return true;
      } else {
        // use relative error
        var max = x.constructor.max(x.abs(), y.abs());
        return diff.lte(max.times(epsilon));
      }
    } // Infinite and Number or negative Infinite and positive Infinite cases

    return false;
  }

  /**
   * Test whether two complex values are equal provided a given epsilon.
   * Does not use or change the global Complex.EPSILON setting
   * @param {Complex} x
   * @param {Complex} y
   * @param {number} epsilon
   * @returns {boolean}
   */

  function complexEquals(x, y, epsilon) {
    return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
  }

  var name$Z = 'equalScalar';
  var dependencies$Z = ['typed', 'config'];
  var createEqualScalar = /* #__PURE__ */factory(name$Z, dependencies$Z, _ref => {
    var {
      typed,
      config
    } = _ref;

    /**
     * Test whether two scalar values are nearly equal.
     *
     * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
     * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
     * @private
     */
    return typed(name$Z, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x === y;
      },
      'number, number': function numberNumber(x, y) {
        return nearlyEqual$1(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.eq(y) || nearlyEqual(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.equals(y);
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        return complexEquals(x, y, config.epsilon);
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }
        return this(x.value, y.value);
      }
    });
  });
  factory(name$Z, ['typed', 'config'], _ref2 => {
    var {
      typed,
      config
    } = _ref2;
    return typed(name$Z, {
      'number, number': function numberNumber(x, y) {
        return nearlyEqual$1(x, y, config.epsilon);
      }
    });
  });

  var name$Y = 'SparseMatrix';
  var dependencies$Y = ['typed', 'equalScalar', 'Matrix'];
  var createSparseMatrixClass = /* #__PURE__ */factory(name$Y, dependencies$Y, _ref => {
    var {
      typed,
      equalScalar,
      Matrix
    } = _ref;

    /**
     * Sparse Matrix implementation. This type implements
     * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
     * format for two-dimensional sparse matrices.
     * @class SparseMatrix
     */
    function SparseMatrix(data, datatype) {
      if (!(this instanceof SparseMatrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
      if (datatype && !isString(datatype)) {
        throw new Error('Invalid datatype: ' + datatype);
      }
      if (isMatrix(data)) {
        // create from matrix
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        // initialize fields
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        // create from array
        _createFromArray(this, data, datatype);
      } else if (data) {
        // unsupported type
        throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
      } else {
        // nothing provided
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }
    function _createFromMatrix(matrix, source, datatype) {
      // check matrix type
      if (source.type === 'SparseMatrix') {
        // clone arrays
        matrix._values = source._values ? clone$1(source._values) : undefined;
        matrix._index = clone$1(source._index);
        matrix._ptr = clone$1(source._ptr);
        matrix._size = clone$1(source._size);
        matrix._datatype = datatype || source._datatype;
      } else {
        // build from matrix data
        _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix, data, datatype) {
      // initialize fields
      matrix._values = [];
      matrix._index = [];
      matrix._ptr = [];
      matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice

      var rows = data.length;
      var columns = 0; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;
      if (isString(datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, datatype);
      } // check we have rows (empty array)

      if (rows > 0) {
        // column index
        var j = 0;
        do {
          // store pointer to values index
          matrix._ptr.push(matrix._index.length); // loop rows

          for (var i = 0; i < rows; i++) {
            // current row
            var row = data[i]; // check row is an array

            if (isArray(row)) {
              // update columns if needed (only on first column)
              if (j === 0 && columns < row.length) {
                columns = row.length;
              } // check row has column

              if (j < row.length) {
                // value
                var v = row[j]; // check value != 0

                if (!eq(v, zero)) {
                  // store value
                  matrix._values.push(v); // index

                  matrix._index.push(i);
                }
              }
            } else {
              // update columns if needed (only on first column)
              if (j === 0 && columns < 1) {
                columns = 1;
              } // check value != 0 (row is a scalar)

              if (!eq(row, zero)) {
                // store value
                matrix._values.push(row); // index

                matrix._index.push(i);
              }
            }
          } // increment index

          j++;
        } while (j < columns);
      } // store number of values in ptr

      matrix._ptr.push(matrix._index.length); // size

      matrix._size = [rows, columns];
    }
    SparseMatrix.prototype = new Matrix();
    /**
     * Create a new SparseMatrix
     */

    SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    /**
     * Attach type information
     */

    SparseMatrix.prototype.type = 'SparseMatrix';
    SparseMatrix.prototype.isSparseMatrix = true;
    /**
     * Get the matrix type
     *
     * Usage:
     *    const matrixType = matrix.getDataType()  // retrieves the matrix type
     *
     * @memberOf SparseMatrix
     * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
     */

    SparseMatrix.prototype.getDataType = function () {
      return getArrayDataType(this._values, typeOf);
    };
    /**
     * Get the storage format used by the matrix.
     *
     * Usage:
     *     const format = matrix.storage()   // retrieve storage format
     *
     * @memberof SparseMatrix
     * @return {string}           The storage format.
     */

    SparseMatrix.prototype.storage = function () {
      return 'sparse';
    };
    /**
     * Get the datatype of the data stored in the matrix.
     *
     * Usage:
     *     const format = matrix.datatype()    // retrieve matrix datatype
     *
     * @memberof SparseMatrix
     * @return {string}           The datatype.
     */

    SparseMatrix.prototype.datatype = function () {
      return this._datatype;
    };
    /**
     * Create a new SparseMatrix
     * @memberof SparseMatrix
     * @param {Array} data
     * @param {string} [datatype]
     */

    SparseMatrix.prototype.create = function (data, datatype) {
      return new SparseMatrix(data, datatype);
    };
    /**
     * Get the matrix density.
     *
     * Usage:
     *     const density = matrix.density()                   // retrieve matrix density
     *
     * @memberof SparseMatrix
     * @return {number}           The matrix density.
     */

    SparseMatrix.prototype.density = function () {
      // rows & columns
      var rows = this._size[0];
      var columns = this._size[1]; // calculate density

      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @memberof SparseMatrix
     * @param {Index} index
     * @param {Array | Matrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */

    SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {
      // check it is a pattern matrix
      if (!this._values) {
        throw new Error('Cannot invoke subset on a Pattern only matrix');
      } // check arguments

      switch (arguments.length) {
        case 1:
          return _getsubset(this, index);
        // intentional fall through

        case 2:
        case 3:
          return _setsubset(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError('Wrong number of arguments');
      }
    };
    function _getsubset(matrix, idx) {
      // check idx
      if (!isIndex(idx)) {
        throw new TypeError('Invalid index');
      }
      var isScalar = idx.isScalar();
      if (isScalar) {
        // return a scalar
        return matrix.get(idx.min());
      } // validate dimensions

      var size = idx.size();
      if (size.length !== matrix._size.length) {
        throw new DimensionError(size.length, matrix._size.length);
      } // vars

      var i, ii, k, kk; // validate if any of the ranges in the index is out of range

      var min = idx.min();
      var max = idx.max();
      for (i = 0, ii = matrix._size.length; i < ii; i++) {
        validateIndex(min[i], matrix._size[i]);
        validateIndex(max[i], matrix._size[i]);
      } // matrix arrays

      var mvalues = matrix._values;
      var mindex = matrix._index;
      var mptr = matrix._ptr; // rows & columns dimensions for result matrix

      var rows = idx.dimension(0);
      var columns = idx.dimension(1); // workspace & permutation vector

      var w = [];
      var pv = []; // loop rows in resulting matrix

      rows.forEach(function (i, r) {
        // update permutation vector
        pv[i] = r[0]; // mark i in workspace

        w[i] = true;
      }); // result matrix arrays

      var values = mvalues ? [] : undefined;
      var index = [];
      var ptr = []; // loop columns in result matrix

      columns.forEach(function (j) {
        // update ptr
        ptr.push(index.length); // loop values in column j

        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          // row
          i = mindex[k]; // check row is in result matrix

          if (w[i] === true) {
            // push index
            index.push(pv[i]); // check we need to process values

            if (values) {
              values.push(mvalues[k]);
            }
          }
        }
      }); // update ptr

      ptr.push(index.length); // return matrix

      return new SparseMatrix({
        values,
        index,
        ptr,
        size,
        datatype: matrix._datatype
      });
    }
    function _setsubset(matrix, index, submatrix, defaultValue) {
      // check index
      if (!index || index.isIndex !== true) {
        throw new TypeError('Invalid index');
      } // get index size and check whether the index contains a single value

      var iSize = index.size();
      var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

      var sSize;
      if (isMatrix(submatrix)) {
        // submatrix size
        sSize = submatrix.size(); // use array representation

        submatrix = submatrix.toArray();
      } else {
        // get submatrix size (array, scalar)
        sSize = arraySize(submatrix);
      } // check index is a scalar

      if (isScalar) {
        // verify submatrix is a scalar
        if (sSize.length !== 0) {
          throw new TypeError('Scalar expected');
        } // set value

        matrix.set(index.min(), submatrix, defaultValue);
      } else {
        // validate dimensions, index size must be one or two dimensions
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix._size.length, '<');
        } // check submatrix and index have the same dimensions

        if (sSize.length < iSize.length) {
          // calculate number of missing outer dimensions
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          } // unsqueeze both outer and inner dimensions

          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        } // check whether the size of the submatrix matches the index size

        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, '>');
        } // insert the sub matrix

        if (iSize.length === 1) {
          // if the replacement index only has 1 dimension, go trough each one and set its value
          var range = index.dimension(0);
          range.forEach(function (dataIndex, subIndex) {
            validateIndex(dataIndex);
            matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
          });
        } else {
          // if the replacement index has 2 dimensions, go through each one and set the value in the correct index
          var firstDimensionRange = index.dimension(0);
          var secondDimensionRange = index.dimension(1);
          firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {
            validateIndex(firstDataIndex);
            secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {
              validateIndex(secondDataIndex);
              matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
            });
          });
        }
      }
      return matrix;
    }
    /**
     * Get a single element from the matrix.
     * @memberof SparseMatrix
     * @param {number[]} index   Zero-based index
     * @return {*} value
     */

    SparseMatrix.prototype.get = function (index) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      } // check it is a pattern matrix

      if (!this._values) {
        throw new Error('Cannot invoke get on a Pattern only matrix');
      } // row and column

      var i = index[0];
      var j = index[1]; // check i, j are valid

      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[1]); // find value index

      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row

      if (k < this._ptr[j + 1] && this._index[k] === i) {
        return this._values[k];
      }
      return 0;
    };
    /**
     * Replace a single element in the matrix.
     * @memberof SparseMatrix
     * @param {number[]} index   Zero-based index
     * @param {*} v
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be set to zero.
     * @return {SparseMatrix} self
     */

    SparseMatrix.prototype.set = function (index, v, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError('Array expected');
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      } // check it is a pattern matrix

      if (!this._values) {
        throw new Error('Cannot invoke set on a Pattern only matrix');
      } // row and column

      var i = index[0];
      var j = index[1]; // rows & columns

      var rows = this._size[0];
      var columns = this._size[1]; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;
      if (isString(this._datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, this._datatype);
      } // check we need to resize matrix

      if (i > rows - 1 || j > columns - 1) {
        // resize matrix
        _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns

        rows = this._size[0];
        columns = this._size[1];
      } // check i, j are valid

      validateIndex(i, rows);
      validateIndex(j, columns); // find value index

      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row

      if (k < this._ptr[j + 1] && this._index[k] === i) {
        // check value != 0
        if (!eq(v, zero)) {
          // update value
          this._values[k] = v;
        } else {
          // remove value from matrix
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        // insert value @ (i, j)
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }
      return this;
    };
    function _getValueIndex(i, top, bottom, index) {
      // check row is on the bottom side
      if (bottom - top === 0) {
        return bottom;
      } // loop rows [top, bottom[

      for (var r = top; r < bottom; r++) {
        // check we found value index
        if (index[r] === i) {
          return r;
        }
      } // we did not find row

      return top;
    }
    function _remove(k, j, values, index, ptr) {
      // remove value @ k
      values.splice(k, 1);
      index.splice(k, 1); // update pointers

      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i, j, v, values, index, ptr) {
      // insert value
      values.splice(k, 0, v); // update row for k

      index.splice(k, 0, i); // update column pointers

      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @memberof SparseMatrix
     * @param {number[] | Matrix} size  The new size the matrix should have.
     *                                  Since sparse matrices are always two-dimensional,
     *                                  size must be two numbers in either an array or a matrix
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */

    SparseMatrix.prototype.resize = function (size, defaultValue, copy) {
      // validate arguments
      if (!isCollection(size)) {
        throw new TypeError('Array or Matrix expected');
      } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector

      var sizeArray = size.valueOf().map(value => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      if (sizeArray.length !== 2) {
        throw new Error('Only two dimensions matrix are supported');
      } // check sizes

      sizeArray.forEach(function (value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');
        }
      }); // matrix to resize

      var m = copy ? this.clone() : this; // resize matrix

      return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize(matrix, rows, columns, defaultValue) {
      // value to insert at the time of growing matrix
      var value = defaultValue || 0; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;
      if (isString(matrix._datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, matrix._datatype); // convert value to the same datatype

        value = typed.convert(value, matrix._datatype);
      } // should we insert the value?

      var ins = !eq(value, zero); // old columns and rows

      var r = matrix._size[0];
      var c = matrix._size[1];
      var i, j, k; // check we need to increase columns

      if (columns > c) {
        // loop new columns
        for (j = c; j < columns; j++) {
          // update matrix._ptr for current column
          matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values

          if (ins) {
            // loop rows
            for (i = 0; i < r; i++) {
              // add new matrix._values
              matrix._values.push(value); // update matrix._index

              matrix._index.push(i);
            }
          }
        } // store number of matrix._values in matrix._ptr

        matrix._ptr[columns] = matrix._values.length;
      } else if (columns < c) {
        // truncate matrix._ptr
        matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index

        matrix._values.splice(matrix._ptr[columns], matrix._values.length);
        matrix._index.splice(matrix._ptr[columns], matrix._index.length);
      } // update columns

      c = columns; // check we need to increase rows

      if (rows > r) {
        // check we have to insert values
        if (ins) {
          // inserts
          var n = 0; // loop columns

          for (j = 0; j < c; j++) {
            // update matrix._ptr for current column
            matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values

            k = matrix._ptr[j + 1] + n; // pointer

            var p = 0; // loop new rows, initialize pointer

            for (i = r; i < rows; i++, p++) {
              // add value
              matrix._values.splice(k + p, 0, value); // update matrix._index

              matrix._index.splice(k + p, 0, i); // increment inserts

              n++;
            }
          } // store number of matrix._values in matrix._ptr

          matrix._ptr[c] = matrix._values.length;
        }
      } else if (rows < r) {
        // deletes
        var d = 0; // loop columns

        for (j = 0; j < c; j++) {
          // update matrix._ptr for current column
          matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column

          var k0 = matrix._ptr[j];
          var k1 = matrix._ptr[j + 1] - d; // loop matrix._index

          for (k = k0; k < k1; k++) {
            // row
            i = matrix._index[k]; // check we need to delete value and matrix._index

            if (i > rows - 1) {
              // remove value
              matrix._values.splice(k, 1); // remove item from matrix._index

              matrix._index.splice(k, 1); // increase deletes

              d++;
            }
          }
        } // update matrix._ptr for current column

        matrix._ptr[j] = matrix._values.length;
      } // update matrix._size

      matrix._size[0] = rows;
      matrix._size[1] = columns; // return matrix

      return matrix;
    }
    /**
     * Reshape the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (reshape in place).
     *
     * NOTE: This might be better suited to copy by default, instead of modifying
     *       in place. For now, it operates in place to remain consistent with
     *       resize().
     *
     * @memberof SparseMatrix
     * @param {number[]} sizes          The new size the matrix should have.
     *                                  Since sparse matrices are always two-dimensional,
     *                                  size must be two numbers in either an array or a matrix
     * @param {boolean} [copy]          Return a reshaped copy of the matrix
     *
     * @return {Matrix}                 The reshaped matrix
     */

    SparseMatrix.prototype.reshape = function (sizes, copy) {
      // validate arguments
      if (!isArray(sizes)) {
        throw new TypeError('Array expected');
      }
      if (sizes.length !== 2) {
        throw new Error('Sparse matrices can only be reshaped in two dimensions');
      } // check sizes

      sizes.forEach(function (value) {
        if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
          throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');
        }
      });
      var currentLength = this._size[0] * this._size[1];
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = sizes[0] * sizes[1]; // m * n must not change

      if (currentLength !== newLength) {
        throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
      } // matrix to reshape

      var m = copy ? this.clone() : this; // return unchanged if the same shape

      if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
        return m;
      } // Convert to COO format (generate a column index)

      var colIndex = [];
      for (var i = 0; i < m._ptr.length; i++) {
        for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
          colIndex.push(i);
        }
      } // Clone the values array

      var values = m._values.slice(); // Clone the row index array

      var rowIndex = m._index.slice(); // Transform the (row, column) indices

      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % sizes[1];
        rowIndex[_i] = Math.floor(flat / sizes[1]);
      } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
      // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
      // sorting several arrays based on some other array.
      // OR, we could easily just:
      // 1. Remove all values from the matrix

      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = sizes[1] + 1;
      m._size = sizes.slice();
      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
      // This step is probably the most time-consuming

      for (var h = 0; h < values.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values[h];
        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      } // The value indices are inserted out of order, but apparently that's... still OK?

      return m;
    };
    /**
     * Create a clone of the matrix
     * @memberof SparseMatrix
     * @return {SparseMatrix} clone
     */

    SparseMatrix.prototype.clone = function () {
      var m = new SparseMatrix({
        values: this._values ? clone$1(this._values) : undefined,
        index: clone$1(this._index),
        ptr: clone$1(this._ptr),
        size: clone$1(this._size),
        datatype: this._datatype
      });
      return m;
    };
    /**
     * Retrieve the size of the matrix.
     * @memberof SparseMatrix
     * @returns {number[]} size
     */

    SparseMatrix.prototype.size = function () {
      return this._size.slice(0); // copy the Array
    };
    /**
     * Create a new matrix with the results of the callback function executed on
     * each entry of the matrix.
     * @memberof SparseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     *
     * @return {SparseMatrix} matrix
     */

    SparseMatrix.prototype.map = function (callback, skipZeros) {
      // check it is a pattern matrix
      if (!this._values) {
        throw new Error('Cannot invoke map on a Pattern only matrix');
      } // matrix instance

      var me = this; // rows and columns

      var rows = this._size[0];
      var columns = this._size[1]; // invoke callback

      var invoke = function invoke(v, i, j) {
        // invoke callback
        return callback(v, [i, j], me);
      }; // invoke _map

      return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    /**
     * Create a new matrix with the results of the callback function executed on the interval
     * [minRow..maxRow, minColumn..maxColumn].
     */

    function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      // result arrays
      var values = [];
      var index = [];
      var ptr = []; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;
      if (isString(matrix._datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, matrix._datatype);
      } // invoke callback

      var invoke = function invoke(v, x, y) {
        // invoke callback
        v = callback(v, x, y); // check value != 0

        if (!eq(v, zero)) {
          // store value
          values.push(v); // index

          index.push(x);
        }
      }; // loop columns

      for (var j = minColumn; j <= maxColumn; j++) {
        // store pointer to values index
        ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]

        var k0 = matrix._ptr[j];
        var k1 = matrix._ptr[j + 1];
        if (skipZeros) {
          // loop k within [k0, k1[
          for (var k = k0; k < k1; k++) {
            // row index
            var i = matrix._index[k]; // check i is in range

            if (i >= minRow && i <= maxRow) {
              // value @ k
              invoke(matrix._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          // create a cache holding all defined values
          var _values = {};
          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix._index[_k];
            _values[_i4] = matrix._values[_k];
          } // loop over all rows (indexes can be unordered so we can't use that),
          // and either read the value or zero

          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      } // store number of values in ptr

      ptr.push(values.length); // return sparse matrix

      return new SparseMatrix({
        values,
        index,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    /**
     * Execute a callback function on each entry of the matrix.
     * @memberof SparseMatrix
     * @param {Function} callback   The callback function is invoked with three
     *                              parameters: the value of the element, the index
     *                              of the element, and the Matrix being traversed.
     * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
     *                              If false, the indices are guaranteed to be in order,
     *                              if true, the indices can be unordered.
     */

    SparseMatrix.prototype.forEach = function (callback, skipZeros) {
      // check it is a pattern matrix
      if (!this._values) {
        throw new Error('Cannot invoke forEach on a Pattern only matrix');
      } // matrix instance

      var me = this; // rows and columns

      var rows = this._size[0];
      var columns = this._size[1]; // loop columns

      for (var j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        if (skipZeros) {
          // loop k within [k0, k1[
          for (var k = k0; k < k1; k++) {
            // row index
            var i = this._index[k]; // value @ k

            callback(this._values[k], [i, j], me);
          }
        } else {
          // create a cache holding all defined values
          var values = {};
          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values[_i6] = this._values[_k2];
          } // loop over all rows (indexes can be unordered so we can't use that),
          // and either read the value or zero

          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values ? values[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    /**
     * Iterate over the matrix elements, skipping zeros
     * @return {Iterable<{ value, index: number[] }>}
     */

    SparseMatrix.prototype[Symbol.iterator] = function* () {
      if (!this._values) {
        throw new Error('Cannot iterate a Pattern only matrix');
      }
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          // row index
          var i = this._index[k];
          yield {
            value: this._values[k],
            index: [i, j]
          };
        }
      }
    };
    /**
     * Create an Array with a copy of the data of the SparseMatrix
     * @memberof SparseMatrix
     * @returns {Array} array
     */

    SparseMatrix.prototype.toArray = function () {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    /**
     * Get the primitive value of the SparseMatrix: a two dimensions array
     * @memberof SparseMatrix
     * @returns {Array} array
     */

    SparseMatrix.prototype.valueOf = function () {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values, index, ptr, size, copy) {
      // rows and columns
      var rows = size[0];
      var columns = size[1]; // result

      var a = []; // vars

      var i, j; // initialize array

      for (i = 0; i < rows; i++) {
        a[i] = [];
        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      } // loop columns

      for (j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = ptr[j];
        var k1 = ptr[j + 1]; // loop k within [k0, k1[

        for (var k = k0; k < k1; k++) {
          // row index
          i = index[k]; // set value (use one for pattern matrix)

          a[i][j] = values ? copy ? clone$1(values[k]) : values[k] : 1;
        }
      }
      return a;
    }
    /**
     * Get a string representation of the matrix, with optional formatting options.
     * @memberof SparseMatrix
     * @param {Object | number | Function} [options]  Formatting options. See
     *                                                lib/utils/number:format for a
     *                                                description of the available
     *                                                options.
     * @returns {string} str
     */

    SparseMatrix.prototype.format = function (options) {
      // rows and columns
      var rows = this._size[0];
      var columns = this._size[1]; // density

      var density = this.density(); // rows & columns

      var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\n'; // loop columns

      for (var j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1]; // loop k within [k0, k1[

        for (var k = k0; k < k1; k++) {
          // row index
          var i = this._index[k]; // append value

          str += '\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');
        }
      }
      return str;
    };
    /**
     * Get a string representation of the matrix
     * @memberof SparseMatrix
     * @returns {string} str
     */

    SparseMatrix.prototype.toString = function () {
      return format(this.toArray());
    };
    /**
     * Get a JSON representation of the matrix
     * @memberof SparseMatrix
     * @returns {Object}
     */

    SparseMatrix.prototype.toJSON = function () {
      return {
        mathjs: 'SparseMatrix',
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    /**
     * Get the kth Matrix diagonal.
     *
     * @memberof SparseMatrix
     * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
     *
     * @returns {Matrix}                     The matrix vector with the diagonal values.
     */

    SparseMatrix.prototype.diagonal = function (k) {
      // validate k if any
      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer

        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows & columns

      var rows = this._size[0];
      var columns = this._size[1]; // number diagonal values

      var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays

      var values = [];
      var index = [];
      var ptr = []; // initial ptr value

      ptr[0] = 0; // loop columns

      for (var j = kSuper; j < columns && values.length < n; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1]; // loop x within [k0, k1[

        for (var x = k0; x < k1; x++) {
          // row index
          var i = this._index[x]; // check row

          if (i === j - kSuper + kSub) {
            // value on this column
            values.push(this._values[x]); // store row

            index[values.length - 1] = i - kSub; // exit loop

            break;
          }
        }
      } // close ptr

      ptr.push(values.length); // return matrix

      return new SparseMatrix({
        values,
        index,
        ptr,
        size: [n, 1]
      });
    };
    /**
     * Generate a matrix from a JSON object
     * @memberof SparseMatrix
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
     *                       where mathjs is optional
     * @returns {SparseMatrix}
     */

    SparseMatrix.fromJSON = function (json) {
      return new SparseMatrix(json);
    };
    /**
     * Create a diagonal matrix.
     *
     * @memberof SparseMatrix
     * @param {Array} size                       The matrix size.
     * @param {number | Array | Matrix } value   The values for the diagonal.
     * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
     * @param {number} [defaultValue]            The default value for non-diagonal
     * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
     *
     * @returns {SparseMatrix}
     */

    SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
      if (!isArray(size)) {
        throw new TypeError('Array expected, size parameter');
      }
      if (size.length !== 2) {
        throw new Error('Only two dimensions matrix are supported');
      } // map size & validate

      size = size.map(function (s) {
        // check it is a big number
        if (isBigNumber(s)) {
          // convert it
          s = s.toNumber();
        } // validate arguments

        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error('Size values must be positive integers');
        }
        return s;
      }); // validate k if any

      if (k) {
        // convert BigNumber to a number
        if (isBigNumber(k)) {
          k = k.toNumber();
        } // is must be an integer

        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError('The parameter k must be an integer number');
        }
      } else {
        // default value
        k = 0;
      } // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0;
      if (isString(datatype)) {
        // find signature that matches (datatype, datatype)
        eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

        zero = typed.convert(0, datatype);
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // rows and columns

      var rows = size[0];
      var columns = size[1]; // number of non-zero items

      var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

      var _value; // check value

      if (isArray(value)) {
        // validate array
        if (value.length !== n) {
          // number of values in array must be n
          throw new Error('Invalid value array length');
        } // define function

        _value = function _value(i) {
          // return value @ i
          return value[i];
        };
      } else if (isMatrix(value)) {
        // matrix size
        var ms = value.size(); // validate matrix

        if (ms.length !== 1 || ms[0] !== n) {
          // number of values in array must be n
          throw new Error('Invalid matrix length');
        } // define function

        _value = function _value(i) {
          // return value @ i
          return value.get([i]);
        };
      } else {
        // define function
        _value = function _value() {
          // return value
          return value;
        };
      } // create arrays

      var values = [];
      var index = [];
      var ptr = []; // loop items

      for (var j = 0; j < columns; j++) {
        // number of rows with value
        ptr.push(values.length); // diagonal index

        var i = j - kSuper; // check we need to set diagonal value

        if (i >= 0 && i < n) {
          // get value @ i
          var v = _value(i); // check for zero

          if (!eq(v, zero)) {
            // column
            index.push(i + kSub); // add value

            values.push(v);
          }
        }
      } // last value should be number of values

      ptr.push(values.length); // create SparseMatrix

      return new SparseMatrix({
        values,
        index,
        ptr,
        size: [rows, columns]
      });
    };
    /**
     * Swap rows i and j in Matrix.
     *
     * @memberof SparseMatrix
     * @param {number} i       Matrix row index 1
     * @param {number} j       Matrix row index 2
     *
     * @return {Matrix}        The matrix reference
     */

    SparseMatrix.prototype.swapRows = function (i, j) {
      // check index
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error('Row index must be positive integers');
      } // check dimensions

      if (this._size.length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      } // validate index

      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]); // swap rows

      SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance

      return this;
    };
    /**
     * Loop rows with data in column j.
     *
     * @param {number} j            Column
     * @param {Array} values        Matrix values
     * @param {Array} index         Matrix row indeces
     * @param {Array} ptr           Matrix column pointers
     * @param {Function} callback   Callback function invoked for every row in column j
     */

    SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {
      // indeces for column j
      var k0 = ptr[j];
      var k1 = ptr[j + 1]; // loop

      for (var k = k0; k < k1; k++) {
        // invoke callback
        callback(index[k], values[k]);
      }
    };
    /**
     * Swap rows x and y in Sparse Matrix data structures.
     *
     * @param {number} x         Matrix row index 1
     * @param {number} y         Matrix row index 2
     * @param {number} columns   Number of columns in matrix
     * @param {Array} values     Matrix values
     * @param {Array} index      Matrix row indeces
     * @param {Array} ptr        Matrix column pointers
     */

    SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {
      // loop columns
      for (var j = 0; j < columns; j++) {
        // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
        var k0 = ptr[j];
        var k1 = ptr[j + 1]; // find value index @ x

        var kx = _getValueIndex(x, k0, k1, index); // find value index @ x

        var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix

        if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
          // swap values (check for pattern matrix)
          if (values) {
            var v = values[kx];
            values[kx] = values[ky];
            values[ky] = v;
          } // next column

          continue;
        } // check x row exist & no y row

        if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
          // value @ x (check for pattern matrix)
          var vx = values ? values[kx] : undefined; // insert value @ y

          index.splice(ky, 0, y);
          if (values) {
            values.splice(ky, 0, vx);
          } // remove value @ x (adjust array index if needed)

          index.splice(ky <= kx ? kx + 1 : kx, 1);
          if (values) {
            values.splice(ky <= kx ? kx + 1 : kx, 1);
          } // next column

          continue;
        } // check y row exist & no x row

        if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
          // value @ y (check for pattern matrix)
          var vy = values ? values[ky] : undefined; // insert value @ x

          index.splice(kx, 0, x);
          if (values) {
            values.splice(kx, 0, vy);
          } // remove value @ y (adjust array index if needed)

          index.splice(kx <= ky ? ky + 1 : ky, 1);
          if (values) {
            values.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };
    return SparseMatrix;
  }, {
    isClass: true
  });

  var name$X = 'number';
  var dependencies$X = ['typed'];
  /**
   * Separates the radix, integer part, and fractional part of a non decimal number string
   * @param {string} input string to parse
   * @returns {object} the parts of the string or null if not a valid input
   */

  function getNonDecimalNumberParts(input) {
    var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
      var radix = {
        '0b': 2,
        '0o': 8,
        '0x': 16
      }[nonDecimalWithRadixMatch[1]];
      var integerPart = nonDecimalWithRadixMatch[2];
      var fractionalPart = nonDecimalWithRadixMatch[3];
      return {
        input,
        radix,
        integerPart,
        fractionalPart
      };
    } else {
      return null;
    }
  }
  /**
   * Makes a number from a radix, and integer part, and a fractional part
   * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)
   * @returns {number} the number
   */

  function makeNumberFromNonDecimalParts(parts) {
    var n = parseInt(parts.integerPart, parts.radix);
    var f = 0;
    for (var i = 0; i < parts.fractionalPart.length; i++) {
      var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
      f += digitValue / Math.pow(parts.radix, i + 1);
    }
    var result = n + f;
    if (isNaN(result)) {
      throw new SyntaxError('String "' + parts.input + '" is no valid number');
    }
    return result;
  }
  var createNumber = /* #__PURE__ */factory(name$X, dependencies$X, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Create a number or convert a string, boolean, or unit to a number.
     * When value is a matrix, all elements will be converted to number.
     *
     * Syntax:
     *
     *    math.number(value)
     *    math.number(unit, valuelessUnit)
     *
     * Examples:
     *
     *    math.number(2)                         // returns number 2
     *    math.number('7.2')                     // returns number 7.2
     *    math.number(true)                      // returns number 1
     *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]
     *    math.number(math.unit('52cm'), 'm')    // returns 0.52
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, matrix, string, unit
     *
     * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
     * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
     * @return {number | Array | Matrix} The created number
     */
    var number = typed('number', {
      '': function _() {
        return 0;
      },
      number: function number(x) {
        return x;
      },
      string: function string(x) {
        if (x === 'NaN') return NaN;
        var nonDecimalNumberParts = getNonDecimalNumberParts(x);
        if (nonDecimalNumberParts) {
          return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
        }
        var size = 0;
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          // x includes a size suffix like 0xffffi32, so we extract
          // the suffix and remove it from x
          size = Number(wordSizeSuffixMatch[2]);
          x = wordSizeSuffixMatch[1];
        }
        var num = Number(x);
        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is no valid number');
        }
        if (wordSizeSuffixMatch) {
          // x is a signed bin, oct, or hex literal
          // num is the value of string x if x is interpreted as unsigned
          if (num > 2 ** size - 1) {
            // literal is too large for size suffix
            throw new SyntaxError("String \"".concat(x, "\" is out of range"));
          } // check if the bit at index size - 1 is set and if so do the twos complement

          if (num >= 2 ** (size - 1)) {
            num = num - 2 ** size;
          }
        }
        return num;
      },
      BigNumber: function BigNumber(x) {
        return x.toNumber();
      },
      Fraction: function Fraction(x) {
        return x.valueOf();
      },
      Unit: function Unit(x) {
        throw new Error('Second argument with valueless unit expected');
      },
      null: function _null(x) {
        return 0;
      },
      'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {
        return unit.toNumber(valuelessUnit);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    }); // reviver function to parse a JSON object like:
    //
    //     {"mathjs":"number","value":"2.3"}
    //
    // into a number 2.3

    number.fromJSON = function (json) {
      return parseFloat(json.value);
    };
    return number;
  });

  var name$W = 'bignumber';
  var dependencies$W = ['typed', 'BigNumber'];
  var createBignumber = /* #__PURE__ */factory(name$W, dependencies$W, _ref => {
    var {
      typed,
      BigNumber
    } = _ref;

    /**
     * Create a BigNumber, which can store numbers with arbitrary precision.
     * When a matrix is provided, all elements will be converted to BigNumber.
     *
     * Syntax:
     *
     *    math.bignumber(x)
     *
     * Examples:
     *
     *    0.1 + 0.2                                  // returns number 0.30000000000000004
     *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
     *
     *
     *    7.2e500                                    // returns number Infinity
     *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
     *
     * See also:
     *
     *    boolean, complex, index, matrix, string, unit
     *
     * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
     *                                                    0 by default.
     * @returns {BigNumber} The created bignumber
     */
    return typed('bignumber', {
      '': function _() {
        return new BigNumber(0);
      },
      number: function number(x) {
        // convert to string to prevent errors in case of >15 digits
        return new BigNumber(x + '');
      },
      string: function string(x) {
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          // x has a word size suffix
          var size = wordSizeSuffixMatch[2];
          var n = BigNumber(wordSizeSuffixMatch[1]);
          var twoPowSize = new BigNumber(2).pow(Number(size));
          if (n.gt(twoPowSize.sub(1))) {
            throw new SyntaxError("String \"".concat(x, "\" is out of range"));
          }
          var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);
          if (n.gte(twoPowSizeSubOne)) {
            return n.sub(twoPowSize);
          } else {
            return n;
          }
        }
        return new BigNumber(x);
      },
      BigNumber: function BigNumber(x) {
        // we assume a BigNumber is immutable
        return x;
      },
      Fraction: function Fraction(x) {
        return new BigNumber(x.n).div(x.d).times(x.s);
      },
      null: function _null(x) {
        return new BigNumber(0);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$V = 'complex';
  var dependencies$V = ['typed', 'Complex'];
  var createComplex = /* #__PURE__ */factory(name$V, dependencies$V, _ref => {
    var {
      typed,
      Complex
    } = _ref;

    /**
     * Create a complex value or convert a value to a complex value.
     *
     * Syntax:
     *
     *     math.complex()                           // creates a complex value with zero
     *                                              // as real and imaginary part.
     *     math.complex(re : number, im : string)   // creates a complex value with provided
     *                                              // values for real and imaginary part.
     *     math.complex(re : number)                // creates a complex value with provided
     *                                              // real value and zero imaginary part.
     *     math.complex(complex : Complex)          // clones the provided complex value.
     *     math.complex(arg : string)               // parses a string into a complex value.
     *     math.complex(array : Array)              // converts the elements of the array
     *                                              // or matrix element wise into a
     *                                              // complex value.
     *     math.complex({re: number, im: number})   // creates a complex value with provided
     *                                              // values for real an imaginary part.
     *     math.complex({r: number, phi: number})   // creates a complex value with provided
     *                                              // polar coordinates
     *
     * Examples:
     *
     *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
     *    a.re = 5                          // a = Complex 5 - 4i
     *    const i = a.im                    // Number -4
     *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
     *    const c = math.complex()          // Complex 0 + 0i
     *    const d = math.add(a, b)          // Complex 5 + 2i
     *
     * See also:
     *
     *    bignumber, boolean, index, matrix, number, string, unit
     *
     * @param {* | Array | Matrix} [args]
     *            Arguments specifying the real and imaginary part of the complex number
     * @return {Complex | Array | Matrix} Returns a complex value
     */
    return typed('complex', {
      '': function _() {
        return Complex.ZERO;
      },
      number: function number(x) {
        return new Complex(x, 0);
      },
      'number, number': function numberNumber(re, im) {
        return new Complex(re, im);
      },
      // TODO: this signature should be redundant
      'BigNumber, BigNumber': function BigNumberBigNumber(re, im) {
        return new Complex(re.toNumber(), im.toNumber());
      },
      Fraction: function Fraction(x) {
        return new Complex(x.valueOf(), 0);
      },
      Complex: function Complex(x) {
        return x.clone();
      },
      string: function string(x) {
        return Complex(x); // for example '2 + 3i'
      },

      null: function _null(x) {
        return Complex(0);
      },
      Object: function Object(x) {
        if ('re' in x && 'im' in x) {
          return new Complex(x.re, x.im);
        }
        if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {
          return new Complex(x);
        }
        throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$U = 'fraction';
  var dependencies$U = ['typed', 'Fraction'];
  var createFraction = /* #__PURE__ */factory(name$U, dependencies$U, _ref => {
    var {
      typed,
      Fraction
    } = _ref;

    /**
     * Create a fraction or convert a value to a fraction.
     *
     * With one numeric argument, produces the closest rational approximation to the
     * input.
     * With two arguments, the first is the numerator and the second is the denominator,
     * and creates the corresponding fraction. Both numerator and denominator must be
     * integers.
     * With one object argument, looks for the integer numerator as the value of property
     * 'n' and the integer denominator as the value of property 'd'.
     * With a matrix argument, creates a matrix of the same shape with entries
     * converted into fractions.
     *
     * Syntax:
     *     math.fraction(value)
     *     math.fraction(numerator, denominator)
     *     math.fraction({n: numerator, d: denominator})
     *     math.fraction(matrix: Array | Matrix)
     *
     * Examples:
     *
     *     math.fraction(6.283)             // returns Fraction 6283/1000
     *     math.fraction(1, 3)              // returns Fraction 1/3
     *     math.fraction('2/3')             // returns Fraction 2/3
     *     math.fraction({n: 2, d: 3})      // returns Fraction 2/3
     *     math.fraction([0.2, 0.25, 1.25]) // returns Array [1/5, 1/4, 5/4]
     *     math.fraction(4, 5.1)            // throws Error: Parameters must be integer
     *
     * See also:
     *
     *    bignumber, number, string, unit
     *
     * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]
     *            Arguments specifying the value, or numerator and denominator of
     *            the fraction
     * @return {Fraction | Array | Matrix} Returns a fraction
     */
    return typed('fraction', {
      number: function number(x) {
        if (!isFinite(x) || isNaN(x)) {
          throw new Error(x + ' cannot be represented as a fraction');
        }
        return new Fraction(x);
      },
      string: function string(x) {
        return new Fraction(x);
      },
      'number, number': function numberNumber(numerator, denominator) {
        return new Fraction(numerator, denominator);
      },
      null: function _null(x) {
        return new Fraction(0);
      },
      BigNumber: function BigNumber(x) {
        return new Fraction(x.toString());
      },
      Fraction: function Fraction(x) {
        return x; // fractions are immutable
      },

      Object: function Object(x) {
        return new Fraction(x);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$T = 'matrix';
  var dependencies$T = ['typed', 'Matrix', 'DenseMatrix', 'SparseMatrix'];
  var createMatrix = /* #__PURE__ */factory(name$T, dependencies$T, _ref => {
    var {
      typed,
      Matrix,
      DenseMatrix,
      SparseMatrix
    } = _ref;

    /**
     * Create a Matrix. The function creates a new `math.Matrix` object from
     * an `Array`. A Matrix has utility functions to manipulate the data in the
     * matrix, like getting the size and getting or setting values in the matrix.
     * Supported storage formats are 'dense' and 'sparse'.
     *
     * Syntax:
     *
     *    math.matrix()                         // creates an empty matrix using default storage format (dense).
     *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
     *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
     *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
     *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
     *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
     *
     * Examples:
     *
     *    let m = math.matrix([[1, 2], [3, 4]])
     *    m.size()                        // Array [2, 2]
     *    m.resize([3, 2], 5)
     *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
     *    m.get([1, 0])                    // number 3
     *
     * See also:
     *
     *    bignumber, boolean, complex, index, number, string, unit, sparse
     *
     * @param {Array | Matrix} [data]    A multi dimensional array
     * @param {string} [format]          The Matrix storage format, either `'dense'` or `'sparse'`
     * @param {string} [datatype]        Type of the values
     *
     * @return {Matrix} The created matrix
     */
    return typed(name$T, {
      '': function _() {
        return _create([]);
      },
      string: function string(format) {
        return _create([], format);
      },
      'string, string': function stringString(format, datatype) {
        return _create([], format, datatype);
      },
      Array: function Array(data) {
        return _create(data);
      },
      Matrix: function Matrix(data) {
        return _create(data, data.storage());
      },
      'Array | Matrix, string': _create,
      'Array | Matrix, string, string': _create
    });
    /**
     * Create a new Matrix with given storage format
     * @param {Array} data
     * @param {string} [format]
     * @param {string} [datatype]
     * @returns {Matrix} Returns a new Matrix
     * @private
     */

    function _create(data, format, datatype) {
      // get storage format constructor
      if (format === 'dense' || format === 'default' || format === undefined) {
        return new DenseMatrix(data, datatype);
      }
      if (format === 'sparse') {
        return new SparseMatrix(data, datatype);
      }
      throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.');
    }
  });

  var name$S = 'matrixFromColumns';
  var dependencies$S = ['typed', 'matrix', 'flatten', 'size'];
  var createMatrixFromColumns = /* #__PURE__ */factory(name$S, dependencies$S, _ref => {
    var {
      typed,
      matrix,
      flatten,
      size
    } = _ref;

    /**
     * Create a dense matrix from vectors as individual columns.
     * If you pass row vectors, they will be transposed (but not conjugated!)
     *
     * Syntax:
     *
     *    math.matrixFromColumns(...arr)
     *    math.matrixFromColumns(col1, col2)
     *    math.matrixFromColumns(col1, col2, col3)
     *
     * Examples:
     *
     *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])
     *    math.matrixFromColumns(...vectors)
     *
     * See also:
     *
     *    matrix, matrixFromRows, matrixFromFunction, zeros
     *
     * @param {... Array | Matrix} cols Multiple columns
     * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
     */
    return typed(name$S, {
      '...Array': function Array(arr) {
        return _createArray(arr);
      },
      '...Matrix': function Matrix(arr) {
        return matrix(_createArray(arr.map(m => m.toArray())));
      } // TODO implement this properly for SparseMatrix
    });

    function _createArray(arr) {
      if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');
      var N = checkVectorTypeAndReturnLength(arr[0]); // create an array with empty rows

      var result = [];
      for (var i = 0; i < N; i++) {
        result[i] = [];
      } // loop columns

      for (var col of arr) {
        var colLength = checkVectorTypeAndReturnLength(col);
        if (colLength !== N) {
          throw new TypeError('The vectors had different length: ' + (N | 0) + '  ' + (colLength | 0));
        }
        var f = flatten(col); // push a value to each row

        for (var _i = 0; _i < N; _i++) {
          result[_i].push(f[_i]);
        }
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      var s = size(vec);
      if (s.length === 1) {
        // 1D vector
        return s[0];
      } else if (s.length === 2) {
        // 2D vector
        if (s[0] === 1) {
          // row vector
          return s[1];
        } else if (s[1] === 1) {
          // col vector
          return s[0];
        } else {
          throw new TypeError('At least one of the arguments is not a vector.');
        }
      } else {
        throw new TypeError('Only one- or two-dimensional vectors are supported.');
      }
    }
  });

  var name$R = 'unaryMinus';
  var dependencies$R = ['typed'];
  var createUnaryMinus = /* #__PURE__ */factory(name$R, dependencies$R, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Inverse the sign of a value, apply a unary minus operation.
     *
     * For matrices, the function is evaluated element wise. Boolean values and
     * strings will be converted to a number. For complex numbers, both real and
     * complex value are inverted.
     *
     * Syntax:
     *
     *    math.unaryMinus(x)
     *
     * Examples:
     *
     *    math.unaryMinus(3.5)      // returns -3.5
     *    math.unaryMinus(-4.2)     // returns 4.2
     *
     * See also:
     *
     *    add, subtract, unaryPlus
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
     */
    return typed(name$R, {
      number: unaryMinusNumber,
      Complex: function Complex(x) {
        return x.neg();
      },
      BigNumber: function BigNumber(x) {
        return x.neg();
      },
      Fraction: function Fraction(x) {
        return x.neg();
      },
      Unit: function Unit(x) {
        var res = x.clone();
        res.value = this(x.value);
        return res;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since unaryMinus(0) = 0
        return deepMap(x, this);
      } // TODO: add support for string
    });
  });

  var name$Q = 'abs';
  var dependencies$Q = ['typed'];
  var createAbs = /* #__PURE__ */factory(name$Q, dependencies$Q, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Calculate the absolute value of a number. For matrices, the function is
     * evaluated element wise.
     *
     * Syntax:
     *
     *    math.abs(x)
     *
     * Examples:
     *
     *    math.abs(3.5)                // returns number 3.5
     *    math.abs(-4.2)               // returns number 4.2
     *
     *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
     *
     * See also:
     *
     *    sign
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
     *            A number or matrix for which to get the absolute value
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
     *            Absolute value of `x`
     */
    return typed(name$Q, {
      number: absNumber,
      Complex: function Complex(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        return x.abs();
      },
      Fraction: function Fraction(x) {
        return x.abs();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since abs(0) = 0
        return deepMap(x, this);
      },
      Unit: function Unit(x) {
        return x.abs();
      }
    });
  });

  var name$P = 'addScalar';
  var dependencies$P = ['typed'];
  var createAddScalar = /* #__PURE__ */factory(name$P, dependencies$P, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Add two scalar values, `x + y`.
     * This function is meant for internal use: it is used by the public function
     * `add`
     *
     * This function does not support collections (Array or Matrix).
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
     * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
     * @return {number | BigNumber | Fraction | Complex | Unit}     Sum of `x` and `y`
     * @private
     */
    return typed(name$P, {
      'number, number': addNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.add(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.plus(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.add(y);
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (x.value === null || x.value === undefined) throw new Error('Parameter x contains a unit with undefined value');
        if (y.value === null || y.value === undefined) throw new Error('Parameter y contains a unit with undefined value');
        if (!x.equalBase(y)) throw new Error('Units do not match');
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      }
    });
  });

  var name$O = 'algorithm11';
  var dependencies$O = ['typed', 'equalScalar'];
  var createAlgorithm11 = /* #__PURE__ */factory(name$O, dependencies$O, _ref => {
    var {
      typed,
      equalScalar
    } = _ref;

    /**
     * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
     * Callback function invoked NZ times (number of nonzero items in S).
     *
     *
     *            f(Sij, b)  ; S(i,j) !== 0
     * C(i,j) = 
     *            0          ; otherwise
     *
     *
     * @param {Matrix}   s                 The SparseMatrix instance (S)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
     */
    return function algorithm11(s, b, callback, inverse) {
      // sparse matrix arrays
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

      if (!avalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays

      var cvalues = [];
      var cindex = [];
      var cptr = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // initialize ptr
        cptr[j] = cindex.length; // values in j

        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          var i = aindex[k]; // invoke callback

          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b); // check value is zero

          if (!eq(v, zero)) {
            // push index & value
            cindex.push(i);
            cvalues.push(v);
          }
        }
      } // update ptr

      cptr[columns] = cindex.length; // return sparse matrix

      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$N = 'algorithm12';
  var dependencies$N = ['typed', 'DenseMatrix'];
  var createAlgorithm12 = /* #__PURE__ */factory(name$N, dependencies$N, _ref => {
    var {
      typed,
      DenseMatrix
    } = _ref;

    /**
     * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
     * Callback function invoked MxN times.
     *
     *
     *            f(Sij, b)  ; S(i,j) !== 0
     * C(i,j) = 
     *            f(0, b)    ; otherwise
     *
     *
     * @param {Matrix}   s                 The SparseMatrix instance (S)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
     */
    return function algorithm12(s, b, callback, inverse) {
      // sparse matrix arrays
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

      if (!avalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays

      var cdata = []; // workspaces

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // columns mark
        var mark = j + 1; // values in j

        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          var r = aindex[k]; // update workspace

          x[r] = avalues[k];
          w[r] = mark;
        } // loop rows

        for (var i = 0; i < rows; i++) {
          // initialize C on first column
          if (j === 0) {
            // create row array
            cdata[i] = [];
          } // check sparse matrix has a value @ i,j

          if (w[i] === mark) {
            // invoke callback, update C
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            // dense matrix value @ i, j
            cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      } // return dense matrix

      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$M = 'algorithm14';
  var dependencies$M = ['typed'];
  var createAlgorithm14 = /* #__PURE__ */factory(name$M, dependencies$M, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
     * Callback function invoked MxN times.
     *
     * C(i,j,...z) = f(Aij..z, b)
     *
     * @param {Matrix}   a                 The DenseMatrix instance (A)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij..z,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
     */
    return function algorithm14(a, b, callback, inverse) {
      // a arrays
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // populate cdata, iterate through dimensions

      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : []; // c matrix

      return a.createDenseMatrix({
        data: cdata,
        size: clone$1(asize),
        datatype: dt
      });
    }; // recursive function

    function _iterate(f, level, s, n, av, bv, inverse) {
      // initialize array for this level
      var cv = []; // check we reach the last level

      if (level === s.length - 1) {
        // loop arrays in last level
        for (var i = 0; i < n; i++) {
          // invoke callback and store value
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        // iterate current level
        for (var j = 0; j < n; j++) {
          // iterate next level
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  });

  var name$L = 'algorithm01';
  var dependencies$L = ['typed'];
  var createAlgorithm01 = /* #__PURE__ */factory(name$L, dependencies$L, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
     * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
     *
     *
     *            f(Dij, Sij)  ; S(i,j) !== 0
     * C(i,j) = 
     *            Dij          ; otherwise
     *
     *
     * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
     * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
     * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
     */
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      // dense matrix arrays
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype; // sparse matrix arrays

      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns

      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // sparse matrix cannot be a Pattern matrix

      if (!bvalues) {
        throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // process data types

      var dt = typeof adt === 'string' && adt === bdt ? adt : undefined; // callback function

      var cf = dt ? typed.find(callback, [dt, dt]) : callback; // vars

      var i, j; // result (DenseMatrix)

      var cdata = []; // initialize c

      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      } // workspace

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns in b

      for (j = 0; j < columns; j++) {
        // column mark
        var mark = j + 1; // values in column j

        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k]; // update workspace

          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // mark i as updated

          w[i] = mark;
        } // loop rows

        for (i = 0; i < rows; i++) {
          // check row is in workspace
          if (w[i] === mark) {
            // c[i][j] was already calculated
            cdata[i][j] = x[i];
          } else {
            // item does not exist in S
            cdata[i][j] = adata[i][j];
          }
        }
      } // return dense matrix

      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$K = 'algorithm04';
  var dependencies$K = ['typed', 'equalScalar'];
  var createAlgorithm04 = /* #__PURE__ */factory(name$K, dependencies$K, _ref => {
    var {
      typed,
      equalScalar
    } = _ref;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
     * Callback function invoked MAX(NNZA, NNZB) times
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
     * C(i,j) =   A(i,j)       ; A(i,j) !== 0
     *            B(i,j)       ; B(i,j) !== 0
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm04(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns

      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays

      var cvalues = avalues && bvalues ? [] : undefined;
      var cindex = [];
      var cptr = []; // workspace

      var xa = avalues && bvalues ? [] : undefined;
      var xb = avalues && bvalues ? [] : undefined; // marks indicating we have a value in x for a given column

      var wa = [];
      var wb = []; // vars

      var i, j, k, k0, k1; // loop columns

      for (j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // columns mark

        var mark = j + 1; // loop A(:,j)

        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = aindex[k]; // update c

          cindex.push(i); // update workspace

          wa[i] = mark; // check we need to process values

          if (xa) {
            xa[i] = avalues[k];
          }
        } // loop B(:,j)

        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          i = bindex[k]; // check row exists in A

          if (wa[i] === mark) {
            // update record in xa @ i
            if (xa) {
              // invoke callback
              var v = cf(xa[i], bvalues[k]); // check for zero

              if (!eq(v, zero)) {
                // update workspace
                xa[i] = v;
              } else {
                // remove mark (index will be removed later)
                wa[i] = null;
              }
            }
          } else {
            // update c
            cindex.push(i); // update workspace

            wb[i] = mark; // check we need to process values

            if (xb) {
              xb[i] = bvalues[k];
            }
          }
        } // check we need to process values (non pattern matrix)

        if (xa && xb) {
          // initialize first index in j
          k = cptr[j]; // loop index in j

          while (k < cindex.length) {
            // row
            i = cindex[k]; // check workspace has value @ i

            if (wa[i] === mark) {
              // push value (Aij != 0 || (Aij != 0 && Bij != 0))
              cvalues[k] = xa[i]; // increment pointer

              k++;
            } else if (wb[i] === mark) {
              // push value (bij != 0)
              cvalues[k] = xb[i]; // increment pointer

              k++;
            } else {
              // remove index @ k
              cindex.splice(k, 1);
            }
          }
        }
      } // update cptr

      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$J = 'algorithm10';
  var dependencies$J = ['typed', 'DenseMatrix'];
  var createAlgorithm10 = /* #__PURE__ */factory(name$J, dependencies$J, _ref => {
    var {
      typed,
      DenseMatrix
    } = _ref;

    /**
     * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
     * Callback function invoked NZ times (number of nonzero items in S).
     *
     *
     *            f(Sij, b)  ; S(i,j) !== 0
     * C(i,j) = 
     *            b          ; otherwise
     *
     *
     * @param {Matrix}   s                 The SparseMatrix instance (S)
     * @param {Scalar}   b                 The Scalar value
     * @param {Function} callback          The f(Aij,b) operation to invoke
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
     */
    return function algorithm10(s, b, callback, inverse) {
      // sparse matrix arrays
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

      if (!avalues) {
        throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string') {
        // datatype
        dt = adt; // convert b to the same datatype

        b = typed.convert(b, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays

      var cdata = []; // workspaces

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns

      for (var j = 0; j < columns; j++) {
        // columns mark
        var mark = j + 1; // values in j

        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          // row
          var r = aindex[k]; // update workspace

          x[r] = avalues[k];
          w[r] = mark;
        } // loop rows

        for (var i = 0; i < rows; i++) {
          // initialize C on first column
          if (j === 0) {
            // create row array
            cdata[i] = [];
          } // check sparse matrix has a value @ i,j

          if (w[i] === mark) {
            // invoke callback, update C
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            // dense matrix value @ i, j
            cdata[i][j] = b;
          }
        }
      } // return dense matrix

      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$I = 'algorithm13';
  var dependencies$I = ['typed'];
  var createAlgorithm13 = /* #__PURE__ */factory(name$I, dependencies$I, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
     * Callback function invoked MxN times.
     *
     * C(i,j,...z) = f(Aij..z, Bij..z)
     *
     * @param {Matrix}   a                 The DenseMatrix instance (A)
     * @param {Matrix}   b                 The DenseMatrix instance (B)
     * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
     */
    return function algorithm13(a, b, callback) {
      // a arrays
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b arrays

      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype; // c arrays

      var csize = []; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // validate each one of the dimension sizes

      for (var s = 0; s < asize.length; s++) {
        // must match
        if (asize[s] !== bsize[s]) {
          throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
        } // update dimension in c

        csize[s] = asize[s];
      } // datatype

      var dt; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // callback

        cf = typed.find(callback, [dt, dt]);
      } // populate cdata, iterate through dimensions

      var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : []; // c matrix

      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    }; // recursive function

    function _iterate(f, level, s, n, av, bv) {
      // initialize array for this level
      var cv = []; // check we reach the last level

      if (level === s.length - 1) {
        // loop arrays in last level
        for (var i = 0; i < n; i++) {
          // invoke callback and store value
          cv[i] = f(av[i], bv[i]);
        }
      } else {
        // iterate current level
        for (var j = 0; j < n; j++) {
          // iterate next level
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }
      return cv;
    }
  });

  var name$H = 'algorithm03';
  var dependencies$H = ['typed'];
  var createAlgorithm03 = /* #__PURE__ */factory(name$H, dependencies$H, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
     * Callback function invoked M*N times.
     *
     *
     *            f(Dij, Sij)  ; S(i,j) !== 0
     * C(i,j) = 
     *            f(Dij, 0)    ; otherwise
     *
     *
     * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
     * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
     * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
     * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
     */
    return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
      // dense matrix arrays
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype; // sparse matrix arrays

      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns

      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // sparse matrix cannot be a Pattern matrix

      if (!bvalues) {
        throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result (DenseMatrix)

      var cdata = []; // initialize dense matrix

      for (var z = 0; z < rows; z++) {
        // initialize row
        cdata[z] = [];
      } // workspace

      var x = []; // marks indicating we have a value in x for a given column

      var w = []; // loop columns in b

      for (var j = 0; j < columns; j++) {
        // column mark
        var mark = j + 1; // values in column j

        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          // row
          var i = bindex[k]; // update workspace

          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        } // process workspace

        for (var y = 0; y < rows; y++) {
          // check we have a calculated value for current row
          if (w[y] === mark) {
            // use calculated value
            cdata[y][j] = x[y];
          } else {
            // calculate value
            cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
          }
        }
      } // return dense matrix

      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$G = 'algorithm05';
  var dependencies$G = ['typed', 'equalScalar'];
  var createAlgorithm05 = /* #__PURE__ */factory(name$G, dependencies$G, _ref => {
    var {
      typed,
      equalScalar
    } = _ref;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
     * Callback function invoked MAX(NNZA, NNZB) times
     *
     *
     *            f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
     * C(i,j) = 
     *            0            ; otherwise
     *
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    SparseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm05(a, b, callback) {
      // sparse matrix arrays
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns

      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // equal signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // find signature that matches (dt, dt)

        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // result arrays

      var cvalues = avalues && bvalues ? [] : undefined;
      var cindex = [];
      var cptr = []; // workspaces

      var xa = cvalues ? [] : undefined;
      var xb = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column

      var wa = [];
      var wb = []; // vars

      var i, j, k, k1; // loop columns

      for (j = 0; j < columns; j++) {
        // update cptr
        cptr[j] = cindex.length; // columns mark

        var mark = j + 1; // loop values A(:,j)

        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          // row
          i = aindex[k]; // push index

          cindex.push(i); // update workspace

          wa[i] = mark; // check we need to process values

          if (xa) {
            xa[i] = avalues[k];
          }
        } // loop values B(:,j)

        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          // row
          i = bindex[k]; // check row existed in A

          if (wa[i] !== mark) {
            // push index
            cindex.push(i);
          } // update workspace

          wb[i] = mark; // check we need to process values

          if (xb) {
            xb[i] = bvalues[k];
          }
        } // check we need to process values (non pattern matrix)

        if (cvalues) {
          // initialize first index in j
          k = cptr[j]; // loop index in j

          while (k < cindex.length) {
            // row
            i = cindex[k]; // marks

            var wai = wa[i];
            var wbi = wb[i]; // check Aij or Bij are nonzero

            if (wai === mark || wbi === mark) {
              // matrix values @ i,j
              var va = wai === mark ? xa[i] : zero;
              var vb = wbi === mark ? xb[i] : zero; // Cij

              var vc = cf(va, vb); // check for zero

              if (!eq(vc, zero)) {
                // push value
                cvalues.push(vc); // increment pointer

                k++;
              } else {
                // remove value @ i, do not increment pointer
                cindex.splice(k, 1);
              }
            }
          }
        }
      } // update cptr

      cptr[columns] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  var name$F = 'multiplyScalar';
  var dependencies$F = ['typed'];
  var createMultiplyScalar = /* #__PURE__ */factory(name$F, dependencies$F, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Multiply two scalar values, `x * y`.
     * This function is meant for internal use: it is used by the public function
     * `multiply`
     *
     * This function does not support collections (Array or Matrix).
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
     * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
     * @return {number | BigNumber | Fraction | Complex | Unit}     Multiplication of `x` and `y`
     * @private
     */
    return typed('multiplyScalar', {
      'number, number': multiplyNumber,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.mul(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.times(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.mul(y);
      },
      'number | Fraction | BigNumber | Complex, Unit': function numberFractionBigNumberComplexUnit(x, y) {
        var res = y.clone();
        res.value = res.value === null ? res._normalize(x) : this(res.value, x);
        return res;
      },
      'Unit, number | Fraction | BigNumber | Complex': function UnitNumberFractionBigNumberComplex(x, y) {
        var res = x.clone();
        res.value = res.value === null ? res._normalize(y) : this(res.value, y);
        return res;
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return x.multiply(y);
      }
    });
  });

  var name$E = 'multiply';
  var dependencies$E = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];
  var createMultiply = /* #__PURE__ */factory(name$E, dependencies$E, _ref => {
    var {
      typed,
      matrix,
      addScalar,
      multiplyScalar,
      equalScalar,
      dot
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    function _validateMatrixDimensions(size1, size2) {
      // check left operand dimensions
      switch (size1.length) {
        case 1:
          // check size2
          switch (size2.length) {
            case 1:
              // Vector x Vector
              if (size1[0] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
              }
              break;
            case 2:
              // Vector x Matrix
              if (size1[0] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
              }
              break;
            default:
              throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
          }
          break;
        case 2:
          // check size2
          switch (size2.length) {
            case 1:
              // Matrix x Vector
              if (size1[1] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
              }
              break;
            case 2:
              // Matrix x Matrix
              if (size1[1] !== size2[0]) {
                // throw error
                throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
              }
              break;
            default:
              throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
          }
          break;
        default:
          throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
      }
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Dense Vector   (N)
     * @param {Matrix} b            Dense Vector   (N)
     *
     * @return {number}             Scalar value
     */

    function _multiplyVectorVector(a, b, n) {
      // check empty vector
      if (n === 0) {
        throw new Error('Cannot multiply two empty vectors');
      }
      return dot(a, b);
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Dense Vector   (M)
     * @param {Matrix} b            Matrix         (MxN)
     *
     * @return {Matrix}             Dense Vector   (N)
     */

    function _multiplyVectorMatrix(a, b) {
      // process storage
      if (b.storage() !== 'dense') {
        throw new Error('Support for SparseMatrix not implemented');
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Dense Vector   (M)
     * @param {Matrix} b            Dense Matrix   (MxN)
     *
     * @return {Matrix}             Dense Vector   (N)
     */

    function _multiplyVectorDenseMatrix(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b dense

      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype; // rows & columns

      var alength = asize[0];
      var bcolumns = bsize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result

      var c = []; // loop matrix columns

      for (var j = 0; j < bcolumns; j++) {
        // sum (do not initialize it with zero)
        var sum = mf(adata[0], bdata[0][j]); // loop vector

        for (var i = 1; i < alength; i++) {
          // multiply & accumulate
          sum = af(sum, mf(adata[i], bdata[i][j]));
        }
        c[j] = sum;
      } // return matrix

      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            Matrix         (MxN)
     * @param {Matrix} b            Dense Vector   (N)
     *
     * @return {Matrix}             Dense Vector   (M)
     */

    var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
      'DenseMatrix, any': _multiplyDenseMatrixVector,
      'SparseMatrix, any': _multiplySparseMatrixVector
    });
    /**
     * C = A * B
     *
     * @param {Matrix} a            Matrix         (MxN)
     * @param {Matrix} b            Matrix         (NxC)
     *
     * @return {Matrix}             Matrix         (MxC)
     */

    var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
      'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
      'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
      'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
      'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
    });
    /**
     * C = A * B
     *
     * @param {Matrix} a            DenseMatrix  (MxN)
     * @param {Matrix} b            Dense Vector (N)
     *
     * @return {Matrix}             Dense Vector (M)
     */

    function _multiplyDenseMatrixVector(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b dense

      var bdata = b._data;
      var bdt = b._datatype; // rows & columns

      var arows = asize[0];
      var acolumns = asize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result

      var c = []; // loop matrix a rows

      for (var i = 0; i < arows; i++) {
        // current row
        var row = adata[i]; // sum (do not initialize it with zero)

        var sum = mf(row[0], bdata[0]); // loop matrix a columns

        for (var j = 1; j < acolumns; j++) {
          // multiply & accumulate
          sum = af(sum, mf(row[j], bdata[j]));
        }
        c[i] = sum;
      } // return matrix

      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            DenseMatrix    (MxN)
     * @param {Matrix} b            DenseMatrix    (NxC)
     *
     * @return {Matrix}             DenseMatrix    (MxC)
     */

    function _multiplyDenseMatrixDenseMatrix(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b dense

      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype; // rows & columns

      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result

      var c = []; // loop matrix a rows

      for (var i = 0; i < arows; i++) {
        // current row
        var row = adata[i]; // initialize row array

        c[i] = []; // loop matrix b columns

        for (var j = 0; j < bcolumns; j++) {
          // sum (avoid initializing sum to zero)
          var sum = mf(row[0], bdata[0][j]); // loop matrix a columns

          for (var x = 1; x < acolumns; x++) {
            // multiply & accumulate
            sum = af(sum, mf(row[x], bdata[x][j]));
          }
          c[i][j] = sum;
        }
      } // return matrix

      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            DenseMatrix    (MxN)
     * @param {Matrix} b            SparseMatrix   (NxC)
     *
     * @return {Matrix}             SparseMatrix   (MxC)
     */

    function _multiplyDenseMatrixSparseMatrix(a, b) {
      // a dense
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype; // b sparse

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype; // validate b matrix

      if (!bvalues) {
        throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
      } // rows & columns

      var arows = asize[0];
      var bcolumns = bsize[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // equalScalar signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt);
      } // result

      var cvalues = [];
      var cindex = [];
      var cptr = []; // c matrix

      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      }); // loop b columns

      for (var jb = 0; jb < bcolumns; jb++) {
        // update ptr
        cptr[jb] = cindex.length; // indeces in column jb

        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1]; // do not process column jb if no data exists

        if (kb1 > kb0) {
          // last row mark processed
          var last = 0; // loop a rows

          for (var i = 0; i < arows; i++) {
            // column mark
            var mark = i + 1; // C[i, jb]

            var cij = void 0; // values in b column j

            for (var kb = kb0; kb < kb1; kb++) {
              // row
              var ib = bindex[kb]; // check value has been initialized

              if (last !== mark) {
                // first value in column jb
                cij = mf(adata[i][ib], bvalues[kb]); // update mark

                last = mark;
              } else {
                // accumulate value
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            } // check column has been processed and value != 0

            if (last === mark && !eq(cij, zero)) {
              // push row & value
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      } // update ptr

      cptr[bcolumns] = cindex.length; // return sparse matrix

      return c;
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            SparseMatrix    (MxN)
     * @param {Matrix} b            Dense Vector (N)
     *
     * @return {Matrix}             SparseMatrix    (M, 1)
     */

    function _multiplySparseMatrixVector(a, b) {
      // a sparse
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype; // validate a matrix

      if (!avalues) {
        throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
      } // b dense

      var bdata = b._data;
      var bdt = b._datatype; // rows & columns

      var arows = a._size[0];
      var brows = b._size[0]; // result

      var cvalues = [];
      var cindex = [];
      var cptr = []; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // equalScalar signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt);
      } // workspace

      var x = []; // vector with marks indicating a value x[i] exists in a given column

      var w = []; // update ptr

      cptr[0] = 0; // rows in b

      for (var ib = 0; ib < brows; ib++) {
        // b[ib]
        var vbi = bdata[ib]; // check b[ib] != 0, avoid loops

        if (!eq(vbi, zero)) {
          // A values & index in ib column
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            // a row
            var ia = aindex[ka]; // check value exists in current j

            if (!w[ia]) {
              // ia is new entry in j
              w[ia] = true; // add i to pattern of C

              cindex.push(ia); // x(ia) = A

              x[ia] = mf(vbi, avalues[ka]);
            } else {
              // i exists in C already
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      } // copy values from x to column jb of c

      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        // row
        var ic = cindex[p]; // copy value

        cvalues[p] = x[ic];
      } // update ptr

      cptr[1] = cindex.length; // return sparse matrix

      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: dt
      });
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            SparseMatrix      (MxN)
     * @param {Matrix} b            DenseMatrix       (NxC)
     *
     * @return {Matrix}             SparseMatrix      (MxC)
     */

    function _multiplySparseMatrixDenseMatrix(a, b) {
      // a sparse
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype; // validate a matrix

      if (!avalues) {
        throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
      } // b dense

      var bdata = b._data;
      var bdt = b._datatype; // rows & columns

      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1]; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // equalScalar signature to use

      var eq = equalScalar; // zero value

      var zero = 0; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
        eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

        zero = typed.convert(0, dt);
      } // result

      var cvalues = [];
      var cindex = [];
      var cptr = []; // c matrix

      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      }); // workspace

      var x = []; // vector with marks indicating a value x[i] exists in a given column

      var w = []; // loop b columns

      for (var jb = 0; jb < bcolumns; jb++) {
        // update ptr
        cptr[jb] = cindex.length; // mark in workspace for current column

        var mark = jb + 1; // rows in jb

        for (var ib = 0; ib < brows; ib++) {
          // b[ib, jb]
          var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops

          if (!eq(vbij, zero)) {
            // A values & index in ib column
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // a row
              var ia = aindex[ka]; // check value exists in current j

              if (w[ia] !== mark) {
                // ia is new entry in j
                w[ia] = mark; // add i to pattern of C

                cindex.push(ia); // x(ia) = A

                x[ia] = mf(vbij, avalues[ka]);
              } else {
                // i exists in C already
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        } // copy values from x to column jb of c

        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          // row
          var ic = cindex[p]; // copy value

          cvalues[p] = x[ic];
        }
      } // update ptr

      cptr[bcolumns] = cindex.length; // return sparse matrix

      return c;
    }
    /**
     * C = A * B
     *
     * @param {Matrix} a            SparseMatrix      (MxN)
     * @param {Matrix} b            SparseMatrix      (NxC)
     *
     * @return {Matrix}             SparseMatrix      (MxC)
     */

    function _multiplySparseMatrixSparseMatrix(a, b) {
      // a sparse
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype; // b sparse

      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype; // rows & columns

      var arows = a._size[0];
      var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data

      var values = avalues && bvalues; // datatype

      var dt; // addScalar signature to use

      var af = addScalar; // multiplyScalar signature to use

      var mf = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        // datatype
        dt = adt; // find signatures that matches (dt, dt)

        af = typed.find(addScalar, [dt, dt]);
        mf = typed.find(multiplyScalar, [dt, dt]);
      } // result

      var cvalues = values ? [] : undefined;
      var cindex = [];
      var cptr = []; // c matrix

      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      }); // workspace

      var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column

      var w = []; // variables

      var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns

      for (var jb = 0; jb < bcolumns; jb++) {
        // update ptr
        cptr[jb] = cindex.length; // mark in workspace for current column

        var mark = jb + 1; // B values & index in j

        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          // b row
          ib = bindex[kb]; // check we need to process values

          if (values) {
            // loop values in a[:,ib]
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // row
              ia = aindex[ka]; // check value exists in current j

              if (w[ia] !== mark) {
                // ia is new entry in j
                w[ia] = mark; // add i to pattern of C

                cindex.push(ia); // x(ia) = A

                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                // i exists in C already
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            // loop values in a[:,ib]
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              // row
              ia = aindex[ka]; // check value exists in current j

              if (w[ia] !== mark) {
                // ia is new entry in j
                w[ia] = mark; // add i to pattern of C

                cindex.push(ia);
              }
            }
          }
        } // check we need to process matrix values (pattern matrix)

        if (values) {
          // copy values from x to column jb of c
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            // row
            var ic = cindex[p]; // copy value

            cvalues[p] = x[ic];
          }
        }
      } // update ptr

      cptr[bcolumns] = cindex.length; // return sparse matrix

      return c;
    }
    /**
     * Multiply two or more values, `x * y`.
     * For matrices, the matrix product is calculated.
     *
     * Syntax:
     *
     *    math.multiply(x, y)
     *    math.multiply(x, y, z, ...)
     *
     * Examples:
     *
     *    math.multiply(4, 5.2)        // returns number 20.8
     *    math.multiply(2, 3, 4)       // returns number 24
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(4, 1)
     *    math.multiply(a, b)          // returns Complex 5 + 14i
     *
     *    const c = [[1, 2], [4, 3]]
     *    const d = [[1, 2, 3], [3, -4, 7]]
     *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
     *
     *    const e = math.unit('2.1 km')
     *    math.multiply(3, e)          // returns Unit 6.3 km
     *
     * See also:
     *
     *    divide, prod, cross, dot
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
     */

    return typed(name$E, extend({
      // we extend the signatures of multiplyScalar with signatures dealing with matrices
      'Array, Array': function ArrayArray(x, y) {
        // check dimensions
        _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation

        var m = this(matrix(x), matrix(y)); // return array or scalar

        return isMatrix(m) ? m.valueOf() : m;
      },
      'Matrix, Matrix': function MatrixMatrix(x, y) {
        // dimensions
        var xsize = x.size();
        var ysize = y.size(); // check dimensions

        _validateMatrixDimensions(xsize, ysize); // process dimensions

        if (xsize.length === 1) {
          // process y dimensions
          if (ysize.length === 1) {
            // Vector * Vector
            return _multiplyVectorVector(x, y, xsize[0]);
          } // Vector * Matrix

          return _multiplyVectorMatrix(x, y);
        } // process y dimensions

        if (ysize.length === 1) {
          // Matrix * Vector
          return _multiplyMatrixVector(x, y);
        } // Matrix * Matrix

        return _multiplyMatrixMatrix(x, y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use Matrix * Matrix implementation
        return this(x, matrix(y));
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use Matrix * Matrix implementation
        return this(matrix(x, y.storage()), y);
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, multiplyScalar, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, multiplyScalar, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm11(y, x, multiplyScalar, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, multiplyScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
      },
      'any, any': multiplyScalar,
      'any, any, ...any': function anyAnyAny(x, y, rest) {
        var result = this(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }
        return result;
      }
    }, multiplyScalar.signatures));
  });

  var name$D = 'sign';
  var dependencies$D = ['typed', 'BigNumber', 'Fraction', 'complex'];
  var createSign = /* #__PURE__ */factory(name$D, dependencies$D, _ref => {
    var {
      typed,
      BigNumber: _BigNumber,
      complex,
      Fraction: _Fraction
    } = _ref;

    /**
     * Compute the sign of a value. The sign of a value x is:
     *
     * -  1 when x > 0
     * - -1 when x < 0
     * -  0 when x == 0
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sign(x)
     *
     * Examples:
     *
     *    math.sign(3.5)               // returns 1
     *    math.sign(-4.2)              // returns -1
     *    math.sign(0)                 // returns 0
     *
     *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
     *
     * See also:
     *
     *    abs
     *
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
     *            The number for which to determine the sign
     * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
     *            The sign of `x`
     */
    return typed(name$D, {
      number: signNumber,
      Complex: function Complex(x) {
        return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
      },
      BigNumber: function BigNumber(x) {
        return new _BigNumber(x.cmp(0));
      },
      Fraction: function Fraction(x) {
        return new _Fraction(x.s, 1);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sign(0) = 0
        return deepMap(x, this);
      },
      Unit: function Unit(x) {
        if (!x._isDerived() && x.units[0].unit.offset !== 0) {
          throw new TypeError('sign is ambiguous for units with offset');
        }
        return this(x.value);
      }
    });
  });

  var name$C = 'sqrt';
  var dependencies$C = ['config', 'typed', 'Complex'];
  var createSqrt = /* #__PURE__ */factory(name$C, dependencies$C, _ref => {
    var {
      config,
      typed,
      Complex
    } = _ref;

    /**
     * Calculate the square root of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sqrt(x)
     *
     * Examples:
     *
     *    math.sqrt(25)                // returns 5
     *    math.square(5)               // returns 25
     *    math.sqrt(-4)                // returns Complex 2i
     *
     * See also:
     *
     *    square, multiply, cube, cbrt, sqrtm
     *
     * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
     *            Value for which to calculate the square root.
     * @return {number | BigNumber | Complex | Array | Matrix | Unit}
     *            Returns the square root of `x`
     */
    return typed('sqrt', {
      number: _sqrtNumber,
      Complex: function Complex(x) {
        return x.sqrt();
      },
      BigNumber: function BigNumber(x) {
        if (!x.isNegative() || config.predictable) {
          return x.sqrt();
        } else {
          // negative value -> downgrade to number to do complex value computation
          return _sqrtNumber(x.toNumber());
        }
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sqrt(0) = 0
        return deepMap(x, this);
      },
      Unit: function Unit(x) {
        // Someday will work for complex units when they are implemented
        return x.pow(0.5);
      }
    });
    /**
     * Calculate sqrt for a number
     * @param {number} x
     * @returns {number | Complex} Returns the square root of x
     * @private
     */

    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex(x, 0).sqrt();
      }
    }
  });

  var name$B = 'subtract';
  var dependencies$B = ['typed', 'matrix', 'equalScalar', 'addScalar', 'unaryMinus', 'DenseMatrix'];
  var createSubtract = /* #__PURE__ */factory(name$B, dependencies$B, _ref => {
    var {
      typed,
      matrix,
      equalScalar,
      addScalar,
      unaryMinus,
      DenseMatrix
    } = _ref;
    // TODO: split function subtract in two: subtract and subtractScalar
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm05 = createAlgorithm05({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Subtract two values, `x - y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.subtract(x, y)
     *
     * Examples:
     *
     *    math.subtract(5.3, 2)        // returns number 3.3
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(4, 1)
     *    math.subtract(a, b)          // returns Complex -2 + 2i
     *
     *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
     *
     *    const c = math.unit('2.1 km')
     *    const d = math.unit('500m')
     *    math.subtract(c, d)          // returns Unit 1.6 km
     *
     * See also:
     *
     *    add
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
     *            Initial value
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
     *            Value to subtract from `x`
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
     *            Subtraction of `x` and `y`
     */

    return typed(name$B, {
      'number, number': function numberNumber(x, y) {
        return x - y;
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.sub(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.minus(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.sub(y);
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (x.value === null) {
          throw new Error('Parameter x contains a unit with undefined value');
        }
        if (y.value === null) {
          throw new Error('Parameter y contains a unit with undefined value');
        }
        if (!x.equalBase(y)) {
          throw new Error('Units do not match');
        }
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm05(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm01(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm10(x, unaryMinus(y), addScalar);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });
  /**
   * Check whether matrix x and y have the same number of dimensions.
   * Throws a DimensionError when dimensions are not equal
   * @param {Matrix} x
   * @param {Matrix} y
   */

  function checkEqualDimensions(x, y) {
    var xsize = x.size();
    var ysize = y.size();
    if (xsize.length !== ysize.length) {
      throw new DimensionError(xsize.length, ysize.length);
    }
  }

  var name$A = 'algorithm07';
  var dependencies$A = ['typed', 'DenseMatrix'];
  var createAlgorithm07 = /* #__PURE__ */factory(name$A, dependencies$A, _ref => {
    var {
      typed,
      DenseMatrix
    } = _ref;

    /**
     * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
     * Callback function invoked MxN times.
     *
     * C(i,j) = f(Aij, Bij)
     *
     * @param {Matrix}   a                 The SparseMatrix instance (A)
     * @param {Matrix}   b                 The SparseMatrix instance (B)
     * @param {Function} callback          The f(Aij,Bij) operation to invoke
     *
     * @return {Matrix}                    DenseMatrix (C)
     *
     * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
     */
    return function algorithm07(a, b, callback) {
      // sparse matrix arrays
      var asize = a._size;
      var adt = a._datatype; // sparse matrix arrays

      var bsize = b._size;
      var bdt = b._datatype; // validate dimensions

      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      } // check rows & columns

      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
      } // rows & columns

      var rows = asize[0];
      var columns = asize[1]; // datatype

      var dt; // zero value

      var zero = 0; // callback signature to use

      var cf = callback; // process data types

      if (typeof adt === 'string' && adt === bdt) {
        // datatype
        dt = adt; // convert 0 to the same datatype

        zero = typed.convert(0, dt); // callback

        cf = typed.find(callback, [dt, dt]);
      } // vars

      var i, j; // result arrays

      var cdata = []; // initialize c

      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      } // workspaces

      var xa = [];
      var xb = []; // marks indicating we have a value in x for a given column

      var wa = [];
      var wb = []; // loop columns

      for (j = 0; j < columns; j++) {
        // columns mark
        var mark = j + 1; // scatter the values of A(:,j) into workspace

        _scatter(a, j, wa, xa, mark); // scatter the values of B(:,j) into workspace

        _scatter(b, j, wb, xb, mark); // loop rows

        for (i = 0; i < rows; i++) {
          // matrix values @ i,j
          var va = wa[i] === mark ? xa[i] : zero;
          var vb = wb[i] === mark ? xb[i] : zero; // invoke callback

          cdata[i][j] = cf(va, vb);
        }
      } // return dense matrix

      return new DenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
    function _scatter(m, j, w, x, mark) {
      // a arrays
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // loop values in column j

      for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        // row
        var i = index[k]; // update workspace

        w[i] = mark;
        x[i] = values[k];
      }
    }
  });

  var name$z = 'conj';
  var dependencies$z = ['typed'];
  var createConj = /* #__PURE__ */factory(name$z, dependencies$z, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Compute the complex conjugate of a complex value.
     * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.conj(x)
     *
     * Examples:
     *
     *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
     *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
     *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
     *
     * See also:
     *
     *    re, im, arg, abs
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Complex | Array | Matrix}
     *            The complex conjugate of x
     */
    return typed(name$z, {
      number: function number(x) {
        return x;
      },
      BigNumber: function BigNumber(x) {
        return x;
      },
      Complex: function Complex(x) {
        return x.conjugate();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$y = 'im';
  var dependencies$y = ['typed'];
  var createIm = /* #__PURE__ */factory(name$y, dependencies$y, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Get the imaginary part of a complex number.
     * For a complex number `a + bi`, the function returns `b`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.im(x)
     *
     * Examples:
     *
     *    const a = math.complex(2, 3)
     *    math.re(a)                     // returns number 2
     *    math.im(a)                     // returns number 3
     *
     *    math.re(math.complex('-5.2i')) // returns number -5.2
     *    math.re(math.complex(2.4))     // returns number 0
     *
     * See also:
     *
     *    re, conj, abs, arg
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Array | Matrix} The imaginary part of x
     */
    return typed(name$y, {
      number: function number(x) {
        return 0;
      },
      BigNumber: function BigNumber(x) {
        return x.mul(0);
      },
      Fraction: function Fraction(x) {
        return x.mul(0);
      },
      Complex: function Complex(x) {
        return x.im;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$x = 're';
  var dependencies$x = ['typed'];
  var createRe = /* #__PURE__ */factory(name$x, dependencies$x, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Get the real part of a complex number.
     * For a complex number `a + bi`, the function returns `a`.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.re(x)
     *
     * Examples:
     *
     *    const a = math.complex(2, 3)
     *    math.re(a)                     // returns number 2
     *    math.im(a)                     // returns number 3
     *
     *    math.re(math.complex('-5.2i')) // returns number 0
     *    math.re(math.complex(2.4))     // returns number 2.4
     *
     * See also:
     *
     *    im, conj, abs, arg
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x
     *            A complex number or array with complex numbers
     * @return {number | BigNumber | Array | Matrix} The real part of x
     */
    return typed(name$x, {
      number: function number(x) {
        return x;
      },
      BigNumber: function BigNumber(x) {
        return x;
      },
      Fraction: function Fraction(x) {
        return x;
      },
      Complex: function Complex(x) {
        return x.re;
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$w = 'column';
  var dependencies$w = ['typed', 'Index', 'matrix', 'range'];
  var createColumn = /* #__PURE__ */factory(name$w, dependencies$w, _ref => {
    var {
      typed,
      Index,
      matrix,
      range
    } = _ref;

    /**
     * Return a column from a Matrix.
     *
     * Syntax:
     *
     *     math.column(value, index)
     *
     * Example:
     *
     *     // get a column
     *     const d = [[1, 2], [3, 4]]
     *     math.column(d, 1) // returns [[2], [4]]
     *
     * See also:
     *
     *     row
     *
     * @param {Array | Matrix } value   An array or matrix
     * @param {number} column           The index of the column
     * @return {Array | Matrix}         The retrieved column
     */
    return typed(name$w, {
      'Matrix, number': _column,
      'Array, number': function ArrayNumber(value, column) {
        return _column(matrix(clone$1(value)), column).valueOf();
      }
    });
    /**
     * Retrieve a column of a matrix
     * @param {Matrix } value  A matrix
     * @param {number} column  The index of the column
     * @return {Matrix}        The retrieved column
     */

    function _column(value, column) {
      // check dimensions
      if (value.size().length !== 2) {
        throw new Error('Only two dimensional matrix is supported');
      }
      validateIndex(column, value.size()[1]);
      var rowRange = range(0, value.size()[0]);
      var index = new Index(rowRange, column);
      return value.subset(index);
    }
  });

  var name$v = 'cross';
  var dependencies$v = ['typed', 'matrix', 'subtract', 'multiply'];
  var createCross = /* #__PURE__ */factory(name$v, dependencies$v, _ref => {
    var {
      typed,
      matrix,
      subtract,
      multiply
    } = _ref;

    /**
     * Calculate the cross product for two vectors in three dimensional space.
     * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
     * as:
     *
     *    cross(A, B) = [
     *      a2 * b3 - a3 * b2,
     *      a3 * b1 - a1 * b3,
     *      a1 * b2 - a2 * b1
     *    ]
     *
     * If one of the input vectors has a dimension greater than 1, the output
     * vector will be a 1x3 (2-dimensional) matrix.
     *
     * Syntax:
     *
     *    math.cross(x, y)
     *
     * Examples:
     *
     *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
     *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
     *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
     *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
     *
     * See also:
     *
     *    dot, multiply
     *
     * @param  {Array | Matrix} x   First vector
     * @param  {Array | Matrix} y   Second vector
     * @return {Array | Matrix}     Returns the cross product of `x` and `y`
     */
    return typed(name$v, {
      'Matrix, Matrix': function MatrixMatrix(x, y) {
        return matrix(_cross(x.toArray(), y.toArray()));
      },
      'Matrix, Array': function MatrixArray(x, y) {
        return matrix(_cross(x.toArray(), y));
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        return matrix(_cross(x, y.toArray()));
      },
      'Array, Array': _cross
    });
    /**
     * Calculate the cross product for two arrays
     * @param {Array} x  First vector
     * @param {Array} y  Second vector
     * @returns {Array} Returns the cross product of x and y
     * @private
     */

    function _cross(x, y) {
      var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
      x = squeeze(x);
      y = squeeze(y);
      var xSize = arraySize(x);
      var ySize = arraySize(y);
      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
      }
      var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];
      if (highestDimension > 1) {
        return [product];
      } else {
        return product;
      }
    }
  });

  var name$u = 'diag';
  var dependencies$u = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];
  var createDiag = /* #__PURE__ */factory(name$u, dependencies$u, _ref => {
    var {
      typed,
      matrix,
      DenseMatrix,
      SparseMatrix
    } = _ref;

    /**
     * Create a diagonal matrix or retrieve the diagonal of a matrix
     *
     * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
     * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
     * When k is positive, the values are placed on the super diagonal.
     * When k is negative, the values are placed on the sub diagonal.
     *
     * Syntax:
     *
     *     math.diag(X)
     *     math.diag(X, format)
     *     math.diag(X, k)
     *     math.diag(X, k, format)
     *
     * Examples:
     *
     *     // create a diagonal matrix
     *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
     *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
     *
     *    // retrieve the diagonal from a matrix
     *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
     *    math.diag(a)   // returns [1, 5, 9]
     *
     * See also:
     *
     *     ones, zeros, identity
     *
     * @param {Matrix | Array} x          A two dimensional matrix or a vector
     * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
     *                                    in or retrieved.
     * @param {string} [format='dense']   The matrix storage format.
     *
     * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
     */
    return typed(name$u, {
      // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
      Array: function Array(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      'Array, number': function ArrayNumber(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      'Array, BigNumber': function ArrayBigNumber(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      'Array, string': function ArrayString(x, format) {
        return _diag(x, 0, arraySize(x), format);
      },
      'Array, number, string': function ArrayNumberString(x, k, format) {
        return _diag(x, k, arraySize(x), format);
      },
      'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {
        return _diag(x, k.toNumber(), arraySize(x), format);
      },
      Matrix: function Matrix(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      'Matrix, number': function MatrixNumber(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      'Matrix, BigNumber': function MatrixBigNumber(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      'Matrix, string': function MatrixString(x, format) {
        return _diag(x, 0, x.size(), format);
      },
      'Matrix, number, string': function MatrixNumberString(x, k, format) {
        return _diag(x, k, x.size(), format);
      },
      'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {
        return _diag(x, k.toNumber(), x.size(), format);
      }
    });
    /**
     * Creeate diagonal matrix from a vector or vice versa
     * @param {Array | Matrix} x
     * @param {number} k
     * @param {string} format Storage format for matrix. If null,
     *                          an Array is returned
     * @returns {Array | Matrix}
     * @private
     */

    function _diag(x, k, size, format) {
      if (!isInteger(k)) {
        throw new TypeError('Second parameter in function diag must be an integer');
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0; // check dimensions

      switch (size.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);
        case 2:
          return _getDiagonal(x, k, format, size, kSub, kSuper);
      }
      throw new RangeError('Matrix for function diag must be 2 dimensional');
    }
    function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
      // matrix size
      var ms = [l + kSub, l + kSuper];
      if (format && format !== 'sparse' && format !== 'dense') {
        throw new TypeError("Unknown matrix type ".concat(format, "\""));
      } // create diagonal matrix

      var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix

      return format !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format, s, kSub, kSuper) {
      // check x is a Matrix
      if (isMatrix(x)) {
        // get diagonal matrix
        var dm = x.diagonal(k); // check we need to return a matrix

        if (format !== null) {
          // check we need to change matrix format
          if (format !== dm.storage()) {
            return matrix(dm, format);
          }
          return dm;
        }
        return dm.valueOf();
      } // vector size

      var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values

      var vector = []; // loop diagonal

      for (var i = 0; i < n; i++) {
        vector[i] = x[i + kSub][i + kSuper];
      } // check we need to return a matrix

      return format !== null ? matrix(vector) : vector;
    }
  });

  var name$t = 'flatten';
  var dependencies$t = ['typed', 'matrix'];
  var createFlatten = /* #__PURE__ */factory(name$t, dependencies$t, _ref => {
    var {
      typed,
      matrix
    } = _ref;

    /**
     * Flatten a multi dimensional matrix into a single dimensional matrix.
     * It is guaranteed to always return a clone of the argument.
     *
     * Syntax:
     *
     *    math.flatten(x)
     *
     * Examples:
     *
     *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
     *
     * See also:
     *
     *    concat, resize, size, squeeze
     *
     * @param {Matrix | Array} x   Matrix to be flattened
     * @return {Matrix | Array} Returns the flattened matrix
     */
    return typed(name$t, {
      Array: function Array(x) {
        return flatten$1(clone$1(x));
      },
      Matrix: function Matrix(x) {
        var flat = flatten$1(clone$1(x.toArray())); // TODO: return the same matrix type as x

        return matrix(flat);
      }
    });
  });

  var name$s = 'identity';
  var dependencies$s = ['typed', 'config', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix'];
  var createIdentity = /* #__PURE__ */factory(name$s, dependencies$s, _ref => {
    var {
      typed,
      config,
      matrix,
      BigNumber,
      DenseMatrix,
      SparseMatrix
    } = _ref;

    /**
     * Create a 2-dimensional identity matrix with size m x n or n x n.
     * The matrix has ones on the diagonal and zeros elsewhere.
     *
     * Syntax:
     *
     *    math.identity(n)
     *    math.identity(n, format)
     *    math.identity(m, n)
     *    math.identity(m, n, format)
     *    math.identity([m, n])
     *    math.identity([m, n], format)
     *
     * Examples:
     *
     *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
     *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
     *
     *    const A = [[1, 2, 3], [4, 5, 6]]
     *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
     *
     * See also:
     *
     *    diag, ones, zeros, size, range
     *
     * @param {...number | Matrix | Array} size   The size for the matrix
     * @param {string} [format]                   The Matrix storage format
     *
     * @return {Matrix | Array | number} A matrix with ones on the diagonal.
     */
    return typed(name$s, {
      '': function _() {
        return config.matrix === 'Matrix' ? matrix([]) : [];
      },
      string: function string(format) {
        return matrix(format);
      },
      'number | BigNumber': function numberBigNumber(rows) {
        return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);
      },
      'number | BigNumber, string': function numberBigNumberString(rows, format) {
        return _identity(rows, rows, format);
      },
      'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(rows, cols) {
        return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);
      },
      'number | BigNumber, number | BigNumber, string': function numberBigNumberNumberBigNumberString(rows, cols, format) {
        return _identity(rows, cols, format);
      },
      Array: function Array(size) {
        return _identityVector(size);
      },
      'Array, string': function ArrayString(size, format) {
        return _identityVector(size, format);
      },
      Matrix: function Matrix(size) {
        return _identityVector(size.valueOf(), size.storage());
      },
      'Matrix, string': function MatrixString(size, format) {
        return _identityVector(size.valueOf(), format);
      }
    });
    function _identityVector(size, format) {
      switch (size.length) {
        case 0:
          return format ? matrix(format) : [];
        case 1:
          return _identity(size[0], size[0], format);
        case 2:
          return _identity(size[0], size[1], format);
        default:
          throw new Error('Vector containing two values expected');
      }
    }
    /**
     * Create an identity matrix
     * @param {number | BigNumber} rows
     * @param {number | BigNumber} cols
     * @param {string} [format]
     * @returns {Matrix}
     * @private
     */

    function _identity(rows, cols, format) {
      // BigNumber constructor with the right precision
      var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
      if (isBigNumber(rows)) rows = rows.toNumber();
      if (isBigNumber(cols)) cols = cols.toNumber();
      if (!isInteger(rows) || rows < 1) {
        throw new Error('Parameters in function identity must be positive integers');
      }
      if (!isInteger(cols) || cols < 1) {
        throw new Error('Parameters in function identity must be positive integers');
      }
      var one = Big ? new BigNumber(1) : 1;
      var defaultValue = Big ? new Big(0) : 0;
      var size = [rows, cols]; // check we need to return a matrix

      if (format) {
        // create diagonal matrix (use optimized implementation for storage format)
        if (format === 'sparse') {
          return SparseMatrix.diagonal(size, one, 0, defaultValue);
        }
        if (format === 'dense') {
          return DenseMatrix.diagonal(size, one, 0, defaultValue);
        }
        throw new TypeError("Unknown matrix type \"".concat(format, "\""));
      } // create and resize array

      var res = resize([], size, defaultValue); // fill in ones on the diagonal

      var minimum = rows < cols ? rows : cols; // fill diagonal

      for (var d = 0; d < minimum; d++) {
        res[d][d] = one;
      }
      return res;
    }
  });

  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  var name$r = 'range';
  var dependencies$r = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq'];
  var createRange = /* #__PURE__ */factory(name$r, dependencies$r, _ref => {
    var {
      typed,
      config,
      matrix,
      bignumber,
      smaller,
      smallerEq,
      larger,
      largerEq
    } = _ref;

    /**
     * Create an array from a range.
     * By default, the range end is excluded. This can be customized by providing
     * an extra parameter `includeEnd`.
     *
     * Syntax:
     *
     *     math.range(str [, includeEnd])               // Create a range from a string,
     *                                                  // where the string contains the
     *                                                  // start, optional step, and end,
     *                                                  // separated by a colon.
     *     math.range(start, end [, includeEnd])        // Create a range with start and
     *                                                  // end and a step size of 1.
     *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
     *                                                  // and end.
     *
     * Where:
     *
     * - `str: string`
     *   A string 'start:end' or 'start:step:end'
     * - `start: {number | BigNumber}`
     *   Start of the range
     * - `end: number | BigNumber`
     *   End of the range, excluded by default, included when parameter includeEnd=true
     * - `step: number | BigNumber`
     *   Step size. Default value is 1.
     * - `includeEnd: boolean`
     *   Option to specify whether to include the end or not. False by default.
     *
     * Examples:
     *
     *     math.range(2, 6)        // [2, 3, 4, 5]
     *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
     *     math.range('2:1:6')     // [2, 3, 4, 5]
     *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
     *
     * See also:
     *
     *     ones, zeros, size, subset
     *
     * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
     * @return {Array | Matrix} range
     */
    return typed(name$r, {
      // TODO: simplify signatures when typed-function supports default values and optional arguments
      // TODO: a number or boolean should not be converted to string here
      string: _strRange,
      'string, boolean': _strRange,
      'number, number': function numberNumber(start, end) {
        return _out(_rangeEx(start, end, 1));
      },
      'number, number, number': function numberNumberNumber(start, end, step) {
        return _out(_rangeEx(start, end, step));
      },
      'number, number, boolean': function numberNumberBoolean(start, end, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
      },
      'number, number, number, boolean': function numberNumberNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(start, end) {
        var BigNumber = start.constructor;
        return _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      'BigNumber, BigNumber, BigNumber': function BigNumberBigNumberBigNumber(start, end, step) {
        return _out(_bigRangeEx(start, end, step));
      },
      'BigNumber, BigNumber, boolean': function BigNumberBigNumberBoolean(start, end, includeEnd) {
        var BigNumber = start.constructor;
        return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
      },
      'BigNumber, BigNumber, BigNumber, boolean': function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
      }
    });
    function _out(arr) {
      if (config.matrix === 'Matrix') {
        return matrix ? matrix(arr) : noMatrix();
      }
      return arr;
    }
    function _strRange(str, includeEnd) {
      var r = _parse(str);
      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }
      var fn;
      if (config.number === 'BigNumber') {
        if (bignumber === undefined) {
          noBignumber();
        }
        fn = includeEnd ? _bigRangeInc : _bigRangeEx;
        return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
      } else {
        fn = includeEnd ? _rangeInc : _rangeEx;
        return _out(fn(r.start, r.end, r.step));
      }
    }
    /**
     * Create a range with numbers. End is excluded
     * @param {number} start
     * @param {number} end
     * @param {number} step
     * @returns {Array} range
     * @private
     */

    function _rangeEx(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smaller(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (larger(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    /**
     * Create a range with numbers. End is included
     * @param {number} start
     * @param {number} end
     * @param {number} step
     * @returns {Array} range
     * @private
     */

    function _rangeInc(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smallerEq(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (largerEq(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    /**
     * Create a range with big numbers. End is excluded
     * @param {BigNumber} start
     * @param {BigNumber} end
     * @param {BigNumber} step
     * @returns {Array} range
     * @private
     */

    function _bigRangeEx(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smaller(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (larger(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    /**
     * Create a range with big numbers. End is included
     * @param {BigNumber} start
     * @param {BigNumber} end
     * @param {BigNumber} step
     * @returns {Array} range
     * @private
     */

    function _bigRangeInc(start, end, step) {
      var zero = bignumber(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smallerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (largerEq(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    /**
     * Parse a string into a range,
     * The string contains the start, optional step, and end, separated by a colon.
     * If the string does not contain a valid range, null is returned.
     * For example str='0:2:11'.
     * @param {string} str
     * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
     * @private
     */

    function _parse(str) {
      var args = str.split(':'); // number

      var nums = args.map(function (arg) {
        // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
        return Number(arg);
      });
      var invalid = nums.some(function (num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };
        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };
        default:
          return null;
      }
    }
  });

  var name$q = 'size';
  var dependencies$q = ['typed', 'config', '?matrix'];
  var createSize = /* #__PURE__ */factory(name$q, dependencies$q, _ref => {
    var {
      typed,
      config,
      matrix
    } = _ref;

    /**
     * Calculate the size of a matrix or scalar.
     *
     * Syntax:
     *
     *     math.size(x)
     *
     * Examples:
     *
     *     math.size(2.3)                  // returns []
     *     math.size('hello world')        // returns [11]
     *
     *     const A = [[1, 2, 3], [4, 5, 6]]
     *     math.size(A)                    // returns [2, 3]
     *     math.size(math.range(1,6))      // returns [5]
     *
     * See also:
     *
     *     count, resize, squeeze, subset
     *
     * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
     * @return {Array | Matrix} A vector with size of `x`.
     */
    return typed(name$q, {
      Matrix: function Matrix(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string(x) {
        return config.matrix === 'Array' ? [x.length] : matrix([x.length]);
      },
      'number | Complex | BigNumber | Unit | boolean | null': function numberComplexBigNumberUnitBooleanNull(x) {
        // scalar
        return config.matrix === 'Array' ? [] : matrix ? matrix([]) : noMatrix();
      }
    });
  });

  var name$p = 'transpose';
  var dependencies$p = ['typed', 'matrix'];
  var createTranspose = /* #__PURE__ */factory(name$p, dependencies$p, _ref => {
    var {
      typed,
      matrix
    } = _ref;

    /**
     * Transpose a matrix. All values of the matrix are reflected over its
     * main diagonal. Only applicable to two dimensional matrices containing
     * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
     * vectors and scalars return the input unchanged.
     *
     * Syntax:
     *
     *     math.transpose(x)
     *
     * Examples:
     *
     *     const A = [[1, 2, 3], [4, 5, 6]]
     *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
     *
     * See also:
     *
     *     diag, inv, subset, squeeze
     *
     * @param {Array | Matrix} x  Matrix to be transposed
     * @return {Array | Matrix}   The transposed matrix
     */
    return typed('transpose', {
      Array: function Array(x) {
        // use dense matrix implementation
        return this(matrix(x)).valueOf();
      },
      Matrix: function Matrix(x) {
        // matrix size
        var size = x.size(); // result

        var c; // process dimensions

        switch (size.length) {
          case 1:
            // vector
            c = x.clone();
            break;
          case 2:
            {
              // rows and columns
              var rows = size[0];
              var columns = size[1]; // check columns

              if (columns === 0) {
                // throw exception
                throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');
              } // process storage format

              switch (x.storage()) {
                case 'dense':
                  c = _denseTranspose(x, rows, columns);
                  break;
                case 'sparse':
                  c = _sparseTranspose(x, rows, columns);
                  break;
              }
            }
            break;
          default:
            // multi dimensional
            throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');
        }
        return c;
      },
      // scalars
      any: function any(x) {
        return clone$1(x);
      }
    });
    function _denseTranspose(m, rows, columns) {
      // matrix array
      var data = m._data; // transposed matrix data

      var transposed = [];
      var transposedRow; // loop columns

      for (var j = 0; j < columns; j++) {
        // initialize row
        transposedRow = transposed[j] = []; // loop rows

        for (var i = 0; i < rows; i++) {
          // set data
          transposedRow[i] = clone$1(data[i][j]);
        }
      } // return matrix

      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
    function _sparseTranspose(m, rows, columns) {
      // matrix arrays
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // result matrices

      var cvalues = values ? [] : undefined;
      var cindex = [];
      var cptr = []; // row counts

      var w = [];
      for (var x = 0; x < rows; x++) {
        w[x] = 0;
      } // vars

      var p, l, j; // loop values in matrix

      for (p = 0, l = index.length; p < l; p++) {
        // number of values in row
        w[index[p]]++;
      } // cumulative sum

      var sum = 0; // initialize cptr with the cummulative sum of row counts

      for (var i = 0; i < rows; i++) {
        // update cptr
        cptr.push(sum); // update sum

        sum += w[i]; // update w

        w[i] = cptr[i];
      } // update cptr

      cptr.push(sum); // loop columns

      for (j = 0; j < columns; j++) {
        // values & index in column
        for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          // C values & index
          var q = w[index[k]]++; // C[j, i] = A[i, j]

          cindex[q] = j; // check we need to process values (pattern matrix)

          if (values) {
            cvalues[q] = clone$1(values[k]);
          }
        }
      } // return matrix

      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  });

  var name$o = 'ctranspose';
  var dependencies$o = ['typed', 'transpose', 'conj'];
  var createCtranspose = /* #__PURE__ */factory(name$o, dependencies$o, _ref => {
    var {
      typed,
      transpose,
      conj
    } = _ref;

    /**
     * Transpose and complex conjugate a matrix. All values of the matrix are
     * reflected over its main diagonal and then the complex conjugate is
     * taken. This is equivalent to complex conjugation for scalars and
     * vectors.
     *
     * Syntax:
     *
     *     math.ctranspose(x)
     *
     * Examples:
     *
     *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
     *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]
     *
     * See also:
     *
     *     transpose, diag, inv, subset, squeeze
     *
     * @param {Array | Matrix} x  Matrix to be ctransposed
     * @return {Array | Matrix}   The ctransposed matrix
     */
    return typed(name$o, {
      any: function any(x) {
        return conj(transpose(x));
      }
    });
  });

  var name$n = 'zeros';
  var dependencies$n = ['typed', 'config', 'matrix', 'BigNumber'];
  var createZeros = /* #__PURE__ */factory(name$n, dependencies$n, _ref => {
    var {
      typed,
      config,
      matrix,
      BigNumber
    } = _ref;

    /**
     * Create a matrix filled with zeros. The created matrix can have one or
     * multiple dimensions.
     *
     * Syntax:
     *
     *    math.zeros(m)
     *    math.zeros(m, format)
     *    math.zeros(m, n)
     *    math.zeros(m, n, format)
     *    math.zeros([m, n])
     *    math.zeros([m, n], format)
     *
     * Examples:
     *
     *    math.zeros(3)                  // returns [0, 0, 0]
     *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
     *    math.zeros(3, 'dense')         // returns [0, 0, 0]
     *
     *    const A = [[1, 2, 3], [4, 5, 6]]
     *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
     *
     * See also:
     *
     *    ones, identity, size, range
     *
     * @param {...number | Array} size    The size of each dimension of the matrix
     * @param {string} [format]           The Matrix storage format
     *
     * @return {Array | Matrix}           A matrix filled with zeros
     */
    return typed(name$n, {
      '': function _() {
        return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');
      },
      // math.zeros(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      '...number | BigNumber | string': function numberBigNumberString(size) {
        var last = size[size.length - 1];
        if (typeof last === 'string') {
          var format = size.pop();
          return _zeros(size, format);
        } else if (config.matrix === 'Array') {
          return _zeros(size);
        } else {
          return _zeros(size, 'default');
        }
      },
      Array: _zeros,
      Matrix: function Matrix(size) {
        var format = size.storage();
        return _zeros(size.valueOf(), format);
      },
      'Array | Matrix, string': function ArrayMatrixString(size, format) {
        return _zeros(size.valueOf(), format);
      }
    });
    /**
     * Create an Array or Matrix with zeros
     * @param {Array} size
     * @param {string} [format='default']
     * @return {Array | Matrix}
     * @private
     */

    function _zeros(size, format) {
      var hasBigNumbers = _normalize(size);
      var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;
      _validate(size);
      if (format) {
        // return a matrix
        var m = matrix(format);
        if (size.length > 0) {
          return m.resize(size, defaultValue);
        }
        return m;
      } else {
        // return an Array
        var arr = [];
        if (size.length > 0) {
          return resize(arr, size, defaultValue);
        }
        return arr;
      }
    } // replace BigNumbers with numbers, returns true if size contained BigNumbers

    function _normalize(size) {
      var hasBigNumbers = false;
      size.forEach(function (value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    } // validate arguments

    function _validate(size) {
      size.forEach(function (value) {
        if (typeof value !== 'number' || !isInteger(value) || value < 0) {
          throw new Error('Parameters in function zeros must be positive integers');
        }
      });
    }
  }); // TODO: zeros contains almost the same code as ones. Reuse this?

  var name$m = 'numeric';
  var dependencies$m = ['number', '?bignumber', '?fraction'];
  var createNumeric = /* #__PURE__ */factory(name$m, dependencies$m, _ref => {
    var {
      number: _number,
      bignumber,
      fraction
    } = _ref;
    var validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    }; // Load the conversion functions for each output type

    var validOutputTypes = {
      number: x => _number(x),
      BigNumber: bignumber ? x => bignumber(x) : noBignumber,
      Fraction: fraction ? x => fraction(x) : noFraction
    };
    /**
     * Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.
     *
     * Syntax:
     *
     *    math.numeric(x)
     *
     * Examples:
     *
     *    math.numeric('4')                           // returns number 4
     *    math.numeric('4', 'number')                 // returns number 4
     *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
     *    math.numeric('4', 'Fraction')               // returns Fraction 4
     *    math.numeric(4, 'Fraction')                 // returns Fraction 4
     *    math.numeric(math.fraction(2, 5), 'number') // returns number 0.4
     *
     * See also:
     *
     *    number, fraction, bignumber, string, format
     *
     * @param {string | number | BigNumber | Fraction } value
     *              A numeric value or a string containing a numeric value
     * @param {string} outputType
     *              Desired numeric output type.
     *              Available values: 'number', 'BigNumber', or 'Fraction'
     * @return {number | BigNumber | Fraction}
     *              Returns an instance of the numeric in the requested type
     */

    return function numeric(value, outputType) {
      var inputType = typeOf(value);
      if (!(inputType in validInputTypes)) {
        throw new TypeError('Cannot convert ' + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(', '));
      }
      if (!(outputType in validOutputTypes)) {
        throw new TypeError('Cannot convert ' + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(', '));
      }
      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  });

  var name$l = 'divideScalar';
  var dependencies$l = ['typed', 'numeric'];
  var createDivideScalar = /* #__PURE__ */factory(name$l, dependencies$l, _ref => {
    var {
      typed,
      numeric
    } = _ref;

    /**
     * Divide two scalar values, `x / y`.
     * This function is meant for internal use: it is used by the public functions
     * `divide` and `inv`.
     *
     * This function does not support collections (Array or Matrix).
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
     * @param  {number | BigNumber | Fraction | Complex} y          Denominator
     * @return {number | BigNumber | Fraction | Complex | Unit}     Quotient, `x / y`
     * @private
     */
    return typed(name$l, {
      'number, number': function numberNumber(x, y) {
        return x / y;
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.div(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.div(y);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.div(y);
      },
      'Unit, number | Fraction | BigNumber': function UnitNumberFractionBigNumber(x, y) {
        var res = x.clone(); // TODO: move the divide function to Unit.js, it uses internals of Unit

        var one = numeric(1, typeOf(y));
        res.value = this(res.value === null ? res._normalize(one) : res.value, y);
        return res;
      },
      'number | Fraction | BigNumber, Unit': function numberFractionBigNumberUnit(x, y) {
        var res = y.clone();
        res = res.pow(-1); // TODO: move the divide function to Unit.js, it uses internals of Unit

        var one = numeric(1, typeOf(x));
        res.value = this(x, y.value === null ? y._normalize(one) : y.value);
        return res;
      },
      'Unit, Unit': function UnitUnit(x, y) {
        return x.divide(y);
      }
    });
  });

  var name$k = 'pow';
  var dependencies$k = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];
  var createPow = /* #__PURE__ */factory(name$k, dependencies$k, _ref => {
    var {
      typed,
      config,
      identity,
      multiply,
      matrix,
      inv,
      number,
      fraction,
      Complex
    } = _ref;

    /**
     * Calculates the power of x to y, `x ^ y`.
     *
     * Matrix exponentiation is supported for square matrices `x` and integers `y`:
     * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
     * negative, `x` must be invertible, and then this function returns
     * inv(x)^(-y).
     *
     * For cubic roots of negative numbers, the function returns the principal
     * root by default. In order to let the function return the real root,
     * math.js can be configured with `math.config({predictable: true})`.
     * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
     *
     * Syntax:
     *
     *    math.pow(x, y)
     *
     * Examples:
     *
     *    math.pow(2, 3)               // returns number 8
     *
     *    const a = math.complex(2, 3)
     *    math.pow(a, 2)                // returns Complex -5 + 12i
     *
     *    const b = [[1, 2], [4, 3]]
     *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
     *
     *    const c = [[1, 2], [4, 3]]
     *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
     *
     * See also:
     *
     *    multiply, sqrt, cbrt, nthRoot
     *
     * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
     * @param  {number | BigNumber | Complex} y                          The exponent
     * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
     */
    return typed(name$k, {
      'number, number': _pow,
      'Complex, Complex': function ComplexComplex(x, y) {
        return x.pow(y);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        if (y.isInteger() || x >= 0 || config.predictable) {
          return x.pow(y);
        } else {
          return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
        }
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        var result = x.pow(y);
        if (result != null) {
          return result;
        }
        if (config.predictable) {
          throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');
        } else {
          return _pow(x.valueOf(), y.valueOf());
        }
      },
      'Array, number': _powArray,
      'Array, BigNumber': function ArrayBigNumber(x, y) {
        return _powArray(x, y.toNumber());
      },
      'Matrix, number': _powMatrix,
      'Matrix, BigNumber': function MatrixBigNumber(x, y) {
        return _powMatrix(x, y.toNumber());
      },
      'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {
        return x.pow(y);
      }
    });
    /**
     * Calculates the power of x to y, x^y, for two numbers.
     * @param {number} x
     * @param {number} y
     * @return {number | Complex} res
     * @private
     */

    function _pow(x, y) {
      // Alternatively could define a 'realmode' config option or something, but
      // 'predictable' will work for now
      if (config.predictable && !isInteger(y) && x < 0) {
        // Check to see if y can be represented as a fraction
        try {
          var yFrac = fraction(y);
          var yNum = number(yFrac);
          if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
            if (yFrac.d % 2 === 1) {
              return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
            }
          }
        } catch (ex) {// fraction() throws an error if y is Infinity, etc.
        } // Unable to express y as a fraction, so continue on
      } // **for predictable mode** x^Infinity === NaN if x < -1
      // N.B. this behavour is different from `Math.pow` which gives
      // (-2)^Infinity === Infinity

      if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
        return NaN;
      }
      if (isInteger(y) || x >= 0 || config.predictable) {
        return powNumber(x, y);
      } else {
        // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
        // x^Infinity === 0 if -1 < x < 1
        // A real number 0 is returned instead of complex(0)
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }
        return new Complex(x, 0).pow(y, 0);
      }
    }
    /**
     * Calculate the power of a 2d array
     * @param {Array} x     must be a 2 dimensional, square matrix
     * @param {number} y    a integer value (positive if `x` is not invertible)
     * @returns {Array}
     * @private
     */

    function _powArray(x, y) {
      if (!isInteger(y)) {
        throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');
      } // verify that A is a 2 dimensional square matrix

      var s = arraySize(x);
      if (s.length !== 2) {
        throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
      }
      if (s[0] !== s[1]) {
        throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
      }
      if (y < 0) {
        try {
          return _powArray(inv(x), -y);
        } catch (error) {
          if (error.message === 'Cannot calculate inverse, determinant is zero') {
            throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');
          }
          throw error;
        }
      }
      var res = identity(s[0]).valueOf();
      var px = x;
      while (y >= 1) {
        if ((y & 1) === 1) {
          res = multiply(px, res);
        }
        y >>= 1;
        px = multiply(px, px);
      }
      return res;
    }
    /**
     * Calculate the power of a 2d matrix
     * @param {Matrix} x     must be a 2 dimensional, square matrix
     * @param {number} y    a positive, integer value
     * @returns {Matrix}
     * @private
     */

    function _powMatrix(x, y) {
      return matrix(_powArray(x.valueOf(), y));
    }
  });

  function createSolveValidation(_ref) {
    var {
      DenseMatrix
    } = _ref;

    /**
     * Validates matrix and column vector b for backward/forward substitution algorithms.
     *
     * @param {Matrix} m            An N x N matrix
     * @param {Array | Matrix} b    A column vector
     * @param {Boolean} copy        Return a copy of vector b
     *
     * @return {DenseMatrix}        Dense column vector b
     */
    return function solveValidation(m, b, copy) {
      var mSize = m.size();
      if (mSize.length !== 2) {
        throw new RangeError('Matrix must be two dimensional (size: ' + format(mSize) + ')');
      }
      var rows = mSize[0];
      var columns = mSize[1];
      if (rows !== columns) {
        throw new RangeError('Matrix must be square (size: ' + format(mSize) + ')');
      }
      var data = [];
      if (isMatrix(b)) {
        var bSize = b.size();
        var bdata = b._data; // 1-dim vector

        if (bSize.length === 1) {
          if (bSize[0] !== rows) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          }
          for (var i = 0; i < rows; i++) {
            data[i] = [bdata[i]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        } // 2-dim column

        if (bSize.length === 2) {
          if (bSize[0] !== rows || bSize[1] !== 1) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          }
          if (isDenseMatrix(b)) {
            if (copy) {
              data = [];
              for (var _i = 0; _i < rows; _i++) {
                data[_i] = [bdata[_i][0]];
              }
              return new DenseMatrix({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
            return b;
          }
          if (isSparseMatrix(b)) {
            for (var _i2 = 0; _i2 < rows; _i2++) {
              data[_i2] = [0];
            }
            var values = b._values;
            var index = b._index;
            var ptr = b._ptr;
            for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
              var _i3 = index[k];
              data[_i3][0] = values[k];
            }
            return new DenseMatrix({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
        }
        throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
      }
      if (isArray(b)) {
        var bsize = arraySize(b);
        if (bsize.length === 1) {
          if (bsize[0] !== rows) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          }
          for (var _i4 = 0; _i4 < rows; _i4++) {
            data[_i4] = [b[_i4]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1]
          });
        }
        if (bsize.length === 2) {
          if (bsize[0] !== rows || bsize[1] !== 1) {
            throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
          }
          for (var _i5 = 0; _i5 < rows; _i5++) {
            data[_i5] = [b[_i5][0]];
          }
          return new DenseMatrix({
            data,
            size: [rows, 1]
          });
        }
        throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
      }
    };
  }

  var name$j = 'usolve';
  var dependencies$j = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
  var createUsolve = /* #__PURE__ */factory(name$j, dependencies$j, _ref => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    /**
     * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
     *
     * `U * x = b`
     *
     * Syntax:
     *
     *    math.usolve(U, b)
     *
     * Examples:
     *
     *    const a = [[-2, 3], [2, 1]]
     *    const b = [11, 9]
     *    const x = usolve(a, b)  // [[8], [9]]
     *
     * See also:
     *
     *    usolveAll, lup, slu, usolve, lusolve
     *
     * @param {Matrix, Array} U       A N x N matrix or array (U)
     * @param {Matrix, Array} b       A column vector with the b values
     *
     * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
     */

    return typed(name$j, {
      'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var r = _denseBackwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseBackwardSubstitution(m, b) {
      // make b into a column vector
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1]; // result

      var x = [];
      var mdata = m._data; // loop columns backwards

      for (var j = columns - 1; j >= 0; j--) {
        // b[j]
        var bj = bdata[j][0] || 0; // x[j]

        var xj = void 0;
        if (!equalScalar(bj, 0)) {
          // value at [j, j]
          var vjj = mdata[j][j];
          if (equalScalar(vjj, 0)) {
            // system cannot be solved
            throw new Error('Linear system cannot be solved since matrix is singular');
          }
          xj = divideScalar(bj, vjj); // loop rows

          for (var i = j - 1; i >= 0; i--) {
            // update copy of b
            bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
          }
        } else {
          // zero value at j
          xj = 0;
        } // update x

        x[j] = [xj];
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseBackwardSubstitution(m, b) {
      // make b into a column vector
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // result

      var x = []; // loop columns backwards

      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar(bj, 0)) {
          // non-degenerate row, find solution
          var vjj = 0; // upper triangular matrix values & index (column j)

          var jValues = [];
          var jIndices = []; // first & last indeces in column

          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1]; // values in column, find value at [j, j], loop backwards

          for (var k = lastIndex - 1; k >= firstIndex; k--) {
            var i = index[k]; // check row (rows are not sorted!)

            if (i === j) {
              vjj = values[k];
            } else if (i < j) {
              // store upper triangular
              jValues.push(values[k]);
              jIndices.push(i);
            }
          } // at this point we must have a value in vjj

          if (equalScalar(vjj, 0)) {
            throw new Error('Linear system cannot be solved since matrix is singular');
          }
          var xj = divideScalar(bj, vjj);
          for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          // degenerate row, we can choose any value
          x[j] = [0];
        }
      }
      return new DenseMatrix({
        data: x,
        size: [rows, 1]
      });
    }
  });

  var name$i = 'usolveAll';
  var dependencies$i = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
  var createUsolveAll = /* #__PURE__ */factory(name$i, dependencies$i, _ref => {
    var {
      typed,
      matrix,
      divideScalar,
      multiplyScalar,
      subtract,
      equalScalar,
      DenseMatrix
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix
    });
    /**
     * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
     *
     * `U * x = b`
     *
     * Syntax:
     *
     *    math.usolveAll(U, b)
     *
     * Examples:
     *
     *    const a = [[-2, 3], [2, 1]]
     *    const b = [11, 9]
     *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
     *
     * See also:
     *
     *    usolve, lup, slu, usolve, lusolve
     *
     * @param {Matrix, Array} U       A N x N matrix or array (U)
     * @param {Matrix, Array} b       A column vector with the b values
     *
     * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
     */

    return typed(name$i, {
      'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
        var m = matrix(a);
        var R = _denseBackwardSubstitution(m, b);
        return R.map(r => r.valueOf());
      }
    });
    function _denseBackwardSubstitution(m, b_) {
      // the algorithm is derived from
      // https://www.overleaf.com/read/csvgqdxggyjv
      // array of right-hand sides
      var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1]; // loop columns backwards

      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length; // loop right-hand sides

        for (var k = 0; k < L; k++) {
          var b = B[k];
          if (!equalScalar(M[i][i], 0)) {
            // non-singular row
            b[i] = divideScalar(b[i], M[i][i]);
            for (var j = i - 1; j >= 0; j--) {
              // b[j] -= b[i] * M[j,i]
              b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
            }
          } else if (!equalScalar(b[i], 0)) {
            // singular row, nonzero RHS
            if (k === 0) {
              // There is no valid solution
              return [];
            } else {
              // This RHS is invalid but other solutions may still exist
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            // singular row, RHS is zero
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j = i - 1; _j >= 0; _j--) {
              bNew[_j] = subtract(bNew[_j], M[_j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map(x => new DenseMatrix({
        data: x.map(e => [e]),
        size: [rows, 1]
      }));
    }
    function _sparseBackwardSubstitution(m, b_) {
      // array of right-hand sides
      var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr; // loop columns backwards

      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length; // loop right-hand sides

        for (var k = 0; k < L; k++) {
          var b = B[k]; // values & indices (column i)

          var iValues = [];
          var iIndices = []; // first & last indeces in column

          var firstIndex = ptr[i];
          var lastIndex = ptr[i + 1]; // find the value at [i, i]

          var Mii = 0;
          for (var j = lastIndex - 1; j >= firstIndex; j--) {
            var J = index[j]; // check row

            if (J === i) {
              Mii = values[j];
            } else if (J < i) {
              // store upper triangular
              iValues.push(values[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar(Mii, 0)) {
            // non-singular row
            b[i] = divideScalar(b[i], Mii); // loop upper triangular

            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
            }
          } else if (!equalScalar(b[i], 0)) {
            // singular row, nonzero RHS
            if (k === 0) {
              // There is no valid solution
              return [];
            } else {
              // This RHS is invalid but other solutions may still exist
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            // singular row, RHS is zero
            var bNew = [...b];
            bNew[i] = 1; // loop upper triangular

            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map(x => new DenseMatrix({
        data: x.map(e => [e]),
        size: [rows, 1]
      }));
    }
  });

  var name$h = 'equal';
  var dependencies$h = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
  var createEqual = /* #__PURE__ */factory(name$h, dependencies$h, _ref => {
    var {
      typed,
      matrix,
      equalScalar,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Test whether two values are equal.
     *
     * The function tests whether the relative difference between x and y is
     * smaller than the configured epsilon. The function cannot be used to
     * compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
     *
     * Values `null` and `undefined` are compared strictly, thus `null` is only
     * equal to `null` and nothing else, and `undefined` is only equal to
     * `undefined` and nothing else. Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.equal(x, y)
     *
     * Examples:
     *
     *    math.equal(2 + 2, 3)         // returns false
     *    math.equal(2 + 2, 4)         // returns true
     *
     *    const a = math.unit('50 cm')
     *    const b = math.unit('5 m')
     *    math.equal(a, b)             // returns true
     *
     *    const c = [2, 5, 1]
     *    const d = [2, 7, 1]
     *
     *    math.equal(c, d)             // returns [true, false, true]
     *    math.deepEqual(c, d)         // returns false
     *
     *    math.equal("1000", "1e3")    // returns true
     *    math.equal(0, null)          // returns false
     *
     * See also:
     *
     *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
     *
     * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
     */

    return typed(name$h, {
      'any, any': function anyAny(x, y) {
        // strict equality for null and undefined?
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === undefined) {
          return y === undefined;
        }
        if (y === undefined) {
          return x === undefined;
        }
        return equalScalar(x, y);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, equalScalar);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, equalScalar, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, equalScalar, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, equalScalar);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, equalScalar, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, equalScalar, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, equalScalar, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, equalScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, equalScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, equalScalar, true).valueOf();
      }
    });
  });
  factory(name$h, ['typed', 'equalScalar'], _ref2 => {
    var {
      typed,
      equalScalar
    } = _ref2;
    return typed(name$h, {
      'any, any': function anyAny(x, y) {
        // strict equality for null and undefined?
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === undefined) {
          return y === undefined;
        }
        if (y === undefined) {
          return x === undefined;
        }
        return equalScalar(x, y);
      }
    });
  });

  var name$g = 'smaller';
  var dependencies$g = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createSmaller = /* #__PURE__ */factory(name$g, dependencies$g, _ref => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Test whether value x is smaller than y.
     *
     * The function returns true when x is smaller than y and the relative
     * difference between x and y is smaller than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.smaller(x, y)
     *
     * Examples:
     *
     *    math.smaller(2, 3)            // returns true
     *    math.smaller(5, 2 * 2)        // returns false
     *
     *    const a = math.unit('5 cm')
     *    const b = math.unit('2 inch')
     *    math.smaller(a, b)            // returns true
     *
     * See also:
     *
     *    equal, unequal, smallerEq, smaller, smallerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
     */

    return typed(name$g, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x < y;
      },
      'number, number': function numberNumber(x, y) {
        return x < y && !nearlyEqual$1(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.lt(y) && !nearlyEqual(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) === -1;
      },
      'Complex, Complex': function ComplexComplex(x, y) {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }
        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$f = 'smallerEq';
  var dependencies$f = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createSmallerEq = /* #__PURE__ */factory(name$f, dependencies$f, _ref => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Test whether value x is smaller or equal to y.
     *
     * The function returns true when x is smaller than y or the relative
     * difference between x and y is smaller than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.smallerEq(x, y)
     *
     * Examples:
     *
     *    math.smaller(1 + 2, 3)        // returns false
     *    math.smallerEq(1 + 2, 3)      // returns true
     *
     * See also:
     *
     *    equal, unequal, smaller, larger, largerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
     */

    return typed(name$f, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x <= y;
      },
      'number, number': function numberNumber(x, y) {
        return x <= y || nearlyEqual$1(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.lte(y) || nearlyEqual(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) !== 1;
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }
        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$e = 'larger';
  var dependencies$e = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createLarger = /* #__PURE__ */factory(name$e, dependencies$e, _ref => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Test whether value x is larger than y.
     *
     * The function returns true when x is larger than y and the relative
     * difference between x and y is larger than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.larger(x, y)
     *
     * Examples:
     *
     *    math.larger(2, 3)             // returns false
     *    math.larger(5, 2 + 2)         // returns true
     *
     *    const a = math.unit('5 cm')
     *    const b = math.unit('2 inch')
     *    math.larger(a, b)             // returns false
     *
     * See also:
     *
     *    equal, unequal, smaller, smallerEq, largerEq, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
     */

    return typed(name$e, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x > y;
      },
      'number, number': function numberNumber(x, y) {
        return x > y && !nearlyEqual$1(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.gt(y) && !nearlyEqual(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) === 1;
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }
        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$d = 'largerEq';
  var dependencies$d = ['typed', 'config', 'matrix', 'DenseMatrix'];
  var createLargerEq = /* #__PURE__ */factory(name$d, dependencies$d, _ref => {
    var {
      typed,
      config,
      matrix,
      DenseMatrix
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed
    });
    var algorithm07 = createAlgorithm07({
      typed,
      DenseMatrix
    });
    var algorithm12 = createAlgorithm12({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Test whether value x is larger or equal to y.
     *
     * The function returns true when x is larger than y or the relative
     * difference between x and y is smaller than the configured epsilon. The
     * function cannot be used to compare values smaller than approximately 2.22e-16.
     *
     * For matrices, the function is evaluated element wise.
     * Strings are compared by their numerical value.
     *
     * Syntax:
     *
     *    math.largerEq(x, y)
     *
     * Examples:
     *
     *    math.larger(2, 1 + 1)         // returns false
     *    math.largerEq(2, 1 + 1)       // returns true
     *
     * See also:
     *
     *    equal, unequal, smaller, smallerEq, larger, compare
     *
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
     * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
     * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
     */

    return typed(name$d, {
      'boolean, boolean': function booleanBoolean(x, y) {
        return x >= y;
      },
      'number, number': function numberNumber(x, y) {
        return x >= y || nearlyEqual$1(x, y, config.epsilon);
      },
      'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
        return x.gte(y) || nearlyEqual(x, y, config.epsilon);
      },
      'Fraction, Fraction': function FractionFraction(x, y) {
        return x.compare(y) !== -1;
      },
      'Complex, Complex': function ComplexComplex() {
        throw new TypeError('No ordering relation is defined for complex numbers');
      },
      'Unit, Unit': function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error('Cannot compare units with different base');
        }
        return this(x.value, y.value);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, this, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, this, true).valueOf();
      }
    });
  });

  var name$c = 'ImmutableDenseMatrix';
  var dependencies$c = ['smaller', 'DenseMatrix'];
  var createImmutableDenseMatrixClass = /* #__PURE__ */factory(name$c, dependencies$c, _ref => {
    var {
      smaller,
      DenseMatrix
    } = _ref;
    function ImmutableDenseMatrix(data, datatype) {
      if (!(this instanceof ImmutableDenseMatrix)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
      if (datatype && !isString(datatype)) {
        throw new Error('Invalid datatype: ' + datatype);
      }
      if (isMatrix(data) || isArray(data)) {
        // use DenseMatrix implementation
        var matrix = new DenseMatrix(data, datatype); // internal structures

        this._data = matrix._data;
        this._size = matrix._size;
        this._datatype = matrix._datatype;
        this._min = null;
        this._max = null;
      } else if (data && isArray(data.data) && isArray(data.size)) {
        // initialize fields from JSON representation
        this._data = data.data;
        this._size = data.size;
        this._datatype = data.datatype;
        this._min = typeof data.min !== 'undefined' ? data.min : null;
        this._max = typeof data.max !== 'undefined' ? data.max : null;
      } else if (data) {
        // unsupported type
        throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
      } else {
        // nothing provided
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
        this._min = null;
        this._max = null;
      }
    }
    ImmutableDenseMatrix.prototype = new DenseMatrix();
    /**
     * Attach type information
     */

    ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
    ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
    /**
     * Get a subset of the matrix, or replace a subset of the matrix.
     *
     * Usage:
     *     const subset = matrix.subset(index)               // retrieve subset
     *     const value = matrix.subset(index, replacement)   // replace subset
     *
     * @param {Index} index
     * @param {Array | ImmutableDenseMatrix | *} [replacement]
     * @param {*} [defaultValue=0]      Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be filled with zeros.
     */

    ImmutableDenseMatrix.prototype.subset = function (index) {
      switch (arguments.length) {
        case 1:
          {
            // use base implementation
            var m = DenseMatrix.prototype.subset.call(this, index); // check result is a matrix

            if (isMatrix(m)) {
              // return immutable matrix
              return new ImmutableDenseMatrix({
                data: m._data,
                size: m._size,
                datatype: m._datatype
              });
            }
            return m;
          }
        // intentional fall through

        case 2:
        case 3:
          throw new Error('Cannot invoke set subset on an Immutable Matrix instance');
        default:
          throw new SyntaxError('Wrong number of arguments');
      }
    };
    /**
     * Replace a single element in the matrix.
     * @param {Number[]} index   Zero-based index
     * @param {*} value
     * @param {*} [defaultValue]        Default value, filled in on new entries when
     *                                  the matrix is resized. If not provided,
     *                                  new matrix elements will be left undefined.
     * @return {ImmutableDenseMatrix} self
     */

    ImmutableDenseMatrix.prototype.set = function () {
      throw new Error('Cannot invoke set on an Immutable Matrix instance');
    };
    /**
     * Resize the matrix to the given size. Returns a copy of the matrix when
     * `copy=true`, otherwise return the matrix itself (resize in place).
     *
     * @param {Number[]} size           The new size the matrix should have.
     * @param {*} [defaultValue=0]      Default value, filled in on new entries.
     *                                  If not provided, the matrix elements will
     *                                  be filled with zeros.
     * @param {boolean} [copy]          Return a resized copy of the matrix
     *
     * @return {Matrix}                 The resized matrix
     */

    ImmutableDenseMatrix.prototype.resize = function () {
      throw new Error('Cannot invoke resize on an Immutable Matrix instance');
    };
    /**
     * Disallows reshaping in favor of immutability.
     *
     * @throws {Error} Operation not allowed
     */

    ImmutableDenseMatrix.prototype.reshape = function () {
      throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
    };
    /**
     * Create a clone of the matrix
     * @return {ImmutableDenseMatrix} clone
     */

    ImmutableDenseMatrix.prototype.clone = function () {
      return new ImmutableDenseMatrix({
        data: clone$1(this._data),
        size: clone$1(this._size),
        datatype: this._datatype
      });
    };
    /**
     * Get a JSON representation of the matrix
     * @returns {Object}
     */

    ImmutableDenseMatrix.prototype.toJSON = function () {
      return {
        mathjs: 'ImmutableDenseMatrix',
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    /**
     * Generate a matrix from a JSON object
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
     *                       where mathjs is optional
     * @returns {ImmutableDenseMatrix}
     */

    ImmutableDenseMatrix.fromJSON = function (json) {
      return new ImmutableDenseMatrix(json);
    };
    /**
     * Swap rows i and j in Matrix.
     *
     * @param {Number} i       Matrix row index 1
     * @param {Number} j       Matrix row index 2
     *
     * @return {Matrix}        The matrix reference
     */

    ImmutableDenseMatrix.prototype.swapRows = function () {
      throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
    };
    /**
     * Calculate the minimum value in the set
     * @return {Number | undefined} min
     */

    ImmutableDenseMatrix.prototype.min = function () {
      // check min has been calculated before
      if (this._min === null) {
        // minimum
        var m = null; // compute min

        this.forEach(function (v) {
          if (m === null || smaller(v, m)) {
            m = v;
          }
        });
        this._min = m !== null ? m : undefined;
      }
      return this._min;
    };
    /**
     * Calculate the maximum value in the set
     * @return {Number | undefined} max
     */

    ImmutableDenseMatrix.prototype.max = function () {
      // check max has been calculated before
      if (this._max === null) {
        // maximum
        var m = null; // compute max

        this.forEach(function (v) {
          if (m === null || smaller(m, v)) {
            m = v;
          }
        });
        this._max = m !== null ? m : undefined;
      }
      return this._max;
    };
    return ImmutableDenseMatrix;
  }, {
    isClass: true
  });

  var name$b = 'Index';
  var dependencies$b = ['ImmutableDenseMatrix'];
  var createIndexClass = /* #__PURE__ */factory(name$b, dependencies$b, _ref => {
    var {
      ImmutableDenseMatrix
    } = _ref;

    /**
     * Create an index. An Index can store ranges and sets for multiple dimensions.
     * Matrix.get, Matrix.set, and math.subset accept an Index as input.
     *
     * Usage:
     *     const index = new Index(range1, range2, matrix1, array1, ...)
     *
     * Where each parameter can be any of:
     *     A number
     *     A string (containing a name of an object property)
     *     An instance of Range
     *     An Array with the Set values
     *     A Matrix with the Set values
     *
     * The parameters start, end, and step must be integer numbers.
     *
     * @class Index
     * @Constructor Index
     * @param {...*} ranges
     */
    function Index(ranges) {
      if (!(this instanceof Index)) {
        throw new SyntaxError('Constructor must be called with the new operator');
      }
      this._dimensions = [];
      this._isScalar = true;
      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];
        if (isRange(arg)) {
          this._dimensions.push(arg);
          this._isScalar = false;
        } else if (Array.isArray(arg) || isMatrix(arg)) {
          // create matrix
          var m = _createImmutableMatrix(arg.valueOf());
          this._dimensions.push(m); // size

          var size = m.size(); // scalar

          if (size.length !== 1 || size[0] !== 1) {
            this._isScalar = false;
          }
        } else if (typeof arg === 'number') {
          this._dimensions.push(_createImmutableMatrix([arg]));
        } else if (typeof arg === 'string') {
          // object property (arguments.count should be 1)
          this._dimensions.push(arg);
        } else {
          throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
        } // TODO: implement support for wildcard '*'
      }
    }
    /**
     * Attach type information
     */

    Index.prototype.type = 'Index';
    Index.prototype.isIndex = true;
    function _createImmutableMatrix(arg) {
      // loop array elements
      for (var i = 0, l = arg.length; i < l; i++) {
        if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
          throw new TypeError('Index parameters must be positive integer numbers');
        }
      } // create matrix

      return new ImmutableDenseMatrix(arg);
    }
    /**
     * Create a clone of the index
     * @memberof Index
     * @return {Index} clone
     */

    Index.prototype.clone = function () {
      var index = new Index();
      index._dimensions = clone$1(this._dimensions);
      index._isScalar = this._isScalar;
      return index;
    };
    /**
     * Create an index from an array with ranges/numbers
     * @memberof Index
     * @param {Array.<Array | number>} ranges
     * @return {Index} index
     * @private
     */

    Index.create = function (ranges) {
      var index = new Index();
      Index.apply(index, ranges);
      return index;
    };
    /**
     * Retrieve the size of the index, the number of elements for each dimension.
     * @memberof Index
     * @returns {number[]} size
     */

    Index.prototype.size = function () {
      var size = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var d = this._dimensions[i];
        size[i] = typeof d === 'string' ? 1 : d.size()[0];
      }
      return size;
    };
    /**
     * Get the maximum value for each of the indexes ranges.
     * @memberof Index
     * @returns {number[]} max
     */

    Index.prototype.max = function () {
      var values = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values[i] = typeof range === 'string' ? range : range.max();
      }
      return values;
    };
    /**
     * Get the minimum value for each of the indexes ranges.
     * @memberof Index
     * @returns {number[]} min
     */

    Index.prototype.min = function () {
      var values = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range = this._dimensions[i];
        values[i] = typeof range === 'string' ? range : range.min();
      }
      return values;
    };
    /**
     * Loop over each of the ranges of the index
     * @memberof Index
     * @param {Function} callback   Called for each range with a Range as first
     *                              argument, the dimension as second, and the
     *                              index object as third.
     */

    Index.prototype.forEach = function (callback) {
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        callback(this._dimensions[i], i, this);
      }
    };
    /**
     * Retrieve the dimension for the given index
     * @memberof Index
     * @param {Number} dim                  Number of the dimension
     * @returns {Range | null} range
     */

    Index.prototype.dimension = function (dim) {
      return this._dimensions[dim] || null;
    };
    /**
     * Test whether this index contains an object property
     * @returns {boolean} Returns true if the index is an object property
     */

    Index.prototype.isObjectProperty = function () {
      return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
    };
    /**
     * Returns the object property name when the Index holds a single object property,
     * else returns null
     * @returns {string | null}
     */

    Index.prototype.getObjectProperty = function () {
      return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    /**
     * Test whether this index contains only a single value.
     *
     * This is the case when the index is created with only scalar values as ranges,
     * not for ranges resolving into a single value.
     * @memberof Index
     * @return {boolean} isScalar
     */

    Index.prototype.isScalar = function () {
      return this._isScalar;
    };
    /**
     * Expand the Index into an array.
     * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
     * @memberof Index
     * @returns {Array} array
     */

    Index.prototype.toArray = function () {
      var array = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        array.push(typeof dimension === 'string' ? dimension : dimension.toArray());
      }
      return array;
    };
    /**
     * Get the primitive value of the Index, a two dimensional array.
     * Equivalent to Index.toArray().
     * @memberof Index
     * @returns {Array} array
     */

    Index.prototype.valueOf = Index.prototype.toArray;
    /**
     * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
     * @memberof Index
     * @returns {String} str
     */

    Index.prototype.toString = function () {
      var strings = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        if (typeof dimension === 'string') {
          strings.push(JSON.stringify(dimension));
        } else {
          strings.push(dimension.toString());
        }
      }
      return '[' + strings.join(', ') + ']';
    };
    /**
     * Get a JSON representation of the Index
     * @memberof Index
     * @returns {Object} Returns a JSON object structured as:
     *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
     */

    Index.prototype.toJSON = function () {
      return {
        mathjs: 'Index',
        dimensions: this._dimensions
      };
    };
    /**
     * Instantiate an Index from a JSON object
     * @memberof Index
     * @param {Object} json A JSON object structured as:
     *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
     * @return {Index}
     */

    Index.fromJSON = function (json) {
      return Index.create(json.dimensions);
    };
    return Index;
  }, {
    isClass: true
  });

  var name$a = 'atan';
  var dependencies$a = ['typed'];
  var createAtan = /* #__PURE__ */factory(name$a, dependencies$a, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Calculate the inverse tangent of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.atan(x)
     *
     * Examples:
     *
     *    math.atan(0.5)           // returns number 0.4636476090008061
     *    math.atan(math.tan(1.5)) // returns number 1.5
     *
     *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
     *
     * See also:
     *
     *    tan, asin, acos
     *
     * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
     * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
     */
    return typed('atan', {
      number: function number(x) {
        return Math.atan(x);
      },
      Complex: function Complex(x) {
        return x.atan();
      },
      BigNumber: function BigNumber(x) {
        return x.atan();
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since atan(0) = 0
        return deepMap(x, this);
      }
    });
  });

  var name$9 = 'cos';
  var dependencies$9 = ['typed'];
  var createCos = /* #__PURE__ */factory(name$9, dependencies$9, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Calculate the cosine of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.cos(x)
     *
     * Examples:
     *
     *    math.cos(2)                      // returns number -0.4161468365471422
     *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
     *    math.cos(math.unit(180, 'deg'))  // returns number -1
     *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
     *
     *    const angle = 0.2
     *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
     *
     * See also:
     *
     *    cos, tan
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
     */
    return typed(name$9, {
      number: Math.cos,
      Complex: function Complex(x) {
        return x.cos();
      },
      BigNumber: function BigNumber(x) {
        return x.cos();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function cos is no angle');
        }
        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  var name$8 = 'sin';
  var dependencies$8 = ['typed'];
  var createSin = /* #__PURE__ */factory(name$8, dependencies$8, _ref => {
    var {
      typed
    } = _ref;

    /**
     * Calculate the sine of a value.
     *
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.sin(x)
     *
     * Examples:
     *
     *    math.sin(2)                      // returns number 0.9092974268256813
     *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
     *    math.sin(math.unit(90, 'deg'))   // returns number 1
     *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
     *
     *    const angle = 0.2
     *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
     *
     * See also:
     *
     *    cos, tan
     *
     * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
     * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
     */
    return typed(name$8, {
      number: Math.sin,
      Complex: function Complex(x) {
        return x.sin();
      },
      BigNumber: function BigNumber(x) {
        return x.sin();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError('Unit in function sin is no angle');
        }
        return this(x.value);
      },
      'Array | Matrix': function ArrayMatrix(x) {
        // deep map collection, skip zeros since sin(0) = 0
        return deepMap(x, this);
      }
    });
  });

  var name$7 = 'add';
  var dependencies$7 = ['typed', 'matrix', 'addScalar', 'equalScalar', 'DenseMatrix', 'SparseMatrix'];
  var createAdd = /* #__PURE__ */factory(name$7, dependencies$7, _ref => {
    var {
      typed,
      matrix,
      addScalar,
      equalScalar,
      DenseMatrix,
      SparseMatrix
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed
    });
    var algorithm04 = createAlgorithm04({
      typed,
      equalScalar
    });
    var algorithm10 = createAlgorithm10({
      typed,
      DenseMatrix
    });
    var algorithm13 = createAlgorithm13({
      typed
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Add two or more values, `x + y`.
     * For matrices, the function is evaluated element wise.
     *
     * Syntax:
     *
     *    math.add(x, y)
     *    math.add(x, y, z, ...)
     *
     * Examples:
     *
     *    math.add(2, 3)               // returns number 5
     *    math.add(2, 3, 4)            // returns number 9
     *
     *    const a = math.complex(2, 3)
     *    const b = math.complex(-4, 1)
     *    math.add(a, b)               // returns Complex -2 + 4i
     *
     *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
     *
     *    const c = math.unit('5 cm')
     *    const d = math.unit('2.1 mm')
     *    math.add(c, d)               // returns Unit 52.1 mm
     *
     *    math.add("2.3", "4")         // returns number 6.3
     *
     * See also:
     *
     *    subtract, sum
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
     */

    return typed(name$7, extend({
      // we extend the signatures of addScalar with signatures dealing with matrices
      'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, addScalar);
      },
      'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, addScalar, false);
      },
      'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, addScalar, true);
      },
      'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, addScalar);
      },
      'Array, Array': function ArrayArray(x, y) {
        // use matrix implementation
        return this(matrix(x), matrix(y)).valueOf();
      },
      'Array, Matrix': function ArrayMatrix(x, y) {
        // use matrix implementation
        return this(matrix(x), y);
      },
      'Matrix, Array': function MatrixArray(x, y) {
        // use matrix implementation
        return this(x, matrix(y));
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, addScalar, false);
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm10(x, y, addScalar, false);
      },
      'any, DenseMatrix': function anyDenseMatrix(x, y) {
        return algorithm14(y, x, addScalar, true);
      },
      'any, SparseMatrix': function anySparseMatrix(x, y) {
        return algorithm10(y, x, addScalar, true);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, addScalar, false).valueOf();
      },
      'any, Array': function anyArray(x, y) {
        // use matrix implementation
        return algorithm14(matrix(y), x, addScalar, true).valueOf();
      },
      'any, any': addScalar,
      'any, any, ...any': function anyAnyAny(x, y, rest) {
        var result = this(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }
        return result;
      }
    }, addScalar.signatures));
  });

  var name$6 = 'norm';
  var dependencies$6 = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];
  var createNorm = /* #__PURE__ */factory(name$6, dependencies$6, _ref => {
    var {
      typed,
      abs,
      add,
      pow,
      conj,
      sqrt,
      multiply,
      equalScalar,
      larger,
      smaller,
      matrix,
      ctranspose,
      eigs
    } = _ref;

    /**
     * Calculate the norm of a number, vector or matrix.
     *
     * The second parameter p is optional. If not provided, it defaults to 2.
     *
     * Syntax:
     *
     *    math.norm(x)
     *    math.norm(x, p)
     *
     * Examples:
     *
     *    math.abs(-3.5)                         // returns 3.5
     *    math.norm(-3.5)                        // returns 3.5
     *
     *    math.norm(math.complex(3, -4))         // returns 5
     *
     *    math.norm([1, 2, -3], Infinity)        // returns 3
     *    math.norm([1, 2, -3], -Infinity)       // returns 1
     *
     *    math.norm([3, 4], 2)                   // returns 5
     *
     *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
     *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
     *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
     *
     * See also:
     *
     *    abs, hypot
     *
     * @param  {number | BigNumber | Complex | Array | Matrix} x
     *            Value for which to calculate the norm
     * @param  {number | BigNumber | string} [p=2]
     *            Vector space.
     *            Supported numbers include Infinity and -Infinity.
     *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
     * @return {number | BigNumber} the p-norm
     */
    return typed(name$6, {
      number: Math.abs,
      Complex: function Complex(x) {
        return x.abs();
      },
      BigNumber: function BigNumber(x) {
        // norm(x) = abs(x)
        return x.abs();
      },
      boolean: function boolean(x) {
        // norm(x) = abs(x)
        return Math.abs(x);
      },
      Array: function Array(x) {
        return _norm(matrix(x), 2);
      },
      Matrix: function Matrix(x) {
        return _norm(x, 2);
      },
      'number | Complex | BigNumber | boolean, number | BigNumber | string': function numberComplexBigNumberBooleanNumberBigNumberString(x) {
        // ignore second parameter, TODO: remove the option of second parameter for these types
        return this(x);
      },
      'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {
        return _norm(matrix(x), p);
      },
      'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {
        return _norm(x, p);
      }
    });
    /**
     * Calculate the plus infinity norm for a vector
     * @param {Matrix} x
     * @returns {number} Returns the norm
     * @private
     */

    function _vectorNormPlusInfinity(x) {
      // norm(x, Infinity) = max(abs(x))
      var pinf = 0; // skip zeros since abs(0) === 0

      x.forEach(function (value) {
        var v = abs(value);
        if (larger(v, pinf)) {
          pinf = v;
        }
      }, true);
      return pinf;
    }
    /**
     * Calculate the minus infinity norm for a vector
     * @param {Matrix} x
     * @returns {number} Returns the norm
     * @private
     */

    function _vectorNormMinusInfinity(x) {
      // norm(x, -Infinity) = min(abs(x))
      var ninf; // skip zeros since abs(0) === 0

      x.forEach(function (value) {
        var v = abs(value);
        if (!ninf || smaller(v, ninf)) {
          ninf = v;
        }
      }, true);
      return ninf || 0;
    }
    /**
     * Calculate the norm for a vector
     * @param {Matrix} x
     * @param {number | string} p
     * @returns {number} Returns the norm
     * @private
     */

    function _vectorNorm(x, p) {
      // check p
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        return _vectorNormPlusInfinity(x);
      }
      if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
        return _vectorNormMinusInfinity(x);
      }
      if (p === 'fro') {
        return _norm(x, 2);
      }
      if (typeof p === 'number' && !isNaN(p)) {
        // check p != 0
        if (!equalScalar(p, 0)) {
          // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
          var n = 0; // skip zeros since abs(0) === 0

          x.forEach(function (value) {
            n = add(pow(abs(value), p), n);
          }, true);
          return pow(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      } // invalid parameter value

      throw new Error('Unsupported parameter value');
    }
    /**
     * Calculate the Frobenius norm for a matrix
     * @param {Matrix} x
     * @returns {number} Returns the norm
     * @private
     */

    function _matrixNormFrobenius(x) {
      // norm(x) = sqrt(sum(diag(x'x)))
      var fro = 0;
      x.forEach(function (value, index) {
        fro = add(fro, multiply(value, conj(value)));
      });
      return abs(sqrt(fro));
    }
    /**
     * Calculate the norm L1 for a matrix
     * @param {Matrix} x
     * @returns {number} Returns the norm
     * @private
     */

    function _matrixNormOne(x) {
      // norm(x) = the largest column sum
      var c = []; // result

      var maxc = 0; // skip zeros since abs(0) == 0

      x.forEach(function (value, index) {
        var j = index[1];
        var cj = add(c[j] || 0, abs(value));
        if (larger(cj, maxc)) {
          maxc = cj;
        }
        c[j] = cj;
      }, true);
      return maxc;
    }
    /**
     * Calculate the norm L2 for a matrix
     * @param {Matrix} x
     * @returns {number} Returns the norm
     * @private
     */

    function _matrixNormTwo(x) {
      // norm(x) = sqrt( max eigenvalue of A*.A)
      var sizeX = x.size();
      if (sizeX[0] !== sizeX[1]) {
        throw new RangeError('Invalid matrix dimensions');
      }
      var tx = ctranspose(x);
      var squaredX = multiply(tx, x);
      var eigenVals = eigs(squaredX).values.toArray();
      var rho = eigenVals[eigenVals.length - 1];
      return abs(sqrt(rho));
    }
    /**
     * Calculate the infinity norm for a matrix
     * @param {Matrix} x
     * @returns {number} Returns the norm
     * @private
     */

    function _matrixNormInfinity(x) {
      // norm(x) = the largest row sum
      var r = []; // result

      var maxr = 0; // skip zeros since abs(0) == 0

      x.forEach(function (value, index) {
        var i = index[0];
        var ri = add(r[i] || 0, abs(value));
        if (larger(ri, maxr)) {
          maxr = ri;
        }
        r[i] = ri;
      }, true);
      return maxr;
    }
    /**
     * Calculate the norm for a 2D Matrix (M*N)
     * @param {Matrix} x
     * @param {number | string} p
     * @returns {number} Returns the norm
     * @private
     */

    function _matrixNorm(x, p) {
      // check p
      if (p === 1) {
        return _matrixNormOne(x);
      }
      if (p === Number.POSITIVE_INFINITY || p === 'inf') {
        return _matrixNormInfinity(x);
      }
      if (p === 'fro') {
        return _matrixNormFrobenius(x);
      }
      if (p === 2) {
        return _matrixNormTwo(x);
      } // invalid parameter value

      throw new Error('Unsupported parameter value ' + p);
    }
    /**
     * Calculate the norm for an array
     * @param {Matrix} x
     * @param {number | string} p
     * @returns {number} Returns the norm
     * @private
     */

    function _norm(x, p) {
      // size
      var sizeX = x.size(); // check if it is a vector

      if (sizeX.length === 1) {
        return _vectorNorm(x, p);
      } // MxN matrix

      if (sizeX.length === 2) {
        if (sizeX[0] && sizeX[1]) {
          return _matrixNorm(x, p);
        } else {
          throw new RangeError('Invalid matrix dimensions');
        }
      }
    }
  });

  var name$5 = 'dot';
  var dependencies$5 = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];
  var createDot = /* #__PURE__ */factory(name$5, dependencies$5, _ref => {
    var {
      typed,
      addScalar,
      multiplyScalar,
      conj,
      size
    } = _ref;

    /**
     * Calculate the dot product of two vectors. The dot product of
     * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
     *
     *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
     *
     * Syntax:
     *
     *    math.dot(x, y)
     *
     * Examples:
     *
     *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
     *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
     *
     * See also:
     *
     *    multiply, cross
     *
     * @param  {Array | Matrix} x     First vector
     * @param  {Array | Matrix} y     Second vector
     * @return {number}               Returns the dot product of `x` and `y`
     */
    return typed(name$5, {
      'Array | DenseMatrix, Array | DenseMatrix': _denseDot,
      'SparseMatrix, SparseMatrix': _sparseDot
    });
    function _validateDim(x, y) {
      var xSize = _size(x);
      var ySize = _size(y);
      var xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');
      }
      if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');
      if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');
      return xLen;
    }
    function _denseDot(a, b) {
      var N = _validateDim(a, b);
      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype : undefined;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype : undefined; // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)

      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add = addScalar;
      var mul = multiplyScalar; // process data types

      if (adt && bdt && adt === bdt && typeof adt === 'string') {
        var dt = adt; // find signatures that matches (dt, dt)

        add = typed.find(addScalar, [dt, dt]);
        mul = typed.find(multiplyScalar, [dt, dt]);
      } // both vectors 1-dimensional

      if (!aIsColumn && !bIsColumn) {
        var c = mul(conj(adata[0]), bdata[0]);
        for (var i = 1; i < N; i++) {
          c = add(c, mul(conj(adata[i]), bdata[i]));
        }
        return c;
      } // a is 1-dim, b is column

      if (!aIsColumn && bIsColumn) {
        var _c = mul(conj(adata[0]), bdata[0][0]);
        for (var _i = 1; _i < N; _i++) {
          _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
        }
        return _c;
      } // a is column, b is 1-dim

      if (aIsColumn && !bIsColumn) {
        var _c2 = mul(conj(adata[0][0]), bdata[0]);
        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
        }
        return _c2;
      } // both vectors are column

      if (aIsColumn && bIsColumn) {
        var _c3 = mul(conj(adata[0][0]), bdata[0][0]);
        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
        }
        return _c3;
      }
    }
    function _sparseDot(x, y) {
      _validateDim(x, y);
      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y._index;
      var yvalues = y._values; // TODO optimize add & mul using datatype

      var c = 0;
      var add = addScalar;
      var mul = multiplyScalar;
      var i = 0;
      var j = 0;
      while (i < xindex.length && j < yindex.length) {
        var I = xindex[i];
        var J = yindex[j];
        if (I < J) {
          i++;
          continue;
        }
        if (I > J) {
          j++;
          continue;
        }
        if (I === J) {
          c = add(c, mul(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }
      return c;
    } // TODO remove this once #1771 is fixed

    function _size(x) {
      return isMatrix(x) ? x.size() : size(x);
    }
  });

  var name$4 = 'qr';
  var dependencies$4 = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];
  var createQr = /* #__PURE__ */factory(name$4, dependencies$4, _ref => {
    var {
      typed,
      matrix,
      zeros,
      identity,
      isZero,
      equal,
      sign,
      sqrt,
      conj,
      unaryMinus,
      addScalar,
      divideScalar,
      multiplyScalar,
      subtract,
      complex
    } = _ref;

    /**
     * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
     * two matrices (`Q`, `R`) where `Q` is an
     * orthogonal matrix and `R` is an upper triangular matrix.
     *
     * Syntax:
     *
     *    math.qr(A)
     *
     * Example:
     *
     *    const m = [
     *      [1, -1,  4],
     *      [1,  4, -2],
     *      [1,  4,  2],
     *      [1,  -1, 0]
     *    ]
     *    const result = math.qr(m)
     *    // r = {
     *    //   Q: [
     *    //     [0.5, -0.5,   0.5],
     *    //     [0.5,  0.5,  -0.5],
     *    //     [0.5,  0.5,   0.5],
     *    //     [0.5, -0.5,  -0.5],
     *    //   ],
     *    //   R: [
     *    //     [2, 3,  2],
     *    //     [0, 5, -2],
     *    //     [0, 0,  4],
     *    //     [0, 0,  0]
     *    //   ]
     *    // }
     *
     * See also:
     *
     *    lup, lusolve
     *
     * @param {Matrix | Array} A    A two dimensional matrix or array
     * for which to get the QR decomposition.
     *
     * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
     * matrix and R: the upper triangular matrix
     */
    return _extends(typed(name$4, {
      DenseMatrix: function DenseMatrix(m) {
        return _denseQR(m);
      },
      SparseMatrix: function SparseMatrix(m) {
        return _sparseQR();
      },
      Array: function Array(a) {
        // create dense matrix from array
        var m = matrix(a); // lup, use matrix implementation

        var r = _denseQR(m); // result

        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    }), {
      _denseQRimpl
    });
    function _denseQRimpl(m) {
      // rows & columns (m x n)
      var rows = m._size[0]; // m

      var cols = m._size[1]; // n

      var Q = identity([rows], 'dense');
      var Qdata = Q._data;
      var R = m.clone();
      var Rdata = R._data; // vars

      var i, j, k;
      var w = zeros([rows], '');
      for (k = 0; k < Math.min(cols, rows); ++k) {
        /*
         * **k-th Household matrix**
         *
         * The matrix I - 2*v*transpose(v)
         * x     = first column of A
         * x1    = first element of x
         * alpha = x1 / |x1| * |x|
         * e1    = tranpose([1, 0, 0, ...])
         * u     = x - alpha * e1
         * v     = u / |u|
         *
         * Household matrix = I - 2 * v * tranpose(v)
         *
         *  * Initially Q = I and R = A.
         *  * Household matrix is a reflection in a plane normal to v which
         *    will zero out all but the top right element in R.
         *  * Appplying reflection to both Q and R will not change product.
         *  * Repeat this process on the (1,1) minor to get R as an upper
         *    triangular matrix.
         *  * Reflections leave the magnitude of the columns of Q unchanged
         *    so Q remains othoganal.
         *
         */
        var pivot = Rdata[k][k];
        var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
        var conjSgn = conj(sgn);
        var alphaSquared = 0;
        for (i = k; i < rows; i++) {
          alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
        }
        var alpha = multiplyScalar(sgn, sqrt(alphaSquared));
        if (!isZero(alpha)) {
          // first element in vector u
          var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)

          w[k] = 1;
          for (i = k + 1; i < rows; i++) {
            w[i] = divideScalar(Rdata[i][k], u1);
          } // tau = - conj(u1 / alpha)

          var tau = unaryMinus(conj(divideScalar(u1, alpha)));
          var s = void 0;
          /*
           * tau and w have been choosen so that
           *
           * 2 * v * tranpose(v) = tau * w * tranpose(w)
           */

          /*
           * -- calculate R = R - tau * w * tranpose(w) * R --
           * Only do calculation with rows k to (rows-1)
           * Additionally columns 0 to (k-1) will not be changed by this
           *   multiplication so do not bother recalculating them
           */

          for (j = k; j < cols; j++) {
            s = 0.0; // calculate jth element of [tranpose(w) * R]

            for (i = k; i < rows; i++) {
              s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
            } // calculate the jth element of [tau * transpose(w) * R]

            s = multiplyScalar(s, tau);
            for (i = k; i < rows; i++) {
              Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
            }
          }
          /*
           * -- calculate Q = Q - tau * Q * w * transpose(w) --
           * Q is a square matrix (rows x rows)
           * Only do calculation with columns k to (rows-1)
           * Additionally rows 0 to (k-1) will not be changed by this
           *   multiplication so do not bother recalculating them
           */

          for (i = 0; i < rows; i++) {
            s = 0.0; // calculate ith element of [Q * w]

            for (j = k; j < rows; j++) {
              s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
            } // calculate the ith element of [tau * Q * w]

            s = multiplyScalar(s, tau);
            for (j = k; j < rows; ++j) {
              Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
            }
          }
        }
      } // return matrices

      return {
        Q,
        R,
        toString: function toString() {
          return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
        }
      };
    }
    function _denseQR(m) {
      var ret = _denseQRimpl(m);
      var Rdata = ret.R._data;
      if (m._data.length > 0) {
        var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;
        for (var i = 0; i < Rdata.length; ++i) {
          for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
            Rdata[i][j] = zero;
          }
        }
      }
      return ret;
    }
    function _sparseQR(m) {
      throw new Error('qr not implemented for sparse matrices yet');
    }
  });

  var name$3 = 'det';
  var dependencies$3 = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];
  var createDet = /* #__PURE__ */factory(name$3, dependencies$3, _ref => {
    var {
      typed,
      matrix,
      subtract,
      multiply,
      divideScalar,
      isZero,
      unaryMinus
    } = _ref;

    /**
     * Calculate the determinant of a matrix.
     *
     * Syntax:
     *
     *    math.det(x)
     *
     * Examples:
     *
     *    math.det([[1, 2], [3, 4]]) // returns -2
     *
     *    const A = [
     *      [-2, 2, 3],
     *      [-1, 1, 3],
     *      [2, 0, -1]
     *    ]
     *    math.det(A) // returns 6
     *
     * See also:
     *
     *    inv
     *
     * @param {Array | Matrix} x  A matrix
     * @return {number} The determinant of `x`
     */
    return typed(name$3, {
      any: function any(x) {
        return clone$1(x);
      },
      'Array | Matrix': function det(x) {
        var size;
        if (isMatrix(x)) {
          size = x.size();
        } else if (Array.isArray(x)) {
          x = matrix(x);
          size = x.size();
        } else {
          // a scalar
          size = [];
        }
        switch (size.length) {
          case 0:
            // scalar
            return clone$1(x);
          case 1:
            // vector
            if (size[0] === 1) {
              return clone$1(x.valueOf()[0]);
            } else {
              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
            }
          case 2:
            {
              // two dimensional array
              var rows = size[0];
              var cols = size[1];
              if (rows === cols) {
                return _det(x.clone().valueOf(), rows);
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
              }
            }
          default:
            // multi dimensional array
            throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');
        }
      }
    });
    /**
     * Calculate the determinant of a matrix
     * @param {Array[]} matrix  A square, two dimensional matrix
     * @param {number} rows     Number of rows of the matrix (zero-based)
     * @param {number} cols     Number of columns of the matrix (zero-based)
     * @returns {number} det
     * @private
     */

    function _det(matrix, rows, cols) {
      if (rows === 1) {
        // this is a 1 x 1 matrix
        return clone$1(matrix[0][0]);
      } else if (rows === 2) {
        // this is a 2 x 2 matrix
        // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
        return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));
      } else {
        // Bareiss algorithm
        // this algorithm have same complexity as LUP decomposition (O(n^3))
        // but it preserve precision of floating point more relative to the LUP decomposition
        var negated = false;
        var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i

        for (var k = 0; k < rows; k++) {
          var k_ = rowIndices[k];
          if (isZero(matrix[k_][k])) {
            var _k = void 0;
            for (_k = k + 1; _k < rows; _k++) {
              if (!isZero(matrix[rowIndices[_k]][k])) {
                k_ = rowIndices[_k];
                rowIndices[_k] = rowIndices[k];
                rowIndices[k] = k_;
                negated = !negated;
                break;
              }
            }
            if (_k === rows) return matrix[k_][k]; // some zero of the type
          }

          var piv = matrix[k_][k];
          var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];
          for (var i = k + 1; i < rows; i++) {
            var i_ = rowIndices[i];
            for (var j = k + 1; j < rows; j++) {
              matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);
            }
          }
        }
        var det = matrix[rowIndices[rows - 1]][rows - 1];
        return negated ? unaryMinus(det) : det;
      }
    }
  });

  var name$2 = 'inv';
  var dependencies$2 = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];
  var createInv = /* #__PURE__ */factory(name$2, dependencies$2, _ref => {
    var {
      typed,
      matrix,
      divideScalar,
      addScalar,
      multiply,
      unaryMinus,
      det,
      identity,
      abs
    } = _ref;

    /**
     * Calculate the inverse of a square matrix.
     *
     * Syntax:
     *
     *     math.inv(x)
     *
     * Examples:
     *
     *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
     *     math.inv(4)                 // returns 0.25
     *     1 / 4                       // returns 0.25
     *
     * See also:
     *
     *     det, transpose
     *
     * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
     * @return {number | Complex | Array | Matrix} The inverse of `x`.
     */
    return typed(name$2, {
      'Array | Matrix': function ArrayMatrix(x) {
        var size = isMatrix(x) ? x.size() : arraySize(x);
        switch (size.length) {
          case 1:
            // vector
            if (size[0] === 1) {
              if (isMatrix(x)) {
                return matrix([divideScalar(1, x.valueOf()[0])]);
              } else {
                return [divideScalar(1, x[0])];
              }
            } else {
              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
            }
          case 2:
            // two dimensional array
            {
              var rows = size[0];
              var cols = size[1];
              if (rows === cols) {
                if (isMatrix(x)) {
                  return matrix(_inv(x.valueOf(), rows, cols), x.storage());
                } else {
                  // return an Array
                  return _inv(x, rows, cols);
                }
              } else {
                throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
              }
            }
          default:
            // multi dimensional array
            throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');
        }
      },
      any: function any(x) {
        // scalar
        return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
      }
    });
    /**
     * Calculate the inverse of a square matrix
     * @param {Array[]} mat     A square matrix
     * @param {number} rows     Number of rows
     * @param {number} cols     Number of columns, must equal rows
     * @return {Array[]} inv    Inverse matrix
     * @private
     */

    function _inv(mat, rows, cols) {
      var r, s, f, value, temp;
      if (rows === 1) {
        // this is a 1 x 1 matrix
        value = mat[0][0];
        if (value === 0) {
          throw Error('Cannot calculate inverse, determinant is zero');
        }
        return [[divideScalar(1, value)]];
      } else if (rows === 2) {
        // this is a 2 x 2 matrix
        var d = det(mat);
        if (d === 0) {
          throw Error('Cannot calculate inverse, determinant is zero');
        }
        return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
      } else {
        // this is a matrix of 3 x 3 or larger
        // calculate inverse using gauss-jordan elimination
        //      https://en.wikipedia.org/wiki/Gaussian_elimination
        //      http://mathworld.wolfram.com/MatrixInverse.html
        //      http://math.uww.edu/~mcfarlat/inverse.htm
        // make a copy of the matrix (only the arrays, not of the elements)
        var A = mat.concat();
        for (r = 0; r < rows; r++) {
          A[r] = A[r].concat();
        } // create an identity matrix which in the end will contain the
        // matrix inverse

        var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions

        for (var c = 0; c < cols; c++) {
          // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
          var ABig = abs(A[c][c]);
          var rBig = c;
          r = c + 1;
          while (r < rows) {
            if (abs(A[r][c]) > ABig) {
              ABig = abs(A[r][c]);
              rBig = r;
            }
            r++;
          }
          if (ABig === 0) {
            throw Error('Cannot calculate inverse, determinant is zero');
          }
          r = rBig;
          if (r !== c) {
            temp = A[c];
            A[c] = A[r];
            A[r] = temp;
            temp = B[c];
            B[c] = B[r];
            B[r] = temp;
          } // eliminate non-zero values on the other rows at column c

          var Ac = A[c];
          var Bc = B[c];
          for (r = 0; r < rows; r++) {
            var Ar = A[r];
            var Br = B[r];
            if (r !== c) {
              // eliminate value at column c and row r
              if (Ar[c] !== 0) {
                f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value
                // at column c

                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
                }
              }
            } else {
              // normalize value at Acc to 1,
              // divide each value on row r with the value at Acc
              f = Ac[c];
              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar(Ar[s], f);
              }
              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar(Br[s], f);
              }
            }
          }
        }
        return B;
      }
    }
  });

  function createComplexEigs(_ref) {
    var {
      addScalar,
      subtract,
      flatten,
      multiply,
      multiplyScalar,
      divideScalar,
      sqrt,
      abs,
      bignumber,
      diag,
      inv,
      qr,
      usolve,
      usolveAll,
      equal,
      complex,
      larger,
      smaller,
      matrixFromColumns,
      dot
    } = _ref;

    /**
     * @param {number[][]} arr the matrix to find eigenvalues of
     * @param {number} N size of the matrix
     * @param {number|BigNumber} prec precision, anything lower will be considered zero
     * @param {'number'|'BigNumber'|'Complex'} type
     * @param {boolean} findVectors should we find eigenvectors?
     *
     * @returns {{ values: number[], vectors: number[][] }}
     */
    function complexEigs(arr, N, prec, type, findVectors) {
      if (findVectors === undefined) {
        findVectors = true;
      } // TODO check if any row/col are zero except the diagonal
      // make sure corresponding rows and columns have similar magnitude
      // important because of numerical stability
      // MODIFIES arr by side effect!

      var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix
      // arr = A' = R A R, A is the original matrix
      // (if findVectors is false, R is undefined)
      // (And so to return to original matrix: A = R arr R)
      // TODO if magnitudes of elements vary over many orders,
      // move greatest elements to the top left corner
      // using similarity transformations, reduce the matrix
      // to Hessenberg form (upper triangular plus one subdiagonal row)
      // updates the transformation matrix R with new row operationsq
      // MODIFIES arr by side effect!

      reduceToHessenberg(arr, N, prec, type, findVectors, R); // still true that original A = R arr R)
      // find eigenvalues

      var {
        values,
        C
      } = iterateUntilTriangular(arr, N, prec, type, findVectors); // values is the list of eigenvalues, C is the column
      // transformation matrix that transforms arr, the hessenberg
      // matrix, to upper triangular
      // (So U = C arr C and the relationship between current arr
      // and original A is unchanged.)

      var vectors;
      if (findVectors) {
        vectors = findEigenvectors(arr, N, C, R, values, prec, type);
        vectors = matrixFromColumns(...vectors);
      }
      return {
        values,
        vectors
      };
    }
    /**
     * @param {number[][]} arr
     * @param {number} N
     * @param {number} prec
     * @param {'number'|'BigNumber'|'Complex'} type
     * @returns {number[][]}
     */

    function balance(arr, N, prec, type, findVectors) {
      var big = type === 'BigNumber';
      var cplx = type === 'Complex';
      var realzero = big ? bignumber(0) : 0;
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      var realone = big ? bignumber(1) : 1; // base of the floating-point arithmetic

      var radix = big ? bignumber(10) : 2;
      var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R

      var Rdiag;
      if (findVectors) {
        Rdiag = Array(N).fill(one);
      } // this isn't the only time we loop thru the matrix...

      var last = false;
      while (!last) {
        // ...haha I'm joking! unless...
        last = true;
        for (var i = 0; i < N; i++) {
          // compute the taxicab norm of i-th column and row
          // TODO optimize for complex numbers
          var colNorm = realzero;
          var rowNorm = realzero;
          for (var j = 0; j < N; j++) {
            if (i === j) continue;
            var c = abs(arr[i][j]); // should be real

            colNorm = addScalar(colNorm, c);
            rowNorm = addScalar(rowNorm, c);
          }
          if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
            // find integer power closest to balancing the matrix
            // (we want to scale only by integer powers of radix,
            // so that we don't lose any precision due to round-off)
            var f = realone;
            var _c = colNorm;
            var rowDivRadix = divideScalar(rowNorm, radix);
            var rowMulRadix = multiplyScalar(rowNorm, radix);
            while (smaller(_c, rowDivRadix)) {
              _c = multiplyScalar(_c, radixSq);
              f = multiplyScalar(f, radix);
            }
            while (larger(_c, rowMulRadix)) {
              _c = divideScalar(_c, radixSq);
              f = divideScalar(f, radix);
            } // check whether balancing is needed
            // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)

            var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation

            if (condition) {
              // we should loop once again to check whether
              // another rebalancing is needed
              last = false;
              var g = divideScalar(1, f);
              for (var _j = 0; _j < N; _j++) {
                if (i === _j) {
                  continue;
                }
                arr[i][_j] = multiplyScalar(arr[i][_j], f);
                arr[_j][i] = multiplyScalar(arr[_j][i], g);
              } // keep track of transformations

              if (findVectors) {
                Rdiag[i] = multiplyScalar(Rdiag[i], f);
              }
            }
          }
        }
      } // return the diagonal row transformation matrix

      return diag(Rdiag);
    }
    /**
     * @param {number[][]} arr
     * @param {number} N
     * @param {number} prec
     * @param {'number'|'BigNumber'|'Complex'} type
     * @param {boolean} findVectors
     * @param {number[][]} R the row transformation matrix that will be modified
     */

    function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
      var big = type === 'BigNumber';
      var cplx = type === 'Complex';
      var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
      if (big) {
        prec = bignumber(prec);
      }
      for (var i = 0; i < N - 2; i++) {
        // Find the largest subdiag element in the i-th col
        var maxIndex = 0;
        var max = zero;
        for (var j = i + 1; j < N; j++) {
          var el = arr[j][i];
          if (smaller(abs(max), abs(el))) {
            max = el;
            maxIndex = j;
          }
        } // This col is pivoted, no need to do anything

        if (smaller(abs(max), prec)) {
          continue;
        }
        if (maxIndex !== i + 1) {
          // Interchange maxIndex-th and (i+1)-th row
          var tmp1 = arr[maxIndex];
          arr[maxIndex] = arr[i + 1];
          arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column

          for (var _j2 = 0; _j2 < N; _j2++) {
            var tmp2 = arr[_j2][maxIndex];
            arr[_j2][maxIndex] = arr[_j2][i + 1];
            arr[_j2][i + 1] = tmp2;
          } // keep track of transformations

          if (findVectors) {
            var tmp3 = R[maxIndex];
            R[maxIndex] = R[i + 1];
            R[i + 1] = tmp3;
          }
        } // Reduce following rows and columns

        for (var _j3 = i + 2; _j3 < N; _j3++) {
          var n = divideScalar(arr[_j3][i], max);
          if (n === 0) {
            continue;
          } // from j-th row subtract n-times (i+1)th row

          for (var k = 0; k < N; k++) {
            arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
          } // to (i+1)th column add n-times j-th column

          for (var _k = 0; _k < N; _k++) {
            arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
          } // keep track of transformations

          if (findVectors) {
            for (var _k2 = 0; _k2 < N; _k2++) {
              R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
            }
          }
        }
      }
      return R;
    }
    /**
     * @returns {{values: values, C: Matrix}}
     * @see Press, Wiliams: Numerical recipes in Fortran 77
     * @see https://en.wikipedia.org/wiki/QR_algorithm
     */

    function iterateUntilTriangular(A, N, prec, type, findVectors) {
      var big = type === 'BigNumber';
      var cplx = type === 'Complex';
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      if (big) {
        prec = bignumber(prec);
      } // The Francis Algorithm
      // The core idea of this algorithm is that doing successive
      // A' = QAQ transformations will eventually converge to block-
      // upper-triangular with diagonal blocks either 1x1 or 2x2.
      // The Q here is the one from the QR decomposition, A = QR.
      // Since the eigenvalues of a block-upper-triangular matrix are
      // the eigenvalues of its diagonal blocks and we know how to find
      // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.

      var arr = clone$1(A); // the list of converged eigenvalues

      var lambdas = []; // size of arr, which will get smaller as eigenvalues converge

      var n = N; // the diagonal of the block-diagonal matrix that turns
      // converged 2x2 matrices into upper triangular matrices

      var Sdiag = []; // NN matrix describing the overall transformation done during the QR algorithm

      var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // nn matrix describing the QR transformations done since last convergence

      var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps

      var lastConvergenceBefore = 0;
      while (lastConvergenceBefore <= 100) {
        lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever
        // Perform the factorization

        var k = 0; // TODO set close to an eigenvalue

        for (var i = 0; i < n; i++) {
          arr[i][i] = subtract(arr[i][i], k);
        } // TODO do an implicit QR transformation

        var {
          Q,
          R
        } = qr(arr);
        arr = multiply(R, Q);
        for (var _i = 0; _i < n; _i++) {
          arr[_i][_i] = addScalar(arr[_i][_i], k);
        } // keep track of transformations

        if (findVectors) {
          Qpartial = multiply(Qpartial, Q);
        } // The rightmost diagonal element converged to an eigenvalue

        if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {
          lastConvergenceBefore = 0;
          lambdas.push(arr[n - 1][n - 1]); // keep track of transformations

          if (findVectors) {
            Sdiag.unshift([[1]]);
            inflateMatrix(Qpartial, N);
            Qtotal = multiply(Qtotal, Qpartial);
            if (n > 1) {
              Qpartial = diag(Array(n - 1).fill(one));
            }
          } // reduce the matrix size

          n -= 1;
          arr.pop();
          for (var _i2 = 0; _i2 < n; _i2++) {
            arr[_i2].pop();
          } // The rightmost diagonal 2x2 block converged
        } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {
          lastConvergenceBefore = 0;
          var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
          lambdas.push(...ll); // keep track of transformations

          if (findVectors) {
            Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
            inflateMatrix(Qpartial, N);
            Qtotal = multiply(Qtotal, Qpartial);
            if (n > 2) {
              Qpartial = diag(Array(n - 2).fill(one));
            }
          } // reduce the matrix size

          n -= 2;
          arr.pop();
          arr.pop();
          for (var _i3 = 0; _i3 < n; _i3++) {
            arr[_i3].pop();
            arr[_i3].pop();
          }
        }
        if (n === 0) {
          break;
        }
      } // standard sorting

      lambdas.sort((a, b) => +subtract(abs(a), abs(b))); // the algorithm didn't converge

      if (lastConvergenceBefore > 100) {
        var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));
        err.values = lambdas;
        err.vectors = [];
        throw err;
      } // combine the overall QR transformation Qtotal with the subsequent
      // transformation S that turns the diagonal 2x2 blocks to upper triangular

      var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;
      return {
        values: lambdas,
        C
      };
    }
    /**
     * @param {Matrix} A hessenberg-form matrix
     * @param {number} N size of A
     * @param {Matrix} C column transformation matrix that turns A into upper triangular
     * @param {Matrix} R similarity that turns original matrix into A
     * @param {number[]} values array of eigenvalues of A
     * @param {'number'|'BigNumber'|'Complex'} type
     * @returns {number[][]} eigenvalues
     */

    function findEigenvectors(A, N, C, R, values, prec, type) {
      var Cinv = inv(C);
      var U = multiply(Cinv, A, C);
      var big = type === 'BigNumber';
      var cplx = type === 'Complex';
      var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
      var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of "multiset"
      // this way it is easier to find eigenvectors

      var uniqueValues = [];
      var multiplicities = [];
      for (var  of values) {
        var i = indexOf(uniqueValues, , equal);
        if (i === -1) {
          uniqueValues.push();
          multiplicities.push(1);
        } else {
          multiplicities[i] += 1;
        }
      } // find eigenvectors by solving U  E = 0
      // TODO replace with an iterative eigenvector algorithm
      // (this one might fail for imprecise eigenvalues)

      var vectors = [];
      var len = uniqueValues.length;
      var b = Array(N).fill(zero);
      var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)

      var failedLambdas = [];
      var _loop = function _loop(_i4) {
        var  = uniqueValues[_i4];
        var S = subtract(U, multiply(, E)); // the characteristic matrix

        var solutions = usolveAll(S, b);
        solutions.shift(); // ignore the null vector
        // looks like we missed something, try inverse iteration

        while (solutions.length < multiplicities[_i4]) {
          var approxVec = inverseIterate(S, N, solutions, prec, type);
          if (approxVec == null) {
            // no more vectors were found
            failedLambdas.push();
            break;
          }
          solutions.push(approxVec);
        } // Transform back into original array coordinates

        var correction = multiply(inv(R), C);
        solutions = solutions.map(v => multiply(correction, v));
        vectors.push(...solutions.map(v => flatten(v)));
      };
      for (var _i4 = 0; _i4 < len; _i4++) {
        _loop(_i4);
      }
      if (failedLambdas.length !== 0) {
        var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));
        err.values = values;
        err.vectors = vectors;
        throw err;
      }
      return vectors;
    }
    /**
     * Compute the eigenvalues of an 2x2 matrix
     * @return {[number,number]}
     */

    function eigenvalues2x2(a, b, c, d) {
      //  =  trA   ( trA - 4 detA )
      var trA = addScalar(a, d);
      var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
      var x = multiplyScalar(trA, 0.5);
      var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
      return [addScalar(x, y), subtract(x, y)];
    }
    /**
     * For an 2x2 matrix compute the transformation matrix S,
     * so that SAS is an upper triangular matrix
     * @return {[[number,number],[number,number]]}
     * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf
     * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
     */

    function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
      var big = type === 'BigNumber';
      var cplx = type === 'Complex';
      var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
      var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular
      // return an identity matrix

      if (smaller(abs(c), prec)) {
        return [[one, zero], [zero, one]];
      } // matrix is diagonalizable
      // return its eigenvectors as columns

      if (larger(abs(subtract(l1, l2)), prec)) {
        return [[subtract(l1, d), subtract(l2, d)], [c, c]];
      } // matrix is not diagonalizable
      // compute off-diagonal elements of N = A - I
      // N = 0  S = ( N, I )
      // N  0  S = ( N, I )

      var na = subtract(a, l1);
      var nb = subtract(b, l1);
      var nc = subtract(c, l1);
      var nd = subtract(d, l1);
      if (smaller(abs(nb), prec)) {
        return [[na, one], [nc, zero]];
      } else {
        return [[nb, zero], [nd, one]];
      }
    }
    /**
     * Enlarge the matrix from nn to NN, setting the new
     * elements to 1 on diagonal and 0 elsewhere
     */

    function inflateMatrix(arr, N) {
      // add columns
      for (var i = 0; i < arr.length; i++) {
        arr[i].push(...Array(N - arr[i].length).fill(0));
      } // add rows

      for (var _i5 = arr.length; _i5 < N; _i5++) {
        arr.push(Array(N).fill(0));
        arr[_i5][_i5] = 1;
      }
      return arr;
    }
    /**
     * Create a block-diagonal matrix with the given square matrices on the diagonal
     * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal
     * @param {number} N the size of the resulting matrix
     */

    function blockDiag(arr, N) {
      var M = [];
      for (var i = 0; i < N; i++) {
        M[i] = Array(N).fill(0);
      }
      var I = 0;
      for (var sub of arr) {
        var n = sub.length;
        for (var _i6 = 0; _i6 < n; _i6++) {
          for (var j = 0; j < n; j++) {
            M[I + _i6][I + j] = sub[_i6][j];
          }
        }
        I += n;
      }
      return M;
    }
    /**
     * Finds the index of an element in an array using a custom equality function
     * @template T
     * @param {Array<T>} arr array in which to search
     * @param {T} el the element to find
     * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`
     * @returns {number} the index of `el`, or -1 when it's not in `arr`
     */

    function indexOf(arr, el, fn) {
      for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i], el)) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Provided a near-singular upper-triangular matrix A and a list of vectors,
     * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal
     * to each vector in the list
     * @template T
     * @param {T[][]} A near-singular square matrix
     * @param {number} N dimension
     * @param {T[][]} orthog list of vectors
     * @param {number} prec epsilon
     * @param {'number'|'BigNumber'|'Complex'} type
     * @return {T[] | null} eigenvector
     *
     * @see Numerical Recipes for Fortran 77  11.7 Eigenvalues or Eigenvectors by Inverse Iteration
     */

    function inverseIterate(A, N, orthog, prec, type) {
      var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;
      var b; // the vector
      // you better choose a random vector before I count to five

      var i = 0;
      while (true) {
        b = randomOrthogonalVector(N, orthog, type);
        b = usolve(A, b);
        if (larger(norm(b), largeNum)) {
          break;
        }
        if (++i >= 5) {
          return null;
        }
      } // you better converge before I count to ten

      i = 0;
      while (true) {
        var c = usolve(A, b);
        if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
          break;
        }
        if (++i >= 10) {
          return null;
        }
        b = normalize(c);
      }
      return b;
    }
    /**
     * Generates a random unit vector of dimension N, orthogonal to each vector in the list
     * @template T
     * @param {number} N dimension
     * @param {T[][]} orthog list of vectors
     * @param {'number'|'BigNumber'|'Complex'} type
     * @returns {T[]} random vector
     */

    function randomOrthogonalVector(N, orthog, type) {
      var big = type === 'BigNumber';
      var cplx = type === 'Complex'; // generate random vector with the correct type

      var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);
      if (big) {
        v = v.map(n => bignumber(n));
      }
      if (cplx) {
        v = v.map(n => complex(n));
      } // project to orthogonal complement

      v = orthogonalComplement(v, orthog); // normalize

      return normalize(v, type);
    }
    /**
     * Project vector v to the orthogonal complement of an array of vectors
     */

    function orthogonalComplement(v, orthog) {
      for (var w of orthog) {
        // v := v  (w, v)/w w
        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
      }
      return v;
    }
    /**
     * Calculate the norm of a vector.
     * We can't use math.norm because factory can't handle circular dependency.
     * Seriously, I'm really fed up with factory.
     */

    function norm(v) {
      return abs(sqrt(dot(v, v)));
    }
    /**
     * Normalize a vector
     * @template T
     * @param {T[]} v
     * @param {'number'|'BigNumber'|'Complex'} type
     * @returns {T[]} normalized vec
     */

    function normalize(v, type) {
      var big = type === 'BigNumber';
      var cplx = type === 'Complex';
      var one = big ? bignumber(1) : cplx ? complex(1) : 1;
      return multiply(divideScalar(one, norm(v)), v);
    }
    return complexEigs;
  }

  function createRealSymmetric(_ref) {
    var {
      config,
      addScalar,
      subtract,
      abs,
      atan,
      cos,
      sin,
      multiplyScalar,
      inv,
      bignumber,
      multiply,
      add
    } = _ref;

    /**
     * @param {number[] | BigNumber[]} arr
     * @param {number} N
     * @param {number} prec
     * @param {'number' | 'BigNumber'} type
     */
    function main(arr, N) {
      var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config.epsilon;
      var type = arguments.length > 3 ? arguments[3] : undefined;
      if (type === 'number') {
        return diag(arr, prec);
      }
      if (type === 'BigNumber') {
        return diagBig(arr, prec);
      }
      throw TypeError('Unsupported data type: ' + type);
    } // diagonalization implementation for number (efficient)

    function diag(x, precision) {
      var N = x.length;
      var e0 = Math.abs(precision / N);
      var psi;
      var Sij = new Array(N); // Sij is Identity Matrix

      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1.0;
      } // initial error

      var Vab = getAij(x);
      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j = Vab[0][1];
        psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
        x = x1(x, psi, _i, j);
        Sij = Sij1(Sij, psi, _i, j);
        Vab = getAij(x);
      }
      var Ei = createArray(N, 0); // eigenvalues

      for (var _i2 = 0; _i2 < N; _i2++) {
        Ei[_i2] = x[_i2][_i2];
      }
      return sorting(clone$1(Ei), clone$1(Sij));
    } // diagonalization implementation for bigNumber

    function diagBig(x, precision) {
      var N = x.length;
      var e0 = abs(precision / N);
      var psi;
      var Sij = new Array(N); // Sij is Identity Matrix

      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1.0;
      } // initial error

      var Vab = getAijBig(x);
      while (abs(Vab[1]) >= abs(e0)) {
        var _i3 = Vab[0][0];
        var j = Vab[0][1];
        psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
        x = x1Big(x, psi, _i3, j);
        Sij = Sij1Big(Sij, psi, _i3, j);
        Vab = getAijBig(x);
      }
      var Ei = createArray(N, 0); // eigenvalues

      for (var _i4 = 0; _i4 < N; _i4++) {
        Ei[_i4] = x[_i4][_i4];
      } // return [clone(Ei), clone(Sij)]

      return sorting(clone$1(Ei), clone$1(Sij));
    } // get angle

    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;
      if (Math.abs(denom) <= config.epsilon) {
        return Math.PI / 4.0;
      } else {
        return 0.5 * Math.atan(2.0 * aij / (ajj - aii));
      }
    } // get angle

    function getThetaBig(aii, ajj, aij) {
      var denom = subtract(ajj, aii);
      if (abs(denom) <= config.epsilon) {
        return bignumber(-1).acos().div(4);
      } else {
        return multiplyScalar(0.5, atan(multiply(2.0, aij, inv(denom))));
      }
    } // update eigvec

    function Sij1(Sij, theta, i, j) {
      var N = Sij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var Ski = createArray(N, 0);
      var Skj = createArray(N, 0);
      for (var k = 0; k < N; k++) {
        Ski[k] = c * Sij[k][i] - s * Sij[k][j];
        Skj[k] = s * Sij[k][i] + c * Sij[k][j];
      }
      for (var _k = 0; _k < N; _k++) {
        Sij[_k][i] = Ski[_k];
        Sij[_k][j] = Skj[_k];
      }
      return Sij;
    } // update eigvec for overlap

    function Sij1Big(Sij, theta, i, j) {
      var N = Sij.length;
      var c = cos(theta);
      var s = sin(theta);
      var Ski = createArray(N, bignumber(0));
      var Skj = createArray(N, bignumber(0));
      for (var k = 0; k < N; k++) {
        Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
        Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
      }
      for (var _k2 = 0; _k2 < N; _k2++) {
        Sij[_k2][i] = Ski[_k2];
        Sij[_k2][j] = Skj[_k2];
      }
      return Sij;
    } // update matrix

    function x1Big(Hij, theta, i, j) {
      var N = Hij.length;
      var c = bignumber(cos(theta));
      var s = bignumber(sin(theta));
      var c2 = multiplyScalar(c, c);
      var s2 = multiplyScalar(s, s);
      var Aki = createArray(N, bignumber(0));
      var Akj = createArray(N, bignumber(0)); // 2cs Hij

      var csHij = multiply(bignumber(2), c, s, Hij[i][j]); //  Aii

      var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
      var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j])); // 0  to i

      for (var k = 0; k < N; k++) {
        Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
        Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
      } // Modify Hij

      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = bignumber(0);
      Hij[j][i] = bignumber(0); // 0  to i

      for (var _k3 = 0; _k3 < N; _k3++) {
        if (_k3 !== i && _k3 !== j) {
          Hij[i][_k3] = Aki[_k3];
          Hij[_k3][i] = Aki[_k3];
          Hij[j][_k3] = Akj[_k3];
          Hij[_k3][j] = Akj[_k3];
        }
      }
      return Hij;
    } // update matrix

    function x1(Hij, theta, i, j) {
      var N = Hij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var c2 = c * c;
      var s2 = s * s;
      var Aki = createArray(N, 0);
      var Akj = createArray(N, 0); //  Aii

      var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
      var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j]; // 0  to i

      for (var k = 0; k < N; k++) {
        Aki[k] = c * Hij[i][k] - s * Hij[j][k];
        Akj[k] = s * Hij[i][k] + c * Hij[j][k];
      } // Modify Hij

      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = 0;
      Hij[j][i] = 0; // 0  to i

      for (var _k4 = 0; _k4 < N; _k4++) {
        if (_k4 !== i && _k4 !== j) {
          Hij[i][_k4] = Aki[_k4];
          Hij[_k4][i] = Aki[_k4];
          Hij[j][_k4] = Akj[_k4];
          Hij[_k4][j] = Akj[_k4];
        }
      }
      return Hij;
    } // get max off-diagonal value from Upper Diagonal

    function getAij(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
            maxMij = Math.abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    } // get max off-diagonal value from Upper Diagonal

    function getAijBig(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (abs(maxMij) < abs(Mij[i][j])) {
            maxMij = abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    } // sort results

    function sorting(E, S) {
      var N = E.length;
      var values = Array(N);
      var vectors = Array(N);
      for (var k = 0; k < N; k++) {
        vectors[k] = Array(N);
      }
      for (var i = 0; i < N; i++) {
        var minID = 0;
        var minE = E[0];
        for (var j = 0; j < E.length; j++) {
          if (abs(E[j]) < abs(minE)) {
            minID = j;
            minE = E[minID];
          }
        }
        values[i] = E.splice(minID, 1)[0];
        for (var _k5 = 0; _k5 < N; _k5++) {
          vectors[_k5][i] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
      return {
        values,
        vectors
      };
    }
    /**
     * Create an array of a certain size and fill all items with an initial value
     * @param {number} size
     * @param {number} value
     * @return {number[]}
     */

    function createArray(size, value) {
      // TODO: as soon as all browsers support Array.fill, use that instead (IE doesn't support it)
      var array = new Array(size);
      for (var i = 0; i < size; i++) {
        array[i] = value;
      }
      return array;
    }
    return main;
  }

  var name$1 = 'eigs'; // The absolute state of math.js's dependency system:

  var dependencies$1 = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];
  var createEigs = /* #__PURE__ */factory(name$1, dependencies$1, _ref => {
    var {
      config,
      typed,
      matrix,
      addScalar,
      subtract,
      equal,
      abs,
      atan,
      cos,
      sin,
      multiplyScalar,
      divideScalar,
      inv,
      bignumber,
      multiply,
      add,
      larger,
      column,
      flatten,
      number,
      complex,
      sqrt,
      diag,
      qr,
      usolve,
      usolveAll,
      im,
      re,
      smaller,
      matrixFromColumns,
      dot
    } = _ref;
    var doRealSymetric = createRealSymmetric({
      config,
      addScalar,
      subtract,
      column,
      flatten,
      equal,
      abs,
      atan,
      cos,
      sin,
      multiplyScalar,
      inv,
      bignumber,
      complex,
      multiply,
      add
    });
    var doComplexEigs = createComplexEigs({
      config,
      addScalar,
      subtract,
      multiply,
      multiplyScalar,
      flatten,
      divideScalar,
      sqrt,
      abs,
      bignumber,
      diag,
      qr,
      inv,
      usolve,
      usolveAll,
      equal,
      complex,
      larger,
      smaller,
      matrixFromColumns,
      dot
    });
    /**
     * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.
     * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix 
     * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).
     * If the algorithm fails to converge, it will throw an error  in that case, however, you may still find useful information
     * in `err.values` and `err.vectors`.
     *
     * Syntax:
     *
     *     math.eigs(x, [prec])
     *
     * Examples:
     *
     *     const { eigs, multiply, column, transpose } = math
     *     const H = [[5, 2.3], [2.3, 1]]
     *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}
     *     const E = ans.values
     *     const U = ans.vectors
     *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))
     *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H
     *     E[0] == UTxHxU[0][0]  // returns true
     *
     * See also:
     *
     *     inv
     *
     * @param {Array | Matrix} x  Matrix to be diagonalized
     *
     * @param {number | BigNumber} [prec] Precision, default value: 1e-15
     * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.
     *
     */

    return typed('eigs', {
      Array: function Array(x) {
        var mat = matrix(x);
        return computeValuesAndVectors(mat);
      },
      'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {
        var mat = matrix(x);
        return computeValuesAndVectors(mat, prec);
      },
      Matrix: function Matrix(mat) {
        var {
          values,
          vectors
        } = computeValuesAndVectors(mat);
        return {
          values: matrix(values),
          vectors: matrix(vectors)
        };
      },
      'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {
        var {
          values,
          vectors
        } = computeValuesAndVectors(mat, prec);
        return {
          values: matrix(values),
          vectors: matrix(vectors)
        };
      }
    });
    function computeValuesAndVectors(mat, prec) {
      if (prec === undefined) {
        prec = config.epsilon;
      }
      var size = mat.size();
      if (size.length !== 2 || size[0] !== size[1]) {
        throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
      }
      var arr = mat.toArray();
      var N = size[0];
      if (isReal(arr, N, prec)) {
        coerceReal(arr, N);
        if (isSymmetric(arr, N, prec)) {
          var _type = coerceTypes(mat, arr, N);
          return doRealSymetric(arr, N, prec, _type);
        }
      }
      var type = coerceTypes(mat, arr, N);
      return doComplexEigs(arr, N, prec, type);
    }
    /** @return {boolean} */

    function isSymmetric(arr, N, prec) {
      for (var i = 0; i < N; i++) {
        for (var j = i; j < N; j++) {
          // TODO proper comparison of bignum and frac
          if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    /** @return {boolean} */

    function isReal(arr, N, prec) {
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          // TODO proper comparison of bignum and frac
          if (larger(bignumber(abs(im(arr[i][j]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function coerceReal(arr, N) {
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          arr[i][j] = re(arr[i][j]);
        }
      }
    }
    /** @return {'number' | 'BigNumber' | 'Complex'} */

    function coerceTypes(mat, arr, N) {
      /** @type {string} */
      var type = mat.datatype();
      if (type === 'number' || type === 'BigNumber' || type === 'Complex') {
        return type;
      }
      var hasNumber = false;
      var hasBig = false;
      var hasComplex = false;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          var el = arr[i][j];
          if (isNumber(el) || isFraction(el)) {
            hasNumber = true;
          } else if (isBigNumber(el)) {
            hasBig = true;
          } else if (isComplex(el)) {
            hasComplex = true;
          } else {
            throw TypeError('Unsupported type in Matrix: ' + typeOf(el));
          }
        }
      }
      if (hasBig && hasComplex) {
        console.warn('Complex BigNumbers not supported, this operation will lose precission.');
      }
      if (hasComplex) {
        for (var _i = 0; _i < N; _i++) {
          for (var _j = 0; _j < N; _j++) {
            arr[_i][_j] = complex(arr[_i][_j]);
          }
        }
        return 'Complex';
      }
      if (hasBig) {
        for (var _i2 = 0; _i2 < N; _i2++) {
          for (var _j2 = 0; _j2 < N; _j2++) {
            arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
          }
        }
        return 'BigNumber';
      }
      if (hasNumber) {
        for (var _i3 = 0; _i3 < N; _i3++) {
          for (var _j3 = 0; _j3 < N; _j3++) {
            arr[_i3][_j3] = number(arr[_i3][_j3]);
          }
        }
        return 'number';
      } else {
        throw TypeError('Matrix contains unsupported types only.');
      }
    }
  });

  var name = 'divide';
  var dependencies = ['typed', 'matrix', 'multiply', 'equalScalar', 'divideScalar', 'inv'];
  var createDivide = /* #__PURE__ */factory(name, dependencies, _ref => {
    var {
      typed,
      matrix,
      multiply,
      equalScalar,
      divideScalar,
      inv
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed,
      equalScalar
    });
    var algorithm14 = createAlgorithm14({
      typed
    });
    /**
     * Divide two values, `x / y`.
     * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
     *
     * Syntax:
     *
     *    math.divide(x, y)
     *
     * Examples:
     *
     *    math.divide(2, 3)            // returns number 0.6666666666666666
     *
     *    const a = math.complex(5, 14)
     *    const b = math.complex(4, 1)
     *    math.divide(a, b)            // returns Complex 2 + 3i
     *
     *    const c = [[7, -6], [13, -4]]
     *    const d = [[1, 2], [4, 3]]
     *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
     *
     *    const e = math.unit('18 km')
     *    math.divide(e, 4.5)          // returns Unit 4 km
     *
     * See also:
     *
     *    multiply
     *
     * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
     * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
     * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
     */

    return typed('divide', extend({
      // we extend the signatures of divideScalar with signatures dealing with matrices
      'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(x, y) {
        // TODO: implement matrix right division using pseudo inverse
        // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
        // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
        // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
        return multiply(x, inv(y));
      },
      'DenseMatrix, any': function DenseMatrixAny(x, y) {
        return algorithm14(x, y, divideScalar, false);
      },
      'SparseMatrix, any': function SparseMatrixAny(x, y) {
        return algorithm11(x, y, divideScalar, false);
      },
      'Array, any': function ArrayAny(x, y) {
        // use matrix implementation
        return algorithm14(matrix(x), y, divideScalar, false).valueOf();
      },
      'any, Array | Matrix': function anyArrayMatrix(x, y) {
        return multiply(x, inv(y));
      }
    }, divideScalar.signatures));
  });

  /**
   * THIS FILE IS AUTO-GENERATED
   * DON'T MAKE CHANGES HERE
   */
  var BigNumber = /* #__PURE__ */createBigNumberClass({
    config: config$1
  });
  var Complex = /* #__PURE__ */createComplexClass({});
  var Fraction = /* #__PURE__ */createFractionClass({});
  var Matrix = /* #__PURE__ */createMatrixClass({});
  var DenseMatrix = /* #__PURE__ */createDenseMatrixClass({
    Matrix
  });
  var typed = /* #__PURE__ */createTyped({
    BigNumber,
    Complex,
    DenseMatrix,
    Fraction
  });
  var abs = /* #__PURE__ */createAbs({
    typed
  });
  var addScalar = /* #__PURE__ */createAddScalar({
    typed
  });
  var atan = /* #__PURE__ */createAtan({
    typed
  });
  var bignumber = /* #__PURE__ */createBignumber({
    BigNumber,
    typed
  });
  var complex = /* #__PURE__ */createComplex({
    Complex,
    typed
  });
  var conj = /* #__PURE__ */createConj({
    typed
  });
  var equalScalar = /* #__PURE__ */createEqualScalar({
    config: config$1,
    typed
  });
  var im = /* #__PURE__ */createIm({
    typed
  });
  var isZero = /* #__PURE__ */createIsZero({
    typed
  });
  var multiplyScalar = /* #__PURE__ */createMultiplyScalar({
    typed
  });
  var number = /* #__PURE__ */createNumber({
    typed
  });
  var re = /* #__PURE__ */createRe({
    typed
  });
  var sign = /* #__PURE__ */createSign({
    BigNumber,
    Fraction,
    complex,
    typed
  });
  var sin$2 = /* #__PURE__ */createSin({
    typed
  });
  var SparseMatrix = /* #__PURE__ */createSparseMatrixClass({
    Matrix,
    equalScalar,
    typed
  });
  var cos$2 = /* #__PURE__ */createCos({
    typed
  });
  var sqrt = /* #__PURE__ */createSqrt({
    Complex,
    config: config$1,
    typed
  });
  var unaryMinus = /* #__PURE__ */createUnaryMinus({
    typed
  });
  var fraction = /* #__PURE__ */createFraction({
    Fraction,
    typed
  });
  var matrix = /* #__PURE__ */createMatrix({
    DenseMatrix,
    Matrix,
    SparseMatrix,
    typed
  });
  var numeric = /* #__PURE__ */createNumeric({
    bignumber,
    fraction,
    number
  });
  var size = /* #__PURE__ */createSize({
    matrix,
    config: config$1,
    typed
  });
  var smaller = /* #__PURE__ */createSmaller({
    DenseMatrix,
    config: config$1,
    matrix,
    typed
  });
  var subtract = /* #__PURE__ */createSubtract({
    DenseMatrix,
    addScalar,
    equalScalar,
    matrix,
    typed,
    unaryMinus
  });
  var transpose = /* #__PURE__ */createTranspose({
    matrix,
    typed
  });
  var zeros = /* #__PURE__ */createZeros({
    BigNumber,
    config: config$1,
    matrix,
    typed
  });
  var ctranspose = /* #__PURE__ */createCtranspose({
    conj,
    transpose,
    typed
  });
  var diag = /* #__PURE__ */createDiag({
    DenseMatrix,
    SparseMatrix,
    matrix,
    typed
  });
  var divideScalar = /* #__PURE__ */createDivideScalar({
    numeric,
    typed
  });
  var equal = /* #__PURE__ */createEqual({
    DenseMatrix,
    equalScalar,
    matrix,
    typed
  });
  var flatten = /* #__PURE__ */createFlatten({
    matrix,
    typed
  });
  var largerEq = /* #__PURE__ */createLargerEq({
    DenseMatrix,
    config: config$1,
    matrix,
    typed
  });
  var matrixFromColumns = /* #__PURE__ */createMatrixFromColumns({
    flatten,
    matrix,
    size,
    typed
  });
  var smallerEq = /* #__PURE__ */createSmallerEq({
    DenseMatrix,
    config: config$1,
    matrix,
    typed
  });
  var usolve = /* #__PURE__ */createUsolve({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtract,
    typed
  });
  var add = /* #__PURE__ */createAdd({
    DenseMatrix,
    SparseMatrix,
    addScalar,
    equalScalar,
    matrix,
    typed
  });
  var dot = /* #__PURE__ */createDot({
    addScalar,
    conj,
    multiplyScalar,
    size,
    typed
  });
  var identity = /* #__PURE__ */createIdentity({
    BigNumber,
    DenseMatrix,
    SparseMatrix,
    config: config$1,
    matrix,
    typed
  });
  var larger = /* #__PURE__ */createLarger({
    DenseMatrix,
    config: config$1,
    matrix,
    typed
  });
  var multiply = /* #__PURE__ */createMultiply({
    addScalar,
    dot,
    equalScalar,
    matrix,
    multiplyScalar,
    typed
  });
  var qr = /* #__PURE__ */createQr({
    addScalar,
    complex,
    conj,
    divideScalar,
    equal,
    identity,
    isZero,
    matrix,
    multiplyScalar,
    sign,
    sqrt,
    subtract,
    typed,
    unaryMinus,
    zeros
  });
  var range = /* #__PURE__ */createRange({
    bignumber,
    matrix,
    config: config$1,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  });
  var usolveAll = /* #__PURE__ */createUsolveAll({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtract,
    typed
  });
  var cross = /* #__PURE__ */createCross({
    matrix,
    multiply,
    subtract,
    typed
  });
  var det = /* #__PURE__ */createDet({
    divideScalar,
    isZero,
    matrix,
    multiply,
    subtract,
    typed,
    unaryMinus
  });
  var ImmutableDenseMatrix = /* #__PURE__ */createImmutableDenseMatrixClass({
    DenseMatrix,
    smaller
  });
  var Index = /* #__PURE__ */createIndexClass({
    ImmutableDenseMatrix
  });
  var column = /* #__PURE__ */createColumn({
    Index,
    matrix,
    range,
    typed
  });
  var inv = /* #__PURE__ */createInv({
    abs,
    addScalar,
    det,
    divideScalar,
    identity,
    matrix,
    multiply,
    typed,
    unaryMinus
  });
  var pow = /* #__PURE__ */createPow({
    Complex,
    config: config$1,
    fraction,
    identity,
    inv,
    matrix,
    multiply,
    number,
    typed
  });
  var divide = /* #__PURE__ */createDivide({
    divideScalar,
    equalScalar,
    inv,
    matrix,
    multiply,
    typed
  });
  var eigs = /* #__PURE__ */createEigs({
    abs,
    add,
    addScalar,
    atan,
    bignumber,
    column,
    complex,
    config: config$1,
    cos: cos$2,
    diag,
    divideScalar,
    dot,
    equal,
    flatten,
    im,
    inv,
    larger,
    matrix,
    matrixFromColumns,
    multiply,
    multiplyScalar,
    number,
    qr,
    re,
    sin: sin$2,
    smaller,
    sqrt,
    subtract,
    typed,
    usolve,
    usolveAll
  });
  var norm = /* #__PURE__ */createNorm({
    abs,
    add,
    conj,
    ctranspose,
    eigs,
    equalScalar,
    larger,
    matrix,
    multiply,
    pow,
    smaller,
    sqrt,
    typed
  });

  function DegToRad(value) {
      return value * (Math.PI / 180);
  }
  function RadToDeg(value) {
      return value * (180 / Math.PI);
  }
  const MIN_LON = -180;
  const MAX_LON = 180;
  const EARTH_RADIUS = 3443.91846652;

  const sin$1 = (angle) => Math.sin(DegToRad(angle));
  const cos$1 = (angle) => Math.cos(DegToRad(angle));
  function asin$1(angle) {
      return RadToDeg(Math.asin(angle));
  }
  function atan2(y, x) {
      return RadToDeg(Math.atan2(y, x));
  }

  /**
   * Calculates the bearing from one point to another (referenced at the first coordinate, bearing can be different at different points between the two)
   * @param from
   * @param to
   */
  function bearingTo(from, to) {
      return (atan2(sin$1(to.long - from.long)
          * cos$1(to.lat), cos$1(from.lat) * sin$1(to.lat)
          - sin$1(from.lat)
              * cos$1(to.lat)
              * cos$1(to.long - from.long)) + 360)
          % 360;
  }

  const robustAcos = (value) => {
      if (value > 1) {
          return 1;
      }
      if (value < -1) {
          return -1;
      }
      return value;
  };
  function clampAngle(a) {
      while (a >= 360) {
          a -= 360;
      }
      while (a < 0) {
          a += 360;
      }
      return a;
  }
  function diffAngle(a, b) {
      let diff = b - a;
      while (diff > 180) {
          diff -= 360;
      }
      while (diff <= -180) {
          diff += 360;
      }
      return diff;
  }
  function coordinatesToSpherical(location) {
      return [
          cos$1(location.lat) * cos$1(location.long),
          cos$1(location.lat) * sin$1(location.long),
          sin$1(location.lat),
      ];
  }
  function sphericalToCoordinates(spherical) {
      return {
          lat: asin$1(spherical[2]),
          long: atan2(spherical[1], spherical[0]),
      };
  }

  /**
   * Calculates the distance between two coordinates on the globe
   * @param from
   * @param to
   */
  function distanceTo(from, to) {
      return Math.acos(robustAcos(sin$1(to.lat) * sin$1(from.lat)
          + cos$1(to.lat)
              * cos$1(from.lat)
              * cos$1(from.long - to.long))) * EARTH_RADIUS;
  }

  /**
   * Calculates a Coordinate at a bearing and distance from a reference point
   * @param place - Point to reference from
   * @param bearing
   * @param distance
   */
  function placeBearingDistance(place, bearing, distance) {
      const delta = distance / EARTH_RADIUS;
      const lat = asin$1(sin$1(place.lat) * Math.cos(delta)
          + cos$1(place.lat) * Math.sin(delta) * cos$1(bearing));
      let long = place.long
          + atan2(sin$1(bearing) * Math.sin(delta) * cos$1(place.lat), Math.cos(delta) - sin$1(place.lat) * sin$1(lat));
      if (long < MIN_LON || long > MAX_LON) {
          long = ((long + 540) % (360)) - 180;
      }
      return {
          lat,
          long,
      };
  }

  /**
   * Calculates the intercept points of two Coordinates and two bearings
   * @param point1
   * @param bearing1
   * @param point2
   * @param bearing2
   */
  function placeBearingIntersection(point1, bearing1, point2, bearing2) {
      const Pa11 = coordinatesToSpherical(point1);
      const point12 = placeBearingDistance(point1, clampAngle(bearing1), 500);
      const Pa12 = coordinatesToSpherical(point12);
      const Pa21 = coordinatesToSpherical(point2);
      const point22 = placeBearingDistance(point2, clampAngle(bearing2), 500);
      const Pa22 = coordinatesToSpherical(point22);
      const N1 = cross(Pa11, Pa12);
      const N2 = cross(Pa21, Pa22);
      const L = cross(N1, N2);
      const l = norm(L);
      const I1 = divide(L, l);
      const I2 = multiply(I1, -1);
      const s1 = sphericalToCoordinates(I1);
      const s2 = sphericalToCoordinates(I2);
      const brgTos1 = bearingTo(point1, s1);
      const brgTos2 = bearingTo(point1, s2);
      const delta1 = Math.abs(clampAngle(bearing1) - brgTos1);
      const delta2 = Math.abs(clampAngle(bearing1) - brgTos2);
      return [delta1 < delta2 ? s1 : s2, delta1 < delta2 ? s2 : s1];
  }

  function xyzToCoordinates(x, y, z) {
      const theta = Math.atan2(Math.sqrt(x ** 2 + y ** 2), z);
      // From: https://en.wikipedia.org/wiki/Spherical_coordinate_system#Coordinate_system_conversions
      let phi = NaN;
      if (x > 0)
          phi = Math.atan(y / x);
      else if (x < 0 && y >= 0)
          phi = Math.atan(y / x) + Math.PI;
      else if (x < 0 && y < 0)
          phi = Math.atan(y / x) - Math.PI;
      else if (x === 0 && y > 0)
          phi = Math.PI;
      else if (x === 0 && y < 0)
          phi = -Math.PI;
      return {
          lat: thetaToLat(theta),
          long: phiToLong(phi),
      };
  }
  function thetaToLat(theta) {
      return 90 - (theta * 180) / Math.PI;
  }
  function phiToLong(phi) {
      if (phi > Math.PI)
          return 180 - (phi * 180) / Math.PI;
      return (phi * 180) / Math.PI;
  }
  function latToTheta(lat) {
      return ((90 - lat) * Math.PI) / 180;
  }
  function longToPhi(long) {
      if (long < 0)
          return ((long + 360) * Math.PI) / 180;
      return (long * Math.PI) / 180;
  }
  function coordinatesToXyz(coordinates, radius) {
      const theta = latToTheta(coordinates.lat);
      const phi = longToPhi(coordinates.long);
      return [
          radius * Math.sin(theta) * Math.cos(phi),
          radius * Math.sin(theta) * Math.sin(phi),
          radius * Math.cos(theta),
      ];
  }
  function crossProduct(x1, y1, z1, x2, y2, z2) {
      return [y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2];
  }
  function thetaUnitVector(theta, phi) {
      return [Math.cos(theta) * Math.cos(phi), Math.cos(theta) * Math.sin(phi), -Math.sin(theta)];
  }
  function phiUnitVector(theta, phi) {
      return [-Math.sin(phi), Math.cos(phi), 0];
  }
  function calculateV(course, theta, phi) {
      const [thetaUnitX, thetaUnitY, thetaUnitZ] = thetaUnitVector(theta, phi);
      const [phiUnitX, phiUnitY, phiUnitZ] = phiUnitVector(theta, phi);
      return [
          -Math.cos(course) * thetaUnitX + Math.sin(course) * phiUnitX,
          -Math.cos(course) * thetaUnitY + Math.sin(course) * phiUnitY,
          -Math.cos(course) * thetaUnitZ + Math.sin(course) * phiUnitZ,
      ];
  }
  function solveWithPermutations(smallCircleCoordinates, ns, smallCircleRadius, permutations) {
      let permutation = permutations[0];
      let denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
      for (let i = 1; Math.abs(denominator) < 1e-4 && i < 3; i++) {
          permutation = permutations[i];
          denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
      }
      const A = (-ns[permutation[2]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2)) / 2 / denominator;
      const B = -(ns[permutation[2]] * smallCircleCoordinates[permutation[0]] - ns[permutation[0]] * smallCircleCoordinates[permutation[2]]) / denominator;
      const C = (ns[permutation[1]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2)) / 2 / denominator;
      const D = -(-ns[permutation[1]] * smallCircleCoordinates[permutation[0]] + ns[permutation[0]] * smallCircleCoordinates[permutation[1]]) / denominator;
      const discriminant = -(C ** 2) * (1 + B ** 2) + 2 * A * B * C * D - A ** 2 * (1 + D ** 2) + (1 + B ** 2 + D ** 2) * EARTH_RADIUS ** 2;
      if (discriminant < 0) {
          return null;
      }
      const result1 = [0, 0, 0];
      const result2 = [0, 0, 0];
      result1[permutation[0]] = (-A * B - C * D - Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
      result2[permutation[0]] = (-A * B - C * D + Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
      result1[permutation[1]] = A + B * result1[permutation[0]];
      result2[permutation[1]] = A + B * result2[permutation[0]];
      result1[permutation[2]] = C + D * result1[permutation[0]];
      result2[permutation[2]] = C + D * result2[permutation[0]];
      return [xyzToCoordinates(result1[0], result1[1], result1[2]), xyzToCoordinates(result2[0], result2[1], result2[2])];
  }
  function smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
      const smallCircleCoords = coordinatesToXyz(smallCircleCentre, EARTH_RADIUS);
      const [greatCircleX, greatCircleY, greatCircleZ] = coordinatesToXyz(greatCircleReference, EARTH_RADIUS);
      const [vx, vy, vz] = calculateV((greatCircleBearing * Math.PI) / 180, latToTheta(greatCircleReference.lat), longToPhi(greatCircleReference.long));
      const normalVector = crossProduct(greatCircleX, greatCircleY, greatCircleZ, vx, vy, vz);
      return solveWithPermutations(smallCircleCoords, normalVector, smallCircleRadius, [[0, 1, 2], [2, 0, 1], [1, 2, 0]]);
  }
  /**
   * Returns the first small circle intersection to occur on a given bearing
   * @param smallCircleCentre
   * @param smallCircleRadius
   * @param greatCircleReference
   * @param greatCircleBearing
   */
  function firstSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
      const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
      if (!intercepts)
          return null;
      if (distanceTo(greatCircleReference, smallCircleCentre) <= smallCircleRadius) {
          // The great circle reference is inside the circle, use the intercept which is in-front of the great circle reference as per the great circle bearing
          if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, intercepts[0]))) <= 90) {
              return intercepts[0];
          }
          return intercepts[1];
      }
      if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, smallCircleCentre))) <= 90) {
          // The small circle centre is in-front of the great circle reference, use the closest intercept
          if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
              return intercepts[0];
          }
          return intercepts[1];
      }
      // The small circle centre is behind the great circle reference, use the furthest intercept
      if (distanceTo(greatCircleReference, intercepts[0]) > distanceTo(greatCircleReference, intercepts[1])) {
          return intercepts[0];
      }
      return intercepts[1];
  }
  /**
   * Returns the closest to greatCircleReference of two intercepts between a great circle and a small circle
   * @param smallCircleCentre
   * @param smallCircleRadius
   * @param greatCircleReference
   * @param greatCircleBearing
   */
  function closestSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
      const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
      if (!intercepts)
          return null;
      if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
          return intercepts[0];
      }
      return intercepts[1];
  }

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  /** Generates fix names based on the ARINC default naming scheme. */
  class FixNamingScheme {
    /**
       * Generates a fix name for a vector type fix.
       *
       * @returns The generated fix name.
       */
    static vector() {
      return 'MANUAL';
    }

    /**
       * Generates a fix name for a heading to altitude type fix.
       *
       * @param altitudeFeet The altitude that will be flown to.
       *
       * @returns The generated fix name.
       */
    static headingUntilAltitude(altitudeFeet) {
      return Math.round(altitudeFeet).toString();
    }

    /**
     * Generates a fix name for a course to distance type fix.
     *
     * @param course The course that will be flown.
     * @param distance The distance along the course or from the reference fix.
     *
     * @returns The generated fix name.
     */
    static courseToDistance(course, distance) {
      const roundedDistance = Math.round(distance);
      const distanceAlpha = distance > 26 ? 'Z' : this.alphabet[roundedDistance];
      return "D".concat(course.toFixed(0).padStart(3, '0')).concat(distanceAlpha);
    }

    /**
     * Generates a fix name for a course turn to intercept type fix.
     *
     * @param course The course that will be turned to.
     *
     * @returns The generated fix name.
     */
    static courseToIntercept(course) {
      return 'INTCPT';
    }
  }
  _defineProperty(FixNamingScheme, "alphabet", ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']);

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  function WorldMagneticModel() {
    this.coff = ['  1,  0,  -29404.5  ,     0.0    ,    6.7  ,      0.0', '  1,  1,   -1450.7  ,  4652.9    ,    7.7  ,    -25.1', '  2,  0,   -2500.0  ,     0.0    ,  -11.5  ,      0.0', '  2,  1,    2982.0  , -2991.6    ,   -7.1  ,    -30.2', '  2,  2,    1676.8  ,  -734.8    ,   -2.2  ,    -23.9', '  3,  0,    1363.9  ,     0.0    ,    2.8  ,      0.0', '  3,  1,   -2381.0  ,   -82.2    ,   -6.2  ,      5.7', '  3,  2,    1236.2  ,   241.8    ,    3.4  ,     -1.0', '  3,  3,     525.7  ,  -542.9    ,  -12.2  ,      1.1', '  4,  0,     903.1  ,     0.0    ,   -1.1  ,      0.0', '  4,  1,     809.4  ,   282.0    ,   -1.6  ,      0.2', '  4,  2,      86.2  ,  -158.4    ,   -6.0  ,      6.9', '  4,  3,    -309.4  ,   199.8    ,    5.4  ,      3.7', '  4,  4,      47.9  ,  -350.1    ,   -5.5  ,     -5.6', '  5,  0,    -234.4  ,     0.0    ,   -0.3  ,      0.0', '  5,  1,     363.1  ,    47.7    ,    0.6  ,      0.1', '  5,  2,     187.8  ,   208.4    ,   -0.7  ,      2.5', '  5,  3,    -140.7  ,  -121.3    ,    0.1  ,     -0.9', '  5,  4,    -151.2  ,    32.2    ,    1.2  ,      3.0', '  5,  5,      13.7  ,    99.1    ,    1.0  ,      0.5', '  6,  0,      65.9  ,     0.0    ,   -0.6  ,      0.0', '  6,  1,      65.6  ,   -19.1    ,   -0.4  ,      0.1', '  6,  2,      73.0  ,    25.0    ,    0.5  ,     -1.8', '  6,  3,    -121.5  ,    52.7    ,    1.4  ,     -1.4', '  6,  4,     -36.2  ,   -64.4    ,   -1.4  ,      0.9', '  6,  5,      13.5  ,     9.0    ,   -0.0  ,      0.1', '  6,  6,     -64.7  ,    68.1    ,    0.8  ,      1.0', '  7,  0,      80.6  ,     0.0    ,   -0.1  ,      0.0', '  7,  1,     -76.8  ,   -51.4    ,   -0.3  ,      0.5', '  7,  2,      -8.3  ,   -16.8    ,   -0.1  ,      0.6', '  7,  3,      56.5  ,     2.3    ,    0.7  ,     -0.7', '  7,  4,      15.8  ,    23.5    ,    0.2  ,     -0.2', '  7,  5,       6.4  ,    -2.2    ,   -0.5  ,     -1.2', '  7,  6,      -7.2  ,   -27.2    ,   -0.8  ,      0.2', '  7,  7,       9.8  ,    -1.9    ,    1.0  ,      0.3', '  8,  0,      23.6  ,     0.0    ,   -0.1  ,      0.0', '  8,  1,       9.8  ,     8.4    ,    0.1  ,     -0.3', '  8,  2,     -17.5  ,   -15.3    ,   -0.1  ,      0.7', '  8,  3,      -0.4  ,    12.8    ,    0.5  ,     -0.2', '  8,  4,     -21.1  ,   -11.8    ,   -0.1  ,      0.5', '  8,  5,      15.3  ,    14.9    ,    0.4  ,     -0.3', '  8,  6,      13.7  ,     3.6    ,    0.5  ,     -0.5', '  8,  7,     -16.5  ,    -6.9    ,    0.0  ,      0.4', '  8,  8,      -0.3  ,     2.8    ,    0.4  ,      0.1', '  9,  0,       5.0  ,     0.0    ,   -0.1  ,      0.0', '  9,  1,       8.2  ,   -23.3    ,   -0.2  ,     -0.3', '  9,  2,       2.9  ,    11.1    ,   -0.0  ,      0.2', '  9,  3,      -1.4  ,     9.8    ,    0.4  ,     -0.4', '  9,  4,      -1.1  ,    -5.1    ,   -0.3  ,      0.4', '  9,  5,     -13.3  ,    -6.2    ,   -0.0  ,      0.1', '  9,  6,       1.1  ,     7.8    ,    0.3  ,     -0.0', '  9,  7,       8.9  ,     0.4    ,   -0.0  ,     -0.2', '  9,  8,      -9.3  ,    -1.5    ,   -0.0  ,      0.5', '  9,  9,     -11.9  ,     9.7    ,   -0.4  ,      0.2', ' 10,  0,      -1.9  ,     0.0    ,    0.0  ,      0.0', ' 10,  1,      -6.2  ,     3.4    ,   -0.0  ,     -0.0', ' 10,  2,      -0.1  ,    -0.2    ,   -0.0  ,      0.1', ' 10,  3,       1.7  ,     3.5    ,    0.2  ,     -0.3', ' 10,  4,      -0.9  ,     4.8    ,   -0.1  ,      0.1', ' 10,  5,       0.6  ,    -8.6    ,   -0.2  ,     -0.2', ' 10,  6,      -0.9  ,    -0.1    ,   -0.0  ,      0.1', ' 10,  7,       1.9  ,    -4.2    ,   -0.1  ,     -0.0', ' 10,  8,       1.4  ,    -3.4    ,   -0.2  ,     -0.1', ' 10,  9,      -2.4  ,    -0.1    ,   -0.1  ,      0.2', ' 10, 10,      -3.9  ,    -8.8    ,   -0.0  ,     -0.0', ' 11,  0,       3.0  ,     0.0    ,   -0.0  ,      0.0', ' 11,  1,      -1.4  ,    -0.0    ,   -0.1  ,     -0.0', ' 11,  2,      -2.5  ,     2.6    ,   -0.0  ,      0.1', ' 11,  3,       2.4  ,    -0.5    ,    0.0  ,      0.0', ' 11,  4,      -0.9  ,    -0.4    ,   -0.0  ,      0.2', ' 11,  5,       0.3  ,     0.6    ,   -0.1  ,     -0.0', ' 11,  6,      -0.7  ,    -0.2    ,    0.0  ,      0.0', ' 11,  7,      -0.1  ,    -1.7    ,   -0.0  ,      0.1', ' 11,  8,       1.4  ,    -1.6    ,   -0.1  ,     -0.0', ' 11,  9,      -0.6  ,    -3.0    ,   -0.1  ,     -0.1', ' 11, 10,       0.2  ,    -2.0    ,   -0.1  ,      0.0', ' 11, 11,       3.1  ,    -2.6    ,   -0.1  ,     -0.0', ' 12,  0,      -2.0  ,     0.0    ,    0.0  ,      0.0', ' 12,  1,      -0.1  ,    -1.2    ,   -0.0  ,     -0.0', ' 12,  2,       0.5  ,     0.5    ,   -0.0  ,      0.0', ' 12,  3,       1.3  ,     1.3    ,    0.0  ,     -0.1', ' 12,  4,      -1.2  ,    -1.8    ,   -0.0  ,      0.1', ' 12,  5,       0.7  ,     0.1    ,   -0.0  ,     -0.0', ' 12,  6,       0.3  ,     0.7    ,    0.0  ,      0.0', ' 12,  7,       0.5  ,    -0.1    ,   -0.0  ,     -0.0', ' 12,  8,      -0.2  ,     0.6    ,    0.0  ,      0.1', ' 12,  9,      -0.5  ,     0.2    ,   -0.0  ,     -0.0', ' 12, 10,       0.1  ,    -0.9    ,   -0.0  ,     -0.0', ' 12, 11,      -1.1  ,    -0.0    ,   -0.0  ,      0.0', ' 12, 12,      -0.3  ,     0.5    ,   -0.1  ,     -0.1'];

    /* static variables */

    /* some 13x13 2D arrays */
    this.c = new Array(13);
    this.cd = new Array(13);
    this.tc = new Array(13);
    this.dp = new Array(13);
    this.k = new Array(13);
    for (var i = 0; i < 13; i++) {
      this.c[i] = new Array(13);
      this.cd[i] = new Array(13);
      this.tc[i] = new Array(13);
      this.dp[i] = new Array(13);
      this.k[i] = new Array(13);
    }

    /* some 1D arrays */
    this.snorm = new Array(169);
    this.sp = new Array(13);
    this.cp = new Array(13);
    this.fn = new Array(13);
    this.fm = new Array(13);
    this.pp = new Array(13);

    /* locals */

    const maxdeg = 12;
    let maxord;
    var i;
    let j;
    let D1;
    let D2;
    let n;
    let m;
    let gnm;
    let hnm;
    let dgnm;
    let dhnm;
    let flnmj;
    let c_str;
    let c_flds;

    /* INITIALIZE CONSTANTS */

    maxord = maxdeg;
    this.sp[0] = 0.0;
    this.cp[0] = this.snorm[0] = this.pp[0] = 1.0;
    this.dp[0][0] = 0.0;

    /* READ WORLD MAGNETIC MODEL SPHERICAL HARMONIC COEFFICIENTS */
    this.c[0][0] = 0.0;
    this.cd[0][0] = 0.0;
    for (i = 0; i < this.coff.length; i++) {
      c_str = this.coff[i];
      c_flds = c_str.split(',');
      n = parseInt(c_flds[0], 10);
      m = parseInt(c_flds[1], 10);
      gnm = parseFloat(c_flds[2]);
      hnm = parseFloat(c_flds[3]);
      dgnm = parseFloat(c_flds[4]);
      dhnm = parseFloat(c_flds[5]);
      if (m <= n) {
        this.c[m][n] = gnm;
        this.cd[m][n] = dgnm;
        if (m != 0) {
          this.c[n][m - 1] = hnm;
          this.cd[n][m - 1] = dhnm;
        }
      }
    }

    /* CONVERT SCHMIDT NORMALIZED GAUSS COEFFICIENTS TO UNNORMALIZED */

    this.snorm[0] = 1.0;
    for (n = 1; n <= maxord; n++) {
      this.snorm[n] = this.snorm[n - 1] * (2 * n - 1) / n;
      j = 2;
      for (m = 0, D1 = 1, D2 = (n - m + D1) / D1; D2 > 0; D2--, m += D1) {
        this.k[m][n] = ((n - 1) * (n - 1) - m * m) / ((2 * n - 1) * (2 * n - 3));
        if (m > 0) {
          flnmj = (n - m + 1) * j / (n + m);
          this.snorm[n + m * 13] = this.snorm[n + (m - 1) * 13] * Math.sqrt(flnmj);
          j = 1;
          this.c[n][m - 1] = this.snorm[n + m * 13] * this.c[n][m - 1];
          this.cd[n][m - 1] = this.snorm[n + m * 13] * this.cd[n][m - 1];
        }
        this.c[m][n] = this.snorm[n + m * 13] * this.c[m][n];
        this.cd[m][n] = this.snorm[n + m * 13] * this.cd[m][n];
      }
      this.fn[n] = n + 1;
      this.fm[n] = n;
    }
    this.k[1][1] = 0.0;
    this.fm[0] = 0.0; // !!!!!! WMM C and Fortran both have a bug in that fm[0] is not initialised
  }

  WorldMagneticModel.prototype.declination = function (altitudeKm, latitudeDegrees, longitudeDegrees, yearFloat) {
    /* locals */

    const a = 6378.137;
    const b = 6356.7523142;
    const re = 6371.2;
    const a2 = a * a;
    const b2 = b * b;
    const c2 = a2 - b2;
    const a4 = a2 * a2;
    const b4 = b2 * b2;
    const c4 = a4 - b4;
    let D3;
    let D4;
    let dec;
    let n;
    let m;
    let pi;
    let dt;
    let rlon;
    let rlat;
    let srlon;
    let srlat;
    let crlon;
    let crlat;
    let srlat2;
    let crlat2;
    let q;
    let q1;
    let q2;
    let ct;
    let d;
    let aor;
    let ar;
    let br;
    let r;
    let r2;
    let bpp;
    let par;
    let temp1;
    let parp;
    let temp2;
    let bx;
    let by;
    let dtr;
    let bp;
    let bt;
    let st;
    let ca;
    let sa;
    const maxord = 12;
    const alt = altitudeKm;
    const glon = longitudeDegrees;
    const glat = latitudeDegrees;

    /** ********************************************************************** */

    dt = yearFloat - 2020.0;
    // if more then 5 years has passed since last epoch update then return invalid
    if (dt < 0.0 || dt > 5.0) return -999;
    pi = 3.14159265359;
    dtr = pi / 180.0;
    rlon = glon * dtr;
    rlat = glat * dtr;
    srlon = Math.sin(rlon);
    srlat = Math.sin(rlat);
    crlon = Math.cos(rlon);
    crlat = Math.cos(rlat);
    srlat2 = srlat * srlat;
    crlat2 = crlat * crlat;
    this.sp[1] = srlon;
    this.cp[1] = crlon;

    /* CONVERT FROM GEODETIC COORDS. TO SPHERICAL COORDS. */

    q = Math.sqrt(a2 - c2 * srlat2);
    q1 = alt * q;
    q2 = (q1 + a2) / (q1 + b2) * ((q1 + a2) / (q1 + b2));
    ct = srlat / Math.sqrt(q2 * crlat2 + srlat2);
    st = Math.sqrt(1.0 - ct * ct);
    r2 = alt * alt + 2.0 * q1 + (a4 - c4 * srlat2) / (q * q);
    r = Math.sqrt(r2);
    d = Math.sqrt(a2 * crlat2 + b2 * srlat2);
    ca = (alt + d) / r;
    sa = c2 * crlat * srlat / (r * d);
    for (m = 2; m <= maxord; m++) {
      this.sp[m] = this.sp[1] * this.cp[m - 1] + this.cp[1] * this.sp[m - 1];
      this.cp[m] = this.cp[1] * this.cp[m - 1] - this.sp[1] * this.sp[m - 1];
    }
    aor = re / r;
    ar = aor * aor;
    br = bt = bp = bpp = 0.0;
    for (n = 1; n <= maxord; n++) {
      ar *= aor;
      for (m = 0, D3 = 1, D4 = (n + m + D3) / D3; D4 > 0; D4--, m += D3) {
        /*
         COMPUTE UNNORMALIZED ASSOCIATED LEGENDRE POLYNOMIALS
         AND DERIVATIVES VIA RECURSION RELATIONS
        */

        if (n == m) {
          this.snorm[n + m * 13] = st * this.snorm[n - 1 + (m - 1) * 13];
          this.dp[m][n] = st * this.dp[m - 1][n - 1] + ct * this.snorm[n - 1 + (m - 1) * 13];
        } else if (n == 1 && m == 0) {
          this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13];
          this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13];
        } else if (n > 1 && n != m) {
          if (m > n - 2) this.snorm[n - 2 + m * 13] = 0.0;
          if (m > n - 2) this.dp[m][n - 2] = 0.0;
          this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.snorm[n - 2 + m * 13];
          this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.dp[m][n - 2];
        }

        /*
        TIME ADJUST THE GAUSS COEFFICIENTS
        */
        this.tc[m][n] = this.c[m][n] + dt * this.cd[m][n];
        if (m != 0) this.tc[n][m - 1] = this.c[n][m - 1] + dt * this.cd[n][m - 1];

        /*
        ACCUMULATE TERMS OF THE SPHERICAL HARMONIC EXPANSIONS
        */
        par = ar * this.snorm[n + m * 13];
        if (m == 0) {
          temp1 = this.tc[m][n] * this.cp[m];
          temp2 = this.tc[m][n] * this.sp[m];
        } else {
          temp1 = this.tc[m][n] * this.cp[m] + this.tc[n][m - 1] * this.sp[m];
          temp2 = this.tc[m][n] * this.sp[m] - this.tc[n][m - 1] * this.cp[m];
        }
        bt -= ar * temp1 * this.dp[m][n];
        bp += this.fm[m] * temp2 * par;
        br += this.fn[n] * temp1 * par;
        /*
        SPECIAL CASE:  NORTH/SOUTH GEOGRAPHIC POLES
        */
        if (st == 0.0 && m == 1) {
          if (n == 1) this.pp[n] = this.pp[n - 1];else this.pp[n] = this.ct * this.pp[n - 1] - this.k[m][n] * this.pp[n - 2];
          parp = ar * this.pp[n];
          bpp += this.fm[m] * temp2 * parp;
        }
      }
    }
    if (st == 0.0) bp = bpp;else bp /= st;

    /*
      ROTATE MAGNETIC VECTOR COMPONENTS FROM SPHERICAL TO
      GEODETIC COORDINATES
    */
    bx = -bt * ca - br * sa;
    by = bp;
    dec = Math.atan2(by, bx) / dtr;
    return dec;
  };
  WorldMagneticModel.prototype.knownAnswerTest = function () {
    /* http://www.ngdc.noaa.gov/geomag/WMM WMM2010testvalues.pdf */

    /* Lat	Lon Dec	    */
    /* Lon 240 = 120W, Lon 300 = 60W */

    /* Alt 0 km */
    const kat2010 = ['80.00	,0.00	 ,-6.13	    ', '0.00	,120.00	 ,0.97	    ', '-80.00	,240.00	 ,70.21	    '];
    const kat2012p5 = ['80.00	,0.00	 ,-5.21	    ', '0.00	,120.00	 ,0.88	    ', '-80.00	,240.00	 ,70.04	    '];
    let maxErr = 0.0;
    for (var i = 0; i < kat2010.length; i++) {
      var c_str = kat2010[i];
      var c_flds = c_str.split(',');
      var lat = parseFloat(c_flds[0]);
      var lon = parseFloat(c_flds[1]);
      var exp = parseFloat(c_flds[2]);
      var maxExp;
      var dec = this.declination(0, lat, lon, 2010.0);
      if (Math.abs(dec - exp) > maxErr) {
        maxErr = Math.abs(dec - exp);
        maxExp = exp;
      }
    }
    for (var i = 0; i < kat2012p5.length; i++) {
      var c_str = kat2012p5[i];
      var c_flds = c_str.split(',');
      var lat = parseFloat(c_flds[0]);
      var lon = parseFloat(c_flds[1]);
      var exp = parseFloat(c_flds[2]);
      var maxExp;
      var dec = this.declination(0, lat, lon, 2012.5);
      if (Math.abs(dec - exp) > maxErr) {
        maxErr = Math.abs(dec - exp);
        maxExp = exp;
      }
    }
    return maxErr * 100 / maxExp; // max % error
  };

  /*

    C***********************************************************************
    C
    C
    C     SUBROUTINE GEOMAG (GEOMAGNETIC FIELD COMPUTATION)
    C
    C
    C***********************************************************************
    C
    C     GEOMAG IS A NATIONAL GEOSPATIAL INTELLIGENCE AGENCY (NGA) STANDARD
    C     PRODUCT.  IT IS COVERED UNDER NGA MILITARY SPECIFICATION:
    C     MIL-W-89500 (1993).
    C
    C***********************************************************************
    C     Contact Information
    C
    C     Software and Model Support
    C     	National Geophysical Data Center
    C     	NOAA EGC/2
    C     	325 Broadway
    C     	Boulder, CO 80303 USA
    C     	Attn: Susan McLean or Stefan Maus
    C     	Phone:  (303) 497-6478 or -6522
    C     	Email:  Susan.McLean@noaa.gov or Stefan.Maus@noaa.gov
    C		Web: http://www.ngdc.noaa.gov/seg/WMM/
    C
    C     Sponsoring Government Agency
    C	   National Geospatial-Intelligence Agency
    C    	   PRG / CSAT, M.S. L-41
    C    	   3838 Vogel Road
    C    	   Arnold, MO 63010
    C    	   Attn: Craig Rollins
    C    	   Phone:  (314) 263-4186
    C    	   Email:  Craig.M.Rollins@Nga.Mil
    C
    C      Original Program By:
    C        Dr. John Quinn
    C        FLEET PRODUCTS DIVISION, CODE N342
    C        NAVAL OCEANOGRAPHIC OFFICE (NAVOCEANO)
    C        STENNIS SPACE CENTER (SSC), MS 39522-5001
    C
    C***********************************************************************
    C
    C     PURPOSE:  THIS ROUTINE COMPUTES THE DECLINATION (DEC),
    C               INCLINATION (DIP), TOTAL INTENSITY (TI) AND
    C               GRID VARIATION (GV - POLAR REGIONS ONLY, REFERENCED
    C               TO GRID NORTH OF A STEREOGRAPHIC PROJECTION) OF THE
    C               EARTH'S MAGNETIC FIELD IN GEODETIC COORDINATES
    C               FROM THE COEFFICIENTS OF THE CURRENT OFFICIAL
    C               DEPARTMENT OF DEFENSE (DOD) SPHERICAL HARMONIC WORLD
    C               MAGNETIC MODEL (WMM.COF).  THE WMM SERIES OF MODELS IS
    C               UPDATED EVERY 5 YEARS ON JANUARY 1ST OF THOSE YEARS
    C               WHICH ARE DIVISIBLE BY 5 (I.E. 2000, 2005, 2010 ETC.)
    C               BY NOAA'S NATIONAL GEOPHYSICAL DATA CENTER IN
    C               COOPERATION WITH THE BRITISH GEOLOGICAL SURVEY (BGS).
    C               THE MODEL IS BASED ON GEOMAGNETIC FIELD MEASUREMENTS
    C               FROM SATELLITE AND GROUND OBSERVATORIES.
    C
    C***********************************************************************
    C
    C     MODEL:  THE WMM SERIES GEOMAGNETIC MODELS ARE COMPOSED
    C             OF TWO PARTS:  THE MAIN FIELD MODEL, WHICH IS
    C             VALID AT THE BASE EPOCH OF THE CURRENT MODEL AND
    C             A SECULAR VARIATION MODEL, WHICH ACCOUNTS FOR SLOW
    C             TEMPORAL VARIATIONS IN THE MAIN GEOMAGNETIC FIELD
    C             FROM THE BASE EPOCH TO A MAXIMUM OF 5 YEARS BEYOND
    C             THE BASE EPOCH.  FOR EXAMPLE, THE BASE EPOCH OF
    C             THE WMM-2005 MODEL IS 2005.0.  THIS MODEL IS THEREFORE
    C             CONSIDERED VALID BETWEEN 2005.0 AND 2010.0. THE
    C             COMPUTED MAGNETIC PARAMETERS ARE REFERENCED TO THE
    C             WGS-84 ELLIPSOID.
    C
    C***********************************************************************
    C
    C     ACCURACY:  IN OCEAN AREAS AT THE EARTH'S SURFACE OVER THE
    C                ENTIRE 5 YEAR LIFE OF THE DEGREE AND ORDER 12
    C                SPHERICAL HARMONIC MODEL WMM-2005, THE ESTIMATED
    C                MAXIMUM RMS ERRORS FOR THE VARIOUS MAGNETIC COMPONENTS
    C                ARE:
    C
    C                DEC  -   0.5 Degrees
    C                DIP  -   0.5 Degrees
    C                TI   - 280.0 nanoTeslas (nT)
    C                GV   -   0.5 Degrees
    C
    C                OTHER MAGNETIC COMPONENTS THAT CAN BE DERIVED FROM
    C                THESE FOUR BY SIMPLE TRIGONOMETRIC RELATIONS WILL
    C                HAVE THE FOLLOWING APPROXIMATE ERRORS OVER OCEAN AREAS:
    C
    C                X    - 140 nT (North)
    C                Y    - 140 nT (East)
    C                Z    - 200 nT (Vertical) Positive is down
    C                H    - 200 nT (Horizontal)
    C
    C                OVER LAND THE MAXIMUM RMS ERRORS ARE EXPECTED TO BE
    C                HIGHER, ALTHOUGH THE RMS ERRORS FOR DEC, DIP, AND GV
    C                ARE STILL ESTIMATED TO BE LESS THAN 1.0 DEGREE, FOR
    C                THE ENTIRE 5-YEAR LIFE OF THE MODEL AT THE EARTH's
    C                SURFACE.  THE OTHER COMPONENT ERRORS OVER LAND ARE
    C                MORE DIFFICULT TO ESTIMATE AND SO ARE NOT GIVEN.
    C
    C                THE ACCURACY AT ANY GIVEN TIME FOR ALL OF THESE
    C                GEOMAGNETIC PARAMETERS DEPENDS ON THE GEOMAGNETIC
    C                LATITUDE.  THE ERRORS ARE LEAST FROM THE EQUATOR TO
    C                MID-LATITUDES AND GREATEST NEAR THE MAGNETIC POLES.
    C
    C                IT IS VERY IMPORTANT TO NOTE THAT A DEGREE AND
    C                ORDER 12 MODEL, SUCH AS WMM-2005, DESCRIBES ONLY
    C                THE LONG WAVELENGTH SPATIAL MAGNETIC FLUCTUATIONS
    C                DUE TO EARTH'S CORE.  NOT INCLUDED IN THE WMM SERIES
    C                MODELS ARE INTERMEDIATE AND SHORT WAVELENGTH
    C                SPATIAL FLUCTUATIONS OF THE GEOMAGNETIC FIELD
    C                WHICH ORIGINATE IN THE EARTH'S MANTLE AND CRUST.
    C                CONSEQUENTLY, ISOLATED ANGULAR ERRORS AT VARIOUS
    C                POSITIONS ON THE SURFACE (PRIMARILY OVER LAND, IN
    C                CONTINENTAL MARGINS AND OVER OCEANIC SEAMOUNTS,
    C                RIDGES AND TRENCHES) OF SEVERAL DEGREES MAY BE
    C                EXPECTED. ALSO NOT INCLUDED IN THE MODEL ARE
    C                NONSECULAR TEMPORAL FLUCTUATIONS OF THE GEOMAGNETIC
    C                FIELD OF MAGNETOSPHERIC AND IONOSPHERIC ORIGIN.
    C                DURING MAGNETIC STORMS, TEMPORAL FLUCTUATIONS CAN
    C                CAUSE SUBSTANTIAL DEVIATIONS OF THE GEOMAGNETIC
    C                FIELD FROM MODEL VALUES.  IN ARCTIC AND ANTARCTIC
    C                REGIONS, AS WELL AS IN EQUATORIAL REGIONS, DEVIATIONS
    C                FROM MODEL VALUES ARE BOTH FREQUENT AND PERSISTENT.
    C
    C                IF THE REQUIRED DECLINATION ACCURACY IS MORE
    C                STRINGENT THAN THE WMM SERIES OF MODELS PROVIDE, THEN
    C                THE USER IS ADVISED TO REQUEST SPECIAL (REGIONAL OR
    C                LOCAL) SURVEYS BE PERFORMED AND MODELS PREPARED.
    C                REQUESTS OF THIS NATURE SHOULD BE MADE TO NIMA
    C                AT THE ADDRESS ABOVE.
    C
    C***********************************************************************
    C
    C     USAGE:  THIS ROUTINE IS BROKEN UP INTO TWO PARTS:
    C
    C             A) AN INITIALIZATION MODULE, WHICH IS CALLED ONLY
    C                ONCE AT THE BEGINNING OF THE MAIN (CALLING)
    C                PROGRAM
    C             B) A PROCESSING MODULE, WHICH COMPUTES THE MAGNETIC
    C                FIELD PARAMETERS FOR EACH SPECIFIED GEODETIC
    C                POSITION (ALTITUDE, LATITUDE, LONGITUDE) AND TIME
    C
    C             INITIALIZATION IS MADE VIA A SINGLE CALL TO THE MAIN
    C             ENTRY POINT (GEOMAG), WHILE SUBSEQUENT PROCESSING
    C             CALLS ARE MADE THROUGH THE SECOND ENTRY POINT (GEOMG1).
    C             ONE CALL TO THE PROCESSING MODULE IS REQUIRED FOR EACH
    C             POSITION AND TIME.
    C
    C             THE VARIABLE MAXDEG IN THE INITIALIZATION CALL IS THE
    C             MAXIMUM DEGREE TO WHICH THE SPHERICAL HARMONIC MODEL
    C             IS TO BE COMPUTED.  IT MUST BE SPECIFIED BY THE USER
    C             IN THE CALLING ROUTINE.  NORMALLY IT IS 12 BUT IT MAY
    C             BE SET LESS THAN 12 TO INCREASE COMPUTATIONAL SPEED AT
    C             THE EXPENSE OF REDUCED ACCURACY.
    C
    C             THE PC VERSION OF THIS SUBROUTINE MUST BE COMPILED
    C             WITH A FORTRAN 77 COMPATIBLE COMPILER SUCH AS THE
    C             MICROSOFT OPTIMIZING FORTRAN COMPILER VERSION 4.1
    C             OR LATER.
    C
    C**********************************************************************
    C
    C     REFERENCES:
    C
    C       JOHN M. QUINN, DAVID J. KERRIDGE AND DAVID R. BARRACLOUGH,
    C            WORLD MAGNETIC CHARTS FOR 1985 - SPHERICAL HARMONIC
    C            MODELS OF THE GEOMAGNETIC FIELD AND ITS SECULAR
    C            VARIATION, GEOPHYS. J. R. ASTR. SOC. (1986) 87,
    C            PP 1143-1157
    C
    C       DEFENSE MAPPING AGENCY TECHNICAL REPORT, TR 8350.2:
    C            DEPARTMENT OF DEFENSE WORLD GEODETIC SYSTEM 1984,
    C            SEPT. 30 (1987)
    C
    C       JOHN M. QUINN, RACHEL J. COLEMAN, MICHAEL R. PECK, AND
    C            STEPHEN E. LAUBER; THE JOINT US/UK 1990 EPOCH
    C            WORLD MAGNETIC MODEL, TECHNICAL REPORT NO. 304,
    C            NAVAL OCEANOGRAPHIC OFFICE (1991)
    C
    C       JOHN M. QUINN, RACHEL J. COLEMAN, DONALD L. SHIEL, AND
    C            JOHN M. NIGRO; THE JOINT US/UK 1995 EPOCH WORLD
    C            MAGNETIC MODEL, TECHNICAL REPORT NO. 314, NAVAL
    C            OCEANOGRAPHIC OFFICE (1995)
    C
    C            SUSAN AMCMILLAN, DAVID R. BARRACLOUGH, JOHN M. QUINN, AND
    C            RACHEL J. COLEMAN;  THE 1995 REVISION OF THE JOINT US/UK
    C            GEOMAGNETIC FIELD MODELS - I. SECULAR VARIATION, JOURNAL OF
    C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 229-243
    C            (1997)
    C
    C            JOHN M. QUINN, RACHEL J. COELMAN, SUSAM MACMILLAN, AND
    C            DAVID R. BARRACLOUGH;  THE 1995 REVISION OF THE JOINT
    C            US/UK GEOMAGNETIC FIELD MODELS: II. MAIN FIELD,JOURNAL OF
    C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 245 - 261
    C            (1997)
    C
    C***********************************************************************
    C
    C     PARAMETER DESCRIPTIONS:
    C
    C       A      - SEMIMAJOR AXIS OF WGS-84 ELLIPSOID (KM)
    C       B      - SEMIMINOR AXIS OF WGS-84 ELLIPSOID (KM)
    C       RE     - MEAN RADIUS OF IAU-66 ELLIPSOID (KM)
    C       SNORM  - SCHMIDT NORMALIZATION FACTORS
    C       C      - GAUSS COEFFICIENTS OF MAIN GEOMAGNETIC MODEL (NT)
    C       CD     - GAUSS COEFFICIENTS OF SECULAR GEOMAGNETIC MODEL (NT/YR)
    C       TC     - TIME ADJUSTED GEOMAGNETIC GAUSS COEFFICIENTS (NT)
    C       OTIME  - TIME ON PREVIOUS CALL TO GEOMAG (YRS)
    C       OALT   - GEODETIC ALTITUDE ON PREVIOUS CALL TO GEOMAG (YRS)
    C       OLAT   - GEODETIC LATITUDE ON PREVIOUS CALL TO GEOMAG (DEG.)
    C       TIME   - COMPUTATION TIME (YRS)                        (INPUT)
    C                (EG. 1 JULY 1995 = 1995.500)
    C       ALT    - GEODETIC ALTITUDE (KM)                        (INPUT)
    C       GLAT   - GEODETIC LATITUDE (DEG.)                      (INPUT)
    C       GLON   - GEODETIC LONGITUDE (DEG.)                     (INPUT)
    C       EPOCH  - BASE TIME OF GEOMAGNETIC MODEL (YRS)
    C       DTR    - DEGREE TO RADIAN CONVERSION
    C       SP(M)  - SINE OF (M*SPHERICAL COORD. LONGITUDE)
    C       CP(M)  - COSINE OF (M*SPHERICAL COORD. LONGITUDE)
    C       ST     - SINE OF (SPHERICAL COORD. LATITUDE)
    C       CT     - COSINE OF (SPHERICAL COORD. LATITUDE)
    C       R      - SPHERICAL COORDINATE RADIAL POSITION (KM)
    C       CA     - COSINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
    C       SA     - SINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
    C       BR     - RADIAL COMPONENT OF GEOMAGNETIC FIELD (NT)
    C       BT     - THETA COMPONENT OF GEOMAGNETIC FIELD (NT)
    C       BP     - PHI COMPONENT OF GEOMAGNETIC FIELD (NT)
    C       P(N,M) - ASSOCIATED LEGENDRE POLYNOMIALS (UNNORMALIZED)
    C       PP(N)  - ASSOCIATED LEGENDRE POLYNOMIALS FOR M=1 (UNNORMALIZED)
    C       DP(N,M)- THETA DERIVATIVE OF P(N,M) (UNNORMALIZED)
    C       BX     - NORTH GEOMAGNETIC COMPONENT (NT)
    C       BY     - EAST GEOMAGNETIC COMPONENT (NT)
    C       BZ     - VERTICALLY DOWN GEOMAGNETIC COMPONENT (NT)
    C       BH     - HORIZONTAL GEOMAGNETIC COMPONENT (NT)
    C       DEC    - GEOMAGNETIC DECLINATION (DEG.)                (OUTPUT)
    C                  EAST=POSITIVE ANGLES
    C                  WEST=NEGATIVE ANGLES
    C       DIP    - GEOMAGNETIC INCLINATION (DEG.)                (OUTPUT)
    C                  DOWN=POSITIVE ANGLES
    C                    UP=NEGATIVE ANGLES
    C       TI     - GEOMAGNETIC TOTAL INTENSITY (NT)              (OUTPUT)
    C       GV     - GEOMAGNETIC GRID VARIATION (DEG.)             (OUTPUT)
    C                REFERENCED TO GRID NORTH
    C                GRID NORTH REFERENCED TO 0 MERIDIAN
    C                OF A POLAR STEREOGRAPHIC PROJECTION
    C                (ARCTIC/ANTARCTIC ONLY)
    C       MAXDEG - MAXIMUM DEGREE OF SPHERICAL HARMONIC MODEL    (INPUT)
    C       MOXORD - MAXIMUM ORDER OF SPHERICAL HARMONIC MODEL
    C
    C***********************************************************************
    C
    C     NOTE:  THIS VERSION OF GEOMAG USES A WMM SERIES GEOMAGNETIC
    C            FIELS MODEL REFERENCED TO THE WGS-84 GRAVITY MODEL
    C            ELLIPSOID
    C

    */

  /** A class for geographical mathematics. */
  class GeoMath {
    /**
     * Gets coordinates at a relative bearing and distance from a set of coordinates.
     * @param course The course, in degrees, from the reference coordinates.
     * @param distanceInNM The distance, in nautical miles, from the reference coordinates.
     * @param referenceCoordinates The reference coordinates to calculate from.
     * @returns The calculated coordinates.
     */
    static relativeBearingDistanceToCoords(course, distanceInNM, referenceCoordinates) {
      const courseRadians = course * Avionics.Utils.DEG2RAD;
      const distanceRadians = Math.PI / (180 * 60) * distanceInNM;
      const refLat = referenceCoordinates.lat * Avionics.Utils.DEG2RAD;
      const refLon = -(referenceCoordinates.long * Avionics.Utils.DEG2RAD);
      const lat = Math.asin(Math.sin(refLat) * Math.cos(distanceRadians) + Math.cos(refLat) * Math.sin(distanceRadians) * Math.cos(courseRadians));
      const dlon = Math.atan2(Math.sin(courseRadians) * Math.sin(distanceRadians) * Math.cos(refLat), Math.cos(distanceRadians) - Math.sin(refLat) * Math.sin(lat));
      const lon = Avionics.Utils.fmod(refLon - dlon + Math.PI, 2 * Math.PI) - Math.PI;
      return new LatLongAlt(lat * Avionics.Utils.RAD2DEG, -(lon * Avionics.Utils.RAD2DEG));
    }

    /**
     * Gets a magnetic heading given a true course and a magnetic variation.
     * @param trueCourse The true course to correct.
     * @param magneticVariation The measured magnetic variation.
     * @returns The magnetic heading, corrected for magnetic variation.
     */
    static correctMagvar(trueCourse, magneticVariation) {
      return trueCourse - GeoMath.normalizeMagVar(magneticVariation);
    }

    /**
     * Gets a true course given a magnetic heading and a magnetic variation.
     * @param headingMagnetic The magnetic heading to correct.
     * @param magneticVariation The measured magnetic variation.
     * @returns The true course, corrected for magnetic variation.
     */
    static removeMagvar(headingMagnetic, magneticVariation) {
      return headingMagnetic + GeoMath.normalizeMagVar(magneticVariation);
    }

    /**
     * Gets a magnetic variation difference in 0-360 degrees.
     * @param magneticVariation The magnetic variation to normalize.
     * @returns A normalized magnetic variation.
     */
    static normalizeMagVar(magneticVariation) {
      let normalizedMagVar;
      if (magneticVariation <= 180) {
        normalizedMagVar = magneticVariation;
      } else {
        normalizedMagVar = magneticVariation - 360;
      }
      return normalizedMagVar;
    }

    /**
     * Gets the magnetic variation for a given latitude and longitude.
     * @param lat The latitude to get a magvar for.
     * @param lon The longitude to get a magvar for.
     * @returns The magnetic variation at the specific latitude and longitude.
     */
    static getMagvar(lat, lon) {
      return GeoMath.magneticModel.declination(0, lat, lon, 2020);
    }
    static directedDistanceToGo(from, to, acDirectedLineBearing) {
      const absDtg = Avionics.Utils.computeGreatCircleDistance(from, to);

      // @todo should be abeam distance
      if (acDirectedLineBearing >= 90 && acDirectedLineBearing <= 270) {
        // Since a line perpendicular to the leg is formed by two 90 degree angles, an aircraftLegBearing outside
        // (North - 90) and (North + 90) is in the lower quadrants of a plane centered at the TO fix. This means
        // the aircraft is NOT past the TO fix, and DTG must be positive.

        return absDtg;
      }
      return -absDtg;
    }
  }
  _defineProperty(GeoMath, "magneticModel", new WorldMagneticModel());

  /**
   * A class for mapping raw facility data to WayPoints.
   */
  class RawDataMapper {
    /**
     * Maps a raw facility record to a WayPoint.
     * @param facility The facility record to map.
     * @param instrument The instrument to attach to the WayPoint.
     * @returns The mapped waypoint.
     */
    static toWaypoint(facility, instrument) {
      const waypoint = new WayPoint(instrument);
      waypoint.ident = WayPoint.formatIdentFromIcao(facility.icao);
      waypoint.icao = facility.icao;
      waypoint.type = facility.icao[0];
      let alt = 0;
      switch (waypoint.type) {
        case 'A':
          {
            const info = new AirportInfo(instrument);
            info.CopyBaseInfosFrom(waypoint);
            info.UpdateNamedFrequencies();
            alt = 3.28084 * facility.runways.reduce((sum, r) => sum + r.elevation, 0) / facility.runways.length;
            info.elevation = alt;
            info.approaches = facility.approaches;
            info.approaches.forEach(approach => {
              approach.name = ApproachUtils.shortApproachName(approach);
              approach.longName = ApproachUtils.longApproachName(approach);
            });
            info.approaches.forEach(approach => {
              approach.transitions.forEach(trans => {
                // if the trans name is empty (in some 3pd navdata), fill it with the IAF name
                if (trans.name.trim().length === 0) {
                  trans.name = WayPoint.formatIdentFromIcao(trans.legs[0].fixIcao);
                }

                // Fix up navigraph approach transitions which hide IAPs inside other transitions rather
                // than splitting them out as they should be in MSFS data. Unfortunately this means
                // these transitions cannot be synced to the sim's flight plan system for ATC etc. as
                // they're not visible without this hack.
                // Note: it is safe to append to the array inside the forEach by the ECMA spec, and the appended
                // elements will not be visited.
                for (let i = 1; i < trans.legs.length; i++) {
                  const leg = trans.legs[i];
                  if ((leg.fixTypeFlags & FixTypeFlags$1.IAF) > 0 && (leg.type === LegType$1.TF || leg.type === LegType$1.IF)) {
                    const iafIdent = WayPoint.formatIdentFromIcao(leg.fixIcao);
                    // this is a transition in itself... check that it doesn't already exist
                    if (approach.transitions.find(t => t.name === iafIdent) !== undefined) {
                      continue;
                    }
                    RawDataMapper.addApproachTransition(approach, iafIdent, trans.legs.slice(i));
                  }
                }
              });
              // It may be tempting to think we can sort the transitions in alphabetical order after appending new ones,
              // but this would break MSFS flight plan syncing even for transitions that do exist before; the MSFS
              // flight plan system is based on the indices of the transitions in this array.

              // fake RNPs for AR/SAAR procs
              const isRnpAr = approach.runwayNumber !== 0 && approach.rnavTypeFlags === 0;
              if (isRnpAr) {
                RawDataMapper.addRnpIfRfPresent(approach.finalLegs, true);
                approach.transitions.forEach(t => RawDataMapper.addRnpIfRfPresent(t.legs));
              }
            });
            info.approaches.forEach(approach => approach.runway = approach.runway.trim());
            info.departures = facility.departures;
            info.departures.forEach(departure => {
              // patch up transition names
              departure.runwayTransitions.forEach(trans => trans.name = RawDataMapper.generateRunwayTransitionName(trans));
              departure.enRouteTransitions.forEach(trans => trans.name.trim().length === 0 && (trans.name = RawDataMapper.generateDepartureEnRouteTransitionName(trans)));

              // fake RNPs for AR/SAAR procs
              RawDataMapper.addRnpIfRfPresent(departure.commonLegs);
              departure.enRouteTransitions.forEach(t => RawDataMapper.addRnpIfRfPresent(t.legs));
              departure.runwayTransitions.forEach(t => RawDataMapper.addRnpIfRfPresent(t.legs));
            });
            info.arrivals = facility.arrivals;
            info.arrivals.forEach(arrival => arrival.runwayTransitions.forEach(trans => trans.name = RawDataMapper.generateRunwayTransitionName(trans)));
            info.arrivals.forEach(arrival => arrival.enRouteTransitions.forEach(trans => trans.name.trim().length === 0 && (trans.name = RawDataMapper.generateArrivalTransitionName(trans))));
            info.runways = facility.runways;
            info.oneWayRunways = [];
            facility.runways.forEach(runway => info.oneWayRunways.push(...Object.assign(new Runway(), runway).splitIfTwoWays()));
            info.oneWayRunways.sort(RawDataMapper.sortRunways);
            waypoint.infos = info;
          }
          break;
        case 'V':
          const vorInfo = new VORInfo(instrument);
          waypoint.infos = vorInfo;
          vorInfo.frequencyMHz = facility.freqMHz;
          vorInfo.frequencyBcd16 = facility.freqBCD16;
          vorInfo.magneticVariation = facility.magneticVariation;
          vorInfo.type = facility.type;
          vorInfo.vorClass = facility.vorClass;
          break;
        case 'N':
          const ndbInfo = new NDBInfo(instrument);
          waypoint.infos = ndbInfo;
          ndbInfo.type = facility.type;
          ndbInfo.frequencyMHz = facility.freqMHz;
          break;
        case 'W':
          waypoint.infos = new IntersectionInfo(instrument);
          break;
        case 'R':
        default:
          waypoint.infos = new WayPointInfo(instrument);
          break;
      }
      if (waypoint.type !== 'A') {
        waypoint.infos.CopyBaseInfosFrom(waypoint);
        waypoint.infos.routes = facility.routes;
      }
      waypoint.infos.coordinates = new LatLongAlt(facility.lat, facility.lon, alt);
      waypoint.additionalData = {
        facility
      };
      return waypoint;
    }

    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
      if (parseInt(r1.designation) === parseInt(r2.designation)) {
        let v1 = 0;
        if (r1.designation.indexOf('L') !== -1) {
          v1 = 1;
        } else if (r1.designation.indexOf('C') !== -1) {
          v1 = 2;
        } else if (r1.designation.indexOf('R') !== -1) {
          v1 = 3;
        }
        let v2 = 0;
        if (r2.designation.indexOf('L') !== -1) {
          v2 = 1;
        } else if (r2.designation.indexOf('C') !== -1) {
          v2 = 2;
        } else if (r2.designation.indexOf('R') !== -1) {
          v2 = 3;
        }
        return v1 - v2;
      }
      return parseInt(r1.designation) - parseInt(r2.designation);
    }

    /**
     * Generates a runway transition name from the designated runway in the transition data.
     * @param runwayTransition The runway transition to generate the name for.
     * @returns The runway transition name.
     */
    static generateRunwayTransitionName(runwayTransition) {
      let name = "RW".concat(runwayTransition.runwayNumber);
      switch (runwayTransition.runwayDesignation) {
        case 1:
          name += 'L';
          break;
        case 2:
          name += 'R';
          break;
        case 3:
          name += 'C';
          break;
      }
      return name;
    }

    /**
     * Generates an arrival transition name from a provided arrival enroute transition.
     * @param enrouteTransition The enroute transition to generate a name for.
     * @returns The generated transition name.
     */
    static generateArrivalTransitionName(enrouteTransition) {
      return WayPoint.formatIdentFromIcao(enrouteTransition.legs[0].fixIcao);
    }

    /**
     * Generates a departure transition name from a provided departure enroute transition.
     * @param enrouteTransition The enroute transition to generate a name for.
     * @returns The generated transition name.
     */
    static generateDepartureEnRouteTransitionName(enrouteTransition) {
      return WayPoint.formatIdentFromIcao(enrouteTransition.legs[enrouteTransition.legs.length - 1].fixIcao);
    }

    /** Create an approach transition from a list of legs starting with the IAF and add it to the approach */
    static addApproachTransition(approach, name, legs) {
      // copy the IAF leg before we mutate it!
      legs[0] = _objectSpread2({}, legs[0]);
      legs[0].type = LegType$1.IF;
      approach.transitions.push({
        name,
        legs,
        __Type: 'JS_ApproachTransition'
      });
    }

    /** Add an RNP of 0.3 if the set of legs contains an RF leg */
    static addRnpIfRfPresent(legs) {
      let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      const hasAr = legs.findIndex(l => l.type === LegType$1.RF) >= 0;
      if (hasAr || force) {
        legs.forEach(l => l.rnp = 0.3);
      }
    }
  }

  /**
   * Creates a collection of waypoints from a legs procedure.
   */
  class LegsProcedure {
    /**
     * Creates an instance of a LegsProcedure.
     * @param legs The legs that are part of the procedure.
     * @param startingPoint The starting point for the procedure.
     * @param instrument The instrument that is attached to the flight plan.
     * @param approachType The approach type if this is an approach procedure
     */
    constructor(_legs, _previousFix, _instrument, airportMagVar, approachType, legAnnotations) {
      this._legs = _legs;
      this._previousFix = _previousFix;
      this._instrument = _instrument;
      this.airportMagVar = airportMagVar;
      this.approachType = approachType;
      this.legAnnotations = legAnnotations;
      /** The current index in the procedure. */
      _defineProperty(this, "_currentIndex", 0);
      /** Whether or not there is a discontinuity pending to be mapped. */
      _defineProperty(this, "_isDiscontinuityPending", false);
      /** A collection of the loaded facilities needed for this procedure. */
      _defineProperty(this, "_facilities", new Map());
      /** Whether or not the facilities have completed loading. */
      _defineProperty(this, "_facilitiesLoaded", false);
      /** The collection of facility promises to await on first load. */
      _defineProperty(this, "_facilitiesToLoad", new Map());
      /** Whether or not a non initial-fix procedure start has been added to the procedure. */
      _defineProperty(this, "_addedProcedureStart", false);
      /** A collection of filtering rules for filtering ICAO data to pre-load for the procedure. */
      _defineProperty(this, "legFilteringRules", [icao => icao.trim() !== '',
      // Icao is not empty
      icao => icao[0] !== 'R',
      // Icao is not runway icao, which is not searchable
      icao => icao[0] !== 'A',
      // Icao is not airport icao, which can be skipped
      icao => !this._facilitiesToLoad.has(icao) // Icao is not already being loaded
      ]);

      for (const leg of this._legs) {
        if (this.isIcaoValid(leg.fixIcao)) {
          this._facilitiesToLoad.set(leg.fixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.fixIcao, 2000, true));
        }
        if (this.isIcaoValid(leg.originIcao)) {
          this._facilitiesToLoad.set(leg.originIcao, this._instrument.facilityLoader.getFacilityRaw(leg.originIcao, 2000, true));
        }
        if (this.isIcaoValid(leg.arcCenterFixIcao)) {
          this._facilitiesToLoad.set(leg.arcCenterFixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.arcCenterFixIcao, 2000, true));
        }
      }
    }

    /**
     * Checks whether or not there are any legs remaining in the procedure.
     * @returns True if there is a next leg, false otherwise.
     */
    hasNext() {
      return this._currentIndex < this._legs.length || this._isDiscontinuityPending;
    }
    async ensureFacilitiesLoaded() {
      if (!this._facilitiesLoaded) {
        const facilityResults = await Promise.all(this._facilitiesToLoad.values());
        for (const facility of facilityResults.filter(f => f !== undefined)) {
          this._facilities.set(facility.icao, facility);
        }
        this._facilitiesLoaded = true;
      }
    }

    /**
     * Gets the next mapped leg from the procedure.
     * @returns The mapped waypoint from the leg of the procedure.
     */
    async getNext() {
      let isLegMappable = false;
      let mappedLeg;
      await this.ensureFacilitiesLoaded();
      while (!isLegMappable && this._currentIndex < this._legs.length) {
        const currentLeg = this._legs[this._currentIndex];
        const currentAnnotation = this.legAnnotations[this._currentIndex];
        isLegMappable = true;

        // Some procedures don't start with 15 (initial fix) but instead start with a heading and distance from
        // a fix: the procedure then starts with the fix exactly
        if (this._currentIndex === 0 && currentLeg.type === 10 && !this._addedProcedureStart) {
          mappedLeg = this.mapExactFix(currentLeg);
          this._addedProcedureStart = true;
        } else {
          try {
            switch (currentLeg.type) {
              case LegType$1.AF:
              case LegType$1.PI:
                mappedLeg = this.mapExactFix(currentLeg);
                break;
              case LegType$1.CD:
              case LegType$1.VD:
                mappedLeg = this.mapHeadingUntilDistanceFromOrigin(currentLeg, this._previousFix);
                break;
              case LegType$1.CF:
                // Only map if the fix is itself not a runway fix to avoid double
                // adding runway fixes
                if (currentLeg.fixIcao === '' || currentLeg.fixIcao[0] !== 'R') {
                  mappedLeg = this.mapOriginRadialForDistance(currentLeg, this._previousFix);
                } else {
                  isLegMappable = false;
                }
                break;
              case LegType$1.CI:
              case LegType$1.VI:
                mappedLeg = this.mapHeadingToInterceptNextLeg(currentLeg, this._previousFix, this._legs[this._currentIndex + 1]);
                break;
              case LegType$1.CR:
              case LegType$1.VR:
                mappedLeg = this.mapHeadingUntilRadialCrossing(currentLeg, this._previousFix);
                break;
              case LegType$1.FC:
              case LegType$1.FD:
                mappedLeg = this.mapBearingAndDistanceFromOrigin(currentLeg);
                break;
              case LegType$1.FM:
              case LegType$1.VM:
                mappedLeg = this.mapVectors(currentLeg, this._previousFix);
                break;
              case LegType$1.IF:
                if (currentLeg.fixIcao[0] !== 'A' && currentLeg.fixIcao[0] !== 'R') {
                  const leg = this.mapExactFix(currentLeg);
                  const prevLeg = this._previousFix;

                  // If a type 15 (initial fix) comes up in the middle of a plan
                  if (leg.icao === prevLeg.icao && leg.infos.coordinates.lat === prevLeg.infos.coordinates.lat && leg.infos.coordinates.long === prevLeg.infos.coordinates.long) {
                    isLegMappable = false;
                  } else {
                    mappedLeg = leg;
                  }
                } else {
                  // If type 15 is an airport itself, we don't need to map it (and the data is generally wrong)
                  isLegMappable = false;
                }
                break;
              case LegType$1.DF:
              case LegType$1.TF:
                // Only map if the fix is itself not a runway fix to avoid double
                // adding runway fixes
                if (currentLeg.fixIcao === '' || currentLeg.fixIcao[0] !== 'R') {
                  mappedLeg = this.mapExactFix(currentLeg);
                } else {
                  isLegMappable = false;
                }
                break;
              case LegType$1.RF:
                mappedLeg = this.mapRadiusToFix(currentLeg);
                break;
              case LegType$1.CA:
              case LegType$1.VA:
                mappedLeg = this.mapHeadingUntilAltitude(currentLeg, this._previousFix);
                break;
              case LegType$1.HA:
              case LegType$1.HF:
              case LegType$1.HM:
                mappedLeg = this.mapHold(currentLeg);
                break;
              default:
                isLegMappable = false;
                break;
            }
          } catch (err) {
            console.log("LegsProcedure: Unexpected unmappable leg: ".concat(err));
          }
          if (mappedLeg !== undefined) {
            const magCorrection = this.getMagCorrection(currentLeg);
            if (this.approachType === ApproachType.APPROACH_TYPE_ILS && (currentLeg.fixTypeFlags & FixTypeFlags$1.FAF) > 0) {
              if (currentLeg.altDesc === AltitudeDescriptor.At) {
                mappedLeg.legAltitudeDescription = AltitudeDescriptor.G;
              } else {
                mappedLeg.legAltitudeDescription = AltitudeDescriptor.H;
              }
            } else {
              mappedLeg.legAltitudeDescription = currentLeg.altDesc;
            }
            mappedLeg.legAltitude1 = currentLeg.altitude1 * 3.28084;
            mappedLeg.legAltitude2 = currentLeg.altitude2 * 3.28084;
            mappedLeg.speedConstraint = currentLeg.speedRestriction;
            mappedLeg.turnDirection = currentLeg.turnDirection;
            const recNavaid = this._facilities.get(currentLeg.originIcao);
            mappedLeg.additionalData.legType = currentLeg.type;
            mappedLeg.additionalData.overfly = currentLeg.flyOver;
            mappedLeg.additionalData.fixTypeFlags = currentLeg.fixTypeFlags;
            mappedLeg.additionalData.distance = currentLeg.distanceMinutes ? undefined : currentLeg.distance / 1852;
            mappedLeg.additionalData.distanceInMinutes = currentLeg.distanceMinutes ? currentLeg.distance : undefined;
            mappedLeg.additionalData.course = currentLeg.trueDegrees ? currentLeg.course : A32NX_Util.magneticToTrue(currentLeg.course, magCorrection);
            mappedLeg.additionalData.recommendedIcao = currentLeg.originIcao.trim().length > 0 ? currentLeg.originIcao : undefined;
            mappedLeg.additionalData.recommendedFrequency = recNavaid ? recNavaid.freqMHz : undefined;
            mappedLeg.additionalData.recommendedLocation = recNavaid ? {
              lat: recNavaid.lat,
              long: recNavaid.lon
            } : undefined;
            mappedLeg.additionalData.recommendedFacility = recNavaid !== null && recNavaid !== void 0 ? recNavaid : null;
            mappedLeg.additionalData.rho = currentLeg.rho / 1852;
            mappedLeg.additionalData.theta = currentLeg.theta;
            mappedLeg.additionalData.thetaTrue = A32NX_Util.magneticToTrue(currentLeg.theta, magCorrection);
            mappedLeg.additionalData.annotation = currentAnnotation;
            mappedLeg.additionalData.verticalAngle = currentLeg.verticalAngle ? currentLeg.verticalAngle - 360 : undefined;
            mappedLeg.additionalData.rnp = currentLeg.rnp;
          }
          this._currentIndex++;
        }
      }
      if (mappedLeg !== undefined) {
        this._previousFix = mappedLeg;
        return mappedLeg;
      }
      return undefined;
    }
    getMagCorrection(currentLeg) {
      // we try to interpret PANS OPs as accurately as possible within the limits of available data

      // magnetic tracks to/from a VOR always use VOR station declination
      if (currentLeg.fixIcao.charAt(0) === 'V') {
        const vor = this.getLoadedFacility(currentLeg.fixIcao);
        if (!vor || vor.magneticVariation === undefined) {
          console.warn('Leg coded incorrectly (missing vor fix or station declination)', currentLeg, vor);
          return this.airportMagVar;
        }
        return 360 - vor.magneticVariation;
      }

      // we use station declination for VOR/DME approaches
      if (this.approachType === ApproachType.APPROACH_TYPE_VORDME) {
        // find a leg with the reference navaid for the procedure
        for (let i = this._legs.length - 1; i >= 0; i--) {
          if (this._legs[i].originIcao.trim().length > 0) {
            const recNavaid = this.getLoadedFacility(this._legs[i].originIcao);
            if (recNavaid && recNavaid.magneticVariation !== undefined) {
              return 360 - recNavaid.magneticVariation;
            }
          }
        }
        console.warn('VOR/DME approach coded incorrectly (missing recommended navaid or station declination)', currentLeg);
        return this.airportMagVar;
      }

      // for RNAV procedures use recommended navaid station declination for these leg types
      let useStationDeclination = currentLeg.type === LegType$1.CF || currentLeg.type === LegType$1.FA || currentLeg.type === LegType$1.FM;

      // for localiser bearings (i.e. at or beyond FACF), always use airport value
      if (this.approachType === ApproachType.APPROACH_TYPE_ILS || this.approachType === ApproachType.APPROACH_TYPE_LOCALIZER) {
        useStationDeclination = useStationDeclination && this._legs.indexOf(currentLeg) < this.getFacfIndex();
      }
      if (useStationDeclination) {
        const recNavaid = this.getLoadedFacility(currentLeg.originIcao);
        if (!recNavaid || recNavaid.magneticVariation === undefined) {
          console.warn('Leg coded incorrectly (missing recommended navaid or station declination)', currentLeg, recNavaid);
          return this.airportMagVar;
        }
        return 360 - recNavaid.magneticVariation;
      }

      // for all other terminal procedure legs we use airport magnetic variation
      return this.airportMagVar;
    }
    getLoadedFacility(icao) {
      const facility = this._facilities.get(icao);
      if (!facility) {
        throw new Error("Failed to load facility: ".concat(icao));
      }
      return facility;
    }
    getFacfIndex() {
      if (this.approachType !== undefined) {
        for (let i = this._legs.length - 1; i >= 0; i--) {
          if (this._legs[i].fixTypeFlags & FixTypeFlags$1.IF) {
            return i;
          }
        }
      }
      return undefined;
    }

    /**
     * Maps a heading until distance from origin leg.
     * @param leg The procedure leg to map.
     * @param prevLeg The previously mapped waypoint in the procedure.
     * @returns The mapped leg.
     */
    mapHeadingUntilDistanceFromOrigin(leg, prevLeg) {
      const origin = this.getLoadedFacility(leg.originIcao);
      const originIdent = origin.icao.substring(7, 12).trim();
      const bearingToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
      const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon)) / LegsProcedure.distanceNormalFactorNM;
      const deltaAngle = this.deltaAngleRadians(bearingToOrigin, leg.course);
      const targetDistance = leg.distance / 1852 / LegsProcedure.distanceNormalFactorNM;
      const distanceAngle = Math.asin(Math.sin(distanceToOrigin) * Math.sin(deltaAngle) / Math.sin(targetDistance));
      const inverseDistanceAngle = Math.PI - distanceAngle;
      const legDistance1 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + distanceAngle)) / Math.sin(0.5 * (deltaAngle - distanceAngle))));
      const legDistance2 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + inverseDistanceAngle)) / Math.sin(0.5 * (deltaAngle - inverseDistanceAngle))));
      const legDistance = targetDistance > distanceToOrigin ? legDistance1 : Math.min(legDistance1, legDistance2);
      const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, legDistance * LegsProcedure.distanceNormalFactorNM, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const waypoint = this.buildWaypoint("".concat(originIdent.substring(0, 3), "/").concat(Math.round(leg.distance / 1852).toString().padStart(2, '0')), coordinates);
      return waypoint;
    }

    /**
     * Maps an FC or FD leg in the procedure.
     * @note FC and FD legs are mapped to CF legs in the real FMS
     * @todo move the code into the CF leg (maybe static functions fromFc and fromFd to construct the leg)
     * @todo FD should overfly the termination... needs a messy refactor to do that
     * @param leg The procedure leg to map.
     * @returns The mapped leg.
     */
    mapBearingAndDistanceFromOrigin(leg) {
      const origin = this.getLoadedFacility(leg.fixIcao);
      const originIdent = origin.icao.substring(7, 12).trim();
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, Facilities.getMagVar(origin.lat, origin.lon));
      // this is the leg length for FC, and the DME distance for FD
      const refDistance = leg.distance / 1852;
      let termPoint;
      let legLength;
      if (leg.type === LegType$1.FD) {
        const recNavaid = this.getLoadedFacility(leg.originIcao);
        termPoint = firstSmallCircleIntersection({
          lat: recNavaid.lat,
          long: recNavaid.lon
        }, refDistance, {
          lat: origin.lat,
          long: origin.lon
        }, course);
        legLength = Avionics.Utils.computeGreatCircleDistance({
          lat: origin.lat,
          long: origin.lon
        }, termPoint);
      } else {
        // FC
        termPoint = Avionics.Utils.bearingDistanceToCoordinates(course, refDistance, origin.lat, origin.lon);
        legLength = refDistance;
      }
      return this.buildWaypoint("".concat(originIdent.substring(0, 3), "/").concat(Math.round(legLength).toString().padStart(2, '0')), termPoint);
    }

    /**
     * Maps a radial on the origin for a specified distance leg in the procedure.
     * @param leg The procedure leg to map.
     * @param prevLeg The previously mapped leg.
     * @returns The mapped leg.
     */
    mapOriginRadialForDistance(leg, prevLeg) {
      if (leg.fixIcao.trim() !== '') {
        return this.mapExactFix(leg);
      }
      const origin = this.getLoadedFacility(leg.originIcao);
      const originIdent = origin.icao.substring(7, 12).trim();
      const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, leg.distance / 1852, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const distanceFromOrigin = Avionics.Utils.computeGreatCircleDistance(new LatLongAlt(origin.lat, origin.lon), coordinates);
      return this.buildWaypoint("".concat(originIdent).concat(Math.trunc(distanceFromOrigin / 1852)), coordinates);
    }

    /**
     * Maps a heading turn to intercept the next leg in the procedure.
     * @param leg The procedure leg to map.
     * @param prevLeg The previously mapped leg.
     * @param nextLeg The next leg in the procedure to intercept.
     * @returns The mapped leg.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mapHeadingToInterceptNextLeg(leg, prevLeg, nextLeg) {
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
      const waypoint = this.buildWaypoint(FixNamingScheme.courseToIntercept(course), coordinates, prevLeg.infos.magneticVariation);
      return waypoint;
    }

    /**
     * Maps flying a heading until crossing a radial of a reference fix.
     * @param leg The procedure leg to map.
     * @param prevLeg The previously mapped leg.
     * @returns The mapped leg.
     */
    mapHeadingUntilRadialCrossing(leg, prevLeg) {
      const origin = this.getLoadedFacility(leg.originIcao);
      const originCoordinates = new LatLongAlt(origin.lat, origin.lon);
      const originToCoordinates = Avionics.Utils.computeGreatCircleHeading(originCoordinates, prevLeg.infos.coordinates);
      const coordinatesToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
      const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, originCoordinates) / LegsProcedure.distanceNormalFactorNM;
      const alpha = this.deltaAngleRadians(coordinatesToOrigin, leg.course);
      const beta = this.deltaAngleRadians(originToCoordinates, leg.theta);
      const gamma = Math.acos(Math.sin(alpha) * Math.sin(beta) * Math.cos(distanceToOrigin) - Math.cos(alpha) * Math.cos(beta));
      const legDistance = Math.acos((Math.cos(beta) + Math.cos(alpha) * Math.cos(gamma)) / (Math.sin(alpha) * Math.sin(gamma)));
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, legDistance * LegsProcedure.distanceNormalFactorNM, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const waypoint = this.buildWaypoint("".concat(this.getIdent(origin.icao)).concat(leg.theta), coordinates);
      return waypoint;
    }

    /**
     * Maps flying a heading until a proscribed altitude.
     * @param leg The procedure leg to map.
     * @param prevLeg The previous leg in the procedure.
     * @returns The mapped leg.
     */
    mapHeadingUntilAltitude(leg, prevLeg) {
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      // const heading = leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course;
      const altitudeFeet = leg.altitude1 * 3.2808399;
      const distanceInNM = altitudeFeet / 500.0;
      const coordinates = GeoMath.relativeBearingDistanceToCoords(course, distanceInNM, prevLeg.infos.coordinates);
      const waypoint = this.buildWaypoint(FixNamingScheme.headingUntilAltitude(altitudeFeet), coordinates, prevLeg.infos.magneticVariation);
      waypoint.additionalData.vectorsAltitude = altitudeFeet;
      return waypoint;
    }

    /**
     * Maps a vectors instruction.
     * @param leg The procedure leg to map.
     * @param prevLeg The previous leg in the procedure.
     * @returns The mapped leg.
     */
    mapVectors(leg, prevLeg) {
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      // const heading = leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course;
      const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
      const waypoint = this.buildWaypoint(FixNamingScheme.vector(), coordinates);
      waypoint.isVectors = true;
      waypoint.endsInDiscontinuity = true;
      waypoint.discontinuityCanBeCleared = false;
      return waypoint;
    }

    /**
     * Maps an exact fix leg in the procedure.
     * @param leg The procedure leg to map.
     * @returns The mapped leg.
     */
    mapExactFix(leg) {
      const facility = this.getLoadedFacility(leg.fixIcao);
      return RawDataMapper.toWaypoint(facility, this._instrument);
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mapArcToFix(leg, prevLeg) {
      const toFix = this.getLoadedFacility(leg.fixIcao);
      const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
      return waypoint;
    }
    mapRadiusToFix(leg) {
      const arcCentreFix = this.getLoadedFacility(leg.arcCenterFixIcao);
      const arcCenterCoordinates = new LatLongAlt(arcCentreFix.lat, arcCentreFix.lon, 0);
      const toFix = this.getLoadedFacility(leg.fixIcao);
      const toCoordinates = new LatLongAlt(toFix.lat, toFix.lon, 0);
      const radius = Avionics.Utils.computeGreatCircleDistance(arcCenterCoordinates, toCoordinates);
      const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
      waypoint.additionalData.radius = radius;
      waypoint.additionalData.center = arcCenterCoordinates;
      return waypoint;
    }
    mapHold(leg) {
      const facility = this.getLoadedFacility(leg.fixIcao);
      const waypoint = RawDataMapper.toWaypoint(facility, this._instrument);
      const magVar = Facilities.getMagVar(facility.lat, facility.lon);
      waypoint.additionalData.defaultHold = {
        inboundMagneticCourse: leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course,
        turnDirection: leg.turnDirection,
        distance: leg.distanceMinutes ? undefined : leg.distance / 1852,
        time: leg.distanceMinutes ? leg.distance : undefined,
        type: HoldType.Database
      };
      waypoint.additionalData.modifiedHold = {};
      return waypoint;
    }

    /**
     * Gets the difference between two headings in zero north normalized radians.
     * @param a The degrees of heading a.
     * @param b The degrees of heading b.
     * @returns The difference between the two headings in zero north normalized radians.
     */
    deltaAngleRadians(a, b) {
      return Math.abs((Avionics.Utils.fmod(a - b + 180, 360) - 180) * Avionics.Utils.DEG2RAD);
    }

    /**
     * Gets an ident from an ICAO.
     * @param icao The icao to pull the ident from.
     * @returns The parsed ident.
     */
    getIdent(icao) {
      return icao.substring(7, 12).trim();
    }

    /**
     * Checks if an ICAO is valid to load.
     * @param icao The icao to check.
     * @returns Whether or not the ICAO is valid.
     */
    isIcaoValid(icao) {
      for (const rule of this.legFilteringRules) {
        if (!rule(icao)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Builds a WayPoint from basic data.
     * @param ident The ident of the waypoint.
     * @param coordinates The coordinates of the waypoint.
     * @param magneticVariation The magnetic variation of the waypoint, if any.
     * @returns The built waypoint.
     */
    buildWaypoint(ident, coordinates, magneticVariation) {
      const waypoint = new WayPoint(this._instrument);
      waypoint.type = 'W';
      waypoint.infos = new IntersectionInfo(this._instrument);
      waypoint.infos.coordinates = coordinates;
      waypoint.infos.magneticVariation = magneticVariation;
      waypoint.ident = ident;
      waypoint.infos.ident = ident;
      waypoint.additionalData = {};
      return waypoint;
    }
  }
  /** A normalization factor for calculating distances from triangular ratios. */
  _defineProperty(LegsProcedure, "distanceNormalFactorNM", 21639 / 2 * Math.PI);

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  /**
   * The details of procedures selected in the flight plan.
   */
  class ProcedureDetails {
    constructor() {
      /** The index of the origin runway in the origin runway information. */
      _defineProperty(this, "originRunwayIndex", -1);
      /** The index of the departure in the origin airport information. */
      _defineProperty(this, "departureIndex", -1);
      /** The index of the departure transition in the origin airport departure information. */
      _defineProperty(this, "departureTransitionIndex", -1);
      /** The index of the selected runway in the original airport departure information. */
      _defineProperty(this, "departureRunwayIndex", -1);
      /** The index of the arrival in the destination airport information. */
      _defineProperty(this, "arrivalIndex", -1);
      /** The index of the arrival transition in the destination airport arrival information. */
      _defineProperty(this, "arrivalTransitionIndex", -1);
      /** The index of the selected runway transition at the destination airport arrival information. */
      _defineProperty(this, "arrivalRunwayIndex", -1);
      /** The index of the apporach in the destination airport information. */
      _defineProperty(this, "approachIndex", -1);
      /** The index of the approach transition in the destination airport approach information. */
      _defineProperty(this, "approachTransitionIndex", -1);
      /** The index of the destination runway in the destination runway information. */
      _defineProperty(this, "destinationRunwayIndex", -1);
      /** The length from the threshold of the runway extension fix. */
      _defineProperty(this, "destinationRunwayExtension", -1);
      /** The type of approach selected */
      _defineProperty(this, "approachType", void 0);
    }
  }

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  /**
   * Creating a new waypoint to be added to a flight plan.
   */
  class WaypointBuilder {
    /**
    * Builds a WayPoint from basic data.
    * @param ident The ident of the waypoint to be created.
    * @param coordinates The coordinates of the waypoint.
    * @param instrument The base instrument instance.
    * @returns The built waypoint.
    */
    static fromCoordinates(ident, coordinates, instrument, additionalData, icao) {
      const waypoint = new WayPoint(instrument);
      waypoint.type = 'W';
      waypoint.infos = new IntersectionInfo(instrument);
      waypoint.infos.coordinates = coordinates;
      waypoint.ident = ident;
      waypoint.infos.ident = ident;
      waypoint.icao = icao !== null && icao !== void 0 ? icao : "W      ".concat(ident);
      waypoint.infos.icao = waypoint.icao;
      waypoint.additionalData = additionalData !== null && additionalData !== void 0 ? additionalData : {};
      return waypoint;
    }

    /**
    * Builds a WayPoint from a refrence waypoint.
    * @param ident The ident of the waypoint to be created.
    * @param placeCoordinates The coordinates of the reference waypoint.
    * @param bearing The bearing from the reference waypoint.
    * @param distance The distance from the reference waypoint.
    * @param instrument The base instrument instance.
    * @returns The built waypoint.
    */
    static fromPlaceBearingDistance(ident, placeCoordinates, bearing, distance, instrument) {
      let magneticBearing = bearing + GeoMath.getMagvar(placeCoordinates.lat, placeCoordinates.long);
      magneticBearing = magneticBearing < 0 ? 360 + magneticBearing : magneticBearing;
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(magneticBearing, distance, placeCoordinates.lat, placeCoordinates.long);
      return WaypointBuilder.fromCoordinates(ident, coordinates, instrument);
    }

    /**
    * Builds a WayPoint at a distance from an existing waypoint along the flight plan.
    * @param ident The ident of the waypoint to be created.
    * @param placeIndex The index of the reference waypoint in the flight plan.
    * @param distance The distance from the reference waypoint.
    * @param instrument The base instrument instance.
    * @param fpm The flightplanmanager instance.
    * @returns The built waypoint.
    */
    static fromPlaceAlongFlightPlan(ident, placeIndex, distance, instrument, fpm) {
      console.log('running fromPlaceAlongFlightPlan');
      console.log("destination? ".concat(fpm.getDestination()) ? 'True' : 'False');
      const destinationDistanceInFlightplan = fpm.getDestination().cumulativeDistanceInFP;
      console.log("destinationDistanceInFlightplan ".concat(destinationDistanceInFlightplan));
      const placeDistanceFromDestination = fpm.getWaypoint(placeIndex, 0, true).cumulativeDistanceInFP;
      console.log("placeDistanceFromDestination ".concat(placeDistanceFromDestination));
      const distanceFromDestination = destinationDistanceInFlightplan - placeDistanceFromDestination - distance;
      console.log("distanceFromDestination ".concat(distanceFromDestination));
      const coordinates = fpm.getCoordinatesAtNMFromDestinationAlongFlightPlan(distanceFromDestination);
      return WaypointBuilder.fromCoordinates(ident, coordinates, instrument);
    }
    static fromWaypointManualHold(waypoint, holdDirection, inboundCourse, holdLength, holdTime, instrument) {
      const newWaypoint = WaypointBuilder.fromCoordinates(waypoint.ident, waypoint.infos.coordinates, instrument);
      newWaypoint.icao = waypoint.icao;
      newWaypoint.infos = waypoint.infos;
      newWaypoint.additionalData.legType = LegType$1.HM;
      newWaypoint.turnDirection = holdDirection;
      newWaypoint.additionalData.course = inboundCourse;
      newWaypoint.additionalData.distance = holdLength;
      newWaypoint.additionalData.distanceInMinutes = holdTime;
      newWaypoint.speedConstraint = waypoint.speedConstraint;
      newWaypoint.legAltitudeDescription = waypoint.legAltitudeDescription;
      newWaypoint.legAltitude1 = waypoint.legAltitude1;
      newWaypoint.legAltitude2 = waypoint.legAltitude2;
      newWaypoint.additionalData.constraintType = waypoint.additionalData.constraintType;
      return newWaypoint;
    }
  }

  /**
   * A flight plan managed by the FlightPlanManager.
   */
  class ManagedFlightPlan {
    constructor() {
      /** Whether or not the flight plan has an origin airfield. */
      _defineProperty(this, "originAirfield", void 0);
      // This is the same as originAirfield, but is not cleared when a direct-to occurs
      _defineProperty(this, "persistentOriginAirfield", void 0);
      /** Transition altitude for the originAirfield from the nav database */
      _defineProperty(this, "originTransitionAltitudeDb", void 0);
      /** Transition altitude for the originAirfield from the pilot */
      _defineProperty(this, "originTransitionAltitudePilot", void 0);
      /** Whether or not the flight plan has a destination airfield. */
      _defineProperty(this, "destinationAirfield", void 0);
      /** Transition level for the destinationAirfield from the nav database */
      _defineProperty(this, "destinationTransitionLevelDb", void 0);
      /** Transition level for the destinationAirfield from the pilot */
      _defineProperty(this, "destinationTransitionLevelPilot", void 0);
      /** Thrust reduction altitude in feet MSL for the origin airport from the nav database elevation, or undefined if none */
      _defineProperty(this, "thrustReductionAltitudeDefault", void 0);
      /** Thrust reduction altitude in feet MSL entered by the pilot, or undefined if none */
      _defineProperty(this, "thrustReductionAltitudePilot", void 0);
      /** Acceleration altitude in feet MSL for the origin airport from the nav database elevation, or undefined if none */
      _defineProperty(this, "accelerationAltitudeDefault", void 0);
      /** Acceleration altitude in feet MSL entered by the pilot, or undefined if none */
      _defineProperty(this, "accelerationAltitudePilot", void 0);
      /** Engine out acceleration altitude in feet MSL for the origin airport from the nav database elevation, or undefined if none */
      _defineProperty(this, "engineOutAccelerationAltitudeDefault", void 0);
      /** Engine out acceleration altitude in feet MSL entered by the pilot, or undefined if none */
      _defineProperty(this, "engineOutAccelerationAltitudePilot", void 0);
      /** Missed approach thrust reduction altitude in feet MSL for the destination airport from the nav database elevation, or undefined if none */
      _defineProperty(this, "missedThrustReductionAltitudeDefault", void 0);
      /** Missed approach thrust reduction altitude in feet MSL entered by the pilot, or undefined if none */
      _defineProperty(this, "missedThrustReductionAltitudePilot", void 0);
      /** Missed approach acceleration altitude in feet MSL for the destination airport from the nav database elevation, or undefined if none */
      _defineProperty(this, "missedAccelerationAltitudeDefault", void 0);
      /** Missed approach acceleration altitude in feet MSL entered by the pilot, or undefined if none */
      _defineProperty(this, "missedAccelerationAltitudePilot", void 0);
      /** Missed approach engine out acceleration altitude in feet MSL for the destination airport from the nav database elevation, or undefined if none */
      _defineProperty(this, "missedEngineOutAccelerationAltitudeDefault", void 0);
      /** Missed approach engine out acceleration altitude in feet MSL entered by the pilot, or undefined if none */
      _defineProperty(this, "missedEngineOutAccelerationAltitudePilot", void 0);
      /** The cruise altitude for this flight plan. */
      _defineProperty(this, "cruiseAltitude", 0);
      /** The index of the currently active waypoint. */
      _defineProperty(this, "activeWaypointIndex", 0);
      /** The details for selected procedures on this flight plan. */
      _defineProperty(this, "procedureDetails", new ProcedureDetails());
      /** The details of any direct-to procedures on this flight plan. */
      _defineProperty(this, "directTo", new DirectTo());
      _defineProperty(this, "turningPointIndex", 0);
      /** The parent instrument this flight plan is attached to locally. */
      _defineProperty(this, "_parentInstrument", void 0);
      /** The current active segments of the flight plan. */
      _defineProperty(this, "_segments", [new FlightPlanSegment$1(SegmentType.Enroute, 0, [])]);
    }
    /** The departure segment of the flight plan. */
    get departure() {
      return this.getSegment(SegmentType.Departure);
    }

    /** The enroute segment of the flight plan. */
    get enroute() {
      return this.getSegment(SegmentType.Enroute);
    }

    /** The arrival segment of the flight plan. */
    get arrival() {
      return this.getSegment(SegmentType.Arrival);
    }

    /** The approach segment of the flight plan. */
    get approach() {
      return this.getSegment(SegmentType.Approach);
    }

    /** The approach segment of the flight plan. */
    get missed() {
      return this.getSegment(SegmentType.Missed);
    }

    /** Whether the flight plan has an origin airfield. */
    get hasOrigin() {
      return this.originAirfield;
    }

    /** Whether the flight plan has a persistent origin airfield. */
    get hasPersistentOrigin() {
      return this.persistentOriginAirfield;
    }

    /** Whether the flight plan has a destination airfield. */
    get hasDestination() {
      return this.destinationAirfield;
    }

    /** The currently active waypoint. */
    get activeWaypoint() {
      return this.waypoints[this.activeWaypointIndex];
    }

    /**
     * Returns a list of {@link WaypointStats} for the waypoints in the flight plan
     *
     * @return {WaypointStats[]} array of statistics for the waypoints in the flight plan, with matching indices to
     *                           flight plan waypoints
     */
    computeWaypointStatistics(ppos) {
      // TODO this should be moved into its own dedicated module

      const stats = new Map();
      const firstData = this.computeActiveWaypointStatistics(ppos);
      stats.set(this.activeWaypointIndex, firstData);
      this.waypoints.slice(0).forEach((waypoint, index) => {
        var _firstData$distanceFr, _this$activeWaypoint$, _this$activeWaypoint;
        // TODO redo when we have a better solution for vector legs
        const firstDistFromPpos = (_firstData$distanceFr = firstData === null || firstData === void 0 ? void 0 : firstData.distanceFromPpos) !== null && _firstData$distanceFr !== void 0 ? _firstData$distanceFr : 0;
        const activeWpCumulativeDist = (_this$activeWaypoint$ = (_this$activeWaypoint = this.activeWaypoint) === null || _this$activeWaypoint === void 0 ? void 0 : _this$activeWaypoint.cumulativeDistanceInFP) !== null && _this$activeWaypoint$ !== void 0 ? _this$activeWaypoint$ : 0;
        const distPpos = waypoint.isVectors ? 1 : waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos;
        const data = {
          ident: waypoint.ident,
          bearingInFp: waypoint.bearingInFP,
          distanceInFP: waypoint.distanceInFP,
          magneticVariation: waypoint.infos.magneticVariation,
          distanceFromPpos: distPpos,
          timeFromPpos: this.computeWaypointTime(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos),
          etaFromPpos: this.computeWaypointEta(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos)
        };
        stats.set(index, data);
      });
      return stats;
    }

    /**
     * Returns info for the currently active waypoint, to be displayed by the Navigation Display
     */
    computeActiveWaypointStatistics(ppos) {
      // TODO this should be moved into its own dedicated module

      if (!this.activeWaypoint) {
        return undefined;
      }
      const bearingInFp = Avionics.Utils.computeGreatCircleHeading(ppos, this.activeWaypoint.infos.coordinates);
      let distanceFromPpos;
      if (Number.isNaN(ppos.lat) || Number.isNaN(ppos.long)) {
        distanceFromPpos = this.activeWaypoint.distanceInFP;
      } else if (this.activeWaypoint.isVectors) {
        // TODO redo when we have a better solution for vector legs
        distanceFromPpos = 1;
      } else {
        distanceFromPpos = Avionics.Utils.computeGreatCircleDistance(ppos, this.activeWaypoint.infos.coordinates);
      }
      const timeFromPpos = this.computeWaypointTime(distanceFromPpos);
      const etaFromPpos = this.computeWaypointEta(distanceFromPpos, timeFromPpos);
      return {
        ident: this.activeWaypoint.ident,
        bearingInFp,
        distanceInFP: this.activeWaypoint.distanceInFP,
        distanceFromPpos,
        timeFromPpos,
        etaFromPpos,
        magneticVariation: GeoMath.getMagvar(this.activeWaypoint.infos.coordinates.lat, this.activeWaypoint.infos.coordinates.long)
      };
    }

    // TODO is this accurate? Logic is same like in the old FPM
    computeWaypointTime(distance) {
      const groundSpeed = Simplane.getGroundSpeed();
      if (groundSpeed < 100) {
        return distance / 400 * 3600;
      }
      return distance / groundSpeed * 3600;
    }
    computeWaypointEta(distance, preComputedTime) {
      const eta = preComputedTime !== null && preComputedTime !== void 0 ? preComputedTime : this.computeWaypointTime(distance);
      const utcTime = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
      return eta + utcTime;
    }
    /** The waypoints of the flight plan. */
    get waypoints() {
      const waypoints = [];
      if (this.originAirfield) {
        waypoints.push(this.originAirfield);
      }
      for (const segment of this._segments) {
        waypoints.push(...segment.waypoints);
      }
      if (this.destinationAirfield) {
        waypoints.push(this.destinationAirfield);
      }
      return waypoints;
    }

    /**
     * Gets all the waypoints that are currently visible and part of the routing.
     *
     * This is used to obtain the list of waypoints to display after a DIRECT TO.
     */
    get visibleWaypoints() {
      const allWaypoints = this.waypoints;
      if (this.directTo.isActive) {
        const directToWaypointIndex = this.directTo.planWaypointIndex;
        return allWaypoints.slice(Math.max(this.activeWaypointIndex - 1, directToWaypointIndex), allWaypoints.length - 1);
      }
      return allWaypoints.slice(this.activeWaypointIndex - 1, allWaypoints.length);
    }
    get activeVisibleWaypointIndex() {
      if (this.directTo.isActive) {
        const directToWaypointIndex = this.directTo.planWaypointIndex;
        return this.activeWaypointIndex - 1 > directToWaypointIndex ? 1 : 0;
      }
      return 1;
    }
    get segments() {
      return this._segments;
    }

    /** The length of the flight plan. */
    get length() {
      const lastSeg = this._segments[this._segments.length - 1];
      return lastSeg.offset + lastSeg.waypoints.length + (this.hasDestination ? 1 : 0);
    }
    get checksum() {
      let checksum = 0;
      const {
        waypoints
      } = this;
      for (let i = 0; i < waypoints.length; i++) checksum += waypoints[i].infos.coordinates.lat;
      return checksum;
    }

    /** The non-approach waypoints of the flight plan. */
    get nonApproachWaypoints() {
      const waypoints = [];
      if (this.originAirfield) {
        waypoints.push(this.originAirfield);
      }
      for (const segment of this._segments.filter(s => s.type < SegmentType.Approach)) {
        waypoints.push(...segment.waypoints);
      }
      if (this.destinationAirfield) {
        waypoints.push(this.destinationAirfield);
      }
      return waypoints;
    }
    get cruiseStepWaypoints() {
      return this.waypoints.reduce((waypoints, wp, index) => {
        if (wp.additionalData.cruiseStep) {
          wp.additionalData.cruiseStep.waypointIndex = index;
          waypoints.push(wp);
        }
        return waypoints;
      }, []);
    }

    /**
     * Sets the parent instrument that the flight plan is attached to locally.
     * @param instrument The instrument that the flight plan is attached to.
     */
    setParentInstrument(instrument) {
      this._parentInstrument = instrument;
    }

    /**
     * Clears the flight plan.
     */
    async clearPlan() {
      this.originAirfield = undefined;
      this.originTransitionAltitudeDb = undefined;
      this.originTransitionAltitudePilot = undefined;
      this.persistentOriginAirfield = undefined;
      this.destinationAirfield = undefined;
      this.destinationTransitionLevelDb = undefined;
      this.destinationTransitionLevelPilot = undefined;
      this.thrustReductionAltitudeDefault = undefined;
      this.thrustReductionAltitudePilot = undefined;
      this.accelerationAltitudeDefault = undefined;
      this.accelerationAltitudePilot = undefined;
      this.engineOutAccelerationAltitudeDefault = undefined;
      this.engineOutAccelerationAltitudePilot = undefined;
      this.missedThrustReductionAltitudeDefault = undefined;
      this.missedThrustReductionAltitudePilot = undefined;
      this.missedAccelerationAltitudeDefault = undefined;
      this.missedAccelerationAltitudePilot = undefined;
      this.missedEngineOutAccelerationAltitudeDefault = undefined;
      this.missedEngineOutAccelerationAltitudePilot = undefined;
      this.cruiseAltitude = 0;
      this.activeWaypointIndex = 0;
      this.procedureDetails = new ProcedureDetails();
      this.directTo = new DirectTo();
      await GPS.clearPlan().catch(console.error);
      this._segments = [new FlightPlanSegment$1(SegmentType.Enroute, 0, [])];
    }

    /**
     * Syncs the flight plan to FS9GPS.
     */
    async syncToGPS() {
      await GPS.clearPlan().catch(console.error);
      for (let i = 0; i < this.waypoints.length; i++) {
        const waypoint = this.waypoints[i];
        if (waypoint.icao && waypoint.icao.trim() !== '') {
          GPS.addIcaoWaypoint(waypoint.icao, i).catch(console.error);
        } else {
          GPS.addUserWaypoint(waypoint.infos.coordinates.lat, waypoint.infos.coordinates.long, i, waypoint.ident).catch(console.error);
        }
        if (waypoint.endsInDiscontinuity) {
          break;
        }
      }
      await GPS.setActiveWaypoint(this.activeWaypointIndex).catch(console.error);
      await GPS.logCurrentPlan().catch(console.error);
    }

    /**
     * Adds a waypoint to the flight plan.
     *
     * @param waypoint    The waypoint to add
     *
     * @param index       The index to add the waypoint at. If omitted the waypoint will
     *                    be appended to the end of the flight plan.
     *
     * @param segmentType The type of segment to add the waypoint to
     * @returns The index the waypoint was actually inserted at
     */
    addWaypoint(waypoint, index, segmentType) {
      console.log("addWaypoint ".concat(waypoint.icao, ", ").concat(index, ", ").concat(SegmentType[segmentType]), waypoint);
      const mappedWaypoint = waypoint instanceof WayPoint ? waypoint : RawDataMapper.toWaypoint(waypoint, this._parentInstrument);
      if (mappedWaypoint.type === 'A' && index === 0) {
        mappedWaypoint.endsInDiscontinuity = true;
        mappedWaypoint.discontinuityCanBeCleared = true;
        this.originAirfield = mappedWaypoint;
        this.persistentOriginAirfield = mappedWaypoint;
        this.setOriginDefaults(mappedWaypoint);
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunwayIndex = -1;
        this.reflowSegments();
        this.reflowDistances();
      } else if (mappedWaypoint.type === 'A' && index === undefined) {
        this.destinationAirfield = mappedWaypoint;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayIndex = -1;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.setDestinationDefaults(mappedWaypoint);
        const previousWp = this.waypoints[this.waypoints.length - 2];
        if (previousWp) {
          previousWp.endsInDiscontinuity = true;
          previousWp.discontinuityCanBeCleared = true;
        }
        this.reflowSegments();
        this.reflowDistances();
      } else {
        let segment;
        if (segmentType !== undefined) {
          segment = this.getSegment(segmentType);
          if (segment === FlightPlanSegment$1.Empty) {
            segment = this.addSegment(segmentType);
          }
        } else {
          segment = this.findSegmentByWaypointIndex(index);
          if (segment === FlightPlanSegment$1.Empty) {
            throw new Error('ManagedFlightPlan::addWaypoint: no segment found!');
          }
        }

        // hitting first waypoint in segment > enroute
        if (segment.type > SegmentType.Enroute && index === segment.offset) {
          const segIdx = this._segments.findIndex(seg => seg.type === segment.type);
          // is prev segment enroute?
          const prevSeg = this._segments[segIdx - 1];
          if (prevSeg.type === SegmentType.Enroute) {
            segment = prevSeg;
          }
        }
        if (segment) {
          if (index > this.length) {
            index = undefined;
          }
          if (mappedWaypoint.additionalData.legType === undefined) {
            if (segment.waypoints.length < 1) {
              mappedWaypoint.additionalData.legType = LegType$1.IF;
            } else {
              mappedWaypoint.additionalData.legType = LegType$1.TF;
            }
          }
          if (index !== undefined) {
            const segmentIndex = index - segment.offset;
            if (segmentIndex < segment.waypoints.length) {
              segment.waypoints.splice(segmentIndex, 0, mappedWaypoint);
            } else {
              segment.waypoints.push(mappedWaypoint);
            }
          } else {
            segment.waypoints.push(mappedWaypoint);
          }
          this.reflowSegments();
          this.reflowDistances();
          const finalIndex = this.waypoints.indexOf(mappedWaypoint);
          const previousWp = finalIndex > 0 ? this.waypoints[finalIndex - 1] : undefined;

          // Transfer discontinuity forwards if previous waypoint has one and it can be cleared,
          // AND the new waypoint isn't the T-P of a direct to
          if (previousWp && previousWp.endsInDiscontinuity && !mappedWaypoint.isTurningPoint) {
            if (previousWp.discontinuityCanBeCleared === undefined || previousWp.discontinuityCanBeCleared) {
              previousWp.endsInDiscontinuity = false;
              previousWp.discontinuityCanBeCleared = undefined;

              // Don't mark the mapped waypoint's discontinuity as clearable if this is a MANUAL
              // TODO maybe extract this logic since we also use it when building a LegsProcedure
              mappedWaypoint.endsInDiscontinuity = true;
              if (!mappedWaypoint.isVectors) {
                mappedWaypoint.discontinuityCanBeCleared = true;
              }
            }
          }
          if (this.activeWaypointIndex === 0 && this.length > 1) {
            this.activeWaypointIndex = 1;
          } else if (this.activeWaypointIndex === 1 && waypoint.isRunway && segment.type === SegmentType.Departure) {
            this.activeWaypointIndex = 2;
          }
          return finalIndex;
        }
      }
      return -1;
    }

    /**
     * Removes a waypoint from the flight plan.
     * @param index The index of the waypoint to remove.
     */
    removeWaypoint(index) {
      let noDiscontinuity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.originAirfield && index === 0) {
        this.originAirfield = undefined;
        this.reflowSegments();
        this.reflowDistances();
      } else if (this.destinationAirfield && index === this.length - 1) {
        this.destinationAirfield = undefined;
      } else {
        const segment = this.findSegmentByWaypointIndex(index);
        if (segment) {
          const spliced = segment.waypoints.splice(index - segment.offset, 1);
          console.log("removing waypoint ".concat(spliced[0].icao, " from segment ").concat(segment.type));
          if (segment.waypoints.length === 0 && segment.type !== SegmentType.Enroute) {
            console.log("removing segment ".concat(segment.type, " as length is 0"));
            this.removeSegment(segment.type);
          }
          this.reflowSegments();
          this.reflowDistances();
        }
      }

      // transfer a potential discontinuity backward
      const beforeRemoved = this.waypoints[index - 1];
      if (!noDiscontinuity && beforeRemoved && !beforeRemoved.endsInDiscontinuity) {
        beforeRemoved.endsInDiscontinuity = true;
        beforeRemoved.discontinuityCanBeCleared = true;
      }
      if (index < this.activeWaypointIndex || this.activeWaypointIndex === this.waypoints.length) {
        this.activeWaypointIndex--;
      }
    }

    /**
     * Gets a waypoint by index from the flight plan.
     * @param index The index of the waypoint to get.
     */
    getWaypoint(index) {
      if (this.originAirfield && index === 0) {
        return this.originAirfield;
      }
      if (this.destinationAirfield && index === this.length - 1) {
        return this.destinationAirfield;
      }
      const segment = this.findSegmentByWaypointIndex(index);
      if (segment) {
        return segment.waypoints[index - segment.offset];
      }
      return null;
    }
    setWaypointOverfly(index, value) {
      // FIXME origin airfield isn't necessarily index 0
      if (this.originAirfield && index === 0) {
        return;
      }

      // FIXME origin airfield isn't necessarily last index (never will be with missed approach)
      if (this.destinationAirfield && index === this.length - 1) {
        return;
      }
      const segment = this.findSegmentByWaypointIndex(index);
      if (segment) {
        segment.waypoints[index - segment.offset].additionalData.overfly = value;
      }
    }
    addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
      const atWaypoint = this.getWaypoint(index);
      if (!atWaypoint) {
        return 0;
      }
      const magVar = Facilities.getMagVar(atWaypoint.infos.coordinates.lat, atWaypoint.infos.coordinates.long);
      const trueCourse = A32NX_Util.magneticToTrue(desiredHold.inboundMagneticCourse, magVar);
      if (atWaypoint.additionalData.legType === LegType$1.HA || atWaypoint.additionalData.legType === LegType$1.HF || atWaypoint.additionalData.legType === LegType$1.HM) {
        atWaypoint.additionalData.legType = LegType$1.HM;
        atWaypoint.turnDirection = desiredHold.turnDirection;
        atWaypoint.additionalData.course = trueCourse;
        atWaypoint.additionalData.distance = desiredHold.distance;
        atWaypoint.additionalData.distanceInMinutes = desiredHold.time;
        atWaypoint.additionalData.modifiedHold = modifiedHold;
        if (atWaypoint.additionalData.defaultHold === undefined) {
          atWaypoint.additionalData.defaultHold = defaultHold;
        }
        return index;
      }
      const manualHoldWaypoint = WaypointBuilder.fromWaypointManualHold(atWaypoint, desiredHold.turnDirection, trueCourse, desiredHold.distance, desiredHold.time, this._parentInstrument);
      manualHoldWaypoint.additionalData.modifiedHold = modifiedHold;
      manualHoldWaypoint.additionalData.defaultHold = defaultHold;
      this.addWaypoint(manualHoldWaypoint, index + 1);
      return index + 1;
    }

    /**
     * Adds a plan segment to the flight plan.
     * @param type The type of the segment to add.
     */
    addSegment(type) {
      const segment = new FlightPlanSegment$1(type, 0, []);
      this._segments.push(segment);
      this._segments.sort((a, b) => a.type - b.type);
      this.reflowSegments();
      return segment;
    }

    /**
     * Removes a plan segment from the flight plan.
     * @param type The type of plan segment to remove.
     */
    removeSegment(type) {
      const segmentIndex = this._segments.findIndex(s => s.type === type);
      if (segmentIndex > -1) {
        this._segments.splice(segmentIndex, 1);
      }
    }

    /**
     * Reflows waypoint index offsets accross plans segments.
     */
    reflowSegments() {
      let index = 0;
      if (this.originAirfield) {
        index = 1;
      }
      for (const segment of this._segments) {
        segment.offset = index;
        index += segment.waypoints.length;
      }
    }

    /**
     * Gets a flight plan segment of the specified type.
     * @param type The type of flight plan segment to get.
     * @returns The found segment, or FlightPlanSegment.Empty if not found.
     */
    getSegment(type) {
      const segment = this._segments.find(s => s.type === type);
      return segment !== undefined ? segment : FlightPlanSegment$1.Empty;
    }

    /**
     * Finds a flight plan segment by waypoint index.
     * @param index The index of the waypoint to find the segment for.
     * @returns The located segment, if any.
     */
    findSegmentByWaypointIndex(index) {
      for (let i = 0; i < this._segments.length; i++) {
        const segMaxIdx = this._segments[i].offset + this._segments[i].waypoints.length;
        if (segMaxIdx > index) {
          return this._segments[i];
        }
      }
      return this._segments[this._segments.length - 1];
    }
    isLastWaypointInSegment(fpIndex) {
      const segment = this.findSegmentByWaypointIndex(fpIndex);
      if (fpIndex >= this.waypoints.length) {
        return false;
      }
      if (fpIndex === segment.offset + segment.waypoints.length - 1) {
        return true;
      }
      return false;
    }

    /**
     * Recalculates all waypoint bearings and distances in the flight plan.
     */
    reflowDistances() {
      let cumulativeDistance = 0;
      const {
        waypoints
      } = this;
      for (let i = 0; i < waypoints.length; i++) {
        if (i > 0) {
          // If there's an approach selected and this is the last approach waypoint, use the destination waypoint for coordinates
          // Runway waypoints do not have coordinates
          const referenceWaypoint = waypoints[i];
          const prevWaypoint = waypoints[i - 1];
          const trueCourseToWaypoint = Avionics.Utils.computeGreatCircleHeading(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
          referenceWaypoint.bearingInFP = trueCourseToWaypoint - GeoMath.getMagvar(prevWaypoint.infos.coordinates.lat, prevWaypoint.infos.coordinates.long);
          referenceWaypoint.bearingInFP = referenceWaypoint.bearingInFP < 0 ? 360 + referenceWaypoint.bearingInFP : referenceWaypoint.bearingInFP;
          if (prevWaypoint.endsInDiscontinuity && !prevWaypoint.discontinuityCanBeCleared) {
            referenceWaypoint.distanceInFP = 0;
          } else if (referenceWaypoint.additionalData) {
            switch (referenceWaypoint.additionalData.legType) {
              case 11:
              case 22:
                referenceWaypoint.distanceInFP = 1;
                break;
              default:
                referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
                break;
            }
          } else {
            referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
          }
          cumulativeDistance += referenceWaypoint.distanceInFP;
          referenceWaypoint.cumulativeDistanceInFP = cumulativeDistance;
        }
      }
    }

    /**
     * Copies a sanitized version of the flight plan for shared data storage.
     * @returns The sanitized flight plan.
     */
    serialize() {
      var _planCopy$directTo$in;
      const planCopy = new ManagedFlightPlan();
      const copyWaypoint = waypoint => ({
        icao: waypoint.icao,
        ident: waypoint.ident,
        type: waypoint.type,
        legAltitudeDescription: waypoint.legAltitudeDescription,
        legAltitude1: waypoint.legAltitude1,
        legAltitude2: waypoint.legAltitude2,
        speedConstraint: waypoint.speedConstraint,
        turnDirection: waypoint.turnDirection,
        isVectors: waypoint.isVectors,
        endsInDiscontinuity: waypoint.endsInDiscontinuity,
        discontinuityCanBeCleared: waypoint.discontinuityCanBeCleared,
        distanceInFP: waypoint.distanceInFP,
        cumulativeDistanceInFP: waypoint.cumulativeDistanceInFP,
        isRunway: waypoint.isRunway,
        additionalData: waypoint.additionalData,
        infos: {
          icao: waypoint.infos.icao,
          ident: waypoint.infos.ident,
          airwayIn: waypoint.infos.airwayIn,
          airwayOut: waypoint.infos.airwayOut,
          routes: waypoint.infos.routes,
          coordinates: {
            lat: waypoint.infos.coordinates.lat,
            long: waypoint.infos.coordinates.long,
            alt: waypoint.infos.coordinates.alt
          }
        }
      });
      const copyAirfield = airfield => {
        const copy = Object.assign(new WayPoint(undefined), airfield);
        copy.infos = Object.assign(new AirportInfo(undefined), copy.infos);
        delete copy.instrument;
        delete copy.infos.instrument;
        delete copy._svgElements;
        delete copy.infos._svgElements;
        return copy;
      };
      planCopy.activeWaypointIndex = this.activeWaypointIndex;
      planCopy.destinationAirfield = this.destinationAirfield && copyAirfield(this.destinationAirfield);
      planCopy.originAirfield = this.originAirfield && copyAirfield(this.originAirfield);
      planCopy.persistentOriginAirfield = this.persistentOriginAirfield && copyAirfield(this.persistentOriginAirfield);
      planCopy.procedureDetails = _objectSpread2({}, this.procedureDetails);
      planCopy.directTo = _objectSpread2({}, this.directTo);
      planCopy.directTo.interceptPoints = (_planCopy$directTo$in = planCopy.directTo.interceptPoints) === null || _planCopy$directTo$in === void 0 ? void 0 : _planCopy$directTo$in.map(w => copyWaypoint(w));
      const copySegments = [];
      for (const segment of this._segments) {
        const copySegment = new FlightPlanSegment$1(segment.type, segment.offset, []);
        for (const waypoint of segment.waypoints) {
          copySegment.waypoints.push(copyWaypoint(waypoint));
        }
        copySegments.push(copySegment);
      }
      planCopy._segments = copySegments;
      return planCopy;
    }

    /**
     * Copies the flight plan.
     * @returns The copied flight plan.
     */
    copy() {
      const newFlightPlan = Object.assign(new ManagedFlightPlan(), this);
      newFlightPlan.setParentInstrument(this._parentInstrument);
      newFlightPlan._segments = [];
      for (let i = 0; i < this._segments.length; i++) {
        const seg = this._segments[i];
        newFlightPlan._segments[i] = Object.assign(new FlightPlanSegment$1(seg.type, seg.offset, []), seg);
        newFlightPlan._segments[i].waypoints = [...seg.waypoints.map(wp => {
          const clone = new wp.constructor();
          Object.assign(clone, wp);
          clone.additionalData = _objectSpread2({}, wp.additionalData);
          return clone;
        })];
      }
      newFlightPlan.procedureDetails = Object.assign(new ProcedureDetails(), this.procedureDetails);
      newFlightPlan.directTo = Object.assign(new DirectTo(), this.directTo);
      newFlightPlan.directTo.interceptPoints = this.directTo.interceptPoints !== undefined ? [...this.directTo.interceptPoints] : undefined;
      return newFlightPlan;
    }

    /**
     * Reverses the flight plan.
     */
    reverse() {
      // TODO: Fix flight plan indexes after reversal
      // this._waypoints.reverse();
    }

    /**
     * Goes direct to the specified waypoint index in the flight plan.
     *
     * @param waypoint The waypoint to go direct to
     */
    async addDirectTo(waypoint) {
      // TODO Replace with FMGC pos
      const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
      const oldToWp = this.waypoints[this.activeWaypointIndex];
      const turningPoint = WaypointBuilder.fromCoordinates('T-P', new LatLongAlt(lat, long), this._parentInstrument, {
        legType: LegType$1.CF,
        course: trueTrack,
        dynamicPpos: true
      }, this.getTurningPointIcao());
      turningPoint.isTurningPoint = true;
      const waypointIndex = this.waypoints.findIndex((w, idx) => idx >= this.activeWaypointIndex && w.icao === waypoint.icao);
      if (waypointIndex === -1) {
        // in this case the waypoint is not already in the flight plan
        // we string it to the start of the flight plan, add a discontinuity after, and then the existing flight plan
        waypoint.endsInDiscontinuity = true;
        waypoint.discontinuityCanBeCleared = true;
        waypoint.additionalData.legType = LegType$1.DF;
        this.addWaypoint(waypoint, this.activeWaypointIndex);
        this.activeWaypointIndex = this.addWaypoint(turningPoint, this.activeWaypointIndex) + 1;

        // fix up the old leg that's now after the discont
        if (ManagedFlightPlan.isXfLeg(oldToWp)) {
          oldToWp.additionalData.legType = LegType$1.IF;
        }
      } else {
        // in this case the waypoint is already in the flight plan...
        // we can skip all the legs before it, and add our dir to
        const toWp = this.waypoints[waypointIndex];
        toWp.additionalData.legType = LegType$1.DF;
        toWp.turnDirection = 0;
        this.addWaypoint(turningPoint, waypointIndex);
        this.activeWaypointIndex = waypointIndex + 1;
      }
    }

    /**
     *
     * @param force force updating a turning point even if it's not marked dynamic
     */
    updateTurningPoint() {
      var _wp$additionalData;
      let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      const wp = this.getWaypoint(this.activeWaypointIndex - 1);
      if (wp !== null && wp !== void 0 && (_wp$additionalData = wp.additionalData) !== null && _wp$additionalData !== void 0 && _wp$additionalData.dynamicPpos || force && wp !== null && wp !== void 0 && wp.isTurningPoint) {
        wp.infos.coordinates.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
        wp.infos.coordinates.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
        wp.additionalData.course = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
        wp.icao = this.getTurningPointIcao();
        wp.infos.icao = wp.icao;
        console.log('updated T-P:', force, wp.additionalData, wp.infos.coordinates);
        return true;
      }
      return false;
    }
    getTurningPointIcao() {
      this.turningPointIndex = (this.turningPointIndex + 1) % 1000;
      return "WXX    TP".concat(this.turningPointIndex.toFixed(0).padStart(3, '0'));
    }

    /**
     * Builds a departure into the flight plan from indexes in the departure airport information.
     */
    async buildDeparture() {
      const legs = [];
      const legAnnotations = [];
      const origin = this.originAirfield;
      const {
        departureIndex
      } = this.procedureDetails;
      const runwayIndex = this.procedureDetails.departureRunwayIndex;
      const transitionIndex = this.procedureDetails.departureTransitionIndex;
      const selectedOriginRunwayIndex = this.procedureDetails.originRunwayIndex;
      const airportInfo = origin.infos;
      const airportMagVar = Facilities.getMagVar(airportInfo.coordinates.lat, airportInfo.coordinates.long);

      // Make origin fix an IF leg
      if (origin) {
        origin.additionalData.legType = LegType$1.IF;
        origin.endsInDiscontinuity = true;
        origin.discontinuityCanBeCleared = true;
        const departure = airportInfo.departures[departureIndex];
        if (departure) {
          origin.additionalData.annotation = departure.name;
        } else {
          origin.additionalData.annotation = '';
        }
      }

      // Set origin fix coordinates to runway beginning coordinates
      if (origin && selectedOriginRunwayIndex >= 0) {
        origin.infos.coordinates = airportInfo.oneWayRunways[selectedOriginRunwayIndex].beginningCoordinates;
        origin.additionalData.runwayElevation = airportInfo.oneWayRunways[selectedOriginRunwayIndex].elevation * 3.2808399;
        origin.additionalData.runwayLength = airportInfo.oneWayRunways[selectedOriginRunwayIndex].length;
      }
      if (departureIndex >= 0 && runwayIndex >= 0) {
        const runwayTransition = airportInfo.departures[departureIndex].runwayTransitions[runwayIndex];
        const departure = airportInfo.departures[departureIndex];
        if (runwayTransition) {
          legs.push(...runwayTransition.legs);
          legAnnotations.push(...runwayTransition.legs.map(_ => departure.name));
          origin.endsInDiscontinuity = false;
          origin.discontinuityCanBeCleared = undefined;
        }
      }
      if (departureIndex >= 0) {
        const departure = airportInfo.departures[departureIndex];
        legs.push(...departure.commonLegs);
        legAnnotations.push(...departure.commonLegs.map(_ => departure.name));
      }
      if (transitionIndex >= 0 && departureIndex >= 0) {
        if (airportInfo.departures[departureIndex].enRouteTransitions.length > 0) {
          const transition = airportInfo.departures[departureIndex].enRouteTransitions[transitionIndex];
          legs.push(...transition.legs);
          legAnnotations.push(...transition.legs.map(_ => transition.name));
        }
      }
      let segment = this.departure;
      if (segment !== FlightPlanSegment$1.Empty) {
        for (let i = 0; i < segment.waypoints.length; i++) {
          this.removeWaypoint(segment.offset);
        }
        this.removeSegment(segment.type);
      }
      if (legs.length > 0 || selectedOriginRunwayIndex >= 0 || departureIndex >= 0 && runwayIndex >= 0) {
        segment = this.addSegment(SegmentType.Departure);
        const procedure = new LegsProcedure(legs, origin, this._parentInstrument, airportMagVar, undefined, legAnnotations);
        const runway = this.getOriginRunway();
        if (runway) {
          // console.error('bruh');
          // Reference : AMM - 22-71-00 PB001, Page 4
          if (departureIndex < 0 && transitionIndex < 0) {
            const TEMPORARY_VERTICAL_SPEED = 2000.0; // ft/min
            const TEMPORARY_GROUND_SPEED = 160; // knots

            const altitudeFeet = runway.elevation * 3.2808399 + 1500;
            const distanceInNM = altitudeFeet / TEMPORARY_VERTICAL_SPEED * (TEMPORARY_GROUND_SPEED / 60);
            const coordinates = GeoMath.relativeBearingDistanceToCoords(runway.direction, distanceInNM, runway.endCoordinates);
            const faLeg = procedure.buildWaypoint("".concat(Math.round(altitudeFeet)), coordinates);
            // TODO should this check for unclr discont? (probs not)
            faLeg.endsInDiscontinuity = true;
            faLeg.discontinuityCanBeCleared = true;
            this.addWaypoint(faLeg, undefined, segment.type);
          }
        }
        let waypointIndex = segment.offset;
        while (procedure.hasNext()) {
          // eslint-disable-next-line no-await-in-loop
          const waypoint = await procedure.getNext();
          if (waypoint !== undefined) {
            waypoint.additionalData.constraintType = WaypointConstraintType.CLB;
            this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
          }
        }
      }
      this.restringSegmentBoundaries(SegmentType.Departure, SegmentType.Enroute);
    }

    /**
     * Rebuilds the arrival and approach segment after a change of procedure
     */
    async rebuildArrivalApproach() {
      // remove all legs from these segments to prevent weird stuff
      this.truncateSegment(SegmentType.Arrival);
      this.truncateSegment(SegmentType.Approach);
      this.truncateSegment(SegmentType.Missed);
      await this.buildArrival().catch(console.error);
      await this.buildApproach().catch(console.error);
    }

    /**
     * Builds an arrival into the flight plan from indexes in the arrival airport information.
     */
    async buildArrival() {
      const legs = [];
      const legAnnotations = [];
      const destination = this.destinationAirfield;
      const {
        arrivalIndex
      } = this.procedureDetails;
      // const { approachTransitionIndex } = this.procedureDetails;
      const {
        arrivalRunwayIndex
      } = this.procedureDetails;
      const {
        arrivalTransitionIndex
      } = this.procedureDetails;
      const destinationInfo = destination.infos;
      const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
      if (arrivalIndex >= 0 && arrivalTransitionIndex >= 0) {
        const transition = destinationInfo.arrivals[arrivalIndex].enRouteTransitions[arrivalTransitionIndex];
        if (transition !== undefined) {
          legs.push(...transition.legs);
          legAnnotations.push(...transition.legs.map(_ => transition.name));
          // console.log('MFP: buildArrival - pushing transition legs ->', legs);
        }
      }

      if (arrivalIndex >= 0) {
        // string the common legs in the middle of the STAR
        const arrival = destinationInfo.arrivals[arrivalIndex];
        legs.push(...arrival.commonLegs);
        legAnnotations.push(...arrival.commonLegs.map(_ => arrival.name));
        // console.log('MFP: buildArrival - pushing STAR legs ->', legs);

        // if no runway is selected at all (non-runway-specific approach)
        // and the selected STAR only has runway transition legs... string them
        // TODO research IRL behaviour
        const starHasOneRunwayTrans = arrival.commonLegs.length === 0 && arrival.runwayTransitions.length === 1;
        const approachIsRunwaySpecific = this.procedureDetails.destinationRunwayIndex >= 0;
        const runwayTransIndex = arrivalRunwayIndex < 0 && starHasOneRunwayTrans && !approachIsRunwaySpecific ? 0 : arrivalRunwayIndex;
        const runwayTransition = arrival.runwayTransitions[runwayTransIndex];
        if (runwayTransition) {
          legs.push(...runwayTransition.legs);
          legAnnotations.push(...runwayTransition.legs.map(_ => arrival.name));
        }
      }
      let {
        _startIndex,
        segment
      } = this.truncateSegment(SegmentType.Arrival);
      if (legs.length > 0) {
        if (segment === FlightPlanSegment$1.Empty) {
          segment = this.addSegment(SegmentType.Arrival);
          _startIndex = segment.offset;
        }
        const procedure = new LegsProcedure(legs, this.getWaypoint(segment.offset - 1), this._parentInstrument, airportMagVar, undefined, legAnnotations);
        let waypointIndex = segment.offset;
        // console.log('MFP: buildArrival - ADDING WAYPOINTS ------------------------');
        while (procedure.hasNext()) {
          // eslint-disable-next-line no-await-in-loop
          const waypoint = await procedure.getNext();
          if (waypoint) {
            waypoint.additionalData.constraintType = WaypointConstraintType.DES;

            // console.log('  ---- MFP: buildArrival: added waypoint ', waypoint.ident, ' to segment ', segment);
            this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
          }
        }
      }
      this.restringSegmentBoundaries(SegmentType.Enroute, SegmentType.Arrival);
      this.restringSegmentBoundaries(SegmentType.Arrival, SegmentType.Approach);
    }

    /**
     * Builds an approach into the flight plan from indexes in the arrival airport information.
     */
    async buildApproach() {
      const legs = [];
      const legAnnotations = [];
      const missedLegs = [];
      const destination = this.destinationAirfield;
      this.procedureDetails.approachType = undefined;
      const {
        approachIndex
      } = this.procedureDetails;
      const {
        approachTransitionIndex
      } = this.procedureDetails;
      const {
        destinationRunwayIndex
      } = this.procedureDetails;
      const destinationInfo = destination.infos;
      const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
      const approach = destinationInfo.approaches[approachIndex];
      const approachName = approach && approach.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN ? approach.name : '';
      if (approachIndex >= 0 && approachTransitionIndex >= 0) {
        const transition = destinationInfo.approaches[approachIndex].transitions[approachTransitionIndex];
        legs.push(...transition.legs);
        legAnnotations.push(...transition.legs.map(_ => transition.name));
        // console.log('MFP: buildApproach - pushing approachTransition legs ->', legs);
      }

      if (approachIndex >= 0) {
        var _legs, _finalLegs$;
        const finalLegs = [...approach.finalLegs];
        // PI legs can only occur in approach vias
        // if the via ends in one, we must omit the IF leg at the start of the approach
        const viaLastLegType = (_legs = legs[legs.length - 1]) === null || _legs === void 0 ? void 0 : _legs.type;
        if (viaLastLegType === LegType$1.PI && ((_finalLegs$ = finalLegs[0]) === null || _finalLegs$ === void 0 ? void 0 : _finalLegs$.type) === LegType$1.IF) {
          var _finalLegs$2;
          finalLegs.splice(0, 1);
          // @ts-expect-error (ts compiler doesn't see that splice mutates finalLegs)
          if (((_finalLegs$2 = finalLegs[0]) === null || _finalLegs$2 === void 0 ? void 0 : _finalLegs$2.type) !== LegType$1.CF) {
            console.error('PI must be followed by CF!');
          }
        }
        this.procedureDetails.approachType = approach.approachType;
        legs.push(...finalLegs);
        legAnnotations.push(...finalLegs.map(_ => approachName));
        missedLegs.push(...approach.missedLegs);
      }
      let {
        _startIndex,
        segment
      } = this.truncateSegment(SegmentType.Approach);
      if (legs.length > 0 || approachIndex >= 0 || destinationRunwayIndex >= 0) {
        if (segment === FlightPlanSegment$1.Empty) {
          segment = this.addSegment(SegmentType.Approach);
          _startIndex = segment.offset;
          const prevWaypointIndex = segment.offset - 1;
          if (prevWaypointIndex > 0) {
            const prevWaypoint = this.getWaypoint(segment.offset - 1);
            if (!prevWaypoint.endsInDiscontinuity) {
              prevWaypoint.endsInDiscontinuity = true;
              prevWaypoint.discontinuityCanBeCleared = true;
            }
          }
        }
        const runway = this.getDestinationRunway();
        const procedure = new LegsProcedure(legs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar, this.procedureDetails.approachType, legAnnotations);
        let waypointIndex = _startIndex;
        // console.log('MFP: buildApproach - ADDING WAYPOINTS ------------------------');
        while (procedure.hasNext()) {
          // eslint-disable-next-line no-await-in-loop
          const waypoint = await procedure.getNext();
          if (waypoint !== undefined) {
            waypoint.additionalData.constraintType = WaypointConstraintType.DES;

            // console.log('  ---- MFP: buildApproach: added waypoint', waypoint.ident, ' to segment ', segment);
            this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
          }
        }
        if (runway) {
          // const selectedRunwayMod = runway.designation.slice(-1);
          // let selectedRunwayOutput;
          // if (selectedRunwayMod === 'L' || selectedRunwayMod === 'C' || selectedRunwayMod === 'R') {
          //     if (runway.designation.length === 2) {
          //         selectedRunwayOutput = `0${runway.designation}`;
          //     } else {
          //         selectedRunwayOutput = runway.designation;
          //     }
          // } else if (runway.designation.length === 2) {
          //     selectedRunwayOutput = runway.designation;
          // } else {
          //     selectedRunwayOutput = `0${runway.designation}`;
          // }

          // When adding approach, edit destination waypoint
          this.destinationAirfield.infos.coordinates = runway.beginningCoordinates;
          this.destinationAirfield.legAltitudeDescription = 1;
          this.destinationAirfield.legAltitude1 = Math.round((runway.elevation * 3.28084 + 50) / 10) * 10;
          this.destinationAirfield.isRunway = true;
          if (approachIndex >= 0) {
            const lastLeg = approach.finalLegs[approach.finalLegs.length - 1];
            if (lastLeg.type === LegType$1.CF) {
              const magCourse = lastLeg.trueDegrees ? A32NX_Util.trueToMagnetic(lastLeg.course, Facilities.getMagVar(runway.beginningCoordinates.lat, runway.beginningCoordinates.long)) : lastLeg.course;
              this.destinationAirfield.additionalData.annotation = "C".concat(magCourse.toFixed(0).padStart(3, '0'), "\xB0");
            } else {
              this.destinationAirfield.additionalData.annotation = approachName;
            }
            this.destinationAirfield.additionalData.verticalAngle = lastLeg.verticalAngle ? lastLeg.verticalAngle - 360 : undefined;
          }

          // Clear discontinuity before destination, if any
          const wpBeforeDestIdx = this.waypoints.indexOf(this.destinationAirfield) - 1;
          if (wpBeforeDestIdx >= 0) {
            const wpBeforeDest = this.getWaypoint(wpBeforeDestIdx);
            if (wpBeforeDest.endsInDiscontinuity && wpBeforeDest.discontinuityCanBeCleared) {
              wpBeforeDest.endsInDiscontinuity = false;
            }
          }
        }
      }
      this.restringSegmentBoundaries(SegmentType.Arrival, SegmentType.Approach);

      /* if (missedLegs.length > 0) {
          let { _startIndex, segment } = this.truncateSegment(SegmentType.Missed);
           if (segment === FlightPlanSegment.Empty) {
              segment = this.addSegment(SegmentType.Missed);
              _startIndex = segment.offset;
          }
           let waypointIndex = _startIndex;
           const missedProcedure = new LegsProcedure(missedLegs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar);
          while (missedProcedure.hasNext()) {
              // eslint-disable-next-line no-await-in-loop
              const waypoint = await missedProcedure.getNext().catch(console.error);
               if (waypoint !== undefined) {
                  // console.log('  ---- MFP: buildApproach: added waypoint', waypoint.ident, ' to segment ', segment);
                  this.addWaypoint(waypoint, ++waypointIndex, segment.type);
              }
          }
      } */
    }

    static isXfLeg(leg) {
      var _leg$additionalData;
      switch (leg === null || leg === void 0 ? void 0 : (_leg$additionalData = leg.additionalData) === null || _leg$additionalData === void 0 ? void 0 : _leg$additionalData.legType) {
        case LegType$1.CF:
        case LegType$1.DF:
        case LegType$1.IF:
        case LegType$1.RF:
        case LegType$1.TF:
          return true;
        default:
          return false;
      }
    }
    static isFxLeg(leg) {
      var _leg$additionalData2;
      switch (leg === null || leg === void 0 ? void 0 : (_leg$additionalData2 = leg.additionalData) === null || _leg$additionalData2 === void 0 ? void 0 : _leg$additionalData2.legType) {
        case LegType$1.FA:
        case LegType$1.FC:
        case LegType$1.FD:
        case LegType$1.FM:
          return true;
        default:
          return false;
      }
    }
    static legsStartOrEndAtSameFix(legA, legB) {
      return legA.icao === legB.icao && (ManagedFlightPlan.isXfLeg(legA) && ManagedFlightPlan.isXfLeg(legB) || ManagedFlightPlan.isFxLeg(legA) && ManagedFlightPlan.isFxLeg(legB));
    }
    static climbConstraint(leg) {
      switch (leg.legAltitudeDescription) {
        case AltitudeDescriptor.At:
        case AltitudeDescriptor.AtOrBelow:
          return leg.legAltitude1;
        case AltitudeDescriptor.Between:
          return Math.max(leg.legAltitude1, leg.legAltitude2);
      }
      return Infinity;
    }
    static descentConstraint(leg) {
      switch (leg.legAltitudeDescription) {
        case AltitudeDescriptor.At:
        case AltitudeDescriptor.AtOrAbove:
          return leg.legAltitude1;
        case AltitudeDescriptor.Between:
          return Math.min(leg.legAltitude1, leg.legAltitude2);
      }
      return -Infinity;
    }
    static mergeConstraints(legA, legB) {
      let legAltitudeDescription = AltitudeDescriptor.Empty;
      let legAltitude1 = 0;
      let legAltitude2 = 0;
      if (legA.legAltitudeDescription === AltitudeDescriptor.At) {
        legAltitudeDescription = AltitudeDescriptor.At;
        if (legB.legAltitudeDescription === AltitudeDescriptor.At) {
          legAltitude1 = Math.min(legA.legAltitude1, legB.legAltitude1);
        } else {
          legAltitude1 = legA.legAltitude1;
        }
      } else if (legB.legAltitudeDescription === AltitudeDescriptor.At) {
        legAltitudeDescription = AltitudeDescriptor.At;
        legAltitude1 = legB.legAltitude1;
      } else if (legA.legAltitudeDescription > 0 || legB.legAltitudeDescription > 0) {
        const maxAlt = Math.min(ManagedFlightPlan.climbConstraint(legA), ManagedFlightPlan.climbConstraint(legB));
        const minAlt = Math.max(ManagedFlightPlan.descentConstraint(legA), ManagedFlightPlan.descentConstraint(legB));
        if (Number.isFinite(maxAlt)) {
          if (Number.isFinite(minAlt)) {
            if (Math.abs(minAlt - maxAlt) < 1) {
              legAltitudeDescription = AltitudeDescriptor.At;
              legAltitude1 = minAlt;
            } else {
              legAltitudeDescription = AltitudeDescriptor.Between;
              legAltitude1 = minAlt;
              legAltitude2 = maxAlt;
            }
          } else {
            legAltitudeDescription = AltitudeDescriptor.AtOrBelow;
            legAltitude1 = maxAlt;
          }
        } else if (Number.isFinite(minAlt)) {
          legAltitudeDescription = AltitudeDescriptor.AtOrAbove;
          legAltitude1 = minAlt;
        }
      }
      const speed = Math.min(legA.speedConstraint > 0 ? legA.speedConstraint : Infinity, legB.speedConstraint > 0 ? legB.speedConstraint : Infinity);
      return {
        legAltitudeDescription,
        legAltitude1,
        legAltitude2,
        speedConstraint: Number.isFinite(speed) ? speed : 0
      };
    }

    /**
     * Check for common waypoints at the boundaries of segments, and merge them if found
     * segmentA must be before segmentB in the plan!
     */
    restringSegmentBoundaries(segmentTypeA, segmentTypeB) {
      if (segmentTypeB < segmentTypeA) {
        throw new Error('restringSegmentBoundaries: segmentTypeA must be before segmentTypeB');
      }
      const segmentA = this.getSegment(segmentTypeA);
      const segmentB = this.getSegment(segmentTypeB);
      if ((segmentA === null || segmentA === void 0 ? void 0 : segmentA.waypoints.length) < 1 || (segmentB === null || segmentB === void 0 ? void 0 : segmentB.waypoints.length) < 1) {
        return;
      }
      const lastLegIndexA = segmentA.offset + segmentA.waypoints.length - 1;
      const lastLegA = segmentA.waypoints[segmentA.waypoints.length - 1];
      const firstLegIndexB = segmentB.offset;
      const firstLegB = segmentB.waypoints[0];
      if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, firstLegB)) {
        const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
        if (segmentA.type === SegmentType.Departure) {
          this.removeWaypoint(firstLegIndexB, true);
          Object.assign(lastLegA, constraints);
          lastLegA.endsInDiscontinuity = false;
          lastLegA.discontinuityCanBeCleared = undefined;
        } else {
          this.removeWaypoint(lastLegIndexA, true);
          Object.assign(firstLegB, constraints);
          firstLegB.endsInDiscontinuity = false;
          firstLegB.discontinuityCanBeCleared = undefined;
        }
      } else if (segmentTypeA === SegmentType.Arrival && segmentTypeB === SegmentType.Approach) {
        let toDeleteFromB = 0;
        for (let i = 0; i < segmentB.waypoints.length; i++) {
          if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, segmentB.waypoints[i])) {
            const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
            Object.assign(lastLegA, constraints);
            toDeleteFromB = i + 1;
            break;
          }
        }
        for (let i = 0; i < toDeleteFromB; i++) {
          this.removeWaypoint(segmentB.offset, true);
        }
        if (toDeleteFromB === 0 && firstLegB.additionalData.legType === LegType$1.IF) {
          lastLegA.endsInDiscontinuity = true;
          lastLegA.discontinuityCanBeCleared = true;
        }
      }
    }

    /**
     * Truncates a flight plan segment. If the active waypoint index is current in the segment,
     * a discontinuity will be added at the end of the active waypoint and the startIndex will
     * point to the next waypoint in the segment after the active.
     * @param type The type of segment to truncate.
     * @returns A segment to add to and a starting waypoint index.
     */
    truncateSegment(type) {
      let segment = this.getSegment(type);
      // const startIndex = this.findSegmentByWaypointIndex(this.activeWaypointIndex) === segment
      //     ? this.activeWaypointIndex + 1
      //     : segment.offset;
      const startIndex = segment.offset;
      if (segment !== FlightPlanSegment$1.Empty) {
        const finalIndex = segment.offset + segment.waypoints.length;
        if (startIndex < finalIndex) {
          for (let i = startIndex; i < finalIndex; i++) {
            // console.log(' MFP ---> truncateSegment: removing waypoint ', this.getWaypoint(startIndex).ident);
            this.removeWaypoint(startIndex);
          }
        }
      }
      if (segment.waypoints.length === 0) {
        this.removeSegment(segment.type);
        segment = FlightPlanSegment$1.Empty;
      } else {
        const waypoint = segment.waypoints[Math.max(startIndex - 1 - segment.offset, 0)];
        waypoint.endsInDiscontinuity = true;
        waypoint.discontinuityCanBeCleared = true;
      }
      return {
        _startIndex: startIndex,
        segment
      };
    }

    /**
     * Converts a plain object into a ManagedFlightPlan.
     * @param flightPlanObject The object to convert.
     * @param parentInstrument The parent instrument attached to this flight plan.
     * @returns The converted ManagedFlightPlan.
     */
    static fromObject(flightPlanObject, parentInstrument) {
      const plan = Object.assign(new ManagedFlightPlan(), flightPlanObject);
      plan.setParentInstrument(parentInstrument);
      plan.directTo = Object.assign(new DirectTo(), plan.directTo);
      const mapObject = (obj, parentType) => {
        if (obj && obj.infos) {
          obj = Object.assign(new WayPoint(parentInstrument), obj);
        }
        if (obj && obj.coordinates) {
          switch (parentType) {
            case 'A':
              obj = Object.assign(new AirportInfo(parentInstrument), obj);
              break;
            case 'W':
              obj = Object.assign(new IntersectionInfo(parentInstrument), obj);
              break;
            case 'V':
              obj = Object.assign(new VORInfo(parentInstrument), obj);
              break;
            case 'N':
              obj = Object.assign(new NDBInfo(parentInstrument), obj);
              break;
            default:
              obj = Object.assign(new WayPointInfo(parentInstrument), obj);
          }
          obj.coordinates = Object.assign(new LatLongAlt(), obj.coordinates);
        }
        return obj;
      };
      const visitObject = obj => {
        for (const key in obj) {
          if (typeof obj[key] === 'object' && obj[key] && obj[key].scroll === undefined) {
            if (Array.isArray(obj[key])) {
              visitArray(obj[key]);
            } else {
              visitObject(obj[key]);
            }
            obj[key] = mapObject(obj[key], obj.type);
          }
        }
      };
      const visitArray = array => {
        array.forEach((item, index) => {
          if (Array.isArray(item)) {
            visitArray(item);
          } else if (typeof item === 'object') {
            visitObject(item);
          }
          array[index] = mapObject(item);
        });
      };
      visitObject(plan);
      return plan;
    }
    legDataMatches(a, b, fields) {
      return fields.every(field => a.additionalData[field] === b.additionalData[field]);
    }
    isLegDuplicate(a, b) {
      if (a.additionalData.legType === b.additionalData.legType) {
        switch (a.additionalData.legType) {
          case LegType$1.AF:
          case LegType$1.CR:
          case LegType$1.VR:
            return this.legDataMatches(a, b, ['course', 'theta', 'recommendedIcao']);
          case LegType$1.CA:
          case LegType$1.VA:
            return this.legDataMatches(a, b, ['course']) && a.legAltitude1 === b.legAltitude1;
          case LegType$1.CD:
          case LegType$1.VD:
            return this.legDataMatches(a, b, ['course', 'distance', 'recommendedIcao']);
          case LegType$1.CF:
            return this.legDataMatches(a, b, ['course']) && a.icao === b.icao;
          case LegType$1.CI:
          case LegType$1.VI:
          case LegType$1.VM:
            return this.legDataMatches(a, b, ['course']);
          case LegType$1.DF:
          case LegType$1.IF:
          case LegType$1.TF:
            return a.icao === b.icao;
          case LegType$1.FA:
            return a.icao === b.icao && a.legAltitude1 === b.legAltitude1;
          case LegType$1.FC:
            return this.legDataMatches(a, b, ['course', 'distance']) && a.icao === b.icao;
          case LegType$1.FD:
            return this.legDataMatches(a, b, ['course', 'distance', 'recommendedIcao']) && a.icao === b.icao;
          case LegType$1.FM:
            return this.legDataMatches(a, b, ['course']) && a.icao === b.icao;
          case LegType$1.HA:
            return this.legDataMatches(a, b, ['course', 'distance', 'distanceInMinutes']) && a.icao === b.icao && a.legAltitude1 === b.legAltitude1;
          case LegType$1.HF:
          case LegType$1.HM:
          case LegType$1.PI:
            return this.legDataMatches(a, b, ['course', 'distance', 'distanceInMinutes']) && a.icao === b.icao;
          case LegType$1.RF:
            return this.legDataMatches(a, b, ['center', 'radius']) && a.icao === b.icao;
        }
      } else if (ManagedFlightPlan.isXfLeg(a) && ManagedFlightPlan.isXfLeg(b) || ManagedFlightPlan.isFxLeg(a) && ManagedFlightPlan.isFxLeg(b)) {
        return a.icao === b.icao;
      }
      return false;
    }
    addWaypointAvoidingDuplicates(waypoint, waypointIndex, segment) {
      const index = this.waypoints.findIndex(wp => this.isLegDuplicate(waypoint, wp));

      // FIXME this should collapse any legs between the old position and the newly inserted position
      const wptDist = Math.abs(index - waypointIndex);
      if (index !== -1 && wptDist <= 2) {
        // console.log('  -------> MFP: addWaypointAvoidingDuplicates: removing duplicate waypoint ', this.getWaypoint(index).ident);
        const removedWp = this.getWaypoint(index);
        if (waypoint.legAltitudeDescription === AltitudeDescriptor.Empty && removedWp.legAltitudeDescription !== AltitudeDescriptor.Empty) {
          waypoint.legAltitudeDescription = removedWp.legAltitudeDescription;
          waypoint.legAltitude1 = removedWp.legAltitude1;
          waypoint.legAltitude2 = removedWp.legAltitude2;
        }
        if (waypoint.speedConstraint <= 0 && removedWp.speedConstraint > 0) {
          waypoint.speedConstraint = removedWp.speedConstraint;
        }
        this.removeWaypoint(index);
      }
      this.addWaypoint(waypoint, waypointIndex, segment.type);
    }
    getOriginRunway() {
      if (this.originAirfield) {
        if (this.procedureDetails.originRunwayIndex >= 0) {
          return this.originAirfield.infos.oneWayRunways[this.procedureDetails.originRunwayIndex];
        }
      }
      return null;
    }
    getDestinationRunway() {
      if (this.destinationAirfield) {
        if (this.procedureDetails.destinationRunwayIndex >= 0) {
          return this.destinationAirfield.infos.oneWayRunways[this.procedureDetails.destinationRunwayIndex];
        }
      }
      return null;
    }
    get manualHoldActive() {
      var _this$waypoints$this$, _this$waypoints$this$2;
      return ((_this$waypoints$this$ = this.waypoints[this.activeWaypointIndex]) === null || _this$waypoints$this$ === void 0 ? void 0 : (_this$waypoints$this$2 = _this$waypoints$this$.additionalData) === null || _this$waypoints$this$2 === void 0 ? void 0 : _this$waypoints$this$2.legType) === LegType$1.HM;
    }
    get glideslopeIntercept() {
      const appr = this.getSegment(SegmentType.Approach);
      for (const wp of appr.waypoints) {
        if (wp.additionalData.fixTypeFlags & FixTypeFlags$1.FAF && (wp.legAltitudeDescription === AltitudeDescriptor.G || wp.legAltitudeDescription === AltitudeDescriptor.H)) {
          return wp.legAltitude1;
        }
      }
      return undefined;
    }
    get destinationIndex() {
      const appr = this.getSegment(SegmentType.Approach);
      const index = appr.offset + appr.waypoints.length;
      if (this.destinationAirfield) {
        return index + 1;
      }
      return -1;
    }
    get finalApproachActive() {
      const appr = this.getSegment(SegmentType.Approach);
      if (appr === FlightPlanSegment$1.Empty) {
        return false;
      }
      const offset = this.activeWaypointIndex - appr.offset;
      if (offset >= 0 && offset < appr.waypoints.length) {
        for (const [index, wp] of appr.waypoints.entries()) {
          if (wp.additionalData.fixTypeFlags & FixTypeFlags$1.FAF) {
            return offset >= index;
          }
        }
      }
      return false;
    }

    /**
     * Rounds a number to the nearest multiple
     * @param n the number to round
     * @param r the multiple
     * @returns n rounded to the nereast multiple of r, or null/undefined if n is null/undefined
     */
    static round(n) {
      let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (n === undefined || n === null) {
        return n;
      }
      return Math.round(n / r) * r;
    }
    setOriginDefaults(airport) {
      const referenceAltitude = airport.infos.elevation;
      if (referenceAltitude !== undefined) {
        this.thrustReductionAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_THR_RED_ALT", "1500"));
        this.accelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ACCEL_ALT", "1500"));
        this.engineOutAccelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ENG_OUT_ACCEL_ALT", "1500"));
      } else {
        this.thrustReductionAltitudeDefault = undefined;
        this.accelerationAltitudeDefault = undefined;
        this.engineOutAccelerationAltitudeDefault = undefined;
      }
      this.thrustReductionAltitudePilot = undefined;
      this.accelerationAltitudePilot = undefined;
      this.engineOutAccelerationAltitudePilot = undefined;
    }
    setDestinationDefaults(airport) {
      const referenceAltitude = airport.infos.elevation;
      if (referenceAltitude !== undefined) {
        this.missedThrustReductionAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_THR_RED_ALT", "1500"));
        this.missedAccelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ACCEL_ALT", "1500"));
        this.missedEngineOutAccelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ENG_OUT_ACCEL_ALT", "1500"));
      } else {
        this.missedThrustReductionAltitudeDefault = undefined;
        this.missedAccelerationAltitudeDefault = undefined;
        this.missedEngineOutAccelerationAltitudeDefault = undefined;
      }
      this.missedThrustReductionAltitudePilot = undefined;
      this.missedAccelerationAltitudePilot = undefined;
      this.missedEngineOutAccelerationAltitudePilot = undefined;
    }

    /**
     * Thrust reduction altitude for the origin airport
     * @returns altitude in feet MSL, or undefined if none
     */
    get thrustReductionAltitude() {
      var _this$thrustReduction;
      return ManagedFlightPlan.round((_this$thrustReduction = this.thrustReductionAltitudePilot) !== null && _this$thrustReduction !== void 0 ? _this$thrustReduction : this.thrustReductionAltitudeDefault, 10);
    }

    /**
     * Check if the thrust reduction altitude is derived from a pilot entry
     * @returns true if pilot entry
     */
    get isThrustReductionAltitudePilotEntered() {
      return this.thrustReductionAltitudePilot !== undefined;
    }

    /**
     * Check if a default thrust reduction altitude is available
     * @returns true if default is available
     */
    get hasThrustReductionAltitudeDefault() {
      return this.thrustReductionAltitudeDefault !== undefined;
    }

    /**
     * Acceleration altitude for the origin airport
     * @returns altitude in feet MSL, or undefined if none
     */
    get accelerationAltitude() {
      var _this$accelerationAlt;
      return ManagedFlightPlan.round((_this$accelerationAlt = this.accelerationAltitudePilot) !== null && _this$accelerationAlt !== void 0 ? _this$accelerationAlt : this.accelerationAltitudeDefault, 10);
    }

    /**
     * Check if the acceleration altitude is derived from a pilot entry
     * @returns true if pilot entry
     */
    get isAccelerationAltitudePilotEntered() {
      return this.accelerationAltitudePilot !== undefined;
    }

    /**
     * Check if a default acceleration altitude is available
     * @returns true if default is available
     */
    get hasAccelerationAltitudeDefault() {
      return this.accelerationAltitudeDefault !== undefined;
    }

    /**
     * Engine out acceleration altitude for the origin airport
     * @returns altitude in feet MSL, or undefined if none
     */
    get engineOutAccelerationAltitude() {
      var _this$engineOutAccele;
      return ManagedFlightPlan.round((_this$engineOutAccele = this.engineOutAccelerationAltitudePilot) !== null && _this$engineOutAccele !== void 0 ? _this$engineOutAccele : this.engineOutAccelerationAltitudeDefault, 10);
    }

    /**
     * Check if the engine out acceleration altitude is derived from a pilot entry
     * @returns true if pilot entry
     */
    get isEngineOutAccelerationAltitudePilotEntered() {
      return this.engineOutAccelerationAltitudePilot !== undefined;
    }

    /**
     * Check if a default engine out acceleration altitude is available
     * @returns true if default is available
     */
    get hasEngineOutAccelerationAltitudeDefault() {
      return this.engineOutAccelerationAltitudeDefault !== undefined;
    }

    /**
     * Missed approach thrust reduction altitude for the destination airport
     * @returns altitude in feet MSL, or undefined if none
     */
    get missedThrustReductionAltitude() {
      var _this$missedThrustRed;
      return ManagedFlightPlan.round((_this$missedThrustRed = this.missedThrustReductionAltitudePilot) !== null && _this$missedThrustRed !== void 0 ? _this$missedThrustRed : this.missedThrustReductionAltitudeDefault, 10);
    }

    /**
     * Check if the missed approach thrust reduction altitude is derived from a pilot entry
     * @returns true if pilot entry
     */
    get isMissedThrustReductionAltitudePilotEntered() {
      return this.missedThrustReductionAltitudePilot !== undefined;
    }

    /**
     * Check if a default missed approach thrust reduction altitude is available
     * @returns true if default is available
     */
    get hasMissedThrustReductionAltitudeDefault() {
      return this.missedThrustReductionAltitudeDefault !== undefined;
    }

    /**
     * Missed approach acceleration altitude for the origin airport
     * @returns altitude in feet MSL, or undefined if none
     */
    get missedAccelerationAltitude() {
      var _this$missedAccelerat;
      return ManagedFlightPlan.round((_this$missedAccelerat = this.missedAccelerationAltitudePilot) !== null && _this$missedAccelerat !== void 0 ? _this$missedAccelerat : this.missedAccelerationAltitudeDefault, 10);
    }

    /**
     * Check if the missed approach acceleration altitude is derived from a pilot entry
     * @returns true if pilot entry
     */
    get isMissedAccelerationAltitudePilotEntered() {
      return this.missedAccelerationAltitudePilot !== undefined;
    }

    /**
     * Check if a default missed approach acceleration altitude is available
     * @returns true if default is available
     */
    get hasMissedAccelerationAltitudeDefault() {
      return this.missedAccelerationAltitudeDefault !== undefined;
    }

    /**
     * Missed approach engine outacceleration altitude for the origin airport
     * @returns altitude in feet MSL, or undefined if none
     */
    get missedEngineOutAccelerationAltitude() {
      var _this$missedEngineOut;
      return ManagedFlightPlan.round((_this$missedEngineOut = this.missedEngineOutAccelerationAltitudePilot) !== null && _this$missedEngineOut !== void 0 ? _this$missedEngineOut : this.missedEngineOutAccelerationAltitudeDefault, 10);
    }

    /**
     * Check if the missed approach engine out acceleration altitude is derived from a pilot entry
     * @returns true if pilot entry
     */
    get isMissedEngineOutAccelerationAltitudePilotEntered() {
      return this.missedEngineOutAccelerationAltitudePilot !== undefined;
    }

    /**
     * Check if a default missed approach engine out acceleration altitude is available
     * @returns true if default is available
     */
    get hasMissedEngineOutAccelerationAltitudeDefault() {
      return this.missedEngineOutAccelerationAltitudeDefault !== undefined;
    }

    /**
     * Finds the lowest climb constraint in the flight plan
     * @returns the lowest climb constraint in feet or Infinity if none
     */
    lowestClimbConstraint() {
      let lowestClimbConstraint = Infinity;
      for (const wp of this.waypoints) {
        const climbConstraint = wp.additionalData.constraintType === WaypointConstraintType.CLB ? ManagedFlightPlan.climbConstraint(wp) : Infinity;
        if (climbConstraint < lowestClimbConstraint) {
          lowestClimbConstraint = climbConstraint;
        }
      }
      return lowestClimbConstraint;
    }

    /**
     * Check if the thrust reduction altitude is limited by a constraint and reduce it if so
     * @returns true if a reduction occured
     */
    reconcileThrustReductionWithConstraints() {
      const lowestClimbConstraint = this.lowestClimbConstraint();
      if (isFinite(lowestClimbConstraint) && this.thrustReductionAltitude > lowestClimbConstraint) {
        this.thrustReductionAltitudeDefault = this.thrustReductionAltitudeDefault !== undefined ? Math.min(this.thrustReductionAltitudeDefault, lowestClimbConstraint) : undefined;
        this.thrustReductionAltitudePilot = this.thrustReductionAltitudePilot !== undefined ? Math.min(this.thrustReductionAltitudePilot, lowestClimbConstraint) : undefined;
        return true;
      }
      return false;
    }

    /**
     * Check if the acceleration altitude is limited by a constraint and reduce it if so
     * @returns true if a reduction occured
     */
    reconcileAccelerationWithConstraints() {
      const lowestClimbConstraint = this.lowestClimbConstraint();
      if (isFinite(lowestClimbConstraint) && this.accelerationAltitude > lowestClimbConstraint) {
        this.accelerationAltitudeDefault = this.accelerationAltitudeDefault !== undefined ? Math.min(this.accelerationAltitudeDefault, lowestClimbConstraint) : undefined;
        this.accelerationAltitudePilot = this.accelerationAltitudePilot !== undefined ? Math.min(this.accelerationAltitudePilot, lowestClimbConstraint) : undefined;
        return true;
      }
      return false;
    }
    addOrUpdateCruiseStep(waypoint, toAltitude, waypointIndex) {
      if (!waypointIndex) {
        waypointIndex = this.findWaypointIndexByIdent(waypoint.ident);
      }
      const step = {
        distanceBeforeTermination: 0,
        toAltitude,
        waypointIndex,
        isIgnored: false
      };

      // TODO: Handle optimum steps
      waypoint.additionalData.cruiseStep = step;
    }
    removeCruiseStep(waypoint) {
      waypoint.additionalData.cruiseStep = undefined;
    }
    findWaypointIndexByIdent(ident) {
      return this.waypoints.findIndex(waypoint => waypoint.ident === ident);
    }
    unignoreAllCruiseSteps() {
      this.cruiseStepWaypoints.forEach(step => step.additionalData.cruiseStep.isIgnored = false);
    }
  }

  /*
   * MIT License
   *
   * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */

  /** A class for syncing a flight plan with the game */
  class FlightPlanAsoboSync {
    static init() {
      if (!this.fpListenerInitialized) {
        RegisterViewListener('JS_LISTENER_FLIGHTPLAN');
        this.fpListenerInitialized = true;
      }
    }
    static async LoadFromGame(fpln) {
      return new Promise(resolve => {
        this.init();
        setTimeout(() => {
          Coherent.call('LOAD_CURRENT_GAME_FLIGHT').catch(console.error);
          Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN').catch(console.error);
          setTimeout(() => {
            Coherent.call('GET_FLIGHTPLAN').then(async data => {
              console.log('COHERENT GET_FLIGHTPLAN received:');
              console.log('Data from MSFS flight plan:', data);

              // Purpose unclear
              // TODO: talk to matt about dirto
              const {
                isDirectTo
              } = data;
              if (isDirectTo) {
                return;
              }

              // Mid air flight plan loading not yet supported - return if first waypoint is not an airport
              // TODO FIXME: better handling of mid-air spawning and syncing fpln
              if (data.waypoints.length === 0 || data.waypoints[0].icao[0] !== 'A') {
                fpln.resumeSync();
                resolve();
                return;
              }

              // result dismissed - why??
              // assumption: counter timeout issues when reading facility from MSFS?
              await fpln._parentInstrument.facilityLoader.getFacilityRaw(data.waypoints[0].icao, 10000).catch(e => {
                console.error('[FP LOAD] Error getting first wp data');
                console.error(e);
              });

              // set origin
              await fpln.setOrigin(data.waypoints[0].icao).catch(e => {
                console.error('[FP LOAD] Error setting origin');
                console.error(e);
              });

              // set dest
              await fpln.setDestination(data.waypoints[data.waypoints.length - 1].icao).catch(e => {
                console.error('[FP LOAD] Error setting Destination');
                console.error(e);
              });

              // set route
              const enrouteStart = data.departureWaypointsSize === -1 ? 1 : data.departureWaypointsSize;
              // Find out first approach waypoint, - 1 to skip destination
              const enrouteEnd = data.waypoints.length - (data.arrivalWaypointsSize === -1 ? 0 : data.arrivalWaypointsSize) - 1;
              const enroute = data.waypoints.slice(enrouteStart, enrouteEnd);
              for (let i = 0; i < enroute.length; i++) {
                const wpt = enroute[i];
                if (wpt.icao.trim() !== '') {
                  // Without the 'await' the order of import is undefined and the flight plan waypoints
                  // are not in the correct order
                  // eslint-disable-next-line no-await-in-loop
                  await fpln.addWaypoint(wpt.icao, Infinity, () => {
                    // console.log(`[FP LOAD] Adding [${wpt.icao}]... SUCCESS`);
                  }).catch(console.error);
                }
              }

              // set departure
              //  rwy index
              await fpln.setDepartureRunwayIndex(data.departureRunwayIndex)
              // .then(() => console.log(`[FP LOAD] Setting Departure Runway ${data.departureRunwayIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Departure Runway ".concat(data.departureRunwayIndex, " ... FAILED"));
                console.error(e);
              });
              // proc index
              await fpln.setDepartureProcIndex(data.departureProcIndex)
              // .then(() => console.log(`[FP LOAD] Setting Departure Procedure  ${data.departureProcIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Departure Procedure ".concat(data.departureProcIndex, " ... FAILED"));
                console.error(e);
              });
              // origin runway
              if (data.originRunwayIndex !== -1) {
                await fpln.setOriginRunwayIndex(data.originRunwayIndex)
                // .then(() => console.log(`[FP LOAD] Setting Origin  ${data.originRunwayIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Origin ".concat(data.originRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
              } else if (data.departureRunwayIndex !== -1 && data.departureProcIndex !== -1) {
                await fpln.setOriginRunwayIndexFromDeparture()
                // .then(() => console.log(`[FP LOAD] Setting Origin using ${data.departureProcIndex}/${data.departureRunwayIndex}... SUCCESS`))
                .catch(e => {
                  console.error("[FP LOAD] Setting Origin using ".concat(data.departureProcIndex, "/").concat(data.departureRunwayIndex, " ... FAILED"));
                  console.error(e);
                });
              }
              //  enroutetrans index
              await fpln.setDepartureEnRouteTransitionIndex(data.departureEnRouteTransitionIndex)
              // .then(() => console.log(`[FP LOAD] Setting Departure En Route Transition ${data.departureEnRouteTransitionIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Departure En Route Transition ".concat(data.departureEnRouteTransitionIndex, " ... FAILED"));
                console.error(e);
              });
              // set approach
              //  rwy index
              await fpln.setArrivalRunwayIndex(data.arrivalRunwayIndex)
              // .then(() => console.log(`[FP LOAD] Setting Arrival Runway ${data.arrivalRunwayIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Arrival Runway ".concat(data.arrivalRunwayIndex, " ... FAILED"));
                console.error(e);
              });
              //  approach index
              await fpln.setApproachIndex(data.approachIndex)
              // .then(() => console.log(`[FP LOAD] Setting Approach ${data.approachIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Approach ".concat(data.approachIndex, " ... FAILED"));
                console.error(e);
              });
              //  approachtrans index
              await fpln.setApproachTransitionIndex(data.approachTransitionIndex)
              // .then(() => console.log(`[FP LOAD] Setting Approach Transition ${data.approachTransitionIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Approach Transition ".concat(data.approachTransitionIndex, " ... FAILED"));
                console.error(e);
              });

              // set arrival
              //  arrivalproc index
              await fpln.setArrivalProcIndex(data.arrivalProcIndex)
              // .then(() => console.log(`[FP LOAD] Setting Arrival Procedure ${data.arrivalProcIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Arrival Procedure ".concat(data.arrivalProcIndex, " ... FAILED"));
                console.error(e);
              });
              //  arrivaltrans index
              await fpln.setArrivalEnRouteTransitionIndex(data.arrivalEnRouteTransitionIndex)
              // .then(() => console.log(`[FP LOAD] Setting En Route Transition ${data.arrivalEnRouteTransitionIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting En Route Transition ".concat(data.arrivalEnRouteTransitionIndex, " ... FAILED"));
                console.error(e);
              });
              await fpln.setDestinationRunwayIndexFromApproach()
              // .then(() => console.log(`[FP LOAD] Setting Destination Runway using ${data.approachIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP LOAD] Setting Destination Runway using ".concat(data.approachIndex, " ... FAILED"));
                console.error(e);
              });
              fpln.resumeSync();
              this.fpChecksum = fpln.getCurrentFlightPlan().checksum;

              // Potential CTD source?
              Coherent.call('SET_ACTIVE_WAYPOINT_INDEX', 0).catch(e => console.error('[FP LOAD] Error when setting Active WP', e));
              Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch(e => console.error('[FP LOAD] Error when recomputing Active WP', e));
              resolve();
              console.log('Resulting aircraft flight plan: ', fpln);
            }).catch(console.error);
          }, 500);
        }, 200);
      });
    }
    static async SaveToGame(fpln) {
      return __awaiter(this, 0, 0, function* () {
        return new Promise(() => __awaiter(this, 0, 0, function* () {
          FlightPlanAsoboSync.init();
          const plan = fpln.getCurrentFlightPlan();
          if (plan.checksum !== this.fpChecksum) {
            // await Coherent.call("CREATE_NEW_FLIGHTPLAN").catch(console.error);
            yield Coherent.call('SET_CURRENT_FLIGHTPLAN_INDEX', 0, false).catch(console.error);
            yield Coherent.call('CLEAR_CURRENT_FLIGHT_PLAN').catch(console.error);
            if (plan.hasPersistentOrigin && plan.hasDestination) {
              yield Coherent.call('SET_ORIGIN', plan.persistentOriginAirfield.icao, false).catch(console.error);
              // .then(() => console.log('[FP SAVE] Setting Origin Airfield... SUCCESS'));
              yield Coherent.call('SET_DESTINATION', plan.destinationAirfield.icao, false).catch(console.error);
              // .then(() => console.log('[FP SAVE] Setting Destination Airfield... SUCCESS'));
              let coIndex = 1;
              for (let i = 0; i < plan.enroute.waypoints.length; i++) {
                const wpt = plan.enroute.waypoints[i];
                if (wpt.icao.trim() !== '') {
                  yield Coherent.call('ADD_WAYPOINT', wpt.icao, coIndex, false).catch(console.error);
                  // .then(() => console.log(`[FP SAVE] Adding Waypoint [${wpt.icao}]... SUCCESS`));
                  coIndex++;
                }
              }
              yield Coherent.call('SET_ORIGIN_RUNWAY_INDEX', plan.procedureDetails.originRunwayIndex)
              // .then(() => console.log(`[FP SAVE] Setting Origin Runway ${plan.procedureDetails.originRunwayIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting Origin Runway ".concat(plan.procedureDetails.originRunwayIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_DEPARTURE_RUNWAY_INDEX', plan.procedureDetails.departureRunwayIndex)
              // .then(() => console.log(`[FP SAVE] Setting Departure Runway ${plan.procedureDetails.departureRunwayIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting Departure Runway ".concat(plan.procedureDetails.departureRunwayIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_DEPARTURE_PROC_INDEX', plan.procedureDetails.departureIndex)
              // .then(() => console.log(`[FP SAVE] Setting Departure Procedure ${plan.procedureDetails.departureIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting Departure Procedure ".concat(plan.procedureDetails.departureIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_DEPARTURE_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.departureTransitionIndex)
              // .then(() => console.log(`[FP SAVE] Setting Departure Transition ${plan.procedureDetails.departureTransitionIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting Departure Transition ".concat(plan.procedureDetails.departureTransitionIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_ARRIVAL_RUNWAY_INDEX', plan.procedureDetails.arrivalRunwayIndex)
              // .then(() => console.log(`[FP SAVE] Setting Arrival Runway ${plan.procedureDetails.arrivalRunwayIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting  Arrival Runway ".concat(plan.procedureDetails.arrivalRunwayIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_ARRIVAL_PROC_INDEX', plan.procedureDetails.arrivalIndex)
              // .then(() => console.log(`[FP SAVE] Setting Arrival Procedure ${plan.procedureDetails.arrivalIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting Arrival Procedure ".concat(plan.procedureDetails.arrivalIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_ARRIVAL_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.arrivalTransitionIndex)
              // .then(() => console.log(`[FP SAVE] Setting Arrival En Route Transition ${plan.procedureDetails.arrivalTransitionIndex} ... SUCCESS`))
              .catch(e => {
                console.error("[FP SAVE] Setting Arrival En Route Transition ".concat(plan.procedureDetails.arrivalTransitionIndex, " ... FAILED"));
                console.error(e);
              });
              yield Coherent.call('SET_APPROACH_INDEX', plan.procedureDetails.approachIndex).then(() => {
                // console.log(`[FP SAVE] Setting Approach ${plan.procedureDetails.approachIndex} ... SUCCESS`);
                Coherent.call('SET_APPROACH_TRANSITION_INDEX', plan.procedureDetails.approachTransitionIndex)
                // .then(() => console.log(`[FP SAVE] Setting Approach Transition ${plan.procedureDetails.approachTransitionIndex} ... SUCCESS`))
                .catch(e => {
                  console.error("[FP SAVE] Setting Approach Transition ".concat(plan.procedureDetails.approachTransitionIndex, " ... FAILED"));
                  console.error(e);
                });
              }).catch(e => {
                console.error("[FP SAVE] Setting Approach ".concat(plan.procedureDetails.approachIndex, " ... FAILED"));
                console.error(e);
              });
            }
            this.fpChecksum = plan.checksum;
          }
          Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX')
          // .then(() => console.log('[FP SAVE] Setting Active Waypoint... SUCCESS'))
          .catch(e => console.log('[FP SAVE] Setting Active Waypoint... FAILED: ', e));
        }));
      });
    }
  }
  _defineProperty(FlightPlanAsoboSync, "fpChecksum", 0);
  _defineProperty(FlightPlanAsoboSync, "fpListenerInitialized", false);
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(resolve => {
        resolve(value);
      });
    }
    return new (P || (P = Promise))((resolve, reject) => {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  // Copyright (c) 2021 FlyByWire Simulations
  // SPDX-License-Identifier: GPL-3.0

  class FixInfo {
    constructor(flightPlanManager) {
      _defineProperty(this, "flightPlanManager", void 0);
      _defineProperty(this, "refFix", void 0);
      _defineProperty(this, "radials", []);
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "abeam", false);
      this.flightPlanManager = flightPlanManager;
    }
    setRefFix(fix) {
      this.radials.length = 0;
      this.radius = undefined;
      this.abeam = false;
      this.refFix = fix;
      this.flightPlanManager.updateFlightPlanVersion();
    }
    getRefFix() {
      return this.refFix;
    }
    getRefFixIdent() {
      var _this$refFix;
      return (_this$refFix = this.refFix) === null || _this$refFix === void 0 ? void 0 : _this$refFix.ident;
    }
    setRadial(index, magneticBearing) {
      if (magneticBearing !== undefined) {
        const trueBearing = Avionics.Utils.clampAngle(magneticBearing + Facilities.getMagVar(this.refFix.infos.coordinates.lat, this.refFix.infos.coordinates.long));
        this.radials[index] = {
          magneticBearing,
          trueBearing
        };
      } else {
        this.radials.splice(index, 1);
      }
      // TODO calculate flight plan intercepts
      this.flightPlanManager.updateFlightPlanVersion();
    }
    getRadial(index) {
      return this.radials[index];
    }
    getRadialTrueBearings() {
      return this.radials.map(r => r.trueBearing);
    }
    setRadius(radius) {
      if (radius !== undefined) {
        this.radius = {
          radius
        };
      } else {
        this.radius = undefined;
      }
      // TODO calculate flight plan intercepts
      this.flightPlanManager.updateFlightPlanVersion();
    }
    getRadius() {
      return this.radius;
    }
    getRadiusValue() {
      var _this$radius;
      return (_this$radius = this.radius) === null || _this$radius === void 0 ? void 0 : _this$radius.radius;
    }
  }

  let WaypointConstraintType$1 = /*#__PURE__*/function (WaypointConstraintType) {
    WaypointConstraintType[WaypointConstraintType["CLB"] = 1] = "CLB";
    WaypointConstraintType[WaypointConstraintType["DES"] = 2] = "DES";
    return WaypointConstraintType;
  }({});
  let FlightPlans = /*#__PURE__*/function (FlightPlans) {
    FlightPlans[FlightPlans["Active"] = 0] = "Active";
    FlightPlans[FlightPlans["Temporary"] = 1] = "Temporary";
    return FlightPlans;
  }({});

  /**
   * Navigation flight areas defined in the OPC database
   */
  let FlightArea = /*#__PURE__*/function (FlightArea) {
    FlightArea[FlightArea["Terminal"] = 0] = "Terminal";
    FlightArea[FlightArea["Takeoff"] = 1] = "Takeoff";
    FlightArea[FlightArea["Enroute"] = 2] = "Enroute";
    FlightArea[FlightArea["Oceanic"] = 3] = "Oceanic";
    FlightArea[FlightArea["VorApproach"] = 4] = "VorApproach";
    FlightArea[FlightArea["GpsApproach"] = 5] = "GpsApproach";
    FlightArea[FlightArea["PrecisionApproach"] = 6] = "PrecisionApproach";
    FlightArea[FlightArea["NonPrecisionApproach"] = 7] = "NonPrecisionApproach";
    return FlightArea;
  }({});

  /**
   * A system for managing flight plan data used by various instruments.
   */
  class FlightPlanManager {
    /**
     * Constructs an instance of the FlightPlanManager with the provided
     * parent instrument attached.
     * @param parentInstrument The parent instrument attached to this FlightPlanManager.
     */
    constructor(_parentInstrument) {
      this._parentInstrument = _parentInstrument;
      _defineProperty(this, "_isRegistered", false);
      _defineProperty(this, "_isMaster", false);
      _defineProperty(this, "_isSyncPaused", false);
      _defineProperty(this, "_currentFlightPlanVersion", 0);
      _defineProperty(this, "__currentFlightPlanIndex", 0);
      _defineProperty(this, "activeArea", FlightArea.Terminal);
      /**
       * The current stored flight plan data.
       * @type ManagedFlightPlan[]
       */
      _defineProperty(this, "_flightPlans", []);
      _defineProperty(this, "_fixInfos", []);
      _defineProperty(this, "updateThrottler", new A32NX_Util.UpdateThrottler(2000));
      this._currentFlightPlanVersion = SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number');
      this._loadFlightPlans();
      if (_parentInstrument.instrumentIdentifier === 'A320_Neo_CDU') {
        this._isMaster = true;
        _parentInstrument.addEventListener('FlightStart', async () => {
          const plan = new ManagedFlightPlan();
          plan.setParentInstrument(_parentInstrument);
          this._flightPlans = [];
          this._flightPlans.push(plan);
          if (NXDataStore.get('FP_SYNC', 'LOAD') !== 'NONE') {
            this.pauseSync();
            await FlightPlanAsoboSync.LoadFromGame(this).catch(console.error);
          }
          this.resumeSync();
        });
        for (let i = 0; i < 4; i++) {
          this._fixInfos.push(new FixInfo(this));
        }
      }
      FlightPlanManager.DEBUG_INSTANCE = this;
    }
    get _currentFlightPlanIndex() {
      return this.__currentFlightPlanIndex;
    }
    set _currentFlightPlanIndex(value) {
      this.__currentFlightPlanIndex = value;
    }
    update(deltaTime) {
      if (this.updateThrottler.canUpdate(deltaTime) !== -1) {
        const tmpy = this._flightPlans[FlightPlans.Temporary];
        if (tmpy && this.__currentFlightPlanIndex === FlightPlans.Temporary) {
          if (tmpy.updateTurningPoint()) {
            this.updateFlightPlanVersion();
          }
        }
      }
      this.updateActiveArea();
    }
    onCurrentGameFlightLoaded(_callback) {
      _callback();
    }
    registerListener() {
      // empty
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    addHardCodedConstraints(wp) {
      // empty
    }

    /**
     * Loads sim flight plan data into WayPoint objects for consumption.
     * @param data The flight plan data to load.
     * @param currentWaypoints The waypoints array to modify with the data loaded.
     * @param callback A callback to call when the data has completed loading.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _loadWaypoints(data, currentWaypoints, callback) {
      // empty
    }

    /**
     * Updates the current active waypoint index from the sim.
     */
    async updateWaypointIndex() {
      // const waypointIndex = await Coherent.call("GET_ACTIVE_WAYPOINT_INDEX");
      // this._activeWaypointIndex = waypointIndex;
    }

    /**
     * Scans for updates to the synchronized flight plan and loads them into the flight plan
     * manager if the flight plan is out of date.
     * @param {() => void} callback A callback to call when the update has completed.
     * @param {Boolean} log Whether or not to log the loaded flight plan value.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateFlightPlan() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const flightPlanVersion = SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number');
      if (flightPlanVersion !== this._currentFlightPlanVersion || force) {
        this._loadFlightPlans();
        this._currentFlightPlanVersion = flightPlanVersion;
      }
      callback();
    }

    /**
     * Loads the flight plans from data storage.
     */
    _loadFlightPlans() {
      this._getFlightPlan();
      if (this._flightPlans.length === 0) {
        const newFpln = new ManagedFlightPlan();
        newFpln.setParentInstrument(this._parentInstrument);
        this._flightPlans.push(new ManagedFlightPlan());
      } else {
        this._flightPlans = this._flightPlans.map(fp => ManagedFlightPlan.fromObject(fp, this._parentInstrument));
      }
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateCurrentApproach() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      callback();
    }
    get cruisingAltitude() {
      return 0;
    }
    isCurrentFlightPlanTemporary() {
      return this.getCurrentFlightPlanIndex() === 1;
    }

    /**
     * Gets the index of the currently active flight plan.
     */
    getCurrentFlightPlanIndex() {
      return this._currentFlightPlanIndex;
    }

    /**
     * Switches the active flight plan index to the supplied index.
     * @param index The index to now use for the active flight plan.
     * @param callback A callback to call when the operation has completed.
     */
    setCurrentFlightPlanIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Boolean;
      if (index >= 0 && index < this._flightPlans.length) {
        this._currentFlightPlanIndex = index;
        callback(true);
      } else {
        callback(false);
      }
    }

    /**
     * Creates a new flight plan.
     * @param callback A callback to call when the operation has completed.
     */
    createNewFlightPlan() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      const newFlightPlan = new ManagedFlightPlan();
      newFlightPlan.setParentInstrument(this._parentInstrument);
      this._flightPlans.push(newFlightPlan);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Copies the currently active flight plan into the specified flight plan index.
     * @param index The index to copy the currently active flight plan into.
     * @param callback A callback to call when the operation has completed.
     */
    async copyCurrentFlightPlanInto(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
      const copiedFlightPlan = this._flightPlans[this._currentFlightPlanIndex].copy();
      const {
        activeWaypointIndex
      } = copiedFlightPlan;
      if (this._currentFlightPlanIndex === FlightPlans.Temporary && index === FlightPlans.Active) {
        copiedFlightPlan.waypoints.forEach(wp => delete wp.additionalData.dynamicPpos);
      }
      this._flightPlans[index] = copiedFlightPlan;
      if (index === 0) {
        await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Copies the flight plan at the specified index to the currently active flight plan index.
     * @param index The index to copy into the currently active flight plan.
     * @param callback A callback to call when the operation has completed.
     */
    async copyFlightPlanIntoCurrent(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
      const copiedFlightPlan = this._flightPlans[index].copy();
      const {
        activeWaypointIndex
      } = copiedFlightPlan;
      this._flightPlans[this._currentFlightPlanIndex] = copiedFlightPlan;
      if (this._currentFlightPlanIndex === 0) {
        await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Clears the currently active flight plan.
     * @param callback A callback to call when the operation has completed.
     */
    async clearFlightPlan() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      await this._flightPlans[this._currentFlightPlanIndex].clearPlan().catch(console.error);
      for (const fixInfo of this._fixInfos) {
        fixInfo.setRefFix();
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async deleteFlightPlan(flightPlanIndex) {
      if (this._flightPlans[flightPlanIndex]) {
        delete this._flightPlans[flightPlanIndex];
      }
    }

    /**
     * Gets the origin of the currently active flight plan.
     */
    getOrigin() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      return this._flightPlans[flightPlanIndex].originAirfield;
    }

    /**
     * Gets the origin of the currently active flight plan, even after it has been cleared for a direct-to.
     */
    getPersistentOrigin() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      return this._flightPlans[flightPlanIndex].persistentOriginAirfield;
    }

    /**
     * Sets the origin in the currently active flight plan.
     * @param icao The ICAO designation of the origin airport.
     * @param callback A callback to call when the operation has completed.
     */
    async setOrigin(icao) {
      var _this$getOrigin;
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const sameAirport = ((_this$getOrigin = this.getOrigin()) === null || _this$getOrigin === void 0 ? void 0 : _this$getOrigin.ident) === icao;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const airport = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(console.error);
      if (airport) {
        airport.additionalData = {};
        airport.additionalData.legType = LegType$1.IF;
        await currentFlightPlan.clearPlan().catch(console.error);
        await currentFlightPlan.addWaypoint(airport, 0);
        // clear pilot trans alt
        this.setOriginTransitionAltitude(undefined, false);
        // TODO get origin trans alt from database
        // until then, don't erase the database value from ATSU if same airport as before
        if (!sameAirport) {
          this.setOriginTransitionAltitude(undefined, true);
        }
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Gets the index of the active waypoint in the flight plan.
     * @param forceSimVarCall Unused
     * @param useCorrection Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getActiveWaypointIndex() {
      var _this$_flightPlans$fl, _this$_flightPlans$fl2;
      let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
      }
      return (_this$_flightPlans$fl = (_this$_flightPlans$fl2 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl2 === void 0 ? void 0 : _this$_flightPlans$fl2.activeWaypointIndex) !== null && _this$_flightPlans$fl !== void 0 ? _this$_flightPlans$fl : -1;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isActiveWaypointAtEnd() {
      let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex + 1 === this.getWaypointsCount(this._currentFlightPlanIndex) - 1;
      }
      return this._flightPlans[flightPlanIndex].activeWaypointIndex === this.getWaypointsCount(flightPlanIndex) - 1;
    }

    /**
     * Sets the index of the active waypoint in the flight plan.
     * @param index The index to make active in the flight plan.
     * @param callback A callback to call when the operation has completed.
     * @param fplnIndex The index of the flight plan
     */
    setActiveWaypointIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
      let fplnIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[fplnIndex];
      // we allow the last leg to be sequenced therefore the index can be 1 past the end of the plan length
      if (index >= 0 && index <= currentFlightPlan.length) {
        currentFlightPlan.activeWaypointIndex = index;
        Coherent.call('SET_ACTIVE_WAYPOINT_INDEX', index + 1).catch(console.error);
        if (currentFlightPlan.directTo.isActive && currentFlightPlan.directTo.waypointIsInFlightPlan && currentFlightPlan.activeWaypointIndex > currentFlightPlan.directTo.planWaypointIndex) {
          currentFlightPlan.directTo.isActive = false;
        }
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /** Unknown */
    recomputeActiveWaypointIndex() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      callback();
    }

    /**
     * Gets the index of the waypoint prior to the currently active waypoint.
     * @param forceSimVarCall Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPreviousActiveWaypoint() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const previousWaypointIndex = currentFlightPlan.activeWaypointIndex - 1;
      return currentFlightPlan.getWaypoint(previousWaypointIndex);
    }

    /**
     * Gets the ident of the active waypoint.
     * @param forceSimVarCall Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getActiveWaypointIdent() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.activeWaypoint) {
        return currentFlightPlan.activeWaypoint.ident;
      }
      return '';
    }

    /**
     * Gets the active waypoint index from fs9gps. Currently unimplemented.
     * @param forceSimVarCall Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getGPSActiveWaypointIndex() {
      return this.getActiveWaypointIndex();
    }

    /**
     * Gets the active waypoint.
     * @param forceSimVarCall Unused
     * @param useCorrection Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getActiveWaypoint() {
      let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return this._flightPlans[flightPlanIndex].activeWaypoint;
    }

    /**
     * Gets the next waypoint following the active waypoint.
     * @param forceSimVarCall Unused
     */
    getNextActiveWaypoint() {
      let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
      if (isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      const nextWaypointIndex = currentFlightPlan.activeWaypointIndex + 1;
      return currentFlightPlan.getWaypoint(nextWaypointIndex);
    }

    /**
     * Gets the distance, in NM, to the active waypoint.
     */
    getDistanceToActiveWaypoint() {
      // TODO Replace with ADIRS getLatitude() getLongitude()
      const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      const ll = new LatLongAlt(lat, long);
      const waypoint = this.getActiveWaypoint();
      if (waypoint && waypoint.infos) {
        return Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
      }
      return 0;
    }

    /**
     *
     * @param fplnIndex index of the flight plan of interest, default active fp
     * @returns distance in NM, or -1 on error
     */
    getDistanceToDestination() {
      var _stats$get$distanceFr, _stats$get;
      let fplnIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      if (fplnIndex < 0) {
        fplnIndex = this._currentFlightPlanIndex;
      }
      const destIndex = this.getDestinationIndex();
      if (destIndex < 0) {
        return -1;
      }

      // TODO get proper pos from FMGC
      const fmPos = {
        lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
        long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
      };
      const fpln = this._flightPlans[fplnIndex];
      const stats = fpln.computeWaypointStatistics(fmPos);
      return (_stats$get$distanceFr = (_stats$get = stats.get(destIndex)) === null || _stats$get === void 0 ? void 0 : _stats$get.distanceFromPpos) !== null && _stats$get$distanceFr !== void 0 ? _stats$get$distanceFr : -1;
    }
    getApproachStats() {
      var _this$getApproach;
      const name = (_this$getApproach = this.getApproach(FlightPlans.Active)) === null || _this$getApproach === void 0 ? void 0 : _this$getApproach.name;
      if (!name) {
        return undefined;
      }
      const distanceFromPpos = this.getDistanceToDestination(FlightPlans.Active);
      return {
        name,
        distanceFromPpos
      };
    }

    /**
     * Gets the bearing, in degrees, to the active waypoint.
     */
    getBearingToActiveWaypoint() {
      // TODO Replace with ADIRS getLatitude() getLongitude()
      const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      const ll = new LatLongAlt(lat, long);
      const waypoint = this.getActiveWaypoint();
      if (waypoint && waypoint.infos) {
        return Avionics.Utils.computeGreatCircleHeading(ll, waypoint.infos.coordinates);
      }
      return 0;
    }

    /**
     * Gets the estimated time enroute to the active waypoint.
     */
    getETEToActiveWaypoint() {
      // TODO Replace with ADIRS getLatitude() getLongitude()
      const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      const ll = new LatLongAlt(lat, long);
      const waypoint = this.getActiveWaypoint();
      if (waypoint && waypoint.infos) {
        const dist = Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
        let groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');
        if (groundSpeed < 50) {
          groundSpeed = 50;
        }
        if (groundSpeed > 0.1) {
          return dist / groundSpeed * 3600;
        }
      }
      return 0;
    }

    /**
     * Gets the destination airfield of the current flight plan, if any.
     */
    getDestination() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      return this._flightPlans[flightPlanIndex].destinationAirfield;
    }

    /**
     * Gets the index of the destination airfield in the current flight plan, if any
     * @param flightPlanIndex flight plan index
     * @returns Index of destination
     */
    getDestinationIndex() {
      if (this.getDestination()) {
        return this.getWaypointsCount() - 1;
      }
      return -1;
    }

    /**
     * Gets the currently selected departure information for the current flight plan.
     */
    getDeparture() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
      const origin = this.getOrigin();
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (origin) {
        const originInfos = origin.infos;
        if (originInfos.departures !== undefined && currentFlightPlan.procedureDetails.departureIndex >= 0) {
          return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex];
        }
      }
      return undefined;
    }

    /**
     * Gets the currently selected departure information for the current flight plan, even after a direct-to.
     */
    getDepartureName() {
      const origin = this.getPersistentOrigin();
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (origin) {
        const originInfos = origin.infos;
        if (originInfos.departures !== undefined && currentFlightPlan.procedureDetails.departureIndex >= 0) {
          return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex].name;
        }
      }
      return undefined;
    }

    /**
     * Gets the currently selected arrival information for the current flight plan.
     */
    getArrival() {
      const destination = this.getDestination();
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (destination) {
        const originInfos = destination.infos;
        if (originInfos.arrivals !== undefined && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
          return originInfos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex];
        }
      }
      return undefined;
    }

    /**
     * Gets the currently selected approach information for the current flight plan.
     */
    getAirportApproach() {
      const destination = this.getDestination();
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (destination) {
        const originInfos = destination.infos;
        if (originInfos.approaches !== undefined && currentFlightPlan.procedureDetails.approachIndex >= 0) {
          return originInfos.approaches[currentFlightPlan.procedureDetails.approachIndex];
        }
      }
      return undefined;
    }

    /**
     * Gets the departure waypoints for the current flight plan.
     */
    getDepartureWaypoints() {
      return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
    }

    /**
     * Gets a map of the departure waypoints (?)
     */
    getDepartureWaypointsMap() {
      return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
    }

    /**
     * Gets the enroute waypoints for the current flight plan.
     * @param outFPIndex An array of waypoint indexes to be pushed to.
     */
    getEnRouteWaypoints(outFPIndex) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const enrouteSegment = currentFlightPlan.enroute;
      if (enrouteSegment !== FlightPlanSegment$1.Empty) {
        for (let i = 0; i < enrouteSegment.waypoints.length; i++) {
          outFPIndex.push(enrouteSegment.offset + i);
        }
      }
      return enrouteSegment.waypoints;
    }

    /**
     * Gets the index of the last waypoint in the enroute segment of the current flight plan.
     */
    getEnRouteWaypointsFirstIndex() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      const enrouteSegment = currentFlightPlan === null || currentFlightPlan === void 0 ? void 0 : currentFlightPlan.enroute;
      return enrouteSegment === null || enrouteSegment === void 0 ? void 0 : enrouteSegment.offset;
    }

    /**
     * Gets the index of the last waypoint in the enroute segment of the current flight plan.
     */
    getEnRouteWaypointsLastIndex() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      const enrouteSegment = currentFlightPlan === null || currentFlightPlan === void 0 ? void 0 : currentFlightPlan.enroute;
      return enrouteSegment ? enrouteSegment.offset + (enrouteSegment.waypoints.length - 1) : null;
    }

    /**
     * Gets the arrival waypoints for the current flight plan.
     */
    getArrivalWaypoints() {
      return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
    }

    /**
     * Gets the arrival waypoints for the current flight plan as a map. (?)
     */
    getArrivalWaypointsMap() {
      return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
    }

    /**
     * Gets the waypoints for the current flight plan with altitude constraints.
     */
    getWaypointsWithAltitudeConstraints() {
      return this._flightPlans[this._currentFlightPlanIndex].waypoints;
    }

    /**
     * Gets the flight plan segment for a flight plan waypoint.
     * @param waypoint The waypoint we want to find the segment for.
     */
    getSegmentFromWaypoint(waypoint) {
      let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const index = waypoint === undefined ? this.getActiveWaypointIndex() : this.indexOfWaypoint(waypoint);
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.findSegmentByWaypointIndex(index);
    }

    /**
     * Sets the destination for the current flight plan.
     * @param icao The ICAO designation for the destination airfield.
     * @param callback A callback to call once the operation completes.
     */
    async setDestination(icao) {
      var _this$getDestination;
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const sameAirport = ((_this$getDestination = this.getDestination()) === null || _this$getDestination === void 0 ? void 0 : _this$getDestination.ident) === icao;
      const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao);
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const destinationIndex = currentFlightPlan.length - 1;
      if (currentFlightPlan.hasDestination) {
        currentFlightPlan.removeWaypoint(destinationIndex);
      }
      currentFlightPlan.addWaypoint(waypoint);

      // make the waypoint before a discontinuity
      /*
      const { waypoints } = currentFlightPlan;
      if (waypoints.length > 0 && destinationIndex > 0) {
          const previous = currentFlightPlan.waypoints[destinationIndex - 1];
          // ensure we do not overwrite a possible discontinuityCanBeCleared
          if (!previous.endsInDiscontinuity) {
              previous.endsInDiscontinuity = true;
              previous.discontinuityCanBeCleared = true;
          }
      }
      */

      // clear pilot trans level
      this.setDestinationTransitionLevel(undefined, false);
      // TODO get destination trans level from database
      // until then, don't erase the database value from ATSU if same airport as before
      if (!sameAirport) {
        this.setDestinationTransitionLevel(undefined, true);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Adds a waypoint to the current flight plan.
     * @param icao The ICAO designation for the waypoint.
     * @param index The index of the waypoint to add.
     * @param callback A callback to call once the operation completes.
     * @param setActive Whether or not to set the added waypoint as active immediately.
     */
    async addWaypoint(icao) {
      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(e => {
        console.log("addWaypoint: [".concat(icao, "] Error"));
        console.error(e);
      });
      if (waypoint) {
        currentFlightPlan.addWaypoint(waypoint, index);
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }
    }

    /**
     * Adds a user waypoint to the current flight plan.
     * @param waypoint The user waypoint to add.
     * @param index The index to add the waypoint at in the flight plan.
     * @param callback A callback to call once the operation completes.
     */
    async addUserWaypoint(waypoint) {
      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      currentFlightPlan.addWaypoint(waypoint, index);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    setLegAltitudeDescription(waypoint, code) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      if (waypoint) {
        waypoint.legAltitudeDescription = code;
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the altitude constraint for a waypoint in the current flight plan.
     * @param altitude The altitude to set for the waypoint.
     * @param index The index of the waypoint to set.
     * @param callback A callback to call once the operation is complete.
     * @param isDescentConstraint For enroute waypoints, indicates whether constraint is a descent or climb constraint
     */
    setWaypointAltitude(altitude, index) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      let isDescentConstraint = arguments.length > 3 ? arguments[3] : undefined;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        waypoint.legAltitude1 = altitude;
        if (isDescentConstraint !== undefined && !waypoint.additionalData.constraintType) {
          // this propagates through intermediate waypoints
          if (isDescentConstraint) {
            this.setFirstDesConstraintWaypoint(index);
          } else {
            this.setLastClbConstraintWaypoint(index);
          }
        }
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the speed constraint for a waypoint in the current flight plan.
     * @param speed The speed to set for the waypoint.
     * @param index The index of the waypoint to set.
     * @param callback A callback to call once the operation is complete.
     * @param isDescentConstraint For enroute waypoints, indicates whether constraint is a descent or climb constraint
     */
    setWaypointSpeed(speed, index) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      let isDescentConstraint = arguments.length > 3 ? arguments[3] : undefined;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        waypoint.speedConstraint = speed;
        // this propagates through intermediate waypoints
        if (isDescentConstraint) {
          this.setFirstDesConstraintWaypoint(index);
        } else {
          this.setLastClbConstraintWaypoint(index);
        }
        this.updateFlightPlanVersion();
      }
      callback();
    }
    setLastClbConstraintWaypoint(index) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      for (let i = index; i >= 0; i--) {
        const waypoint = currentFlightPlan.getWaypoint(i);
        if (waypoint) {
          waypoint.additionalData.constraintType = WaypointConstraintType$1.CLB;
        }
      }
    }
    setFirstDesConstraintWaypoint(index) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      for (let i = index; i < this.getWaypointsCount(); i++) {
        const waypoint = currentFlightPlan.getWaypoint(i);
        if (waypoint) {
          waypoint.additionalData.constraintType = WaypointConstraintType$1.DES;
        }
      }
    }

    /**
     * Sets additional data on a waypoint in the current flight plan.
     * @param index The index of the waypoint to set additional data for.
     * @param key The key of the data.
     * @param value The value of the data.
     * @param callback A callback to call once the operation is complete.
     */
    setWaypointAdditionalData(index, key, value) {
      let callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        waypoint.additionalData[key] = value;
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Gets additional data on a waypoint in the current flight plan.
     * @param index The index of the waypoint to set additional data for.
     * @param key The key of the data.
     * @param callback A callback to call with the value once the operation is complete.
     */
    getWaypointAdditionalData(index, key) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        callback(waypoint.additionalData[key]);
      } else {
        callback(undefined);
      }
    }

    /**
     * Reverses the currently active flight plan.
     * @param {() => void} callback A callback to call when the operation is complete.
     */
    invertActiveFlightPlan() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      this._flightPlans[this._currentFlightPlanIndex].reverse();
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Not sure what this is supposed to do.
     * @param callback Stuff?
     */
    getApproachIfIcao() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      callback(this.getApproach());
    }

    /**
     * Unused
     * @param {*} _callback Unused
     */
    addFlightPlanUpdateCallback(_callback) {
      // empty
    }

    /**
     * Adds a waypoint to the currently active flight plan by ident(?)
     * @param ident The ident of the waypoint.
     * @param index The index to add the waypoint at.
     * @param callback A callback to call when the operation finishes.
     */
    addWaypointByIdent(ident, index) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyCallback.Void;
      this.addWaypoint(ident, index, callback).catch(console.error);
    }

    /**
     * Removes a waypoint from the currently active flight plan.
     * @param index The index of the waypoint to remove.
     * @param noDiscontinuity Don't create a discontinuity
     * @param callback A callback to call when the operation finishes.
     */
    removeWaypoint(index) {
      let noDiscontinuity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      this._flightPlans[this._currentFlightPlanIndex].removeWaypoint(index, noDiscontinuity);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    addWaypointOverfly(index) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, true);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    removeWaypointOverfly(index) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, false);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
      const holdIndex = this._flightPlans[this._currentFlightPlanIndex].addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold);
      this.updateFlightPlanVersion().catch(console.error);
      return holdIndex;
    }

    /**
     * Truncates a flight plan after a specific waypoint.
     * @param index The index of the first waypoint to remove.
     * @param callback A callback to call when the operation finishes.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    truncateWaypoints(index) {
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      const fp = this._flightPlans[this._currentFlightPlanIndex];
      for (let i = fp.length; i > index; i--) {
        fp.removeWaypoint(index);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Gets the index of a given waypoint in the current flight plan.
     * @param waypoint The waypoint to get the index of.
     */
    indexOfWaypoint(waypoint) {
      return this._flightPlans[this._currentFlightPlanIndex].waypoints.indexOf(waypoint);
    }

    /**
     * Gets the number of waypoints in a flight plan.
     * @param flightPlanIndex The index of the flight plan. If omitted, will get the current flight plan.
     */
    getWaypointsCount() {
      var _this$_flightPlans$fl3, _this$_flightPlans$fl4;
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        var _this$_flightPlans$th, _this$_flightPlans$th2;
        return (_this$_flightPlans$th = (_this$_flightPlans$th2 = this._flightPlans[this._currentFlightPlanIndex]) === null || _this$_flightPlans$th2 === void 0 ? void 0 : _this$_flightPlans$th2.length) !== null && _this$_flightPlans$th !== void 0 ? _this$_flightPlans$th : 0;
      }
      return (_this$_flightPlans$fl3 = (_this$_flightPlans$fl4 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl4 === void 0 ? void 0 : _this$_flightPlans$fl4.length) !== null && _this$_flightPlans$fl3 !== void 0 ? _this$_flightPlans$fl3 : 0;
    }

    /**
     * Gets a count of the number of departure waypoints in the current flight plan.
     */
    getDepartureWaypointsCount() {
      return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints.length;
    }

    /**
     * Gets a count of the number of arrival waypoints in the current flight plan.
     */
    getArrivalWaypointsCount() {
      return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints.length;
    }

    /**
     * Gets a waypoint from a flight plan.
     * @param index The index of the waypoint to get.
     * @param flightPlanIndex The index of the flight plan to get the waypoint from. If omitted, will get from the current flight plan.
     * @param considerApproachWaypoints Whether or not to consider approach waypoints.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getWaypoint(index) {
      var _this$_flightPlans$fl5;
      let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return (_this$_flightPlans$fl5 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl5 === void 0 ? void 0 : _this$_flightPlans$fl5.getWaypoint(index);
    }

    /**
     * Gets all non-approach waypoints from a flight plan.
     *
     * @param flightPlanIndex The index of the flight plan to get the waypoints from. If omitted, will get from the current flight plan.
     */
    getWaypoints() {
      var _this$_flightPlans$fl6, _this$_flightPlans$fl7;
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return (_this$_flightPlans$fl6 = (_this$_flightPlans$fl7 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl7 === void 0 ? void 0 : _this$_flightPlans$fl7.nonApproachWaypoints) !== null && _this$_flightPlans$fl6 !== void 0 ? _this$_flightPlans$fl6 : [];
    }

    /**
     * Gets all waypoints from a flight plan.
     * @param flightPlanIndex The index of the flight plan to get the waypoints from. If omitted, will get from the current flight plan.
     */
    getAllWaypoints(flightPlanIndex) {
      if (flightPlanIndex === undefined) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return this._flightPlans[flightPlanIndex].waypoints;
    }

    /**
     * Gets the departure runway index, based on the departure in a flight plan.
     */
    getDepartureRunwayIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasOrigin) {
        return currentFlightPlan.procedureDetails.departureRunwayIndex;
      }
      return -1;
    }

    /**
     * Gets the index value of the origin runway (oneWayRunways) in a flight plan.
     * @param flightPlanIndex The flight plan to use, or default to the current flight plan being edited
     */
    getOriginRunwayIndex() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (flightPlanIndex === undefined) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (currentFlightPlan.procedureDetails.originRunwayIndex >= 0 && currentFlightPlan.originAirfield) {
        return currentFlightPlan.procedureDetails.originRunwayIndex;
      }
      return -1;
    }

    /**
     * Gets the string value of the departure runway in the current flight plan.
     * @param flightPlanIndex The flight plan to use, or default to the current flight plan being edited
     */
    getOriginRunway() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (flightPlanIndex === undefined) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const runwayIndex = this.getOriginRunwayIndex(flightPlanIndex);
      if (runwayIndex >= 0) {
        var _this$getOrigin2, _this$getOrigin2$info;
        return (_this$getOrigin2 = this.getOrigin()) === null || _this$getOrigin2 === void 0 ? void 0 : (_this$getOrigin2$info = _this$getOrigin2.infos) === null || _this$getOrigin2$info === void 0 ? void 0 : _this$getOrigin2$info.oneWayRunways[runwayIndex];
      }
      return undefined;
    }

    /**
     * Gets the best runway based on the current plane heading.
     */
    getDetectedCurrentRunway() {
      const origin = this.getOrigin();
      if (origin && origin.infos instanceof AirportInfo) {
        const runways = origin.infos.oneWayRunways;
        if (runways && runways.length > 0) {
          const direction = Simplane.getHeadingMagnetic();
          let bestRunway = runways[0];
          let bestDeltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, bestRunway.direction));
          for (let i = 1; i < runways.length; i++) {
            const deltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, runways[i].direction));
            if (deltaAngle < bestDeltaAngle) {
              bestDeltaAngle = deltaAngle;
              bestRunway = runways[i];
            }
          }
          return bestRunway;
        }
      }
      return undefined;
    }

    /**
     * Gets the departure procedure index for the current flight plan.
     */
    getDepartureProcIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.departureIndex;
    }

    /**
     * Sets the departure procedure index for the current flight plan.
     * @param index The index of the departure procedure in the origin airport departures information.
     * @param callback A callback to call when the operation completes.
     */
    async setDepartureProcIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.departureIndex !== index) {
        currentFlightPlan.procedureDetails.departureIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the departure runway index for the current flight plan.
     * @param index The index of the runway in the origin airport runway information.
     * @param callback A callback to call when the operation completes.
     */
    async setDepartureRunwayIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.departureRunwayIndex !== index) {
        currentFlightPlan.procedureDetails.departureRunwayIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the origin runway index for the current flight plan.
     * @param index The index of the runway in the origin airport runway information.
     * @param callback A callback to call when the operation completes.
     */
    async setOriginRunwayIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.originRunwayIndex !== index) {
        currentFlightPlan.procedureDetails.originRunwayIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setOriginRunwayIndexFromDeparture() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasOrigin && currentFlightPlan.procedureDetails.departureRunwayIndex >= 0 && currentFlightPlan.procedureDetails.departureIndex >= 0 && currentFlightPlan.originAirfield) {
        const transition = currentFlightPlan.originAirfield.infos.departures[currentFlightPlan.procedureDetails.departureIndex].runwayTransitions[currentFlightPlan.procedureDetails.departureRunwayIndex];
        const runways = currentFlightPlan.originAirfield.infos.oneWayRunways;
        await this.setOriginRunwayIndex(runways.findIndex(r => r.number === transition.runwayNumber && r.designator === transition.runwayDesignation));
      }
    }

    /**
     * Gets the departure transition index for the current flight plan.
     */
    getDepartureEnRouteTransitionIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.departureTransitionIndex;
    }

    /**
     * Sets the departure transition index for the current flight plan.
     * @param index The index of the departure transition to select.
     * @param callback A callback to call when the operation completes.
     */
    async setDepartureEnRouteTransitionIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.departureTransitionIndex !== index) {
        currentFlightPlan.procedureDetails.departureTransitionIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Unused
     */
    getDepartureDiscontinuity() {
      // empty
    }

    /**
     * Unused
     * @param callback A callback to call when the operation completes.
     */
    clearDepartureDiscontinuity() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      callback();
    }

    /**
     * Removes the departure from the currently active flight plan.
     * @param callback A callback to call when the operation completes.
     */
    async removeDeparture() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      currentFlightPlan.procedureDetails.departureIndex = -1;
      await currentFlightPlan.buildDeparture().catch(console.error);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Gets the arrival procedure index in the currenly active flight plan.
     */
    getArrivalProcIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
        return currentFlightPlan.procedureDetails.arrivalIndex;
      }
      return -1;
    }

    /**
     * Gets the arrival transition procedure index in the currently active flight plan.
     */
    getArrivalTransitionIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.arrivalTransitionIndex;
    }

    /**
     * Sets the arrival procedure index for the current flight plan.
     * @param {Number} index The index of the arrival procedure to select.
     * @param {() => void} callback A callback to call when the operation completes.
     */
    async setArrivalProcIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.arrivalIndex !== index) {
        // console.log('FPM: setArrivalProcIndex: SET STAR ', currentFlightPlan.destinationAirfield.infos.arrivals[index].name);
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
        currentFlightPlan.procedureDetails.arrivalIndex = index;
        currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }

      // TODO check for transition level coded in procedure...
      // pick higher of procedure or destination airfield trans fl

      callback();
    }

    /**
     * Unused
     */
    getArrivalDiscontinuity() {
      // empty
    }

    /**
     * Unused
     * @param {*} callback
     */
    clearArrivalDiscontinuity() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      callback();
    }

    /**
     * Clears a discontinuity from the end of a waypoint.
     * @param index
     */
    clearDiscontinuity(index) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      const nextWaypoint = currentFlightPlan.getWaypoint(index + 1);
      if (waypoint !== undefined && nextWaypoint !== undefined && waypoint.discontinuityCanBeCleared) {
        waypoint.endsInDiscontinuity = false;
        switch (nextWaypoint.additionalData.legType) {
          case LegType$1.FA:
          case LegType$1.FC:
          case LegType$1.FD:
          case LegType$1.FM:
          case LegType$1.HA:
          case LegType$1.HF:
          case LegType$1.HM:
          case LegType$1.PI:
            this.addWaypointByIdent(nextWaypoint.icao, index + 1, () => this.updateFlightPlanVersion().catch(console.error));
            break;
          default:
            this.updateFlightPlanVersion().catch(console.error);
        }
        return true;
      }
      this.updateFlightPlanVersion().catch(console.error);
      return false;
    }

    /**
     * Sets the arrival transition index for the current flight plan.
     * @param {Number} index The index of the arrival transition to select.
     * @param {() => void} callback A callback to call when the operation completes.
     */
    async setArrivalEnRouteTransitionIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // console.log('FPM: setArrivalEnRouteTransitionIndex: SET TRANSITION - ARRIVAL',
      // currentFlightPlan.destinationAirfield.infos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex].enRouteTransitions[index].name);

      if (currentFlightPlan.procedureDetails.arrivalTransitionIndex !== index) {
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = index;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the arrival runway index in the currently active flight plan.
     * @param {Number} index The index of the runway to select.
     * @param {() => void} callback A callback to call when the operation completes.
     */
    async setArrivalRunwayIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.arrivalRunwayIndex !== index) {
        /* if (currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
            console.log(`setArrivalRunwayIndex: Finishing at
            ${currentFlightPlan.destinationAirfield.infos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex].runwayTransitions[index].name}`);
        } else {
            console.log('setArrivalRunwayIndex: Finishing at none');
        } */
        currentFlightPlan.procedureDetails.arrivalRunwayIndex = index;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the destination runway index in the currently active flight plan.
     * @param index The index of the runway to select.
     * @param runwayExtension The length of the runway extension fix to create, or -1 if none.
     * @param callback A callback to call when the operation completes.
     */
    async setDestinationRunwayIndex(index) {
      let runwayExtension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // console.log('setDestinationRunwayIndex - APPROACH');

      if (currentFlightPlan.procedureDetails.destinationRunwayIndex !== index || currentFlightPlan.procedureDetails.destinationRunwayExtension !== runwayExtension) {
        currentFlightPlan.procedureDetails.destinationRunwayIndex = index;
        currentFlightPlan.procedureDetails.destinationRunwayExtension = runwayExtension;
        await currentFlightPlan.buildApproach().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Sets the destination runway index using the current selected approach
     */
    async setDestinationRunwayIndexFromApproach() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
        const approach = currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
        const destRunways = currentFlightPlan.destinationAirfield.infos.oneWayRunways;
        await this.setDestinationRunwayIndex(destRunways.findIndex(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator));
      }
    }

    /**
     * Gets the index of the approach in the currently active flight plan.
     */
    getApproachIndex() {
      return this._flightPlans[this._currentFlightPlanIndex].procedureDetails.approachIndex;
    }

    /**
     * Sets the approach index in the currently active flight plan.
     * @param index The index of the approach in the destination airport information.
     * @param callback A callback to call when the operation has completed.
     * @param transition The approach transition index to set in the approach information.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setApproachIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // console.log(currentFlightPlan);

      if (currentFlightPlan.procedureDetails.approachIndex !== index) {
        // console.log('FPM: setApproachIndex - APPROACH', currentFlightPlan.destinationAirfield.infos.approaches[index].name);
        currentFlightPlan.procedureDetails.approachIndex = index;
        currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
        currentFlightPlan.procedureDetails.arrivalIndex = -1;
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Whether or not an approach is loaded in the current flight plan.
     * @param forceSimVarCall Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isLoadedApproach() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.approachIndex >= 0;
    }

    /**
     * Whether or not the approach is active in the current flight plan.
     * @param forceSimVarCall Unused
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isActiveApproach() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.approach.waypoints.length > 0 && currentFlightPlan.activeWaypointIndex >= currentFlightPlan.approach.offset;
    }

    /**
     * Activates the approach segment in the current flight plan.
     * @param {() => void} callback
     */
    async activateApproach() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (!this.isActiveApproach() && currentFlightPlan.approach.offset >= 0) {
        await GPS.setActiveWaypoint(currentFlightPlan.approach.offset).catch(console.error);
      }
      callback();
    }

    /**
     * Deactivates the approach segments in the current flight plan.
     */
    deactivateApproach() {
      // empty
    }

    /**
     * Attemptes to auto-activate the approach in the current flight plan.
     */
    tryAutoActivateApproach() {
      // empty
    }

    /**
     * Gets the index of the active waypoint on the approach in the current flight plan.
     */
    getApproachActiveWaypointIndex() {
      return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
    }

    /**
     * Gets the approach procedure from the current flight plan destination airport procedure information.
     */
    getApproach() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
        return currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
      }
      return undefined;
    }

    /**
     * Gets the index of the approach transition in the current flight plan.
     */
    getApproachTransitionIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.approachTransitionIndex;
    }

    /**
     * Gets the last waypoint index before the start of the approach segment in
     * the current flight plan.
     */
    getLastIndexBeforeApproach() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // TODO: if we have an approach return last index
      if (currentFlightPlan.approach !== FlightPlanSegment$1.Empty) {
        return currentFlightPlan.approach.offset - 1;
      }
      return this.getWaypointsCount();
    }

    /**
     * Gets the destination runway from the current flight plan.
     */
    getDestinationRunway() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const flightPlan = this._flightPlans[flightPlanIndex];
      const runwayIndex = this.getDestinationRunwayIndex(flightPlanIndex);
      if (runwayIndex >= 0) {
        return flightPlan.destinationAirfield.infos.oneWayRunways[runwayIndex];
      }
      return undefined;
    }

    /**
     * Gets the destination runway index (oneWayRunways) from the current flight plan.
     */
    getDestinationRunwayIndex() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const flightPlan = this._flightPlans[flightPlanIndex];
      if (flightPlan.procedureDetails.destinationRunwayIndex >= 0 && flightPlan.destinationAirfield) {
        return flightPlan.procedureDetails.destinationRunwayIndex;
      }
      if (flightPlan.hasDestination && flightPlan.procedureDetails.approachIndex >= 0) {
        console.error('Destination runway index is -1 with valid STAR');
        const approach = flightPlan.destinationAirfield.infos.approaches[flightPlan.procedureDetails.approachIndex];
        const runways = flightPlan.destinationAirfield.infos.oneWayRunways;
        return runways.findIndex(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
      }
      return -1;
    }

    /**
     * Gets the approach waypoints for the current flight plan.
     */
    getApproachWaypoints() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      return this._flightPlans[flightPlanIndex].approach.waypoints;
    }

    /**
     * Sets the approach transition index for the current flight plan.
     * @param index The index of the transition in the destination airport approach information.
     * @param callback A callback to call when the operation completes.
     */
    async setApproachTransitionIndex(index) {
      let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // console.log('setApproachTransitionIndex - APPROACH');

      if (currentFlightPlan.procedureDetails.approachTransitionIndex !== index) {
        // console.log(`setApproachIndex: APPR TRANS ${currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex].transitions[index].name}`);
        currentFlightPlan.procedureDetails.approachTransitionIndex = index;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }

    /**
     * Removes the arrival segment from the current flight plan.
     * @param callback A callback to call when the operation completes.
     */
    async removeArrival() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // console.log('remove arrival - ARRIVAL');

      currentFlightPlan.procedureDetails.arrivalIndex = -1;
      currentFlightPlan.procedureDetails.arrivalRunwayIndex = -1;
      currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
      await currentFlightPlan.buildArrival().catch(console.error);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }

    /**
     * Inserts direct-to an ICAO designated fix.
     *
     * @param icao The ICAO designation for the fix to fly direct-to.
     */
    async insertDirectTo(waypoint) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      await currentFlightPlan.addDirectTo(waypoint);
      this.updateFlightPlanVersion().catch(console.error);
    }

    /**
     * Cancels the current direct-to and proceeds back along the flight plan.
     * @param callback A callback to call when the operation completes.
     */
    cancelDirectTo() {
      let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
      // const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      // currentFlightPlan.directTo.cancel();

      callback();
    }

    /**
     * Gets whether or not the flight plan is current in a direct-to procedure.
     */
    getIsDirectTo() {
      return this._flightPlans[this._currentFlightPlanIndex].directTo.isActive;
    }

    /**
     * Gets the target of the direct-to procedure in the current flight plan.
     */
    getDirectToTarget() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.directTo.waypointIsInFlightPlan) {
        return currentFlightPlan.waypoints[currentFlightPlan.directTo.planWaypointIndex];
      }
      return currentFlightPlan.directTo.waypoint;
    }

    /**
     * Gets the origin/start waypoint of the direct-to procedure in the current flight plan.
     */
    getDirecToOrigin() {
      return this._flightPlans[this._currentFlightPlanIndex].directTo.interceptPoints[0];
    }
    getCoordinatesHeadingAtDistanceAlongFlightPlan(_distance) {
      // empty
    }

    /**
     * Gets the coordinates of a point that is a specific distance from the destination along the flight plan.
     * @param distance The distance from destination we want the coordinates for.
     */
    getCoordinatesAtNMFromDestinationAlongFlightPlan(distance) {
      const allWaypoints = this.getAllWaypoints();
      const destination = this.getDestination();
      if (destination) {
        const fromStartDistance = destination.cumulativeDistanceInFP - distance;
        let prev;
        let next;
        for (let i = 0; i < allWaypoints.length - 1; i++) {
          prev = allWaypoints[i];
          next = allWaypoints[i + 1];
          if (prev.cumulativeDistanceInFP < fromStartDistance && next.cumulativeDistanceInFP > fromStartDistance) {
            break;
          }
        }
        const prevCD = prev.cumulativeDistanceInFP;
        const nextCD = next.cumulativeDistanceInFP;
        const d = (fromStartDistance - prevCD) / (nextCD - prevCD);
        const output = new LatLongAlt();
        output.lat = Avionics.Utils.lerpAngle(prev.infos.coordinates.lat, next.infos.coordinates.lat, d);
        output.long = Avionics.Utils.lerpAngle(prev.infos.coordinates.long, next.infos.coordinates.long, d);
        return output;
      }
      return null;
    }

    /**
     * Gets the current stored flight plan
     */
    _getFlightPlan() {
      {
        return;
      }
    }
    getCurrentFlightPlan() {
      return this._flightPlans[this._currentFlightPlanIndex];
    }
    getFlightPlan(index) {
      return this._flightPlans[index];
    }

    /**
     * Updates the synchronized flight plan version and saves it to shared storage.
     */
    async updateFlightPlanVersion() {
      if (this._isSyncPaused) {
        return;
      }
      SimVar.SetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number', ++this._currentFlightPlanVersion);
      if (NXDataStore.get('FP_SYNC', 'LOAD') === 'SAVE') {
        FlightPlanAsoboSync.SaveToGame(this).catch(console.error);
      }
    }
    pauseSync() {
      this._isSyncPaused = true;
      console.log('FlightPlan Sync Paused');
    }
    resumeSync() {
      this._isSyncPaused = false;
      this.updateFlightPlanVersion().catch(console.error);
      console.log('FlightPlan Sync Resume');
    }
    get currentFlightPlanVersion() {
      return this._currentFlightPlanVersion;
    }
    getOriginTransitionAltitude() {
      var _currentFlightPlan$or;
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return (_currentFlightPlan$or = currentFlightPlan.originTransitionAltitudePilot) !== null && _currentFlightPlan$or !== void 0 ? _currentFlightPlan$or : currentFlightPlan.originTransitionAltitudeDb;
    }

    /**
     * The transition altitude for the origin in the *active* flight plan
     */
    get originTransitionAltitude() {
      return this.getOriginTransitionAltitude(0);
    }
    getOriginTransitionAltitudeIsFromDb() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.originTransitionAltitudePilot === undefined;
    }

    /**
     * Is the transition altitude for the origin in the *active* flight plan from the database?
     */
    get originTransitionAltitudeIsFromDb() {
      return this.getOriginTransitionAltitudeIsFromDb(0);
    }

    /**
     * Set the transition altitude for the origin
     * @param altitude transition altitude
     * @param database is this value from the database, or pilot?
     * @param flightPlanIndex index of flight plan to be edited, defaults to current plan being edited (not active!)
     */
    setOriginTransitionAltitude(altitude) {
      let database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (database) {
        currentFlightPlan.originTransitionAltitudeDb = altitude;
      } else {
        currentFlightPlan.originTransitionAltitudePilot = altitude;
      }
      this.updateFlightPlanVersion();
    }
    getDestinationTransitionLevel() {
      var _currentFlightPlan$de;
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return (_currentFlightPlan$de = currentFlightPlan.destinationTransitionLevelPilot) !== null && _currentFlightPlan$de !== void 0 ? _currentFlightPlan$de : currentFlightPlan.destinationTransitionLevelDb;
    }

    /**
     * The transition level for the destination in the *active* flight plan
     */
    get destinationTransitionLevel() {
      return this.getDestinationTransitionLevel(0);
    }
    getDestinationTransitionLevelIsFromDb() {
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.destinationTransitionLevelPilot === undefined;
    }

    /**
     * Is the transition level for the destination in the *active* flight plan from the database?
     */
    get destinationTransitionLevelIsFromDb() {
      return this.getDestinationTransitionLevelIsFromDb(0);
    }

    /**
     * Set the transition level for the destination
     * @param flightLevel transition level
     * @param database is this value from the database, or pilot?
     * @param flightPlanIndex index of flight plan to be edited, defaults to current plan being edited (not active!)
     */
    setDestinationTransitionLevel(flightLevel) {
      let database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (database) {
        currentFlightPlan.destinationTransitionLevelDb = flightLevel;
      } else {
        currentFlightPlan.destinationTransitionLevelPilot = flightLevel;
      }
      this.updateFlightPlanVersion();
    }
    getFixInfo(index) {
      return this._fixInfos[index];
    }
    isWaypointInUse(icao) {
      for (const fp of this._flightPlans) {
        for (let i = 0; i < (fp === null || fp === void 0 ? void 0 : fp.waypoints.length); i++) {
          var _fp$getWaypoint;
          if ((fp === null || fp === void 0 ? void 0 : (_fp$getWaypoint = fp.getWaypoint(i)) === null || _fp$getWaypoint === void 0 ? void 0 : _fp$getWaypoint.icao) === icao) {
            return true;
          }
        }
      }
      for (const fixInfo of this._fixInfos) {
        var _fixInfo$getRefFix;
        if ((fixInfo === null || fixInfo === void 0 ? void 0 : (_fixInfo$getRefFix = fixInfo.getRefFix()) === null || _fixInfo$getRefFix === void 0 ? void 0 : _fixInfo$getRefFix.infos.icao) === icao) {
          return true;
        }
      }
      return false;
    }
    get activeFlightPlan() {
      return this._flightPlans[FlightPlans.Active];
    }
    getApproachType() {
      var _fp$procedureDetails$;
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const fp = this._flightPlans[flightPlanIndex];
      return (_fp$procedureDetails$ = fp === null || fp === void 0 ? void 0 : fp.procedureDetails.approachType) !== null && _fp$procedureDetails$ !== void 0 ? _fp$procedureDetails$ : undefined;
    }
    getGlideslopeIntercept() {
      var _fp$glideslopeInterce;
      let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
      const fp = this._flightPlans[flightPlanIndex];
      return (_fp$glideslopeInterce = fp === null || fp === void 0 ? void 0 : fp.glideslopeIntercept) !== null && _fp$glideslopeInterce !== void 0 ? _fp$glideslopeInterce : undefined;
    }
    updateActiveArea() {
      const activeFp = this._flightPlans[FlightPlans.Active];
      if (!activeFp) {
        this.activeArea = FlightArea.Terminal;
        return;
      }
      this.activeArea = this.calculateActiveArea(activeFp);
    }
    calculateActiveArea(activeFp) {
      const activeIndex = activeFp.activeWaypointIndex;
      const appr = activeFp.getSegment(SegmentType.Approach);
      const arrival = activeFp.getSegment(SegmentType.Arrival);
      const departure = activeFp.getSegment(SegmentType.Departure);
      if (departure !== FlightPlanSegment$1.Empty && activeIndex < departure.offset + departure.waypoints.length) {
        return FlightArea.Terminal;
      }
      if (arrival !== FlightPlanSegment$1.Empty && activeIndex >= arrival.offset && activeIndex < arrival.offset + arrival.waypoints.length) {
        return FlightArea.Terminal;
      }
      if (appr !== FlightPlanSegment$1.Empty && activeIndex >= appr.offset && activeIndex < appr.offset + appr.waypoints.length && activeFp.finalApproachActive) {
        const apprType = activeFp.procedureDetails.approachType;
        switch (apprType) {
          case ApproachType.APPROACH_TYPE_ILS:
            return FlightArea.PrecisionApproach;
          case ApproachType.APPROACH_TYPE_GPS:
          case ApproachType.APPROACH_TYPE_RNAV:
            return FlightArea.GpsApproach;
          case ApproachType.APPROACH_TYPE_VOR:
          case ApproachType.APPROACH_TYPE_VORDME:
            return FlightArea.VorApproach;
          default:
            return FlightArea.NonPrecisionApproach;
        }
      }
      return FlightArea.Enroute;
    }
    addOrUpdateCruiseStep(waypoint, toAltitude, waypointIndex) {
      this._flightPlans[this._currentFlightPlanIndex].addOrUpdateCruiseStep(waypoint, toAltitude, waypointIndex);
      // Unignore all of them, so a new VNAV computation with all steps is done
      this.unignoreAllCruiseSteps();
      this.updateFlightPlanVersion().catch(console.error);
    }
    removeCruiseStep(waypoint) {
      this._flightPlans[this._currentFlightPlanIndex].removeCruiseStep(waypoint);
      // Unignore all of them, so a new VNAV computation with all steps is done
      this.unignoreAllCruiseSteps();
      this.updateFlightPlanVersion().catch(console.error);
    }
    findWaypointIndexByIdent(ident) {
      return this._flightPlans[this._currentFlightPlanIndex].findWaypointIndexByIdent(ident);
    }
    unignoreAllCruiseSteps() {
      this._flightPlans[this._currentFlightPlanIndex].unignoreAllCruiseSteps();
      this.updateFlightPlanVersion().catch(console.error);
    }
  }
  _defineProperty(FlightPlanManager, "DEBUG_INSTANCE", void 0);
  _defineProperty(FlightPlanManager, "FlightPlanKey", 'A32NX.FlightPlan');
  _defineProperty(FlightPlanManager, "FlightPlanCompressedKey", 'A32NX.FlightPlan.Compressed');
  _defineProperty(FlightPlanManager, "FlightPlanVersionKey", 'L:A32NX.FlightPlan.Version');

  let Arinc429SignStatusMatrix = /*#__PURE__*/function (Arinc429SignStatusMatrix) {
    Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["FailureWarning"] = 0] = "FailureWarning";
    Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["NoComputedData"] = 1] = "NoComputedData";
    Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["FunctionalTest"] = 2] = "FunctionalTest";
    Arinc429SignStatusMatrix[Arinc429SignStatusMatrix["NormalOperation"] = 3] = "NormalOperation";
    return Arinc429SignStatusMatrix;
  }({});
  class Arinc429Word {
    constructor(word) {
      _defineProperty(this, "ssm", void 0);
      _defineProperty(this, "value", void 0);
      Arinc429Word.u32View[0] = (word & 0xffffffff) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 0b11;
      this.value = Arinc429Word.f32View[0];
    }
    static empty() {
      return new Arinc429Word(0);
    }
    static fromSimVarValue(name) {
      return new Arinc429Word(SimVar.GetSimVarValue(name, 'number'));
    }
    static async toSimVarValue(name, value, ssm) {
      Arinc429Word.f32View[0] = value;
      const simVal = Arinc429Word.u32View[0] + Math.trunc(ssm) * 2 ** 32;
      return SimVar.SetSimVarValue(name, 'string', simVal.toString());
    }
    isFailureWarning() {
      return this.ssm === Arinc429SignStatusMatrix.FailureWarning;
    }
    isNoComputedData() {
      return this.ssm === Arinc429SignStatusMatrix.NoComputedData;
    }
    isFunctionalTest() {
      return this.ssm === Arinc429SignStatusMatrix.FunctionalTest;
    }
    isNormalOperation() {
      return this.ssm === Arinc429SignStatusMatrix.NormalOperation;
    }

    /**
     * Returns the value when normal operation, the supplied default value otherwise.
     */
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    getBitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    getBitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
    setBitValue(bit, value) {
      if (value) {
        this.value |= 1 << bit - 1;
      } else {
        this.value &= ~(1 << bit - 1);
      }
    }
  }
  _defineProperty(Arinc429Word, "u32View", new Uint32Array(1));
  _defineProperty(Arinc429Word, "f32View", new Float32Array(Arinc429Word.u32View.buffer));
  class Arinc429Register {
    static empty() {
      return new Arinc429Register();
    }
    constructor() {
      _defineProperty(this, "u32View", new Uint32Array(1));
      _defineProperty(this, "f32View", new Float32Array(this.u32View.buffer));
      _defineProperty(this, "ssm", void 0);
      _defineProperty(this, "value", void 0);
      this.set(0);
    }
    set(word) {
      this.u32View[0] = (word & 0xffffffff) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 0b11;
      this.value = this.f32View[0];
    }
    setFromSimVar(name) {
      this.set(SimVar.GetSimVarValue(name, 'number'));
    }
    isFailureWarning() {
      return this.ssm === Arinc429SignStatusMatrix.FailureWarning;
    }
    isNoComputedData() {
      return this.ssm === Arinc429SignStatusMatrix.NoComputedData;
    }
    isFunctionalTest() {
      return this.ssm === Arinc429SignStatusMatrix.FunctionalTest;
    }
    isNormalOperation() {
      return this.ssm === Arinc429SignStatusMatrix.NormalOperation;
    }

    /**
     * Returns the value when normal operation, the supplied default value otherwise.
     */
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    bitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    bitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
  }

  // Copyright (c) 2021-2022 FlyByWire Simulations
  // Copyright (c) 2021-2022 Synaptic Simulations
  //
  // SPDX-License-Identifier: GPL-3.0

  /**
   * This enum represents a Control Law selected by the guidance system.
   */
  let ControlLaw = /*#__PURE__*/function (ControlLaw) {
    ControlLaw[ControlLaw["HEADING"] = 1] = "HEADING";
    ControlLaw[ControlLaw["TRACK"] = 2] = "TRACK";
    ControlLaw[ControlLaw["LATERAL_PATH"] = 3] = "LATERAL_PATH";
    return ControlLaw;
  }({});
  let RequestedVerticalMode = /*#__PURE__*/function (RequestedVerticalMode) {
    RequestedVerticalMode[RequestedVerticalMode["None"] = 0] = "None";
    RequestedVerticalMode[RequestedVerticalMode["SpeedThrust"] = 1] = "SpeedThrust";
    RequestedVerticalMode[RequestedVerticalMode["VpathThrust"] = 2] = "VpathThrust";
    RequestedVerticalMode[RequestedVerticalMode["VpathSpeed"] = 3] = "VpathSpeed";
    RequestedVerticalMode[RequestedVerticalMode["FpaSpeed"] = 4] = "FpaSpeed";
    RequestedVerticalMode[RequestedVerticalMode["VsSpeed"] = 5] = "VsSpeed";
    return RequestedVerticalMode;
  }({});

  var LateralMode = /*#__PURE__*/function (LateralMode) {
    LateralMode[LateralMode["NONE"] = 0] = "NONE";
    LateralMode[LateralMode["HDG"] = 10] = "HDG";
    LateralMode[LateralMode["TRACK"] = 11] = "TRACK";
    LateralMode[LateralMode["NAV"] = 20] = "NAV";
    LateralMode[LateralMode["LOC_CPT"] = 30] = "LOC_CPT";
    LateralMode[LateralMode["LOC_TRACK"] = 31] = "LOC_TRACK";
    LateralMode[LateralMode["LAND"] = 32] = "LAND";
    LateralMode[LateralMode["FLARE"] = 33] = "FLARE";
    LateralMode[LateralMode["ROLL_OUT"] = 34] = "ROLL_OUT";
    LateralMode[LateralMode["RWY"] = 40] = "RWY";
    LateralMode[LateralMode["RWY_TRACK"] = 41] = "RWY_TRACK";
    LateralMode[LateralMode["GA_TRACK"] = 50] = "GA_TRACK";
    return LateralMode;
  }(LateralMode || {});
  var ArmedLateralMode = /*#__PURE__*/function (ArmedLateralMode) {
    ArmedLateralMode[ArmedLateralMode["NAV"] = 0] = "NAV";
    ArmedLateralMode[ArmedLateralMode["LOC"] = 1] = "LOC";
    return ArmedLateralMode;
  }(ArmedLateralMode || {});
  var VerticalMode = /*#__PURE__*/function (VerticalMode) {
    VerticalMode[VerticalMode["NONE"] = 0] = "NONE";
    VerticalMode[VerticalMode["ALT"] = 10] = "ALT";
    VerticalMode[VerticalMode["ALT_CPT"] = 11] = "ALT_CPT";
    VerticalMode[VerticalMode["OP_CLB"] = 12] = "OP_CLB";
    VerticalMode[VerticalMode["OP_DES"] = 13] = "OP_DES";
    VerticalMode[VerticalMode["VS"] = 14] = "VS";
    VerticalMode[VerticalMode["FPA"] = 15] = "FPA";
    VerticalMode[VerticalMode["ALT_CST"] = 20] = "ALT_CST";
    VerticalMode[VerticalMode["ALT_CST_CPT"] = 21] = "ALT_CST_CPT";
    VerticalMode[VerticalMode["CLB"] = 22] = "CLB";
    VerticalMode[VerticalMode["DES"] = 23] = "DES";
    VerticalMode[VerticalMode["FINAL"] = 24] = "FINAL";
    VerticalMode[VerticalMode["GS_CPT"] = 30] = "GS_CPT";
    VerticalMode[VerticalMode["GS_TRACK"] = 31] = "GS_TRACK";
    VerticalMode[VerticalMode["LAND"] = 32] = "LAND";
    VerticalMode[VerticalMode["FLARE"] = 33] = "FLARE";
    VerticalMode[VerticalMode["ROLL_OUT"] = 34] = "ROLL_OUT";
    VerticalMode[VerticalMode["SRS"] = 40] = "SRS";
    VerticalMode[VerticalMode["SRS_GA"] = 41] = "SRS_GA";
    VerticalMode[VerticalMode["TCAS"] = 50] = "TCAS";
    return VerticalMode;
  }(VerticalMode || {});
  var ArmedVerticalMode = /*#__PURE__*/function (ArmedVerticalMode) {
    ArmedVerticalMode[ArmedVerticalMode["ALT"] = 0] = "ALT";
    ArmedVerticalMode[ArmedVerticalMode["ALT_CST"] = 1] = "ALT_CST";
    ArmedVerticalMode[ArmedVerticalMode["CLB"] = 2] = "CLB";
    ArmedVerticalMode[ArmedVerticalMode["DES"] = 3] = "DES";
    ArmedVerticalMode[ArmedVerticalMode["GS"] = 4] = "GS";
    ArmedVerticalMode[ArmedVerticalMode["FINAL"] = 5] = "FINAL";
    ArmedVerticalMode[ArmedVerticalMode["TCAS"] = 6] = "TCAS";
    return ArmedVerticalMode;
  }(ArmedVerticalMode || {});
  function isArmed(bitmask, armedBit) {
    return (bitmask >> armedBit & 1) === 1;
  }

  let FmgcFlightPhase = /*#__PURE__*/function (FmgcFlightPhase) {
    FmgcFlightPhase[FmgcFlightPhase["Preflight"] = 0] = "Preflight";
    FmgcFlightPhase[FmgcFlightPhase["Takeoff"] = 1] = "Takeoff";
    FmgcFlightPhase[FmgcFlightPhase["Climb"] = 2] = "Climb";
    FmgcFlightPhase[FmgcFlightPhase["Cruise"] = 3] = "Cruise";
    FmgcFlightPhase[FmgcFlightPhase["Descent"] = 4] = "Descent";
    FmgcFlightPhase[FmgcFlightPhase["Approach"] = 5] = "Approach";
    FmgcFlightPhase[FmgcFlightPhase["GoAround"] = 6] = "GoAround";
    FmgcFlightPhase[FmgcFlightPhase["Done"] = 7] = "Done";
    return FmgcFlightPhase;
  }({});
  function isReady() {
    return SimVar.GetSimVarValue('L:A32NX_IS_READY', 'number') === 1;
  }
  function isSlewActive() {
    return SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
  }
  function isOnGround() {
    return SimVar.GetSimVarValue('L:A32NX_LGCIU_1_NOSE_GEAR_COMPRESSED', 'bool') || SimVar.GetSimVarValue('L:A32NX_LGCIU_2_NOSE_GEAR_COMPRESSED', 'bool');
  }
  function isEngineOn(index) {
    return SimVar.GetSimVarValue("L:A32NX_ENGINE_N2:".concat(index), 'number') > 20;
  }
  function isEngineOnTakeOffThrust(index) {
    return SimVar.GetSimVarValue("L:A32NX_ENGINE_N1:".concat(index), 'number') >= 70;
  }
  function isAnEngineOn() {
    return isEngineOn(1) || isEngineOn(2);
  }
  function isAllEngineOn() {
    return isEngineOn(1) && isEngineOn(2);
  }
  function getAutopilotVerticalMode() {
    return SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
  }
  function conditionTakeOff() {
    return getAutopilotVerticalMode() === VerticalMode.SRS && isEngineOnTakeOffThrust(1) && isEngineOnTakeOffThrust(2) || Math.abs(Simplane.getGroundSpeed()) > 90;
  }

  class ConfirmationNode {
    constructor(triggerTime) {
      this.triggerTime = triggerTime;
      _defineProperty(this, "lastInput", false);
      _defineProperty(this, "input", false);
      _defineProperty(this, "output", false);
      _defineProperty(this, "timer", 0.0);
    }
    update(deltaTime) {
      // State change - reset timer
      if (this.lastInput !== this.input) {
        this.lastInput = this.input;
        this.output = false;
        this.timer = 0.0;
        return;
      }
      this.lastInput = this.input;
      if (this.input) {
        this.timer += deltaTime;
      }
      if (this.timer > this.triggerTime) {
        this.output = true;
      }
    }
  }
  class Trigger {
    constructor(risingEdge) {
      this.risingEdge = risingEdge;
      _defineProperty(this, "lastInput", false);
      _defineProperty(this, "input", false);
      _defineProperty(this, "output", false);
    }
    update(_) {
      // State change - set output
      if (this.lastInput !== this.input) {
        if (this.risingEdge && this.input) {
          this.output = true;
        } else if (!this.risingEdge && this.input) {
          this.output = false;
        }
      } else {
        this.output = false;
      }
      this.lastInput = this.input;
    }
  }

  class Phase {
    constructor() {
      _defineProperty(this, "nextPhase", void 0);
    }
    // eslint-disable-next-line no-empty-function
    init() {/* prototype function */}
  }
  class PreFlightPhase extends Phase {
    constructor() {
      super(...arguments);
      _defineProperty(this, "takeoffConfirmation", new ConfirmationNode(0.2 * 1000));
    }
    init() {
      this.nextPhase = FmgcFlightPhase.Takeoff;
    }
    shouldActivateNextPhase(_deltaTime) {
      this.takeoffConfirmation.input = conditionTakeOff();
      this.takeoffConfirmation.update(_deltaTime);
      return this.takeoffConfirmation.output;
    }
  }
  class TakeOffPhase extends Phase {
    constructor() {
      super(...arguments);
      _defineProperty(this, "accelerationAltitudeMsl", void 0);
      _defineProperty(this, "accelerationAltitudeMslEo", void 0);
    }
    init() {
      this.nextPhase = FmgcFlightPhase.Climb;
      SimVar.SetSimVarValue('L:A32NX_COLD_AND_DARK_SPAWN', 'Bool', false);
      const accAlt = Arinc429Word.fromSimVarValue('L:A32NX_FM1_ACC_ALT');
      this.accelerationAltitudeMsl = accAlt.valueOr(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') + parseInt(NXDataStore.get('CONFIG_ACCEL_ALT', '1500')));
      const eoAccAlt = Arinc429Word.fromSimVarValue('L:A32NX_FM1_EO_ACC_ALT');
      this.accelerationAltitudeMslEo = eoAccAlt.valueOr(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') + parseInt(NXDataStore.get('CONFIG_ACCEL_ALT', '1500')));
    }
    shouldActivateNextPhase(_deltaTime) {
      return Simplane.getAltitude() > (isAllEngineOn() ? this.accelerationAltitudeMsl : this.accelerationAltitudeMslEo);
    }
  }
  class ClimbPhase extends Phase {
    init() {
      this.nextPhase = FmgcFlightPhase.Cruise;
    }
    shouldActivateNextPhase(_deltaTime) {
      const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;
      const fl = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
      return fl >= cruiseFl;
    }
  }
  class CruisePhase extends Phase {
    init() {
      // switch out of cruise phase is handled in FlightPhaseManager
      this.nextPhase = FmgcFlightPhase.Cruise;
    }
    shouldActivateNextPhase(_deltaTime) {
      return false;
    }
  }
  class DescentPhase extends Phase {
    init() {
      this.nextPhase = FmgcFlightPhase.Approach;
    }
    shouldActivateNextPhase(_deltaTime) {
      const fl = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
      const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue('feet') / 100;
      const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;
      if (fl === cruiseFl && fcuSelFl === fl) {
        this.nextPhase = FmgcFlightPhase.Cruise;
        return true;
      }

      // APPROACH phase from DECEL pseudo waypoint case. This is decided by the new TS FMS.
      return !!SimVar.GetSimVarValue('L:A32NX_FM_ENABLE_APPROACH_PHASE', 'Bool');
    }
  }
  class ApproachPhase extends Phase {
    constructor() {
      super(...arguments);
      _defineProperty(this, "landingConfirmation", new ConfirmationNode(30 * 1000));
    }
    init() {
      SimVar.SetSimVarValue('L:A32NX_TO_FLEX_TEMP', 'Number', 0);
      this.nextPhase = FmgcFlightPhase.Done;
    }
    shouldActivateNextPhase(_deltaTime) {
      if (getAutopilotVerticalMode() === VerticalMode.SRS_GA) {
        this.nextPhase = FmgcFlightPhase.GoAround;
        return true;
      }
      this.landingConfirmation.input = isOnGround();
      this.landingConfirmation.update(_deltaTime);
      return this.landingConfirmation.output || !isAnEngineOn();
    }
  }
  class GoAroundPhase extends Phase {
    init() {
      SimVar.SetSimVarValue('L:A32NX_TO_FLEX_TEMP', 'Number', 0);
      this.nextPhase = FmgcFlightPhase.GoAround;
    }
    shouldActivateNextPhase(_deltaTime) {
      // there is no automatic switch from this phase
      return false;
    }
  }
  class DonePhase extends Phase {
    init() {
      SimVar.SetSimVarValue('L:A32NX_TO_FLEX_TEMP', 'Number', 0);
      this.nextPhase = FmgcFlightPhase.Done;
    }
    shouldActivateNextPhase(_deltaTime) {
      // there is no automatic switch from this phase
      return false;
    }
  }

  function canInitiateDes(distanceToDestination) {
    const fl = Math.round(Simplane.getAltitude() / 100);
    const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue('feet') / 100;
    const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;

    // Can initiate descent? OR Can initiate early descent?
    return (distanceToDestination < 200 || fl < 200) && fcuSelFl < cruiseFl && fcuSelFl < fl || distanceToDestination >= 200 && fl > 200 && fcuSelFl <= 200;
  }
  class FlightPhaseManager {
    constructor() {
      _defineProperty(this, "onGroundConfirmationNode", new ConfirmationNode(30 * 1000));
      _defineProperty(this, "activePhase", this.initialPhase || FmgcFlightPhase.Preflight);
      _defineProperty(this, "phases", {
        [FmgcFlightPhase.Preflight]: new PreFlightPhase(),
        [FmgcFlightPhase.Takeoff]: new TakeOffPhase(),
        [FmgcFlightPhase.Climb]: new ClimbPhase(),
        [FmgcFlightPhase.Cruise]: new CruisePhase(),
        [FmgcFlightPhase.Descent]: new DescentPhase(),
        [FmgcFlightPhase.Approach]: new ApproachPhase(),
        [FmgcFlightPhase.GoAround]: new GoAroundPhase(),
        [FmgcFlightPhase.Done]: new DonePhase()
      });
      _defineProperty(this, "phaseChangeListeners", []);
    }
    get phase() {
      return this.activePhase;
    }
    get initialPhase() {
      return SimVar.GetSimVarValue('L:A32NX_INITIAL_FLIGHT_PHASE', 'number');
    }
    init() {
      console.log("FMGC Flight Phase: ".concat(this.phase));
      this.phases[this.phase].init();
      this.changePhase(this.activePhase);
    }
    shouldActivateNextPhase(_deltaTime) {
      // process transitions only when plane is ready
      if (isReady() && !isSlewActive()) {
        if (this.shouldActivateDonePhase(_deltaTime)) {
          this.changePhase(FmgcFlightPhase.Done);
        } else if (this.phases[this.phase].shouldActivateNextPhase(_deltaTime)) {
          this.changePhase(this.phases[this.phase].nextPhase);
        }
      } else if (isReady() && isSlewActive()) {
        this.handleSlewSituation(_deltaTime);
      } else if (this.activePhase !== this.initialPhase) {
        // ensure correct init of phase
        this.activePhase = this.initialPhase;
        this.changePhase(this.initialPhase);
      }
    }
    addOnPhaseChanged(cb) {
      this.phaseChangeListeners.push(cb);
    }
    handleFcuAltKnobPushPull(distanceToDestination) {
      switch (this.phase) {
        case FmgcFlightPhase.Takeoff:
          this.changePhase(FmgcFlightPhase.Climb);
          break;
        case FmgcFlightPhase.Climb:
        case FmgcFlightPhase.Cruise:
          if (canInitiateDes(distanceToDestination)) {
            this.changePhase(FmgcFlightPhase.Descent);
          }
          break;
      }
    }
    handleFcuAltKnobTurn(distanceToDestination) {
      if (this.phase === FmgcFlightPhase.Cruise) {
        const activeVerticalMode = SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
        const VS = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_VS_SELECTED', 'feet per minute');
        const FPA = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_FPA_SELECTED', 'Degrees');
        if ((activeVerticalMode === VerticalMode.OP_DES || activeVerticalMode === VerticalMode.VS && VS < 0 || activeVerticalMode === VerticalMode.FPA && FPA < 0 || activeVerticalMode === VerticalMode.DES) && canInitiateDes(distanceToDestination)) {
          this.changePhase(FmgcFlightPhase.Descent);
        }
      }
    }
    handleFcuVSKnob(distanceToDestination, onStepClimbDescent) {
      if (this.phase === FmgcFlightPhase.Climb || this.phase === FmgcFlightPhase.Cruise) {
        /** a timeout of 100ms is required in order to receive the updated autopilot vertical mode */
        setTimeout(() => {
          const activeVerticalMode = SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
          const VS = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_VS_SELECTED', 'feet per minute');
          const FPA = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_FPA_SELECTED', 'Degrees');
          if (activeVerticalMode === VerticalMode.VS && VS < 0 || activeVerticalMode === VerticalMode.FPA && FPA < 0) {
            if (canInitiateDes(distanceToDestination)) {
              this.changePhase(FmgcFlightPhase.Descent);
            } else {
              onStepClimbDescent();
            }
          }
        }, 100);
      }
    }
    handleNewCruiseAltitudeEntered(newCruiseFlightLevel) {
      const currentFlightLevel = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
      if (this.activePhase === FmgcFlightPhase.Approach) {
        this.changePhase(FmgcFlightPhase.Climb);
      } else if (currentFlightLevel < newCruiseFlightLevel && this.activePhase === FmgcFlightPhase.Descent) {
        this.changePhase(FmgcFlightPhase.Climb);
      } else if (currentFlightLevel > newCruiseFlightLevel && (this.activePhase === FmgcFlightPhase.Climb || this.activePhase === FmgcFlightPhase.Descent)) {
        this.changePhase(FmgcFlightPhase.Cruise);
      }
    }
    handleNewDestinationAirportEntered() {
      if (this.activePhase === FmgcFlightPhase.GoAround) {
        const accAlt = isAllEngineOn() ? Arinc429Word.fromSimVarValue('L:A32NX_FM1_MISSED_ACC_ALT') : Arinc429Word.fromSimVarValue('L:A32NX_FM1_MISSED_EO_ACC_ALT');
        if (Simplane.getAltitude() > accAlt.valueOr(0)) {
          this.changePhase(FmgcFlightPhase.Climb);
        }
      }
    }
    changePhase(newPhase) {
      const prevPhase = this.phase;
      console.log("FMGC Flight Phase: ".concat(prevPhase, " => ").concat(newPhase));
      this.activePhase = newPhase;
      SimVar.SetSimVarValue('L:A32NX_FMGC_FLIGHT_PHASE', 'number', newPhase);
      // Updating old SimVar to ensure backwards compatibility
      SimVar.SetSimVarValue('L:AIRLINER_FLIGHT_PHASE', 'number', newPhase < FmgcFlightPhase.Takeoff ? FmgcFlightPhase.Preflight : newPhase + 1);
      this.phases[this.phase].init();
      for (const pcl of this.phaseChangeListeners) {
        pcl(prevPhase, newPhase);
      }
      this.shouldActivateNextPhase(0);
    }
    tryGoInApproachPhase() {
      if (this.phase === FmgcFlightPhase.Preflight || this.phase === FmgcFlightPhase.Takeoff || this.phase === FmgcFlightPhase.Done) {
        return false;
      }
      if (this.phase !== FmgcFlightPhase.Approach) {
        this.changePhase(FmgcFlightPhase.Approach);
      }
      return true;
    }
    shouldActivateDonePhase(_deltaTime) {
      this.onGroundConfirmationNode.input = isOnGround();
      this.onGroundConfirmationNode.update(_deltaTime);
      return this.onGroundConfirmationNode.output && !isAnEngineOn() && this.phase !== FmgcFlightPhase.Done && this.phase !== FmgcFlightPhase.Preflight;
    }
    handleSlewSituation(_deltaTime) {
      switch (this.phase) {
        case FmgcFlightPhase.Preflight:
        case FmgcFlightPhase.Takeoff:
        case FmgcFlightPhase.Done:
          if (Simplane.getAltitudeAboveGround() >= 1500) {
            this.changePhase(FmgcFlightPhase.Climb);
          }
          break;
      }
    }
  }

  const flightPhaseManager = new FlightPhaseManager();
  function getFlightPhaseManager() {
    return flightPhaseManager;
  }

  class MathUtils$1 {
    static fastToFixed(val, fraction) {
      if (fraction <= 0) {
        return Math.round(val).toString();
      }
      let coefficient = MathUtils$1.optiPow10[fraction];
      if (!coefficient || Number.isNaN(coefficient)) {
        coefficient = 10 ** fraction;
        MathUtils$1.optiPow10[fraction] = coefficient;
      }
      return (Math.round(val * coefficient) / coefficient).toString();
    }
    static fastToFixedNum(val, fraction) {
      if (fraction <= 0) {
        return Math.round(val);
      }
      let coefficient = MathUtils$1.optiPow10[fraction];
      if (!coefficient || Number.isNaN(coefficient)) {
        coefficient = 10 ** fraction;
        MathUtils$1.optiPow10[fraction] = coefficient;
      }
      return Math.round(val * coefficient) / coefficient;
    }

    /**
      * Adds two angles with wrap around to result in 0-360
      * @param a - positive or negative angle
      * @param b - positive or negative angle
      */
    static angleAdd(a, b) {
      let r = a + b;
      while (r > 360) {
        r -= 360;
      }
      while (r < 0) {
        r += 360;
      }
      return r;
    }
    static diffAngle(a, b, direction) {
      let diff = b - a;
      while (diff > 180) {
        diff -= 360;
      }
      while (diff <= -180) {
        diff += 360;
      }
      if (diff < 0 && direction === TurnDirection.Right) {
        diff += 360;
      }
      if (diff > 0 && direction === TurnDirection.Left) {
        diff -= 360;
      }
      return diff;
    }
    static adjustAngleForTurnDirection(angle, turnDirection) {
      let ret = angle;
      if (angle < 0 && turnDirection === TurnDirection.Right) {
        ret += 360;
      }
      if (angle > 0 && turnDirection === TurnDirection.Left) {
        ret -= 360;
      }
      return ret;
    }

    /**
     * Calculates the inner angle of the small triangle formed by two intersecting lines
     *
     * This effectively returns the angle XYZ in the figure shown below:
     *
     * ```
     * * Y
     * |\
     * | \
     * |  \
     * |   \
     * |    \
     * |     \
     * |      \
     * * X     * Z
     * ```
     *
     * @param xyAngle {number} bearing of line XY
     * @param zyAngle {number} bearing of line ZY
     */
    static smallCrossingAngle(xyAngle, zyAngle) {
      // Rotate frame of reference to 0deg
      let correctedXyBearing = xyAngle - zyAngle;
      if (correctedXyBearing < 0) {
        correctedXyBearing = 360 + correctedXyBearing;
      }
      let xyzAngle = 180 - correctedXyBearing;
      if (xyzAngle < 0) {
        // correctedXyBearing was > 180

        xyzAngle = 360 + xyzAngle;
      }
      return xyzAngle;
    }
    static mod(x, n) {
      return x - Math.floor(x / n) * n;
    }
    static highestPower2(n) {
      let res = 0;
      for (let i = n; i >= 1; i--) {
        if ((i & i - 1) === 0) {
          res = i;
          break;
        }
      }
      return res;
    }
    static unpackPowers(n) {
      const res = [];
      let x = n;
      while (x > 0) {
        const pow = MathUtils$1.highestPower2(x);
        res.push(pow);
        x -= pow;
      }
      return res;
    }
    static packPowers(ns) {
      if (ns.some(it => it === 0 || (it & it - 1) !== 0)) {
        throw new Error('Cannot pack number which is not a power of 2 or is equal to zero.');
      }
      return ns.reduce((acc, v) => acc + v);
    }

    /**
      * Convert degrees Celsius into Kelvin
      * @param celsius degrees Celsius
      * @returns degrees Kelvin
      */
    static convertCtoK(celsius) {
      return celsius + 273.15;
    }

    /**
      * Convert Mach to True Air Speed
      * @param mach Mach
      * @param oat Kelvin
      * @returns True Air Speed
      */
    static convertMachToKTas(mach, oat) {
      return mach * 661.4786 * Math.sqrt(oat / 288.15);
    }

    /**
      * Convert TAS to Mach
      * @param tas TAS
      * @param oat Kelvin
      * @returns True Air Speed
      */
    static convertKTASToMach(tas, oat) {
      return tas / 661.4786 / Math.sqrt(oat / 288.15);
    }

    /**
      * Convert TAS to Calibrated Air Speed
      * @param tas velocity true air speed
      * @param oat current temperature Kelvin
      * @param pressure current pressure hpa
      * @returns Calibrated Air Speed
      */
    static convertTasToKCas(tas, oat, pressure) {
      return 1479.1 * Math.sqrt((pressure / 1013 * ((1 + 1 / (oat / 288.15) * (tas / 1479.1) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1);
    }

    /**
      * Convert KCAS to KTAS
      * @param kcas velocity true air speed
      * @param oat current temperature Kelvin
      * @param pressure current pressure hpa
      * @returns True Air Speed
      */
    static convertKCasToKTAS(kcas, oat, pressure) {
      return 1479.1 * Math.sqrt(oat / 288.15 * ((1 / (pressure / 1013) * ((1 + 0.2 * (kcas / 661.4786) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1));
    }

    /**
      * Convert Mach to Calibrated Air Speed
      * @param mach Mach
      * @param oat Kelvin
      * @param pressure current pressure hpa
      * @returns Calibrated Air Speed
      */
    static convertMachToKCas(mach, oat, pressure) {
      return MathUtils$1.convertTasToKCas(MathUtils$1.convertMachToKTas(mach, oat), oat, pressure);
    }

    /**
      * Gets the horizontal distance between 2 points, given in lat/lon
      * @param pos0Lat {number} Position 0 lat
      * @param pos0Lon {number} Position 0 lon
      * @param pos1Lat {number} Position 1 lat
      * @param pos1Lon {number} Position 1 lon
      * @return {number} distance in nautical miles
      */
    static computeGreatCircleDistance(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
      const lat0 = pos0Lat * MathUtils$1.DEGREES_TO_RADIANS;
      const lon0 = pos0Lon * MathUtils$1.DEGREES_TO_RADIANS;
      const lat1 = pos1Lat * MathUtils$1.DEGREES_TO_RADIANS;
      const lon1 = pos1Lon * MathUtils$1.DEGREES_TO_RADIANS;
      const dlon = lon1 - lon0;
      const cosLat0 = Math.cos(lat0);
      const cosLat1 = Math.cos(lat1);
      const a1 = Math.sin((lat1 - lat0) / 2);
      const a2 = Math.sin(dlon / 2);
      return Math.asin(Math.sqrt(a1 * a1 + cosLat0 * cosLat1 * a2 * a2)) * 6880.126;
    }

    /**
      * Gets the heading between 2 points, given in lat/lon
      * @param pos0Lat {number} Position 0 lat
      * @param pos0Lon {number} Position 0 lon
      * @param pos1Lat {number} Position 1 lat
      * @param pos1Lon {number} Position 1 lon
      * @return {number} distance in nautical miles
      */
    static computeGreatCircleHeading(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
      const lat0 = pos0Lat * MathUtils$1.DEGREES_TO_RADIANS;
      const lon0 = pos0Lon * MathUtils$1.DEGREES_TO_RADIANS;
      const lat1 = pos1Lat * MathUtils$1.DEGREES_TO_RADIANS;
      const lon1 = pos1Lon * MathUtils$1.DEGREES_TO_RADIANS;
      const dlon = lon1 - lon0;
      const cosLat1 = Math.cos(lat1);
      let x = Math.sin(lat1 - lat0);
      const sinLon2 = Math.sin(dlon / 2.0);
      x += sinLon2 * sinLon2 * 2.0 * Math.sin(lat0) * cosLat1;
      let heading = Math.atan2(cosLat1 * Math.sin(dlon), x);
      if (heading < 0) {
        heading += 2 * Math.PI;
      }
      return heading * MathUtils$1.RADIANS_TO_DEGREES;
    }

    /**
      * Gets the distance between 2 points, given in lat/lon/alt above sea level
      * @param pos0Lat {number} Position 0 lat
      * @param pos0Lon {number} Position 0 lon
      * @param pos0alt {number} Position 0 alt (feet)
      * @param pos1Lat {number} Position 1 lat
      * @param pos1Lon {number} Position 1 lon
      * @param pos1alt {number} Position 1 alt (feet)
      * @return {number} distance in nautical miles
      */
    static computeDistance3D(pos0Lat, pos0Lon, pos0alt, pos1Lat, pos1Lon, pos1alt) {
      const earthRadius = 3440.065; // earth radius in nautcal miles
      const deg2rad = Math.PI / 180;
      const radius1 = pos0alt / 6076 + earthRadius;
      const radius2 = pos1alt / 6076 + earthRadius;
      const x1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.cos(deg2rad * (pos0Lon + 180));
      const y1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.sin(deg2rad * (pos0Lon + 180));
      const z1 = radius1 * Math.cos(deg2rad * (pos0Lat + 90));
      const x2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.cos(deg2rad * (pos1Lon + 180));
      const y2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.sin(deg2rad * (pos1Lon + 180));
      const z2 = radius2 * Math.cos(deg2rad * (pos1Lat + 90));
      return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
    }

    /**
      * Check if point is inside a given ellipse
      *
      * @param {number} xPos x value of point
      * @param {number} yPos y value of point
      * @param {number} xLimPos +ve xLimit of ellipse
      * @param {number} xLimNeg -ve xLimit of ellipse
      * @param {number} yLimPos +ve yLimit of ellipse
      * @param {number} yLimNeg -ve yLimit of ellipse
      * @return {boolean} Whether the point is in the ellipse
      *
      */
    static pointInEllipse(xPos, yPos, xLimPos, yLimPos) {
      let xLimNeg = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : xLimPos;
      let yLimNeg = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : yLimPos;
      return xPos ** 2 / (xPos >= 0 ? xLimPos : xLimNeg) ** 2 + yPos ** 2 / (yPos >= 0 ? yLimPos : yLimNeg) ** 2 <= 1;
    }

    /**
      * Performs the even-odd-rule Algorithm (a raycasting algorithm) to find out whether a point is in a given polygon.
      * This runs in O(n) where n is the number of edges of the polygon.
      *
      * @param {Array} polygon an array representation of the polygon where polygon[i][0] is the x Value of the i-th point and polygon[i][1] is the y Value.
      * @param {number} xPos  x value of point
      * @param {number} yPos y value of point
      * @return {boolean} Whether the point is in the polygon (not on the edge, just turn < into <= and > into >= for that)
      */
    static pointInPolygon(xPos, yPos, polygon) {
      // A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
      let odd = false;
      // For each edge (In this case for each point of the polygon and the previous one)
      for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
        // If a line from the point into infinity crosses this edge
        if (polygon[i][1] > yPos !== polygon[j][1] > yPos // One point needs to be above, one below our y coordinate
        // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
        && xPos < (polygon[j][0] - polygon[i][0]) * (yPos - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {
          // Invert odd
          odd = !odd;
        }
        j = i;
      }
      // If the number of crossings was odd, the point is in the polygon
      return odd;
    }

    /**
      * Line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
      * Determine the intersection point of two line segments
      * Return null if the lines don't intersect
      *
      * @param {number} x1 line0 x origin
      * @param {number} y1 line0 y origin
      * @param {number} x2 line0 x end
      * @param {number} y2 line0 y end
      * @param {number} x3 line1 x origin
      * @param {number} y3 line1 y origin
      * @param {number} x4 line1 x end
      * @param {number} y4 line1 y end
      *
      * @return {[number, number] | null} [x,y] of intercept, null if no intercept.
      */
    static intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      // Check if none of the lines are of length 0
      if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) {
        return null;
      }
      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

      // Lines are parallel
      if (denominator === 0) {
        return null;
      }
      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
      const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

      // is the intersection along the segments
      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
        return null;
      }

      // Return a object with the x and y coordinates of the intersection
      const x = x1 + ua * (x2 - x1);
      const y = y1 + ua * (y2 - y1);
      return [x, y];
    }

    // Find intersect with polygon
    static intersectWithPolygon(x1, y1, x2, y2, polygon) {
      let ret = null;
      polygon.forEach((xy, index, polygon) => {
        if (ret) return;
        if (index + 1 >= polygon.length) {
          return;
        }
        const x3 = xy[0];
        const y3 = xy[1];
        const x4 = polygon[index + 1][0];
        const y4 = polygon[index + 1][1];
        ret = MathUtils$1.intersect(x1, y1, x2, y2, x3, y3, x4, y4);
      });
      return ret;
    }

    /**
      * Returns the given value if the value is >=lower or <= upper. Otherwise returns the boundary value.
      * @param value the value to be clamped
      * @param lower lowest boundary value
      * @param upper highest boundary value
      */
    static clamp(value, lower, upper) {
      return Math.min(Math.max(value, lower), upper);
    }

    /**
      * Returns a value rounded to the given number of decimal precission.
      * @param value
      * @param decimalPrecision
      */
    static round(value, decimalPrecision) {
      const shift = 10 ** decimalPrecision;
      return Math.round((value + Number.EPSILON) * shift) / shift;
    }
  }
  _defineProperty(MathUtils$1, "DEGREES_TO_RADIANS", Math.PI / 180);
  _defineProperty(MathUtils$1, "RADIANS_TO_DEGREES", 180 / Math.PI);
  _defineProperty(MathUtils$1, "optiPow10", []);

  let Constants = /*#__PURE__*/function (Constants) {
    Constants[Constants["G"] = 9.81] = "G";
    Constants[Constants["EARTH_RADIUS_NM"] = 3440.1] = "EARTH_RADIUS_NM";
    return Constants;
  }({});

  // Copyright (c) 2021-2022 FlyByWire Simulations

  /**
   * Compute the remaining distance around an arc
   * This is only valid once past the itp
   * @param ppos       current aircraft position
   * @param itp        current aircraft track
   * @param centreFix  centre of the arc
   * @param sweepAngle angle swept around the arc, +ve for clockwise
   * @returns
   */
  function arcDistanceToGo(ppos, itp, centreFix, sweepAngle) {
    const itpBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, itp);
    const pposBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
    const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
    const refFrameOffset = Avionics.Utils.diffAngle(0, itpBearing);
    const pposAngle = sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - pposBearing) : Avionics.Utils.clampAngle(pposBearing - refFrameOffset);

    // before the arc... this implies max sweep angle is <340, arinc allows less than that anyway
    if (pposAngle >= 340) {
      return radius * Math.PI * Math.abs(sweepAngle) / 180;
    }
    if (pposAngle >= Math.abs(sweepAngle)) {
      return 0;
    }
    return radius * Math.PI * (Math.abs(sweepAngle) - pposAngle) / 180;
  }

  /**
   * Compute guidance parameters for an arc path
   *
   * @param ppos       current aircraft position
   * @param trueTrack  current aircraft track
   * @param itp        initial turning point for the arc
   * @param centreFix  centre of the arc
   * @param sweepAngle angle swept around the arc, +ve for clockwise
   *
   * @returns lateral path law params
   */
  function arcGuidance(ppos, trueTrack, itp, centreFix, sweepAngle) {
    const bearingPpos = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
    const desiredTrack = sweepAngle > 0 ? Avionics.Utils.clampAngle(bearingPpos + 90) : Avionics.Utils.clampAngle(bearingPpos - 90);
    const trackAngleError = Avionics.Utils.diffAngle(trueTrack, desiredTrack);
    const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
    const distanceFromCenter = Avionics.Utils.computeGreatCircleDistance(centreFix, ppos);
    const crossTrackError = sweepAngle > 0 ? distanceFromCenter - radius : radius - distanceFromCenter;
    const groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'meters per second');
    const radiusInMetre = radius * 1852;
    const phiCommand = (sweepAngle > 0 ? 1 : -1) * Math.atan(groundSpeed * groundSpeed / (radiusInMetre * 9.81)) * (180 / Math.PI);
    return {
      law: ControlLaw.LATERAL_PATH,
      trackAngleError,
      crossTrackError,
      phiCommand
    };
  }

  /**
   * Computes a point along a course to a fix
   *
   * @param distanceFromEnd distance before end of line
   * @param course          course of the line to the fix
   * @param fix             self-explanatory
   */
  function pointOnCourseToFix(distanceFromEnd, course, fix) {
    return Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(course + 180), distanceFromEnd, fix.lat, fix.long);
  }

  /**
   * Computes a point along an arc at a distance before its termination
   *
   * @param distanceFromFtp distance before end of arc
   * @param ftp             arc exit point
   * @param centreFix       arc centre fix
   * @param sweepAngle      angle swept around the arc, +ve for clockwise
   */
  function pointOnArc(distanceFromFtp, ftp, centreFix, sweepAngle) {
    const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, ftp);
    const distanceRatio = distanceFromFtp / arcLength(radius, sweepAngle);
    const angleFromFtp = -distanceRatio * sweepAngle;
    const centerToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ftp);
    return Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(centerToTerminationBearing + angleFromFtp), radius, centreFix.lat, centreFix.long);
  }
  function minBank(segment) {
    return segment === SegmentType.Enroute ? 5 : 10;
  }

  /**
   *
   * @param tas
   * @param pathCapture true when the turn is to capture a path or heading, or for curved legs
   * @returns
   */
  function maxBank(tas, pathCapture) {
    /*
    TODO
    if (engineOut) {
        return 15;
    }
    */

    if (pathCapture) {
      // roll limit 2 from honeywell doc
      if (tas < 100) {
        return 15 + tas / 10;
      }
      if (tas > 350) {
        return 19 + Math.max(0, (450 - tas) * 6 / 100);
      }
      return 25;
    }
    // roll limit 1
    if (tas < 150) {
      return 15 + tas / 10;
    }
    if (tas > 300) {
      return 19 + Math.max(0, (450 - tas) * 11 / 150);
    }
    return 30;
  }

  /**
   * Returns the largest acceptable turn anticipation distance for a given true air speed
   *
   * @param tas the current or predicted true airspeed
   */
  function maxTad(tas) {
    if (tas === undefined) {
      return 10;
    }
    if (tas <= 100) {
      return 4;
    }
    if (tas >= 100 && tas <= 400) {
      return tas / 100 * 4;
    }
    return 16;
  }
  function courseToFixDistanceToGo(ppos, course, fix) {
    const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
    const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
    const pposToFixAngle = Avionics.Utils.diffAngle(pposToFixBearing, course);
    return Math.max(0, pposToFixDist * Math.cos(pposToFixAngle * Math.PI / 180));
  }
  function courseToFixGuidance(ppos, trueTrack, course, fix) {
    const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
    const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
    const pposToFixAngle = Avionics.Utils.diffAngle(course, pposToFixBearing);
    const crossTrackError = pposToFixDist * Math.sin(pposToFixAngle * Math.PI / 180);
    const trackAngleError = Avionics.Utils.diffAngle(trueTrack, course);
    return {
      law: ControlLaw.LATERAL_PATH,
      trackAngleError,
      crossTrackError,
      phiCommand: 0
    };
  }
  let PointSide = /*#__PURE__*/function (PointSide) {
    PointSide[PointSide["Before"] = 0] = "Before";
    PointSide[PointSide["After"] = 1] = "After";
    return PointSide;
  }({});

  /**
   * Returns the side of a fix (considering a course inbound to that fix) a point is lying on, assuming they lie on the same
   * great circle.
   *
   * @param fix    destination fix
   * @param course course to the fix
   * @param point  point to compare with
   *
   * @returns `-1` if the point is before the fix, `1` if the point is after the fix
   */
  function sideOfPointOnCourseToFix(fix, course, point) {
    const bearingFixPoint = bearingTo(fix, point);
    const onOtherSide = Math.abs(MathUtils$1.diffAngle(bearingFixPoint, course)) < 3;
    if (onOtherSide) {
      return PointSide.After;
    }
    return PointSide.Before;
  }
  function getAlongTrackDistanceTo(start, end, ppos) {
    const R = Constants.EARTH_RADIUS_NM;
    const d13 = Avionics.Utils.computeGreatCircleDistance(start, ppos) / R;
    const Theta13 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, ppos);
    const Theta12 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, end);
    const deltaXt = Math.asin(Math.sin(d13) * Math.sin(Theta13 - Theta12));
    const deltaAt = Math.acos(Math.cos(d13) / Math.abs(Math.cos(deltaXt)));
    return deltaAt * Math.sign(Math.cos(Theta12 - Theta13)) * R;
  }
  function getIntermediatePoint(start, end, fraction) {
    const Phi1 = start.lat * Avionics.Utils.DEG2RAD;
    const Gamma1 = start.long * Avionics.Utils.DEG2RAD;
    const Phi2 = end.lat * Avionics.Utils.DEG2RAD;
    const Gamma2 = end.long * Avionics.Utils.DEG2RAD;
    const deltaPhi = Phi2 - Phi1;
    const deltaGamma = Gamma2 - Gamma1;
    const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(Phi1) * Math.cos(Phi2) * Math.sin(deltaGamma / 2) * Math.sin(deltaGamma / 2);
    const delta = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const A = Math.sin((1 - fraction) * delta) / Math.sin(delta);
    const B = Math.sin(fraction * delta) / Math.sin(delta);
    const x = A * Math.cos(Phi1) * Math.cos(Gamma1) + B * Math.cos(Phi2) * Math.cos(Gamma2);
    const y = A * Math.cos(Phi1) * Math.sin(Gamma1) + B * Math.cos(Phi2) * Math.sin(Gamma2);
    const z = A * Math.sin(Phi1) + B * Math.sin(Phi2);
    const Phi3 = Math.atan2(z, Math.sqrt(x * x + y * y));
    const Gamma3 = Math.atan2(y, x);
    return {
      lat: Phi3 * Avionics.Utils.RAD2DEG,
      long: Gamma3 * Avionics.Utils.RAD2DEG
    };
  }
  function fixToFixGuidance(ppos, trueTrack, from, to) {
    // Track angle error
    const totalTrackDistance = Avionics.Utils.computeGreatCircleDistance(from, to);
    const alongTrackDistance = getAlongTrackDistanceTo(from, to, ppos);
    const intermediatePoint = getIntermediatePoint(from, to, Math.min(Math.max(alongTrackDistance / totalTrackDistance, 0.05), 0.95));
    const desiredTrack = Avionics.Utils.computeGreatCircleHeading(intermediatePoint, to);
    const trackAngleError = MathUtils$1.mod(desiredTrack - trueTrack + 180, 360) - 180;

    // Cross track error
    const bearingAC = Avionics.Utils.computeGreatCircleHeading(from, ppos);
    const bearingAB = Avionics.Utils.computeGreatCircleHeading(from, to);
    const distanceAC = Avionics.Utils.computeDistance(from, ppos);
    const desiredOffset = 0;
    const actualOffset = Math.asin(Math.sin(Avionics.Utils.DEG2RAD * (distanceAC / Constants.EARTH_RADIUS_NM)) * Math.sin(Avionics.Utils.DEG2RAD * (bearingAC - bearingAB))) * Avionics.Utils.RAD2DEG * Constants.EARTH_RADIUS_NM;
    const crossTrackError = desiredOffset - actualOffset;
    return {
      law: ControlLaw.LATERAL_PATH,
      trackAngleError,
      crossTrackError,
      phiCommand: 0
    };
  }
  function arcLength(radius, sweepAngle) {
    const circumference = 2 * Math.PI * radius;
    return circumference / 360 * Math.abs(sweepAngle);
  }
  function reciprocal(course) {
    return Avionics.Utils.clampAngle(course + 180);
  }

  let PathVectorType = /*#__PURE__*/function (PathVectorType) {
    PathVectorType[PathVectorType["Line"] = 0] = "Line";
    PathVectorType[PathVectorType["Arc"] = 1] = "Arc";
    PathVectorType[PathVectorType["DebugPoint"] = 2] = "DebugPoint";
    return PathVectorType;
  }({});
  let DebugPointColour = /*#__PURE__*/function (DebugPointColour) {
    DebugPointColour[DebugPointColour["White"] = 0] = "White";
    DebugPointColour[DebugPointColour["Green"] = 1] = "Green";
    DebugPointColour[DebugPointColour["Yellow"] = 2] = "Yellow";
    DebugPointColour[DebugPointColour["Cyan"] = 3] = "Cyan";
    DebugPointColour[DebugPointColour["Magenta"] = 4] = "Magenta";
    return DebugPointColour;
  }({});
  function pathVectorLength(vector) {
    if (vector.type === PathVectorType.Line) {
      return Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.endPoint);
    }
    if (vector.type === PathVectorType.Arc) {
      const radius = Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.centrePoint);
      return arcLength(radius, vector.sweepAngle);
    }
    return 0;
  }
  function pathVectorValid(vector) {
    var _vector$startPoint, _vector$endPoint, _vector$endPoint2, _vector$centrePoint, _vector$startPoint2;
    switch (vector.type) {
      case PathVectorType.Line:
        return !!((_vector$startPoint = vector.startPoint) !== null && _vector$startPoint !== void 0 && _vector$startPoint.lat && (_vector$endPoint = vector.endPoint) !== null && _vector$endPoint !== void 0 && _vector$endPoint.lat);
      case PathVectorType.Arc:
        return !!((_vector$endPoint2 = vector.endPoint) !== null && _vector$endPoint2 !== void 0 && _vector$endPoint2.lat && (_vector$centrePoint = vector.centrePoint) !== null && _vector$centrePoint !== void 0 && _vector$centrePoint.lat && vector.sweepAngle);
      case PathVectorType.DebugPoint:
        return !!((_vector$startPoint2 = vector.startPoint) !== null && _vector$startPoint2 !== void 0 && _vector$startPoint2.lat);
      default:
        return true;
    }
  }
  function pathVectorPoint(vector, distanceFromEnd) {
    if (vector.type === PathVectorType.Line) {
      return pointOnCourseToFix(distanceFromEnd, Avionics.Utils.computeGreatCircleHeading(vector.startPoint, vector.endPoint), vector.endPoint);
    }
    if (vector.type === PathVectorType.Arc) {
      return pointOnArc(distanceFromEnd, vector.endPoint, vector.centrePoint, vector.sweepAngle);
    }
    return undefined;
  }

  /**
   * A `Guidable` is a part of an LNAV path. It can be either a leg or a transition.
   */
  class Guidable {
    constructor() {
      /**
       * Whether the guidable should be considered for map display, guidance and sequencing
       *
       * For a transition, this indicates that the transition between the legs is selected but has no geometry.
       * For a leg, this indicates that geometry conditions cause the leg to be skipped.
       */
      _defineProperty(this, "isNull", false);
      /**
       * The first valid guidable that precedes this one. This takes into account the `isNull` property, meaning other
       * guidables can exist before this one but would not be referred to by this property if they were to be null.
       */
      _defineProperty(this, "inboundGuidable", void 0);
      /**
       * The first valid guidable that succeeds this one. This takes into account the `isNull` property, meaning other
       * guidables can exist after this one but would not be referred to by this property if they were to be null.
       */
      _defineProperty(this, "outboundGuidable", void 0);
      _defineProperty(this, "isComputed", false);
    }

    /**
     * Used to update the {@link inboundGuidable} and {@link outboundGuidable} properties.
     */
    setNeighboringGuidables(inbound, outbound) {
      this.inboundGuidable = inbound;
      this.outboundGuidable = outbound;
    }
    getPathEndPoint() {
      if (this.isNull) {
        return this.inboundGuidable.getPathEndPoint();
      }
      if (this.predictedPath) {
        for (let i = this.predictedPath.length - 1; i >= 0; i--) {
          const vector = this.predictedPath[i];
          if (vector.type === PathVectorType.DebugPoint) {
            continue;
          }
          if (vector.endPoint) {
            return vector.endPoint;
          }
        }
      }
      return undefined;
    }

    /**
     * Recomputes the guidable using new parameters
     *
     * @param isActive          whether the guidable is being flown
     * @param tas               predicted true airspeed speed of the current leg (for a leg) or the next leg (for a transition) in knots
     * @param gs                predicted ground speed of the current leg
     * @param ppos              the current position of the aircraft
     * @param trueTrack         true ground track
     * @param previousGuidable  previous guidable before leg
     * @param nextGuidable      next guidable after leg
     */

    /**
     * Obtains guidance parameters that will be sent to the FG when this guidable is active (or being captured by a previous guidable)
     *
     * @param ppos     the current position of the aircraft
     * @param trueTrack true ground track
     * @param tas       true air speed
     * @param gs        ground speed
     */

    /**
     * Calculates directed DTG parameter
     *
     * @param ppos the current position of the aircraft
     */

    /**
     * Obtains the location of a pseudo-waypoint on the guidable (does NOT include inbound or outbound
     * transitions for legs; see {@link PseudoWaypoints.pointFromEndOfPath} for a function that includes those).
     *
     * @param distanceBeforeTerminator
     */
    getPseudoWaypointLocation(distanceBeforeTerminator) {
      let accumulator = 0;
      for (const vector of [...this.predictedPath].reverse()) {
        const length = pathVectorLength(vector);
        if (accumulator + length > distanceBeforeTerminator) {
          return pathVectorPoint(vector, distanceBeforeTerminator - accumulator);
        }
        accumulator += length;
      }
      return undefined;
    }

    /**
     * Path vectors for the predicted path.
     *
     * This path always represents what is being drawn on the ND, and is used for the vast majority of prediction computations. It is
     * however not always representative of guidance, for example in case of path capture or course capture transitions or CX/VX legs.
     */

    /**
     * Whether the path ends in a curved arc - for entry roll anticipation
     */
    get startsInCircularArc() {
      return false;
    }

    /**
     * Whether the path ends in a curved arc - for exit roll anticipation
     */
    get endsInCircularArc() {
      return false;
    }

    /**
     * Obtain the nominal roll angle for the curved portion of the path
     */
  }

  class Transition extends Guidable {
    constructor(previousLeg, nextLeg) {
      super();
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "isFrozen", false);
      this.inboundGuidable = previousLeg;
      this.outboundGuidable = nextLeg;
    }
    freeze() {
      this.isFrozen = true;
    }

    /**
     * Used to update the {@link previousLeg} and {@link nextLeg} properties.
     */
    setNeighboringLegs(previous, next) {
      this.previousLeg = previous;
      this.nextLeg = next;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      // Default impl.
    }
  }

  var constants = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.areaConversion = exports.timeConversion = exports.distanceConversion = exports.altitudeKeys = exports.latitudeKeys = exports.longitudeKeys = exports.MAXLON = exports.MINLON = exports.MAXLAT = exports.MINLAT = exports.earthRadius = exports.sexagesimalPattern = void 0;
    var sexagesimalPattern = /^([0-9]{1,3})\s*([0-9]{1,3}(?:\.(?:[0-9]{1,}))?)[']\s*(([0-9]{1,3}(\.([0-9]{1,}))?)["]\s*)?([NEOSW]?)$/;
    exports.sexagesimalPattern = sexagesimalPattern;
    var earthRadius = 6378137;
    exports.earthRadius = earthRadius;
    var MINLAT = -90;
    exports.MINLAT = MINLAT;
    var MAXLAT = 90;
    exports.MAXLAT = MAXLAT;
    var MINLON = -180;
    exports.MINLON = MINLON;
    var MAXLON = 180;
    exports.MAXLON = MAXLON;
    var longitudeKeys = ["lng", "lon", "longitude", 0];
    exports.longitudeKeys = longitudeKeys;
    var latitudeKeys = ["lat", "latitude", 1];
    exports.latitudeKeys = latitudeKeys;
    var altitudeKeys = ["alt", "altitude", "elevation", "elev", 2];
    exports.altitudeKeys = altitudeKeys;
    var distanceConversion = {
      m: 1,
      km: 0.001,
      cm: 100,
      mm: 1000,
      mi: 1 / 1609.344,
      sm: 1 / 1852.216,
      ft: 100 / 30.48,
      in: 100 / 2.54,
      yd: 1 / 0.9144
    };
    exports.distanceConversion = distanceConversion;
    var timeConversion = {
      m: 60,
      h: 3600,
      d: 86400
    };
    exports.timeConversion = timeConversion;
    var areaConversion = {
      m2: 1,
      km2: 0.000001,
      ha: 0.0001,
      a: 0.01,
      ft2: 10.763911,
      yd2: 1.19599,
      in2: 1550.0031
    };
    exports.areaConversion = areaConversion;
    areaConversion.sqm = areaConversion.m2;
    areaConversion.sqkm = areaConversion.km2;
    areaConversion.sqft = areaConversion.ft2;
    areaConversion.sqyd = areaConversion.yd2;
    areaConversion.sqin = areaConversion.in2;
  });

  var getCoordinateKey_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var getCoordinateKey = function getCoordinateKey(point, keysToLookup) {
      return keysToLookup.reduce(function (foundKey, key) {
        if (typeof point === "undefined" || point === null) {
          throw new Error("'".concat(point, "' is no valid coordinate."));
        }
        if (Object.prototype.hasOwnProperty.call(point, key) && typeof key !== "undefined" && typeof foundKey === "undefined") {
          foundKey = key;
          return key;
        }
        return foundKey;
      }, undefined);
    };
    var _default = getCoordinateKey;
    exports.default = _default;
  });

  var isDecimal_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var isDecimal = function isDecimal(value) {
      var checkedValue = value.toString().trim();
      if (isNaN(parseFloat(checkedValue))) {
        return false;
      }
      return parseFloat(checkedValue) === Number(checkedValue);
    };
    var _default = isDecimal;
    exports.default = _default;
  });

  var isSexagesimal_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var isSexagesimal = function isSexagesimal(value) {
      return constants.sexagesimalPattern.test(value.toString().trim());
    };
    var _default = isSexagesimal;
    exports.default = _default;
  });

  var sexagesimalToDecimal_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var sexagesimalToDecimal = function sexagesimalToDecimal(sexagesimal) {
      var data = new RegExp(constants.sexagesimalPattern).exec(sexagesimal.toString().trim());
      if (typeof data === "undefined" || data === null) {
        throw new Error("Given value is not in sexagesimal format");
      }
      var min = Number(data[2]) / 60 || 0;
      var sec = Number(data[4]) / 3600 || 0;
      var decimal = parseFloat(data[1]) + min + sec;
      return ["S", "W"].includes(data[7]) ? -decimal : decimal;
    };
    var _default = sexagesimalToDecimal;
    exports.default = _default;
  });

  var getCoordinateKeys_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var getCoordinateKeys = function getCoordinateKeys(point) {
      var keysToLookup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        longitude: constants.longitudeKeys,
        latitude: constants.latitudeKeys,
        altitude: constants.altitudeKeys
      };
      var longitude = (0, _getCoordinateKey.default)(point, keysToLookup.longitude);
      var latitude = (0, _getCoordinateKey.default)(point, keysToLookup.latitude);
      var altitude = (0, _getCoordinateKey.default)(point, keysToLookup.altitude);
      return _objectSpread({
        latitude: latitude,
        longitude: longitude
      }, altitude ? {
        altitude: altitude
      } : {});
    };
    var _default = getCoordinateKeys;
    exports.default = _default;
  });

  var isValidLatitude_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isDecimal = _interopRequireDefault(isDecimal_1);
    var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);
    var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isValidLatitude = function isValidLatitude(value) {
      if ((0, _isDecimal.default)(value)) {
        if (parseFloat(value) > constants.MAXLAT || value < constants.MINLAT) {
          return false;
        }
        return true;
      }
      if ((0, _isSexagesimal.default)(value)) {
        return isValidLatitude((0, _sexagesimalToDecimal.default)(value));
      }
      return false;
    };
    var _default = isValidLatitude;
    exports.default = _default;
  });

  var isValidLongitude_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isDecimal = _interopRequireDefault(isDecimal_1);
    var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);
    var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isValidLongitude = function isValidLongitude(value) {
      if ((0, _isDecimal.default)(value)) {
        if (parseFloat(value) > constants.MAXLON || value < constants.MINLON) {
          return false;
        }
        return true;
      }
      if ((0, _isSexagesimal.default)(value)) {
        return isValidLongitude((0, _sexagesimalToDecimal.default)(value));
      }
      return false;
    };
    var _default = isValidLongitude;
    exports.default = _default;
  });

  var isValidCoordinate_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getCoordinateKeys2 = _interopRequireDefault(getCoordinateKeys_1);
    var _isValidLatitude = _interopRequireDefault(isValidLatitude_1);
    var _isValidLongitude = _interopRequireDefault(isValidLongitude_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isValidCoordinate = function isValidCoordinate(point) {
      var _getCoordinateKeys = (0, _getCoordinateKeys2.default)(point),
        latitude = _getCoordinateKeys.latitude,
        longitude = _getCoordinateKeys.longitude;
      if (Array.isArray(point) && point.length >= 2) {
        return (0, _isValidLongitude.default)(point[0]) && (0, _isValidLatitude.default)(point[1]);
      }
      if (typeof latitude === "undefined" || typeof longitude === "undefined") {
        return false;
      }
      var lon = point[longitude];
      var lat = point[latitude];
      if (typeof lat === "undefined" || typeof lon === "undefined") {
        return false;
      }
      if ((0, _isValidLatitude.default)(lat) === false || (0, _isValidLongitude.default)(lon) === false) {
        return false;
      }
      return true;
    };
    var _default = isValidCoordinate;
    exports.default = _default;
  });

  var toDecimal_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _isDecimal = _interopRequireDefault(isDecimal_1);
    var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);
    var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);
    var _isValidCoordinate = _interopRequireDefault(isValidCoordinate_1);
    var _getCoordinateKeys = _interopRequireDefault(getCoordinateKeys_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var toDecimal = function toDecimal(value) {
      if ((0, _isDecimal.default)(value)) {
        return Number(value);
      }
      if ((0, _isSexagesimal.default)(value)) {
        return (0, _sexagesimalToDecimal.default)(value);
      }
      if ((0, _isValidCoordinate.default)(value)) {
        var keys = (0, _getCoordinateKeys.default)(value);
        if (Array.isArray(value)) {
          return value.map(function (v, index) {
            return [0, 1].includes(index) ? toDecimal(v) : v;
          });
        }
        return _objectSpread(_objectSpread(_objectSpread({}, value), keys.latitude && _defineProperty({}, keys.latitude, toDecimal(value[keys.latitude]))), keys.longitude && _defineProperty({}, keys.longitude, toDecimal(value[keys.longitude])));
      }
      if (Array.isArray(value)) {
        return value.map(function (point) {
          return (0, _isValidCoordinate.default)(point) ? toDecimal(point) : point;
        });
      }
      return value;
    };
    var _default = toDecimal;
    exports.default = _default;
  });

  var getLatitude_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);
    var _toDecimal = _interopRequireDefault(toDecimal_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getLatitude = function getLatitude(point, raw) {
      var latKey = (0, _getCoordinateKey.default)(point, constants.latitudeKeys);
      if (typeof latKey === "undefined" || latKey === null) {
        return;
      }
      var value = point[latKey];
      return raw === true ? value : (0, _toDecimal.default)(value);
    };
    var _default = getLatitude;
    exports.default = _default;
  });

  var getLongitude_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);
    var _toDecimal = _interopRequireDefault(toDecimal_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getLongitude = function getLongitude(point, raw) {
      var latKey = (0, _getCoordinateKey.default)(point, constants.longitudeKeys);
      if (typeof latKey === "undefined" || latKey === null) {
        return;
      }
      var value = point[latKey];
      return raw === true ? value : (0, _toDecimal.default)(value);
    };
    var _default = getLongitude;
    exports.default = _default;
  });

  var toRad_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toRad = function toRad(value) {
      return value * Math.PI / 180;
    };
    var _default = toRad;
    exports.default = _default;
  });

  var toDeg_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var toDeg = function toDeg(value) {
      return value * 180 / Math.PI;
    };
    var _default = toDeg;
    exports.default = _default;
  });

  var computeDestinationPoint_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _toDeg = _interopRequireDefault(toDeg_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var computeDestinationPoint = function computeDestinationPoint(start, distance, bearing) {
      var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371000;
      var lat = (0, _getLatitude.default)(start);
      var lng = (0, _getLongitude.default)(start);
      var delta = distance / radius;
      var theta = (0, _toRad.default)(bearing);
      var phi1 = (0, _toRad.default)(lat);
      var lambda1 = (0, _toRad.default)(lng);
      var phi2 = Math.asin(Math.sin(phi1) * Math.cos(delta) + Math.cos(phi1) * Math.sin(delta) * Math.cos(theta));
      var lambda2 = lambda1 + Math.atan2(Math.sin(theta) * Math.sin(delta) * Math.cos(phi1), Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2));
      var longitude = (0, _toDeg.default)(lambda2);
      if (longitude < constants.MINLON || longitude > constants.MAXLON) {
        lambda2 = (lambda2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
        longitude = (0, _toDeg.default)(lambda2);
      }
      return {
        latitude: (0, _toDeg.default)(phi2),
        longitude: longitude
      };
    };
    var _default = computeDestinationPoint;
    exports.default = _default;
  });

  var convertArea_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var convertArea = function convertArea(squareMeters) {
      var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";
      var factor = constants.areaConversion[targetUnit];
      if (factor) {
        return squareMeters * factor;
      }
      throw new Error("Invalid unit used for area conversion.");
    };
    var _default = convertArea;
    exports.default = _default;
  });

  var convertDistance_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var convertDistance = function convertDistance(meters) {
      var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";
      var factor = constants.distanceConversion[targetUnit];
      if (factor) {
        return meters * factor;
      }
      throw new Error("Invalid unit used for distance conversion.");
    };
    var _default = convertDistance;
    exports.default = _default;
  });

  var convertSpeed_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var convertSpeed = function convertSpeed(metersPerSecond) {
      var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "kmh";
      switch (targetUnit) {
        case "kmh":
          return metersPerSecond * constants.timeConversion.h * constants.distanceConversion.km;
        case "mph":
          return metersPerSecond * constants.timeConversion.h * constants.distanceConversion.mi;
        default:
          return metersPerSecond;
      }
    };
    var _default = convertSpeed;
    exports.default = _default;
  });

  var decimalToSexagesimal = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var imprecise = function imprecise(number) {
      var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
      var factor = Math.pow(10, decimals);
      return Math.round(number * factor) / factor;
    };
    var decimal2sexagesimalNext = function decimal2sexagesimalNext(decimal) {
      var _decimal$toString$spl = decimal.toString().split("."),
        _decimal$toString$spl2 = _slicedToArray(_decimal$toString$spl, 2),
        pre = _decimal$toString$spl2[0],
        post = _decimal$toString$spl2[1];
      var deg = Math.abs(Number(pre));
      var min0 = Number("0." + (post || 0)) * 60;
      var sec0 = min0.toString().split(".");
      var min = Math.floor(min0);
      var sec = imprecise(Number("0." + (sec0[1] || 0)) * 60).toString();
      var _sec$split = sec.split("."),
        _sec$split2 = _slicedToArray(_sec$split, 2),
        secPreDec = _sec$split2[0],
        _sec$split2$ = _sec$split2[1],
        secDec = _sec$split2$ === void 0 ? "0" : _sec$split2$;
      return deg + "\xB0 " + min.toString().padStart(2, "0") + "' " + secPreDec.padStart(2, "0") + "." + secDec.padEnd(1, "0") + "\"";
    };
    var _default = decimal2sexagesimalNext;
    exports.default = _default;
  });

  var robustAcos_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var robustAcos = function robustAcos(value) {
      if (value > 1) {
        return 1;
      }
      if (value < -1) {
        return -1;
      }
      return value;
    };
    var _default = robustAcos;
    exports.default = _default;
  });

  var getDistance_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _robustAcos = _interopRequireDefault(robustAcos_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getDistance = function getDistance(from, to) {
      var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
      var fromLat = (0, _getLatitude.default)(from);
      var fromLon = (0, _getLongitude.default)(from);
      var toLat = (0, _getLatitude.default)(to);
      var toLon = (0, _getLongitude.default)(to);
      var distance = Math.acos((0, _robustAcos.default)(Math.sin((0, _toRad.default)(toLat)) * Math.sin((0, _toRad.default)(fromLat)) + Math.cos((0, _toRad.default)(toLat)) * Math.cos((0, _toRad.default)(fromLat)) * Math.cos((0, _toRad.default)(fromLon) - (0, _toRad.default)(toLon)))) * constants.earthRadius;
      return Math.round(distance / accuracy) * accuracy;
    };
    var _default = getDistance;
    exports.default = _default;
  });

  var orderByDistance_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var orderByDistance = function orderByDistance(point, coords) {
      var distanceFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getDistance.default;
      distanceFn = typeof distanceFn === "function" ? distanceFn : _getDistance.default;
      return coords.slice().sort(function (a, b) {
        return distanceFn(point, a) - distanceFn(point, b);
      });
    };
    var _default = orderByDistance;
    exports.default = _default;
  });

  var findNearest_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _orderByDistance = _interopRequireDefault(orderByDistance_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var findNearest = function findNearest(point, coords) {
      return (0, _orderByDistance.default)(point, coords)[0];
    };
    var _default = findNearest;
    exports.default = _default;
  });

  var getAreaOfPolygon_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _toRad = _interopRequireDefault(toRad_1);
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getAreaOfPolygon = function getAreaOfPolygon(points) {
      var area = 0;
      if (points.length > 2) {
        var lowerIndex;
        var middleIndex;
        var upperIndex;
        for (var i = 0; i < points.length; i++) {
          if (i === points.length - 2) {
            lowerIndex = points.length - 2;
            middleIndex = points.length - 1;
            upperIndex = 0;
          } else if (i === points.length - 1) {
            lowerIndex = points.length - 1;
            middleIndex = 0;
            upperIndex = 1;
          } else {
            lowerIndex = i;
            middleIndex = i + 1;
            upperIndex = i + 2;
          }
          var p1lon = (0, _getLongitude.default)(points[lowerIndex]);
          var p2lat = (0, _getLatitude.default)(points[middleIndex]);
          var p3lon = (0, _getLongitude.default)(points[upperIndex]);
          area += ((0, _toRad.default)(p3lon) - (0, _toRad.default)(p1lon)) * Math.sin((0, _toRad.default)(p2lat));
        }
        area = area * constants.earthRadius * constants.earthRadius / 2;
      }
      return Math.abs(area);
    };
    var _default = getAreaOfPolygon;
    exports.default = _default;
  });

  var getBounds_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getBounds = function getBounds(points) {
      if (Array.isArray(points) === false || points.length === 0) {
        throw new Error("No points were given.");
      }
      return points.reduce(function (stats, point) {
        var latitude = (0, _getLatitude.default)(point);
        var longitude = (0, _getLongitude.default)(point);
        return {
          maxLat: Math.max(latitude, stats.maxLat),
          minLat: Math.min(latitude, stats.minLat),
          maxLng: Math.max(longitude, stats.maxLng),
          minLng: Math.min(longitude, stats.minLng)
        };
      }, {
        maxLat: -Infinity,
        minLat: Infinity,
        maxLng: -Infinity,
        minLng: Infinity
      });
    };
    var _default = getBounds;
    exports.default = _default;
  });

  var getBoundsOfDistance_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _toDeg = _interopRequireDefault(toDeg_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getBoundsOfDistance = function getBoundsOfDistance(point, distance) {
      var latitude = (0, _getLatitude.default)(point);
      var longitude = (0, _getLongitude.default)(point);
      var radLat = (0, _toRad.default)(latitude);
      var radLon = (0, _toRad.default)(longitude);
      var radDist = distance / constants.earthRadius;
      var minLat = radLat - radDist;
      var maxLat = radLat + radDist;
      var MAX_LAT_RAD = (0, _toRad.default)(constants.MAXLAT);
      var MIN_LAT_RAD = (0, _toRad.default)(constants.MINLAT);
      var MAX_LON_RAD = (0, _toRad.default)(constants.MAXLON);
      var MIN_LON_RAD = (0, _toRad.default)(constants.MINLON);
      var minLon;
      var maxLon;
      if (minLat > MIN_LAT_RAD && maxLat < MAX_LAT_RAD) {
        var deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));
        minLon = radLon - deltaLon;
        if (minLon < MIN_LON_RAD) {
          minLon += Math.PI * 2;
        }
        maxLon = radLon + deltaLon;
        if (maxLon > MAX_LON_RAD) {
          maxLon -= Math.PI * 2;
        }
      } else {
        minLat = Math.max(minLat, MIN_LAT_RAD);
        maxLat = Math.min(maxLat, MAX_LAT_RAD);
        minLon = MIN_LON_RAD;
        maxLon = MAX_LON_RAD;
      }
      return [{
        latitude: (0, _toDeg.default)(minLat),
        longitude: (0, _toDeg.default)(minLon)
      }, {
        latitude: (0, _toDeg.default)(maxLat),
        longitude: (0, _toDeg.default)(maxLon)
      }];
    };
    var _default = getBoundsOfDistance;
    exports.default = _default;
  });

  var getCenter_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _toDeg = _interopRequireDefault(toDeg_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getCenter = function getCenter(points) {
      if (Array.isArray(points) === false || points.length === 0) {
        return false;
      }
      var numberOfPoints = points.length;
      var sum = points.reduce(function (acc, point) {
        var pointLat = (0, _toRad.default)((0, _getLatitude.default)(point));
        var pointLon = (0, _toRad.default)((0, _getLongitude.default)(point));
        return {
          X: acc.X + Math.cos(pointLat) * Math.cos(pointLon),
          Y: acc.Y + Math.cos(pointLat) * Math.sin(pointLon),
          Z: acc.Z + Math.sin(pointLat)
        };
      }, {
        X: 0,
        Y: 0,
        Z: 0
      });
      var X = sum.X / numberOfPoints;
      var Y = sum.Y / numberOfPoints;
      var Z = sum.Z / numberOfPoints;
      return {
        longitude: (0, _toDeg.default)(Math.atan2(Y, X)),
        latitude: (0, _toDeg.default)(Math.atan2(Z, Math.sqrt(X * X + Y * Y)))
      };
    };
    var _default = getCenter;
    exports.default = _default;
  });

  var getCenterOfBounds_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getBounds = _interopRequireDefault(getBounds_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getCenterOfBounds = function getCenterOfBounds(coords) {
      var bounds = (0, _getBounds.default)(coords);
      var latitude = bounds.minLat + (bounds.maxLat - bounds.minLat) / 2;
      var longitude = bounds.minLng + (bounds.maxLng - bounds.minLng) / 2;
      return {
        latitude: parseFloat(latitude.toFixed(6)),
        longitude: parseFloat(longitude.toFixed(6))
      };
    };
    var _default = getCenterOfBounds;
    exports.default = _default;
  });

  var getRhumbLineBearing_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _toDeg = _interopRequireDefault(toDeg_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getRhumbLineBearing = function getRhumbLineBearing(origin, dest) {
      var diffLon = (0, _toRad.default)((0, _getLongitude.default)(dest)) - (0, _toRad.default)((0, _getLongitude.default)(origin));
      var diffPhi = Math.log(Math.tan((0, _toRad.default)((0, _getLatitude.default)(dest)) / 2 + Math.PI / 4) / Math.tan((0, _toRad.default)((0, _getLatitude.default)(origin)) / 2 + Math.PI / 4));
      if (Math.abs(diffLon) > Math.PI) {
        if (diffLon > 0) {
          diffLon = (Math.PI * 2 - diffLon) * -1;
        } else {
          diffLon = Math.PI * 2 + diffLon;
        }
      }
      return ((0, _toDeg.default)(Math.atan2(diffLon, diffPhi)) + 360) % 360;
    };
    var _default = getRhumbLineBearing;
    exports.default = _default;
  });

  var getCompassDirection_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getRhumbLineBearing = _interopRequireDefault(getRhumbLineBearing_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getCompassDirection = function getCompassDirection(origin, dest) {
      var bearingFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getRhumbLineBearing.default;
      var bearing = typeof bearingFn === "function" ? bearingFn(origin, dest) : (0, _getRhumbLineBearing.default)(origin, dest);
      if (isNaN(bearing)) {
        throw new Error("Could not calculate bearing for given points. Check your bearing function");
      }
      switch (Math.round(bearing / 22.5)) {
        case 1:
          return "NNE";
        case 2:
          return "NE";
        case 3:
          return "ENE";
        case 4:
          return "E";
        case 5:
          return "ESE";
        case 6:
          return "SE";
        case 7:
          return "SSE";
        case 8:
          return "S";
        case 9:
          return "SSW";
        case 10:
          return "SW";
        case 11:
          return "WSW";
        case 12:
          return "W";
        case 13:
          return "WNW";
        case 14:
          return "NW";
        case 15:
          return "NNW";
        default:
          return "N";
      }
    };
    var _default = getCompassDirection;
    exports.default = _default;
  });

  var getDistanceFromLine_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance_1);
    var _robustAcos = _interopRequireDefault(robustAcos_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getDistanceFromLine = function getDistanceFromLine(point, lineStart, lineEnd) {
      var accuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var d1 = (0, _getDistance.default)(lineStart, point, accuracy);
      var d2 = (0, _getDistance.default)(point, lineEnd, accuracy);
      var d3 = (0, _getDistance.default)(lineStart, lineEnd, accuracy);
      var alpha = Math.acos((0, _robustAcos.default)((d1 * d1 + d3 * d3 - d2 * d2) / (2 * d1 * d3)));
      var beta = Math.acos((0, _robustAcos.default)((d2 * d2 + d3 * d3 - d1 * d1) / (2 * d2 * d3)));
      if (alpha > Math.PI / 2) {
        return d1;
      }
      if (beta > Math.PI / 2) {
        return d2;
      }
      return Math.sin(alpha) * d1;
    };
    var _default = getDistanceFromLine;
    exports.default = _default;
  });

  var getGreatCircleBearing_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _toDeg = _interopRequireDefault(toDeg_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getGreatCircleBearing = function getGreatCircleBearing(origin, dest) {
      var destLat = (0, _getLatitude.default)(dest);
      var detLon = (0, _getLongitude.default)(dest);
      var originLat = (0, _getLatitude.default)(origin);
      var originLon = (0, _getLongitude.default)(origin);
      var bearing = ((0, _toDeg.default)(Math.atan2(Math.sin((0, _toRad.default)(detLon) - (0, _toRad.default)(originLon)) * Math.cos((0, _toRad.default)(destLat)), Math.cos((0, _toRad.default)(originLat)) * Math.sin((0, _toRad.default)(destLat)) - Math.sin((0, _toRad.default)(originLat)) * Math.cos((0, _toRad.default)(destLat)) * Math.cos((0, _toRad.default)(detLon) - (0, _toRad.default)(originLon)))) + 360) % 360;
      return bearing;
    };
    var _default = getGreatCircleBearing;
    exports.default = _default;
  });

  var getPathLength_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof(obj);
    }
    var getPathLength = function getPathLength(points) {
      var distanceFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _getDistance.default;
      return points.reduce(function (acc, point) {
        if (_typeof(acc) === "object" && acc.last !== null) {
          acc.distance += distanceFn(point, acc.last);
        }
        acc.last = point;
        return acc;
      }, {
        last: null,
        distance: 0
      }).distance;
    };
    var _default = getPathLength;
    exports.default = _default;
  });

  var getPreciseDistance = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _toRad = _interopRequireDefault(toRad_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getDistance = function getDistance(start, end) {
      var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
      var startLat = (0, _getLatitude.default)(start);
      var startLon = (0, _getLongitude.default)(start);
      var endLat = (0, _getLatitude.default)(end);
      var endLon = (0, _getLongitude.default)(end);
      var b = 6356752.314245;
      var ellipsoidParams = 1 / 298.257223563;
      var L = (0, _toRad.default)(endLon - startLon);
      var cosSigma;
      var sigma;
      var sinAlpha;
      var cosSqAlpha;
      var cos2SigmaM;
      var sinSigma;
      var U1 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(startLat))));
      var U2 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(endLat))));
      var sinU1 = Math.sin(U1);
      var cosU1 = Math.cos(U1);
      var sinU2 = Math.sin(U2);
      var cosU2 = Math.cos(U2);
      var lambda = L;
      var lambdaP;
      var iterLimit = 100;
      do {
        var sinLambda = Math.sin(lambda);
        var cosLambda = Math.cos(lambda);
        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
        if (sinSigma === 0) {
          return 0;
        }
        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
        sigma = Math.atan2(sinSigma, cosSigma);
        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
        cosSqAlpha = 1 - sinAlpha * sinAlpha;
        cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
        if (isNaN(cos2SigmaM)) {
          cos2SigmaM = 0;
        }
        var C = ellipsoidParams / 16 * cosSqAlpha * (4 + ellipsoidParams * (4 - 3 * cosSqAlpha));
        lambdaP = lambda;
        lambda = L + (1 - C) * ellipsoidParams * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
      } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
      if (iterLimit === 0) {
        return NaN;
      }
      var uSq = cosSqAlpha * (constants.earthRadius * constants.earthRadius - b * b) / (b * b);
      var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
      var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
      var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
      var distance = b * A * (sigma - deltaSigma);
      return Math.round(distance / accuracy) * accuracy;
    };
    var _default = getDistance;
    exports.default = _default;
  });

  var getRoughCompassDirection_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var getRoughCompassDirection = function getRoughCompassDirection(exact) {
      if (/^NNE|NE|NNW|N$/.test(exact)) {
        return "N";
      }
      if (/^ENE|E|ESE|SE$/.test(exact)) {
        return "E";
      }
      if (/^SSE|S|SSW|SW$/.test(exact)) {
        return "S";
      }
      if (/^WSW|W|WNW|NW$/.test(exact)) {
        return "W";
      }
    };
    var _default = getRoughCompassDirection;
    exports.default = _default;
  });

  var getSpeed_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getSpeed = function getSpeed(start, end) {
      var distanceFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getDistance.default;
      var distance = distanceFn(start, end);
      var time = Number(end.time) - Number(start.time);
      var metersPerSecond = distance / time * 1000;
      return metersPerSecond;
    };
    var _default = getSpeed;
    exports.default = _default;
  });

  var isPointInLine_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointInLine = function isPointInLine(point, lineStart, lineEnd) {
      return (0, _getDistance.default)(lineStart, point) + (0, _getDistance.default)(point, lineEnd) === (0, _getDistance.default)(lineStart, lineEnd);
    };
    var _default = isPointInLine;
    exports.default = _default;
  });

  var isPointInPolygon_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointInPolygon = function isPointInPolygon(point, polygon) {
      var isInside = false;
      var totalPolys = polygon.length;
      for (var i = -1, j = totalPolys - 1; ++i < totalPolys; j = i) {
        if (((0, _getLongitude.default)(polygon[i]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[j]) || (0, _getLongitude.default)(polygon[j]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[i])) && (0, _getLatitude.default)(point) < ((0, _getLatitude.default)(polygon[j]) - (0, _getLatitude.default)(polygon[i])) * ((0, _getLongitude.default)(point) - (0, _getLongitude.default)(polygon[i])) / ((0, _getLongitude.default)(polygon[j]) - (0, _getLongitude.default)(polygon[i])) + (0, _getLatitude.default)(polygon[i])) {
          isInside = !isInside;
        }
      }
      return isInside;
    };
    var _default = isPointInPolygon;
    exports.default = _default;
  });

  var isPointNearLine_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistanceFromLine = _interopRequireDefault(getDistanceFromLine_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointNearLine = function isPointNearLine(point, start, end, distance) {
      return (0, _getDistanceFromLine.default)(point, start, end) < distance;
    };
    var _default = isPointNearLine;
    exports.default = _default;
  });

  var isPointWithinRadius_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _getDistance = _interopRequireDefault(getDistance_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isPointWithinRadius = function isPointWithinRadius(point, center, radius) {
      return (0, _getDistance.default)(point, center) < radius;
    };
    var _default = isPointWithinRadius;
    exports.default = _default;
  });

  var wktToPolygon_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    var wktToPolygon = function wktToPolygon(wkt) {
      if (!wkt.startsWith("POLYGON")) {
        throw new Error("Invalid wkt.");
      }
      var coordsText = wkt.slice(wkt.indexOf("(") + 2, wkt.indexOf(")")).split(", ");
      var polygon = coordsText.map(function (coordText) {
        var _coordText$split = coordText.split(" "),
          _coordText$split2 = _slicedToArray(_coordText$split, 2),
          longitude = _coordText$split2[0],
          latitude = _coordText$split2[1];
        return {
          longitude: parseFloat(longitude),
          latitude: parseFloat(latitude)
        };
      });
      return polygon;
    };
    var _default = wktToPolygon;
    exports.default = _default;
  });

  var es = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      computeDestinationPoint: true,
      convertArea: true,
      convertDistance: true,
      convertSpeed: true,
      decimalToSexagesimal: true,
      findNearest: true,
      getAreaOfPolygon: true,
      getBounds: true,
      getBoundsOfDistance: true,
      getCenter: true,
      getCenterOfBounds: true,
      getCompassDirection: true,
      getCoordinateKey: true,
      getCoordinateKeys: true,
      getDistance: true,
      getDistanceFromLine: true,
      getGreatCircleBearing: true,
      getLatitude: true,
      getLongitude: true,
      getPathLength: true,
      getPreciseDistance: true,
      getRhumbLineBearing: true,
      getRoughCompassDirection: true,
      getSpeed: true,
      isDecimal: true,
      isPointInLine: true,
      isPointInPolygon: true,
      isPointNearLine: true,
      isPointWithinRadius: true,
      isSexagesimal: true,
      isValidCoordinate: true,
      isValidLatitude: true,
      isValidLongitude: true,
      orderByDistance: true,
      sexagesimalToDecimal: true,
      toDecimal: true,
      toRad: true,
      toDeg: true,
      wktToPolygon: true
    };
    Object.defineProperty(exports, "computeDestinationPoint", {
      enumerable: true,
      get: function get() {
        return _computeDestinationPoint.default;
      }
    });
    Object.defineProperty(exports, "convertArea", {
      enumerable: true,
      get: function get() {
        return _convertArea.default;
      }
    });
    Object.defineProperty(exports, "convertDistance", {
      enumerable: true,
      get: function get() {
        return _convertDistance.default;
      }
    });
    Object.defineProperty(exports, "convertSpeed", {
      enumerable: true,
      get: function get() {
        return _convertSpeed.default;
      }
    });
    Object.defineProperty(exports, "decimalToSexagesimal", {
      enumerable: true,
      get: function get() {
        return _decimalToSexagesimal.default;
      }
    });
    Object.defineProperty(exports, "findNearest", {
      enumerable: true,
      get: function get() {
        return _findNearest.default;
      }
    });
    Object.defineProperty(exports, "getAreaOfPolygon", {
      enumerable: true,
      get: function get() {
        return _getAreaOfPolygon.default;
      }
    });
    Object.defineProperty(exports, "getBounds", {
      enumerable: true,
      get: function get() {
        return _getBounds.default;
      }
    });
    Object.defineProperty(exports, "getBoundsOfDistance", {
      enumerable: true,
      get: function get() {
        return _getBoundsOfDistance.default;
      }
    });
    Object.defineProperty(exports, "getCenter", {
      enumerable: true,
      get: function get() {
        return _getCenter.default;
      }
    });
    Object.defineProperty(exports, "getCenterOfBounds", {
      enumerable: true,
      get: function get() {
        return _getCenterOfBounds.default;
      }
    });
    Object.defineProperty(exports, "getCompassDirection", {
      enumerable: true,
      get: function get() {
        return _getCompassDirection.default;
      }
    });
    Object.defineProperty(exports, "getCoordinateKey", {
      enumerable: true,
      get: function get() {
        return _getCoordinateKey.default;
      }
    });
    Object.defineProperty(exports, "getCoordinateKeys", {
      enumerable: true,
      get: function get() {
        return _getCoordinateKeys.default;
      }
    });
    Object.defineProperty(exports, "getDistance", {
      enumerable: true,
      get: function get() {
        return _getDistance.default;
      }
    });
    Object.defineProperty(exports, "getDistanceFromLine", {
      enumerable: true,
      get: function get() {
        return _getDistanceFromLine.default;
      }
    });
    Object.defineProperty(exports, "getGreatCircleBearing", {
      enumerable: true,
      get: function get() {
        return _getGreatCircleBearing.default;
      }
    });
    Object.defineProperty(exports, "getLatitude", {
      enumerable: true,
      get: function get() {
        return _getLatitude.default;
      }
    });
    Object.defineProperty(exports, "getLongitude", {
      enumerable: true,
      get: function get() {
        return _getLongitude.default;
      }
    });
    Object.defineProperty(exports, "getPathLength", {
      enumerable: true,
      get: function get() {
        return _getPathLength.default;
      }
    });
    Object.defineProperty(exports, "getPreciseDistance", {
      enumerable: true,
      get: function get() {
        return _getPreciseDistance.default;
      }
    });
    Object.defineProperty(exports, "getRhumbLineBearing", {
      enumerable: true,
      get: function get() {
        return _getRhumbLineBearing.default;
      }
    });
    Object.defineProperty(exports, "getRoughCompassDirection", {
      enumerable: true,
      get: function get() {
        return _getRoughCompassDirection.default;
      }
    });
    Object.defineProperty(exports, "getSpeed", {
      enumerable: true,
      get: function get() {
        return _getSpeed.default;
      }
    });
    Object.defineProperty(exports, "isDecimal", {
      enumerable: true,
      get: function get() {
        return _isDecimal.default;
      }
    });
    Object.defineProperty(exports, "isPointInLine", {
      enumerable: true,
      get: function get() {
        return _isPointInLine.default;
      }
    });
    Object.defineProperty(exports, "isPointInPolygon", {
      enumerable: true,
      get: function get() {
        return _isPointInPolygon.default;
      }
    });
    Object.defineProperty(exports, "isPointNearLine", {
      enumerable: true,
      get: function get() {
        return _isPointNearLine.default;
      }
    });
    Object.defineProperty(exports, "isPointWithinRadius", {
      enumerable: true,
      get: function get() {
        return _isPointWithinRadius.default;
      }
    });
    Object.defineProperty(exports, "isSexagesimal", {
      enumerable: true,
      get: function get() {
        return _isSexagesimal.default;
      }
    });
    Object.defineProperty(exports, "isValidCoordinate", {
      enumerable: true,
      get: function get() {
        return _isValidCoordinate.default;
      }
    });
    Object.defineProperty(exports, "isValidLatitude", {
      enumerable: true,
      get: function get() {
        return _isValidLatitude.default;
      }
    });
    Object.defineProperty(exports, "isValidLongitude", {
      enumerable: true,
      get: function get() {
        return _isValidLongitude.default;
      }
    });
    Object.defineProperty(exports, "orderByDistance", {
      enumerable: true,
      get: function get() {
        return _orderByDistance.default;
      }
    });
    Object.defineProperty(exports, "sexagesimalToDecimal", {
      enumerable: true,
      get: function get() {
        return _sexagesimalToDecimal.default;
      }
    });
    Object.defineProperty(exports, "toDecimal", {
      enumerable: true,
      get: function get() {
        return _toDecimal.default;
      }
    });
    Object.defineProperty(exports, "toRad", {
      enumerable: true,
      get: function get() {
        return _toRad.default;
      }
    });
    Object.defineProperty(exports, "toDeg", {
      enumerable: true,
      get: function get() {
        return _toDeg.default;
      }
    });
    Object.defineProperty(exports, "wktToPolygon", {
      enumerable: true,
      get: function get() {
        return _wktToPolygon.default;
      }
    });
    var _computeDestinationPoint = _interopRequireDefault(computeDestinationPoint_1);
    var _convertArea = _interopRequireDefault(convertArea_1);
    var _convertDistance = _interopRequireDefault(convertDistance_1);
    var _convertSpeed = _interopRequireDefault(convertSpeed_1);
    var _decimalToSexagesimal = _interopRequireDefault(decimalToSexagesimal);
    var _findNearest = _interopRequireDefault(findNearest_1);
    var _getAreaOfPolygon = _interopRequireDefault(getAreaOfPolygon_1);
    var _getBounds = _interopRequireDefault(getBounds_1);
    var _getBoundsOfDistance = _interopRequireDefault(getBoundsOfDistance_1);
    var _getCenter = _interopRequireDefault(getCenter_1);
    var _getCenterOfBounds = _interopRequireDefault(getCenterOfBounds_1);
    var _getCompassDirection = _interopRequireDefault(getCompassDirection_1);
    var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);
    var _getCoordinateKeys = _interopRequireDefault(getCoordinateKeys_1);
    var _getDistance = _interopRequireDefault(getDistance_1);
    var _getDistanceFromLine = _interopRequireDefault(getDistanceFromLine_1);
    var _getGreatCircleBearing = _interopRequireDefault(getGreatCircleBearing_1);
    var _getLatitude = _interopRequireDefault(getLatitude_1);
    var _getLongitude = _interopRequireDefault(getLongitude_1);
    var _getPathLength = _interopRequireDefault(getPathLength_1);
    var _getPreciseDistance = _interopRequireDefault(getPreciseDistance);
    var _getRhumbLineBearing = _interopRequireDefault(getRhumbLineBearing_1);
    var _getRoughCompassDirection = _interopRequireDefault(getRoughCompassDirection_1);
    var _getSpeed = _interopRequireDefault(getSpeed_1);
    var _isDecimal = _interopRequireDefault(isDecimal_1);
    var _isPointInLine = _interopRequireDefault(isPointInLine_1);
    var _isPointInPolygon = _interopRequireDefault(isPointInPolygon_1);
    var _isPointNearLine = _interopRequireDefault(isPointNearLine_1);
    var _isPointWithinRadius = _interopRequireDefault(isPointWithinRadius_1);
    var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);
    var _isValidCoordinate = _interopRequireDefault(isValidCoordinate_1);
    var _isValidLatitude = _interopRequireDefault(isValidLatitude_1);
    var _isValidLongitude = _interopRequireDefault(isValidLongitude_1);
    var _orderByDistance = _interopRequireDefault(orderByDistance_1);
    var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);
    var _toDecimal = _interopRequireDefault(toDecimal_1);
    var _toRad = _interopRequireDefault(toRad_1);
    var _toDeg = _interopRequireDefault(toDeg_1);
    var _wktToPolygon = _interopRequireDefault(wktToPolygon_1);
    Object.keys(constants).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return constants[key];
        }
      });
    });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  });

  class Leg extends Guidable {
    constructor() {
      super(...arguments);
      _defineProperty(this, "segment", void 0);
      _defineProperty(this, "metadata", void 0);
      _defineProperty(this, "constrainedTurnDirection", void 0);
      _defineProperty(this, "isNull", false);
      _defineProperty(this, "displayedOnMap", true);
      _defineProperty(this, "predictedTas", void 0);
      _defineProperty(this, "predictedGs", void 0);
    }
    get disableAutomaticSequencing() {
      return false;
    }

    /** @inheritDoc */
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      // Default impl.
    }
    get distance() {
      try {
        return distanceTo(this.getPathStartPoint(), this.getPathEndPoint());
      } catch (_unused) {
        return 0;
      }
    }
    get overflyTermFix() {
      return false;
    }
    get initialLegTermPoint() {
      return this.getPathEndPoint();
    }
  }

  /* | VILeg | VDLeg */

  const tan$3 = input => Math.tan(input * (Math.PI / 180));
  class DmeArcTransition extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "predictedPath", []);
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "itp", void 0);
      _defineProperty(this, "centre", void 0);
      _defineProperty(this, "ftp", void 0);
      _defineProperty(this, "sweepAngle", void 0);
      _defineProperty(this, "clockwise", void 0);
    }
    getPathStartPoint() {
      return this.itp;
    }
    getPathEndPoint() {
      return this.ftp;
    }
    recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
      if (this.isFrozen) {
        return;
      }
      this.radius = gs ** 2 / (9.81 * tan$3(maxBank(tas, true))) / 6080.2;
      if (this.previousLeg instanceof AFLeg) {
        const turnDirection = Math.sign(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
        const nextLegReference = this.nextLeg.getPathStartPoint(); // FIXME FX legs
        const reference = placeBearingDistance(nextLegReference, this.nextLeg.inboundCourse + 90 * turnDirection, this.radius);
        const dme = this.previousLeg.centre;
        const turnCentre = closestSmallCircleIntersection(dme, this.previousLeg.radius + this.radius * turnDirection * -this.previousLeg.turnDirectionSign, reference, this.nextLeg.inboundCourse - 180);
        if (!turnCentre) {
          throw new Error('AFLeg did not intersect with previous leg offset reference');
        }
        this.centre = turnCentre;
        this.itp = placeBearingDistance(turnCentre, turnDirection * -this.previousLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
        this.ftp = placeBearingDistance(turnCentre, this.nextLeg.inboundCourse - 90 * turnDirection, this.radius);
        this.sweepAngle = MathUtils$1.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
        this.clockwise = this.sweepAngle > 0;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.itp,
          centrePoint: turnCentre,
          endPoint: this.ftp,
          sweepAngle: this.sweepAngle
        });
        this.isComputed = true;
      } else if (this.nextLeg instanceof AFLeg) {
        const turnDirection = Math.sign(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
        const reference = placeBearingDistance(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse + 90 * turnDirection, this.radius);
        const dme = this.nextLeg.centre;
        let turnCentre;
        if (this.previousLeg instanceof XFLeg && !(this.previousLeg instanceof AFLeg)) {
          const intersection = closestSmallCircleIntersection(dme, this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign, reference, this.previousLeg.outboundCourse);
          if (intersection) {
            turnCentre = intersection;
            this.itp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse - 90 * turnDirection, this.radius);
            this.ftp = placeBearingDistance(turnCentre, turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
          } else {
            this.ftp = placeBearingDistance(dme, this.nextLeg.boundaryRadial, this.nextLeg.radius);
            const turnSign = turnDirection > 0 ? 1 : -1;
            turnCentre = placeBearingDistance(this.ftp, Avionics.Utils.clampAngle(this.nextLeg.boundaryRadial + (turnSign > 0 ? 180 : 0)), this.radius);
            this.itp = placeBearingDistance(turnCentre, Avionics.Utils.clampAngle(this.previousLeg.outboundCourse - turnSign * 90), this.radius);
          }
        } else {
          turnCentre = closestSmallCircleIntersection(dme, this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign, reference, this.previousLeg.outboundCourse);
          if (!turnCentre) {
            throw new Error('AFLeg did not intersect with previous leg offset reference');
          }
          this.itp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse - 90 * turnDirection, this.radius);
          this.ftp = placeBearingDistance(turnCentre, turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
        }
        this.centre = turnCentre;
        this.sweepAngle = MathUtils$1.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
        this.clockwise = this.sweepAngle > 0;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Arc,
          startPoint: this.itp,
          centrePoint: turnCentre,
          endPoint: this.ftp,
          sweepAngle: this.sweepAngle
        });
        this.isComputed = true;
      }
    }
    addDebugPoints() {
      if (this.itp && this.centre && this.ftp) {
        this.predictedPath.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.itp,
          annotation: 'DME TRANS ITP'
        }, {
          type: PathVectorType.DebugPoint,
          startPoint: this.centre,
          annotation: 'DME TRANS C'
        }, {
          type: PathVectorType.DebugPoint,
          startPoint: this.ftp,
          annotation: 'DME TRANS FTP'
        });
      }
    }
    getTurningPoints() {
      return [this.itp, this.ftp];
    }
    get distance() {
      return pathVectorLength(this.predictedPath[0]); // FIXME HAX
    }

    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    getGuidanceParameters(ppos, trueTrack) {
      return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    getDistanceToGo(ppos) {
      return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    isAbeam(ppos) {
      const turningPoints = this.getTurningPoints();
      if (!turningPoints) {
        return false;
      }
      const [inbound, outbound] = turningPoints;
      const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
      const inHeadingAc = Math.abs(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
      const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
      const outHeadingAc = Math.abs(MathUtils$1.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
      return inHeadingAc <= 90 && outHeadingAc >= 90;
    }
    get repr() {
      return "DME(".concat(this.previousLeg.repr, ", ").concat(this.nextLeg.repr, ")");
    }
  }

  // Copyright (c) 2021-2022 FlyByWire Simulations
  class XFLeg extends Leg {
    constructor(fix) {
      super();
      this.fix = fix;
    }
    getPathEndPoint() {
      if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.fix.infos.coordinates;
    }
    get terminationWaypoint() {
      return this.fix;
    }
    get ident() {
      return this.fix.ident;
    }
    get overflyTermFix() {
      return this.metadata.isOverfly;
    }

    /**
     * Returns `true` if the inbound transition has overshot the leg
     */
    get overshot() {
      const side = sideOfPointOnCourseToFix(this.fix.infos.coordinates, this.outboundCourse, this.getPathStartPoint());
      return side === PointSide.After;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      if (this.overshot) {
        return 0;
      }
      return distanceTo(startPoint, this.fix.infos.coordinates);
    }
  }

  class AFLeg extends XFLeg {
    constructor(fix, navaid, rho, theta, boundaryRadial, metadata, segment) {
      super(fix);
      this.navaid = navaid;
      this.rho = rho;
      this.theta = theta;
      this.boundaryRadial = boundaryRadial;
      this.metadata = metadata;
      _defineProperty(this, "predictedPath", []);
      _defineProperty(this, "centre", void 0);
      _defineProperty(this, "terminationRadial", void 0);
      _defineProperty(this, "bearing", void 0);
      _defineProperty(this, "arcStartPoint", void 0);
      _defineProperty(this, "arcEndPoint", void 0);
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "sweepAngle", void 0);
      _defineProperty(this, "clockwise", void 0);
      _defineProperty(this, "inboundCourse", void 0);
      _defineProperty(this, "outboundCourse", void 0);
      this.segment = segment;
      this.centre = navaid;
      this.radius = distanceTo(navaid, this.fix.infos.coordinates);
      this.terminationRadial = this.theta;
      this.bearing = Avionics.Utils.clampAngle(bearingTo(this.centre, this.fix.infos.coordinates) + 90 * this.turnDirectionSign);
      this.arcStartPoint = placeBearingDistance(this.centre, this.boundaryRadial, this.radius);
      this.arcEndPoint = placeBearingDistance(this.centre, this.terminationRadial, this.radius);
      this.inboundCourse = this.boundaryRadial + 90 * this.turnDirectionSign;
      this.outboundCourse = this.terminationRadial + 90 * this.turnDirectionSign;
    }
    getPathStartPoint() {
      return this.inboundGuidable instanceof DmeArcTransition ? this.inboundGuidable.getPathEndPoint() : this.arcStartPoint;
    }
    getPathEndPoint() {
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.arcEndPoint;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.sweepAngle = MathUtils$1.diffAngle(bearingTo(this.centre, this.getPathStartPoint()), bearingTo(this.centre, this.getPathEndPoint()));
      this.clockwise = this.sweepAngle > 0;

      // We do not consider the path capture end point in this class' getPathEndPoint since that causes a race condition with the path capture
      // finding its intercept point onto this leg
      const startPoint = this.inboundGuidable instanceof PathCaptureTransition ? this.inboundGuidable.getPathEndPoint() : this.getPathStartPoint();
      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: PathVectorType.Arc,
        startPoint,
        centrePoint: this.centre,
        endPoint: this.getPathEndPoint(),
        sweepAngle: this.sweepAngle
      });
    }
    get turnDirectionSign() {
      if (this.fix.turnDirection !== TurnDirection.Right && this.fix.turnDirection !== TurnDirection.Left) {
        throw new Error('AFLeg found without specific turnDirection');
      }
      return this.fix.turnDirection === TurnDirection.Left ? -1 : 1;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    getGuidanceParameters(ppos, trueTrack) {
      return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    getDistanceToGo(ppos) {
      return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    isAbeam(ppos) {
      const bearingPpos = Avionics.Utils.computeGreatCircleHeading(this.centre, ppos);
      const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.centre, this.getPathStartPoint());
      const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
      return trackAngleError >= 0;
    }
    get repr() {
      return "AF(".concat(this.radius.toFixed(1), "NM) TO ").concat(this.fix.ident);
    }
  }

  class TFLeg extends XFLeg {
    constructor(from, to, metadata, segment) {
      super(to);
      this.metadata = metadata;
      _defineProperty(this, "from", void 0);
      _defineProperty(this, "to", void 0);
      _defineProperty(this, "constraintType", void 0);
      _defineProperty(this, "course", void 0);
      _defineProperty(this, "computedPath", []);
      this.from = from;
      this.to = to;
      this.segment = segment;
      this.constraintType = to.constraintType;
      this.course = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, this.to.infos.coordinates);
    }
    get inboundCourse() {
      return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
    }
    get outboundCourse() {
      return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
    }
    get predictedPath() {
      return this.computedPath;
    }
    getPathStartPoint() {
      var _this$inboundGuidable;
      return (_this$inboundGuidable = this.inboundGuidable) !== null && _this$inboundGuidable !== void 0 && _this$inboundGuidable.isComputed ? this.inboundGuidable.getPathEndPoint() : this.from.infos.coordinates;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      const startPoint = this.getPathStartPoint();
      const endPoint = this.getPathEndPoint();
      this.computedPath.length = 0;
      if (this.overshot) {
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: endPoint,
          endPoint
        });
      } else {
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint,
          endPoint
        });
      }
      this.isComputed = true;
    }
    getPseudoWaypointLocation(distanceBeforeTerminator) {
      return getIntermediatePoint(this.getPathStartPoint(), this.getPathEndPoint(), (this.distance - distanceBeforeTerminator) / this.distance);
    }
    getGuidanceParameters(ppos, trueTrack) {
      return fixToFixGuidance(ppos, trueTrack, this.from.infos.coordinates, this.to.infos.coordinates);
    }
    getNominalRollAngle(_gs) {
      return 0;
    }

    /**
     * Calculates the angle between the leg and the aircraft PPOS.
     *
     * This effectively returns the angle ABC in the figure shown below:
     *
     * ```
     * * A
     * |
     * * B (TO)
     * |\
     * | \
     * |  \
     * |   \
     * |    \
     * |     \
     * |      \
     * * FROM  * C (PPOS)
     * ```
     *
     * @param ppos {LatLong} the current position of the aircraft
     */
    getAircraftToLegBearing(ppos) {
      const aircraftToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(ppos, this.to.infos.coordinates);
      const aircraftLegBearing = MathUtils$1.smallCrossingAngle(this.outboundCourse, aircraftToTerminationBearing);
      return aircraftLegBearing;
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    isAbeam(ppos) {
      const bearingAC = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, ppos);
      const headingAC = Math.abs(MathUtils$1.diffAngle(this.inboundCourse, bearingAC));
      if (headingAC > 90) {
        // if we're even not abeam of the starting point
        return false;
      }
      const distanceAC = Avionics.Utils.computeDistance(this.from.infos.coordinates, ppos);
      const distanceAX = Math.cos(headingAC * Avionics.Utils.DEG2RAD) * distanceAC;
      // if we're too far away from the starting point to be still abeam of the ending point
      return distanceAX <= this.distance;
    }
    get repr() {
      return "TF FROM ".concat(this.from.ident, " TO ").concat(this.to.ident);
    }
  }

  const sin = input => Math.sin(input * (Math.PI / 180));
  const asin = input => Math.asin(input) * (180 / Math.PI);
  class Geo {
    static computeDestinationPoint(start, distance, bearing) {
      let radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371000;
      // FIXME rm -f geolib ?
      const a = es.computeDestinationPoint(_objectSpread2(_objectSpread2({}, start), {}, {
        lon: start.long
      }), distance * 1852, bearing, radius);
      return {
        lat: a.latitude,
        long: a.longitude
      };
    }
    static distanceToLeg(from, leg) {
      const intersections1 = placeBearingIntersection(from, Avionics.Utils.clampAngle(leg.outboundCourse - 90), leg.initialLegTermPoint, Avionics.Utils.clampAngle(leg.outboundCourse - 180));
      const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[0]);
      const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[1]);
      let legStartReference;
      if (leg instanceof TFLeg) {
        legStartReference = leg.from.infos.coordinates;
      } else {
        legStartReference = leg.getPathStartPoint();
      }

      // We might call this on legs that do not have a defined start point yet, as it depends on their inbound transition, which is what is passing
      // them in to this function.
      // In that case, do not consider the second intersection set.
      if (!legStartReference) {
        return Math.min(d1, d2);
      }
      const intersections2 = placeBearingIntersection(from, Avionics.Utils.clampAngle(leg.outboundCourse - 90), legStartReference, Avionics.Utils.clampAngle(leg.outboundCourse - 180));
      const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
      const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
      return Math.min(d1, d2, d3, d4);
    }
    static legIntercept(from, bearing, leg) {
      if (leg instanceof AFLeg) {
        const intersections = smallCircleGreatCircleIntersection(leg.centre, leg.radius, from, bearing);
        const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections[0]);
        const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections[1]);
        return d1 > d2 ? intersections[1] : intersections[0];
      }
      if (leg.getPathEndPoint() === undefined || leg.outboundCourse === undefined) {
        throw new Error('[FMS/LNAV] Cannot compute leg intercept if leg end point or outbound course are undefined');
      }
      const intersections1 = placeBearingIntersection(from, Avionics.Utils.clampAngle(bearing), 'fix' in leg ? leg.fix.infos.coordinates : leg.getPathEndPoint(), Avionics.Utils.clampAngle(leg.outboundCourse - 180));
      const d1 = distanceTo(from, intersections1[0]);
      const d2 = distanceTo(from, intersections1[1]);

      // We might call this on legs that do not have a defined start point yet, as it depends on their inbound transition, which is what is passing
      // them in to this function.
      // In that case, do not consider the second intersection set.
      if (!leg.getPathStartPoint()) {
        return d1 > d2 ? intersections1[1] : intersections1[0];
      }
      const intersections2 = placeBearingIntersection(from, Avionics.Utils.clampAngle(bearing), leg.getPathStartPoint(), Avionics.Utils.clampAngle(leg.outboundCourse - 180));
      const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
      const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
      const smallest = Math.min(d1, d2, d3, d4);
      if (smallest === d1) {
        return intersections1[0];
      }
      if (smallest === d2) {
        return intersections1[1];
      }
      if (smallest === d3) {
        return intersections2[0];
      }
      return intersections2[1];
    }
    static placeBearingPlaceDistanceIntercept(bearingPoint, distancePoint, bearing, distance) {
      const relativeBearing = bearingTo(bearingPoint, distancePoint);
      const distanceBetween = distanceTo(bearingPoint, distancePoint);
      const angleA = Math.abs(MathUtils$1.diffAngle(relativeBearing, bearing));
      const angleC = angleA > 90 ? asin(distanceBetween * (sin(angleA) / distance)) : 180 - asin(distanceBetween * (sin(angleA) / distance));
      const angleB = 180 - angleA - angleC;
      return placeBearingDistance(bearingPoint, bearing, Math.abs(sin(angleB) * (distance / sin(angleA))));
    }
    static doublePlaceBearingIntercept(pointA, pointB, bearingA, bearingB) {
      return A32NX_Util.greatCircleIntersection(pointA, bearingA, pointB, bearingB);
    }
  }

  // Copyright (c) 2021-2022 FlyByWire Simulations
  // Copyright (c) 2021-2022 Synaptic Simulations
  //
  // SPDX-License-Identifier: GPL-3.0

  /**
   * Functions for figuring out an appropriate course change for leg captures
   */
  class CourseChange {
    static normal(turnDirection, turnCenterDistance, trackChange, radius) {
      if (turnDirection > 0) {
        if (turnCenterDistance >= radius) {
          return trackChange - 45;
        }
        return trackChange + 45;
      }
      if (-turnCenterDistance >= radius) {
        return trackChange + 45;
      }
      return trackChange - 45;
    }
    static reverse(turnDirection, turnCenterDistance, trackChange, radius) {
      if (trackChange > 0) {
        if (turnCenterDistance > 0) {
          if (turnCenterDistance > radius) {
            return trackChange - 45;
          }
          return trackChange + 45;
        }
        return trackChange + 45;
      }
      if (turnCenterDistance > 0) {
        return trackChange - 45;
      }
      if (-turnCenterDistance > radius) {
        return trackChange + 45;
      }
      return trackChange - 45;
    }
    static acuteFar(turnDirection, turnCenterDistance, trackChange) {
      return turnDirection * (45 - Math.abs(trackChange));
    }
    static acuteNear(turnDirection, turnCenterDistance, trackChange) {
      return trackChange + (turnDirection > 0 ? 45 : -45);
    }
  }

  // Copyright (c) 2021-2022 FlyByWire Simulations
  class IFLeg extends XFLeg {
    constructor(fix, metadata, segment) {
      super(fix);
      this.metadata = metadata;
      this.segment = segment;
    }
    get predictedPath() {
      return [];
    }
    getPathStartPoint() {
      return this.fix.infos.coordinates;
    }
    getPathEndPoint() {
      return this.fix.infos.coordinates;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.isComputed = true;
    }

    /** @inheritdoc */
    setNeighboringGuidables(inbound, outbound) {
      if (outbound && !(outbound instanceof Leg) && outbound !== this.outboundGuidable) {
        console.error("IF outboundGuidable must be a leg (is ".concat(outbound === null || outbound === void 0 ? void 0 : outbound.constructor, ")"));
      }
      super.setNeighboringGuidables(inbound, outbound);
    }
    get inboundCourse() {
      return undefined;
    }
    get outboundCourse() {
      return undefined;
    }
    get distance() {
      return 0;
    }
    getDistanceToGo(_ppos) {
      return undefined;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      var _this$outboundGuidabl, _this$outboundGuidabl2;
      return (_this$outboundGuidabl = (_this$outboundGuidabl2 = this.outboundGuidable) === null || _this$outboundGuidabl2 === void 0 ? void 0 : _this$outboundGuidabl2.getGuidanceParameters(ppos, trueTrack, tas, gs)) !== null && _this$outboundGuidabl !== void 0 ? _this$outboundGuidabl : undefined;
    }
    getNominalRollAngle(_gs) {
      return undefined;
    }
    getPseudoWaypointLocation(_distanceBeforeTerminator) {
      return undefined;
    }
    isAbeam(_ppos) {
      return false;
    }
    get repr() {
      return "IF AT ".concat(this.fix.ident);
    }
  }

  class CFLeg extends XFLeg {
    constructor(fix, course, metadata, segment) {
      super(fix);
      this.course = course;
      this.metadata = metadata;
      _defineProperty(this, "computedPath", []);
      this.segment = segment;
    }
    getPathStartPoint() {
      if (this.inboundGuidable instanceof IFLeg) {
        return this.inboundGuidable.fix.infos.coordinates;
      }
      if (this.inboundGuidable instanceof Transition && this.inboundGuidable.isComputed) {
        return this.inboundGuidable.getPathEndPoint();
      }
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }

      // Estimate where we should start the leg
      return this.estimateStartWithoutInboundTransition();
    }

    /**
     * Based on FBW-22-07
     *
     * @private
     */
    estimateStartWithoutInboundTransition() {
      const inverseCourse = Avionics.Utils.clampAngle(this.course + 180);
      if (this.inboundGuidable && this.inboundGuidable.isComputed) {
        const prevLegTerm = this.inboundGuidable.getPathEndPoint();
        return Geo.doublePlaceBearingIntercept(this.getPathEndPoint(), prevLegTerm, inverseCourse, Avionics.Utils.clampAngle(inverseCourse + 90));
      }

      // We start the leg at (tad + 0.1) from the fix if we have a fixed radius transition outbound. This allows showing a better looking path after sequencing.
      let distance = 1;
      if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
        distance = this.outboundGuidable.tad + 0.1;
      }
      return Avionics.Utils.bearingDistanceToCoordinates(inverseCourse, distance, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      // Is start point after the fix ?
      if (this.overshot) {
        this.computedPath = [{
          type: PathVectorType.Line,
          startPoint: this.getPathEndPoint(),
          endPoint: this.getPathEndPoint()
        }];
      } else {
        this.computedPath = [{
          type: PathVectorType.Line,
          startPoint: this.getPathStartPoint(),
          endPoint: this.getPathEndPoint()
        }];
      }
      this.isComputed = true;
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    isAbeam(ppos) {
      const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      return dtg >= 0 && dtg <= this.distance;
    }
    get repr() {
      return "CF(".concat(this.course.toFixed(1), "T) TO ").concat(this.fix.ident);
    }
  }

  var PiState = /*#__PURE__*/function (PiState) {
    PiState[PiState["Straight"] = 0] = "Straight";
    PiState[PiState["Turn1"] = 1] = "Turn1";
    PiState[PiState["Outbound"] = 2] = "Outbound";
    PiState[PiState["Turn2"] = 3] = "Turn2";
    PiState[PiState["Intercept"] = 4] = "Intercept";
    return PiState;
  }(PiState || {});
  class PILeg extends Leg {
    constructor(fix, nextLeg, metadata, segment) {
      super();
      this.fix = fix;
      this.nextLeg = nextLeg;
      this.metadata = metadata;
      this.segment = segment;
      _defineProperty(this, "radius", 1);
      _defineProperty(this, "straight", {});
      _defineProperty(this, "turn1", {});
      _defineProperty(this, "outbound", {});
      _defineProperty(this, "turn2", {});
      _defineProperty(this, "intercept", {});
      _defineProperty(this, "state", PiState.Straight);
      _defineProperty(this, "debugPoints", []);
      this.recomputeWithParameters(false, 220, 220, {
        lat: 0,
        long: 0
      }, 0);
    }
    recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
      if (isActive) {
        return;
      }
      if (this.nextLeg && !(this.nextLeg instanceof CFLeg)) {
        throw new Error('PI must be followed by CF!');
      } else if (!this.nextLeg) {
        return;
      }
      this.debugPoints.length = 0;
      const turn1Sign = this.fix.turnDirection === TurnDirection.Left ? 1 : -1;
      const turn2Sign = -1 * turn1Sign;
      const gsMs = gs / 1.94384;
      this.radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(tas, true) * Math.PI / 180)) / 1852;
      const minStraightDist = this.radius * 2;
      const brgToCf = Avionics.Utils.computeGreatCircleHeading(this.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates);
      const distToCf = Avionics.Utils.computeGreatCircleDistance(this.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates);
      const cfInverseCrs = (this.nextLeg.course + 180) % 360;
      this.outbound.course = this.fix.additionalData.course;
      this.straight.itp = this.fix.infos.coordinates;
      this.straight.course = cfInverseCrs;
      let tp;
      if (Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, brgToCf)) < 90 && distToCf > minStraightDist) {
        tp = this.nextLeg.fix.infos.coordinates;
      } else {
        // find an intercept on the CF at min dist
        [tp] = smallCircleGreatCircleIntersection(this.fix.infos.coordinates, minStraightDist, this.nextLeg.fix.infos.coordinates, cfInverseCrs).filter(p => Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, bearingTo(this.nextLeg.fix.infos.coordinates, p))) < 90);
        this.straight.course = Avionics.Utils.computeGreatCircleHeading(this.fix.infos.coordinates, tp);
      }
      this.turn1.sweepAngle = turn1Sign * Math.abs(Avionics.Utils.diffAngle(this.straight.course, this.outbound.course));
      const tpT1FtpDist = this.radius * Math.tan(Math.abs(this.turn1.sweepAngle) * Math.PI / 360);
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outbound.course, tpT1FtpDist, tp.lat, tp.long);
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn1Sign * 90) % 360, this.radius, this.turn1.ftp.lat, this.turn1.ftp.long);
      this.turn1.itp = Avionics.Utils.bearingDistanceToCoordinates((this.straight.course + 180) % 360, this.radius * (1 - Math.cos(this.turn1.sweepAngle * Math.PI / 180)), tp.lat, tp.long);
      this.turn1.length = Math.abs(this.turn1.sweepAngle / 180 * this.radius);
      this.straight.ftp = this.turn1.itp;
      this.straight.length = Avionics.Utils.computeGreatCircleDistance(this.fix.infos.coordinates, this.turn1.itp);
      const theta = Math.abs(Avionics.Utils.diffAngle(this.outbound.course, (this.nextLeg.course + 180) % 360)) * Math.PI / 180;
      this.outbound.length = this.radius * (1 / Math.tan(theta / 2));
      this.outbound.itp = this.turn1.ftp;
      this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outbound.course, this.outbound.length + tpT1FtpDist, tp.lat, tp.long);
      this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn2Sign * 90) % 360, this.radius, this.turn2.itp.lat, this.turn2.itp.long);
      this.turn2.sweepAngle = turn2Sign * 180;
      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn2Sign * 90) % 360, this.radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
      this.turn2.length = Math.abs(this.turn2.sweepAngle / 180 * this.radius);
      this.outbound.ftp = this.turn2.itp;
      this.intercept.itp = this.turn2.ftp;
      this.intercept.ftp = A32NX_Util.greatCircleIntersection(this.turn2.ftp, (this.outbound.course + 180) % 360, tp, cfInverseCrs);
      this.intercept.length = Avionics.Utils.computeGreatCircleDistance(this.intercept.itp, this.intercept.ftp);
      this.intercept.course = Avionics.Utils.computeGreatCircleHeading(this.intercept.itp, this.intercept.ftp);
      this.isComputed = true;
    }
    get initialLegTermPoint() {
      return this.turn1.itp;
    }
    get distanceToTermination() {
      return this.straight.length;
    }
    get distance() {
      return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + this.straight.length;
    }

    /**
     * Do we end up further away from the fix than the coded limit
     */
    get turnAreaExceeded() {
      if (!this.turn2) {
        return false;
      }
      const maxExcursion = distanceTo(this.fix.infos.coordinates, this.turn2.arcCentre) + this.radius;
      return maxExcursion > this.fix.additionalData.distance;
    }
    getDistanceToGo(ppos) {
      switch (this.state) {
        case PiState.Intercept:
          return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);
        case PiState.Turn2:
          return this.intercept.length + arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
        case PiState.Outbound:
          return this.intercept.length + this.turn2.length + courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);
        case PiState.Turn1:
          return this.intercept.length + this.turn2.length + this.outbound.length + arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
        case PiState.Straight:
          return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);
        default:
          return 1;
      }
    }
    dtgCurrentSegment(ppos) {
      switch (this.state) {
        case PiState.Intercept:
          return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);
        case PiState.Turn2:
          return arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
        case PiState.Outbound:
          return courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);
        case PiState.Turn1:
          return arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
        case PiState.Straight:
          return courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);
        default:
          return 0;
      }
    }
    radCurrentSegment(tas, gs) {
      const turn1Sign = this.fix.turnDirection === TurnDirection.Left ? 1 : -1;
      const turn2Sign = -1 * turn1Sign;
      let currentBank;
      let nextBank;
      switch (this.state) {
        case PiState.Turn1:
          currentBank = turn1Sign * maxBank(tas, true);
          nextBank = 0;
          break;
        case PiState.Turn2:
          currentBank = turn2Sign * maxBank(tas, true);
          nextBank = 0;
          break;
        case PiState.Straight:
          currentBank = 0;
          nextBank = turn1Sign * maxBank(tas, true);
          break;
        case PiState.Outbound:
          currentBank = 0;
          nextBank = turn2Sign * maxBank(tas, true);
          break;
        default:
          return [0, 0];
      }
      return [Geometry.getRollAnticipationDistance(gs, currentBank, nextBank), nextBank];
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      var _this$nextLeg;
      let dtg = this.dtgCurrentSegment(ppos);
      if (dtg <= 0 && this.state < PiState.Intercept) {
        this.state++;
        dtg = this.dtgCurrentSegment(ppos);
      }
      let params;
      switch (this.state) {
        case PiState.Intercept:
          return (_this$nextLeg = this.nextLeg) === null || _this$nextLeg === void 0 ? void 0 : _this$nextLeg.getGuidanceParameters(ppos, trueTrack, tas);
        case PiState.Turn2:
          return arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
        case PiState.Outbound:
          params = courseToFixGuidance(ppos, trueTrack, this.outbound.course, this.outbound.ftp);
          break;
        case PiState.Turn1:
          params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          break;
        case PiState.Straight:
          params = courseToFixGuidance(ppos, trueTrack, this.straight.course, this.straight.ftp);
          break;
      }
      const [rad, nextBank] = this.radCurrentSegment(tas, gs);
      if (params && rad > 0 && dtg <= rad) {
        params.phiCommand = nextBank;
      }
      return params;
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getPathStartPoint() {
      var _this$inboundGuidable;
      return (_this$inboundGuidable = this.inboundGuidable) !== null && _this$inboundGuidable !== void 0 && _this$inboundGuidable.isComputed ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates;
    }
    getPathEndPoint() {
      return this.intercept.ftp;
    }
    get terminationWaypoint() {
      return this.intercept.ftp;
    }
    get inboundCourse() {
      var _this$straight$course;
      return (_this$straight$course = this.straight.course) !== null && _this$straight$course !== void 0 ? _this$straight$course : 0;
    }
    get outboundCourse() {
      var _this$nextLeg$course, _this$nextLeg2;
      return (_this$nextLeg$course = (_this$nextLeg2 = this.nextLeg) === null || _this$nextLeg2 === void 0 ? void 0 : _this$nextLeg2.course) !== null && _this$nextLeg$course !== void 0 ? _this$nextLeg$course : 0;
    }
    isAbeam(_ppos) {
      return true; // TODO y needed
    }

    get predictedPath() {
      var _this$inboundGuidable2;
      return [{
        type: PathVectorType.Line,
        startPoint: (_this$inboundGuidable2 = this.inboundGuidable) !== null && _this$inboundGuidable2 !== void 0 && _this$inboundGuidable2.isComputed ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates,
        endPoint: this.turn1.itp
      }, {
        type: PathVectorType.Arc,
        startPoint: this.turn1.itp,
        centrePoint: this.turn1.arcCentre,
        endPoint: this.turn1.ftp,
        sweepAngle: this.turn1.sweepAngle
      }, {
        type: PathVectorType.Line,
        startPoint: this.turn1.ftp,
        endPoint: this.turn2.itp
      }, {
        type: PathVectorType.Arc,
        startPoint: this.turn2.itp,
        centrePoint: this.turn2.arcCentre,
        endPoint: this.turn2.ftp,
        sweepAngle: this.turn2.sweepAngle
      }, {
        type: PathVectorType.Line,
        startPoint: this.turn2.ftp,
        endPoint: this.intercept.ftp
      }, ...this.debugPoints];
    }
    get ident() {
      return 'INTCPT';
    }
    get repr() {
      return "PI ".concat(this.ident);
    }
  }

  let AltitudeConstraintType = /*#__PURE__*/function (AltitudeConstraintType) {
    AltitudeConstraintType[AltitudeConstraintType["at"] = 0] = "at";
    AltitudeConstraintType[AltitudeConstraintType["atOrAbove"] = 1] = "atOrAbove";
    AltitudeConstraintType[AltitudeConstraintType["atOrBelow"] = 2] = "atOrBelow";
    AltitudeConstraintType[AltitudeConstraintType["range"] = 3] = "range";
    return AltitudeConstraintType;
  }({});

  // TODO at and atOrAbove do not exist in the airbus (former interpreted as atOrBelow, latter discarded)
  let SpeedConstraintType = /*#__PURE__*/function (SpeedConstraintType) {
    SpeedConstraintType[SpeedConstraintType["at"] = 0] = "at";
    SpeedConstraintType[SpeedConstraintType["atOrAbove"] = 1] = "atOrAbove";
    SpeedConstraintType[SpeedConstraintType["atOrBelow"] = 2] = "atOrBelow";
    return SpeedConstraintType;
  }({});
  function getAltitudeConstraintFromWaypoint(wp) {
    if (wp.legAltitudeDescription && wp.legAltitude1) {
      const ac = {};
      ac.altitude1 = wp.legAltitude1;
      ac.altitude2 = undefined;
      switch (wp.legAltitudeDescription) {
        case 1:
        case 6:
          ac.type = AltitudeConstraintType.at;
          break;
        case 2:
          ac.type = AltitudeConstraintType.atOrAbove;
          break;
        case 3:
          ac.type = AltitudeConstraintType.atOrBelow;
          break;
        case 4:
        case 7:
          ac.type = AltitudeConstraintType.range;
          ac.altitude2 = wp.legAltitude2;
          break;
      }
      return ac;
    }
    return undefined;
  }
  function getSpeedConstraintFromWaypoint(wp) {
    if (wp.speedConstraint) {
      const sc = {};
      sc.type = SpeedConstraintType.atOrBelow;
      sc.speed = wp.speedConstraint;
      return sc;
    }
    return undefined;
  }
  function getPathAngleConstraintFromWaypoint(wp) {
    return wp.additionalData.verticalAngle;
  }
  function isHold(leg) {
    return leg instanceof HALeg || leg instanceof HFLeg || leg instanceof HMLeg;
  }
  function isCourseReversalLeg(leg) {
    return isHold(leg) || leg instanceof PILeg;
  }

  /**
   * Geometry and vertical constraints applicable to a leg
   */

  function legMetadataFromMsfsWaypoint(waypoint) {
    const altitudeConstraint = getAltitudeConstraintFromWaypoint(waypoint);
    const speedConstraint = getSpeedConstraintFromWaypoint(waypoint);
    const pathAngleConstraint = getPathAngleConstraintFromWaypoint(waypoint);
    return {
      turnDirection: waypoint.turnDirection,
      altitudeConstraint,
      speedConstraint,
      pathAngleConstraint,
      isOverfly: waypoint.additionalData.overfly
    };
  }

  const cos = input => Math.cos(input * (Math.PI / 180));
  const tan$2 = input => Math.tan(input * MathUtils$1.DEGREES_TO_RADIANS);
  const compareTurnDirections = (sign, data) => {
    if ((data === TurnDirection.Left || data === TurnDirection.Right) && (sign === -1 || sign === 1)) {
      return data === TurnDirection.Left && sign === -1 || data === TurnDirection.Right && sign === 1;
    }
    return true;
  };

  /**
   * A type II transition
   */
  class PathCaptureTransition extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "startWithTad", false);
      _defineProperty(this, "predictedPath", []);
      _defineProperty(this, "itp", void 0);
      _defineProperty(this, "ftp", void 0);
      _defineProperty(this, "tad", void 0);
      _defineProperty(this, "forcedTurnComplete", false);
      _defineProperty(this, "computedTurnDirection", TurnDirection.Either);
      _defineProperty(this, "computedTargetTrack", 0);
      _defineProperty(this, "distance", 0);
    }
    getPathStartPoint() {
      return this.itp;
    }
    get turnDirection() {
      return this.nextLeg.metadata.turnDirection;
    }
    get deltaTrack() {
      return MathUtils$1.fastToFixedNum(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
    }
    recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
      if (this.isFrozen) {
        return;
      }
      if (!(this.inboundGuidable instanceof Leg)) {
        throw new Error('[FMS/Geometry/PathCapture] previousGuidable must be a leg');
      }
      const targetTrack = this.inboundGuidable.outboundCourse;
      const naturalTurnDirectionSign = Math.sign(MathUtils$1.diffAngle(targetTrack, this.nextLeg.inboundCourse));
      this.computedTurnDirection = TurnDirection.Either;
      this.computedTargetTrack = this.nextLeg.inboundCourse;
      let prevLegTermFix;
      if (this.previousLeg instanceof AFLeg) {
        prevLegTermFix = this.previousLeg.arcEndPoint;
      } else {
        prevLegTermFix = this.previousLeg.terminationWaypoint instanceof WayPoint ? this.previousLeg.terminationWaypoint.infos.coordinates : this.previousLeg.terminationWaypoint;
      }

      // Start the transition before the termination fix if we are reverted because of an overshoot
      let initialTurningPoint;
      if (this.startWithTad) {
        const prevLegDistanceToTerm = this.previousLeg.distanceToTermination;
        this.tad = Math.min(maxTad(tas), prevLegDistanceToTerm - 0.05);

        // If we are inbound of a TF leg, we use getIntermediatePoint in order to get more accurate results
        if ('from' in this.previousLeg) {
          const start = this.previousLeg.from.infos.coordinates;
          const end = this.previousLeg.to.infos.coordinates;
          const length = distanceTo(start, end);
          const ratio = (length - this.tad) / length;
          initialTurningPoint = getIntermediatePoint(start, end, ratio);
        } else {
          initialTurningPoint = placeBearingDistance(prevLegTermFix, reciprocal(this.previousLeg.outboundCourse), this.tad);
        }
      } else {
        this.tad = 0;
        initialTurningPoint = prevLegTermFix;
      }
      const distanceFromItp = Geo.distanceToLeg(initialTurningPoint, this.nextLeg);
      // for some legs the turn direction is not for forced turn onto the leg
      const desiredDirection = isCourseReversalLeg(this.nextLeg) ? TurnDirection.Either : this.nextLeg.metadata.turnDirection;
      const deltaTrack = MathUtils$1.diffAngle(targetTrack, this.nextLeg.inboundCourse, desiredDirection);
      this.predictedPath.length = 0;
      if (Math.abs(deltaTrack) < 3 && distanceFromItp < 0.1) {
        this.itp = this.previousLeg.getPathEndPoint();
        this.ftp = this.previousLeg.getPathEndPoint();
        this.predictedPath.push({
          type: PathVectorType.Line,
          startPoint: this.previousLeg.getPathEndPoint(),
          endPoint: this.previousLeg.getPathEndPoint()
        });
        this.isNull = true;
        this.distance = 0;
        this.isComputed = true;
        return;
      }
      this.isNull = false;

      // If track change is very similar to a 45 degree intercept, we do a direct intercept
      if (Math.abs(deltaTrack) > 42 && Math.abs(deltaTrack) < 48 && distanceFromItp > 0.01) {
        this.computeDirectIntercept();
        this.isComputed = true;
        return;
      }
      let turnDirection = Math.sign(deltaTrack);

      // Theta variable should be stored based on turn direction and max roll, but it is only used once in an absolute sense, so it is useless
      const radius = gs ** 2 / (Constants.G * tan$2(maxBank(tas, true)) * 6997.84) * LnavConfig.TURN_RADIUS_FACTOR;
      const distanceLimit = radius * cos(48);

      // TODO: Turn center is slightly off for some reason, fix
      let turnCenter = placeBearingDistance(initialTurningPoint, targetTrack + turnDirection * 90, radius);
      let turnCenterDistance = Math.sign(MathUtils$1.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
      let courseChange;
      if (Math.abs(deltaTrack) < 45) {
        if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
          turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
          turnDirection = -turnDirection;
          // Turn direction is to be flipped, FBW-22-05
          turnCenterDistance = Math.sign(MathUtils$1.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
          courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
        } else {
          courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
        }
      } else if (Math.abs(deltaTrack) >= 45 && !compareTurnDirections(turnDirection, this.nextLeg.metadata.turnDirection)) {
        turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
        turnDirection = -turnDirection;
        turnCenterDistance = Math.sign(MathUtils$1.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
      }

      // Omit 45 degree intercept segment if possible
      if (distanceLimit <= Math.abs(turnCenterDistance) && Math.abs(turnCenterDistance) < radius) {
        const radiusToLeg = radius - Math.abs(turnCenterDistance);
        let intercept;

        // If we are inbound of a TF leg, we use the TF leg ref fix for our small circle intersect in order to get
        // more accurate results
        if ('from' in this.nextLeg) {
          const intersects = smallCircleGreatCircleIntersection(turnCenter, radius, this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);
          if (intersects) {
            const [one, two] = intersects;
            if (distanceTo(initialTurningPoint, one) > distanceTo(initialTurningPoint, two)) {
              intercept = one;
            } else {
              intercept = two;
            }
          }
        } else {
          intercept = firstSmallCircleIntersection(turnCenter, radius, this.nextLeg.getPathEndPoint(), reciprocal(this.nextLeg.outboundCourse));
        }

        // If the difference between the radius and turnCenterDistance is very small, we might not find an intercept using the circle.
        // Do a direct intercept instead.
        if (!intercept && radiusToLeg < 0.1) {
          this.computeDirectIntercept();
          this.isComputed = true;
          return;
        }
        if (intercept && !Number.isNaN(intercept.lat)) {
          const bearingTcFtp = bearingTo(turnCenter, intercept);
          const angleToLeg = MathUtils$1.diffAngle(Avionics.Utils.clampAngle(bearingTcFtp - (turnDirection > 0 ? -90 : 90)), this.nextLeg.outboundCourse);
          if (Math.abs(angleToLeg) <= 48) {
            this.itp = initialTurningPoint;
            this.ftp = intercept;
            this.predictedPath.push({
              type: PathVectorType.Arc,
              startPoint: initialTurningPoint,
              endPoint: intercept,
              centrePoint: turnCenter,
              sweepAngle: Math.abs(deltaTrack) * turnDirection
            });
            this.distance = arcLength(radius, Math.abs(deltaTrack) * turnDirection);
            this.isComputed = true;
            return;
          }
        }
      }
      if (Math.abs(deltaTrack) < 45) {
        if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
          courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
        } else {
          courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
        }
      } else {
        const isReverse = !compareTurnDirections(naturalTurnDirectionSign, this.nextLeg.metadata.turnDirection);
        if (isReverse) {
          courseChange = CourseChange.reverse(turnDirection, turnCenterDistance, deltaTrack, radius);
          this.computedTurnDirection = this.nextLeg.metadata.turnDirection;
        } else {
          courseChange = CourseChange.normal(turnDirection, turnCenterDistance, deltaTrack, radius);
          this.computedTurnDirection = turnDirection < 0 ? TurnDirection.Left : TurnDirection.Right;
        }
      }
      this.computedTargetTrack = (360 + this.previousLeg.outboundCourse + courseChange) % 360;
      const finalTurningPoint = placeBearingDistance(turnCenter, targetTrack + courseChange - 90 * turnDirection, radius);
      let intercept;

      // If we are inbound of a TF leg, we use the TF leg FROM ref fix for our great circle intersect in order to get
      // more accurate results
      if ('from' in this.nextLeg) {
        const intersections = placeBearingIntersection(finalTurningPoint, Avionics.Utils.clampAngle(targetTrack + courseChange), this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);
        if (intersections) {
          const [one, two] = intersections;
          if (distanceTo(finalTurningPoint, one) < distanceTo(finalTurningPoint, two)) {
            intercept = one;
          } else {
            intercept = two;
          }
        }
      } else {
        intercept = Geo.legIntercept(finalTurningPoint, targetTrack + courseChange, this.nextLeg);
      }
      const overshot = sideOfPointOnCourseToFix(finalTurningPoint, targetTrack + courseChange, intercept) === PointSide.Before;
      this.itp = initialTurningPoint;
      this.ftp = finalTurningPoint;
      this.isComputed = true;
      this.predictedPath.push({
        type: PathVectorType.Arc,
        startPoint: initialTurningPoint,
        endPoint: finalTurningPoint,
        centrePoint: turnCenter,
        sweepAngle: courseChange
      });
      if (!overshot) {
        this.predictedPath.push({
          type: PathVectorType.Line,
          startPoint: finalTurningPoint,
          endPoint: intercept
        });
      }
      this.distance = arcLength(radius, courseChange) + (overshot ? 0 : distanceTo(finalTurningPoint, intercept));
    }

    /**
     * Computes the path capture as a direct leg intercept from the previous leg path end point to the next leg,
     * with previous leg outbound course
     *
     * @private
     */
    computeDirectIntercept() {
      const intercept = Geo.legIntercept(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse, this.nextLeg);
      this.itp = this.previousLeg.getPathEndPoint();
      this.ftp = intercept;
      this.predictedPath.push({
        type: PathVectorType.Line,
        startPoint: this.previousLeg.getPathEndPoint(),
        endPoint: intercept
      });
      this.distance = distanceTo(this.previousLeg.getPathEndPoint(), intercept);
    }
    get startsInCircularArc() {
      return false; // We don't want to do RAD for path captures
    }

    get endsInCircularArc() {
      return false; // We don't want to do RAD for path captures
    }

    isAbeam(ppos) {
      return !this.isNull && this.computedTurnDirection !== TurnDirection.Either && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
    }
    getTurningPoints() {
      return [this.itp, this.ftp];
    }
    getDistanceToGo(_ppos) {
      return 1;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (this.computedTurnDirection !== TurnDirection.Either) {
        const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
        let trackAngleError = this.computedTargetTrack - trueTrack;
        if (turnSign !== Math.sign(trackAngleError)) {
          trackAngleError += turnSign * 360;
        }
        if (Math.abs(trackAngleError) > 130) {
          const phiCommand = turnSign * maxBank(tas, true);
          return {
            law: ControlLaw.LATERAL_PATH,
            trackAngleError: 0,
            phiCommand,
            crossTrackError: 0
          };
        }
        this.forcedTurnComplete = true;
      }
      return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    get repr() {
      return "PATH CAPTURE(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
    }

    // This is for VNAV to estimate the amount of track miles left
    // TODO: I'm not sure this is really used IRL. I think it does it through the direct distance to fix and TAE.
    getActualDistanceToGo(ppos, trueTrack) {
      let dtg = 0;
      for (const path of this.predictedPath) {
        if (path.type === PathVectorType.Arc) {
          // Arc
          const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
          let trackAngleError = this.computedTargetTrack - trueTrack;
          if (turnSign !== Math.sign(trackAngleError)) {
            trackAngleError += turnSign * 360;
          }
          dtg += pathVectorLength(path) * trackAngleError / path.sweepAngle;
        } else if (path.type === PathVectorType.Line) {
          // Line
          dtg += Math.min(pathVectorLength(path), distanceTo(path.endPoint, ppos));
        }
      }
      return dtg;
    }
  }

  class CILeg extends Leg {
    constructor(course, nextLeg, metadata, segment) {
      super();
      this.course = course;
      this.nextLeg = nextLeg;
      this.metadata = metadata;
      _defineProperty(this, "computedPath", []);
      _defineProperty(this, "intercept", undefined);
      this.segment = segment;
    }
    get terminationWaypoint() {
      return this.intercept;
    }
    get distanceToTermFix() {
      return Avionics.Utils.computeGreatCircleDistance(this.getPathStartPoint(), this.intercept);
    }
    get ident() {
      return 'INTCPT';
    }
    getPathStartPoint() {
      if (this.inboundGuidable instanceof IFLeg) {
        return this.inboundGuidable.fix.infos.coordinates;
      }
      if (this.inboundGuidable && this.inboundGuidable.isComputed) {
        return this.inboundGuidable.getPathEndPoint();
      }
      throw new Error('[CILeg] No computed inbound guidable.');
    }
    getPathEndPoint() {
      if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.intercept;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.intercept = Geo.legIntercept(this.getPathStartPoint(), this.course, this.nextLeg);
      const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
      const overshot = side === PointSide.After;
      if (this.intercept && !Number.isNaN(this.intercept.lat) && !overshot) {
        this.isNull = false;
        this.computedPath = [{
          type: PathVectorType.Line,
          startPoint: this.getPathStartPoint(),
          endPoint: this.getPathEndPoint()
        }];
        this.isComputed = true;
      } else {
        this.computedPath.length = 0;
        this.isNull = true;
        this.isComputed = true;
      }
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      return distanceTo(startPoint, this.intercept);
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    getGuidanceParameters(_ppos, _trueTrack) {
      return {
        law: ControlLaw.TRACK,
        course: this.course
      };
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    isAbeam(ppos) {
      const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      return dtg >= 0 && dtg <= this.distance;
    }
    get repr() {
      return "CI(".concat(Math.trunc(this.course), "T)");
    }
  }

  const mod = (x, n) => x - Math.floor(x / n) * n;

  /**
   * A type I transition uses a fixed turn radius between two fix-referenced legs.
   */
  class FixedRadiusTransition extends Transition {
    constructor(previousLeg,
    // FIXME temporary
    nextLeg // FIXME temporary
    ) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "tad", void 0);
      _defineProperty(this, "clockwise", void 0);
      _defineProperty(this, "isFrozen", false);
      _defineProperty(this, "computedPath", []);
      _defineProperty(this, "sweepAngle", void 0);
      _defineProperty(this, "centre", undefined);
      _defineProperty(this, "revertTo", undefined);
      _defineProperty(this, "turningPoints", void 0);
    }
    get isReverted() {
      return this.revertTo !== undefined;
    }
    getPathStartPoint() {
      if (this.revertTo) {
        return this.revertTo.getPathStartPoint();
      }
      if (this.isComputed) {
        return this.turningPoints[0];
      }
      throw Error('?');
    }
    getPathEndPoint() {
      if (this.revertTo) {
        return this.revertTo.getPathEndPoint();
      }
      if (this.isComputed) {
        return this.turningPoints[1];
      }
      throw Error('?');
    }
    recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
      if (this.isFrozen) {
        return;
      }

      // Sweep angle
      this.sweepAngle = MathUtils$1.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse);

      // Start with half the track change
      const bankAngle = Math.abs(this.sweepAngle) / 2;

      // apply limits
      const finalBankAngle = Math.max(Math.min(bankAngle, maxBank(tas, true)), minBank(this.nextLeg.segment));

      // Turn radius
      this.radius = tas ** 2 / (9.81 * Math.tan(finalBankAngle * Avionics.Utils.DEG2RAD)) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;

      // Turn anticipation distance
      this.tad = this.radius * Math.tan(Math.abs(this.sweepAngle / 2) * MathUtils$1.DEGREES_TO_RADIANS);

      // Check what the distance from the fix to the next leg is (to avoid being not lined up in some XF -> CF cases)
      const prevLegTermDistanceToNextLeg = Geo.distanceToLeg(this.previousLeg instanceof XFLeg ? this.previousLeg.fix.infos.coordinates : this.previousLeg.intercept, this.nextLeg);
      const defaultTurnDirection = this.sweepAngle >= 0 ? TurnDirection.Right : TurnDirection.Left;
      const forcedTurn = (this.nextLeg.metadata.turnDirection === TurnDirection.Left || this.nextLeg.metadata.turnDirection === TurnDirection.Right) && defaultTurnDirection !== this.nextLeg.metadata.turnDirection;
      const tooBigForPrevious = this.previousLeg.distanceToTermination < this.tad + 0.1;
      const tooBigForNext = 'from' in this.nextLeg ? distanceTo(this.nextLeg.from.infos.coordinates, this.nextLeg.to.infos.coordinates) < this.tad + 0.1 : false;
      const notLinedUp = Math.abs(prevLegTermDistanceToNextLeg) >= 0.25; // "reasonable" distance

      // in some circumstances we revert to a path capture transition where the fixed radius won't work well
      const shouldRevert = Math.abs(this.sweepAngle) <= 3 || Math.abs(this.sweepAngle) > 175 || this.previousLeg.overflyTermFix || forcedTurn || tooBigForPrevious || tooBigForNext || notLinedUp;

      // We do not revert to a path capture if the previous leg was overshot anyway - draw the normal fixed radius turn
      const previousLegOvershot = 'overshot' in this.previousLeg && this.previousLeg.overshot;
      if (shouldRevert && !previousLegOvershot) {
        const shouldHaveTad = !this.previousLeg.overflyTermFix && !notLinedUp && (tooBigForPrevious || tooBigForNext);
        if (!this.revertTo) {
          const reverted = new PathCaptureTransition(this.previousLeg, this.nextLeg);
          reverted.startWithTad = shouldHaveTad;
          reverted.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
          const reversionTad = reverted.tad;
          const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.tad;

          // See if there is enough space left for the reverted transition
          if (fixDtg > reversionTad) {
            this.revertTo = reverted;
            this.isComputed = this.revertTo.isComputed;
            return;
          }
        } else {
          this.revertTo.startWithTad = shouldHaveTad;
          this.revertTo.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
          this.isComputed = this.revertTo.isComputed;
          return;
        }
      }

      // Try to de-revert if needed
      if (this.revertTo) {
        // We assume we are inactive here
        const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.revertTo.tad;

        // Only de-revert if there is space for the fixed radius TAD
        if (fixDtg > this.tad + 0.05 || !isActive) {
          this.revertTo = undefined;
        }
      }

      // Turn direction
      this.clockwise = this.sweepAngle >= 0;

      // Turning points
      this.turningPoints = this.computeTurningPoints();
      this.computedPath.length = 0;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.getTurningPoints()[0],
        centrePoint: this.centre,
        endPoint: this.getTurningPoints()[1],
        sweepAngle: this.sweepAngle
      });
      this.isComputed = true;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    isAbeam(ppos) {
      if (this.revertTo !== undefined) {
        return this.revertTo.isAbeam(ppos);
      }
      const turningPoints = this.getTurningPoints();
      if (!turningPoints) {
        return false;
      }
      const [inbound, outbound] = turningPoints;
      const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
      const inHeadingAc = Math.abs(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
      const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
      const outHeadingAc = Math.abs(MathUtils$1.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
      return inHeadingAc <= 90 && outHeadingAc >= 90;
    }
    get distance() {
      if (this.revertTo) {
        return this.revertTo.distance;
      }
      return arcLength(this.radius, this.sweepAngle);
    }

    /**
     * Returns the distance between the inbound turning point and the reference fix
     */
    get unflownDistance() {
      if (this.revertTo) {
        return 0;
      }
      if (!this.getTurningPoints()) {
        return 0;
      }
      return Avionics.Utils.computeGreatCircleDistance(this.previousLeg.getPathEndPoint(), this.getTurningPoints()[0]);
    }
    computeTurningPoints() {
      const {
        lat,
        long
      } = this.previousLeg instanceof CILeg ? this.previousLeg.intercept : this.previousLeg.fix.infos.coordinates;
      const inbound = Avionics.Utils.bearingDistanceToCoordinates(mod(this.previousLeg.outboundCourse + 180, 360), this.tad, lat, long);
      const outbound = Avionics.Utils.bearingDistanceToCoordinates(this.nextLeg.inboundCourse, this.tad, lat, long);
      this.centre = Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(this.previousLeg.outboundCourse + (this.clockwise ? 90 : -90)), this.radius, inbound.lat, inbound.long);
      return [inbound, outbound];
    }
    getTurningPoints() {
      if (this.revertTo) {
        return this.revertTo.getTurningPoints();
      }
      return this.turningPoints;
    }
    get predictedPath() {
      if (this.revertTo) {
        return this.revertTo.predictedPath;
      }
      return this.computedPath;
    }
    getDistanceToGo(ppos) {
      if (this.revertTo) {
        return this.revertTo.getDistanceToGo(ppos);
      }
      const [itp] = this.getTurningPoints();
      return arcDistanceToGo(ppos, itp, this.centre, this.sweepAngle);
    }
    getGuidanceParameters(ppos, trueTrack, tas) {
      if (this.revertTo) {
        return this.revertTo.getGuidanceParameters(ppos, trueTrack, tas);
      }
      const [itp] = this.getTurningPoints();
      return arcGuidance(ppos, trueTrack, itp, this.centre, this.sweepAngle);
    }
    getNominalRollAngle(gs) {
      if (this.revertTo) {
        return this.revertTo.getNominalRollAngle(gs);
      }
      return (this.clockwise ? 1 : -1) * Math.atan((gs * 463 / 900) ** 2 / (this.radius * 1852 * Constants.G)) * (180 / Math.PI);
    }
    get repr() {
      return "TYPE1(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
    }
  }

  const tan$1 = input => Math.tan(input * (Math.PI / 180));

  /**
   * A type I transition uses a fixed turn radius between two fix-referenced legs.
   */
  class CourseCaptureTransition extends Transition {
    constructor(previousLeg, nextLeg // FIXME temporary
    ) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "terminator", void 0);
      _defineProperty(this, "isArc", void 0);
      _defineProperty(this, "startPoint", void 0);
      _defineProperty(this, "endPoint", void 0);
      _defineProperty(this, "center", void 0);
      _defineProperty(this, "sweepAngle", void 0);
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "clockwise", void 0);
      _defineProperty(this, "predictedPath", []);
      _defineProperty(this, "forcedTurnComplete", false);
      _defineProperty(this, "computedTurnDirection", TurnDirection.Either);
    }
    getPathStartPoint() {
      return this.previousLeg.getPathEndPoint();
    }
    getPathEndPoint() {
      return this.terminator;
    }
    get turnDirection() {
      return Math.sign(this.courseVariation) === -1 ? TurnDirection.Left : TurnDirection.Right;
    }
    get deltaTrack() {
      return MathUtils$1.fastToFixedNum(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
    }
    get courseVariation() {
      return MathUtils$1.adjustAngleForTurnDirection(this.deltaTrack, this.nextLeg.metadata.turnDirection);
    }
    recomputeWithParameters(_isActive, tas, gs, ppos, _trueTrack) {
      const termFix = this.previousLeg.getPathEndPoint();
      this.computedTurnDirection = TurnDirection.Either;
      let courseChange;
      let initialTurningPoint;
      if (!this.inboundGuidable) {
        if (this.courseVariation <= 90) {
          courseChange = this.deltaTrack;
        } else if (Math.sign(this.courseVariation) === Math.sign(this.deltaTrack)) {
          courseChange = this.deltaTrack;
        } else {
          courseChange = Math.sign(this.courseVariation) * 360 + this.deltaTrack;
        }
        initialTurningPoint = ppos;
      } else {
        courseChange = this.courseVariation;
        initialTurningPoint = termFix;
      }

      // Course change and delta track?
      const radius = gs ** 2 / (Constants.G * tan$1(Math.abs(maxBank(tas, false)))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
      const turnCenter = Geo.computeDestinationPoint(initialTurningPoint, radius, this.previousLeg.outboundCourse + 90 * Math.sign(courseChange));
      const finalTurningPoint = Geo.computeDestinationPoint(turnCenter, radius, this.previousLeg.outboundCourse - 90 * Math.sign(courseChange) + courseChange);
      this.radius = radius;

      // Turn direction
      this.clockwise = courseChange >= 0;
      if (courseChange === 0) {
        this.isArc = false;
        this.startPoint = this.previousLeg.getPathEndPoint();
        this.endPoint = this.previousLeg.getPathEndPoint();
        this.terminator = this.endPoint;
        this.isComputed = true;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: PathVectorType.Line,
          startPoint: this.startPoint,
          endPoint: this.endPoint
        });
        this.isNull = true;
        return;
      }
      this.computedTurnDirection = this.clockwise ? TurnDirection.Right : TurnDirection.Left;
      this.isNull = false;
      this.isArc = true;
      this.startPoint = initialTurningPoint;
      this.center = turnCenter;
      this.endPoint = finalTurningPoint;
      this.sweepAngle = courseChange;
      this.terminator = this.endPoint;
      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.startPoint,
        centrePoint: this.center,
        endPoint: this.endPoint,
        sweepAngle: this.sweepAngle
      });
      this.isComputed = true;
    }
    get startsInCircularArc() {
      return this.isArc;
    }
    get endsInCircularArc() {
      return this.isArc;
    }
    get angle() {
      return this.sweepAngle;
    }
    isAbeam(ppos) {
      return !this.isNull && this.computedTurnDirection !== TurnDirection.Either && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
    }
    get distance() {
      if (this.isNull) {
        return 0;
      }
      return arcLength(this.radius, this.angle);
    }
    getTurningPoints() {
      return [this.startPoint, this.endPoint];
    }
    getDistanceToGo(ppos) {
      const [itp] = this.getTurningPoints();
      return arcDistanceToGo(ppos, itp, this.center, this.clockwise ? this.angle : -this.angle);
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (this.computedTurnDirection !== TurnDirection.Either) {
        const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
        let trackAngleError = this.nextLeg.inboundCourse - trueTrack;
        if (turnSign !== Math.sign(trackAngleError)) {
          trackAngleError += turnSign * 360;
        }
        if (Math.abs(trackAngleError) > 130) {
          const phiCommand = turnSign * maxBank(tas, false);
          return {
            law: ControlLaw.LATERAL_PATH,
            trackAngleError: 0,
            phiCommand,
            crossTrackError: 0
          };
        }
        this.forcedTurnComplete = true;
      }

      // FIXME PPOS guidance and all...
      return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    get repr() {
      return "COURSE CAPTURE(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
    }
  }

  /* | VRLeg */

  /* | FALeg | FMLeg */

  const tan = input => Math.tan(input * (Math.PI / 180));
  const acos = input => Math.acos(input) * (180 / Math.PI);
  let DirectToFixTransitionGuidanceState = /*#__PURE__*/function (DirectToFixTransitionGuidanceState) {
    DirectToFixTransitionGuidanceState[DirectToFixTransitionGuidanceState["Straight"] = 0] = "Straight";
    DirectToFixTransitionGuidanceState[DirectToFixTransitionGuidanceState["Turn"] = 1] = "Turn";
    return DirectToFixTransitionGuidanceState;
  }({});

  /**
   * A type I transition uses a fixed turn radius between two fix-referenced legs.
   */
  class DirectToFixTransition extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "state", DirectToFixTransitionGuidanceState.Straight);
      _defineProperty(this, "straightCourse", void 0);
      _defineProperty(this, "terminator", void 0);
      _defineProperty(this, "hasArc", void 0);
      _defineProperty(this, "center", void 0);
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "clockwise", void 0);
      _defineProperty(this, "lineStartPoint", void 0);
      _defineProperty(this, "lineEndPoint", void 0);
      _defineProperty(this, "arcStartPoint", void 0);
      _defineProperty(this, "arcCentrePoint", void 0);
      _defineProperty(this, "arcEndPoint", void 0);
      _defineProperty(this, "arcSweepAngle", void 0);
      _defineProperty(this, "computedPath", []);
    }
    getPathStartPoint() {
      return this.previousLeg.getPathEndPoint();
    }
    get turnDirection() {
      return Math.sign(this.deltaTrack);
    }
    get deltaTrack() {
      return MathUtils$1.fastToFixedNum(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
    }
    get courseVariation() {
      // TODO reverse turn direction
      return this.deltaTrack;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
      if (this.isFrozen) {
        return;
      }
      const termFix = this.previousLeg.getPathEndPoint();

      // FIXME fix for FX legs
      const nextFix = this.nextLeg.fix.infos.coordinates;
      this.radius = gs ** 2 / (Constants.G * tan(maxBank(tas, true))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
      let trackChange = MathUtils$1.diffAngle(this.previousLeg.outboundCourse, bearingTo(this.previousLeg.getPathEndPoint(), nextFix), this.nextLeg.metadata.turnDirection);
      if (Math.abs(trackChange) < 3 || !Number.isFinite(trackChange)) {
        this.isNull = true;
        this.isComputed = true;
        return;
      }
      const turnDirectionSign = trackChange > 0 ? 1 : -1;
      const turnDirection = turnDirectionSign > 0 ? TurnDirection.Right : TurnDirection.Left;
      const currentRollAngle = isActive ? -SimVar.GetSimVarValue('PLANE BANK DEGREES', 'degrees') : 0;
      const rollAngleChange = Math.abs(turnDirectionSign * maxBank(tas, true) - currentRollAngle);
      const rollAnticipationDistance = Geometry.getRollAnticipationDistance(gs, 0, rollAngleChange);
      let itp = rollAnticipationDistance >= 0.05 ? placeBearingDistance(termFix, this.previousLeg.outboundCourse, rollAnticipationDistance) : termFix;
      let turnCentre = placeBearingDistance(itp, this.previousLeg.outboundCourse + turnDirectionSign * 90, this.radius);
      let distanceToFix = distanceTo(turnCentre, nextFix);
      if (distanceToFix < this.radius) {
        if (Math.abs(MathUtils$1.diffAngle(this.previousLeg.outboundCourse, bearingTo(termFix, nextFix), this.nextLeg.metadata.turnDirection)) < 60) {
          this.hasArc = false;
          this.lineStartPoint = termFix;
          this.lineEndPoint = termFix;
          this.terminator = this.lineEndPoint;
          this.predictedPath.length = 0;
          this.predictedPath.push({
            type: PathVectorType.Line,
            startPoint: this.lineStartPoint,
            endPoint: this.lineEndPoint
          });
          this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
          this.isNull = true;
          this.isComputed = true;
          return;
        }
        const tcFixBearing = bearingTo(turnCentre, nextFix);
        const extendDist = Math.sqrt(this.radius ** 2 - distanceToFix ** 2 * Math.sin((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) ** 2) + distanceToFix * Math.cos((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) + 0.3;
        itp = placeBearingDistance(itp, this.previousLeg.outboundCourse, extendDist);
        turnCentre = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse, extendDist);
        distanceToFix = distanceTo(turnCentre, nextFix);
      }
      const bearingTcItp = bearingTo(turnCentre, itp);
      const bearingTcFix = bearingTo(turnCentre, nextFix);
      const angleFtpFix = acos(this.radius / distanceToFix);
      trackChange = MathUtils$1.diffAngle(bearingTcItp, MathUtils$1.diffAngle(turnDirectionSign * angleFtpFix, bearingTcFix), turnDirection);
      const ftp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse + trackChange - 90 * turnDirectionSign, this.radius);
      this.lineStartPoint = this.previousLeg.getPathEndPoint();
      this.lineEndPoint = itp;
      this.hasArc = true;
      this.arcStartPoint = itp;
      this.arcCentrePoint = turnCentre;
      this.arcEndPoint = ftp;
      this.arcSweepAngle = trackChange;
      this.terminator = this.arcEndPoint;
      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: PathVectorType.Line,
        startPoint: this.lineStartPoint,
        endPoint: this.lineEndPoint
      });
      this.predictedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.arcStartPoint,
        centrePoint: this.arcCentrePoint,
        endPoint: this.arcEndPoint,
        sweepAngle: this.arcSweepAngle
      });
      this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
      this.isNull = false;
      this.isComputed = true;
    }
    getPathDebugPoints() {
      const points = [];
      points.push({
        type: PathVectorType.DebugPoint,
        startPoint: this.lineStartPoint,
        annotation: 'T4 RAD START'
      }, {
        type: PathVectorType.DebugPoint,
        startPoint: this.lineEndPoint,
        annotation: 'T4 RAD END'
      });
      if (this.hasArc) {
        points.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.arcStartPoint,
          annotation: 'T4 ARC START'
        }, {
          type: PathVectorType.DebugPoint,
          startPoint: this.arcCentrePoint
        }, {
          type: PathVectorType.DebugPoint,
          startPoint: this.arcEndPoint,
          annotation: 'T4 ARC END'
        });
      }
      return points;
    }
    get endsInCircularArc() {
      return this.hasArc;
    }
    isAbeam(ppos) {
      if (this.isNull) {
        return false;
      }
      let dtg = 0;
      if (this.state === DirectToFixTransitionGuidanceState.Straight) {
        const straightDist = distanceTo(this.lineStartPoint, this.lineEndPoint);
        const straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
        dtg += straightDtg;
        if (dtg >= straightDist) {
          return false;
        }
      }
      if (this.hasArc) {
        if (this.state === DirectToFixTransitionGuidanceState.Turn) {
          const arcDtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
          dtg += arcDtg;
        } else {
          dtg += arcLength(this.radius, this.arcSweepAngle);
        }
      }
      return dtg > 0;
    }
    get distance() {
      if (this.isNull) {
        return 0;
      }
      const straightDistance = distanceTo(this.lineStartPoint, this.lineEndPoint);
      if (this.hasArc) {
        return straightDistance + arcLength(this.radius, this.arcSweepAngle);
      }
      return straightDistance;
    }
    getTurningPoints() {
      return [this.arcStartPoint, this.arcEndPoint];
    }
    getDistanceToGo(ppos) {
      let straightDtg = 0;
      if (this.state === DirectToFixTransitionGuidanceState.Straight) {
        straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
      }
      if (!this.hasArc) {
        return straightDtg;
      }
      return straightDtg + arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
    }
    getGuidanceParameters(ppos, trueTrack, tas) {
      let dtg;
      let params;

      // State machine & DTG

      switch (this.state) {
        case DirectToFixTransitionGuidanceState.Straight:
          dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
          if (dtg <= 0 && this.hasArc) {
            this.state = DirectToFixTransitionGuidanceState.Turn;
          }
          break;
        case DirectToFixTransitionGuidanceState.Turn:
          dtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
          break;
      }

      // Guidance

      switch (this.state) {
        case DirectToFixTransitionGuidanceState.Straight:
          params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.lineEndPoint);
          let bankNext = 0;
          if (this.hasArc) {
            bankNext = this.arcSweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, false);
          }
          const rad = Geometry.getRollAnticipationDistance(tas, 0, bankNext);
          if (dtg <= rad) {
            params.phiCommand = bankNext;
          }
          break;
        case DirectToFixTransitionGuidanceState.Turn:
          params = arcGuidance(ppos, trueTrack, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
          // TODO next leg RAD
          break;
      }
      return params;
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    get repr() {
      return "DIRECT TO FIX(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
    }
  }

  class CALeg extends Leg {
    constructor(course, altitude, metadata, segment, extraLength) {
      super();
      this.course = course;
      this.altitude = altitude;
      this.metadata = metadata;
      this.extraLength = extraLength;
      _defineProperty(this, "estimatedTermination", void 0);
      _defineProperty(this, "computedPath", []);
      _defineProperty(this, "start", void 0);
      _defineProperty(this, "wasMovedByPpos", false);
      this.segment = segment;
    }
    get terminationWaypoint() {
      return this.estimatedTermination;
    }
    get ident() {
      return Math.round(this.altitude).toString();
    }
    getPathStartPoint() {
      var _this$inboundGuidable;
      return (_this$inboundGuidable = this.inboundGuidable) === null || _this$inboundGuidable === void 0 ? void 0 : _this$inboundGuidable.getPathEndPoint();
    }
    getPathEndPoint() {
      return this.estimatedTermination;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(isActive, _tas, _gs, ppos, _trueTrack) {
      // FIXME somehow after reloads the isRunway property is gone, so consider airports as runways for now
      const afterRunway = this.inboundGuidable instanceof IFLeg && (this.inboundGuidable.fix.isRunway || this.inboundGuidable.fix.icao.startsWith('A'));

      // We assign / spread properties here to avoid copying references and causing bugs
      if (isActive && !afterRunway) {
        this.wasMovedByPpos = true;
        if (!this.start) {
          this.start = _objectSpread2({}, ppos);
        } else {
          this.start.lat = ppos.lat;
          this.start.long = ppos.long;
        }
        if (!this.estimatedTermination) {
          this.recomputeEstimatedTermination();
        }
      } else if (!this.wasMovedByPpos) {
        var _this$inboundGuidable2;
        const newPreviousGuidableStart = (_this$inboundGuidable2 = this.inboundGuidable) === null || _this$inboundGuidable2 === void 0 ? void 0 : _this$inboundGuidable2.getPathEndPoint();
        if (newPreviousGuidableStart) {
          if (!this.start) {
            this.start = _objectSpread2({}, newPreviousGuidableStart);
          } else {
            this.start.lat = newPreviousGuidableStart.lat;
            this.start.long = newPreviousGuidableStart.long;
          }
        }
        this.recomputeEstimatedTermination();
      }
      this.computedPath = [{
        type: PathVectorType.Line,
        startPoint: this.start,
        endPoint: this.getPathEndPoint()
      }];
      this.isComputed = true;
    }
    recomputeEstimatedTermination() {
      const ESTIMATED_VS = 2000; // feet per minute
      const ESTIMATED_KTS = 175; // NM per hour

      // FIXME hax!
      let originAltitude = 0;
      if (this.inboundGuidable instanceof IFLeg && this.inboundGuidable.fix.icao.startsWith('A')) {
        originAltitude = this.inboundGuidable.fix.infos.oneWayRunways[0].elevation * 3.28084;
      }
      const minutesToAltitude = (this.altitude - Math.max(0, originAltitude)) / ESTIMATED_VS; // minutes
      let distanceToTermination = minutesToAltitude / 60 * ESTIMATED_KTS; // NM

      if (!this.wasMovedByPpos && this.extraLength > 0) {
        distanceToTermination += this.extraLength;
      }
      this.estimatedTermination = Avionics.Utils.bearingDistanceToCoordinates(this.course, distanceToTermination, this.start.lat, this.start.long);
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.estimatedTermination);
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      // FIXME: should be just track guidance, no xtk
      // (the start of the predicted path should also float with ppos once active, along with the transition to the leg)
      // return {
      //    law: ControlLaw.TRACK,
      //    course: this.course,
      // };
      return courseToFixGuidance(ppos, trueTrack, this.course, this.estimatedTermination);
    }
    getNominalRollAngle(_gs) {
      return undefined;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      return distanceTo(startPoint, this.estimatedTermination);
    }
    isAbeam(_ppos) {
      return false;
    }
    get repr() {
      return "CA(".concat(this.course.toFixed(1), "T) TO ").concat(Math.round(this.altitude), " FT");
    }
  }

  class CRLeg extends Leg {
    constructor(course, origin, radial, metadata, segment) {
      super();
      this.course = course;
      this.origin = origin;
      this.radial = radial;
      this.metadata = metadata;
      _defineProperty(this, "computedPath", []);
      _defineProperty(this, "intercept", undefined);
      this.segment = segment;
    }
    get terminationWaypoint() {
      return this.intercept;
    }
    get ident() {
      return this.origin.ident.substring(0, 3) + this.origin.theta.toFixed(0);
    }
    getPathStartPoint() {
      if (this.inboundGuidable && this.inboundGuidable.isComputed) {
        return this.inboundGuidable.getPathEndPoint();
      }
      throw new Error('[CRLeg] No computed inbound guidable.');
    }
    getPathEndPoint() {
      return this.intercept;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.intercept = Geo.doublePlaceBearingIntercept(this.getPathStartPoint(), this.origin.coordinates, this.course, this.radial);
      const overshot = distanceTo(this.getPathStartPoint(), this.intercept) >= 5000;
      if (this.intercept && !overshot) {
        this.computedPath = [{
          type: PathVectorType.Line,
          startPoint: this.getPathStartPoint(),
          endPoint: this.intercept
        }];
        this.isNull = false;
        this.isComputed = true;
      } else {
        this.predictedPath.length = 0;
        this.isNull = true;
        this.isComputed = true;
      }
    }

    /**
     * Returns `true` if the inbound transition has overshot the leg
     */
    get overshot() {
      const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
      return side === PointSide.After;
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      return distanceTo(startPoint, this.intercept);
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getPseudoWaypointLocation(_distanceBeforeTerminator) {
      return undefined;
    }
    isAbeam(ppos) {
      const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      return dtg >= 0 && dtg <= this.distance;
    }
    get repr() {
      return "CR ".concat(this.course, "T to ").concat(this.origin.ident).concat(this.origin.theta);
    }
  }

  /**
   * Temporary - better solution is just to have an `InfiniteLine` vector...
   */
  const VM_LEG_SIZE = 321;

  // TODO needs updated with wind prediction, and maybe local magvar if following for longer distances
  class VMLeg extends Leg {
    constructor(heading, metadata, segment) {
      super();
      this.heading = heading;
      this.metadata = metadata;
      _defineProperty(this, "predictedPath", []);
      _defineProperty(this, "displayedOnMap", false);
      this.segment = segment;
    }
    get terminationWaypoint() {
      return undefined;
    }
    get ident() {
      return 'MANUAL';
    }
    getPathStartPoint() {
      var _this$inboundGuidable;
      return (_this$inboundGuidable = this.inboundGuidable) === null || _this$inboundGuidable === void 0 ? void 0 : _this$inboundGuidable.getPathEndPoint();
    }
    getPathEndPoint() {
      return Avionics.Utils.bearingDistanceToCoordinates(this.heading, VM_LEG_SIZE, this.getPathStartPoint().lat, this.getPathStartPoint().long);
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      // FIXME course based on predicted wind

      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: PathVectorType.Line,
        startPoint: this.getPathStartPoint(),
        endPoint: this.getPathEndPoint()
      });
      this.isComputed = true;
    }
    get inboundCourse() {
      // FIXME this is a bit naughty...
      return this.heading;
    }
    get outboundCourse() {
      // FIXME this is a bit naughty...
      return this.heading;
    }
    get distance() {
      return 0;
    }
    get distanceToTermination() {
      return 1;
    }

    // Can't get pseudo-waypoint location without a finite terminator
    getPseudoWaypointLocation(_distanceBeforeTerminator) {
      return undefined;
    }
    getGuidanceParameters(_ppos, _trueTrack) {
      return {
        law: ControlLaw.HEADING,
        heading: this.heading
      };
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getDistanceToGo(_ppos) {
      return undefined;
    }
    isAbeam(_ppos) {
      return true;
    }
    get disableAutomaticSequencing() {
      return true;
    }
    get repr() {
      return "VM(".concat(this.heading.toFixed(1), "T)");
    }
  }

  class DFLeg extends XFLeg {
    constructor(fix, metadata, segment) {
      super(fix);
      this.metadata = metadata;
      _defineProperty(this, "computedPath", []);
      _defineProperty(this, "start", void 0);
      this.segment = segment;
    }
    getPathStartPoint() {
      var _this$inboundGuidable, _this$inboundGuidable2;
      return (_this$inboundGuidable = (_this$inboundGuidable2 = this.inboundGuidable) === null || _this$inboundGuidable2 === void 0 ? void 0 : _this$inboundGuidable2.getPathEndPoint()) !== null && _this$inboundGuidable !== void 0 ? _this$inboundGuidable : this.estimateStartPoint();
    }
    get predictedPath() {
      return this.computedPath;
    }
    estimateStartPoint() {
      let bearing = 0;
      if (this.outboundGuidable instanceof Transition) {
        bearing = this.outboundGuidable.nextLeg.inboundCourse + 180;
      } else if (this.outboundGuidable instanceof Leg) {
        bearing = this.outboundGuidable.inboundCourse + 180;
      }
      bearing = Avionics.Utils.clampAngle(bearing);
      return Avionics.Utils.bearingDistanceToCoordinates(bearing, 2, this.fix.infos.coordinates.long, this.fix.infos.coordinates.long);
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      var _this$inboundGuidable3, _this$inboundGuidable4;
      const newStart = (_this$inboundGuidable3 = (_this$inboundGuidable4 = this.inboundGuidable) === null || _this$inboundGuidable4 === void 0 ? void 0 : _this$inboundGuidable4.getPathEndPoint()) !== null && _this$inboundGuidable3 !== void 0 ? _this$inboundGuidable3 : this.estimateStartPoint();

      // Adjust the start point if we can
      if (newStart) {
        this.start = newStart;
      }
      this.computedPath = [{
        type: PathVectorType.Line,
        startPoint: this.start,
        endPoint: this.getPathEndPoint()
      }];
      this.isComputed = true;
    }
    get inboundCourse() {
      return bearingTo(this.start, this.fix.infos.coordinates);
    }
    get outboundCourse() {
      return bearingTo(this.start, this.fix.infos.coordinates);
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.outboundCourse, this.getPathEndPoint());
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return fixToFixGuidance(ppos, trueTrack, this.start, this.fix.infos.coordinates);
    }
    getNominalRollAngle(_gs) {
      return undefined;
    }
    isAbeam(_ppos) {
      return false;
    }
    get repr() {
      return "DF TO '".concat(this.fix.ident, "'");
    }
  }

  class RFLeg extends XFLeg {
    constructor(from, to, center, metadata, segment) {
      super(to);
      this.metadata = metadata;
      // termination fix of the previous leg
      _defineProperty(this, "from", void 0);
      // to fix for the RF leg, most params referenced off this
      _defineProperty(this, "to", void 0);
      // location of the centre fix of the arc
      _defineProperty(this, "center", void 0);
      _defineProperty(this, "radius", void 0);
      _defineProperty(this, "angle", void 0);
      _defineProperty(this, "clockwise", void 0);
      _defineProperty(this, "mDistance", void 0);
      _defineProperty(this, "computedPath", []);
      this.from = from;
      this.to = to;
      this.center = center;
      this.radius = Avionics.Utils.computeGreatCircleDistance(this.center, this.to.infos.coordinates);
      this.segment = segment;
      const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates); // -90?
      const bearingTo = Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates); // -90?

      switch (to.turnDirection) {
        case 1:
          // left
          this.clockwise = false;
          this.angle = Avionics.Utils.clampAngle(bearingFrom - bearingTo);
          break;
        case 2:
          // right
          this.clockwise = true;
          this.angle = Avionics.Utils.clampAngle(bearingTo - bearingFrom);
          break;
        case 0: // unknown
        case 3: // either
        default:
          const angle = Avionics.Utils.diffAngle(bearingTo, bearingFrom);
          this.clockwise = angle > 0;
          this.angle = Math.abs(angle);
          break;
      }
      this.mDistance = 2 * Math.PI * this.radius / 360 * this.angle;
      this.computedPath = [{
        type: PathVectorType.Arc,
        startPoint: this.from.infos.coordinates,
        centrePoint: this.center,
        endPoint: this.to.infos.coordinates,
        sweepAngle: this.clockwise ? this.angle : -this.angle
      }];
      this.isComputed = true;
    }
    getPathStartPoint() {
      return this.from.infos.coordinates;
    }
    getPathEndPoint() {
      return this.to.infos.coordinates;
    }
    get predictedPath() {
      return this.computedPath;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    get inboundCourse() {
      return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates) + (this.clockwise ? 90 : -90));
    }
    get outboundCourse() {
      return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates) + (this.clockwise ? 90 : -90));
    }
    get distance() {
      return this.mDistance;
    }
    get distanceToTermination() {
      return arcLength(this.radius, this.angle);
    }

    // basically straight from type 1 transition... willl need refinement
    getGuidanceParameters(ppos, trueTrack, _tas) {
      // FIXME should be defined in terms of to fix
      return arcGuidance(ppos, trueTrack, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }

    /**
     * Calculates directed DTG parameter
     *
     * @param ppos {LatLong} the current position of the aircraft
     */
    getDistanceToGo(ppos) {
      // FIXME geometry should be defined in terms of to...
      return arcDistanceToGo(ppos, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
    }
    isAbeam(ppos) {
      const bearingPpos = Avionics.Utils.computeGreatCircleHeading(this.center, ppos);
      const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates);
      const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
      return trackAngleError >= 0;
    }
    toString() {
      return "<RFLeg radius=".concat(this.radius, " to=").concat(this.to, ">");
    }
    get repr() {
      return "RF(".concat(this.radius.toFixed(1), "NM. ").concat(this.angle.toFixed(1), "\xB0) TO ").concat(this.to.ident);
    }
  }

  var EntryType = /*#__PURE__*/function (EntryType) {
    EntryType[EntryType["Null"] = 0] = "Null";
    EntryType[EntryType["Teardrop"] = 1] = "Teardrop";
    EntryType[EntryType["Parallel"] = 2] = "Parallel";
    EntryType[EntryType["DirectOutbound"] = 3] = "DirectOutbound";
    EntryType[EntryType["DirectTurn"] = 4] = "DirectTurn";
    return EntryType;
  }(EntryType || {});
  let EntryState = /*#__PURE__*/function (EntryState) {
    EntryState[EntryState["Turn1"] = 0] = "Turn1";
    EntryState[EntryState["Straight1"] = 1] = "Straight1";
    EntryState[EntryState["Turn2"] = 2] = "Turn2";
    EntryState[EntryState["Capture"] = 3] = "Capture";
    EntryState[EntryState["Done"] = 4] = "Done";
    return EntryState;
  }({});
  class HoldEntryTransition extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      _defineProperty(this, "entry", EntryType.Null);
      _defineProperty(this, "computedPath", []);
      _defineProperty(this, "turn1", {});
      _defineProperty(this, "turn2", {});
      _defineProperty(this, "turn3", {});
      _defineProperty(this, "straightCourse", void 0);
      _defineProperty(this, "state", EntryState.Turn1);
      // hax
      _defineProperty(this, "wasAbeam", false);
      _defineProperty(this, "guidanceActive", false);
      _defineProperty(this, "frozen", false);
    }
    get distance() {
      return 0; // 0 so no PWPs
    }

    getDistanceToGo(_ppos) {
      if (this.entry === EntryType.Null || this.state === EntryState.Done) {
        return 0;
      }

      // TODO
      return 1;
    }
    setHxEntry() {
      switch (this.entry) {
        case EntryType.DirectTurn:
        case EntryType.Parallel:
        case EntryType.Teardrop:
        case EntryType.Null:
          this.nextLeg.setInitialState(HxLegGuidanceState.Arc1);
          break;
        case EntryType.DirectOutbound:
          this.nextLeg.setInitialState(HxLegGuidanceState.Outbound);
          break;
      }
    }
    getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs) {
      let dtg;

      // update state
      switch (this.state) {
        case EntryState.Turn1:
          dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          if (dtg <= 0) {
            this.state = EntryState.Straight1;
          }
          break;
        case EntryState.Straight1:
          dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);
          if (dtg <= 0) {
            this.state = EntryState.Turn2;
          }
          break;
        case EntryState.Turn2:
          dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          const refFrameOffset = Avionics.Utils.diffAngle(0, this.outboundCourse);
          const trackAngleError = this.turn2.sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - trueTrack) : Avionics.Utils.clampAngle(trueTrack - refFrameOffset);
          if (trackAngleError < 130) {
            this.state = EntryState.Capture;
          }
          break;
        case EntryState.Capture:
          dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          if (dtg < 0.1) {
            this.nextLeg.updatePrediction();
            this.state = EntryState.Done;
          }
          break;
      }
      let bankNext = 0;
      let params;
      // compute guidance
      switch (this.state) {
        case EntryState.Turn1:
          params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          break;
        case EntryState.Straight1:
          params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
          bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          break;
        case EntryState.Turn2:
          // force the initial part of the turn to ensure correct direction
          const phiCommand = this.turn2.sweepAngle > 0 ? maxBank(tas, true /* FIXME false */) : -maxBank(tas, true /* FIXME false */);
          bankNext = phiCommand;
          params = {
            law: ControlLaw.LATERAL_PATH,
            trackAngleError: 0,
            phiCommand,
            crossTrackError: 0
          };
          break;
        case EntryState.Capture:
          params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          // TODO for HF get the following leg bank
          const {
            sweepAngle
          } = this.nextLeg.geometry;
          bankNext = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          break;
        case EntryState.Done:
          params = this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
          bankNext = params.phiCommand;
          break;
      }
      const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);
      if (rad > 0 && dtg <= rad) {
        params.phiCommand = bankNext;
      }
      return params;
    }
    getDirectTurnGuidanceParameters(ppos, trueTrack, tas, _gs) {
      let dtg;
      switch (this.state) {
        case EntryState.Turn1:
          dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          if (dtg <= 0) {
            this.state = EntryState.Straight1;
          }
          break;
        case EntryState.Straight1:
          dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);
          if (dtg <= 0) {
            this.state = EntryState.Turn2;
          }
          break;
        case EntryState.Turn2:
          dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          if (dtg <= 0) {
            this.state = EntryState.Capture;
          }
          break;
        case EntryState.Capture:
          dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          if (dtg < 0.1) {
            this.state = EntryState.Done;
          }
          break;
      }
      let params;
      let bankNext;
      switch (this.state) {
        case EntryState.Turn1:
          params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          bankNext = 0;
          break;
        case EntryState.Straight1:
          params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
          bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          break;
        case EntryState.Turn2:
          params = arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          bankNext = 0;
          break;
        case EntryState.Capture:
          params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          bankNext = 0;
          break;
      }
      const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);
      if (rad > 0 && dtg <= rad) {
        params.phiCommand = bankNext;
      }
      return params;
    }

    /**
     *
     * @todo guide inbound leg for parallel + teardrop?
     */
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (!this.guidanceActive) {
        this.nextLeg.updatePrediction();
        this.guidanceActive = true;
      }
      switch (this.entry) {
        case EntryType.Parallel:
        case EntryType.Teardrop:
          return this.getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs);
        case EntryType.DirectOutbound:
          return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
        case EntryType.DirectTurn:
          return this.getDirectTurnGuidanceParameters(ppos, trueTrack, tas, gs);
      }
      return undefined;
    }
    getNominalRollAngle(gs) {
      if (this.entry === EntryType.Null) {
        return this.nextLeg.getNominalRollAngle(gs);
      }
      if (Math.abs(this.turn1.sweepAngle) <= 3) {
        return 0;
      }
      return this.turn1.sweepAngle > 0 ? maxBank(gs /* FIXME tas */, true) : -maxBank(gs /* FIXME tas */, true);
    }
    getTurningPoints() {
      switch (this.entry) {
        case EntryType.Parallel:
        case EntryType.Teardrop:
          return [this.nextLeg.fix.infos.coordinates, this.turn3.ftp];
        case EntryType.DirectTurn:
        case EntryType.DirectOutbound:
          return [this.nextLeg.fix.infos.coordinates, this.turn1.ftp];
        case EntryType.Null:
        default:
          return [this.nextLeg.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates];
      }
    }
    isAbeam(ppos) {
      // major hack
      if (!this.wasAbeam && this.previousLeg.getDistanceToGo(ppos) <= 0) {
        this.wasAbeam = true;
        return true;
      }
      return this.wasAbeam && this.state !== EntryState.Done;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    get inboundCourse() {
      return this.previousLeg.outboundCourse;
    }
    get outboundCourse() {
      return this.nextLeg.inboundCourse;
    }
    get predictedPath() {
      if (this.entry === EntryType.Null) {
        return [];
      }
      if (this.entry === EntryType.DirectOutbound) {
        if (this.nextLeg instanceof HFLeg) {
          return this.nextLeg.getHippodromePath();
        }
        return [];
      }
      return this.computedPath;
    }
    getPathDebugPoints() {
      if (this.entry === EntryType.Null) {
        return [];
      }
      const debugPoints = [{
        type: PathVectorType.DebugPoint,
        startPoint: this.turn1.arcCentre,
        annotation: 'AC1'
      }, {
        type: PathVectorType.DebugPoint,
        startPoint: this.turn1.ftp,
        annotation: 'FTP1'
      }];
      if (this.entry === EntryType.Parallel || this.entry === EntryType.Teardrop) {
        debugPoints.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.turn2.itp,
          annotation: 'ITP2',
          colour: DebugPointColour.Magenta
        });
        debugPoints.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.turn2.arcCentre,
          annotation: 'AC2',
          colour: DebugPointColour.Magenta
        });
        debugPoints.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.turn2.ftp,
          annotation: 'FTP2',
          colour: DebugPointColour.Magenta
        });
        debugPoints.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.turn3.itp,
          annotation: 'ITP3',
          colour: DebugPointColour.Yellow
        });
        debugPoints.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.turn3.arcCentre,
          annotation: 'AC3',
          colour: DebugPointColour.Yellow
        });
        debugPoints.push({
          type: PathVectorType.DebugPoint,
          startPoint: this.turn3.ftp,
          annotation: 'FTP3',
          colour: DebugPointColour.Yellow
        });
      }
      return debugPoints;
    }
    computeNullEntry() {
      this.entry = EntryType.Null;
      this.computedPath.length = 0;
    }
    computeDirectOutboundEntry() {
      this.entry = EntryType.DirectOutbound;
      const {
        radius: maxRadius
      } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
      const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
      const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + turnSign * 90, radius, this.turn1.itp.lat, this.turn1.itp.long);
      this.turn1.sweepAngle = turnSign * 180 + trackChange;
      const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
    }
    computeDirectTurnEntry() {
      this.entry = EntryType.DirectTurn;
      const {
        fixB,
        fixC,
        arcCentreFix2,
        sweepAngle,
        radius: maxRadius
      } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
      const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
      const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + turnSign * 90, radius, this.turn1.itp.lat, this.turn1.itp.long);
      this.turn1.sweepAngle = turnSign * 180 + trackChange;
      const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
      this.straightCourse = (this.outboundCourse + 180) % 360;
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: this.turn1.ftp,
        endPoint: fixB
      });
      this.turn2.itp = fixB;
      this.turn2.ftp = fixC;
      this.turn2.sweepAngle = sweepAngle;
      this.turn2.arcCentre = arcCentreFix2;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: fixB,
        centrePoint: arcCentreFix2,
        endPoint: fixC,
        sweepAngle
      });
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: fixC,
        endPoint: this.nextLeg.fix.infos.coordinates
      });
    }

    /**
     * @todo extend outbound path to ensure capture before hold fix
     */
    computeTeardropEntry() {
      this.entry = EntryType.Teardrop;
      const {
        radius,
        legLength
      } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
      this.straightCourse = Avionics.Utils.clampAngle(this.outboundCourse + 150 * turnSign);
      this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.straightCourse);
      const turn1Clockwise = this.turn1.sweepAngle >= 0;
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + (turn1Clockwise ? 90 : -90), radius, this.turn1.itp.lat, this.turn1.itp.long);
      const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (turn1Clockwise ? -90 : 90));
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
      const kekRads = Math.abs(Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180)) * Math.PI / 180;
      let minStraightDistance = radius * 2 / Math.sqrt(3) * (0.1 + Math.SQRT2 - 1 / 2 - Math.abs(Math.sin(kekRads) - 1 / 2));
      const nominalStraightDistance = 1.15 * legLength; // - Math.sin(Math.abs(this.turn1.sweepAngle * Math.PI / 180)) * radius;
      let straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
      let radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
      if (Math.SQRT2 - radii2Inbound > 0) {
        const extraCapComponent = Math.SQRT2 - radii2Inbound;
        minStraightDistance += radius * 2 / Math.sqrt(3) * extraCapComponent;
        straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
        radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
      }
      this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse, straightDistance, this.turn1.ftp.lat, this.turn1.ftp.long);
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: this.turn1.ftp,
        endPoint: this.turn2.itp
      });
      this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 120, radius, this.turn2.itp.lat, this.turn2.itp.long);
      if (radii2Inbound >= 2) {
        // we are intercepting from the inside with room for 45 deg capture
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 75, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
        this.turn2.sweepAngle = turnSign * 165;
        const straightDist = (radii2Inbound - 2) * Math.SQRT2 * radius;
        this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 165, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
        this.turn3.sweepAngle = turnSign * 45;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse - turnSign * 105, radius, this.turn3.itp.lat, this.turn3.itp.long);
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn2.ftp,
          endPoint: this.turn3.itp
        });
      } else if (Math.SQRT2 - radii2Inbound < 0) {
        // we are intercepting from the outside without enough room for 45 deg capture
        const interceptAngle = Math.acos(radii2Inbound / 2) * 180 / Math.PI;
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * (120 + interceptAngle), radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
        this.turn2.sweepAngle = turnSign * (210 + interceptAngle);
        this.turn3.itp = this.turn2.ftp;
        this.turn3.sweepAngle = -turnSign * interceptAngle;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * (120 + interceptAngle), radius, this.turn3.itp.lat, this.turn3.itp.long);
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
      } else {
        // we are intercepting from the outside with room for 45 deg capture
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
        this.turn2.sweepAngle = turnSign * 255;
        const straightDist = Math.sqrt(2 * (Math.SQRT2 - radii2Inbound) ** 2) * radius;
        this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 255, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
        this.turn3.sweepAngle = -turnSign * 45;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, radius, this.turn3.itp.lat, this.turn3.itp.long);
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
        this.computedPath.push({
          type: PathVectorType.Line,
          startPoint: this.turn2.ftp,
          endPoint: this.turn3.itp
        });
      }
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn2.itp,
        endPoint: this.turn2.ftp,
        centrePoint: this.turn2.arcCentre,
        sweepAngle: this.turn2.sweepAngle
      });
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn3.itp,
        endPoint: this.turn3.ftp,
        centrePoint: this.turn3.arcCentre,
        sweepAngle: this.turn3.sweepAngle
      });
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: this.turn3.ftp,
        endPoint: this.nextLeg.fix.infos.coordinates
      });
    }
    computeParallelEntry() {
      this.entry = EntryType.Parallel;
      const {
        radius,
        legLength
      } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + (this.nextLeg.turnDirection === TurnDirection.Right ? -90 : 90), radius, this.turn1.itp.lat, this.turn1.itp.long);
      this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180);
      const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (this.nextLeg.turnDirection === TurnDirection.Right ? 90 : -90));
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
      const turn1Rads = Math.abs(this.turn1.sweepAngle) * Math.PI / 180;
      const minStraightDistance = 0.1 + 2 * Math.cos(1 - Math.SQRT2 / 2 - Math.sin(turn1Rads)) * radius;
      const nominalStraightDistance = 1.15 * legLength - radius * Math.sin(turn1Rads);
      const straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
      this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + 180, straightDistance, this.turn1.ftp.lat, this.turn1.ftp.long);
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: this.turn1.ftp,
        endPoint: this.turn2.itp
      });
      this.straightCourse = Avionics.Utils.computeGreatCircleHeading(this.turn1.ftp, this.turn2.itp);
      this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn2.itp.lat, this.turn2.itp.long);
      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 45, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
      this.turn2.sweepAngle = turnSign * -225;
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn2.itp,
        endPoint: this.turn2.ftp,
        centrePoint: this.turn2.arcCentre,
        sweepAngle: this.turn2.sweepAngle
      });
      const ftp2ToInboundAbeamRadii = Math.cos(turn1Rads) + Math.SQRT2 / 2;
      const straightDist = Math.sqrt(2 * (ftp2ToInboundAbeamRadii - (1 - Math.SQRT2 / 2)) ** 2) * radius;
      this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: this.turn2.ftp,
        endPoint: this.turn3.itp
      });
      this.turn3.sweepAngle = turnSign * 45;
      this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 45, radius, this.turn3.itp.lat, this.turn3.itp.long);
      this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
      this.computedPath.push({
        type: PathVectorType.Arc,
        startPoint: this.turn3.itp,
        endPoint: this.turn3.ftp,
        centrePoint: this.turn3.arcCentre,
        sweepAngle: this.turn3.sweepAngle
      });
      this.computedPath.push({
        type: PathVectorType.Line,
        startPoint: this.turn3.ftp,
        endPoint: this.nextLeg.fix.infos.coordinates
      });
    }
    recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack) {
      // TODO only HX leg drives this

      const hxInbound = this.outboundCourse;
      const entryAngle = Avionics.Utils.diffAngle(this.inboundCourse, hxInbound);
      if (this.frozen) {
        if (this.state === EntryState.Done) {
          this.computedPath.length = 0;
        }
        return;
      }
      if (isActive && !this.frozen) {
        this.frozen = true;
      }
      // TODO freeze once we're active?

      // TODO, should HA entry become null when the leg is no longer flown?
      // might have bad implications for the next leg, and also for straying outside protected area
      // related: if we still fly the entry... should we shorten the leg length to minimum?
      if (!this.previousLeg || entryAngle >= -3 && entryAngle <= 3) {
        this.computeNullEntry();
        this.setHxEntry();
        this.isNull = true;
        return;
      }
      this.isNull = false;

      // parallel entry is always used when entering from opposite of hold course...
      // we give a 3 degree tolerance to allow for mag var, calculation errors etc.
      if (this.nextLeg.turnDirection === TurnDirection.Left) {
        if (entryAngle > 110 && entryAngle < 177) {
          this.computeTeardropEntry();
        } else if (entryAngle >= 177 && entryAngle <= 180 || entryAngle > -180 && entryAngle < -70) {
          this.computeParallelEntry();
        } else if (entryAngle >= -70 && entryAngle < -3) {
          this.computeDirectTurnEntry();
        } else {
          this.computeDirectOutboundEntry();
        }
      } else if (this.nextLeg.turnDirection === TurnDirection.Right) {
        if (entryAngle > -177 && entryAngle < -110) {
          this.computeTeardropEntry();
        } else if (entryAngle > 70 && entryAngle <= 180 || entryAngle > -180 && entryAngle <= -177) {
          this.computeParallelEntry();
        } else if (entryAngle > 3 && entryAngle <= 70) {
          this.computeDirectTurnEntry();
        } else {
          this.computeDirectOutboundEntry();
        }
      }

      // prepare the HX leg for our entry type
      this.setHxEntry();
    }
    getPathStartPoint() {
      return this.getTurningPoints()[0];
    }
    getPathEndPoint() {
      return this.getTurningPoints()[1];
    }
    get repr() {
      return "HOLD ENTRY(".concat(this.nextLeg.repr, ")");
    }
  }

  // Copyright (c) 2021-2022 FlyByWire Simulations
  class TransitionPicker {
    static forLegs(from, to) {
      if (from instanceof AFLeg) {
        return TransitionPicker.fromAF(from, to);
      }
      if (from instanceof CALeg) {
        return TransitionPicker.fromCA(from, to);
      }
      if (from instanceof CFLeg) {
        return TransitionPicker.fromCF(from, to);
      }
      if (from instanceof DFLeg) {
        return TransitionPicker.fromDF(from, to);
      }
      if (from instanceof HALeg || from instanceof HFLeg || from instanceof HMLeg) {
        return TransitionPicker.fromHX(from, to);
      }
      if (from instanceof PILeg) {
        return TransitionPicker.fromPI(from, to);
      }
      if (from instanceof RFLeg) {
        return TransitionPicker.fromRF(from, to);
      }
      if (from instanceof TFLeg) {
        return TransitionPicker.fromTF(from, to);
      }
      if (from instanceof CILeg) {
        return TransitionPicker.fromCI(from, to);
      }
      if (from instanceof CRLeg) {
        return TransitionPicker.fromCR(from, to);
      }
      if (from instanceof VMLeg) {
        return TransitionPicker.fromVM(from, to);
      }
      return null;
    }
    static fromCA(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromAF(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        // FIXME fixed radius / revert to path capture
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromCF(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        // FIXME fixed radius / revert to path capture
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof PILeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromCI(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      return null;
    }
    static fromDF(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof PILeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromHX(from, to) {
      if (to instanceof AFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromPI(from, to) {
      if (!(to instanceof CFLeg)) {
        console.error('PI -> !CF', from, to);
      }
      return null;
    }
    static fromRF(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      return null;
    }
    static fromTF(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        // FIXME / revert to fixed radius
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof PILeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromCR(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        // FIXME / revert to fixed radius
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
    static fromVM(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      return null;
    }
  }

  function isGuidableCapturingPath(guidable) {
    return !(guidable instanceof CALeg || guidable instanceof CILeg || guidable instanceof CRLeg || guidable instanceof VMLeg || guidable instanceof CourseCaptureTransition);
  }
  class Geometry {
    constructor(transitions, legs, temp) {
      this.temp = temp;
      /**
       * The list of transitions between legs.
       * - entry n: transition after leg n
       */
      _defineProperty(this, "transitions", void 0);
      /**
       * The list of legs in this geometry, possibly connected through transitions:
       * - entry n: nth leg, before transition n
       */
      _defineProperty(this, "legs", void 0);
      _defineProperty(this, "version", 0);
      _defineProperty(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
      _defineProperty(this, "isComputed", false);
      _defineProperty(this, "cachedVectors", []);
      _defineProperty(this, "cachedVectorsVersion", 0);
      this.transitions = transitions;
      this.legs = legs;
    }
    getAllPathVectors(activeLegIndex) {
      if (this.version === this.cachedVectorsVersion) {
        return this.cachedVectors;
      }
      const transmitHoldEntry = !this.temp;
      const ret = [];
      for (const [index, leg] of this.legs.entries()) {
        if (leg.isNull) {
          continue;
        }

        // TODO don't transmit any course reversals when this side range >= 160
        const transmitCourseReversal = index === activeLegIndex || index === activeLegIndex + 1;
        if (activeLegIndex !== undefined) {
          if (isCourseReversalLeg(leg) && !transmitCourseReversal) {
            continue;
          }
          if (index < activeLegIndex) {
            continue;
          }
        }
        const legInboundTransition = leg.inboundGuidable instanceof Transition ? leg.inboundGuidable : null;
        if (legInboundTransition && !legInboundTransition.isNull && (!isHold(leg) || transmitHoldEntry)) {
          ret.push(...legInboundTransition.predictedPath);
        }
        if (leg) {
          ret.push(...leg.predictedPath);
        }
      }
      this.cachedVectors = ret;
      this.cachedVectorsVersion = this.version;
      return ret;
    }

    /**
     * Recomputes the guidable using new parameters
     *
     * @param tas             predicted true airspeed speed of the current leg (for a leg) or the next leg (for a transition) in knots
     * @param gs              predicted ground speed of the current leg
     * @param ppos            present position coordinates
     * @param trueTrack       present true track
     * @param activeLegIdx    current active leg index
     * @param activeTransIdx  current active transition index
     */
    recomputeWithParameters(tas, gs, ppos, trueTrack, activeLegIdx, _activeTransIdx) {
      this.version++;
      for (let i = activeLegIdx !== null && activeLegIdx !== void 0 ? activeLegIdx : 0; this.legs.get(i) || this.legs.get(i + 1); i++) {
        if (!this.legs.has(i)) {
          continue;
        }
        const leg = this.legs.get(i);
        const wasNull = leg.isNull;
        this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);

        // If a leg became null/not null, we immediately recompute it to calculate the new guidables and transitions
        if (!wasNull && leg.isNull || wasNull && !leg.isNull) {
          this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);
        }
      }
    }
    static getLegPredictedTas(leg, currentTas) {
      var _leg$predictedTas;
      return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_leg$predictedTas = leg.predictedTas) !== null && _leg$predictedTas !== void 0 ? _leg$predictedTas : currentTas);
    }
    static getLegPredictedGs(leg, currentGs) {
      var _leg$predictedGs;
      return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_leg$predictedGs = leg.predictedGs) !== null && _leg$predictedGs !== void 0 ? _leg$predictedGs : currentGs);
    }
    computeLeg(index, activeLegIdx, ppos, trueTrack, tas, gs) {
      const prevLeg = this.legs.get(index - 1);
      const leg = this.legs.get(index);
      const nextLeg = this.legs.get(index + 1);
      const nextNextLeg = this.legs.get(index + 2);
      const inboundTransition = this.transitions.get(index - 1);
      const outboundTransition = this.transitions.get(index);
      const legPredictedTas = Geometry.getLegPredictedTas(leg, tas);
      const legPredictedGs = Geometry.getLegPredictedGs(leg, gs);

      // If the leg is null, we compute the following:
      //  - transition from prevLeg to nextLeg
      //  - nextLeg
      //  - transition from nextLeg to nextNextLeg (in order to compute nextLeg)
      if (leg !== null && leg !== void 0 && leg.isNull) {
        if (nextLeg) {
          var _newInboundTransition, _newOutboundTransitio;
          let newInboundTransition;
          {
            newInboundTransition = TransitionPicker.forLegs(prevLeg, nextLeg);
          }
          let newOutboundTransition;
          if (nextNextLeg && LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1 || index + 1 - activeLegIdx < LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE) {
            newOutboundTransition = TransitionPicker.forLegs(nextLeg, nextNextLeg);
          }
          if (newInboundTransition && prevLeg) {
            const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
            const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
            newInboundTransition.setNeighboringGuidables(prevLeg, nextLeg);
            newInboundTransition.recomputeWithParameters(activeLegIdx === index, prevLegPredictedLegTas, prevLegPredictedLegGs, ppos, trueTrack);
          }
          const nextLegPredictedLegTas = Geometry.getLegPredictedTas(nextLeg, tas);
          const nextLegPredictedLegGs = Geometry.getLegPredictedGs(nextLeg, gs);
          nextLeg.setNeighboringGuidables((_newInboundTransition = newInboundTransition) !== null && _newInboundTransition !== void 0 ? _newInboundTransition : prevLeg, (_newOutboundTransitio = newOutboundTransition) !== null && _newOutboundTransitio !== void 0 ? _newOutboundTransitio : nextNextLeg);
          nextLeg.recomputeWithParameters(activeLegIdx === index, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
          if (newOutboundTransition) {
            newOutboundTransition.setNeighboringGuidables(nextLeg, nextNextLeg);
            newOutboundTransition.recomputeWithParameters(activeLegIdx === index + 1, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
            nextLeg.recomputeWithParameters(activeLegIdx === index, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
          }
        }
      }
      if (inboundTransition && prevLeg) {
        const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
        const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
        inboundTransition.setNeighboringGuidables(prevLeg, leg);
        inboundTransition.setNeighboringLegs(prevLeg, leg);
        inboundTransition.recomputeWithParameters(activeLegIdx === index, prevLegPredictedLegTas, prevLegPredictedLegGs, ppos, trueTrack);
      }

      // Compute leg and outbound if previous leg isn't null (we already computed 1 leg forward the previous iteration)
      if (!(prevLeg && prevLeg.isNull)) {
        leg.setNeighboringGuidables(inboundTransition !== null && inboundTransition !== void 0 ? inboundTransition : prevLeg, outboundTransition !== null && outboundTransition !== void 0 ? outboundTransition : nextLeg);
        leg.recomputeWithParameters(activeLegIdx === index, legPredictedTas, legPredictedGs, ppos, trueTrack);
        if (outboundTransition && nextLeg) {
          outboundTransition.setNeighboringGuidables(leg, nextLeg);
          outboundTransition.setNeighboringLegs(leg, nextLeg);
          outboundTransition.recomputeWithParameters(activeLegIdx === index + 1, legPredictedTas, legPredictedGs, ppos, trueTrack);

          // Since the outbound transition can have TAD, we recompute the leg again to make sure the end point is at the right place for this cycle
          leg.setNeighboringGuidables(inboundTransition !== null && inboundTransition !== void 0 ? inboundTransition : prevLeg, outboundTransition);
          leg.recomputeWithParameters(activeLegIdx === index, legPredictedTas, legPredictedGs, ppos, trueTrack);
        }
      }
    }

    /**
     * @param activeLegIdx
     * @param ppos
     * @param trueTrack
     * @param gs
     * @param tas
     */
    getGuidanceParameters(activeLegIdx, ppos, trueTrack, gs, tas) {
      const activeLeg = this.legs.get(activeLegIdx);
      const nextLeg = this.legs.get(activeLegIdx + 1);

      // TODO handle in guidance controller state
      const autoSequencing = !(activeLeg !== null && activeLeg !== void 0 && activeLeg.disableAutomaticSequencing);
      let activeGuidable = null;
      let nextGuidable = null;

      // first, check if we're abeam with one of the transitions (start or end)
      const fromTransition = this.transitions.get(activeLegIdx - 1);
      const toTransition = this.transitions.get(activeLegIdx);
      if (fromTransition && !fromTransition.isNull && fromTransition.isAbeam(ppos)) {
        if (!fromTransition.isFrozen) {
          fromTransition.freeze();
        }

        // Since CA leg CourseCaptureTransition inbound starts at PPOS, we always consider the CA leg as the active guidable
        if (fromTransition instanceof CourseCaptureTransition && activeLeg instanceof CALeg) {
          activeGuidable = activeLeg;
          nextGuidable = toTransition;
        } else {
          activeGuidable = fromTransition;
          nextGuidable = activeLeg;
        }
      } else if (toTransition && !toTransition.isNull && autoSequencing) {
        // TODO need to check that the previous leg is actually flown first...
        if (toTransition.isAbeam(ppos)) {
          if (toTransition instanceof FixedRadiusTransition && !toTransition.isFrozen) {
            toTransition.freeze();
          }
          activeGuidable = toTransition;
          nextGuidable = nextLeg;
        } else if (activeLeg) {
          activeGuidable = activeLeg;
          nextGuidable = toTransition;
        }
      } else if (activeLeg) {
        activeGuidable = activeLeg;
        if (nextLeg && autoSequencing) {
          nextGuidable = nextLeg;
        }
      }

      // figure out guidance params and roll anticipation
      let guidanceParams;
      let rad;
      let dtg;
      if (activeGuidable) {
        const phiLimit = maxBank(tas, isGuidableCapturingPath(activeGuidable));
        guidanceParams = _objectSpread2(_objectSpread2({}, activeGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs)), {}, {
          phiLimit
        });
        dtg = activeGuidable.getDistanceToGo(ppos);
        if (activeGuidable && nextGuidable) {
          rad = this.getGuidableRollAnticipationDistance(gs, activeGuidable, nextGuidable);
          if (rad > 0 && dtg <= rad) {
            const nextGuidanceParams = nextGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs);
            if (nextGuidanceParams.law === ControlLaw.LATERAL_PATH) {
              var _nextGuidanceParams$p;
              guidanceParams.phiCommand = (_nextGuidanceParams$p = nextGuidanceParams === null || nextGuidanceParams === void 0 ? void 0 : nextGuidanceParams.phiCommand) !== null && _nextGuidanceParams$p !== void 0 ? _nextGuidanceParams$p : 0;
            }
          }
        }
      }
      return guidanceParams;
    }
    getGuidableRollAnticipationDistance(gs, from, to) {
      if (!from.endsInCircularArc && !to.startsInCircularArc) {
        return 0;
      }

      // get nominal phi from previous and next leg
      const phiNominalFrom = from.endsInCircularArc ? from.getNominalRollAngle(gs) : 0;
      const phiNominalTo = to.startsInCircularArc ? to.getNominalRollAngle(gs) : 0;

      // TODO consider case where RAD > transition distance

      return Geometry.getRollAnticipationDistance(gs, phiNominalFrom, phiNominalTo);
    }
    static getRollAnticipationDistance(gs, bankA, bankB) {
      // calculate delta phi
      const deltaPhi = Math.abs(bankA - bankB);

      // calculate RAD
      const maxRollRate = 5; // deg / s, TODO picked off the wind
      const k2 = 0.0038;
      const rad = gs / 3600 * (Math.sqrt(1 + 2 * k2 * 9.81 * deltaPhi / maxRollRate) - 1) / (k2 * 9.81);
      return rad;
    }
    getDistanceToGo(activeLegIdx, ppos) {
      const activeLeg = this.legs.get(activeLegIdx);
      if (activeLeg) {
        return activeLeg.getDistanceToGo(ppos);
      }
      return null;
    }
    shouldSequenceLeg(activeLegIdx, ppos) {
      const activeLeg = this.legs.get(activeLegIdx);
      const inboundTransition = this.transitions.get(activeLegIdx - 1);

      // Restrict sequencing in cases where we are still in inbound transition. Make an exception for very short legs as the transition could be overshooting.
      if (!(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull) && inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isAbeam(ppos) && activeLeg.distance > 0.01) {
        return false;
      }
      const dtg = activeLeg.getDistanceToGo(ppos);
      if (dtg <= 0 || activeLeg.isNull) {
        return true;
      }
      if (activeLeg) {
        return activeLeg.getDistanceToGo(ppos) < 0.001;
      }
      return false;
    }
    onLegSequenced(_sequencedLeg, nextLeg, followingLeg) {
      if (isCourseReversalLeg(nextLeg) || isCourseReversalLeg(followingLeg)) {
        this.version++;
      }
    }
    legsInSegment(segmentType) {
      const newMap = new Map();
      for (const entry of this.legs.entries()) {
        if (entry[1].segment === segmentType) {
          newMap.set(...entry);
        }
      }
      return newMap;
    }

    /**
     * Returns DTG for a complete leg path, taking into account transitions (including split FXR)
     *
     * @param ppos      present position
     * @param leg       the leg guidable
     * @param inbound   the inbound transition guidable, if present
     * @param outbound  the outbound transition guidable, if present
     */
    static completeLegPathDistanceToGo(ppos, leg, inbound, outbound) {
      const [, legPartLength, outboundTransLength] = Geometry.completeLegPathLengths(leg, inbound, outbound);
      if (outbound && outbound.isAbeam(ppos)) {
        return outbound.getDistanceToGo(ppos) - outbound.distance / 2; // Remove half of the transition length, since it is split (Type I)
      }

      if (inbound && inbound.isAbeam(ppos)) {
        return inbound.getDistanceToGo(ppos) + legPartLength + outboundTransLength;
      }
      return leg.getDistanceToGo(ppos) - (outbound && outbound instanceof FixedRadiusTransition ? outbound.unflownDistance : 0) + outboundTransLength;
    }

    /**
     * Returns lengths of the different segments of a leg, taking into account transitions (including split FXR)
     *
     * @param leg       the leg guidable
     * @param inbound   the inbound transition guidable, if present
     * @param outbound  the outbound transition guidable, if present
     */
    static completeLegPathLengths(leg, inbound, outbound) {
      let inboundLength = 0;
      let outboundLength = 0;
      let legDistance = leg.distance;
      if (outbound) {
        if (outbound instanceof FixedRadiusTransition && !outbound.isReverted) {
          // Type I transitions are split between the prev and next legs
          outboundLength = outbound.distance / 2;
        }
      }
      if (inbound) {
        if (inbound instanceof FixedRadiusTransition && !inbound.isReverted) {
          // Type I transitions are split between the prev and next legs
          inboundLength = inbound.distance / 2;
        } else {
          inboundLength = inbound.distance;
        }

        // TODO: This is a hack. In the situation where we have a TF -> FixedRadius -> CF and the FixedRadius reverts to PathCapture such that it overshoots the fix of the CF,
        // the CF's distance is the distance between where the transition intercepts the next leg and the fix of the CF, but the AC will not fly this distance
        if (leg instanceof XFLeg && leg.overshot && leg.distance > 0) {
          legDistance = -leg.distance;
        }
      }
      return [inboundLength, legDistance, outboundLength];
    }
  }

  let HxLegGuidanceState = /*#__PURE__*/function (HxLegGuidanceState) {
    HxLegGuidanceState[HxLegGuidanceState["Inbound"] = 0] = "Inbound";
    HxLegGuidanceState[HxLegGuidanceState["Arc1"] = 1] = "Arc1";
    HxLegGuidanceState[HxLegGuidanceState["Outbound"] = 2] = "Outbound";
    HxLegGuidanceState[HxLegGuidanceState["Arc2"] = 3] = "Arc2";
    return HxLegGuidanceState;
  }({});

  // TODO make sure IMM EXIT works during teardrop/parallel (proceed to HF via that entry then sequence the HM immediately)
  // TODO move HMLeg specific logic to HMLeg
  class HXLeg extends XFLeg {
    constructor(fix, metadata, segment) {
      super(fix);
      this.metadata = metadata;
      this.segment = segment;
      // TODO consider different entries for initial state...
      // TODO make protected when done with DebugHXLeg
      _defineProperty(this, "state", HxLegGuidanceState.Inbound);
      _defineProperty(this, "initialState", HxLegGuidanceState.Inbound);
      _defineProperty(this, "termConditionMet", false);
      /**
       * Predicted tas for next prediction update
       * Not including wind
       */
      _defineProperty(this, "nextPredictedTas", 180);
      /**
       * Nominal TAS used for the current prediction
       * Not including wind
       */
      _defineProperty(this, "currentPredictedTas", 180);
      /**
       * Nominal ground speed used the current prediction
       * including wind
       */
      _defineProperty(this, "currentPredictedGs", 180);
      /**
       * Wind velocity along the inbound leg
       */
      _defineProperty(this, "inboundWindSpeed", void 0);
      /**
       * Current predicted hippodrome geometry
       */
      _defineProperty(this, "geometry", void 0);
      this.geometry = this.computeGeometry();
    }
    get inboundLegCourse() {
      return this.fix.additionalData.course;
    }
    get outboundLegCourse() {
      return (this.inboundLegCourse + 180) % 360;
    }
    get turnDirection() {
      return this.fix.turnDirection;
    }
    get ident() {
      return this.fix.ident;
    }

    /**
     * Used by hold entry transition to set our initial state depending on entry type
     * @param initialState
     */
    setInitialState(initialState) {
      // TODO check if already active and deny...
      this.state = initialState;
      this.initialState = initialState;
    }
    get outboundStartPoint() {
      const {
        fixB
      } = this.computeGeometry();
      return fixB;
    }
    computeLegDistance() {
      var _this$fix$legAltitude, _this$inboundWindSpee;
      // is distance in NM?
      if (this.fix.additionalData.distance !== undefined) {
        return this.fix.additionalData.distance;
      }
      const alt = (_this$fix$legAltitude = this.fix.legAltitude1) !== null && _this$fix$legAltitude !== void 0 ? _this$fix$legAltitude : SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet');

      // distance is in time then...
      const defaultMinutes = alt < 14000 ? 1 : 1.5;
      const inboundGroundSpeed = this.currentPredictedTas + ((_this$inboundWindSpee = this.inboundWindSpeed) !== null && _this$inboundWindSpee !== void 0 ? _this$inboundWindSpee : 0);
      return (this.fix.additionalData.distanceInMinutes !== undefined ? this.fix.additionalData.distanceInMinutes : defaultMinutes) * inboundGroundSpeed / 60;
    }
    computeGeometry() {
      /*
       * We define some fixes at the turning points around the hippodrome like so (mirror vertically for left turn):
       *         A          B
       *         *----------*
       *       /              \
       * arc1 |  *          *  | arc2
       *       \              /
       *         *<---------*
       *      hold fix      C
       */

      const legLength = this.computeLegDistance();
      const radius = this.radius;
      const turnSign = this.turnDirection === TurnDirection.Left ? -1 : 1;
      const fixA = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius * 2, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
      const fixB = Avionics.Utils.bearingDistanceToCoordinates(this.outboundLegCourse, legLength, fixA.lat, fixA.long);
      const fixC = Avionics.Utils.bearingDistanceToCoordinates(this.outboundLegCourse, legLength, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
      const arcCentreFix1 = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
      const arcCentreFix2 = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius, fixC.lat, fixC.long);
      return {
        fixA,
        fixB,
        fixC,
        arcCentreFix1,
        arcCentreFix2,
        sweepAngle: turnSign * 180,
        legLength,
        radius
      };
    }
    get radius() {
      const gsMs = this.currentPredictedGs / 1.94384;
      const radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(this.currentPredictedTas, true) * Math.PI / 180)) / 1852;
      return radius;
    }
    get terminationPoint() {
      return this.fix.infos.coordinates;
    }
    get distance() {
      return 0; // 0 so no PWPs
    }

    get inboundCourse() {
      return this.inboundLegCourse;
    }
    get outboundCourse() {
      return this.inboundLegCourse;
    }
    get startsInCircularArc() {
      // this is intended to be used only for entry...
      return this.state === HxLegGuidanceState.Arc1 || this.state === HxLegGuidanceState.Arc2;
    }

    /**
     *
     * @param tas
     * @returns
     */
    getNominalRollAngle(gs) {
      return this.endsInCircularArc ? maxBank(gs, true) : 0;
    }
    getDistanceToGoThisOrbit(ppos) {
      const {
        fixB,
        arcCentreFix1,
        arcCentreFix2,
        sweepAngle
      } = this.geometry;
      switch (this.state) {
        case HxLegGuidanceState.Inbound:
          return courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
        case HxLegGuidanceState.Arc1:
          return arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle) + this.computeLegDistance() * 2 + this.radius * Math.PI;
        case HxLegGuidanceState.Outbound:
          return courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB) + this.computeLegDistance() + this.radius * Math.PI;
        case HxLegGuidanceState.Arc2:
          return arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle) + this.computeLegDistance();
        // no default
      }

      return 1;
    }
    getDistanceToGo(ppos) {
      return this.getDistanceToGoThisOrbit(ppos);
    }
    getHippodromePath() {
      const {
        fixA,
        fixB,
        fixC,
        arcCentreFix1,
        arcCentreFix2,
        sweepAngle
      } = this.geometry;
      return [{
        type: PathVectorType.Arc,
        startPoint: this.fix.infos.coordinates,
        centrePoint: arcCentreFix1,
        endPoint: fixA,
        sweepAngle
      }, {
        type: PathVectorType.Line,
        startPoint: fixA,
        endPoint: fixB
      }, {
        type: PathVectorType.Arc,
        startPoint: fixB,
        centrePoint: arcCentreFix2,
        endPoint: fixC,
        sweepAngle
      }, {
        type: PathVectorType.Line,
        startPoint: fixC,
        endPoint: this.fix.infos.coordinates
      }];
    }
    get predictedPath() {
      return this.getHippodromePath();
    }
    updateState(ppos, tas, geometry) {
      let dtg = 0;

      // TODO divide up into sectors and choose based on that?

      switch (this.state) {
        case HxLegGuidanceState.Inbound:
          {
            dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
            break;
          }
        case HxLegGuidanceState.Arc1:
          {
            dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, geometry.arcCentreFix1, geometry.sweepAngle);
            break;
          }
        case HxLegGuidanceState.Outbound:
          {
            dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, geometry.fixB);
            break;
          }
        case HxLegGuidanceState.Arc2:
          {
            dtg = arcDistanceToGo(ppos, geometry.fixB, geometry.arcCentreFix2, geometry.sweepAngle);
            break;
          }
        default:
          throw new Error("Bad HxLeg state ".concat(this.state));
      }
      if (dtg <= 0) {
        if (this.state === HxLegGuidanceState.Inbound) {
          if (this.termConditionMet) {
            return;
          }
          this.updatePrediction();
        }
        this.state = (this.state + 1) % (HxLegGuidanceState.Arc2 + 1);
        console.log("HX switched to state ".concat(HxLegGuidanceState[this.state]));
      }
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      const {
        fixB,
        arcCentreFix1,
        arcCentreFix2,
        sweepAngle,
        legLength
      } = this.geometry;
      this.updateState(ppos, tas, this.geometry);
      let params;
      let dtg;
      let nextPhi = 0;
      let rad = 0;
      switch (this.state) {
        case HxLegGuidanceState.Inbound:
          params = courseToFixGuidance(ppos, trueTrack, this.inboundLegCourse, this.fix.infos.coordinates);
          dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
          nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          break;
        case HxLegGuidanceState.Arc1:
          params = arcGuidance(ppos, trueTrack, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
          dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          if (legLength <= rad) {
            nextPhi = params.phiCommand;
          }
          break;
        case HxLegGuidanceState.Outbound:
          params = courseToFixGuidance(ppos, trueTrack, this.outboundLegCourse, fixB);
          dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB);
          nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          break;
        case HxLegGuidanceState.Arc2:
          params = arcGuidance(ppos, trueTrack, fixB, arcCentreFix2, sweepAngle);
          dtg = arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          if (legLength <= rad) {
            nextPhi = params.phiCommand;
          }
          break;
        default:
          throw new Error("Bad HxLeg state ".concat(this.state));
      }

      // TODO HF/HA too
      if (dtg <= rad && !(this.state === HxLegGuidanceState.Inbound && this.termConditionMet)) {
        params.phiCommand = nextPhi;
      }
      return params;
    }
    recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack, _startAltitude, _verticalSpeed) {
      if (!isActive) {
        this.updatePrediction();
      }
    }
    setPredictedTas(tas) {
      this.nextPredictedTas = tas;
    }

    /**
     * Should be called on each crossing of the hold fix
     */
    updatePrediction() {
      const windDirection = SimVar.GetSimVarValue('AMBIENT WIND DIRECTION', 'Degrees');
      const windSpeed = SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', 'Knots');
      const windAngleToInbound = Math.abs(Avionics.Utils.diffAngle(reciprocal(windDirection), this.inboundLegCourse));
      this.inboundWindSpeed = Math.cos(windAngleToInbound * Math.PI / 180) * windSpeed;
      this.currentPredictedTas = this.nextPredictedTas;
      this.currentPredictedGs = this.currentPredictedTas + windSpeed;
      this.geometry = this.computeGeometry();

      // TODO update entry transition too
    }

    // TODO are we even using this? What exactly should it tell us?
    isAbeam(_ppos) {
      return false;
    }
    getPathStartPoint() {
      return this.fix.infos.coordinates;
    }
    getPathEndPoint() {
      // TODO consider early exit to CF on HF leg
      return this.fix.infos.coordinates;
    }
  }
  class HMLeg extends HXLeg {
    constructor() {
      super(...arguments);
      // TODO only reset this on crossing the hold fix (so exit/resume/exit keeps the existing shortened path)
      _defineProperty(this, "immExitLength", void 0);
    }
    /**
     * Use for IMM EXIT set/reset function on the MCDU
     * Note: if IMM EXIT is set before this leg is active it should be deleted from the f-pln instead
     * @param
     */
    setImmediateExit(exit, ppos, tas) {
      // TODO if we're still in the entry transition, HM becomes empty, but still fly the entry

      const {
        legLength,
        fixA,
        sweepAngle
      } = this.geometry;
      if (exit) {
        switch (this.state) {
          case HxLegGuidanceState.Arc1:
            // let's do a circle
            this.immExitLength = 0;
            break;
          case HxLegGuidanceState.Outbound:
            const nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            const rad = Geometry.getRollAnticipationDistance(tas, 0, nextPhi);
            this.immExitLength = Math.min(legLength, rad + courseToFixDistanceToGo(ppos, this.inboundLegCourse, fixA));
            break;
          case HxLegGuidanceState.Arc2:
          case HxLegGuidanceState.Inbound:
            // keep the normal leg distance as we can't shorten
            this.immExitLength = legLength;
            break;
          // no default
        }
      }

      // hack to allow f-pln page to see state
      this.fix.additionalData.immExit = exit;
      this.termConditionMet = exit;

      // if resuming hold, the geometry will be recomputed on the next pass of the hold fix
      if (exit) {
        this.geometry = this.computeGeometry();
      }
    }
    computeLegDistance() {
      if (this.termConditionMet) {
        return this.immExitLength;
      }
      return super.computeLegDistance();
    }
    get disableAutomaticSequencing() {
      return !this.termConditionMet;
    }
    get repr() {
      return "HM '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection]);
    }
  }

  // TODO
  /*
  If the aircraft reaches or exceeds the altitude
  specified in the flight plan before the HA leg is active, the aircraft
  does not enter the hold
  */
  class HALeg extends HXLeg {
    constructor(to, metadata, segment) {
      super(to, metadata, segment);

      // the term altitude is guaranteed to be at or above, and in field altitude1, by ARINC424 coding rules
      this.to = to;
      this.metadata = metadata;
      this.segment = segment;
      _defineProperty(this, "targetAltitude", void 0);
      if (this.fix.legAltitudeDescription !== AltitudeDescriptor.AtOrAbove) {
        console.warn("HALeg invalid altitude descriptor ".concat(this.fix.legAltitudeDescription, ", must be ").concat(AltitudeDescriptor.AtOrAbove));
      }
      this.targetAltitude = this.fix.legAltitude1;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') >= this.targetAltitude) {
        this.termConditionMet = true;
      }
      return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
      if (SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') >= this.targetAltitude) {
        this.termConditionMet = true;
      }
      if (!isActive && this.termConditionMet) {
        this.isNull = true;
      }
      this.setPredictedTas(tas);
      super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
    }
    getDistanceToGo(ppos) {
      if (this.isNull) {
        return 0;
      }
      if (this.termConditionMet) {
        return this.getDistanceToGoThisOrbit(ppos);
      }
      const {
        legLength,
        radius
      } = this.geometry;
      return legLength * 2 + radius * Math.PI * 2;
    }
    get disableAutomaticSequencing() {
      return !this.termConditionMet;
    }
    get predictedPath() {
      if (!this.isNull) {
        return super.predictedPath;
      }
      return [];
    }
    get repr() {
      return "HA '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection], " - ").concat(this.targetAltitude.toFixed(0));
    }
  }
  class HFLeg extends HXLeg {
    constructor() {
      super(...arguments);
      _defineProperty(this, "entryTransition", void 0);
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (this.entryTransition) {
        this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === EntryState.Capture || this.entryTransition.state === EntryState.Done;
      }
      return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
      if (this.inboundGuidable instanceof HoldEntryTransition) {
        this.entryTransition = this.inboundGuidable;
        this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === EntryState.Capture || this.entryTransition.state === EntryState.Done;
      }
      this.setPredictedTas(tas);
      super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
    }
    getDistanceToGo(ppos) {
      var _this$entryTransition, _this$entryTransition2;
      return (_this$entryTransition = (_this$entryTransition2 = this.entryTransition) === null || _this$entryTransition2 === void 0 ? void 0 : _this$entryTransition2.getDistanceToGo(ppos)) !== null && _this$entryTransition !== void 0 ? _this$entryTransition : 0;
    }
    get predictedPath() {
      return [];
    }
    get disableAutomaticSequencing() {
      return false;
    }
    get repr() {
      return "HF '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection]);
    }
  }

  /**
   * This class will guide the aircraft by predicting a flight path and
   * calculating the autopilot inputs to follow the predicted flight path.
   */
  class GuidanceManager {
    constructor(flightPlanManager) {
      _defineProperty(this, "flightPlanManager", void 0);
      this.flightPlanManager = flightPlanManager;
    }

    /**
     * Returns a {@link Leg} from two {@link WayPoint} objects. Only for fpm v1.
     *
     * @param from      the FROM waypoint
     * @param to        the TO waypoint
     * @param toIndex   index of the TO waypoint
     * @param segment   flight plan segment
     *
     * @private
     */
    static legFromWaypoints(prevLeg, nextLeg, from, to, toIndex, segment) {
      var _to$additionalData;
      if ((to === null || to === void 0 ? void 0 : (_to$additionalData = to.additionalData) === null || _to$additionalData === void 0 ? void 0 : _to$additionalData.legType) === LegType$1.IF) {
        const editableData = legMetadataFromMsfsWaypoint(to);
        if (prevLeg && prevLeg instanceof XFLeg && !prevLeg.fix.endsInDiscontinuity) {
          return new TFLeg(prevLeg.fix, to, editableData, segment);
        }
        return new IFLeg(to, editableData, segment);
      }
      if (!from || !to) {
        return null;
      }
      const metadata = legMetadataFromMsfsWaypoint(to);
      if (from.endsInDiscontinuity) {
        if ((to === null || to === void 0 ? void 0 : to.additionalData.legType) === LegType$1.CF || (to === null || to === void 0 ? void 0 : to.additionalData.legType) === LegType$1.TF) {
          return new IFLeg(to, metadata, segment);
        }
        return null;
      }
      if (to.additionalData) {
        var _to$additionalData2, _to$additionalData3, _to$additionalData4;
        if (to.additionalData.legType === LegType$1.AF) {
          return new AFLeg(to, to.additionalData.recommendedLocation, to.additionalData.rho, to.additionalData.thetaTrue, to.additionalData.course, metadata, segment);
        }
        if (to.additionalData.legType === LegType$1.CF) {
          return new CFLeg(to, to.additionalData.course, metadata, segment);
        }
        if (to.additionalData.legType === LegType$1.DF) {
          return new DFLeg(to, metadata, segment);
        }
        if (to.additionalData.legType === LegType$1.RF) {
          return new RFLeg(from, to, to.additionalData.center, metadata, segment);
        }

        // FIXME VALeg should be implemented to give proper heading guidance
        if (to.additionalData.legType === LegType$1.CA || to.additionalData.legType === LegType$1.VA) {
          var _from$additionalData$;
          const course = to.additionalData.course;
          const altitude = to.additionalData.vectorsAltitude;
          const extraLength = ((_from$additionalData$ = from.additionalData.runwayLength) !== null && _from$additionalData$ !== void 0 ? _from$additionalData$ : 0) / (2 * 1852);
          return new CALeg(course, altitude, metadata, segment, extraLength);
        }
        if (to.additionalData.legType === LegType$1.CI || to.additionalData.legType === LegType$1.VI) {
          if (!nextLeg) {
            return null;
          }
          const course = to.additionalData.course;
          return new CILeg(course, nextLeg, metadata, segment);
        }
        if (to.additionalData.legType === LegType$1.CR) {
          // TODO clean this whole thing up
          const course = to.additionalData.course;
          const radial = to.additionalData.thetaTrue;
          const theta = to.additionalData.theta;
          const ident = WayPoint.formatIdentFromIcao(to.additionalData.recommendedIcao);
          const originObj = {
            coordinates: to.additionalData.recommendedLocation,
            ident,
            theta
          };
          return new CRLeg(course, originObj, radial, metadata, segment);
        }
        if (((_to$additionalData2 = to.additionalData) === null || _to$additionalData2 === void 0 ? void 0 : _to$additionalData2.legType) === LegType$1.HA) {
          return new HALeg(to, metadata, segment);
        }
        if (((_to$additionalData3 = to.additionalData) === null || _to$additionalData3 === void 0 ? void 0 : _to$additionalData3.legType) === LegType$1.HF) {
          return new HFLeg(to, metadata, segment);
        }
        if (((_to$additionalData4 = to.additionalData) === null || _to$additionalData4 === void 0 ? void 0 : _to$additionalData4.legType) === LegType$1.HM) {
          return new HMLeg(to, metadata, segment);
        }
        if (to.additionalData.legType === LegType$1.PI) {
          return new PILeg(to, nextLeg, metadata, segment);
        }
      }
      if (to.isVectors) {
        return new VMLeg(to.additionalData.course, metadata, segment);
      }
      return new TFLeg(from, to, metadata, segment);
    }
    getLeg(prevLeg, nextLeg, index, flightPlanIndex) {
      const from = this.flightPlanManager.getWaypoint(index - 1, flightPlanIndex);
      const to = this.flightPlanManager.getWaypoint(index, flightPlanIndex);
      const segment = this.flightPlanManager.getSegmentFromWaypoint(to, flightPlanIndex).type;
      return GuidanceManager.legFromWaypoints(prevLeg, nextLeg, from, to, index, segment);
    }
    updateGeometry(geometry, flightPlanIndex, activeIdx, wptCount) {
      for (let i = activeIdx - 1; i < wptCount; i++) {
        const prevLeg = geometry.legs.get(i - 1);
        const oldLeg = geometry.legs.get(i);
        const nextLeg = this.getLeg(prevLeg, null, i + 1, flightPlanIndex);
        const newLeg = this.getLeg(prevLeg, nextLeg, i, flightPlanIndex);
        const legsMatch = (oldLeg === null || oldLeg === void 0 ? void 0 : oldLeg.repr) === (newLeg === null || newLeg === void 0 ? void 0 : newLeg.repr);
        if (legsMatch) {

          // Sync discontinuity info (FIXME until we have proper discontinuities)

          if (oldLeg instanceof XFLeg && newLeg instanceof XFLeg) {
            oldLeg.fix = newLeg.fix;
          }

          // Sync metadata

          if (oldLeg && newLeg) {
            oldLeg.metadata = _objectSpread2(_objectSpread2({}, oldLeg.metadata), newLeg.metadata);
          }
          const prevLeg = geometry.legs.get(i - 1);
          const oldInboundTransition = geometry.transitions.get(i - 1);
          const newInboundTransition = TransitionPicker.forLegs(prevLeg, newLeg);
          const transitionsMatch = (oldInboundTransition === null || oldInboundTransition === void 0 ? void 0 : oldInboundTransition.repr) === (newInboundTransition === null || newInboundTransition === void 0 ? void 0 : newInboundTransition.repr);
          if (!transitionsMatch) {
            geometry.transitions.set(i - 1, newInboundTransition);
          }
        } else {
          if (newLeg) {
            geometry.legs.set(i, newLeg);
            const prevLeg = geometry.legs.get(i - 1);
            const computeAllTransitions = LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1;
            if (prevLeg && (computeAllTransitions )) {
              const newInboundTransition = TransitionPicker.forLegs(prevLeg, newLeg);
              if (newInboundTransition) {
                geometry.transitions.set(i - 1, newInboundTransition);
              } else {
                geometry.transitions.delete(i - 1);
              }
            } else {
              geometry.transitions.delete(i - 1);
            }
          } else {
            geometry.legs.delete(i);
            geometry.transitions.delete(i - 1);
            geometry.transitions.delete(i);
          }
        }
      }

      // Trim geometry

      for (const [index] of geometry.legs.entries()) {
        const legBeforePrev = index < activeIdx - 1;
        const legAfterLastWpt = index >= wptCount;
        if (legBeforePrev || legAfterLastWpt) {
          geometry.legs.delete(index);
          geometry.transitions.delete(index - 1);
        }
      }
    }

    /**
     * The full leg path geometry, used for the ND and predictions on the F-PLN page.
     */
    getMultipleLegGeometry(temp) {
      if (temp) {
        if (this.flightPlanManager.getFlightPlan(1) === undefined) {
          return undefined;
        }
      }
      const activeIdx = temp ? this.flightPlanManager.getFlightPlan(1).activeWaypointIndex : this.flightPlanManager.getCurrentFlightPlan().activeWaypointIndex;
      const legs = new Map();
      const transitions = new Map();
      const wpCount = temp ? this.flightPlanManager.getFlightPlan(1).length : this.flightPlanManager.getCurrentFlightPlan().length;
      for (let i = activeIdx - 1; i < wpCount; i++) {
        // Leg
        const prevLeg = legs.get(i - 1);
        const nextLeg = this.getLeg(prevLeg, null, i + 1, temp ? FlightPlans.Temporary : FlightPlans.Active);
        const currentLeg = this.getLeg(prevLeg, nextLeg, i, temp ? FlightPlans.Temporary : FlightPlans.Active);
        if (currentLeg) {
          legs.set(i, currentLeg);
        }

        // Transition
        const transition = TransitionPicker.forLegs(prevLeg, currentLeg);
        if (transition) {
          transitions.set(i - 1, transition);
        }
      }
      return new Geometry(transitions, legs, temp);
    }
  }

  //  Copyright (c) 2021 FlyByWire Simulations
  //  SPDX-License-Identifier: GPL-3.0

  /**
   * Types that tie pseudo waypoints to sequencing actions
   */
  let PseudoWaypointSequencingAction = /*#__PURE__*/function (PseudoWaypointSequencingAction) {
    PseudoWaypointSequencingAction[PseudoWaypointSequencingAction["TOD_REACHED"] = 0] = "TOD_REACHED";
    PseudoWaypointSequencingAction[PseudoWaypointSequencingAction["APPROACH_PHASE_AUTO_ENGAGE"] = 1] = "APPROACH_PHASE_AUTO_ENGAGE";
    return PseudoWaypointSequencingAction;
  }({});

  // Copyright (c) 2021-2022 FlyByWire Simulations
  // Copyright (c) 2021-2022 Synaptic Simulations
  //
  // SPDX-License-Identifier: GPL-3.0

  let VnavDescentMode = /*#__PURE__*/function (VnavDescentMode) {
    VnavDescentMode[VnavDescentMode["NORMAL"] = 0] = "NORMAL";
    VnavDescentMode[VnavDescentMode["CDA"] = 1] = "CDA";
    VnavDescentMode[VnavDescentMode["DPO"] = 2] = "DPO";
    return VnavDescentMode;
  }({});
  const VnavConfig = {
    /**
     * VNAV descent calculation mode (NORMAL, CDA or DPO)
     */
    VNAV_DESCENT_MODE: VnavDescentMode.NORMAL,
    /**
     * Whether to emit CDA flap1/2 pseudo-waypoints (only if VNAV_DESCENT_MODE is CDA)
     */
    VNAV_EMIT_CDA_FLAP_PWP: false,
    /**
     * Whether to pring debug information and errors during the VNAV computation.
     */
    DEBUG_PROFILE: false,
    /**
     * Whether to use debug simvars (VNAV_DEBUG_*) to determine aircraft position and state.
     * This is useful for testing VNAV without having to fly the aircraft. This lets you put the aircraft some distance before destination at a given altitude and speed.
     * The following simvars can be used:
     * - A32NX_FM_VNAV_DEBUG_POINT: Indicates the distance from start (NM) at which to draw a debug pseudowaypoint on the ND
     * - A32NX_FM_VNAV_DEBUG_ALTITUDE: Indicates the indicated altitude (ft) VNAV uses for predictions
     * - A32NX_FM_VNAV_DEBUG_SPEED: Indicates the indicated airspeed (kts) VNAV uses for predictions
     * - A32NX_FM_VNAV_DEBUG_DISTANCE_TO_END: Indicates the distance (NM) to end VNAV uses for predictions
     */
    ALLOW_DEBUG_PARAMETER_INJECTION: false,
    VNAV_USE_LATCHED_DESCENT_MODE: false,
    /**
     * Percent N1 to add to the predicted idle N1. The real aircraft does also use a margin for this, but I don't know how much
     */
    IDLE_N1_MARGIN: 3,
    /**
     * VNAV needs to make an initial estimate of the fuel on board at destination to compute the descent path.
     * We don't want this figure to be too large as it might crash the predictions. So we clamp it to this value.
     * This value is in lbs.
     */
    MAXIMUM_FUEL_ESTIMATE: 40000
  };

  //  Copyright (c) 2021 FlyByWire Simulations
  //  SPDX-License-Identifier: GPL-3.0

  const rangeSettings = [10, 20, 40, 80, 160, 320];
  let EfisNdMode = /*#__PURE__*/function (EfisNdMode) {
    EfisNdMode[EfisNdMode["ROSE_ILS"] = 0] = "ROSE_ILS";
    EfisNdMode[EfisNdMode["ROSE_VOR"] = 1] = "ROSE_VOR";
    EfisNdMode[EfisNdMode["ROSE_NAV"] = 2] = "ROSE_NAV";
    EfisNdMode[EfisNdMode["ARC"] = 3] = "ARC";
    EfisNdMode[EfisNdMode["PLAN"] = 4] = "PLAN";
    return EfisNdMode;
  }({});
  let EfisOption = /*#__PURE__*/function (EfisOption) {
    EfisOption[EfisOption["None"] = 0] = "None";
    EfisOption[EfisOption["Constraints"] = 1] = "Constraints";
    EfisOption[EfisOption["VorDmes"] = 2] = "VorDmes";
    EfisOption[EfisOption["Waypoints"] = 3] = "Waypoints";
    EfisOption[EfisOption["Ndbs"] = 4] = "Ndbs";
    EfisOption[EfisOption["Airports"] = 5] = "Airports";
    return EfisOption;
  }({});
  let NdSymbolTypeFlags = /*#__PURE__*/function (NdSymbolTypeFlags) {
    NdSymbolTypeFlags[NdSymbolTypeFlags["Vor"] = 1] = "Vor";
    NdSymbolTypeFlags[NdSymbolTypeFlags["VorDme"] = 2] = "VorDme";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Ndb"] = 4] = "Ndb";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Waypoint"] = 8] = "Waypoint";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Airport"] = 16] = "Airport";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Runway"] = 32] = "Runway";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Tuned"] = 64] = "Tuned";
    NdSymbolTypeFlags[NdSymbolTypeFlags["ActiveLegTermination"] = 128] = "ActiveLegTermination";
    NdSymbolTypeFlags[NdSymbolTypeFlags["EfisOption"] = 256] = "EfisOption";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Dme"] = 512] = "Dme";
    NdSymbolTypeFlags[NdSymbolTypeFlags["Constraint"] = 1024] = "Constraint";
    NdSymbolTypeFlags[NdSymbolTypeFlags["FixInfo"] = 2048] = "FixInfo";
    NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlan"] = 4096] = "FlightPlan";
    NdSymbolTypeFlags[NdSymbolTypeFlags["CourseReversalLeft"] = 131072] = "CourseReversalLeft";
    NdSymbolTypeFlags[NdSymbolTypeFlags["CourseReversalRight"] = 262144] = "CourseReversalRight";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpDecel"] = 524288] = "PwpDecel";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpTopOfDescent"] = 1048576] = "PwpTopOfDescent";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpSpeedChange"] = 2097152] = "PwpSpeedChange";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpClimbLevelOff"] = 4194304] = "PwpClimbLevelOff";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpDescentLevelOff"] = 8388608] = "PwpDescentLevelOff";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpStartOfClimb"] = 16777216] = "PwpStartOfClimb";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpInterceptProfile"] = 33554432] = "PwpInterceptProfile";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpTimeMarker"] = 67108864] = "PwpTimeMarker";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpCdaFlap1"] = 134217728] = "PwpCdaFlap1";
    NdSymbolTypeFlags[NdSymbolTypeFlags["PwpCdaFlap2"] = 268435456] = "PwpCdaFlap2";
    NdSymbolTypeFlags[NdSymbolTypeFlags["CyanColor"] = 536870912] = "CyanColor";
    NdSymbolTypeFlags[NdSymbolTypeFlags["AmberColor"] = 1073741824] = "AmberColor";
    NdSymbolTypeFlags[NdSymbolTypeFlags["MagentaColor"] = -2147483648] = "MagentaColor";
    return NdSymbolTypeFlags;
  }({});
  /**
   * Possible flight plan vector groups to be transmitted to the ND.
   *
   * **NOTE:** this does not necessarily represent the current function of a transmitted flight plan. Those groups are sometimes used for other purposes than their name
   * refers to, for example the DASHED flight plan being used to transmit the non-offset path of an active flight plan with an offset applied.
   */
  let EfisVectorsGroup = /*#__PURE__*/function (EfisVectorsGroup) {
    EfisVectorsGroup[EfisVectorsGroup["ACTIVE"] = 0] = "ACTIVE";
    EfisVectorsGroup[EfisVectorsGroup["DASHED"] = 1] = "DASHED";
    EfisVectorsGroup[EfisVectorsGroup["OFFSET"] = 2] = "OFFSET";
    EfisVectorsGroup[EfisVectorsGroup["TEMPORARY"] = 3] = "TEMPORARY";
    EfisVectorsGroup[EfisVectorsGroup["SECONDARY"] = 4] = "SECONDARY";
    EfisVectorsGroup[EfisVectorsGroup["SECONDARY_DASHED"] = 5] = "SECONDARY_DASHED";
    EfisVectorsGroup[EfisVectorsGroup["MISSED"] = 6] = "MISSED";
    EfisVectorsGroup[EfisVectorsGroup["ALTERNATE"] = 7] = "ALTERNATE";
    EfisVectorsGroup[EfisVectorsGroup["ACTIVE_EOSID"] = 8] = "ACTIVE_EOSID";
    return EfisVectorsGroup;
  }({});

  let FlapConf = /*#__PURE__*/function (FlapConf) {
    FlapConf[FlapConf["CLEAN"] = 0] = "CLEAN";
    FlapConf[FlapConf["CONF_1"] = 1] = "CONF_1";
    FlapConf[FlapConf["CONF_2"] = 2] = "CONF_2";
    FlapConf[FlapConf["CONF_3"] = 3] = "CONF_3";
    FlapConf[FlapConf["CONF_FULL"] = 4] = "CONF_FULL";
    return FlapConf;
  }({});
  let AccelFactorMode = /*#__PURE__*/function (AccelFactorMode) {
    AccelFactorMode[AccelFactorMode["CONSTANT_CAS"] = 0] = "CONSTANT_CAS";
    AccelFactorMode[AccelFactorMode["CONSTANT_MACH"] = 1] = "CONSTANT_MACH";
    return AccelFactorMode;
  }({});
  class Common {
    /**
     * Calculates ISA temperature as a function of altitude
     * @param alt in feet
     * @param aboveTropo boolean
     * @returns ISA temperature in celsius
     */
    static getIsaTemp(alt) {
      let aboveTropo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (aboveTropo) {
        return -56.5;
      }
      return 15 - 0.0019812 * alt;
    }
    static getTemp(alt) {
      let isaDev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let aboveTropo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (aboveTropo) {
        return -56.5 + isaDev;
      }
      return 15 - 0.0019812 * alt + isaDev;
    }

    /**
     * Get temperature ratio for a particular altitude (below tropopause)
     * @param alt pressure altitude
     * @param isaDev ISA deviation in celsius
     * @param aboveTropo whether the aircraft is above the tropopause
     * @returns temperature ratio
     */
    static getTheta(alt) {
      let isaDev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let aboveTropo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (aboveTropo) {
        return (216.65 + isaDev) / 288.15;
      }
      return (288.15 - 0.0019812 * alt + isaDev) / 288.15;
    }

    /**
     * Get temperature ratio for a particular altitude and mach.
     * @param theta temperature ratio (from only altitude)
     * @param mach mach
     * @returns temperature ratio
     */
    static getTheta2(theta, mach) {
      return theta * (1 + 0.2 * mach ** 2);
    }

    /**
     * Get pressure ratio for a particular altitude
     * @param alt pressure altitude
     * @param aboveTropo whether the aircraft is above the tropopause
     * @returns pressure ratio
     */
    static getDelta(alt) {
      let aboveTropo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (aboveTropo && alt !== undefined) {
        return 0.22336 * Math.exp((36089.24 - alt) / 20805.7);
      }
      return this.getTheta(alt, 0, aboveTropo) ** 5.25588;
    }

    /**
     * Get pressure ratio for a particular theta and mach
     * @param delta pressure ratio (from only theta)
     * @param mach mach
     * @returns pressure ratio
     */
    static getDelta2(delta, mach) {
      return delta * (1 + 0.2 * mach ** 2) ** 3.5;
    }

    /**
     * Get KTAS value from mach
     * @param mach
     * @param theta
     * @returns speed in KTAS (knots true airspeed)
     */
    static machToTAS(mach, theta) {
      return 661.4786 * mach * Math.sqrt(theta);
    }
    static machToEAS(mach, delta) {
      return 661.4786 * mach * Math.sqrt(delta);
    }
    static CAStoMach(cas, delta) {
      const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
      const term2 = 1 / delta * (term1 ** 3.5 - 1);
      const term3 = 5 * ((term2 + 1) ** (1 / 3.5) - 1);
      return Math.sqrt(term3);
    }
    static machToCas(mach, delta) {
      const term1 = (0.2 * mach ** 2 + 1) ** 3.5;
      const term2 = (delta * (term1 - 1) + 1) ** (1 / 3.5) - 1;
      return 1479.1 * Math.sqrt(term2);
    }
    static TAStoCAS(tas, theta, delta) {
      const term1 = 1 + 1 / theta * (tas / 1479.1) ** 2;
      const term2 = delta * (term1 ** 3.5 - 1) + 1;
      const term3 = term2 ** (1 / 3.5) - 1;
      return 1479.1 * Math.sqrt(term3);
    }
    static CAStoTAS(cas, theta, delta) {
      const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
      const term2 = 1 / delta * (term1 ** 3.5 - 1);
      const term3 = theta * ((term2 + 1) ** (1 / 3.5) - 1);
      return 1479.1 * Math.sqrt(term3);
    }
    static CAStoEAS(cas, delta) {
      const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
      const term2 = 1 / delta * (term1 ** 3.5 - 1);
      const term3 = delta * ((term2 + 1) ** (1 / 3.5) - 1);
      return 1479.1 * Math.sqrt(term3);
    }
    static getAccelFactorCAS(mach, aboveTropo, tempRatio) {
      const phi = ((1 + 0.2 * mach ** 2) ** 3.5 - 1) / (0.7 * mach ** 2 * (1 + 0.2 * mach ** 2) ** 2.5);
      if (aboveTropo) {
        return 1 + 0.7 * mach ** 2 * phi;
      }
      return 1 + 0.7 * mach ** 2 * (phi - 0.190263 * tempRatio);
    }
    static getAccelFactorMach(mach, aboveTropo, tempRatio) {
      if (aboveTropo) {
        return 1;
      }
      return 1 - 0.13318 * mach ** 2 * tempRatio;
    }

    /**
     * Placeholder
     * @param mach
     * @param temp
     * @param stdTemp
     * @param aboveTropo
     * @param accelFactorMode
     * @returns
     */
    static getAccelerationFactor(mach, altitude, isaDev, aboveTropo, accelFactorMode) {
      // This is T_ISA / T, the ratio between ISA temperature at that altitude and the actual temperature at that altitude
      const tempRatio = (273.15 + this.getIsaTemp(altitude, aboveTropo)) / (273.15 + this.getTemp(altitude, isaDev, aboveTropo));
      if (accelFactorMode === AccelFactorMode.CONSTANT_CAS) {
        return Common.getAccelFactorCAS(mach, aboveTropo, tempRatio);
      }
      return Common.getAccelFactorMach(mach, aboveTropo, tempRatio);
    }
    static interpolate(x, x0, x1, y0, y1) {
      return (y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0);
    }
    static poundsToMetricTons(pounds) {
      return pounds / 2204.6;
    }
  }

  class BaseGeometryProfile {
    constructor() {
      _defineProperty(this, "isReadyToDisplay", false);
      _defineProperty(this, "checkpoints", []);
    }
    get lastCheckpoint() {
      if (this.checkpoints.length < 1) {
        return null;
      }
      return this.checkpoints[this.checkpoints.length - 1];
    }
    addCheckpointFromLast(checkpointBuilder) {
      this.checkpoints.push(_objectSpread2(_objectSpread2({}, this.lastCheckpoint), checkpointBuilder(this.lastCheckpoint)));
    }
    predictAtTime(secondsFromPresent) {
      const distanceFromStart = this.interpolateDistanceAtTime(secondsFromPresent);
      const {
        altitude,
        speed
      } = this.interpolateEverythingFromStart(distanceFromStart);
      return {
        distanceFromStart,
        altitude,
        speed,
        secondsFromPresent
      };
    }
    interpolateFromCheckpoints(indexValue, keySelector, valueSelector) {
      if (indexValue <= keySelector(this.checkpoints[0])) {
        return valueSelector(this.checkpoints[0]);
      }
      for (let i = 0; i < this.checkpoints.length - 1; i++) {
        if (indexValue > keySelector(this.checkpoints[i]) && indexValue <= keySelector(this.checkpoints[i + 1])) {
          return Common.interpolate(indexValue, keySelector(this.checkpoints[i]), keySelector(this.checkpoints[i + 1]), valueSelector(this.checkpoints[i]), valueSelector(this.checkpoints[i + 1]));
        }
      }
      return valueSelector(this.checkpoints[this.checkpoints.length - 1]);
    }
    interpolateFromCheckpointsBackwards(indexValue, keySelector, valueSelector) {
      let snapReverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (indexValue < keySelector(this.checkpoints[this.checkpoints.length - 1])) {
        return valueSelector(this.checkpoints[this.checkpoints.length - 1]);
      }
      for (let i = this.checkpoints.length - 2; i >= 0; i--) {
        if (!snapReverse && indexValue <= keySelector(this.checkpoints[i]) && indexValue > keySelector(this.checkpoints[i + 1]) || snapReverse && indexValue < keySelector(this.checkpoints[i]) && indexValue >= keySelector(this.checkpoints[i + 1])) {
          return Common.interpolate(indexValue, keySelector(this.checkpoints[i]), keySelector(this.checkpoints[i + 1]), valueSelector(this.checkpoints[i]), valueSelector(this.checkpoints[i + 1]));
        }
      }
      return valueSelector(this.checkpoints[0]);
    }

    /**
     * Find the time from start at which the profile predicts us to be at a distance along the flightplan.
     * @param distanceFromStart Distance along that path
     * @returns Predicted altitude
     */
    interpolateTimeAtDistance(distanceFromStart) {
      return this.interpolateFromCheckpoints(distanceFromStart, checkpoint => checkpoint.distanceFromStart, checkpoint => checkpoint.secondsFromPresent);
    }

    /**
     * Find the altitude at which the profile predicts us to be at a distance along the flightplan.
     * @param distanceFromStart Distance along that path
     * @returns Predicted altitude
     */
    interpolateAltitudeAtDistance(distanceFromStart) {
      return this.interpolateFromCheckpoints(distanceFromStart, checkpoint => checkpoint.distanceFromStart, checkpoint => checkpoint.altitude);
    }

    /**
     * Find the speed at which the profile predicts us to be at a distance along the flightplan.
     * @param distanceFromStart Distance along that path
     * @returns Predicted speed
     */
    interpolateSpeedAtDistance(distanceFromStart) {
      return this.interpolateFromCheckpoints(distanceFromStart, checkpoint => checkpoint.distanceFromStart, checkpoint => checkpoint.speed);
    }

    /**
     * Find the distanceFromStart at which the profile predicts us to be at a time since departure
     * @param secondsFromPresent Time since departure
     * @returns Predicted distance
     */
    interpolateDistanceAtTime(secondsFromPresent) {
      return this.interpolateFromCheckpoints(secondsFromPresent, checkpoint => checkpoint.secondsFromPresent, checkpoint => checkpoint.distanceFromStart);
    }
    interpolateEverythingFromStart(distanceFromStart) {
      let doInterpolateAltitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (distanceFromStart <= this.checkpoints[0].distanceFromStart) {
        return {
          distanceFromStart,
          secondsFromPresent: this.checkpoints[0].secondsFromPresent,
          altitude: this.checkpoints[0].altitude,
          remainingFuelOnBoard: this.checkpoints[0].remainingFuelOnBoard,
          speed: this.checkpoints[0].speed,
          mach: this.checkpoints[0].mach
        };
      }
      for (let i = 0; i < this.checkpoints.length - 1; i++) {
        if (distanceFromStart > this.checkpoints[i].distanceFromStart && distanceFromStart <= this.checkpoints[i + 1].distanceFromStart) {
          return {
            distanceFromStart,
            secondsFromPresent: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].secondsFromPresent, this.checkpoints[i + 1].secondsFromPresent),
            altitude: doInterpolateAltitude ? Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].altitude, this.checkpoints[i + 1].altitude) : this.checkpoints[i].altitude,
            remainingFuelOnBoard: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].remainingFuelOnBoard, this.checkpoints[i + 1].remainingFuelOnBoard),
            speed: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].speed, this.checkpoints[i + 1].speed),
            mach: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].mach, this.checkpoints[i + 1].mach)
          };
        }
      }
      return {
        distanceFromStart,
        secondsFromPresent: this.lastCheckpoint.secondsFromPresent,
        altitude: this.lastCheckpoint.altitude,
        remainingFuelOnBoard: this.lastCheckpoint.remainingFuelOnBoard,
        speed: this.lastCheckpoint.speed,
        mach: this.lastCheckpoint.mach
      };
    }
    interpolateDistanceAtAltitude(altitude) {
      return this.interpolateFromCheckpoints(altitude, checkpoint => checkpoint.altitude, checkpoint => checkpoint.distanceFromStart);
    }

    /**
     *
     * @param altitude Altitude to interpolate from
     * @param snapReverse True if we are looking for the first distance at which the altitude is reached or the last. (Think of a level segment)
     * @returns
     */
    interpolateDistanceAtAltitudeBackwards(altitude) {
      let snapReverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return this.interpolateFromCheckpointsBackwards(altitude, checkpoint => Math.round(checkpoint.altitude), checkpoint => checkpoint.distanceFromStart, snapReverse);
    }
    interpolateFuelAtDistance(distance) {
      return this.interpolateFromCheckpoints(distance, checkpoint => checkpoint.distanceFromStart, checkpoint => checkpoint.remainingFuelOnBoard);
    }
    interpolatePathAngleAtDistance(distanceFromStart) {
      if (distanceFromStart < this.checkpoints[0].distanceFromStart) {
        return 0;
      }
      for (let i = 0; i < this.checkpoints.length - 1; i++) {
        if (distanceFromStart > this.checkpoints[i].distanceFromStart && distanceFromStart <= this.checkpoints[i + 1].distanceFromStart) {
          return MathUtils$1.RADIANS_TO_DEGREES * Math.atan((this.checkpoints[i + 1].altitude - this.checkpoints[i].altitude) / (this.checkpoints[i + 1].distanceFromStart - this.checkpoints[i].distanceFromStart) / 6076.12);
        }
      }
      return 0;
    }

    /**
     * Find first checkpoint with a reason
     * @param reasons The reasons to look for
     * @returns The first checkpoint with a reason
     */
    findVerticalCheckpoint() {
      for (var _len = arguments.length, reasons = new Array(_len), _key = 0; _key < _len; _key++) {
        reasons[_key] = arguments[_key];
      }
      return this.checkpoints.find(checkpoint => reasons.includes(checkpoint.reason));
    }
    findLastVerticalCheckpoint() {
      for (var _len2 = arguments.length, reasons = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        reasons[_key2] = arguments[_key2];
      }
      return [...this.checkpoints].reverse().find(checkpoint => reasons.includes(checkpoint.reason));
    }
    findLastVerticalCheckpointIndex() {
      for (var _len3 = arguments.length, reasons = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        reasons[_key3] = arguments[_key3];
      }
      return findLastIndex(this.checkpoints, _ref => {
        let {
          reason
        } = _ref;
        return reasons.includes(reason);
      });
    }
    purgeVerticalCheckpoints(reason) {
      this.checkpoints = this.checkpoints.filter(checkpoint => checkpoint.reason !== reason);
    }
    addInterpolatedCheckpoint(distanceFromStart, additionalProperties) {
      if (distanceFromStart <= this.checkpoints[0].distanceFromStart) {
        this.checkpoints.unshift(_objectSpread2({
          distanceFromStart,
          secondsFromPresent: this.checkpoints[0].secondsFromPresent,
          altitude: this.checkpoints[0].altitude,
          remainingFuelOnBoard: this.checkpoints[0].remainingFuelOnBoard,
          speed: this.checkpoints[0].speed,
          mach: this.checkpoints[0].mach
        }, additionalProperties));
        return this.checkpoints[0];
      }
      for (let i = 0; i < this.checkpoints.length - 1; i++) {
        if (distanceFromStart > this.checkpoints[i].distanceFromStart && distanceFromStart <= this.checkpoints[i + 1].distanceFromStart) {
          this.checkpoints.splice(i + 1, 0, _objectSpread2({
            distanceFromStart,
            secondsFromPresent: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].secondsFromPresent, this.checkpoints[i + 1].secondsFromPresent),
            altitude: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].altitude, this.checkpoints[i + 1].altitude),
            remainingFuelOnBoard: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].remainingFuelOnBoard, this.checkpoints[i + 1].remainingFuelOnBoard),
            speed: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].speed, this.checkpoints[i + 1].speed),
            mach: Common.interpolate(distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i + 1].distanceFromStart, this.checkpoints[i].mach, this.checkpoints[i + 1].mach)
          }, additionalProperties));
          return this.checkpoints[i + 1];
        }
      }
      this.checkpoints.push(_objectSpread2({
        distanceFromStart,
        secondsFromPresent: this.lastCheckpoint.secondsFromPresent,
        altitude: this.lastCheckpoint.altitude,
        remainingFuelOnBoard: this.lastCheckpoint.remainingFuelOnBoard,
        speed: this.lastCheckpoint.speed,
        mach: this.lastCheckpoint.mach
      }, additionalProperties));
      return this.lastCheckpoint;
    }
    addCheckpointAtDistanceFromStart(distanceFromStart) {
      for (var _len4 = arguments.length, checkpoints = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        checkpoints[_key4 - 1] = arguments[_key4];
      }
      if (distanceFromStart <= this.checkpoints[0].distanceFromStart) {
        this.checkpoints.unshift(...checkpoints);
        return;
      }
      for (let i = 0; i < this.checkpoints.length - 1; i++) {
        if (distanceFromStart > this.checkpoints[i].distanceFromStart && distanceFromStart <= this.checkpoints[i + 1].distanceFromStart) {
          this.checkpoints.splice(i + 1, 0, ...checkpoints);
          return;
        }
      }
      this.checkpoints.push(...checkpoints);
    }
    sortCheckpoints() {
      this.checkpoints.sort((a, b) => a.distanceFromStart - b.distanceFromStart);
    }
    finalizeProfile() {
      this.sortCheckpoints();
      this.isReadyToDisplay = true;
    }
    computePredictionToFcuAltitude(fcuAltitude) {
      const maxAltitude = this.checkpoints.reduce((currentMax, checkpoint) => Math.max(currentMax, checkpoint.altitude), 0);
      if (fcuAltitude < this.checkpoints[0].altitude || fcuAltitude > maxAltitude) {
        return undefined;
      }
      const distanceToFcuAltitude = this.interpolateFromCheckpoints(fcuAltitude, checkpoint => checkpoint.altitude, checkpoint => checkpoint.distanceFromStart);
      const timeToFcuAltitude = this.interpolateTimeAtDistance(distanceToFcuAltitude);
      return {
        altitude: fcuAltitude,
        distanceFromStart: distanceToFcuAltitude,
        secondsFromPresent: timeToFcuAltitude
      };
    }
    addPresentPositionCheckpoint(presentPosition, remainingFuelOnBoard, mach, vman) {
      this.checkpoints.push({
        reason: VerticalCheckpointReason.PresentPosition,
        distanceFromStart: this.distanceToPresentPosition,
        secondsFromPresent: 0,
        altitude: presentPosition.alt,
        remainingFuelOnBoard,
        speed: Math.max(SimVar.GetSimVarValue('AIRSPEED INDICATED', 'knots'), vman),
        // Note that the `mach` field here is usually not the Mach number that the aircraft is predicted to travel, but rather the Mach number
        // at which the speed target would change to be a Mach number.
        mach
      });
    }
    getRemainingFuelAtDestination() {
      if (this.checkpoints.length < 1) {
        return null;
      }
      if (this.lastCheckpoint.reason !== VerticalCheckpointReason.Landing) {
        return null;
      }
      return this.lastCheckpoint.remainingFuelOnBoard;
    }
    getTimeToDestination() {
      if (this.checkpoints.length < 1) {
        return null;
      }
      if (this.lastCheckpoint.reason !== VerticalCheckpointReason.Landing) {
        return null;
      }
      return this.lastCheckpoint.secondsFromPresent;
    }
  }
  function findLastIndex(array, predicate) {
    let l = array.length;
    while (l--) {
      if (predicate(array[l], l, array)) {
        return l;
      }
    }
    return -1;
  }

  let ManagedSpeedType = /*#__PURE__*/function (ManagedSpeedType) {
    ManagedSpeedType[ManagedSpeedType["Climb"] = 0] = "Climb";
    ManagedSpeedType[ManagedSpeedType["Cruise"] = 1] = "Cruise";
    ManagedSpeedType[ManagedSpeedType["Descent"] = 2] = "Descent";
    return ManagedSpeedType;
  }({});
  function constraintToSpeed(constraint) {
    var _constraint$maxSpeed;
    return (_constraint$maxSpeed = constraint === null || constraint === void 0 ? void 0 : constraint.maxSpeed) !== null && _constraint$maxSpeed !== void 0 ? _constraint$maxSpeed : Infinity;
  }

  /**
   * This class's purpose is to provide a predicted speed at a given position and altitude.
   */
  class McduSpeedProfile {
    /**
     *
     * @param parameters
     * @param aircraftDistanceAlongTrack
     * @param climbSpeedConstraints - This should be sorted in increasing distance along track
     * @param descentSpeedConstraints - This should be sorted in increasing distance along track
     */
    constructor(parameters, aircraftDistanceAlongTrack, climbSpeedConstraints, descentSpeedConstraints) {
      this.parameters = parameters;
      this.aircraftDistanceAlongTrack = aircraftDistanceAlongTrack;
      this.climbSpeedConstraints = climbSpeedConstraints;
      this.descentSpeedConstraints = descentSpeedConstraints;
    }
    isValidSpeedLimit(speedLimit) {
      if (!speedLimit) {
        return false;
      }
      const {
        speed,
        underAltitude
      } = speedLimit;
      return Number.isFinite(speed) && Number.isFinite(underAltitude);
    }
    update(aircraftDistanceAlongTrack) {
      this.aircraftDistanceAlongTrack = aircraftDistanceAlongTrack;
    }
    getTarget(distanceFromStart, altitude, managedSpeedType) {
      const {
        fcuSpeed,
        flightPhase,
        preselectedClbSpeed,
        preselectedCruiseSpeed,
        preselectedDescentSpeed
      } = this.parameters.get();
      let preselectedSpeed = -1;
      if (flightPhase < FmgcFlightPhase.Climb && preselectedClbSpeed > 100) {
        preselectedSpeed = preselectedClbSpeed;
      } else if (flightPhase < FmgcFlightPhase.Cruise && preselectedCruiseSpeed > 100) {
        preselectedSpeed = preselectedCruiseSpeed;
      } else if (flightPhase < FmgcFlightPhase.Descent && preselectedDescentSpeed > 100) {
        preselectedSpeed = preselectedDescentSpeed;
      }
      const hasPreselectedSpeed = preselectedSpeed > 0;
      const isPredictingForCurrentPhase = managedSpeedType === ManagedSpeedType.Climb && flightPhase === FmgcFlightPhase.Climb || managedSpeedType === ManagedSpeedType.Cruise && flightPhase === FmgcFlightPhase.Cruise || managedSpeedType === ManagedSpeedType.Descent && (flightPhase === FmgcFlightPhase.Descent || flightPhase === FmgcFlightPhase.Approach);

      // In the descent, the MCDU assumes an immediate return to managed speed, and selecting a speed should not affect the profile
      const hasSelectedSpeed = fcuSpeed > 100 && isPredictingForCurrentPhase;
      if (!hasPreselectedSpeed && !hasSelectedSpeed) {
        return this.getManagedTarget(distanceFromStart, altitude, managedSpeedType);
      }
      const nextSpeedChange = this.findDistanceAlongTrackOfNextSpeedChange(this.aircraftDistanceAlongTrack);
      if (distanceFromStart > nextSpeedChange) {
        return this.getManagedTarget(distanceFromStart, altitude, managedSpeedType);
      }
      if (hasPreselectedSpeed) {
        return preselectedSpeed;
      }
      return fcuSpeed;
    }
    getTargetWithoutConstraints(altitude, managedSpeedType) {
      let managedSpeed = this.getManagedSpeedForType(managedSpeedType);
      const {
        climbSpeedLimit,
        descentSpeedLimit
      } = this.parameters.get();
      if (managedSpeedType === ManagedSpeedType.Climb || managedSpeedType === ManagedSpeedType.Cruise) {
        if (this.shouldTakeClimbSpeedLimitIntoAccount() && altitude < climbSpeedLimit.underAltitude) {
          managedSpeed = Math.min(climbSpeedLimit.speed, managedSpeed);
        }
      } else if (this.shouldTakeDescentSpeedLimitIntoAccount() && altitude < descentSpeedLimit.underAltitude) {
        managedSpeed = Math.min(descentSpeedLimit.speed, managedSpeed);
      }
      return managedSpeed;
    }
    getManagedTarget(distanceFromStart, altitude, managedSpeedType) {
      const constraintSpeed = constraintToSpeed(managedSpeedType === ManagedSpeedType.Climb || managedSpeedType === ManagedSpeedType.Cruise ? this.getMaxClimbSpeedConstraint(distanceFromStart) : this.getMaxDescentSpeedConstraint(distanceFromStart));
      return Math.min(this.getTargetWithoutConstraints(altitude, managedSpeedType), constraintSpeed);
    }
    getMaxClimbSpeedConstraint(distanceAlongTrack) {
      let activeConstraint = null;
      for (const constraint of this.climbSpeedConstraints) {
        if (distanceAlongTrack < constraint.distanceFromStart && constraint.maxSpeed < constraintToSpeed(activeConstraint)) {
          activeConstraint = constraint;
        }
      }
      return activeConstraint;
    }
    getMaxDescentSpeedConstraint(distanceAlongTrack) {
      let activeConstraint = null;
      for (const constraint of this.descentSpeedConstraints) {
        if (constraint.maxSpeed >= constraintToSpeed(activeConstraint)) {
          continue;
        }

        // Since the constraint are ordered, there is no need to search further
        if (distanceAlongTrack < constraint.distanceFromStart) {
          return activeConstraint;
        }
        activeConstraint = constraint;
      }
      return activeConstraint;
    }

    /**
     * This is used to figure out where predictions should assume managed speed again while being in selected.
     * @param distanceAlongTrack
     * @returns
     */
    findDistanceAlongTrackOfNextSpeedChange(distanceAlongTrack) {
      let distance = Infinity;
      for (const constraint of this.climbSpeedConstraints) {
        if (distanceAlongTrack <= constraint.distanceFromStart && constraint.distanceFromStart < distance) {
          distance = constraint.distanceFromStart;
        }
      }

      // TODO: Handle speed limit

      return distance;
    }
    shouldTakeClimbSpeedLimitIntoAccount() {
      return this.isValidSpeedLimit(this.parameters.get().climbSpeedLimit);
    }
    shouldTakeDescentSpeedLimitIntoAccount() {
      return this.isValidSpeedLimit(this.parameters.get().descentSpeedLimit);
    }
    getManagedSpeedForType(managedSpeedType) {
      const {
        managedClimbSpeed,
        managedCruiseSpeed,
        managedDescentSpeed
      } = this.parameters.get();
      switch (managedSpeedType) {
        case ManagedSpeedType.Climb:
          return managedClimbSpeed;
        case ManagedSpeedType.Cruise:
          return managedCruiseSpeed;
        case ManagedSpeedType.Descent:
          return managedDescentSpeed;
        default:
          throw new Error("[FMS/VNAV] Invalid managedSpeedType: ".concat(managedSpeedType));
      }
    }
  }
  class ExpediteSpeedProfile {
    constructor(greenDotSpeed) {
      this.greenDotSpeed = greenDotSpeed;
    }
    getTarget(_distanceFromStart, _altitude) {
      return this.greenDotSpeed;
    }
    getTargetWithoutConstraints(_altitude, _managedSpeedType) {
      return this.greenDotSpeed;
    }
    getCurrentSpeedTarget() {
      return Infinity;
    }
    shouldTakeClimbSpeedLimitIntoAccount() {
      return false;
    }
    shouldTakeDescentSpeedLimitIntoAccount() {
      return false;
    }
    getMaxClimbSpeedConstraint(_distanceFromStart) {
      return null;
    }
    getMaxDescentSpeedConstraint(_distanceFromStart) {
      return null;
    }
  }

  /**
   * The NdSpeedProfile is different from the MCDU speed profile because it assumes a selected speed is
   * held until the end of the flight phase rather than only until the next speed constraint
   */
  class NdSpeedProfile {
    constructor(parameters, aircraftDistanceAlongTrack, maxSpeedConstraints, descentSpeedConstraints) {
      this.parameters = parameters;
      this.aircraftDistanceAlongTrack = aircraftDistanceAlongTrack;
      this.maxSpeedConstraints = maxSpeedConstraints;
      this.descentSpeedConstraints = descentSpeedConstraints;
      _defineProperty(this, "maxSpeedCacheHits", 0);
      _defineProperty(this, "maxSpeedLookups", 0);
      _defineProperty(this, "maxSpeedCache", new Map());
    }
    isValidSpeedLimit(speedLimit) {
      if (!speedLimit) {
        return false;
      }
      const {
        speed,
        underAltitude
      } = speedLimit;
      return Number.isFinite(speed) && Number.isFinite(underAltitude);
    }
    getTarget(distanceFromStart, altitude, managedSpeedType) {
      const {
        fcuSpeed,
        flightPhase,
        preselectedClbSpeed
      } = this.parameters.get();
      const hasPreselectedSpeed = flightPhase < FmgcFlightPhase.Climb && preselectedClbSpeed > 1;
      const hasSelectedSpeed = fcuSpeed > 100 && flightPhase > FmgcFlightPhase.Takeoff;
      if (hasPreselectedSpeed) {
        return preselectedClbSpeed;
      }
      if (hasSelectedSpeed) {
        return fcuSpeed;
      }
      return this.getManaged(distanceFromStart, altitude, managedSpeedType);
    }
    getTargetWithoutConstraints(altitude, managedSpeedType) {
      let managedSpeed = this.getManagedSpeedForType(managedSpeedType);
      const {
        climbSpeedLimit,
        descentSpeedLimit
      } = this.parameters.get();
      if (managedSpeedType === ManagedSpeedType.Climb || managedSpeedType === ManagedSpeedType.Cruise) {
        if (this.shouldTakeClimbSpeedLimitIntoAccount() && altitude < climbSpeedLimit.underAltitude) {
          managedSpeed = Math.min(climbSpeedLimit.speed, managedSpeed);
        }
      } else if (this.shouldTakeDescentSpeedLimitIntoAccount() && altitude < descentSpeedLimit.underAltitude) {
        managedSpeed = Math.min(descentSpeedLimit.speed, managedSpeed);
      }
      return managedSpeed;
    }
    getManaged(distanceFromStart, altitude, managedSpeedType) {
      let managedSpeed = this.getManagedSpeedForType(managedSpeedType);
      const {
        climbSpeedLimit,
        descentSpeedLimit
      } = this.parameters.get();
      if (managedSpeedType === ManagedSpeedType.Climb || managedSpeedType === ManagedSpeedType.Cruise) {
        if (this.shouldTakeClimbSpeedLimitIntoAccount() && altitude < climbSpeedLimit.underAltitude) {
          managedSpeed = Math.min(climbSpeedLimit.speed, managedSpeed);
        }
      } else if (this.shouldTakeDescentSpeedLimitIntoAccount() && altitude < descentSpeedLimit.underAltitude) {
        managedSpeed = Math.min(descentSpeedLimit.speed, managedSpeed);
      }
      return Math.min(managedSpeed, this.findMaxSpeedAtDistanceAlongTrack(distanceFromStart));
    }
    getCurrentSpeedTarget() {
      return this.findMaxSpeedAtDistanceAlongTrack(this.aircraftDistanceAlongTrack);
    }
    isSelectedSpeed() {
      const {
        fcuSpeed,
        flightPhase,
        preselectedClbSpeed
      } = this.parameters.get();
      const hasPreselectedSpeed = flightPhase < FmgcFlightPhase.Climb && preselectedClbSpeed > 1;
      const hasSelectedSpeed = fcuSpeed > 100 && flightPhase > FmgcFlightPhase.Takeoff;
      return hasSelectedSpeed || hasPreselectedSpeed;
    }
    findMaxSpeedAtDistanceAlongTrack(distanceAlongTrack) {
      this.maxSpeedLookups++;
      const cachedMaxSpeed = this.maxSpeedCache.get(distanceAlongTrack);
      if (cachedMaxSpeed) {
        this.maxSpeedCacheHits++;
        return cachedMaxSpeed;
      }
      const maxSpeed = Math.min(constraintToSpeed(this.getMaxClimbSpeedConstraint(distanceAlongTrack)), constraintToSpeed(this.findMaxDescentSpeedConstraint(distanceAlongTrack)));
      this.maxSpeedCache.set(distanceAlongTrack, maxSpeed);
      return maxSpeed;
    }
    getMaxClimbSpeedConstraint(distanceAlongTrack) {
      let activeConstraint = null;
      for (const constraint of this.maxSpeedConstraints) {
        if (distanceAlongTrack < constraint.distanceFromStart && constraint.maxSpeed < constraintToSpeed(activeConstraint)) {
          activeConstraint = constraint;
        }
      }
      return activeConstraint;
    }
    getMaxDescentSpeedConstraint(distanceAlongTrack) {
      let activeConstraint = null;

      // TODO: I think this is unnecessarily complex, we can probably just return the first constraint that is in front of us.
      for (const constraint of this.descentSpeedConstraints) {
        // Since the constraint are ordered, there is no need to search further
        if (distanceAlongTrack < constraint.distanceFromStart) {
          return activeConstraint;
        }
        activeConstraint = constraint;
      }
      return activeConstraint;
    }
    findMaxDescentSpeedConstraint(distanceAlongTrack) {
      let activeConstraint = null;

      // TODO: I think this is unnecessarily complex, we can probably just return the first constraint that is in front of us.
      for (const constraint of this.descentSpeedConstraints) {
        // Since the constraint are ordered, there is no need to search further
        if (distanceAlongTrack < constraint.distanceFromStart) {
          return activeConstraint;
        }
        activeConstraint = constraint;
      }
      return activeConstraint;
    }
    showDebugStats() {
      if (this.maxSpeedLookups === 0) {
        console.log('[FMS/VNAV] No max speed lookups done so far.');
        return;
      }
      console.log("[FMS/VNAV] Performed ".concat(this.maxSpeedLookups, " max speed lookups. Of which ").concat(this.maxSpeedCacheHits, " (").concat(100 * this.maxSpeedCacheHits / this.maxSpeedLookups, "%) had been cached"));
    }
    shouldTakeClimbSpeedLimitIntoAccount() {
      return this.isValidSpeedLimit(this.parameters.get().climbSpeedLimit) && !this.isSelectedSpeed();
    }
    shouldTakeDescentSpeedLimitIntoAccount() {
      return this.isValidSpeedLimit(this.parameters.get().descentSpeedLimit) && !this.isSelectedSpeed();
    }
    getManagedSpeedForType(managedSpeedType) {
      const {
        managedClimbSpeed,
        managedCruiseSpeed,
        managedDescentSpeed
      } = this.parameters.get();
      switch (managedSpeedType) {
        case ManagedSpeedType.Climb:
          return managedClimbSpeed;
        case ManagedSpeedType.Cruise:
          return managedCruiseSpeed;
        case ManagedSpeedType.Descent:
          return managedDescentSpeed;
        default:
          throw new Error("[FMS/VNAV] Invalid managedSpeedType: ".concat(managedSpeedType));
      }
    }
  }

  class EngineModel {
    /**
     * Placeholder
     * @param table
     * @param i
     * @param j
     * @returns
     */
    static tableInterpolation(table, i, j) {
      const numRows = table.length;
      const numCols = table[0].length;
      // Iterate through rows to find the upper bound to i
      let r;
      for (r = 1; r < numRows; r++) {
        if (table[r][0] > i) {
          break;
        }
      }
      // Get lower bound to i
      const r1 = Math.max(1, r - 1);
      const r2 = Math.min(numRows - 1, r);
      // Iterate through rows to find the upper bound to j
      let c;
      for (c = 1; c < numCols; c++) {
        if (table[0][c] > j) {
          break;
        }
      }
      // Get the lower bound to j
      const c1 = Math.max(1, c - 1);
      const c2 = Math.min(numCols - 1, c);
      const interpolatedRowAtC1 = r1 === r2 ? table[r1][c1] : Common.interpolate(i, table[r1][0], table[r2][0], table[r1][c1], table[r2][c1]);
      const interpolatedRowAtC2 = r1 === r2 ? table[r1][c2] : Common.interpolate(i, table[r1][0], table[r2][0], table[r1][c2], table[r2][c2]);
      if (c1 === c2) {
        return interpolatedRowAtC1;
      }
      return Common.interpolate(j, table[0][c1], table[0][c2], interpolatedRowAtC1, interpolatedRowAtC2);
    }

    /**
     * Retrieve a bilinear interpolated row value from a table
     * @param table
     * @param j Value on column axis
     * @param result Value normally returned as result
     */
    static reverseTableInterpolation(table, j, result) {
      const numRows = table.length;
      const numCols = table[0].length;
      let c;
      for (c = 1; c < numCols; c++) {
        if (table[0][c] > j) {
          break;
        }
      }
      const c1 = Math.max(1, c - 1);
      const c2 = Math.min(numCols - 1, c);
      let r;
      for (r = 1; r < numRows; r++) {
        if (table[r][c1] > result) {
          break;
        }
      }
      const r1 = Math.max(1, r - 1);
      const r2 = Math.min(numRows - 1, r);
      for (r = 1; r < numRows; r++) {
        if (table[r][c2] > result) {
          break;
        }
      }
      const r3 = Math.max(1, r - 1);
      const r4 = Math.min(numRows - 1, r);
      const interpolatedRowAtC1 = r1 === r2 ? table[r1][0] : Common.interpolate(result, table[r1][c1], table[r2][c1], table[r1][0], table[r2][0]);
      const interpolatedRowAtC2 = r3 === r4 ? table[r3][0] : Common.interpolate(result, table[r3][c2], table[r4][c2], table[r3][0], table[r4][0]);
      return Common.interpolate(j, table[0][c1], table[0][c2], interpolatedRowAtC1, interpolatedRowAtC2);
    }

    /**
     * Placeholder
     * @param cn1 corrected N1 %
     * @param mach mach value
     * @param alt altitude in feet
     * @returns fuel flow, in pounds per hour (per engine)
     */
    static getCorrectedFuelFlow(cn1, mach, alt) {
      const coefficients = [-639.6602981, 0.00000e+00, 1.03705e+02, -2.23264e+03, 5.70316e-03, -2.29404e+00, 1.08230e+02, 2.77667e-04, -6.17180e+02, -7.20713e-02, 2.19013e-07, 2.49418e-02, -7.31662e-01, -1.00003e-05, -3.79466e+01, 1.34552e-03, 5.72612e-09, -2.71950e+02, 8.58469e-02, -2.72912e-06, 2.02928e-11];
      const flow = coefficients[0] + coefficients[1] + coefficients[2] * cn1 + coefficients[3] * mach + coefficients[4] * alt + coefficients[5] * cn1 ** 2 + coefficients[6] * cn1 * mach + coefficients[7] * cn1 * alt + coefficients[8] * mach ** 2 + coefficients[9] * mach * alt + coefficients[10] * alt ** 2 + coefficients[11] * cn1 ** 3 + coefficients[12] * cn1 ** 2 * mach + coefficients[13] * cn1 ** 2 * alt + coefficients[14] * cn1 * mach ** 2 + coefficients[15] * cn1 * mach * alt + coefficients[16] * cn1 * alt ** 2 + coefficients[17] * mach ** 3 + coefficients[18] * mach ** 2 * alt + coefficients[19] * mach * alt ** 2 + coefficients[20] * alt ** 3;
      return flow;
    }

    // static getCN1fromUncorrectedThrust(thrust: number)

    static getCorrectedN1(n1, theta2) {
      return n1 / Math.sqrt(theta2);
    }
    static getUncorrectedN1(cn1, theta2) {
      return cn1 * Math.sqrt(theta2);
    }
    static getUncorrectedN2(cn2, theta2) {
      return cn2 * Math.sqrt(theta2);
    }
    static getUncorrectedThrust(correctedThrust, delta2) {
      return correctedThrust * delta2;
    }
    static getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) {
      return correctedFuelFlow * delta2 * Math.sqrt(theta2);
    }
    static getCorrectedThrust(uncorrectedThrust, delta2) {
      return uncorrectedThrust / delta2;
    }
    static getIdleN1(altitude, mach, tropoAltitude) {
      const delta = Common.getDelta(altitude, altitude > tropoAltitude);
      const iap = 1 / delta;
      const theta = Common.getTheta(altitude, 0, altitude > tropoAltitude);
      const theta2 = Common.getTheta2(theta, mach);
      const lowMachCn2 = EngineModel.tableInterpolation(EngineModel.table1503, 0, iap);
      const highMachCn2 = EngineModel.tableInterpolation(EngineModel.table1504, 0, iap);
      const cn2 = Common.interpolate(mach, 0, 0.9, lowMachCn2, highMachCn2);
      const cn1 = EngineModel.tableInterpolation(EngineModel.table1502, cn2, mach);
      const n1 = cn1 * Math.sqrt(theta2);
      return n1;
    }
  }
  // In pounds of force. Used as a multiplier for results of table 1506
  _defineProperty(EngineModel, "maxThrust", 27120);
  /**
   * Maximum N1 in CLB thrust
   * @param i row index (tat) in steps of 4C
   * @param j col index (pressure altitude)
   * @returns Corrected N1 (CN1)
   */
  _defineProperty(EngineModel, "maxClimbThrustTableLeap", [[0, 2000, 5000, 8000, 12000, 15000, 17000, 20000, 24000, 27000, 31000, 35000, 39000, 41500], [-54.0, 71.8, 73.6, 75.5, 76.8, 78.1, 78.9, 80.1, 81.5, 81.6, 83.0, 83.6, 83.7, 83.3], [-50.0, 72.5, 74.3, 76.2, 77.5, 78.8, 79.6, 80.9, 82.2, 82.4, 83.8, 84.4, 84.5, 84.0], [-46.0, 73.1, 75.0, 76.9, 78.2, 79.5, 80.3, 81.6, 83.0, 83.1, 84.5, 85.1, 85.3, 84.8], [-42.0, 73.8, 75.6, 77.6, 78.9, 80.2, 81.0, 82.3, 83.7, 83.8, 85.3, 85.9, 86.0, 85.5], [-38.0, 74.4, 76.3, 78.2, 79.6, 80.9, 81.7, 83.0, 84.4, 84.6, 86.0, 86.6, 86.7, 86.3], [-34.0, 75.0, 76.9, 78.9, 80.3, 81.6, 82.4, 83.7, 85.1, 85.3, 86.7, 87.3, 87.5, 87.0], [-30.0, 75.7, 77.6, 79.6, 80.9, 82.2, 83.1, 84.4, 85.8, 86.0, 87.5, 88.1, 88.2, 87.7], [-26.0, 76.3, 78.2, 80.2, 81.6, 82.9, 83.8, 85.1, 86.5, 86.7, 88.2, 88.8, 88.9, 88.4], [-22.0, 76.9, 78.8, 80.9, 82.2, 83.6, 84.4, 85.8, 87.2, 87.4, 88.9, 89.5, 89.6, 89.1], [-18.0, 77.5, 79.5, 81.5, 82.9, 84.2, 85.1, 86.5, 87.9, 88.1, 89.6, 90.2, 90.0, 89.5], [-14.0, 78.1, 80.1, 82.1, 83.5, 84.9, 85.8, 87.1, 88.6, 88.8, 90.3, 90.0, 89.2, 88.7], [-10.0, 78.7, 80.7, 82.8, 84.2, 85.6, 86.4, 87.8, 89.3, 89.5, 91.0, 89.2, 88.4, 87.9], [-6.0, 79.3, 81.3, 83.4, 84.8, 86.2, 87.1, 88.5, 90.0, 90.1, 91.1, 88.5, 87.7, 87.1], [-2.0, 79.9, 81.9, 84.0, 85.5, 86.8, 87.7, 89.1, 90.6, 90.8, 90.2, 87.7, 86.9, 86.4], [2.0, 80.5, 82.5, 84.6, 86.1, 87.5, 88.4, 89.8, 91.3, 90.3, 89.5, 87.0, 86.2, 85.6], [6.0, 81.1, 83.1, 85.3, 86.7, 88.1, 89.0, 90.4, 90.5, 89.5, 88.8, 86.3, 85.5, 84.9], [10.0, 81.6, 83.7, 85.9, 87.3, 88.7, 89.7, 90.0, 89.6, 88.7, 88.1, 85.6, 84.8, 84.2], [14.0, 82.2, 84.3, 86.5, 87.9, 89.4, 89.3, 89.1, 88.7, 87.9, 87.5, 84.8, 83.9, 83.3], [18.0, 82.8, 84.9, 87.1, 88.5, 88.6, 88.4, 88.3, 87.9, 87.2, 86.8, 86.8, 86.8, 86.8], [22.0, 83.4, 85.5, 86.9, 88.0, 87.8, 87.7, 87.5, 87.2, 86.5, 86.1, 86.1, 86.1, 86.1], [26.0, 83.9, 85.7, 86.2, 87.2, 87.1, 87.0, 86.8, 86.5, 85.8, 85.4, 85.4, 85.4, 85.4], [30.0, 84.5, 84.9, 85.4, 86.5, 86.4, 86.3, 86.1, 85.8, 85.1, 85.1, 85.1, 85.1, 85.1], [34.0, 83.8, 84.2, 84.7, 85.8, 85.7, 85.6, 85.5, 85.1, 85.1, 85.1, 85.1, 85.1, 85.1], [38.0, 83.0, 83.4, 83.9, 85.1, 85.0, 84.9, 84.8, 84.8, 84.8, 84.8, 84.8, 84.8, 84.8], [42.0, 82.2, 82.6, 83.1, 84.4, 84.4, 84.3, 84.3, 84.3, 84.3, 84.3, 84.3, 84.3, 84.3], [46.0, 81.4, 81.8, 82.4, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7], [50.0, 80.6, 81.1, 81.6, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0], [54.0, 79.9, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4], [58.0, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2]]);
  /**
   * Table 1502 - CN2 vs CN1 @ Mach 0, 0.2, 0.9
   * n2_to_n1_table
   * @param i row index (n2)
   * @param j 1 = Mach 0, 2 = Mach 0.2, 3 = Mach 0.9
   * @returns Corrected N1 (CN1)
   */
  _defineProperty(EngineModel, "table1502", [[0, 0, 0.2, 0.9], [18.200000, 0.000000, 0.000000, 17.000000], [22.000000, 1.900000, 1.900000, 17.400000], [26.000000, 2.500000, 2.500000, 18.200000], [57.000000, 12.800000, 12.800000, 27.000000], [68.200000, 19.600000, 19.600000, 34.827774], [77.000000, 26.000000, 26.000000, 40.839552], [83.000000, 31.420240, 31.420240, 44.768766], [89.000000, 40.972041, 40.972041, 50.092140], [92.800000, 51.000000, 51.000000, 55.042000], [97.000000, 65.000000, 65.000000, 65.000000], [100.000000, 77.000000, 77.000000, 77.000000], [104.000000, 85.000000, 85.000000, 85.500000], [116.500000, 101.000000, 101.000000, 101.000000]]);
  /**
   * Table 1503 - Turbine LoMach (0) CN2 vs. Throttle @ IAP Ratio 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313
   * mach_0_corrected_commanded_ne_table
   * @param i row index (thrust lever position)
   * @param j IAP ratio
   * @returns Corrected N2 (CN2)
   */
  _defineProperty(EngineModel, "table1503", [[0, 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313], [0.000000, 68.200000, 69.402657, 70.671269, 73.432244, 76.544349, 78.644882, 78.644882], [0.100000, 76.000000, 77.340205, 78.753906, 81.830654, 85.298688, 87.639458, 87.639458], [0.200000, 83.000000, 84.463645, 86.007556, 89.367688, 93.155146, 95.711513, 95.711513], [0.400000, 92.800000, 94.436461, 96.162664, 99.919535, 104.154188, 107.012390, 107.012390], [0.600000, 98.000000, 99.728159, 101.551090, 105.518475, 109.990414, 113.008774, 113.008774], [0.750000, 101.500000, 103.289879, 105.177914, 109.286991, 113.918643, 117.044802, 117.044802], [0.900000, 103.000000, 104.816330, 106.000000, 110.902070, 115.602170, 118.774528, 118.774528], [1.000000, 104.200000, 106.037491, 107.975750, 112.194133, 116.948991, 120.158309, 120.158309]]);
  /**
   * Table 1504 - Turbine HiMach (0.9) CN2 vs. Throttle @ IAP Ratio 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313
   * mach_hi_corrected_commanded_ne_table
   * @param i row index (thrust lever position)
   * @param j IAP ratio
   * @returns Corrected N2 (CN2)
   */
  _defineProperty(EngineModel, "table1504", [[0, 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313], [0.000000, 63.267593, 64.383271, 65.560133, 68.121427, 71.008456, 72.957073, 72.957073], [0.100000, 70.503476, 71.746753, 73.058212, 75.912441, 79.129658, 81.301137, 81.301137], [0.200000, 76.997217, 78.355007, 79.787258, 82.904376, 86.417916, 88.789399, 88.789399], [0.400000, 86.088455, 87.606562, 89.207922, 92.693086, 96.621477, 99.272967, 99.272967], [0.600000, 90.912377, 92.515550, 94.206642, 97.887095, 102.035612, 104.835676, 104.835676], [0.750000, 94.159247, 95.819677, 97.571165, 101.383063, 105.679741, 108.579808, 108.579808], [0.900000, 95.550763, 97.235732, 98.333795, 102.881334, 107.241510, 110.184435, 110.184435], [1.000000, 104.200000, 106.037491, 107.975750, 112.194133, 116.948991, 120.158309, 120.158309]]);
  /**
   * Table 1506 - Corrected net Thrust vs CN1 @ Mach 0 to 0.9 in 0.1 steps
   * n1_and_mach_on_thrust_table
   * @param i row index (CN1)
   * @param j mach
   * @returns Corrected net thrust (pounds of force)
   */
  _defineProperty(EngineModel, "table1506", [[0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000], [20.000000, 0.091741, 0.057020, 0.052029, 0.028096, -0.017284, -0.037284, -0.057077, -0.205841, -0.315399, -0.488717], [25.000000, 0.142810, 0.072215, 0.053026, 0.030404, -0.009593, -0.026571, -0.041999, -0.151328, -0.266204, -0.439028], [30.000000, 0.189837, 0.082322, 0.055050, 0.032748, 0.017389, 0.003990, -0.026921, -0.056814, -0.081946, -0.369391], [35.000000, 0.262207, 0.126047, 0.077206, 0.045921, 0.024719, 0.006062, -0.002812, -0.022800, -0.044248, -0.293631], [40.000000, 0.330230, 0.162757, 0.124088, 0.069579, 0.057905, 0.049621, 0.029790, -0.002139, -0.025811, -0.220630], [45.000000, 0.393293, 0.250096, 0.156707, 0.112419, 0.091418, 0.076757, 0.056090, 0.018509, -0.007375, -0.155120], [50.000000, 0.452337, 0.311066, 0.211353, 0.158174, 0.127429, 0.104915, 0.081171, 0.047419, 0.011062, -0.098474], [55.000000, 0.509468, 0.373568, 0.269961, 0.209106, 0.168650, 0.137223, 0.108383, 0.075660, 0.028704, -0.049469], [60.000000, 0.594614, 0.439955, 0.334629, 0.267477, 0.217773, 0.176899, 0.141404, 0.107148, 0.064556, -0.005036], [65.000000, 0.660035, 0.512604, 0.407151, 0.335055, 0.276928, 0.226669, 0.183627, 0.145850, 0.104441, 0.039012], [70.000000, 0.733601, 0.593506, 0.488571, 0.412623, 0.347163, 0.288210, 0.237559, 0.195142, 0.152485, 0.087269], [75.000000, 0.818693, 0.683880, 0.578756, 0.499514, 0.427939, 0.361604, 0.304241, 0.257197, 0.212005, 0.144042], [80.000000, 0.910344, 0.783795, 0.675982, 0.593166, 0.516644, 0.444822, 0.382689, 0.332384, 0.284867, 0.212679], [85.000000, 1.025165, 0.891823, 0.776548, 0.688692, 0.608128, 0.533210, 0.469351, 0.418690, 0.370870, 0.294907], [90.000000, 1.157049, 1.004695, 0.874400, 0.778466, 0.694251, 0.619011, 0.557581, 0.511153, 0.467149, 0.390203], [95.000000, 1.281333, 1.116993, 0.960774, 0.851733, 0.763455, 0.690890, 0.637136, 0.601322, 0.567588, 0.495167], [100.000000, 1.357935, 1.220844, 1.023864, 0.894234, 0.800352, 0.733488, 0.693684, 0.654691, 0.617963, 0.539115], [105.000000, 1.378826, 1.239626, 1.048498, 0.915750, 0.819609, 0.751137, 0.710375, 0.670444, 0.632832, 0.552086], [110.000000, 1.392754, 1.252148, 1.069322, 0.933937, 0.835886, 0.766054, 0.724483, 0.683759, 0.645400, 0.563051]]);

  class FlightModel {
    /**
     * Get lift coefficient at given conditions
     * @param weight in pounds
     * @param mach self-explanatory
     * @param delta pressure at the altitude divided by the pressure at sea level
     * @param loadFactor g-Force
     * @returns lift coefficient (Cl)
     */
    static getLiftCoefficient(weight, mach, delta) {
      let loadFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      return weight * loadFactor / (1481.4 * mach ** 2 * delta * this.wingArea);
    }
    static getLiftCoefficientFromEAS(lift, eas) {
      return 295.369 * lift / (eas ** 2 * this.wingArea);
    }

    /**
     * Get drag coefficient at given conditions
     * @param Cl coefficient of lift
     * @param spdBrkDeflected whether speedbrake is deflected at half or not
     * @param gearExtended whether gear is extended or not
     * @param flapConf flap configuration
     * @returns drag coefficient (Cd)
     */
    static getDragCoefficient(Cl) {
      let spdBrkDeflected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let gearExtended = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let flapConf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : FlapConf.CLEAN;
      // Values taken at mach 0
      let baseDrag;
      switch (flapConf) {
        case FlapConf.CLEAN:
          baseDrag = 0.0211 * Cl ** 3 + 0.0412 * Cl ** 2 - 0.015 * Cl + 0.0215;
          break;
        case FlapConf.CONF_1:
          baseDrag = 0.0303 * Cl ** 4 - 0.064 * Cl ** 3 + 0.1166 * Cl ** 2 - 0.0538 * Cl + 0.0398;
          break;
        case FlapConf.CONF_2:
          baseDrag = 0.0168 * Cl ** 3 - 0.0018 * Cl ** 2 - 0.0037 * Cl + 0.0729;
          break;
        case FlapConf.CONF_3:
          baseDrag = 0.013 * Cl ** 3 - 0.0056 * Cl ** 2 + 0.0005 * Cl + 0.0902;
          break;
        case FlapConf.CONF_FULL:
          baseDrag = 0.0077 * Cl ** 3 - 0.0056 * Cl ** 2 - 0.001 * Cl + 0.1405;
          break;
      }
      const spdBrkIncrement = spdBrkDeflected ? 0.01008 : 0;
      const gearIncrement = gearExtended ? 0.0372 : 0;
      return baseDrag + spdBrkIncrement + gearIncrement;
    }

    /**
     * Get drag at given conditions
     * @param weight in pounds
     * @param mach self-explanatory
     * @param delta pressure at the altitude divided by the pressure at sea level
     * @param spdBrkDeflected Whether speedbrake is deflected at half or not
     * @param gearExtended whether gear is extended or not
     * @param flapConf flap configuration
     * @returns drag
     */
    static getDrag(weight, mach, delta, spdBrkDeflected, gearExtended, flapConf) {
      const Cl = this.getLiftCoefficient(weight, mach, delta);
      const Cd = this.getDragCoefficient(Cl, spdBrkDeflected, gearExtended, flapConf);
      const deltaCd = this.getMachCorrection(mach, flapConf);
      return 1481.4 * mach ** 2 * delta * this.wingArea * (Cd + deltaCd);
    }
    static getMachCorrection(mach, flapConf) {
      if (flapConf !== FlapConf.CLEAN) {
        return 0;
      }
      return this.interpolate(mach, this.machValues, this.dragCoefficientCorrections);
    }

    /**
     * Interpolates in a list
     * @param x The value to look up in in `xs`.
     * @param xs The table of x values with known y values
     * @param ys The y values corresponding to the x values in `xs`
     */
    static interpolate(x, xs, ys) {
      if (x <= xs[0]) {
        return ys[0];
      }
      for (let i = 0; i < xs.length - 1; i++) {
        if (x > xs[i] && x <= xs[i + 1]) {
          return Common.interpolate(x, xs[i], xs[i + 1], ys[i], ys[i + 1]);
        }
      }
      return ys[ys.length - 1];
    }

    // NEW

    /**
     * Returns the available climb or descent gradient.
     *
     * @param thrust the thrust in lbf
     * @param drag
     * @param weight in lbs
     *
     * @returns the available gradient in radians
     */
    static getAvailableGradient(thrust, drag, weight) {
      return Math.asin((thrust - drag) / weight);
    }

    /**
     * Returns an acceleration for a given available gradient, fpa and acceleration factor.
     *
     * @param availableGradient in radians
     * @param fpa in radians
     * @param accelFactor
     *
     * @returns the acceleration
     */
    static accelerationForGradient(availableGradient, fpa, accelFactor) {
      return (Math.sin(availableGradient) - Math.sin(fpa)) * accelFactor;
    }

    /**
     * Returns an fpa for a given available gradient, acceleration and acceleration factor.
     *
     * @param availableGradient in radians
     * @param acceleration
     * @param accelFactor
     *
     * @returns the fpa in radians
     */
    static fpaForGradient(availableGradient, acceleration, accelFactor) {
      return Math.asin(Math.sin(availableGradient) - acceleration / accelFactor);
    }

    // END NEW

    static getConstantThrustPathAngle(thrust, weight, drag, accelFactor) {
      return Math.asin((thrust - drag) / weight / accelFactor);
    }
    static getConstantThrustPathAngleFromCoefficients(thrust, weight, Cl, Cd, accelFactor) {
      return Math.asin((thrust / weight - Cd / Cl) / accelFactor);
    }
    static getThrustFromConstantPathAngle(fpa, weight, drag, accelFactor) {
      // fpa is in degrees
      return weight * (accelFactor * Math.sin(fpa * MathUtils$1.DEGREES_TO_RADIANS)) + drag;
    }
    static getThrustFromConstantPathAngleCoefficients(fpa, weight, Cl, Cd, accelFactor) {
      // fpa is in degrees
      return weight * (accelFactor * Math.sin(fpa * MathUtils$1.DEGREES_TO_RADIANS) + Cd / Cl);
    }
    static getSpeedChangePathAngle(thrust, weight, drag) {
      return Math.asin((thrust - drag) / weight - 1 / FlightModel.gravityConstMS2 * FlightModel.requiredAccelRateMS2);
    }
    static getSpeedChangePathAngleFromCoefficients(thrust, weight, Cl, Cd) {
      return Math.asin(thrust / weight - Cd / Cl - 1 / FlightModel.gravityConstMS2 * FlightModel.requiredAccelRateMS2);
    }
    static getAccelRateFromIdleGeoPath(thrust, weight, drag, fpaDeg) {
      // fpa is in degrees
      const fpaRad = fpaDeg * MathUtils$1.DEGREES_TO_RADIANS;
      return FlightModel.gravityConstKNS * ((thrust - drag) / weight - Math.sin(fpaRad));
    }
    static getAccelRateFromIdleGeoPathCoefficients(thrust, weight, Cl, Cd, fpaDeg) {
      // fpa is in degrees
      const fpaRad = fpaDeg * MathUtils$1.DEGREES_TO_RADIANS;
      return FlightModel.gravityConstKNS * (thrust / weight - Cd / Cl - Math.sin(fpaRad));
    }

    /**
     * Gets distance required to accelerate/decelerate
     * @param thrust
     * @param drag
     * @param weight in pounds
     * @param initialSpeed
     * @param targetSpeed
     * @param fpa flight path angle, default value 0 for level segments
     * @param accelFactor acceleration factor, default value 0 for level segments
     * @returns distance to accel/decel
     */
    static getAccelerationDistance(thrust, drag, weight, initialSpeed, targetSpeed) {
      let fpa = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      let accelFactor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      const sign = Math.sign(fpa);
      const force = thrust - drag + sign * weight * Math.sin(fpa * (Math.PI / 180)) * accelFactor;
      const accel = force / weight; // TODO: Check units
      const timeToAccel = (targetSpeed - initialSpeed) / accel;
      const distanceToAccel = initialSpeed * timeToAccel + 0.5 * accel * timeToAccel ** 2; // TODO: Check units
      return distanceToAccel;
    }
    static getGreenDotSpeedCas(altitude, weight) {
      return weight / 500 + 85 + Math.max(0, (altitude - 20000) / 1000);
    }
  }
  _defineProperty(FlightModel, "Cd0", 0.01873);
  _defineProperty(FlightModel, "wingSpan", 117.454);
  _defineProperty(FlightModel, "wingArea", 1317.47);
  _defineProperty(FlightModel, "wingEffcyFactor", 0.70);
  _defineProperty(FlightModel, "requiredAccelRateKNS", 1.33);
  // in knots/second
  _defineProperty(FlightModel, "requiredAccelRateMS2", 0.684);
  // in m/s^2
  _defineProperty(FlightModel, "gravityConstKNS", 19.0626);
  // in knots/second
  _defineProperty(FlightModel, "gravityConstMS2", 9.806665);
  // in m/s^2
  // From https://github.com/flybywiresim/a32nx/pull/6903#issuecomment-1073168320
  _defineProperty(FlightModel, "machValues", [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85]);
  _defineProperty(FlightModel, "dragCoefficientCorrections", [0, 0.0002, 0.0003, 0.0004, 0.0008, 0.0015, 0.01]);

  let VnavStepError = /*#__PURE__*/function (VnavStepError) {
    VnavStepError[VnavStepError["AVAILABLE_GRADIENT_INSUFFICIENT"] = 0] = "AVAILABLE_GRADIENT_INSUFFICIENT";
    VnavStepError[VnavStepError["TOO_LOW_DECELERATION"] = 1] = "TOO_LOW_DECELERATION";
    return VnavStepError;
  }({});
  class Predictions {
    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param stepSize the size of the altitude step, in feet
     * @param econCAS airspeed during climb (taking SPD LIM & restrictions into account)
     * @param econMach mach during climb, after passing crossover altitude
     * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param headwindAtMidStepAlt headwind component (in knots) at initialAltitude + (stepSize / 2); tailwind is negative
     * @param isaDev ISA deviation (in celsius)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not speedbrakes are extended at half
     * @param flapsConfig flaps configuration to use for drag calculation
     * @param gearExtended whether or not gear is extended
     * @param perfFactorPercent performance factor (in percent) entered in the MCDU to apply to fuel calculations
     */
    static altitudeStep(initialAltitude, stepSize, econCAS, econMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      let flapsConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let perfFactorPercent = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      const midStepAltitude = initialAltitude + stepSize / 2;
      const theta = Common.getTheta(midStepAltitude, isaDev, midStepAltitude > tropoAltitude);
      const delta = Common.getDelta(midStepAltitude, midStepAltitude > tropoAltitude);
      let mach = Common.CAStoMach(econCAS, delta);
      let tas;
      let accelFactorMode = AccelFactorMode.CONSTANT_CAS;
      // If above crossover altitude, use econMach
      if (mach > econMach) {
        mach = econMach;
        tas = Common.machToTAS(mach, theta);
        accelFactorMode = AccelFactorMode.CONSTANT_MACH;
      } else {
        tas = Common.CAStoTAS(econCAS, theta, delta);
      }

      // Engine model calculations
      const theta2 = Common.getTheta2(theta, mach);
      const delta2 = Common.getDelta2(delta, mach);
      const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
      const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, mach) * 2 * EngineModel.maxThrust;
      const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, midStepAltitude) * 2;
      const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
      const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

      const weightEstimate = zeroFuelWeight + initialFuelWeight;
      let pathAngle;
      let verticalSpeed;
      let stepTime;
      let distanceTraveled;
      let fuelBurned;
      let midStepWeight = weightEstimate;
      let previousMidStepWeight = midStepWeight;
      let iterations = 0;
      do {
        const drag = FlightModel.getDrag(midStepWeight, mach, delta, speedbrakesExtended, gearExtended, flapsConfig);
        const accelerationFactor = Common.getAccelerationFactor(mach, midStepAltitude, isaDev, midStepAltitude > tropoAltitude, accelFactorMode);
        pathAngle = FlightModel.getConstantThrustPathAngle(thrust, midStepWeight, drag, accelerationFactor);
        verticalSpeed = 101.268 * tas * Math.sin(pathAngle); // in feet per minute
        stepTime = verticalSpeed !== 0 ? 60 * stepSize / verticalSpeed : 0; // in seconds
        distanceTraveled = (tas - headwindAtMidStepAlt) * (stepTime / 3600); // in nautical miles
        fuelBurned = fuelFlow / 3600 * stepTime;
        // const endStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned); <- not really needed

        // Adjust variables for better accuracy next iteration
        previousMidStepWeight = midStepWeight;
        midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
        iterations++;
      } while (iterations < 4 && Math.abs(previousMidStepWeight - midStepWeight) > 10);
      return {
        pathAngle: pathAngle * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        timeElapsed: stepTime,
        distanceTraveled,
        fuelBurned,
        initialAltitude,
        finalAltitude: initialAltitude + stepSize,
        speed: econCAS
      };
    }

    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param distance distance to travel during step, in nautical miles
     * @param econCAS corrected airspeed at the start of the step, in knots
     * @param econMach mach during climb, after passing crossover altitude
     * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT FUEL PRED)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param headwindAtMidStepAlt headwind component (in knots) at initialAltitude + (stepSize / 2); tailwind is negative
     * @param isaDev ISA deviation (in celsius)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not speedbrakes are extended at half
     * @param flapsConfig flaps configuration to use for drag calculation
     * @param gearExtended whether or not gear is extended
     * @param perfFactorPercent performance factor (in percent) entered in the MCDU to apply to fuel calculations
     */
    static distanceStep(initialAltitude, distance, econCAS, econMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      let flapsConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let perfFactorPercent = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      const weightEstimate = zeroFuelWeight + initialFuelWeight;
      let finalAltitude = initialAltitude;
      let previousFinalAltitude = finalAltitude;
      let pathAngle;
      let verticalSpeed;
      let stepTime;
      let stepSize;
      let fuelBurned;
      let midStepWeight = weightEstimate;
      let iterations = 0;
      do {
        const midStepAltitude = (initialAltitude + finalAltitude) / 2;
        const theta = Common.getTheta(midStepAltitude, isaDev, midStepAltitude > tropoAltitude);
        const delta = Common.getDelta(midStepAltitude, midStepAltitude > tropoAltitude);
        let mach = Common.CAStoMach(econCAS, delta);
        let tas;
        let accelFactorMode = AccelFactorMode.CONSTANT_CAS;
        // If above crossover altitude, use econMach
        if (mach > econMach) {
          mach = econMach;
          tas = Common.machToTAS(mach, theta);
          accelFactorMode = AccelFactorMode.CONSTANT_MACH;
        } else {
          tas = Common.CAStoTAS(econCAS, theta, delta);
        }

        // Engine model calculations
        const theta2 = Common.getTheta2(theta, mach);
        const delta2 = Common.getDelta2(delta, mach);
        const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
        const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, mach) * 2 * EngineModel.maxThrust;
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, initialAltitude) * 2;
        const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
        const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

        const drag = FlightModel.getDrag(midStepWeight, mach, delta, speedbrakesExtended, gearExtended, flapsConfig);
        const accelerationFactor = Common.getAccelerationFactor(mach, midStepAltitude, isaDev, midStepAltitude > tropoAltitude, accelFactorMode);
        pathAngle = FlightModel.getConstantThrustPathAngle(thrust, midStepWeight, drag, accelerationFactor);
        verticalSpeed = 101.268 * tas * Math.sin(pathAngle); // in feet per minute
        stepTime = tas - headwindAtMidStepAlt !== 0 ? 3600 * distance / (tas - headwindAtMidStepAlt) : 0; // in seconds
        stepSize = stepTime / 60 * verticalSpeed;
        fuelBurned = fuelFlow / 3600 * stepTime;

        // Adjust variables for better accuracy next iteration
        previousFinalAltitude = finalAltitude;
        midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
        finalAltitude = initialAltitude + stepSize;
        iterations++;
      } while (iterations < 4 && Math.abs(finalAltitude - previousFinalAltitude) > 10);
      return {
        pathAngle: pathAngle * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        timeElapsed: stepTime,
        distanceTraveled: distance,
        fuelBurned,
        initialAltitude,
        finalAltitude,
        speed: econCAS
      };
    }

    /**
     * @param altitude altitude of this level segment
     * @param stepSize the distance of the step, in NM
     * @param econCAS airspeed during level segment
     * @param econMach mach during level segment (when over crossover altitude)
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param headwind headwind component (in knots) at altitude; tailwind is negative
     * @param isaDev ISA deviation (in celsius)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not speedbrakes are extended at half
     * @param flapsConfig flaps configuration to use for drag calculation
     * @param gearExtended whether or not gear is extended
     * @param perfFactorPercent performance factor (in percent) entered in the MCDU to apply to fuel calculations
     */
    static levelFlightStep(altitude, stepSize, econCAS, econMach, zeroFuelWeight, initialFuelWeight, headwind, isaDev, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
      let flapsConfig = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : false;
      let perfFactorPercent = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      const theta = Common.getTheta(altitude, isaDev, altitude > tropoAltitude);
      const delta = Common.getDelta(altitude, altitude > tropoAltitude);
      let mach = Common.CAStoMach(econCAS, delta);
      let tas;
      // If above crossover altitude, use econMach
      if (mach > econMach) {
        mach = econMach;
        tas = Common.machToTAS(mach, theta);
      } else {
        tas = Common.CAStoTAS(econCAS, theta, delta);
      }
      const initialWeight = zeroFuelWeight + initialFuelWeight;
      const thrust = FlightModel.getDrag(initialWeight, mach, delta, speedbrakesExtended, gearExtended, flapsConfig);

      // Engine model calculations
      const theta2 = Common.getTheta2(theta, mach);
      const delta2 = Common.getDelta2(delta, mach);
      // Divide by 2 to get thrust per engine
      const correctedThrust = thrust / delta2 / 2;
      // Since table 1506 describes corrected thrust as a fraction of max thrust, divide it
      const correctedN1 = EngineModel.reverseTableInterpolation(EngineModel.table1506, mach, correctedThrust / EngineModel.maxThrust);
      const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, altitude) * 2;
      const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

      const stepTime = stepSize / (tas - headwind) * 3600; // in seconds
      const fuelBurned = fuelFlow / 3600 * stepTime;
      return {
        pathAngle: 0,
        verticalSpeed: 0,
        timeElapsed: stepTime,
        distanceTraveled: stepSize,
        fuelBurned,
        finalAltitude: altitude,
        initialAltitude: altitude,
        speed: econCAS
      };
    }

    /**
     * @param flightPathAngle flight path angle (in degrees) to fly the speed change step at
     * @param initialAltitude altitude at beginning of step, in feet
     * @param initialCAS airspeed at beginning of step
     * @param finalCAS airspeed at end of step
     * @param initialMach initial mach, above crossover altitude
     * @param finalMach final mach, above crossover altitude
     * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param headwindAtInitialAltitude headwind component (in knots) at initialAltitude
     * @param isaDev ISA deviation (in celsius)
     * @param tropoAltitude tropopause altitude (feet)
     * @param gearExtended whether the gear is extended
     * @param flapConfig the flaps configuration
     * @param speedbrakesExtended whether or not speedbrakes are extended at half
     * @param minimumAbsoluteAcceleration the minimum absolute acceleration before emitting TOO_LOW_DECELERATION (kts/s)
     * @param perfFactorPercent performance factor (in percent) entered in the MCDU to apply to fuel calculations
     */
    static speedChangeStep(flightPathAngle, initialAltitude, initialCAS, finalCAS, initialMach, finalMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtInitialAltitude, isaDev, tropoAltitude) {
      let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let flapConfig = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : FlapConf.CLEAN;
      let speedbrakesExtended = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : false;
      let minimumAbsoluteAcceleration = arguments.length > 15 ? arguments[15] : undefined;
      let perfFactorPercent = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : 0;
      const theta = Common.getTheta(initialAltitude, isaDev, initialAltitude > tropoAltitude);
      const delta = Common.getDelta(initialAltitude, initialAltitude > tropoAltitude);
      let actualInitialMach = Common.CAStoMach(initialCAS, delta);
      let actualFinalMach = Common.CAStoMach(finalCAS, delta);
      let initialTas;
      let finalTas;

      // If above crossover altitude, use mach
      if (actualInitialMach > initialMach) {
        actualInitialMach = initialMach;
        initialTas = Common.machToTAS(actualInitialMach, theta);
      } else {
        initialTas = Common.CAStoTAS(initialCAS, theta, delta);
      }
      if (actualFinalMach > finalMach) {
        actualFinalMach = finalMach;
        finalTas = Common.machToTAS(actualFinalMach, theta);
      } else {
        finalTas = Common.CAStoTAS(finalCAS, theta, delta);
      }
      const averageMach = (actualInitialMach + actualFinalMach) / 2;
      const averageTas = (initialTas + finalTas) / 2;

      // Engine model calculations
      const theta2 = Common.getTheta2(theta, averageMach);
      const delta2 = Common.getDelta2(delta, averageMach);
      const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
      const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, averageMach) * 2 * EngineModel.maxThrust;
      const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, averageMach, initialAltitude) * 2;
      const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
      const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

      const weightEstimate = zeroFuelWeight + initialFuelWeight;
      let pathAngleRadians = flightPathAngle * MathUtils$1.DEGREES_TO_RADIANS;
      let error;
      let verticalSpeed;
      let stepTime;
      let distanceTraveled;
      let fuelBurned;
      let finalAltitude;
      let lift = weightEstimate;
      let midStepWeight = weightEstimate;
      let previousMidStepWeight = midStepWeight;
      let iterations = 0;
      do {
        // Calculate the available gradient
        const drag = FlightModel.getDrag(lift, averageMach, delta, speedbrakesExtended, gearExtended, flapConfig);
        const availableGradient = FlightModel.getAvailableGradient(thrust, drag, weightEstimate);
        pathAngleRadians = flightPathAngle * MathUtils$1.DEGREES_TO_RADIANS;
        if (Math.abs(availableGradient) < Math.abs(pathAngleRadians)) {
          error = VnavStepError.AVAILABLE_GRADIENT_INSUFFICIENT;
          // Save the achievable gradient here, so it can be used by the caller
          pathAngleRadians = availableGradient;
          break;
        }
        const acceleration = FlightModel.accelerationForGradient(availableGradient, pathAngleRadians, FlightModel.gravityConstKNS); // in kts/s

        if (Math.abs(acceleration) < minimumAbsoluteAcceleration) {
          error = VnavStepError.TOO_LOW_DECELERATION;
          break;
        }
        stepTime = (finalTas - initialTas) / acceleration; // in seconds
        distanceTraveled = stepTime / 3600 * (averageTas - headwindAtInitialAltitude);
        finalAltitude = initialAltitude + 6076.12 * distanceTraveled * Math.tan(pathAngleRadians);
        verticalSpeed = Math.abs(stepTime) < 1e-12 ? 0 : 60 * (finalAltitude - initialAltitude) / stepTime; // in feet per minute
        fuelBurned = fuelFlow / 3600 * stepTime;

        // Adjust variables for better accuracy next iteration
        previousMidStepWeight = midStepWeight;
        midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
        lift = midStepWeight * Math.cos(pathAngleRadians);
        iterations++;
      } while (iterations < 4 && Math.abs(previousMidStepWeight - midStepWeight) > 100);
      return {
        pathAngle: pathAngleRadians * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        timeElapsed: stepTime,
        distanceTraveled,
        fuelBurned,
        initialAltitude,
        finalAltitude,
        error,
        speed: finalCAS
      };
    }

    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param finalAltitude altitude at end of step, in feet
     * @param distance distance of step, in NM
     * @param econCAS airspeed during step
     * @param econMach mach during step
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param isaDev ISA deviation (in celsius)
     * @param headwind headwind component (in knots)
     * @param tropoAltitude tropopause altitude (feet)
     * @param gearExtended whether or not the landing gear is extended
     * @param flapConfig flap configuration to use for drag calculation
     * @param speedbrakesExtended whether or not the speedbrakes are extended at half
     * @param perfFactorPercent performance factor (in percent)
     */
    static geometricStep(initialAltitude, finalAltitude, distance, econCAS, econMach, zeroFuelWeight, initialFuelWeight, isaDev, headwind, tropoAltitude) {
      let gearExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      let flapConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
      let speedbrakesExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let perfFactorPercent = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      const distanceInFeet = distance * 6076.12;
      const fpaRadians = Math.atan((finalAltitude - initialAltitude) / distanceInFeet);
      const fpaDegrees = fpaRadians * MathUtils$1.RADIANS_TO_DEGREES;
      const midStepAltitude = (initialAltitude + finalAltitude) / 2;
      const theta = Common.getTheta(midStepAltitude, isaDev, midStepAltitude > tropoAltitude);
      const delta = Common.getDelta(midStepAltitude, midStepAltitude > tropoAltitude);
      let mach = Common.CAStoMach(econCAS, delta);
      let eas;
      let tas;
      let accelFactorMode = AccelFactorMode.CONSTANT_CAS;
      // If above crossover altitude, use econMach
      if (mach > econMach) {
        mach = econMach;
        eas = Common.machToEAS(mach, delta);
        tas = Common.machToTAS(mach, theta);
        accelFactorMode = AccelFactorMode.CONSTANT_MACH;
      } else {
        eas = Common.CAStoEAS(econCAS, delta);
        tas = Common.CAStoTAS(econCAS, theta, delta);
      }
      const weightEstimate = zeroFuelWeight + initialFuelWeight;
      const theta2 = Common.getTheta2(theta, mach);
      const delta2 = Common.getDelta2(delta, mach);
      let thrust; // In lbs force
      let verticalSpeed;
      let stepTime;
      let fuelBurned;
      let lift = weightEstimate * Math.cos(fpaRadians);
      let midStepWeight = weightEstimate;
      let previousMidStepWeight = midStepWeight;
      let iterations = 0;
      do {
        const liftCoefficient = FlightModel.getLiftCoefficientFromEAS(lift, eas);
        const dragCoefficient = FlightModel.getDragCoefficient(liftCoefficient, speedbrakesExtended, gearExtended, flapConfig);
        const accelFactor = Common.getAccelerationFactor(mach, midStepAltitude, isaDev, midStepAltitude > tropoAltitude, accelFactorMode);
        thrust = FlightModel.getThrustFromConstantPathAngleCoefficients(fpaDegrees, midStepWeight, liftCoefficient, dragCoefficient, accelFactor);
        verticalSpeed = 101.268 * (tas - headwind) * Math.sin(fpaRadians); // in feet per minute
        stepTime = verticalSpeed !== 0 ? 60 * (finalAltitude - initialAltitude) / verticalSpeed : 0; // in seconds

        // Divide by 2 to get thrust per engine
        const correctedThrust = thrust / delta2 / 2;
        // Since table 1506 describes corrected thrust as a fraction of max thrust, divide it
        const correctedN1 = EngineModel.reverseTableInterpolation(EngineModel.table1506, mach, correctedThrust / EngineModel.maxThrust);
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, mach, midStepAltitude) * 2;
        const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

        fuelBurned = fuelFlow / 3600 * stepTime;

        // Adjust variables for better accuracy next iteration
        previousMidStepWeight = midStepWeight;
        midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
        lift = midStepWeight * Math.cos(fpaRadians);
        iterations++;
      } while (iterations < 4 && Math.abs(previousMidStepWeight - midStepWeight) > 100);
      return {
        pathAngle: fpaDegrees,
        verticalSpeed,
        timeElapsed: stepTime,
        distanceTraveled: distance,
        fuelBurned,
        finalAltitude,
        initialAltitude,
        speed: econCAS
      };
    }

    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param finalAltitude altitude at end of step, in feet
     * @param verticalSpeed vertical speed during step, in feet per minute
     * @param econCAS airspeed during step
     * @param econMach mach during step
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param isaDev ISA deviation (in celsius)
     * @param headwind headwind component (in knots)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not the speedbrakes are extended at half
     * @param flapsConfig flap configuration to use for drag calculation
     * @param gearExtended whether or not the landing gear is extended
     * @param perfFactorPercent performance factor (in percent)
     */
    static verticalSpeedStep(initialAltitude, finalAltitude, verticalSpeed, econCAS, econMach, zeroFuelWeight, initialFuelWeight, isaDev, headwind, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      let flapsConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let perfFactorPercent = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      const midStepAltitude = (initialAltitude + finalAltitude) / 2;
      const theta = Common.getTheta(midStepAltitude, isaDev, midStepAltitude > tropoAltitude);
      const delta = Common.getDelta(midStepAltitude, midStepAltitude > tropoAltitude);
      let mach = Common.CAStoMach(econCAS, delta);
      const delta2 = Common.getDelta2(delta, mach);
      const theta2 = Common.getTheta2(theta, mach);
      let tas;
      let accelFactorMode = AccelFactorMode.CONSTANT_CAS;
      // If above crossover altitude, use econMach
      if (mach > econMach) {
        mach = econMach;
        tas = Common.machToTAS(mach, theta);
        accelFactorMode = AccelFactorMode.CONSTANT_MACH;
      } else {
        tas = Common.CAStoTAS(econCAS, theta, delta);
      }
      const pathAngle = Math.atan2(verticalSpeed, tas * 101.269); // radians
      const stepTime = 60 * (finalAltitude - initialAltitude) / verticalSpeed; // seconds
      const distanceTraveled = (tas - headwind) * Math.cos(pathAngle) * stepTime / 3600;
      let fuelBurned = 0;
      let iterations = 0;
      let midstepWeight = zeroFuelWeight + initialFuelWeight;
      let previousMidstepWeight = midstepWeight;
      let predictedN1 = 0;
      do {
        const drag = FlightModel.getDrag(midstepWeight, mach, delta, speedbrakesExtended, gearExtended, flapsConfig);
        const thrust = FlightModel.getThrustFromConstantPathAngle(pathAngle * MathUtils$1.RADIANS_TO_DEGREES, midstepWeight, drag, accelFactorMode);
        const correctedThrust = thrust / delta2 / 2;
        // Since table 1506 describes corrected thrust as a fraction of max thrust, divide it
        predictedN1 = EngineModel.reverseTableInterpolation(EngineModel.table1506, mach, correctedThrust / EngineModel.maxThrust);
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(predictedN1, mach, midStepAltitude) * 2;
        const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

        fuelBurned = fuelFlow / 3600 * stepTime;
        previousMidstepWeight = midstepWeight;
        midstepWeight -= fuelBurned / 2;
      } while (++iterations < 4 && Math.abs(previousMidstepWeight - midstepWeight) > 100);
      return {
        pathAngle: pathAngle * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        distanceTraveled,
        fuelBurned,
        timeElapsed: stepTime,
        finalAltitude,
        predictedN1,
        speed: econCAS
      };
    }

    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param distance distance traveled during step, in nautical miles
     * @param verticalSpeed vertical speed during step, in feet per minute
     * @param econCAS airspeed during step
     * @param econMach mach during step
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param isaDev ISA deviation (in celsius)
     * @param headwind headwind component (in knots)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not the speedbrakes are extended at half
     * @param flapsConfig flap configuration to use for drag calculation
     * @param gearExtended whether or not the landing gear is extended
     * @param perfFactorPercent performance factor (in percent)
     */
    static verticalSpeedDistanceStep(initialAltitude, distance, verticalSpeed, econCAS, econMach, zeroFuelWeight, initialFuelWeight, isaDev, headwind, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      let flapsConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let perfFactorPercent = arguments.length > 13 ? arguments[13] : undefined;
      let finalAltitude = initialAltitude;
      let previousFinalAltitude = finalAltitude;
      let pathAngle = 0;
      let stepTime = 0;
      let fuelBurned = 0;
      let iterations = 0;
      let midstepWeight = zeroFuelWeight + initialFuelWeight;
      let predictedN1 = 0;
      do {
        const midStepAltitude = (initialAltitude + finalAltitude) / 2;
        const theta = Common.getTheta(midStepAltitude, isaDev, midStepAltitude > tropoAltitude);
        const delta = Common.getDelta(midStepAltitude, midStepAltitude > tropoAltitude);
        let mach = Common.CAStoMach(econCAS, delta);
        const delta2 = Common.getDelta2(delta, mach);
        const theta2 = Common.getTheta2(theta, mach);
        let tas;
        let accelFactorMode = AccelFactorMode.CONSTANT_CAS;
        // If above crossover altitude, use econMach
        if (mach > econMach) {
          mach = econMach;
          tas = Common.machToTAS(mach, theta);
          accelFactorMode = AccelFactorMode.CONSTANT_MACH;
        } else {
          tas = Common.CAStoTAS(econCAS, theta, delta);
        }

        // TODO: Use headwind
        pathAngle = Math.atan2(verticalSpeed, tas * 101.269); // radians
        stepTime = tas - headwind !== 0 ? 3600 * distance / (tas - headwind) : 0;
        const drag = FlightModel.getDrag(midstepWeight, mach, delta, speedbrakesExtended, gearExtended, flapsConfig);
        const thrust = FlightModel.getThrustFromConstantPathAngle(pathAngle * MathUtils$1.RADIANS_TO_DEGREES, midstepWeight, drag, accelFactorMode);
        const correctedThrust = thrust / delta2 / 2;
        // Since table 1506 describes corrected thrust as a fraction of max thrust, divide it
        predictedN1 = EngineModel.reverseTableInterpolation(EngineModel.table1506, mach, correctedThrust / EngineModel.maxThrust);
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(predictedN1, mach, midStepAltitude) * 2;
        const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

        previousFinalAltitude = finalAltitude;
        finalAltitude = initialAltitude + verticalSpeed * stepTime / 60;
        fuelBurned = fuelFlow / 3600 * stepTime;
        midstepWeight -= fuelBurned / 2;
      } while (++iterations < 4 && Math.abs(previousFinalAltitude - finalAltitude) > 10);
      return {
        pathAngle: pathAngle * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        distanceTraveled: distance,
        fuelBurned,
        timeElapsed: stepTime,
        initialAltitude,
        finalAltitude,
        predictedN1,
        speed: econCAS
      };
    }

    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param initialCAS airspeed at beginning of step
     * @param finalCAS airspeed at end of step
     * @param verticalSpeed vertical speed during step, in feet per minute
     * @param econMach mach during step
     * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param headwindAtMidStepAlt headwind component (in knots)
     * @param isaDev ISA deviation (in celsius)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not the speedbrakes are extended at half
     * @param flapsConfig flap configuration to use for drag calculation
     * @param gearExtended whether or not the landing gear is extended
     * @param perfFactorPercent performance factor (in percent)
     */
    static verticalSpeedStepWithSpeedChange(initialAltitude, initialCAS, finalCAS, verticalSpeed, econMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : false;
      let flapsConfig = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : false;
      let perfFactorPercent = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      const weightEstimate = zeroFuelWeight + initialFuelWeight;
      let pathAngle;
      let finalAltitude = initialAltitude;
      let previousFinalAltitude = finalAltitude;
      let stepTime;
      let distanceTraveled;
      let fuelBurned;
      let midStepWeight = weightEstimate;
      let iterations = 0;
      do {
        const midStepAltitude = (initialAltitude + finalAltitude) / 2;
        const isAboveTropo = midStepAltitude > tropoAltitude;
        const theta = Common.getTheta(midStepAltitude, isaDev, isAboveTropo);
        const delta = Common.getDelta(midStepAltitude, isAboveTropo);
        let initialMach = Common.CAStoMach(initialCAS, delta);
        let finalMach = Common.CAStoMach(finalCAS, delta);
        let initialTas;
        // If above crossover altitude, use econMach
        if (initialMach > econMach) {
          initialMach = econMach;
          initialTas = Common.machToTAS(initialMach, theta);
        } else {
          initialTas = Common.CAStoTAS(initialCAS, theta, delta);
        }
        let finalTas;
        if (finalMach > econMach) {
          finalMach = econMach;
          finalTas = Common.machToTAS(finalMach, theta);
        } else {
          finalTas = Common.CAStoTAS(finalCAS, theta, delta);
        }
        const midwayTas = (initialTas + finalTas) / 2;
        const midwayMach = (initialMach + finalMach) / 2;

        // Engine model calculations
        const theta2 = Common.getTheta2(theta, midwayMach);
        const delta2 = Common.getDelta2(delta, midwayMach);
        const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
        const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, midwayMach) * 2 * EngineModel.maxThrust;
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, midwayMach, midStepAltitude) * 2;
        const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
        const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

        const drag = FlightModel.getDrag(midStepWeight, midwayMach, delta, speedbrakesExtended, gearExtended, flapsConfig);
        const availableGradient = FlightModel.getAvailableGradient(thrust, drag, midStepWeight);
        pathAngle = Math.atan2(verticalSpeed, midwayTas * 101.269); // radians

        const acceleration = FlightModel.accelerationForGradient(availableGradient, pathAngle, FlightModel.gravityConstKNS); // kts/s

        stepTime = (finalCAS - initialCAS) / acceleration; // in seconds
        distanceTraveled = (midwayTas - headwindAtMidStepAlt) * (stepTime / 3600); // in nautical miles
        fuelBurned = fuelFlow / 3600 * stepTime;

        // Adjust variables for better accuracy next iteration
        previousFinalAltitude = finalAltitude;
        finalAltitude = initialAltitude + stepTime / 60 * verticalSpeed;
        midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
        iterations++;
      } while (iterations < 4 && Math.abs(previousFinalAltitude - finalAltitude) > 10);
      return {
        pathAngle: pathAngle * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        timeElapsed: stepTime,
        distanceTraveled,
        fuelBurned,
        initialAltitude,
        finalAltitude,
        speed: finalCAS
      };
    }

    /**
     * @param initialAltitude altitude at beginning of step, in feet
     * @param initialCAS airspeed at beginning of step
     * @param finalCAS airspeed at end of step
     * @param econMach mach during step
     * @param commandedN1 N1% at CLB (or idle) setting, depending on flight phase
     * @param zeroFuelWeight zero fuel weight of the aircraft (from INIT B)
     * @param initialFuelWeight weight of fuel at the end of last step
     * @param headwindAtMidStepAlt headwind component (in knots)
     * @param isaDev ISA deviation (in celsius)
     * @param tropoAltitude tropopause altitude (feet)
     * @param speedbrakesExtended whether or not the speedbrakes are extended at half
     * @param flapsConfig flap configuration to use for drag calculation
     * @param gearExtended whether or not the landing gear is extended
     * @param perfFactorPercent performance factor (in percent)
     */
    static altitudeStepWithSpeedChange(initialAltitude, initialCAS, finalCAS, econMach, commandedN1, zeroFuelWeight, initialFuelWeight, headwindAtMidStepAlt, isaDev, tropoAltitude) {
      let speedbrakesExtended = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      let flapsConfig = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : FlapConf.CLEAN;
      let gearExtended = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;
      let perfFactorPercent = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      const weightEstimate = zeroFuelWeight + initialFuelWeight;
      let pathAngle;
      let finalAltitude = initialAltitude;
      let previousFinalAltitude = finalAltitude;
      let verticalSpeed;
      let stepTime;
      let distanceTraveled;
      let fuelBurned;
      let midStepWeight = weightEstimate;
      let iterations = 0;
      do {
        const midStepAltitude = (initialAltitude + finalAltitude) / 2;
        const isAboveTropo = midStepAltitude > tropoAltitude;
        const theta = Common.getTheta(midStepAltitude, isaDev, isAboveTropo);
        const delta = Common.getDelta(midStepAltitude, isAboveTropo);
        let initialMach = Common.CAStoMach(initialCAS, delta);
        let finalMach = Common.CAStoMach(finalCAS, delta);
        let initialTas;
        // If above crossover altitude, use econMach
        if (initialMach > econMach) {
          initialMach = econMach;
          initialTas = Common.machToTAS(initialMach, theta);
        } else {
          initialTas = Common.CAStoTAS(initialCAS, theta, delta);
        }
        let finalTas;
        // If above crossover altitude, use econMach
        if (finalMach > econMach) {
          finalMach = econMach;
          finalTas = Common.machToTAS(finalMach, theta);
        } else {
          finalTas = Common.CAStoTAS(finalCAS, theta, delta);
        }
        const midwayMach = (initialMach + finalMach) / 2;
        const midwayTas = (initialTas + finalTas) / 2;

        // Engine model calculations
        const theta2 = Common.getTheta2(theta, midwayMach);
        const delta2 = Common.getDelta2(delta, midwayMach);
        const correctedN1 = EngineModel.getCorrectedN1(commandedN1, theta2);
        const correctedThrust = EngineModel.tableInterpolation(EngineModel.table1506, correctedN1, midwayMach) * 2 * EngineModel.maxThrust;
        const correctedFuelFlow = EngineModel.getCorrectedFuelFlow(correctedN1, midwayMach, midStepAltitude) * 2;
        const thrust = EngineModel.getUncorrectedThrust(correctedThrust, delta2); // in lbf
        const fuelFlow = Math.max(0, EngineModel.getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) * (1 + perfFactorPercent / 100)); // in lbs/hour

        const drag = FlightModel.getDrag(midStepWeight, midwayMach, delta, speedbrakesExtended, gearExtended, flapsConfig);
        const availableGradient = FlightModel.getAvailableGradient(thrust, drag, midStepWeight);
        pathAngle = FlightModel.getSpeedChangePathAngle(thrust, midStepWeight, drag); // radians
        const acceleration = FlightModel.accelerationForGradient(availableGradient, pathAngle, FlightModel.gravityConstKNS); // kts/s

        verticalSpeed = 101.268 * midwayTas * Math.sin(pathAngle); // in feet per minute
        stepTime = (finalCAS - initialCAS) / acceleration; // in seconds
        distanceTraveled = (midwayTas - headwindAtMidStepAlt) * (stepTime / 3600); // in nautical miles
        fuelBurned = fuelFlow / 3600 * stepTime;

        // Adjust variables for better accuracy next iteration
        previousFinalAltitude = finalAltitude;
        finalAltitude = initialAltitude + stepTime / 60 * verticalSpeed;
        midStepWeight = zeroFuelWeight + (initialFuelWeight - fuelBurned / 2);
        iterations++;
      } while (iterations < 4 && Math.abs(previousFinalAltitude - finalAltitude) > 10);
      return {
        pathAngle: pathAngle * MathUtils$1.RADIANS_TO_DEGREES,
        verticalSpeed,
        timeElapsed: stepTime,
        distanceTraveled,
        fuelBurned,
        initialAltitude,
        finalAltitude,
        speed: finalCAS
      };
    }
  }

  const DEFAULT_AIRCRAFT_CONFIG = {
    flapConfig: FlapConf.CLEAN,
    speedbrakesExtended: false,
    gearExtended: false
  };
  class DesModeStrategy {
    constructor(observer, atmosphericConditions, descentStrategy) {
      this.descentStrategy = descentStrategy;
      _defineProperty(this, "decelerationStrategy", void 0);
      this.decelerationStrategy = new IdleDescentStrategy(observer, atmosphericConditions);
    }
    static aboveProfile(observer, atmosphericConditions) {
      return new DesModeStrategy(observer, atmosphericConditions, new IdleDescentStrategy(observer, atmosphericConditions, {
        flapConfig: FlapConf.CLEAN,
        gearExtended: false,
        speedbrakesExtended: true
      }));
    }
    static belowProfileVs(observer, atmosphericConditions, verticalSpeed) {
      return new DesModeStrategy(observer, atmosphericConditions, new VerticalSpeedStrategy(observer, atmosphericConditions, verticalSpeed));
    }
    static belowProfileFpa(observer, atmosphericConditions, flightPathAngle) {
      return new DesModeStrategy(observer, atmosphericConditions, new FlightPathAngleStrategy(observer, atmosphericConditions, flightPathAngle));
    }
    predictToAltitude(initialAltitude, finalAltitude, speed, mach, fuelOnBoard, headwindComponent, config) {
      return this.descentStrategy.predictToAltitude(initialAltitude, finalAltitude, speed, mach, fuelOnBoard, headwindComponent, config);
    }
    predictToDistance(initialAltitude, distance, speed, mach, fuelOnBoard, headwindComponent, config) {
      return this.descentStrategy.predictToDistance(initialAltitude, distance, speed, mach, fuelOnBoard, headwindComponent, config);
    }
    predictToSpeed(initialAltitude, finalSpeed, initialSpeed, mach, fuelOnBoard, headwindComponent, config) {
      return this.decelerationStrategy.predictToSpeed(initialAltitude, finalSpeed, initialSpeed, mach, fuelOnBoard, headwindComponent, config);
    }
  }
  class IdleDescentStrategy {
    constructor(observer, atmosphericConditions) {
      let defaultConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_AIRCRAFT_CONFIG;
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
      this.defaultConfig = defaultConfig;
    }
    predictToAltitude(initialAltitude, finalAltitude, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this.defaultConfig;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      const {
        flapConfig,
        gearExtended,
        speedbrakesExtended
      } = _objectSpread2(_objectSpread2({}, this.defaultConfig), config);
      const midwayAltitude = (initialAltitude + finalAltitude) / 2;
      const computedMach = Math.min(this.atmosphericConditions.computeMachFromCas(midwayAltitude, speed), mach);
      const predictedN1 = EngineModel.getIdleN1(midwayAltitude, computedMach, tropoPause) + VnavConfig.IDLE_N1_MARGIN;
      return Predictions.altitudeStep(initialAltitude, finalAltitude - initialAltitude, speed, mach, predictedN1, zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, speedbrakesExtended, flapConfig, gearExtended, perfFactor);
    }
    predictToDistance(initialAltitude, distance, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this.defaultConfig;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      const {
        flapConfig,
        gearExtended,
        speedbrakesExtended
      } = _objectSpread2(_objectSpread2({}, this.defaultConfig), config);
      const computedMach = Math.min(this.atmosphericConditions.computeMachFromCas(initialAltitude, speed), mach);
      const predictedN1 = EngineModel.getIdleN1(initialAltitude, computedMach, tropoPause) + VnavConfig.IDLE_N1_MARGIN;
      return Predictions.distanceStep(initialAltitude, distance, speed, mach, predictedN1, zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, speedbrakesExtended, flapConfig, gearExtended, perfFactor);
    }
    predictToSpeed(initialAltitude, finalSpeed, initialSpeed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this.defaultConfig;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      const {
        flapConfig,
        gearExtended,
        speedbrakesExtended
      } = _objectSpread2(_objectSpread2({}, this.defaultConfig), config);
      const computedMach = Math.min(this.atmosphericConditions.computeMachFromCas(initialAltitude, initialSpeed), mach);
      const predictedN1 = EngineModel.getIdleN1(initialAltitude, computedMach, tropoPause) + VnavConfig.IDLE_N1_MARGIN;
      const initialMach = Math.min(this.atmosphericConditions.computeMachFromCas(initialAltitude, initialSpeed), mach);
      const finalMach = Math.min(this.atmosphericConditions.computeMachFromCas(initialAltitude, finalSpeed), mach);
      return Predictions.speedChangeStep(-1, initialAltitude, initialSpeed, finalSpeed, initialMach, finalMach, predictedN1, zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, gearExtended, flapConfig, speedbrakesExtended, perfFactor);
    }
  }

  /**
   * Valid type arguments for Set/GetSimVarValue
   */var SimVarValueType;(function(SimVarValueType){SimVarValueType["Number"]="number";SimVarValueType["Percent"]="percent";SimVarValueType["Degree"]="degrees";SimVarValueType["Knots"]="knots";SimVarValueType["Feet"]="feet";SimVarValueType["Meters"]="meters";SimVarValueType["FPM"]="feet per minute";SimVarValueType["Radians"]="radians";SimVarValueType["InHG"]="inches of mercury";SimVarValueType["MB"]="Millibars";SimVarValueType["Bool"]="bool";SimVarValueType["Celsius"]="celsius";SimVarValueType["MHz"]="MHz";SimVarValueType["KHz"]="KHz";SimVarValueType["NM"]="nautical mile";SimVarValueType["String"]="string";SimVarValueType["RPM"]="Rpm";SimVarValueType["PPH"]="Pounds per hour";SimVarValueType["GPH"]="gph";SimVarValueType["Farenheit"]="farenheit";SimVarValueType["PSI"]="psi";SimVarValueType["GAL"]="gallons";SimVarValueType["LBS"]="pounds";SimVarValueType["Hours"]="Hours";SimVarValueType["Volts"]="Volts";SimVarValueType["Amps"]="Amperes";SimVarValueType["Seconds"]="seconds";SimVarValueType["Enum"]="enum";SimVarValueType["LLA"]="latlonalt";SimVarValueType["MetersPerSecond"]="meters per second";SimVarValueType["Mach"]="mach";SimVarValueType["Pounds"]="pounds";SimVarValueType["SlugsPerCubicFoot"]="slug per cubic foot";})(SimVarValueType||(SimVarValueType={}));const latlonaltRegEx=new RegExp(/latlonalt/i);const latlonaltpbhRegex=new RegExp(/latlonaltpbh/i);const pbhRegex=new RegExp(/pbh/i);const pid_structRegex=new RegExp(/pid_struct/i);const xyzRegex=new RegExp(/xyz/i);const stringRegex=new RegExp(/string/i);const boolRegex=new RegExp(/boolean|bool/i);const numberRegex=new RegExp(/number/i);const defaultSource='';SimVar.GetSimVarValue=function(name,unit){let dataSource=arguments.length>2&&arguments[2]!==undefined?arguments[2]:defaultSource;try{if(simvar){let output;const registeredID=SimVar.GetRegisteredId(name,unit,dataSource);if(registeredID>=0){if(numberRegex.test(unit)){output=simvar.getValueReg(registeredID);}else if(stringRegex.test(unit)){output=simvar.getValueReg_String(registeredID);}else if(latlonaltRegEx.test(unit)){output=new LatLongAlt(simvar.getValue_LatLongAlt(name,dataSource));}else if(latlonaltpbhRegex.test(unit)){output=new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name,dataSource));}else if(pbhRegex.test(unit)){output=new PitchBankHeading(simvar.getValue_PBH(name,dataSource));}else if(pid_structRegex.test(unit)){output=new PID_STRUCT(simvar.getValue_PID_STRUCT(name,dataSource));}else if(xyzRegex.test(unit)){output=new XYZ(simvar.getValue_XYZ(name,dataSource));}else {output=simvar.getValueReg(registeredID);}}return output;}else {console.warn('SimVar handler is not defined ('+name+')');}}catch(error){console.warn('ERROR ',error,' GetSimVarValue '+name+' unit : '+unit);return null;}return null;};SimVar.SetSimVarValue=function(name,unit,value){let dataSource=arguments.length>3&&arguments[3]!==undefined?arguments[3]:defaultSource;if(value==undefined){console.warn(name+' : Trying to set a null value');return Promise.resolve();}try{if(simvar){const regID=SimVar.GetRegisteredId(name,unit,dataSource);if(regID>=0){if(stringRegex.test(unit)){return Coherent.call('setValueReg_String',regID,value);}else if(boolRegex.test(unit)){return Coherent.call('setValueReg_Bool',regID,!!value);}else if(numberRegex.test(unit)){return Coherent.call('setValueReg_Number',regID,value);}else if(latlonaltRegEx.test(unit)){return Coherent.call('setValue_LatLongAlt',name,value,dataSource);}else if(latlonaltpbhRegex.test(unit)){return Coherent.call('setValue_LatLongAltPBH',name,value,dataSource);}else if(pbhRegex.test(unit)){return Coherent.call('setValue_PBH',name,value,dataSource);}else if(pid_structRegex.test(unit)){return Coherent.call('setValue_PID_STRUCT',name,value,dataSource);}else if(xyzRegex.test(unit)){return Coherent.call('setValue_XYZ',name,value,dataSource);}else {return Coherent.call('setValueReg_Number',regID,value);}}}else {console.warn('SimVar handler is not defined');}}catch(error){console.warn('error SetSimVarValue '+error);}return Promise.resolve();};/**
   * A number with an associated unit. Each NumberUnit is created with a reference unit type,
   * which cannot be changed after instantiation. The reference unit type determines how the
   * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
   * active unit type, which can be dynamically changed at any time.
   */class NumberUnit{/**
       * Constructor.
       * @param number - the initial numeric value of the new NumberUnit.
       * @param unit - the unit type of the new NumberUnit.
       */constructor(number,unit){this._number=number;this._unit=unit;this.readonly=new NumberUnitReadOnly(this);}/**
       * Gets this NumberUnit's numeric value.
       * @returns This NumberUnit's numeric value.
       */get number(){return this._number;}/**
       * Gets this NumberUnit's unit type.
       * @returns This NumberUnit's unit type.
       */get unit(){return this._unit;}/**
       * Converts a value to a numeric value with this NumberUnit's unit type.
       * @param value - the value.
       * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
       * value is a NumberUnit.
       * @returns the numeric of the value with this NumberUnit's unit type.
       */toNumberOfThisUnit(value,unit){if(typeof value!=='number'&&this.unit.canConvert(value.unit)){return this.unit.convertFrom(value.number,value.unit);}if(typeof value==='number'&&(!unit||this.unit.canConvert(unit))){return unit?this.unit.convertFrom(value,unit):value;}return undefined;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,arg2){const converted=this.toNumberOfThisUnit(arg1,arg2);if(converted!==undefined){this._number=converted;return this;}throw new Error('Invalid unit conversion attempted.');}// eslint-disable-next-line jsdoc/require-jsdoc
  add(arg1,arg2,arg3){const isArg2NumberUnit=arg2 instanceof NumberUnit;const converted=this.toNumberOfThisUnit(arg1,isArg2NumberUnit?undefined:arg2);if(converted!==undefined){let out=isArg2NumberUnit?arg2:arg3;if(out){out.set(this.number+converted,this.unit);}else {// eslint-disable-next-line @typescript-eslint/no-this-alias
  out=this;this._number+=converted;}return out;}throw new Error('Invalid unit conversion attempted.');}// eslint-disable-next-line jsdoc/require-jsdoc
  subtract(arg1,arg2,arg3){const isArg2NumberUnit=arg2 instanceof NumberUnit;const converted=this.toNumberOfThisUnit(arg1,isArg2NumberUnit?undefined:arg2);if(converted!==undefined){let out=isArg2NumberUnit?arg2:arg3;if(out){out.set(this.number-converted,this.unit);}else {// eslint-disable-next-line @typescript-eslint/no-this-alias
  out=this;this._number-=converted;}return out;}throw new Error('Invalid unit conversion attempted.');}// eslint-disable-next-line jsdoc/require-jsdoc
  scale(factor,out){if(out){return out.set(this.number*factor,this.unit);}else {this._number*=factor;return this;}}// eslint-disable-next-line jsdoc/require-jsdoc
  ratio(value,unit){const converted=this.toNumberOfThisUnit(value,unit);if(converted){return this.number/converted;}throw new Error('Invalid unit conversion attempted.');}// eslint-disable-next-line jsdoc/require-jsdoc
  abs(out){if(out){return out.set(Math.abs(this.number),this.unit);}else {this._number=Math.abs(this._number);return this;}}/**
       * Returns the numeric value of this NumberUnit after conversion to a specified unit.
       * @param unit The unit to which to convert.
       * @returns The converted numeric value.
       * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
       */asUnit(unit){return this.unit.convertTo(this.number,unit);}// eslint-disable-next-line jsdoc/require-jsdoc
  compare(value,unit){const converted=this.toNumberOfThisUnit(value,unit);if(converted===undefined){throw new Error('Invalid unit conversion attempted.');}const diff=this.number-converted;if(Math.abs(diff)<1e-14){return 0;}return Math.sign(diff);}// eslint-disable-next-line jsdoc/require-jsdoc
  equals(value,unit){const converted=this.toNumberOfThisUnit(value,unit);if(converted===undefined){return false;}if(isNaN(converted)&&this.isNaN()){return true;}const diff=this.number-converted;return !isNaN(diff)&&Math.abs(diff)<1e-14;}/**
       * Checks whether this NumberUnit has a numeric value of NaN.
       * @returns Whether this NumberUnit has a numeric value of NaN.
       */isNaN(){return isNaN(this.number);}/**
       * Copies this NumberUnit.
       * @returns A copy of this NumberUnit.
       */copy(){return new NumberUnit(this.number,this.unit);}}/**
   * A read-only interface for a WT_NumberUnit.
   */class NumberUnitReadOnly{/**
       * Constructor.
       * @param source - the source of the new read-only NumberUnit.
       */constructor(source){this.source=source;}/**
       * Gets this NumberUnit's numeric value.
       * @returns This NumberUnit's numeric value.
       */get number(){return this.source.number;}/**
       * Gets this NumberUnit's unit type.
       * @returns This NumberUnit's unit type.
       */get unit(){return this.source.unit;}// eslint-disable-next-line jsdoc/require-jsdoc
  add(arg1,arg2,arg3){const isArg2NumberUnit=arg2 instanceof NumberUnit;const out=isArg2NumberUnit?arg2:arg3;if(typeof arg1==='number'){return this.source.add(arg1,arg2,out);}else {return this.source.add(arg1,out);}}// eslint-disable-next-line jsdoc/require-jsdoc
  subtract(arg1,arg2,arg3){const isArg2NumberUnit=arg2 instanceof NumberUnit;const out=isArg2NumberUnit?arg2:arg3;if(typeof arg1==='number'){return this.source.subtract(arg1,arg2,out);}else {return this.source.subtract(arg1,out);}}/**
       * Scales this NumberUnit by a unit-less factor and returns the result.
       * @param factor The factor by which to scale.
       * @param out The NumberUnit to which to write the result.
       * @returns The scaled value.
       */scale(factor,out){return this.source.scale(factor,out);}// eslint-disable-next-line jsdoc/require-jsdoc
  ratio(arg1,arg2){if(typeof arg1==='number'){return this.source.ratio(arg1,arg2);}else {return this.source.ratio(arg1);}}/**
       * Calculates the absolute value of this NumberUnit and returns the result.
       * @param out The NumberUnit to which to write the result.
       * @returns The absolute value.
       */abs(out){return this.source.abs(out);}/**
       * Returns the numeric value of this NumberUnit after conversion to a specified unit.
       * @param unit The unit to which to convert.
       * @returns The converted numeric value.
       * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
       */asUnit(unit){return this.source.asUnit(unit);}// eslint-disable-next-line jsdoc/require-jsdoc
  compare(arg1,arg2){if(typeof arg1==='number'){return this.source.compare(arg1,arg2);}else {return this.source.compare(arg1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  equals(arg1,arg2){if(typeof arg1==='number'){return this.source.equals(arg1,arg2);}else {return this.source.equals(arg1);}}/**
       * Checks whether this NumberUnit has a numeric value of NaN.
       * @returns Whether this NumberUnit has a numeric value of NaN.
       */isNaN(){return this.source.isNaN();}/**
       * Copies this NumberUnit.
       * @returns A copy of this NumberUnit.
       */copy(){return this.source.copy();}}/**
   * A unit of measurement.
   */class AbstractUnit{/**
       * Constructor.
       * @param name The name of this unit.
       */constructor(name){this.name=name;}/** @inheritdoc */canConvert(otherUnit){return this.family===otherUnit.family;}/** @inheritdoc */createNumber(value){return new NumberUnit(value,this);}/** @inheritdoc */equals(other){return this.family===other.family&&this.name===other.name;}}/**
   * A unit that can be converted to another unit of the same type via a fixed linear transformation.
   */class SimpleUnit extends AbstractUnit{/**
       * Constructor.
       * @param family The family to which this unit belongs.
       * @param name The name of this unit.
       * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
       * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
       */constructor(family,name,scaleFactor){let zeroOffset=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;super(name);this.family=family;this.scaleFactor=scaleFactor;this.zeroOffset=zeroOffset;}/** @inheritdoc */canConvert(otherUnit){return otherUnit instanceof SimpleUnit&&super.canConvert(otherUnit);}/** @inheritdoc */convertTo(value,toUnit){if(!this.canConvert(toUnit)){throw new Error("Invalid conversion from ".concat(this.name," to ").concat(toUnit.name,"."));}return (value+this.zeroOffset)*(this.scaleFactor/toUnit.scaleFactor)-toUnit.zeroOffset;}/** @inheritdoc */convertFrom(value,fromUnit){if(!this.canConvert(fromUnit)){throw new Error("Invalid conversion from ".concat(fromUnit.name," to ").concat(this.name,"."));}return (value+fromUnit.zeroOffset)*(fromUnit.scaleFactor/this.scaleFactor)-this.zeroOffset;}}/**
   * A unit of measure composed of the multiplicative combination of multiple elementary units.
   */class CompoundUnit extends AbstractUnit{/**
       * Constructor.
       * @param family The family to which this unit belongs.
       * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
       * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
       * @param name The name of this unit. If not defined, one will be automatically generated.
       */constructor(family,numerator,denominator,name){// if not specified, build name from component units.
  if(name===undefined){name='';let i=0;while(i<numerator.length-1){name+="".concat(numerator[i++].name,"-");}name+="".concat(numerator[i].name);if(denominator.length>0){name+=' per ';i=0;while(i<denominator.length-1){name+="".concat(denominator[i++].name,"-");}name+="".concat(denominator[i].name);}}super(name);this.family=family;this.numerator=Array.from(numerator);this.denominator=Array.from(denominator);this.numerator.sort((a,b)=>a.family.localeCompare(b.family));this.denominator.sort((a,b)=>a.family.localeCompare(b.family));this.scaleFactor=this.getScaleFactor();}/**
       * Gets the scale factor for this unit.
       * @returns the scale factor for this unit.
       */getScaleFactor(){let factor=1;factor=this.numerator.reduce((prev,curr)=>prev*curr.scaleFactor,factor);factor=this.denominator.reduce((prev,curr)=>prev/curr.scaleFactor,factor);return factor;}/** @inheritdoc */canConvert(otherUnit){return otherUnit instanceof CompoundUnit&&super.canConvert(otherUnit);}/** @inheritdoc */convertTo(value,toUnit){if(!this.canConvert(toUnit)){throw new Error("Invalid conversion from ".concat(this.name," to ").concat(toUnit.name,"."));}return value*(this.scaleFactor/toUnit.scaleFactor);}/** @inheritdoc */convertFrom(value,fromUnit){if(!this.canConvert(fromUnit)){throw new Error("Invalid conversion from ".concat(fromUnit.name," to ").concat(this.name,"."));}return value*(fromUnit.scaleFactor/this.scaleFactor);}}/**
   * Predefined unit families.
   */var UnitFamily;(function(UnitFamily){UnitFamily["Distance"]="distance";UnitFamily["Angle"]="angle";UnitFamily["Duration"]="duration";UnitFamily["Weight"]="weight";UnitFamily["Volume"]="volume";UnitFamily["Pressure"]="pressure";UnitFamily["Temperature"]="temperature";UnitFamily["TemperatureDelta"]="temperature_delta";UnitFamily["Speed"]="speed";UnitFamily["Acceleration"]="acceleration";UnitFamily["WeightFlux"]="weight_flux";UnitFamily["VolumeFlux"]="volume_flux";})(UnitFamily||(UnitFamily={}));/**
   * Predefined unit types.
   */class UnitType{}UnitType.METER=new SimpleUnit(UnitFamily.Distance,'meter',1);UnitType.FOOT=new SimpleUnit(UnitFamily.Distance,'foot',0.3048);UnitType.KILOMETER=new SimpleUnit(UnitFamily.Distance,'kilometer',1000);/** Statute mile. */UnitType.MILE=new SimpleUnit(UnitFamily.Distance,'mile',1609.34);/** Nautical mile. */UnitType.NMILE=new SimpleUnit(UnitFamily.Distance,'nautical mile',1852);/** Great-arc radian. The average radius of Earth. */UnitType.GA_RADIAN=new SimpleUnit(UnitFamily.Distance,'great arc radian',6378100);UnitType.RADIAN=new SimpleUnit(UnitFamily.Angle,'radian',1);UnitType.DEGREE=new SimpleUnit(UnitFamily.Angle,'degree',Math.PI/180);UnitType.ARC_MIN=new SimpleUnit(UnitFamily.Angle,'minute',Math.PI/180/60);UnitType.ARC_SEC=new SimpleUnit(UnitFamily.Angle,'second',Math.PI/180/3600);UnitType.MILLISECOND=new SimpleUnit(UnitFamily.Duration,'millisecond',0.001);UnitType.SECOND=new SimpleUnit(UnitFamily.Duration,'second',1);UnitType.MINUTE=new SimpleUnit(UnitFamily.Duration,'minute',60);UnitType.HOUR=new SimpleUnit(UnitFamily.Duration,'hour',3600);UnitType.KILOGRAM=new SimpleUnit(UnitFamily.Weight,'kilogram',1);UnitType.POUND=new SimpleUnit(UnitFamily.Weight,'pound',0.453592);UnitType.TON=new SimpleUnit(UnitFamily.Weight,'ton',907.185);UnitType.TONNE=new SimpleUnit(UnitFamily.Weight,'tonne',1000);/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */UnitType.LITER_FUEL=new SimpleUnit(UnitFamily.Weight,'liter',0.80283679);/** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */UnitType.GALLON_FUEL=new SimpleUnit(UnitFamily.Weight,'gallon',3.0390664);/** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */UnitType.IMP_GALLON_FUEL=new SimpleUnit(UnitFamily.Weight,'imperial gallon',3.6497683);UnitType.LITER=new SimpleUnit(UnitFamily.Volume,'liter',1);UnitType.GALLON=new SimpleUnit(UnitFamily.Volume,'gallon',3.78541);/** Hectopascal. */UnitType.HPA=new SimpleUnit(UnitFamily.Pressure,'hectopascal',1);/** Atmosphere. */UnitType.ATM=new SimpleUnit(UnitFamily.Pressure,'atmosphere',1013.25);/** Inch of mercury. */UnitType.IN_HG=new SimpleUnit(UnitFamily.Pressure,'inch of mercury',33.8639);/** Millimeter of mercury. */UnitType.MM_HG=new SimpleUnit(UnitFamily.Pressure,'millimeter of mercury',1.33322);UnitType.KELVIN=new SimpleUnit(UnitFamily.Temperature,'kelvin',1,0);UnitType.CELSIUS=new SimpleUnit(UnitFamily.Temperature,' Celsius',1,273.15);UnitType.FAHRENHEIT=new SimpleUnit(UnitFamily.Temperature,' Fahrenheit',5/9,459.67);UnitType.RANKINE=new SimpleUnit(UnitFamily.Temperature,' Rankine',5/9,0);/** Change in degrees Celsius. */UnitType.DELTA_CELSIUS=new SimpleUnit(UnitFamily.TemperatureDelta,' Celsius',1);/** Change in degrees Fahrenheit. */UnitType.DELTA_FAHRENHEIT=new SimpleUnit(UnitFamily.TemperatureDelta,' Fahrenheit',5/9);UnitType.KNOT=new CompoundUnit(UnitFamily.Speed,[UnitType.NMILE],[UnitType.HOUR],'knot');/** Kilometer per hour. */UnitType.KPH=new CompoundUnit(UnitFamily.Speed,[UnitType.KILOMETER],[UnitType.HOUR]);/** Miles per hour. */UnitType.MPH=new CompoundUnit(UnitFamily.Speed,[UnitType.MILE],[UnitType.HOUR]);/** Meter per minute. */UnitType.MPM=new CompoundUnit(UnitFamily.Speed,[UnitType.METER],[UnitType.MINUTE]);/** Meter per second. */UnitType.MPS=new CompoundUnit(UnitFamily.Speed,[UnitType.METER],[UnitType.SECOND]);/** Foot per minute. */UnitType.FPM=new CompoundUnit(UnitFamily.Speed,[UnitType.FOOT],[UnitType.MINUTE]);/** Foot per second. */UnitType.FPS=new CompoundUnit(UnitFamily.Speed,[UnitType.FOOT],[UnitType.SECOND]);/** Meter per minute per second. */UnitType.MPM_PER_SEC=new CompoundUnit(UnitFamily.Acceleration,[UnitType.METER],[UnitType.MINUTE,UnitType.SECOND]);/** Meter per second per second. */UnitType.MPS_PER_SEC=new CompoundUnit(UnitFamily.Acceleration,[UnitType.METER],[UnitType.SECOND,UnitType.SECOND]);/** Foot per minute per second. */UnitType.FPM_PER_SEC=new CompoundUnit(UnitFamily.Acceleration,[UnitType.FOOT],[UnitType.MINUTE,UnitType.SECOND]);/** Foot per second per second. */UnitType.FPS_PER_SEC=new CompoundUnit(UnitFamily.Acceleration,[UnitType.FOOT],[UnitType.SECOND,UnitType.SECOND]);/** Average gravitational acceleration on Earth at sea level. */UnitType.G_ACCEL=new CompoundUnit(UnitFamily.Acceleration,[new SimpleUnit(UnitFamily.Distance,'9.80665 meter',9.80665)],[UnitType.SECOND,UnitType.SECOND]);/** Kilogram per hour. */UnitType.KGH=new CompoundUnit(UnitFamily.WeightFlux,[UnitType.KILOGRAM],[UnitType.HOUR]);/** Pound per hour. */UnitType.PPH=new CompoundUnit(UnitFamily.WeightFlux,[UnitType.POUND],[UnitType.HOUR]);/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */UnitType.LPH_FUEL=new CompoundUnit(UnitFamily.WeightFlux,[UnitType.LITER_FUEL],[UnitType.HOUR]);/** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */UnitType.GPH_FUEL=new CompoundUnit(UnitFamily.WeightFlux,[UnitType.GALLON_FUEL],[UnitType.HOUR]);/** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */UnitType.IGPH_FUEL=new CompoundUnit(UnitFamily.WeightFlux,[UnitType.IMP_GALLON_FUEL],[UnitType.HOUR]);/**
   * A basic event-bus publisher.
   */class BasePublisher{/**
       * Creates an instance of BasePublisher.
       * @param bus The common event bus.
       * @param pacer An optional pacer to control the rate of publishing.
       */constructor(bus){let pacer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;this.bus=bus;this.publisher=this.bus.getPublisher();this.publishActive=false;this.pacer=pacer;}/**
       * Start publishing.
       */startPublish(){this.publishActive=true;}/**
       * Stop publishing.
       */stopPublish(){this.publishActive=false;}/**
       * Tells whether or not the publisher is currently active.
       * @returns True if the publisher is active, false otherwise.
       */isPublishing(){return this.publishActive;}/**
       * A callback called when the publisher receives an update cycle.
       */onUpdate(){return;}/**
       * Publish a message if publishing is acpive
       * @param topic The topic key to publish to.
       * @param data The data type for chosen topic.
       * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
       * @param isCached Whether or not the event should be cached. Defaults to `true`.
       */publish(topic,data){let sync=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let isCached=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(this.publishActive&&(!this.pacer||this.pacer.canPublish(topic,data))){this.publisher.pub(topic,data,sync,isCached);}}}/**
   * A base class for publishers that need to handle simvars with built-in
   * support for pacing callbacks.
   */class SimVarPublisher extends BasePublisher{/**
       * Create a SimVarPublisher
       * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
       * @param bus The EventBus to use for publishing.
       * @param pacer An optional pacer to control the rate of publishing.
       */constructor(simVarMap,bus,pacer){super(bus,pacer);this.resolvedSimVars=new Map();this.indexedSimVars=new Map();this.subscribed=new Set();for(const[topic,entry]of simVarMap){if(entry.indexed){this.indexedSimVars.set(topic,entry);this.resolveIndexedSimVar(topic,entry);// resolve indexed topic to its non-suffixed form
  }else {this.resolvedSimVars.set(topic,entry);}}const handleSubscribedTopic=topic=>{if(this.resolvedSimVars.has(topic)){// If topic matches an already resolved topic -> start publishing.
  this.onTopicSubscribed(topic);}else {// Check if topic matches indexed topic.
  this.tryMatchIndexedSubscribedTopic(topic);}};// Iterate over each subscribed topic on the bus to see if it matches any of our topics. If so, start publishing.
  this.bus.forEachSubscribedTopic(handleSubscribedTopic);// Listen to first-time topic subscriptions. If any of them match our topics, start publishing.
  this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(handleSubscribedTopic);}/**
       * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
       * publishing the indexed topic.
       * @param topic The subscribed topic to check.
       */tryMatchIndexedSubscribedTopic(topic){if(this.indexedSimVars.size===0){return;}if(!SimVarPublisher.INDEXED_REGEX.test(topic)){// Don't generate an array if we don't have to.
  return;}const match=topic.match(SimVarPublisher.INDEXED_REGEX);const[,matchedTopic,index]=match;const entry=this.indexedSimVars.get(matchedTopic);if(entry){this.onTopicSubscribed(this.resolveIndexedSimVar(matchedTopic,entry,parseInt(index)));}}/**
       * Resolves an indexed topic with an index, generating a version of the topic which is mapped to an indexed simvar.
       * The resolved indexed topic can then be published.
       * @param topic The topic to resolve.
       * @param entry The entry of the topic to resolve.
       * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
       * a suffix) and will be mapped the index-1 version of its simvar.
       * @returns The resolved indexed topic.
       */resolveIndexedSimVar(topic,entry,index){const resolvedTopic=index===undefined?topic:"".concat(topic,"_").concat(index);if(this.resolvedSimVars.has(resolvedTopic)){return resolvedTopic;}this.resolvedSimVars.set(resolvedTopic,{name:entry.name.replace('#index#',"".concat(index!==null&&index!==void 0?index:1)),type:entry.type,map:entry.map});return resolvedTopic;}/**
       * Responds to when one of this publisher's topics is subscribed to for the first time.
       * @param topic The topic that was subscribed to.
       */onTopicSubscribed(topic){if(this.subscribed.has(topic)){return;}this.subscribed.add(topic);// Immediately publish the current value if publishing is active.
  if(this.publishActive){this.publishTopic(topic);}}/**
       * NOOP - For backwards compatibility.
       * @deprecated
       * @param data Key of the event type in the simVarMap
       */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  subscribe(data){return;}/**
       * NOOP - For backwards compatibility.
       * @deprecated
       * @param data Key of the event type in the simVarMap
       */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unsubscribe(data){return;}/**
       * Publish all subscribed data points to the bus.
       */onUpdate(){for(const topic of this.subscribed.values()){this.publishTopic(topic);}}/**
       * Publishes data to the event bus for a topic.
       * @param topic The topic to publish.
       */publishTopic(topic){const value=this.getValue(topic);if(value!==undefined){this.publish(topic,value);}}/**
       * Gets the current value for a topic.
       * @param topic A topic.
       * @returns The current value for the specified topic.
       */getValue(topic){const entry=this.resolvedSimVars.get(topic);if(entry===undefined){return undefined;}return entry.map===undefined?this.getSimVarValue(entry):entry.map(this.getSimVarValue(entry));}/**
       * Gets the value of the SimVar
       * @param entry The SimVar definition entry
       * @returns The value of the SimVar
       */getSimVarValue(entry){const svValue=SimVar.GetSimVarValue(entry.name,entry.type);if(entry.type===SimVarValueType.Bool){return svValue===1;}return svValue;}}SimVarPublisher.INDEXED_REGEX=/(.*)_([1-9]\d*)$/;/**
   * Utility class for manipulating bit flags.
   */class BitFlags{/**
       * Generates a bit flag with a boolean value of true at a specified index.
       * @param index The index of the flag. Must be between 0 and 32, inclusive.
       * @returns a bit flag.
       * @throws Error if index is out of bounds.
       */static createFlag(index){if(index<0||index>32){throw new Error("Invalid index ".concat(index," for bit flag. Index must be between 0 and 32."));}return 1<<index;}/**
       * Gets the inverse of some bit flags.
       * @param flags The bit flag group containing the flags to invert.
       * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
       * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
       * at all indexes.
       * @returns the inverse
       */static not(flags){let mask=arguments.length>1&&arguments[1]!==undefined?arguments[1]:~0;return flags^mask;}/**
       * Gets the union of zero or more bit flags.
       * @param flags A list of bit flags.
       * @returns the union of the bit flags.
       */static union(){let result=0;const len=arguments.length;for(let i=0;i<len;i++){result|=i<0||arguments.length<=i?undefined:arguments[i];}return result;}/**
       * Gets the intersection of zero or more bit flags.
       * @param flags A list of bit flags.
       * @returns the intersection of the bit flags.
       */static intersection(){const len=arguments.length;if(len===0){return 0;}let result=arguments.length<=0?undefined:arguments[0];for(let i=1;i<len;i++){result&=i<0||arguments.length<=i?undefined:arguments[i];}return result;}/**
       * Changes a bit flag group by setting values at specific indexes.
       * @param flags The bit flag group to change.
       * @param valuesToSet A bit flag group containing the values to set.
       * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
       * be set.
       * @returns The result of changing `flags` using the specified values and indexes.
       */static set(flags,valuesToSet,mask){return flags&~mask|valuesToSet&mask;}/**
       * Checks if a bit flag group meets at least one condition from a list of conditions.
       * @param flags A bit flag group.
       * @param conditions The conditions to meet, as a bit flag group.
       * @returns whether the bit flag group meets at least one condition.
       */static isAny(flags,conditions){return (flags&conditions)!==0;}/**
       * Checks if a bit flag group meets all the conditions from a list of conditions.
       * @param flags A bit flag group.
       * @param conditions The conditions to meet, as a bit flag group.
       * @returns whether the bit flag group meets all the conditions.
       */static isAll(flags,conditions){return (flags&conditions)===conditions;}/**
       * Iterates through a bit flag group and executes a callback function once for each flag.
       * @param flags A bit flag group.
       * @param callback A function which will be called once for each flag.
       * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
       * iterated, otherwise all flags will be iterated regardless of their values.
       * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
       * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
       */static forEach(flags,callback,valueFilter,startIndex,endIndex){startIndex=Utils.Clamp(startIndex!==null&&startIndex!==void 0?startIndex:startIndex=0,0,32);endIndex=Utils.Clamp(endIndex!==null&&endIndex!==void 0?endIndex:endIndex=32,0,32);for(let i=startIndex;i<endIndex;i++){const value=(flags&1<<i)!==0;if(valueFilter===undefined||valueFilter===value){callback(value,i,flags);}}}}/**
   * A {@link Subscription} which executes a handler function every time it receives a notification.
   */class HandlerSubscription{/**
       * Constructor.
       * @param handler This subscription's handler. The handler will be called each time this subscription receives a
       * notification from its source.
       * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
       * subscription will not support initial notifications.
       * @param onDestroy A function which is called when this subscription is destroyed.
       */constructor(handler,initialNotifyFunc,onDestroy){this.handler=handler;this.initialNotifyFunc=initialNotifyFunc;this.onDestroy=onDestroy;this._isAlive=true;this._isPaused=false;this.canInitialNotify=initialNotifyFunc!==undefined;}/** @inheritdoc */get isAlive(){return this._isAlive;}/** @inheritdoc */get isPaused(){return this._isPaused;}/**
       * Sends an initial notification to this subscription.
       * @throws Error if this subscription is not alive.
       */initialNotify(){if(!this._isAlive){throw new Error('HandlerSubscription: cannot notify a dead Subscription.');}this.initialNotifyFunc&&this.initialNotifyFunc(this);}/** @inheritdoc */pause(){if(!this._isAlive){throw new Error('Subscription: cannot pause a dead Subscription.');}this._isPaused=true;return this;}/** @inheritdoc */resume(){let initialNotify=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(!this._isAlive){throw new Error('Subscription: cannot resume a dead Subscription.');}if(!this._isPaused){return this;}this._isPaused=false;if(initialNotify){this.initialNotify();}return this;}/** @inheritdoc */destroy(){if(!this._isAlive){return;}this._isAlive=false;this.onDestroy&&this.onDestroy(this);}}/**
   * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
   * to change the state of the output subscribable.
   */class SubscribablePipe extends HandlerSubscription{// eslint-disable-next-line jsdoc/require-jsdoc
  constructor(from,to,arg3,arg4){let handler;let onDestroy;if(typeof arg4==='function'){handler=fromVal=>{to.set(arg3(fromVal,to.get()));};onDestroy=arg4;}else {handler=fromVal=>{to.set(fromVal);};onDestroy=arg3;}super(handler,sub=>{sub.handler(from.get());},onDestroy);}}/**
   * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
   */class AbstractSubscribable{constructor(){this.isSubscribable=true;this.subs=[];this.notifyDepth=0;/** A function which sends initial notifications to subscriptions. */this.initialNotifyFunc=this.notifySubscription.bind(this);/** A function which responds to when a subscription to this subscribable is destroyed. */this.onSubDestroyedFunc=this.onSubDestroyed.bind(this);}/** @inheritdoc */sub(handler){let initialNotify=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let paused=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const sub=new HandlerSubscription(handler,this.initialNotifyFunc,this.onSubDestroyedFunc);this.subs.push(sub);if(paused){sub.pause();}else if(initialNotify){sub.initialNotify();}return sub;}/** @inheritdoc */unsub(handler){const toDestroy=this.subs.find(sub=>sub.handler===handler);toDestroy===null||toDestroy===void 0?void 0:toDestroy.destroy();}/**
       * Notifies subscriptions that this subscribable's value has changed.
       */notify(){let needCleanUpSubs=false;this.notifyDepth++;const subLen=this.subs.length;for(let i=0;i<subLen;i++){try{const sub=this.subs[i];if(sub.isAlive&&!sub.isPaused){this.notifySubscription(sub);}needCleanUpSubs||(needCleanUpSubs=!sub.isAlive);}catch(error){console.error("AbstractSubscribable: error in handler: ".concat(error));if(error instanceof Error){console.error(error.stack);}}}this.notifyDepth--;if(needCleanUpSubs&&this.notifyDepth===0){this.subs=this.subs.filter(sub=>sub.isAlive);}}/**
       * Notifies a subscription of this subscribable's current state.
       * @param sub The subscription to notify.
       */notifySubscription(sub){sub.handler(this.get());}/**
       * Responds to when a subscription to this subscribable is destroyed.
       * @param sub The destroyed subscription.
       */onSubDestroyed(sub){// If we are not in the middle of a notify operation, remove the subscription.
  // Otherwise, do nothing and let the post-notify clean-up code handle it.
  if(this.notifyDepth===0){this.subs.splice(this.subs.indexOf(sub),1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  map(fn,equalityFunc,mutateFunc,initialVal){return new MappedSubscribableClass(this,fn,equalityFunc!==null&&equalityFunc!==void 0?equalityFunc:AbstractSubscribable.DEFAULT_EQUALITY_FUNC,mutateFunc,initialVal);}// eslint-disable-next-line jsdoc/require-jsdoc
  pipe(to,arg2,arg3){let sub;let paused;if(typeof arg2==='function'){sub=new SubscribablePipe(this,to,arg2,this.onSubDestroyedFunc);paused=arg3!==null&&arg3!==void 0?arg3:false;}else {sub=new SubscribablePipe(this,to,this.onSubDestroyedFunc);paused=arg2!==null&&arg2!==void 0?arg2:false;}this.subs.push(sub);if(paused){sub.pause();}else {sub.initialNotify();}return sub;}}/**
   * Checks if two values are equal using the strict equality operator.
   * @param a The first value.
   * @param b The second value.
   * @returns whether a and b are equal.
   */AbstractSubscribable.DEFAULT_EQUALITY_FUNC=(a,b)=>a===b;/**
   * An implementation of {@link MappedSubscribable}.
   */class MappedSubscribableClass extends AbstractSubscribable{/**
       * Constructor.
       * @param input This subscribable's input.
       * @param mapFunc The function which maps this subject's inputs to a value.
       * @param equalityFunc The function which this subject uses to check for equality between values.
       * @param mutateFunc The function which this subject uses to change its value.
       * @param initialVal The initial value of this subject.
       */constructor(input,mapFunc,equalityFunc,mutateFunc,initialVal){super();this.input=input;this.mapFunc=mapFunc;this.equalityFunc=equalityFunc;this.isSubscribable=true;this._isAlive=true;this._isPaused=false;if(initialVal&&mutateFunc){this.value=initialVal;mutateFunc(this.value,this.mapFunc(this.input.get()));this.mutateFunc=newVal=>{mutateFunc(this.value,newVal);};}else {this.value=this.mapFunc(this.input.get());this.mutateFunc=newVal=>{this.value=newVal;};}this.inputSub=this.input.sub(inputValue=>{this.updateValue(inputValue);},true);}/** @inheritdoc */get isAlive(){return this._isAlive;}/** @inheritdoc */get isPaused(){return this._isPaused;}/**
       * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
       * value according to this subject's equality function.
       * @param inputValue The input value.
       */updateValue(inputValue){const value=this.mapFunc(inputValue,this.value);if(!this.equalityFunc(this.value,value)){this.mutateFunc(value);this.notify();}}/** @inheritdoc */get(){return this.value;}/** @inheritdoc */pause(){if(!this._isAlive){throw new Error('MappedSubscribable: cannot pause a dead subscribable');}if(this._isPaused){return this;}this.inputSub.pause();this._isPaused=true;return this;}/** @inheritdoc */resume(){if(!this._isAlive){throw new Error('MappedSubscribable: cannot resume a dead subscribable');}if(!this._isPaused){return this;}this._isPaused=false;this.inputSub.resume(true);return this;}/** @inheritdoc */destroy(){this._isAlive=false;this.inputSub.destroy();}}/**
   * 2D vector mathematical operations.
   */class Vec2Math{// eslint-disable-next-line jsdoc/require-jsdoc
  static create(x,y){const vec=new Float64Array(2);if(x!==undefined&&y!==undefined){vec[0]=x;vec[1]=y;}return vec;}/**
       * Gets the polar angle theta of a vector in radians.
       * @param vec - a vector.
       * @returns the polar angle theta of the vector.
       */static theta(vec){return Math.atan2(vec[1],vec[0]);}/**
       * Sets the components of a vector.
       * @param x - the new x-component.
       * @param y - the new y-component.
       * @param vec - the vector to change.
       * @returns the vector after it has been changed.
       */static set(x,y,vec){vec[0]=x;vec[1]=y;return vec;}/**
       * Sets the polar components of a vector.
       * @param r - the new length (magnitude).
       * @param theta - the new polar angle theta, in radians.
       * @param vec - the vector to change.
       * @returns the vector after it has been changed.
       */static setFromPolar(r,theta,vec){vec[0]=r*Math.cos(theta);vec[1]=r*Math.sin(theta);return vec;}/**
       * Add one vector to another.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @param out The vector to write the results to.
       * @returns the vector sum.
       */static add(v1,v2,out){out[0]=v1[0]+v2[0];out[1]=v1[1]+v2[1];return out;}/**
       * Subtracts one vector from another.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @param out The vector to write the results to.
       * @returns the vector difference.
       */static sub(v1,v2,out){out[0]=v1[0]-v2[0];out[1]=v1[1]-v2[1];return out;}/**
       * Gets the dot product of two vectors.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @returns The dot product of the vectors.
       */static dot(v1,v2){return v1[0]*v2[0]+v1[1]*v2[1];}/**
       * Multiplies a vector by a scalar.
       * @param v1 The vector to multiply.
       * @param scalar The scalar to apply.
       * @param out The vector to write the results to.
       * @returns The scaled vector.
       */static multScalar(v1,scalar,out){out[0]=v1[0]*scalar;out[1]=v1[1]*scalar;return out;}/**
       * Gets the magnitude of a vector.
       * @param v1 The vector to get the magnitude for.
       * @returns the vector's magnitude.
       */static abs(v1){return Math.hypot(v1[0],v1[1]);}/**
       * Normalizes the vector to a unit vector.
       * @param v1 The vector to normalize.
       * @param out The vector to write the results to.
       * @returns the normalized vector.
       */static normalize(v1,out){const mag=Vec2Math.abs(v1);out[0]=v1[0]/mag;out[1]=v1[1]/mag;return out;}/**
       * Gets the normal of the supplied vector.
       * @param v1 The vector to get the normal for.
       * @param out The vector to write the results to.
       * @param counterClockwise Whether or not to get the counterclockwise normal.
       * @returns the normal vector.
       */static normal(v1,out){let counterClockwise=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const x=v1[0];const y=v1[1];if(!counterClockwise){out[0]=y;out[1]=-x;}else {out[0]=-y;out[1]=x;}return out;}/**
       * Gets the Euclidean distance between two vectors.
       * @param vec1 The first vector.
       * @param vec2 The second vector.
       * @returns the Euclidean distance between the two vectors.
       */static distance(vec1,vec2){return Math.hypot(vec2[0]-vec1[0],vec2[1]-vec1[1]);}/**
       * Checks if two vectors are equal.
       * @param vec1 The first vector.
       * @param vec2 The second vector.
       * @returns Whether the two vectors are equal.
       */static equals(vec1,vec2){return vec1[0]===vec2[0]&&vec1[1]===vec2[1];}/**
       * Copies one vector to another.
       * @param from The vector from which to copy.
       * @param to The vector to which to copy.
       * @returns The changed vector.
       */static copy(from,to){return Vec2Math.set(from[0],from[1],to);}/**
       * Checks if a point is within a polygon.
       * @param polygon The polygon to check against.
       * @param point The point to test.
       * @returns True if the point is within or on the polygon, false otherwise.
       * @throws An error if first and last points in a polygon are not the same.
       */static pointWithinPolygon(polygon,point){//Adapted from https://github.com/rowanwins/point-in-polygon-hao
  let k=0;let f=0;let u1=0;let v1=0;let u2=0;let v2=0;let currentP=null;let nextP=null;const x=point[0];const y=point[1];const contourLen=polygon.length-1;currentP=polygon[0];if(currentP[0]!==polygon[contourLen][0]&&currentP[1]!==polygon[contourLen][1]){throw new Error('First and last coordinates in a ring must be the same');}u1=currentP[0]-x;v1=currentP[1]-y;for(let i=0;i<polygon.length-1;i++){nextP=polygon[i+1];v2=nextP[1]-y;if(v1<0&&v2<0||v1>0&&v2>0){currentP=nextP;v1=v2;u1=currentP[0]-x;continue;}u2=nextP[0]-point[0];if(v2>0&&v1<=0){f=u1*v2-u2*v1;if(f>0){k=k+1;}else if(f===0){return undefined;}}else if(v1>0&&v2<=0){f=u1*v2-u2*v1;if(f<0){k=k+1;}else if(f===0){return undefined;}}else if(v2===0&&v1<0){f=u1*v2-u2*v1;if(f===0){return undefined;}}else if(v1===0&&v2<0){f=u1*v2-u2*v1;if(f===0){return undefined;}}else if(v1===0&&v2===0){if(u2<=0&&u1>=0){return undefined;}else if(u1<=0&&u2>=0){return undefined;}}currentP=nextP;v1=v2;u1=u2;}if(k%2===0){return false;}return true;}}/**
   * 3D vector mathematical operations.
   */class Vec3Math{// eslint-disable-next-line jsdoc/require-jsdoc
  static create(x,y,z){const vec=new Float64Array(3);if(x!==undefined&&y!==undefined&&z!==undefined){vec[0]=x;vec[1]=y;vec[2]=z;}return vec;}/**
       * Gets the spherical angle theta of a vector in radians.
       * @param vec - a vector.
       * @returns the spherical angle theta of the vector.
       */static theta(vec){return Math.atan2(Math.hypot(vec[0],vec[1]),vec[2]);}/**
       * Gets the spherical angle phi of a vector in radians.
       * @param vec - a vector.
       * @returns the spherical angle phi of the vector.
       */static phi(vec){return Math.atan2(vec[1],vec[0]);}/**
       * Sets the components of a vector.
       * @param x - the new x-component.
       * @param y - the new y-component.
       * @param z - the new z-component.
       * @param vec - the vector to change.
       * @returns the vector after it has been changed.
       */static set(x,y,z,vec){vec[0]=x;vec[1]=y;vec[2]=z;return vec;}/**
       * Sets the spherical components of a vector.
       * @param r - the new length (magnitude).
       * @param theta - the new spherical angle theta, in radians.
       * @param phi - the new spherical angle phi, in radians.
       * @param vec - the vector to change.
       * @returns the vector after it has been changed.
       */static setFromSpherical(r,theta,phi,vec){const sinTheta=Math.sin(theta);vec[0]=sinTheta*Math.cos(phi);vec[1]=sinTheta*Math.sin(phi);vec[2]=Math.cos(theta);return vec;}/**
       * Add one vector to another.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @param out The vector to write the results to.
       * @returns the vector sum.
       */static add(v1,v2,out){out[0]=v1[0]+v2[0];out[1]=v1[1]+v2[1];out[2]=v1[2]+v2[2];return out;}/**
       * Subtracts one vector from another.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @param out The vector to write the results to.
       * @returns the vector difference.
       */static sub(v1,v2,out){out[0]=v1[0]-v2[0];out[1]=v1[1]-v2[1];out[2]=v1[2]-v2[2];return out;}/**
       * Gets the dot product of two vectors.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @returns The dot product of the vectors.
       */static dot(v1,v2){return v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2];}/**
       * Gets the cross product of two vectors.
       * @param v1 - the first vector.
       * @param v2 - the second vector.
       * @param out - the vector to which to write the result.
       * @returns the cross product.
       */static cross(v1,v2,out){const x1=v1[0];const y1=v1[1];const z1=v1[2];const x2=v2[0];const y2=v2[1];const z2=v2[2];out[0]=y1*z2-z1*y2;out[1]=z1*x2-x1*z2;out[2]=x1*y2-y1*x2;return out;}/**
       * Multiplies a vector by a scalar.
       * @param v1 The vector to multiply.
       * @param scalar The scalar to apply.
       * @param out The vector to write the results to.
       * @returns The scaled vector.
       */static multScalar(v1,scalar,out){out[0]=v1[0]*scalar;out[1]=v1[1]*scalar;out[2]=v1[2]*scalar;return out;}/**
       * Gets the magnitude of a vector.
       * @param v1 The vector to get the magnitude for.
       * @returns the vector's magnitude.
       */static abs(v1){return Math.hypot(v1[0],v1[1],v1[2]);}/**
       * Normalizes the vector to a unit vector.
       * @param v1 The vector to normalize.
       * @param out The vector to write the results to.
       * @returns the normalized vector.
       */static normalize(v1,out){const mag=Vec3Math.abs(v1);out[0]=v1[0]/mag;out[1]=v1[1]/mag;out[2]=v1[2]/mag;return out;}/**
       * Gets the Euclidean distance between two vectors.
       * @param vec1 The first vector.
       * @param vec2 The second vector.
       * @returns the Euclidean distance between the two vectors.
       */static distance(vec1,vec2){return Math.hypot(vec2[0]-vec1[0],vec2[1]-vec1[0],vec2[2]-vec1[2]);}/**
       * Checks if two vectors are equal.
       * @param vec1 The first vector.
       * @param vec2 The second vector.
       * @returns Whether the two vectors are equal.
       */static equals(vec1,vec2){return vec1[0]===vec2[0]&&vec1[1]===vec2[1]&&vec1[2]===vec2[2];}/**
       * Copies one vector to another.
       * @param from The vector from which to copy.
       * @param to The vector to which to copy.
       * @returns the changed vector.
       */static copy(from,to){return Vec3Math.set(from[0],from[1],from[2],to);}}/**
   * N-dimensional vector mathematical operations.
   */class VecNMath{// eslint-disable-next-line jsdoc/require-jsdoc
  static create(length){const vec=new Float64Array(length);for(let i=0;i<length&&(arguments.length<=1?0:arguments.length-1);i++){vec[i]=i+1<1||arguments.length<=i+1?undefined:arguments[i+1];}return vec;}/**
       * Sets the components of a vector.
       * @param vec The vector to change.
       * @param components The new components.
       * @returns The vector after it has been changed.
       */static set(vec){for(let i=0;i<vec.length&&(arguments.length<=1?0:arguments.length-1);i++){vec[i]=i+1<1||arguments.length<=i+1?undefined:arguments[i+1];}return vec;}/**
       * Gets the magnitude of a vector.
       * @param vec The vector to get the magnitude for.
       * @returns The vector's magnitude.
       */static abs(vec){return Math.hypot(...vec);}/**
       * Gets the dot product of two vectors.
       * @param v1 The first vector.
       * @param v2 The second vector.
       * @returns The dot product of the vectors.
       * @throws Error if the two vectors are of unequal lengths.
       */static dot(v1,v2){if(v1.length!==v2.length){throw new Error("VecNMath: cannot compute dot product of two vectors of unequal length (".concat(v1.length," and ").concat(v2.length,")"));}let dot=0;const len=v1.length;for(let i=0;i<len;i++){dot+=v1[i]*v2[i];}return dot;}/**
       * Normalizes a vector to a unit vector.
       * @param v1 The vector to normalize.
       * @param out The vector to write the results to.
       * @returns The normalized vector.
       */static normalize(v1,out){const mag=Vec3Math.abs(v1);const len=v1.length;for(let i=0;i<len;i++){out[i]=v1[i]/mag;}return out;}/**
       * Checks if two vectors are equal.
       * @param vec1 The first vector.
       * @param vec2 The second vector.
       * @returns Whether the two vectors are equal.
       */static equals(vec1,vec2){if(vec1.length!==vec2.length){return false;}for(let i=0;i<vec1.length;i++){if(vec1[i]!==vec2[i]){return false;}}return true;}/**
       * Copies one vector to another.
       * @param from The vector from which to copy.
       * @param to The vector to which to copy.
       * @returns The changed vector.
       * @throws Error if the vectors are of unequal lengths.
       */static copy(from,to){if(from.length!==to.length){throw new Error("VecNMath: cannot copy a vector of length ".concat(from.length," to a vector of length ").concat(to.length));}to.set(from);return to;}}/**
   * A Subject which allows a 2D vector to be observed.
   */class Vec2Subject extends AbstractSubscribable{/**
       * Constructor.
       * @param value The value of this subject.
       */constructor(value){super();this.value=value;/** @inheritdoc */this.isMutableSubscribable=true;}/**
       * Creates a Vec2Subject.
       * @param initialVal The initial value.
       * @returns A Vec2Subject.
       */static create(initialVal){return new Vec2Subject(initialVal);}/**
       * Creates a Vec2Subject.
       * @param initialVal The initial value.
       * @returns A Vec2Subject.
       * @deprecated Use `Vec2Subject.create()` instead.
       */static createFromVector(initialVal){return new Vec2Subject(initialVal);}/** @inheritdoc */get(){return this.value;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,arg2){let x,y;if(typeof arg1==='number'){x=arg1;y=arg2;}else {x=arg1[0];y=arg1[1];}const equals=x===this.value[0]&&y===this.value[1];if(!equals){Vec2Math.set(x,y,this.value);this.notify();}}}/**
   * A Subject which allows a N-D vector to be observed.
   */class VecNSubject extends AbstractSubscribable{/**
       * Constructor.
       * @param value The value of this subject.
       */constructor(value){super();this.value=value;/** @inheritdoc */this.isMutableSubscribable=true;}/**
       * Creates a VecNSubject.
       * @param initialVal The initial value.
       * @returns A VecNSubject.
       */static create(initialVal){return new VecNSubject(initialVal);}/**
       * Creates a VecNSubject.
       * @param initialVal The initial value.
       * @returns A VecNSubject.
       * @deprecated Use `VecNSubject.create()` instead.
       */static createFromVector(initialVal){return new VecNSubject(initialVal);}/** @inheritdoc */get(){return this.value;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1){let array;if(typeof arg1==='number'){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}array=args;args.unshift(arg1);}else {array=arg1;}if(array.length>this.value.length){throw new RangeError("VecNSubject: Cannot set ".concat(array.length," components on a vector of length ").concat(this.value.length));}let equals=true;const len=array.length;for(let i=0;i<len;i++){if(array[i]!==this.value[i]){equals=false;break;}}if(!equals){this.value.set(array);this.notify();}}}/**
   * A subscribable subject whose value can be freely manipulated.
   */class Subject extends AbstractSubscribable{/**
       * Constructs an observable Subject.
       * @param value The initial value.
       * @param equalityFunc The function to use to check for equality.
       * @param mutateFunc The function to use to mutate the subject's value.
       */constructor(value,equalityFunc,mutateFunc){super();this.value=value;this.equalityFunc=equalityFunc;this.mutateFunc=mutateFunc;this.isMutableSubscribable=true;}/**
       * Creates and returns a new Subject.
       * @param v The initial value of the subject.
       * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
       * equality comparison (`===`).
       * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
       * old values by variable assignment.
       * @returns A Subject instance.
       */static create(v,equalityFunc,mutateFunc){return new Subject(v,equalityFunc!==null&&equalityFunc!==void 0?equalityFunc:Subject.DEFAULT_EQUALITY_FUNC,mutateFunc);}/** @inheritdoc */notifySub(sub){sub(this.value);}/**
       * Sets the value of this subject and notifies subscribers if the value changed.
       * @param value The new value.
       */set(value){if(!this.equalityFunc(value,this.value)){if(this.mutateFunc){this.mutateFunc(this.value,value);}else {this.value=value;}this.notify();}}/**
       * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
       * result.
       * @param value The properties to apply.
       */apply(value){let changed=false;for(const prop in value){changed=value[prop]!==this.value[prop];if(changed){break;}}Object.assign(this.value,value);changed&&this.notify();}/** @inheritdoc */notify(){super.notify();}/**
       * Gets the value of this subject.
       * @returns The value of this subject.
       */get(){return this.value;}}/**
   * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
   */class Transform2D{constructor(){this.array=new Float64Array([1,0,0,0,1,0]);}/**
       * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
       * @returns The parameters of this transformation.
       */getParameters(){return this.array;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,skewX,translateX,skewY,scaleY,translateY){let scaleX=arg1;if(arg1 instanceof Transform2D){[scaleX,skewX,translateX,skewY,scaleY,translateY]=arg1.array;}const array=this.array;array[0]=scaleX;array[1]=skewX;array[2]=translateX;array[3]=skewY;array[4]=scaleY;array[5]=translateY;return this;}/**
       * Sets the x scaling factor of this transformation.
       * @param value The new x scaling factor.
       * @returns This transformation, after it has been changed.
       */setScaleX(value){this.array[0]=value;return this;}/**
       * Sets the y scaling factor of this transformation.
       * @param value The new y scaling factor.
       * @returns This transformation, after it has been changed.
       */setScaleY(value){this.array[4]=value;return this;}/**
       * Sets the x and y scaling factors of this transformation.
       * @param x The new x scaling factor.
       * @param y The new y scaling factor.
       * @returns This transformation, after it has been changed.
       */setScale(x,y){this.array[0]=x;this.array[4]=y;return this;}/**
       * Sets the x skew factor of this transformation.
       * @param value The new x skew factor.
       * @returns This transformation, after it has been changed.
       */setSkewX(value){this.array[1]=value;return this;}/**
       * Sets the y skew factor of this transformation.
       * @param value The new y skew factor.
       * @returns This transformation, after it has been changed.
       */setSkewY(value){this.array[3]=value;return this;}/**
       * Sets the x translation of this transformation.
       * @param value The new x translation.
       * @returns This transformation, after it has been changed.
       */setTranslateX(value){this.array[2]=value;return this;}/**
       * Sets the y translation of this transformation.
       * @param value The new y translation.
       * @returns This transformation, after it has been changed.
       */setTranslateY(value){this.array[5]=value;return this;}/**
       * Sets the x and y translations of this transformation.
       * @param x The new x translation.
       * @param y The new y translation.
       * @returns This transformation, after it has been changed.
       */setTranslate(x,y){this.array[2]=x;this.array[5]=y;return this;}/**
       * Inverts this transformation.
       * @returns This transformation, after it has been inverted.
       */invert(){const array=this.array;const e_00=array[0];const e_01=array[1];const e_02=array[2];const e_10=array[3];const e_11=array[4];const e_12=array[5];const i_00=e_11;const i_01=-e_10;const i_10=-e_01;const i_11=e_00;const i_20=e_01*e_12-e_02*e_11;const i_21=-(e_00*e_12-e_02*e_10);const det=e_00*i_00+e_01*i_01;return this.set(i_00/det,i_10/det,i_20/det,i_01/det,i_11/det,i_21/det);}/**
       * Copies this transformation.
       * @returns A copy of this transformation.
       */copy(){return new Transform2D().set(this);}/**
       * Applies this transformation to a 2D vector.
       * @param vec A 2D vector.
       * @param out The vector to which to write the result.
       * @returns The result of applying this transformation to `vec`.
       */apply(vec,out){const array=this.array;const x=vec[0]*array[0]+vec[1]*array[1]+array[2];const y=vec[0]*array[3]+vec[1]*array[4]+array[5];return Vec2Math.set(x,y,out);}/**
       * Changes this transformation to the one that is the result of offsetting this transformation's origin.
       * @param x The x-coordinate of the offset origin.
       * @param y The y-coordinate of the offset origin.
       * @returns This transformation, after it has been changed.
       */offsetOrigin(x,y){Transform2D.offsetOriginCache[0].toTranslation(-x,-y);Transform2D.offsetOriginCache[1]=this;Transform2D.offsetOriginCache[2].toTranslation(x,y);return Transform2D.concat(this,Transform2D.offsetOriginCache);}/**
       * Sets this transformation to the identity transformation.
       * @returns This transformation, after it has been changed.
       */toIdentity(){return this.set(1,0,0,0,1,0);}/**
       * Sets this transformation to a translation.
       * @param x The x translation.
       * @param y The y translation.
       * @returns This transformation, after it has been changed.
       */toTranslation(x,y){return this.set(1,0,x,0,1,y);}// eslint-disable-next-line jsdoc/require-jsdoc
  toScale(x,y,originX,originY){this.set(x,0,0,0,y,0);if(originX!==undefined&&originY!==undefined){this.offsetOrigin(originX,originY);}return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  toRotation(theta,originX,originY){const sin=Math.sin(theta);const cos=Math.cos(theta);this.set(cos,-sin,0,sin,cos,0);if(originX!==undefined&&originY!==undefined){this.offsetOrigin(originX,originY);}return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  toReflection(theta,originX,originY){const sin=Math.sin(2*theta);const cos=Math.cos(2*theta);this.set(cos,sin,0,sin,-cos,0);if(originX!==undefined&&originY!==undefined){this.offsetOrigin(originX,originY);}return this;}/**
       * Adds a translation to this transformation.
       * @param x The x translation.
       * @param y The y translation.
       * @param order The order in which to add the translation, relative to this existing transformation, either
       * `'before'` or `'after'`. Defaults to `'after'`.
       * @returns This transformation, after it has been changed.
       */addTranslation(x,y){let order=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'after';if(order==='before'){Transform2D.addCache[0].toTranslation(x,y);Transform2D.addCache[1].set(this);}else {Transform2D.addCache[0].set(this);Transform2D.addCache[1].toTranslation(x,y);}return Transform2D.concat(this,Transform2D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addScale(x,y,arg3,arg4,arg5){let originX,originY,order;if(typeof arg3==='number'){originX=arg3;originY=arg4;order=arg5;}else {order=arg3;}if(order==='before'){originX===undefined?Transform2D.addCache[0].toScale(x,y):Transform2D.addCache[0].toScale(x,y,originX,originY);Transform2D.addCache[1].set(this);}else {Transform2D.addCache[0].set(this);originX===undefined?Transform2D.addCache[1].toScale(x,y):Transform2D.addCache[1].toScale(x,y,originX,originY);}return Transform2D.concat(this,Transform2D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addRotation(theta,arg2,arg3,arg4){let originX,originY,order;if(typeof arg2==='number'){originX=arg2;originY=arg3;order=arg4;}else {order=arg2;}if(order==='before'){originX===undefined?Transform2D.addCache[0].toRotation(theta):Transform2D.addCache[0].toRotation(theta,originX,originY);Transform2D.addCache[1].set(this);}else {Transform2D.addCache[0].set(this);originX===undefined?Transform2D.addCache[1].toRotation(theta):Transform2D.addCache[1].toRotation(theta,originX,originY);}return Transform2D.concat(this,Transform2D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addReflection(theta,arg2,arg3,arg4){let originX,originY,order;if(typeof arg2==='number'){originX=arg2;originY=arg3;order=arg4;}else {order=arg2;}if(order==='before'){originX===undefined?Transform2D.addCache[0].toReflection(theta):Transform2D.addCache[0].toReflection(theta,originX,originY);Transform2D.addCache[1].set(this);}else {Transform2D.addCache[0].set(this);originX===undefined?Transform2D.addCache[1].toReflection(theta):Transform2D.addCache[1].toReflection(theta,originX,originY);}return Transform2D.concat(this,Transform2D.addCache);}/**
       * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
       * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
       * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
       * `M_A * M_B * ...`.
       *
       * If the number of transformations to concatenate equals zero, the identity matrix is returned.
       * @param out The transformation to which to write the result.
       * @param transforms The transformations to concatenate, in order.
       * @returns The result of concatenating all transformations in `transforms`.
       */static concat(out,transforms){if(transforms.length===0){return out.toIdentity();}if(transforms.length===1){return out.set(transforms[0]);}let index=0;let next=transforms[index];const oldTransform=Transform2D.concatCache[0];const newTransform=Transform2D.concatCache[1].set(next);const oldArray=oldTransform.array;const newArray=newTransform.array;const end=transforms.length;while(++index<end){next=transforms[index];const nextArray=next.array;oldTransform.set(newTransform);for(let i=0;i<3;i++){for(let j=0;j<2;j++){newArray[j*3+i]=oldArray[i]*nextArray[j*3]+oldArray[3+i]*nextArray[j*3+1]+(i===2?1:0)*nextArray[j*3+2];}}}return out.set(newTransform);}}Transform2D.offsetOriginCache=[new Transform2D(),undefined,new Transform2D()];Transform2D.addCache=[new Transform2D(),new Transform2D()];Transform2D.concatCache=[new Transform2D(),new Transform2D()];/**
   * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
   */class Transform3D{constructor(){this.array=new Float64Array([1,0,0,0,0,1,0,0,0,0,1,0]);}/**
       * Gets the parameters of this transformation as a 12-tuple:
       * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
       * @returns The parameters of this transformation.
       */getParameters(){return this.array;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,skewXY,skewXZ,translateX,skewYX,scaleY,skewYZ,translateY,skewZX,skewZY,scaleZ,translateZ){let scaleX=arg1;if(arg1 instanceof Transform3D){[scaleX,skewXY,skewXZ,translateX,skewYX,scaleY,skewYZ,translateY,skewZX,skewZY,scaleZ,translateZ]=arg1.array;}const array=this.array;array[0]=scaleX;array[1]=skewXY;array[2]=skewXZ;array[3]=translateX;array[4]=skewYX;array[5]=scaleY;array[6]=skewYZ;array[7]=translateY;array[8]=skewZX;array[9]=skewZY;array[10]=scaleZ;array[11]=translateZ;return this;}/**
       * Sets the x scaling factor of this transformation.
       * @param value The new x scaling factor.
       * @returns This transformation, after it has been changed.
       */setScaleX(value){this.array[0]=value;return this;}/**
       * Sets the y scaling factor of this transformation.
       * @param value The new y scaling factor.
       * @returns This transformation, after it has been changed.
       */setScaleY(value){this.array[5]=value;return this;}/**
       * Sets the z scaling factor of this transformation.
       * @param value The new z scaling factor.
       * @returns This transformation, after it has been changed.
       */setScaleZ(value){this.array[10]=value;return this;}/**
       * Sets the x and y scaling factors of this transformation.
       * @param x The new x scaling factor.
       * @param y The new y scaling factor.
       * @param z The new z scaling factor.
       * @returns This transformation, after it has been changed.
       */setScale(x,y,z){this.array[0]=x;this.array[5]=y;this.array[10]=z;return this;}/**
       * Sets the x skew factor of this transformation.
       * @param y The new x skew factor along the y axis.
       * @param z The new x skew factor along the z axis.
       * @returns This transformation, after it has been changed.
       */setSkewX(y,z){this.array[1]=y;this.array[2]=z;return this;}/**
       * Sets the y skew factor of this transformation.
       * @param x The new y skew factor along the x axis.
       * @param z The new y skew factor along the z axis.
       * @returns This transformation, after it has been changed.
       */setSkewY(x,z){this.array[4]=x;this.array[6]=z;return this;}/**
       * Sets the z skew factor of this transformation.
       * @param x The new z skew factor along the x axis.
       * @param y The new z skew factor along the y axis.
       * @returns This transformation, after it has been changed.
       */setSkewZ(x,y){this.array[8]=x;this.array[9]=y;return this;}/**
       * Sets the x translation of this transformation.
       * @param value The new x translation.
       * @returns This transformation, after it has been changed.
       */setTranslateX(value){this.array[3]=value;return this;}/**
       * Sets the y translation of this transformation.
       * @param value The new y translation.
       * @returns This transformation, after it has been changed.
       */setTranslateY(value){this.array[7]=value;return this;}/**
       * Sets the z translation of this transformation.
       * @param value The new z translation.
       * @returns This transformation, after it has been changed.
       */setTranslateZ(value){this.array[11]=value;return this;}/**
       * Sets the x and y translations of this transformation.
       * @param x The new x translation.
       * @param y The new y translation.
       * @param z The new z translation.
       * @returns This transformation, after it has been changed.
       */setTranslate(x,y,z){this.array[3]=x;this.array[7]=y;this.array[11]=z;return this;}/**
       * Inverts this transformation.
       * @returns This transformation, after it has been inverted.
       * @throws Error if this transformation cannot be inverted.
       */invert(){const array=this.array;const e_00=array[0];const e_01=array[1];const e_02=array[2];const e_03=array[3];const e_10=array[4];const e_11=array[5];const e_12=array[6];const e_13=array[7];const e_20=array[8];const e_21=array[9];const e_22=array[10];const e_23=array[11];const c_00=e_11*e_22-e_12*e_21;const c_01=e_12*e_20-e_10*e_22;const c_02=e_10*e_21-e_11*e_20;const c_10=e_02*e_21-e_01*e_22;const c_11=e_00*e_22-e_02*e_20;const c_12=e_01*e_20-e_00*e_21;const c_20=e_01*e_12-e_02*e_11;const c_21=e_02*e_10-e_00*e_12;const c_22=e_00*e_11-e_01*e_10;const det=e_00*c_00+e_01*c_01+e_02*c_02;if(det===0){throw new Error("Transform3D: cannot invert transformation with parameters: ".concat(this.array));}const i_00=c_00/det;const i_01=c_10/det;const i_02=c_20/det;const i_10=c_01/det;const i_11=c_11/det;const i_12=c_21/det;const i_20=c_02/det;const i_21=c_12/det;const i_22=c_22/det;const i_03=-(i_00*e_03+i_01*e_13+i_02*e_23);const i_13=-(i_10*e_03+i_11*e_13+i_12*e_23);const i_23=-(i_20*e_03+i_21*e_13+i_22*e_23);return this.set(i_00,i_01,i_02,i_03,i_10,i_11,i_12,i_13,i_20,i_21,i_22,i_23);}/**
       * Copies this transformation.
       * @returns A copy of this transformation.
       */copy(){return new Transform3D().set(this);}/**
       * Applies this transformation to a 3D vector.
       * @param vec A 3D vector.
       * @param out The vector to which to write the result.
       * @returns The result of applying this transformation to `vec`.
       */apply(vec,out){const array=this.array;const x=vec[0]*array[0]+vec[1]*array[1]+vec[2]*array[2]+array[3];const y=vec[0]*array[4]+vec[1]*array[5]+vec[2]*array[6]+array[7];const z=vec[0]*array[8]+vec[1]*array[9]+vec[2]*array[10]+array[11];return Vec3Math.set(x,y,z,out);}/**
       * Changes this transformation to the one that is the result of offsetting this transformation's origin.
       * @param x The x-coordinate of the offset origin.
       * @param y The y-coordinate of the offset origin.
       * @param z The z-coordinate of the offset origin.
       * @returns This transformation, after it has been changed.
       */offsetOrigin(x,y,z){Transform3D.offsetOriginCache[0].toTranslation(-x,-y,-z);Transform3D.offsetOriginCache[1]=this;Transform3D.offsetOriginCache[2].toTranslation(x,y,z);return Transform3D.concat(this,Transform3D.offsetOriginCache);}/**
       * Sets this transformation to the identity transformation.
       * @returns This transformation, after it has been changed.
       */toIdentity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0);}/**
       * Sets this transformation to a translation.
       * @param x The x translation.
       * @param y The y translation.
       * @param z The z translation.
       * @returns This transformation, after it has been changed.
       */toTranslation(x,y,z){return this.set(1,0,0,x,0,1,0,y,0,0,1,z);}// eslint-disable-next-line jsdoc/require-jsdoc
  toScale(x,y,z,originX,originY,originZ){this.set(x,0,0,0,0,y,0,0,0,0,z,0);if(originX!==undefined&&originY!==undefined&&originZ!==undefined){this.offsetOrigin(originX,originY,originZ);}return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  toRotationX(theta,originX,originY,originZ){const sin=Math.sin(theta);const cos=Math.cos(theta);this.set(1,0,0,0,0,cos,-sin,0,0,sin,cos,0);if(originX!==undefined&&originY!==undefined&&originZ!==undefined){this.offsetOrigin(originX,originY,originZ);}return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  toRotationY(theta,originX,originY,originZ){const sin=Math.sin(theta);const cos=Math.cos(theta);this.set(cos,0,sin,0,0,1,0,0,-sin,0,cos,0);if(originX!==undefined&&originY!==undefined&&originZ!==undefined){this.offsetOrigin(originX,originY,originZ);}return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  toRotationZ(theta,originX,originY,originZ){const sin=Math.sin(theta);const cos=Math.cos(theta);this.set(cos,-sin,0,0,sin,cos,0,0,0,0,1,0);if(originX!==undefined&&originY!==undefined&&originZ!==undefined){this.offsetOrigin(originX,originY,originZ);}return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  toRotation(theta,axisX,axisY,axisZ,originX,originY,originZ){const abs=Math.hypot(axisX,axisY,axisZ);const ux=axisX/abs;const uy=axisY/abs;const uz=axisZ/abs;const ux_uy=ux*uy;const ux_uz=ux*uz;const uy_uz=uy*uz;const sin=Math.sin(theta);const cos=Math.cos(theta);const cosCompl=1-cos;this.set(cos+ux*ux*cosCompl,ux_uy*cosCompl-uz*sin,ux_uz*cosCompl*uy*sin,0,ux_uy*cosCompl+uz*sin,cos+uy*uy*cosCompl,uy_uz*cosCompl-ux*sin,0,ux_uz*cosCompl-uy*sin,uy_uz*cosCompl+ux*sin,cos+uz*uz*cosCompl,0);if(originX!==undefined&&originY!==undefined&&originZ!==undefined){this.offsetOrigin(originX,originY,originZ);}return this;}/**
       * Adds a translation to this transformation.
       * @param x The x translation.
       * @param y The y translation.
       * @param z The z translation.
       * @param order The order in which to add the translation, relative to this existing transformation, either
       * `'before'` or `'after'`. Defaults to `'after'`.
       * @returns This transformation, after it has been changed.
       */addTranslation(x,y,z){let order=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'after';if(order==='before'){Transform3D.addCache[0].toTranslation(x,y,z);Transform3D.addCache[1].set(this);}else {Transform3D.addCache[0].set(this);Transform3D.addCache[1].toTranslation(x,y,z);}return Transform3D.concat(this,Transform3D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addScale(x,y,z,arg4,arg5,arg6,arg7){let originX,originY,originZ,order;if(typeof arg4==='number'){originX=arg4;originY=arg5;originZ=arg6;order=arg7;}else {order=arg4;}if(order==='before'){originX===undefined?Transform3D.addCache[0].toScale(x,y,z):Transform3D.addCache[0].toScale(x,y,z,originX,originY,originZ);Transform3D.addCache[1].set(this);}else {Transform3D.addCache[0].set(this);originX===undefined?Transform3D.addCache[1].toScale(x,y,z):Transform3D.addCache[1].toScale(x,y,z,originX,originY,originZ);}return Transform3D.concat(this,Transform3D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addRotationX(theta,arg2,arg3,arg4,arg5){let originX,originY,originZ,order;if(typeof arg2==='number'){originX=arg2;originY=arg3;originZ=arg4;order=arg5;}else {order=arg2;}if(order==='before'){originX===undefined?Transform3D.addCache[0].toRotationX(theta):Transform3D.addCache[0].toRotationX(theta,originX,originY,originZ);Transform3D.addCache[1].set(this);}else {Transform3D.addCache[0].set(this);originX===undefined?Transform3D.addCache[1].toRotationX(theta):Transform3D.addCache[1].toRotationX(theta,originX,originY,originZ);}return Transform3D.concat(this,Transform3D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addRotationY(theta,arg2,arg3,arg4,arg5){let originX,originY,originZ,order;if(typeof arg2==='number'){originX=arg2;originY=arg3;originZ=arg4;order=arg5;}else {order=arg2;}if(order==='before'){originX===undefined?Transform3D.addCache[0].toRotationY(theta):Transform3D.addCache[0].toRotationY(theta,originX,originY,originZ);Transform3D.addCache[1].set(this);}else {Transform3D.addCache[0].set(this);originX===undefined?Transform3D.addCache[1].toRotationY(theta):Transform3D.addCache[1].toRotationY(theta,originX,originY,originZ);}return Transform3D.concat(this,Transform3D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addRotationZ(theta,arg2,arg3,arg4,arg5){let originX,originY,originZ,order;if(typeof arg2==='number'){originX=arg2;originY=arg3;originZ=arg4;order=arg5;}else {order=arg2;}if(order==='before'){originX===undefined?Transform3D.addCache[0].toRotationZ(theta):Transform3D.addCache[0].toRotationZ(theta,originX,originY,originZ);Transform3D.addCache[1].set(this);}else {Transform3D.addCache[0].set(this);originX===undefined?Transform3D.addCache[1].toRotationZ(theta):Transform3D.addCache[1].toRotationZ(theta,originX,originY,originZ);}return Transform3D.concat(this,Transform3D.addCache);}// eslint-disable-next-line jsdoc/require-jsdoc
  addRotation(theta,axisX,axisY,axisZ,arg5,arg6,arg7,arg8){let originX,originY,originZ,order;if(typeof arg5==='number'){originX=arg5;originY=arg6;originZ=arg7;order=arg8;}else {order=arg5;}if(order==='before'){originX===undefined?Transform3D.addCache[0].toRotation(theta,axisX,axisY,axisZ):Transform3D.addCache[0].toRotation(theta,axisX,axisY,axisZ,originX,originY,originZ);Transform3D.addCache[1].set(this);}else {Transform3D.addCache[0].set(this);originX===undefined?Transform3D.addCache[1].toRotation(theta,axisX,axisY,axisZ):Transform3D.addCache[1].toRotation(theta,axisX,axisY,axisZ,originX,originY,originZ);}return Transform3D.concat(this,Transform3D.addCache);}/**
       * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
       * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
       * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
       * `M_A * M_B * ...`.
       *
       * If the number of transformations to concatenate equals zero, the identity matrix is returned.
       * @param out The transformation to which to write the result.
       * @param transforms The transformations to concatenate, in order.
       * @returns The result of concatenating all transformations in `transforms`.
       */static concat(out,transforms){if(transforms.length===0){return out.toIdentity();}if(transforms.length===1){return out.set(transforms[0]);}let index=0;let next=transforms[index];const oldTransform=Transform3D.concatCache[0];const newTransform=Transform3D.concatCache[1].set(next);const oldArray=oldTransform.array;const newArray=newTransform.array;const end=transforms.length;while(++index<end){next=transforms[index];const nextArray=next.array;oldTransform.set(newTransform);for(let i=0;i<4;i++){for(let j=0;j<3;j++){newArray[j*4+i]=oldArray[i]*nextArray[j*4]+oldArray[4+i]*nextArray[j*4+1]+oldArray[8+i]*nextArray[j*4+2]+(i===3?1:0)*nextArray[j*4+3];}}}return out.set(newTransform);}}Transform3D.offsetOriginCache=[new Transform3D(),undefined,new Transform3D()];Transform3D.addCache=[new Transform3D(),new Transform3D()];Transform3D.concatCache=[new Transform3D(),new Transform3D()];[Vec3Math.create()];/**
   * A utitlity class for basic math.
   */class MathUtils{/**
       * Clamps a numerical value to the min/max range.
       * @param value The value to be clamped.
       * @param min The minimum.
       * @param max The maximum.
       *
       * @returns The clamped numerical value..
       */static clamp(value,min,max){return Math.max(min,Math.min(max,value));}/**
       * Rounds a number.
       * @param value The number to round.
       * @param precision The precision with which to round. Defaults to `1`.
       * @returns The rounded number.
       */static round(value){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;return Math.round(value/precision)*precision;}/**
       * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
       * directional and non-directional differences. The directional difference is the angle swept from the start angle
       * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
       * of the two angles swept from the start angle to the end angle proceeding in either direction.
       * @param start The starting angle, in radians.
       * @param end The ending angle, in radians.
       * @param directional Whether to calculate the directional difference. Defaults to `true`.
       * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
       */static diffAngle(start,end){let directional=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;const diff=((end-start)%MathUtils.TWO_PI+MathUtils.TWO_PI)%MathUtils.TWO_PI;return directional?diff:Math.min(diff,MathUtils.TWO_PI-diff);}/**
       * Linearly interpolates a keyed value along one dimension.
       * @param x The key of the value to interpolate.
       * @param x0 The key of the first known value.
       * @param x1 The key of the second known value.
       * @param y0 The first known value.
       * @param y1 The second known value.
       * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
       * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
       * @returns The interpolated value corresponding to the specified key.
       */static lerp(x,x0,x1,y0,y1){let clampStart=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;let clampEnd=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;if(x0!==x1&&y0!==y1){const fraction=MathUtils.clamp((x-x0)/(x1-x0),clampStart?0:-Infinity,clampEnd?1:Infinity);return fraction*(y1-y0)+y0;}else {return y0;}}/**
       * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
       * lengths, then only the components shared by all vectors are interpolated in the result.
       * @param out The object to which to write the result.
       * @param x The key of the vector to interpolate.
       * @param x0 The key of the first known vector.
       * @param x1 The key of the second known vector.
       * @param y0 The first known vector.
       * @param y1 The second known vector.
       * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
       * Defaults to false.
       * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
       * Defaults to false.
       * @returns The interpolated vector corresponding to the specified key.
       */static lerpVector(out,x,x0,x1,y0,y1){let clampStart=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;let clampEnd=arguments.length>7&&arguments[7]!==undefined?arguments[7]:false;const length=Math.min(y0.length,y1.length,out.length);for(let i=0;i<length;i++){out[i]=MathUtils.lerp(x,x0,x1,y0[i],y1[i],clampStart,clampEnd);}return out;}}/** Twice the value of pi. */MathUtils.TWO_PI=Math.PI*2;/** Half the value of pi. */MathUtils.HALF_PI=Math.PI/2;/**
   * A read-only wrapper for a GeoPoint.
   */class GeoPointReadOnly{/**
       * Constructor.
       * @param source - the source of the new read-only point.
       */constructor(source){this.source=source;}/**
       * The latitude of this point, in degrees.
       * @returns the latitude of this point.
       */get lat(){return this.source.lat;}/**
       * The longitude of this point, in degrees.
       * @returns the longitude of this point.
       */get lon(){return this.source.lon;}// eslint-disable-next-line jsdoc/require-jsdoc
  distance(arg1,arg2){if(typeof arg1==='number'){return this.source.distance(arg1,arg2);}else {return this.source.distance(arg1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  distanceRhumb(arg1,arg2){if(typeof arg1==='number'){return this.source.distanceRhumb(arg1,arg2);}else {return this.source.distanceRhumb(arg1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  bearingTo(arg1,arg2){if(typeof arg1==='number'){return this.source.bearingTo(arg1,arg2);}else {return this.source.bearingTo(arg1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  bearingFrom(arg1,arg2){if(typeof arg1==='number'){return this.source.bearingFrom(arg1,arg2);}else {return this.source.bearingFrom(arg1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  bearingRhumb(arg1,arg2){if(typeof arg1==='number'){return this.source.bearingRhumb(arg1,arg2);}else {return this.source.bearingRhumb(arg1);}}/**
       * Offsets this point by an initial bearing and distance along a great circle.
       * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
       * @param distance The distance, in great-arc radians, by which to offset.
       * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
       * @returns The offset point.
       * @throws Error if argument `out` is undefined.
       */offset(bearing,distance,out){if(!out){throw new Error('Cannot mutate a read-only GeoPoint.');}return this.source.offset(bearing,distance,out);}/**
       * Offsets this point by a constant bearing and distance along a rhumb line.
       * @param bearing The true bearing, in degrees, by which to offset.
       * @param distance The distance, in great-arc radians, by which to offset.
       * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
       * @returns The offset point.
       * @throws Error if argument `out` is undefined.
       */offsetRhumb(bearing,distance,out){if(!out){throw new Error('Cannot mutate a read-only GeoPoint.');}return this.source.offsetRhumb(bearing,distance,out);}/**
       * Gets the antipode of this point.
       * @param out The GeoPoint ot which to write the result.
       * @returns The antipode of this point.
       * @throws Error if argument `out` is undefined.
       */antipode(out){if(!out){throw new Error('Cannot mutate a read-only GeoPoint.');}return this.source.antipode(out);}/**
       * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
       * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
       * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
       * @param out The vector array to which to write the result.
       * @returns The cartesian representation of this point.
       */toCartesian(out){return this.source.toCartesian(out);}// eslint-disable-next-line jsdoc/require-jsdoc
  equals(arg1,arg2,arg3){if(typeof arg1==='number'){return this.source.equals(arg1,arg2,arg3);}else {return this.source.equals(arg1,arg2);}}/** @inheritdoc */copy(to){return this.source.copy(to);}}/**
   * A point on Earth's surface. This class uses a spherical Earth model.
   */class GeoPoint{/**
       * Constructor.
       * @param lat The latitude, in degrees.
       * @param lon The longitude, in degrees.
       */constructor(lat,lon){this._lat=0;this._lon=0;this.set(lat,lon);this.readonly=new GeoPointReadOnly(this);}/**
       * The latitude of this point, in degrees.
       * @returns the latitude of this point.
       */get lat(){return this._lat;}/**
       * The longitude of this point, in degrees.
       * @returns the longitude of this point.
       */get lon(){return this._lon;}/**
       * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
       * LatLonInterface.
       * @param arg1 Argument 1.
       * @param arg2 Argument 2.
       * @returns A LatLonInterface.
       */static asLatLonInterface(arg1,arg2){if(typeof arg1==='number'){return GeoPoint.tempGeoPoint.set(arg1,arg2);}else {return arg1;}}/**
       * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
       * @param arg1 Argument 1.
       * @param arg2 Argument 2.
       * @param arg3 Argument 3.
       * @returns A 3D vector.
       */static asVec3(arg1,arg2,arg3){if(typeof arg1==='number'){return Vec3Math.set(arg1,arg2,arg3,GeoPoint.tempVec3);}else {return arg1;}}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,arg2){let lat,lon;if(typeof arg1==='number'){lat=arg1;lon=arg2;}else {lat=arg1.lat;lon=arg1.lon;}lat=GeoPoint.toPlusMinus180(lat);lon=GeoPoint.toPlusMinus180(lon);if(Math.abs(lat)>90){lat=180-lat;lat=GeoPoint.toPlusMinus180(lat);lon+=180;lon=GeoPoint.toPlusMinus180(lon);}this._lat=lat;this._lon=lon;return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  setFromCartesian(arg1,arg2,arg3){const vec=GeoPoint.asVec3(arg1,arg2,arg3);const theta=Vec3Math.theta(vec);const phi=Vec3Math.phi(vec);return this.set(90-theta*Avionics.Utils.RAD2DEG,phi*Avionics.Utils.RAD2DEG);}// eslint-disable-next-line jsdoc/require-jsdoc
  distance(arg1,arg2){const other=GeoPoint.asLatLonInterface(arg1,arg2);return GeoPoint.distance(this.lat,this.lon,other.lat,other.lon);}// eslint-disable-next-line jsdoc/require-jsdoc
  distanceRhumb(arg1,arg2){const other=GeoPoint.asLatLonInterface(arg1,arg2);return GeoPoint.distanceRhumb(this.lat,this.lon,other.lat,other.lon);}// eslint-disable-next-line jsdoc/require-jsdoc
  bearingTo(arg1,arg2){const other=GeoPoint.asLatLonInterface(arg1,arg2);return GeoPoint.initialBearing(this.lat,this.lon,other.lat,other.lon);}// eslint-disable-next-line jsdoc/require-jsdoc
  bearingFrom(arg1,arg2){const other=GeoPoint.asLatLonInterface(arg1,arg2);return GeoPoint.finalBearing(other.lat,other.lon,this.lat,this.lon);}// eslint-disable-next-line jsdoc/require-jsdoc
  bearingRhumb(arg1,arg2){const other=GeoPoint.asLatLonInterface(arg1,arg2);return GeoPoint.bearingRhumb(this.lat,this.lon,other.lat,other.lon);}/**
       * Offsets this point by an initial bearing and distance along a great circle.
       * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
       * @param distance The distance, in great-arc radians, by which to offset.
       * @param out The GeoPoint to which to write the result. By default this point.
       * @returns The offset point.
       */offset(bearing,distance,out){const latRad=this.lat*Avionics.Utils.DEG2RAD;const lonRad=this.lon*Avionics.Utils.DEG2RAD;const sinLat=Math.sin(latRad);const cosLat=Math.cos(latRad);const sinBearing=Math.sin(bearing*Avionics.Utils.DEG2RAD);const cosBearing=Math.cos(bearing*Avionics.Utils.DEG2RAD);const angularDistance=distance;const sinAngularDistance=Math.sin(angularDistance);const cosAngularDistance=Math.cos(angularDistance);const offsetLatRad=Math.asin(sinLat*cosAngularDistance+cosLat*sinAngularDistance*cosBearing);const offsetLonDeltaRad=Math.atan2(sinBearing*sinAngularDistance*cosLat,cosAngularDistance-sinLat*Math.sin(offsetLatRad));const offsetLat=offsetLatRad*Avionics.Utils.RAD2DEG;const offsetLon=(lonRad+offsetLonDeltaRad)*Avionics.Utils.RAD2DEG;return (out!==null&&out!==void 0?out:this).set(offsetLat,offsetLon);}/**
       * Offsets this point by a constant bearing and distance along a rhumb line.
       * @param bearing The true bearing, in degrees, by which to offset.
       * @param distance The distance, in great-arc radians, by which to offset.
       * @param out The GeoPoint to which to write the result. By default this point.
       * @returns The offset point.
       */offsetRhumb(bearing,distance,out){const latRad=this.lat*Avionics.Utils.DEG2RAD;const lonRad=this.lon*Avionics.Utils.DEG2RAD;const bearingRad=bearing*Avionics.Utils.DEG2RAD;const deltaLat=distance*Math.cos(bearingRad);let offsetLat=latRad+deltaLat;let offsetLon;if(Math.abs(offsetLat)>=Math.PI/2){// you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
  offsetLat=Math.sign(offsetLat)*90;offsetLon=0;// since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
  }else {const deltaPsi=GeoPoint.deltaPsi(latRad,offsetLat);const correction=GeoPoint.rhumbCorrection(deltaPsi,latRad,offsetLat);const deltaLon=distance*Math.sin(bearingRad)/correction;offsetLon=lonRad+deltaLon;offsetLat*=Avionics.Utils.RAD2DEG;offsetLon*=Avionics.Utils.RAD2DEG;}return (out!==null&&out!==void 0?out:this).set(offsetLat,offsetLon);}/**
       * Gets the antipode of this point.
       * @param out The GeoPoint to which to write the results. By default this point.
       * @returns The antipode of this point.
       */antipode(out){return (out!==null&&out!==void 0?out:this).set(-this._lat,this._lon+180);}/** @inheritdoc */toCartesian(out){return GeoPoint.sphericalToCartesian(this,out);}// eslint-disable-next-line jsdoc/require-jsdoc
  equals(arg1,arg2,arg3){const other=GeoPoint.asLatLonInterface(arg1,arg2);if(other){if(isNaN(this._lat)&&isNaN(this._lon)&&isNaN(other.lat)&&isNaN(other.lon)){return true;}const tolerance=typeof arg1==='number'?arg3:arg2;const distance=this.distance(other);return !isNaN(distance)&&distance<=(tolerance!==null&&tolerance!==void 0?tolerance:GeoPoint.EQUALITY_TOLERANCE);}else {return false;}}/** @inheritdoc */copy(to){return to?to.set(this.lat,this.lon):new GeoPoint(this.lat,this.lon);}// eslint-disable-next-line jsdoc/require-jsdoc
  static sphericalToCartesian(arg1,arg2,arg3){const point=GeoPoint.asLatLonInterface(arg1,arg2);const theta=(90-point.lat)*Avionics.Utils.DEG2RAD;const phi=point.lon*Avionics.Utils.DEG2RAD;return Vec3Math.setFromSpherical(1,theta,phi,arg3!==null&&arg3!==void 0?arg3:arg2);}// eslint-disable-next-line jsdoc/require-jsdoc
  static equals(arg1,arg2,arg3,arg4,arg5){if(arg1 instanceof Float64Array){return GeoPoint.distance(arg1,arg2)<=(arg3!==null&&arg3!==void 0?arg3:GeoPoint.EQUALITY_TOLERANCE);}else if(typeof arg1==='number'){return GeoPoint.distance(arg1,arg2,arg3,arg4)<=(arg5!==null&&arg5!==void 0?arg5:GeoPoint.EQUALITY_TOLERANCE);}else {return GeoPoint.distance(arg1,arg2)<=(arg3!==null&&arg3!==void 0?arg3:GeoPoint.EQUALITY_TOLERANCE);}}// eslint-disable-next-line jsdoc/require-jsdoc
  static distance(arg1,arg2,arg3,arg4){if(arg1 instanceof Float64Array){return Math.acos(Utils.Clamp(Vec3Math.dot(arg1,arg2),-1,1));}else {let lat1,lon1,lat2,lon2;if(typeof arg1==='number'){lat1=arg1;lon1=arg2;lat2=arg3;lon2=arg4;}else {lat1=arg1.lat;lon1=arg1.lon;lat2=arg2.lat;lon2=arg2.lon;}lat1*=Avionics.Utils.DEG2RAD;lon1*=Avionics.Utils.DEG2RAD;lat2*=Avionics.Utils.DEG2RAD;lon2*=Avionics.Utils.DEG2RAD;// haversine formula
  const sinHalfDeltaLat=Math.sin((lat2-lat1)/2);const sinHalfDeltaLon=Math.sin((lon2-lon1)/2);const a=sinHalfDeltaLat*sinHalfDeltaLat+Math.cos(lat1)*Math.cos(lat2)*sinHalfDeltaLon*sinHalfDeltaLon;return 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));}}// eslint-disable-next-line jsdoc/require-jsdoc
  static distanceRhumb(arg1,arg2,arg3,arg4){let lat1,lon1,lat2,lon2;if(typeof arg1==='number'){lat1=arg1*Avionics.Utils.DEG2RAD;lon1=arg2*Avionics.Utils.DEG2RAD;lat2=arg3*Avionics.Utils.DEG2RAD;lon2=arg4*Avionics.Utils.DEG2RAD;}else if(arg1 instanceof Float64Array){const point1=GeoPoint.tempGeoPoint.setFromCartesian(arg1);lat1=point1.lat;lon1=point1.lon;const point2=GeoPoint.tempGeoPoint.setFromCartesian(arg2);lat2=point2.lat;lon2=point2.lon;}else {lat1=arg1.lat;lon1=arg1.lon;lat2=arg2.lat;lon2=arg2.lon;}const deltaLat=lat2-lat1;let deltaLon=lon2-lon1;const deltaPsi=GeoPoint.deltaPsi(lat1,lat2);const correction=GeoPoint.rhumbCorrection(deltaPsi,lat1,lat2);if(Math.abs(deltaLon)>Math.PI){deltaLon+=-Math.sign(deltaLon)*2*Math.PI;}return Math.sqrt(deltaLat*deltaLat+correction*correction*deltaLon*deltaLon);}/**
       * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
       * the two.
       * @param lat1 The latitude of the initial point, in degrees.
       * @param lon1 The longitude of the initial point, in degrees.
       * @param lat2 The latitude of the final point, in degrees.
       * @param lon2 The longitude of the final point, in degrees.
       * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
       * connecting the two.
       */static initialBearing(lat1,lon1,lat2,lon2){lat1*=Avionics.Utils.DEG2RAD;lat2*=Avionics.Utils.DEG2RAD;lon1*=Avionics.Utils.DEG2RAD;lon2*=Avionics.Utils.DEG2RAD;const cosLat2=Math.cos(lat2);const x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*cosLat2*Math.cos(lon2-lon1);const y=Math.sin(lon2-lon1)*cosLat2;const bearing=Math.atan2(y,x)*Avionics.Utils.RAD2DEG;return (bearing+360)%360;// enforce range [0, 360)
  }/**
       * Calculates the final true bearing from one point to another along the great circle connecting the two.
       * @param lat1 The latitude of the initial point, in degrees.
       * @param lon1 The longitude of the initial point, in degrees.
       * @param lat2 The latitude of the final point, in degrees.
       * @param lon2 The longitude of the final point, in degrees.
       * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
       * connecting the two.
       */static finalBearing(lat1,lon1,lat2,lon2){return (GeoPoint.initialBearing(lat2,lon2,lat1,lon1)+180)%360;}/**
       * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
       * @param lat1 The latitude of the initial point, in degrees.
       * @param lon1 The longitude of the initial point, in degrees.
       * @param lat2 The latitude of the final point, in degrees.
       * @param lon2 The longitude of the final point, in degrees.
       * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
       * connecting the two.
       */static bearingRhumb(lat1,lon1,lat2,lon2){lat1*=Avionics.Utils.DEG2RAD;lat2*=Avionics.Utils.DEG2RAD;lon1*=Avionics.Utils.DEG2RAD;lon2*=Avionics.Utils.DEG2RAD;let deltaLon=lon2-lon1;const deltaPsi=GeoPoint.deltaPsi(lat1,lat2);if(Math.abs(deltaLon)>Math.PI){deltaLon+=-Math.sign(deltaLon)*2*Math.PI;}return Math.atan2(deltaLon,deltaPsi)*Avionics.Utils.RAD2DEG;}/**
       * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
       * @param angle An angle in degrees.
       * @returns The angle's equivalent in the range [-180, 180).
       */static toPlusMinus180(angle){return (angle%360+540)%360-180;}/**
       * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
       * @param latRad1 Geodetic latitude 1, in radians.
       * @param latRad2 Geodetic latitude 2, in radians.
       * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
       */static deltaPsi(latRad1,latRad2){return Math.log(Math.tan(latRad2/2+Math.PI/4)/Math.tan(latRad1/2+Math.PI/4));}/**
       * Calculates the rhumb correction factor between two latitudes.
       * @param deltaPsi The difference in isometric latitude beween the two latitudes.
       * @param latRad1 Geodetic latitude 1, in radians.
       * @param latRad2 Geodetic latitude 2, in radians.
       * @returns The rhumb correction factor between the two latitudes.
       */static rhumbCorrection(deltaPsi,latRad1,latRad2){return Math.abs(deltaPsi)>1e-12?(latRad2-latRad1)/deltaPsi:Math.cos(latRad1);}}/**
   * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
   * radians.
   */GeoPoint.EQUALITY_TOLERANCE=1e-7;// ~61 cm
  GeoPoint.tempVec3=new Float64Array(3);GeoPoint.tempGeoPoint=new GeoPoint(0,0);/**
   * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
   * geodetically) from a central point.
   */class GeoCircle{/**
       * Constructor.
       * @param center The center of the new small circle, represented as a position vector in the standard geographic
       * cartesian reference system.
       * @param radius The radius of the new small circle in great-arc radians.
       */constructor(center,radius){this._center=new Float64Array(3);this._radius=0;this._sinRadius=0;this.set(center,radius);}// eslint-disable-next-line jsdoc/require-returns
  /**
       * The center of this circle.
       */get center(){return this._center;}// eslint-disable-next-line jsdoc/require-returns
  /**
       * The radius of this circle, in great-arc radians.
       */get radius(){return this._radius;}/**
       * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
       * radians.
       * @returns Whether this circle is a great circle.
       */isGreatCircle(){return this._radius===Math.PI/2;}/**
       * Calculates the length of an arc along this circle subtended by a central angle.
       * @param angle A central angle, in radians.
       * @returns The length of the arc subtended by the angle, in great-arc radians.
       */arcLength(angle){return this._sinRadius*angle;}/**
       * Calculates the central angle which subtends an arc along this circle of given length.
       * @param length An arc length, in great-arc radians.
       * @returns The central angle which subtends an arc along this circle of the given length, in radians.
       */angularWidth(length){return length/this._sinRadius;}/**
       * Sets the center and radius of this circle.
       * @param center The new center.
       * @param radius The new radius in great-arc radians.
       * @returns this circle, after it has been changed.
       */set(center,radius){if(center instanceof Float64Array){if(Vec3Math.abs(center)===0){// if center has no direction, arbitrarily set the center to 0 N, 0 E.
  Vec3Math.set(1,0,0,this._center);}else {Vec3Math.normalize(center,this._center);}}else {GeoPoint.sphericalToCartesian(center,this._center);}this._radius=Math.abs(radius)%Math.PI;this._sinRadius=Math.sin(this._radius);return this;}// eslint-disable-next-line jsdoc/require-jsdoc
  setAsGreatCircle(arg1,arg2){this.set(GeoCircle._getGreatCircleNormal(arg1,arg2,GeoCircle.vec3Cache[0]),Math.PI/2);return this;}/**
       * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
       * complement with `Math.PI`.
       * @returns This circle, after it has been reversed.
       */reverse(){Vec3Math.multScalar(this._center,-1,this._center);this._radius=Math.PI-this._radius;return this;}/**
       * Gets the distance from a point to the center of this circle, in great-arc radians.
       * @param point The point to which to measure the distance.
       * @returns the distance from the point to the center of this circle.
       */distanceToCenter(point){if(point instanceof Float64Array){point=Vec3Math.normalize(point,GeoCircle.vec3Cache[0]);}else {point=GeoPoint.sphericalToCartesian(point,GeoCircle.vec3Cache[0]);}const dot=Vec3Math.dot(point,this._center);return Math.acos(Utils.Clamp(dot,-1,1));}// eslint-disable-next-line jsdoc/require-jsdoc
  closest(point,out){if(!(point instanceof Float64Array)){point=GeoPoint.sphericalToCartesian(point,GeoCircle.vec3Cache[0]);}const offset=Vec3Math.multScalar(this._center,Math.cos(this._radius),GeoCircle.vec3Cache[1]);const dot=Vec3Math.dot(Vec3Math.sub(point,offset,GeoCircle.vec3Cache[2]),this._center);const planeProjected=Vec3Math.sub(point,Vec3Math.multScalar(this._center,dot,GeoCircle.vec3Cache[2]),GeoCircle.vec3Cache[2]);if(Vec3Math.dot(planeProjected,planeProjected)===0||Math.abs(Vec3Math.dot(planeProjected,this._center))===1){// the point is equidistant from all points on this circle
  return out instanceof GeoPoint?out.set(NaN,NaN):Vec3Math.set(NaN,NaN,NaN,out);}const displacement=Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected,offset,GeoCircle.vec3Cache[2]),GeoCircle.vec3Cache[2]),Math.sin(this._radius),GeoCircle.vec3Cache[2]);const closest=Vec3Math.add(offset,displacement,GeoCircle.vec3Cache[2]);return out instanceof Float64Array?Vec3Math.normalize(closest,out):out.setFromCartesian(closest);}/**
       * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
       * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
       * positive distances representing deviation away from the center of the circle, and negative distances representing
       * deviation toward the center of the circle.
       * @param point A point, represented as either a position vector or lat/long coordinates.
       * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
       */distance(point){const distanceToCenter=this.distanceToCenter(point);return distanceToCenter-this._radius;}/**
       * Checks whether a point lies on this circle.
       * @param point A point, represented as either a position vector or lat/long coordinates.
       * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
       * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns whether the point lies on this circle.
       */includes(point){let tolerance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:GeoCircle.ANGULAR_TOLERANCE;const distance=this.distance(point);return Math.abs(distance)<tolerance;}/**
       * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
       * the distance of the point from the center of this circle is less than or equal to this circle's radius.
       * @param point A point, represented as either a position vector or lat/long coordinates.
       * @param inclusive Whether points that lie on this circle should pass the check. True by default.
       * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
       * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns whether the point lies within the boundary defined by this circle.
       */encircles(point){let inclusive=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:GeoCircle.ANGULAR_TOLERANCE;const distance=this.distance(point);return inclusive?distance<=tolerance:distance<-tolerance;}/**
       * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
       * point to the second in a counterclockwise direction when viewed from above the center of the circle.
       * @param start A point on this circle which marks the beginning of an arc.
       * @param end A point on this circle which marks the end of an arc.
       * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
       * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
       * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
       * this value, then the zero will be returned. Defaults to `0`.
       * @returns the angular width of the arc between the two points, in radians.
       * @throws Error if either point does not lie on this circle.
       */angleAlong(start,end){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:GeoCircle.ANGULAR_TOLERANCE;let equalityTolerance=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;if(!(start instanceof Float64Array)){start=GeoPoint.sphericalToCartesian(start,GeoCircle.vec3Cache[1]);}if(!(end instanceof Float64Array)){end=GeoPoint.sphericalToCartesian(end,GeoCircle.vec3Cache[2]);}if(!this.includes(start,tolerance)||!this.includes(end,tolerance)){throw new Error("GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ".concat(this.distance(start),", end point distance of ").concat(this.distance(end),", vs tolerance of ").concat(tolerance,")."));}if(this._radius<=GeoCircle.ANGULAR_TOLERANCE){return 0;}const startRadialNormal=Vec3Math.normalize(Vec3Math.cross(this._center,start,GeoCircle.vec3Cache[3]),GeoCircle.vec3Cache[3]);const endRadialNormal=Vec3Math.normalize(Vec3Math.cross(this._center,end,GeoCircle.vec3Cache[4]),GeoCircle.vec3Cache[4]);const angularDistance=Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal,endRadialNormal),-1,1));const isArcGreaterThanSemi=Vec3Math.dot(startRadialNormal,end)<0;const angle=isArcGreaterThanSemi?MathUtils.TWO_PI-angularDistance:angularDistance;return angle>=MathUtils.TWO_PI-equalityTolerance||angle<=equalityTolerance?0:angle;}/**
       * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
       * to the second in a counterclockwise direction when viewed from above the center of the circle.
       * @param start A point on this circle which marks the beginning of an arc.
       * @param end A point on this circle which marks the end of an arc.
       * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
       * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
       * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
       * this value, then the zero will be returned. Defaults to `0`.
       * @returns the length of the arc between the two points, in great-arc radians.
       * @throws Error if either point does not lie on this circle.
       */distanceAlong(start,end){let tolerance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:GeoCircle.ANGULAR_TOLERANCE;let equalityTolerance=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;return this.arcLength(this.angleAlong(start,end,tolerance,this.angularWidth(equalityTolerance)));}/**
       * Calculates the true bearing along this circle at a point on the circle.
       * @param point A point on this circle.
       * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
       * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns the bearing along this circle at the point.
       * @throws Error if the point does not lie on this circle.
       */bearingAt(point){let tolerance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:GeoCircle.ANGULAR_TOLERANCE;if(!(point instanceof Float64Array)){point=GeoPoint.sphericalToCartesian(point,GeoCircle.vec3Cache[1]);}if(!this.includes(point,tolerance)){throw new Error("GeoCircle: the specified point does not lie on this circle (distance of ".concat(Math.abs(this.distance(point))," vs tolerance of ").concat(tolerance,")."));}if(this._radius<=GeoCircle.ANGULAR_TOLERANCE||1-Math.abs(Vec3Math.dot(point,GeoCircle.NORTH_POLE))<=GeoCircle.ANGULAR_TOLERANCE){// Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
  return NaN;}const radialNormal=Vec3Math.normalize(Vec3Math.cross(this._center,point,GeoCircle.vec3Cache[2]),GeoCircle.vec3Cache[2]);const northNormal=Vec3Math.normalize(Vec3Math.cross(point,GeoCircle.NORTH_POLE,GeoCircle.vec3Cache[3]),GeoCircle.vec3Cache[3]);return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal,northNormal),-1,1))*(radialNormal[2]>=0?1:-1)*Avionics.Utils.RAD2DEG-90+360)%360;}// eslint-disable-next-line jsdoc/require-jsdoc
  offsetDistanceAlong(point,distance,out){let tolerance=arguments.length>3&&arguments[3]!==undefined?arguments[3]:GeoCircle.ANGULAR_TOLERANCE;const angle=distance/Math.sin(this.radius);return this._offsetAngleAlong(point,angle,out,tolerance);}// eslint-disable-next-line jsdoc/require-jsdoc
  offsetAngleAlong(point,angle,out){let tolerance=arguments.length>3&&arguments[3]!==undefined?arguments[3]:GeoCircle.ANGULAR_TOLERANCE;return this._offsetAngleAlong(point,angle,out,tolerance);}/**
       * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
       * is counterclockwise when viewed from above the center of this circle.
       * @param point The point to offset.
       * @param angle The angular distance by which to offset, in radians.
       * @param out A Float64Array or GeoPoint object to which to write the result.
       * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
       * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns The offset point.
       * @throws Error if the point does not lie on this circle.
       */_offsetAngleAlong(point,angle,out){let tolerance=arguments.length>3&&arguments[3]!==undefined?arguments[3]:GeoCircle.ANGULAR_TOLERANCE;if(!(point instanceof Float64Array)){point=GeoPoint.sphericalToCartesian(point,GeoCircle.vec3Cache[3]);}if(!this.includes(point,tolerance)){throw new Error("GeoCircle: the specified point does not lie on this circle (distance of ".concat(Math.abs(this.distance(point))," vs tolerance of ").concat(tolerance,")."));}if(this.radius===0){return out instanceof GeoPoint?out.setFromCartesian(point):Vec3Math.copy(point,out);}// Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
  // the offset point lies exactly on this circle.
  point=this.closest(point,GeoCircle.vec3Cache[3]);const sin=Math.sin(angle/2);const q0=Math.cos(angle/2);const q1=sin*this._center[0];const q2=sin*this._center[1];const q3=sin*this._center[2];const q0Sq=q0*q0;const q1Sq=q1*q1;const q2Sq=q2*q2;const q3Sq=q3*q3;const q01=q0*q1;const q02=q0*q2;const q03=q0*q3;const q12=q1*q2;const q13=q1*q3;const q23=q2*q3;const rot_11=q0Sq+q1Sq-q2Sq-q3Sq;const rot_12=2*(q12-q03);const rot_13=2*(q13+q02);const rot_21=2*(q12+q03);const rot_22=q0Sq-q1Sq+q2Sq-q3Sq;const rot_23=2*(q23-q01);const rot_31=2*(q13-q02);const rot_32=2*(q23+q01);const rot_33=q0Sq-q1Sq-q2Sq+q3Sq;const x=point[0];const y=point[1];const z=point[2];const rotX=rot_11*x+rot_12*y+rot_13*z;const rotY=rot_21*x+rot_22*y+rot_23*z;const rotZ=rot_31*x+rot_32*y+rot_33*z;return out instanceof Float64Array?Vec3Math.set(rotX,rotY,rotZ,out):out.setFromCartesian(Vec3Math.set(rotX,rotY,rotZ,GeoCircle.vec3Cache[2]));}/**
       * Calculates and returns the set of intersection points between this circle and another one, and writes the results
       * to an array of position vectors.
       * @param other The other circle to test for intersections.
       * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
       * are empty, then new Float64Array objects will be created and inserted into the array.
       * @returns The number of solutions written to the out array. Either 0, 1, or 2.
       */intersection(other,out){const center1=this._center;const center2=other._center;const radius1=this._radius;const radius2=other._radius;/**
           * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
           * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
           * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
           * point), then we find the intersection of that geometry with the unit sphere.
           */const dot=Vec3Math.dot(center1,center2);const dotSquared=dot*dot;if(dotSquared===1){// the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
  // write any solutions to the array.
  return 0;}// find the position vector to the center of the circle which defines the intersection of the two geo circle
  // spheres.
  const a=(Math.cos(radius1)-dot*Math.cos(radius2))/(1-dotSquared);const b=(Math.cos(radius2)-dot*Math.cos(radius1))/(1-dotSquared);const intersection=Vec3Math.add(Vec3Math.multScalar(center1,a,GeoCircle.vec3Cache[0]),Vec3Math.multScalar(center2,b,GeoCircle.vec3Cache[1]),GeoCircle.vec3Cache[0]);const intersectionLengthSquared=Vec3Math.dot(intersection,intersection);if(intersectionLengthSquared>1){// the two geo circle spheres do not intersect.
  return 0;}const cross=Vec3Math.cross(center1,center2,GeoCircle.vec3Cache[1]);const crossLengthSquared=Vec3Math.dot(cross,cross);if(crossLengthSquared===0){// this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
  // case...)
  return 0;}const offset=Math.sqrt((1-intersectionLengthSquared)/crossLengthSquared);let solutionCount=1;if(!out[0]){out[0]=new Float64Array(3);}out[0].set(cross);Vec3Math.multScalar(out[0],offset,out[0]);Vec3Math.add(out[0],intersection,out[0]);if(offset>0){if(!out[1]){out[1]=new Float64Array(3);}out[1].set(cross);Vec3Math.multScalar(out[1],-offset,out[1]);Vec3Math.add(out[1],intersection,out[1]);solutionCount++;}return solutionCount;}/**
       * Calculates and returns the set of intersection points between this circle and another one, and writes the results
       * to an array of GeoPoint objects.
       * @param other The other circle to test for intersections.
       * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
       * are empty, then new GeoPoint objects will be created and inserted into the array.
       * @returns The number of solutions written to the out array. Either 0, 1, or 2.
       */intersectionGeoPoint(other,out){const solutionCount=this.intersection(other,GeoCircle.intersectionCache);for(let i=0;i<solutionCount;i++){if(!out[i]){out[i]=new GeoPoint(0,0);}out[i].setFromCartesian(GeoCircle.intersectionCache[i]);}return solutionCount;}/**
       * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
       * are an infinite number of intersection points.
       * @param other The other circle to test for intersections.
       * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
       * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns the number of intersection points between this circle and the other one.
       */numIntersectionPoints(other){let tolerance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:GeoCircle.ANGULAR_TOLERANCE;const center1=this.center;const center2=other.center;const radius1=this.radius;const radius2=other.radius;const dot=Vec3Math.dot(center1,center2);const dotSquared=dot*dot;if(dotSquared===1){// the two circles are concentric; if they are the same circle there are an infinite number of intersections,
  // otherwise there are none.
  if(dot===1){// centers are the same
  return Math.abs(this.radius-other.radius)<=tolerance?NaN:0;}else {// centers are antipodal
  return Math.abs(Math.PI-this.radius-other.radius)<=tolerance?NaN:0;}}const a=(Math.cos(radius1)-dot*Math.cos(radius2))/(1-dotSquared);const b=(Math.cos(radius2)-dot*Math.cos(radius1))/(1-dotSquared);const intersection=Vec3Math.add(Vec3Math.multScalar(center1,a,GeoCircle.vec3Cache[0]),Vec3Math.multScalar(center2,b,GeoCircle.vec3Cache[1]),GeoCircle.vec3Cache[1]);const intersectionLengthSquared=Vec3Math.dot(intersection,intersection);if(intersectionLengthSquared>1){return 0;}const cross=Vec3Math.cross(center1,center2,GeoCircle.vec3Cache[1]);const crossLengthSquared=Vec3Math.dot(cross,cross);if(crossLengthSquared===0){return 0;}const sinTol=Math.sin(tolerance);return (1-intersectionLengthSquared)/crossLengthSquared>sinTol*sinTol?2:1;}/**
       * Creates a new small circle from a lat/long coordinate pair and radius.
       * @param point The center of the new small circle.
       * @param radius The radius of the new small circle, in great-arc radians.
       * @returns a small circle.
       */static createFromPoint(point,radius){return new GeoCircle(GeoPoint.sphericalToCartesian(point,GeoCircle.vec3Cache[0]),radius);}static createGreatCircle(arg1,arg2){return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1,arg2,GeoCircle.vec3Cache[0]),Math.PI/2);}/* eslint-enable jsdoc/require-jsdoc */ /**
       * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
       * the path projected from the point with the specified initial bearing (forward azimuth).
       * @param point A point that lies on the new great circle.
       * @param bearing The initial bearing from the point.
       * @returns a great circle.
       */static createGreatCircleFromPointBearing(point,bearing){return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point,bearing,GeoCircle.vec3Cache[0]),Math.PI/2);}// eslint-disable-next-line jsdoc/require-jsdoc
  static getGreatCircleNormal(arg1,arg2,out){return GeoCircle._getGreatCircleNormal(arg1,arg2,out);}/**
       * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
       * @param arg1 A point that lies on the great circle.
       * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
       * @param out The vector to which to write the result.
       * @returns the normal vector for the great circle.
       */static _getGreatCircleNormal(arg1,arg2,out){if(typeof arg2==='number'){return GeoCircle.getGreatCircleNormalFromPointBearing(arg1,arg2,out);}else {return GeoCircle.getGreatCircleNormalFromPoints(arg1,arg2,out);}}/**
       * Calculates a normal vector for a great circle given two points which lie on the cirlce.
       * @param point1 The first point that lies on the great circle.
       * @param point2 The second point that lies on the great circle.
       * @param out The vector to which to write the result.
       * @returns the normal vector for the great circle.
       */static getGreatCircleNormalFromPoints(point1,point2,out){if(!(point1 instanceof Float64Array)){point1=GeoPoint.sphericalToCartesian(point1,GeoCircle.vec3Cache[0]);}if(!(point2 instanceof Float64Array)){point2=GeoPoint.sphericalToCartesian(point2,GeoCircle.vec3Cache[1]);}return Vec3Math.normalize(Vec3Math.cross(point1,point2,out),out);}/**
       * Calculates a normal vector for a great circle given a point and initial bearing.
       * @param point A point that lies on the great circle.
       * @param bearing The initial bearing from the point.
       * @param out The vector to which to write the result.
       * @returns the normal vector for the great circle.
       */static getGreatCircleNormalFromPointBearing(point,bearing,out){if(point instanceof Float64Array){point=GeoCircle.tempGeoPoint.setFromCartesian(point);}const lat=point.lat*Avionics.Utils.DEG2RAD;const long=point.lon*Avionics.Utils.DEG2RAD;bearing*=Avionics.Utils.DEG2RAD;const sinLat=Math.sin(lat);const sinLon=Math.sin(long);const cosLon=Math.cos(long);const sinBearing=Math.sin(bearing);const cosBearing=Math.cos(bearing);const x=sinLon*cosBearing-sinLat*cosLon*sinBearing;const y=-cosLon*cosBearing-sinLat*sinLon*sinBearing;const z=Math.cos(lat)*sinBearing;return Vec3Math.set(x,y,z,out);}}GeoCircle.ANGULAR_TOLERANCE=1e-7;// ~61cm
  GeoCircle.NORTH_POLE=new Float64Array([0,0,1]);GeoCircle.tempGeoPoint=new GeoPoint(0,0);GeoCircle.vec3Cache=[new Float64Array(3),new Float64Array(3),new Float64Array(3),new Float64Array(3),new Float64Array(3)];GeoCircle.intersectionCache=[new Float64Array(3),new Float64Array(3)];/**
   * Navigational mathematics functions.
   */class NavMath{/**
       * Clamps a value to a min and max.
       * @param val The value to clamp.
       * @param min The minimum value to clamp to.
       * @param max The maximum value to clamp to.
       * @returns The clamped value.
       */static clamp(val,min,max){return Math.min(Math.max(val,min),max);}/**
       * Normalizes a heading to a 0-360 range.
       * @param heading The heading to normalize.
       * @returns The normalized heading.
       */static normalizeHeading(heading){if(isFinite(heading)){return (heading%360+360)%360;}else {console.error("normalizeHeading: Invalid heading: ".concat(heading));return NaN;}}/**
       * Inverts a heading value by adding 180 and normalizing.
       * @param heading The heading to invert/reciprocate.
       * @returns The inverted/reciprocated heading.
       * */static reciprocateHeading(heading){return NavMath.normalizeHeading(heading+180);}/**
       * Gets the turn radius for a given true airspeed.
       * @param airspeedTrue The true airspeed of the plane, in knots.
       * @param bankAngle The bank angle of the plane, in degrees.
       * @returns The airplane turn radius, in meters.
       */static turnRadius(airspeedTrue,bankAngle){return Math.pow(airspeedTrue,2)/(11.26*Math.tan(bankAngle*Avionics.Utils.DEG2RAD))/3.2808399;}/**
       * Gets the required bank angle for a given true airspeed and turn radius.
       * @param airspeedTrue The true airspeed of the plane, in knots.
       * @param radius The airplane turn radius, in meters.
       * @returns The required bank angle, in degrees.
       */static bankAngle(airspeedTrue,radius){const airspeedMS=airspeedTrue*0.51444444;return Math.atan(Math.pow(airspeedMS,2)/(radius*9.80665))*Avionics.Utils.RAD2DEG;}/**
       * Get the turn direction for a given course change.
       * @param startCourse The start course.
       * @param endCourse The end course.
       * @returns The turn direction for the course change.
       */static getTurnDirection(startCourse,endCourse){return NavMath.normalizeHeading(endCourse-startCourse)>180?'left':'right';}/**
       * Converts polar radians to degrees north.
       * @param radians The radians to convert.
       * @returns The angle, in degrees north.
       */static polarToDegreesNorth(radians){return NavMath.normalizeHeading(180/Math.PI*(Math.PI/2-radians));}/**
       * Converts degrees north to polar radians.
       * @param degrees The degrees to convert.
       * @returns The angle radians, in polar.
       */static degreesNorthToPolar(degrees){return NavMath.normalizeHeading(degrees-90)/(180/Math.PI);}/**
       * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
       * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
       * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
       * proceeding clockwise (as viewed from above).
       * @param startBearing The degrees of the start of the arc.
       * @param endBearing The degrees of the end of the arc.
       * @param radius The radius of the arc, in meters.
       * @returns The arc distance.
       */static calculateArcDistance(startBearing,endBearing,radius){const angularWidth=(endBearing-startBearing+360)%360*Avionics.Utils.DEG2RAD;const conversion=UnitType.GA_RADIAN.convertTo(1,UnitType.METER);return angularWidth*Math.sin(radius/conversion)*conversion;}/**
       * Calculates the intersection of a line and a circle.
       * @param x1 The start x of the line.
       * @param y1 The start y of the line.
       * @param x2 The end x of the line.
       * @param y2 The end y of the line.
       * @param cx The circle center x.
       * @param cy The circle center y.
       * @param r The radius of the circle.
       * @param sRef The reference to the solution object to write the solution to.
       * @returns The number of solutions (0, 1 or 2).
       */static circleIntersection(x1,y1,x2,y2,cx,cy,r,sRef){const dx=x2-x1;const dy=y2-y1;const a=dx*dx+dy*dy;const b=2*(dx*(x1-cx)+dy*(y1-cy));const c=(x1-cx)*(x1-cx)+(y1-cy)*(y1-cy)-r*r;const det=b*b-4*a*c;if(a<0.0000001||det<0){sRef.x1=NaN;sRef.x2=NaN;sRef.y1=NaN;sRef.y2=NaN;return 0;}else if(det==0){const t=-b/(2*a);sRef.x1=x1+t*dx;sRef.y1=y1+t*dy;sRef.x2=NaN;sRef.y2=NaN;return 1;}else {const t1=(-b+Math.sqrt(det))/(2*a);sRef.x1=x1+t1*dx;sRef.y1=y1+t1*dy;const t2=(-b-Math.sqrt(det))/(2*a);sRef.x2=x1+t2*dx;sRef.y2=y1+t2*dy;return 2;}}/**
       * Gets the degrees north that a point lies on a circle.
       * @param cx The x point of the center of the circle.
       * @param cy The y point of the center of the circle.
       * @param x The x point to get the bearing for.
       * @param y The y point to get the bearing for.
       * @returns The angle in degrees north that the point is relative to the center.
       */static northAngle(cx,cy,x,y){return NavMath.polarToDegreesNorth(Math.atan2(y-cy,x-cx));}/**
       * Checks if a degrees north bearing is between two other degrees north bearings.
       * @param bearing The bearing in degrees north to check.
       * @param start The start bearing in degrees north.
       * @param end The end bearing, in degrees north.
       * @returns True if the bearing is between the two provided bearings, false otherwise.
       */static bearingIsBetween(bearing,start,end){const range=this.normalizeHeading(end-start);const relativeBearing=this.normalizeHeading(bearing-start);return relativeBearing>=0&&relativeBearing<=range;}/**
       * Converts a degrees north heading to a degrees north turn circle angle.
       * @param heading The heading to convert.
       * @param turnDirection The direction of the turn.
       * @returns A degrees north turn circle angle.
       */static headingToAngle(heading,turnDirection){return NavMath.normalizeHeading(heading+(turnDirection==='left'?90:-90));}/**
       * Converts a degrees north turn circle angle to a degrees north heading.
       * @param angle The turn circle angle to convert.
       * @param turnDirection The direction of the turn.
       * @returns A degrees north heading.
       */static angleToHeading(angle,turnDirection){return NavMath.normalizeHeading(angle+(turnDirection==='left'?-90:90));}/**
       * Calculates the wind correction angle.
       * @param course The current plane true course.
       * @param airspeedTrue The current plane true airspeed.
       * @param windDirection The direction of the wind, in degrees true.
       * @param windSpeed The current speed of the wind.
       * @returns The calculated wind correction angle.
       */static windCorrectionAngle(course,airspeedTrue,windDirection,windSpeed){const currCrosswind=windSpeed*Math.sin(course*Math.PI/180-windDirection*Math.PI/180);const windCorrection=180*Math.asin(currCrosswind/airspeedTrue)/Math.PI;return windCorrection;}/**
       * Calculates the cross track deviation from the provided leg fixes.
       * @param start The location of the starting fix of the leg.
       * @param end The location of the ending fix of the leg.
       * @param pos The current plane location coordinates.
       * @returns The amount of cross track deviation, in nautical miles.
       */static crossTrack(start,end,pos){const path=NavMath.geoCircleCache[0].setAsGreatCircle(start,end);if(isNaN(path.center[0])){return NaN;}return UnitType.GA_RADIAN.convertTo(path.distance(pos),UnitType.NMILE);}/**
       * Calculates the along-track distance from a starting point to another point along a great-circle track running
       * through the starting point.
       * @param start The start of the great-circle track.
       * @param end The end of the great-circle track.
       * @param pos The point for which to calculate the along-track distance.
       * @returns The along-track distance, in nautical miles.
       */static alongTrack(start,end,pos){const path=NavMath.geoCircleCache[0].setAsGreatCircle(start,end);if(isNaN(path.center[0])){return NaN;}const distance=path.distanceAlong(start,path.closest(pos,NavMath.vec3Cache[0]));return UnitType.GA_RADIAN.convertTo((distance+Math.PI)%(2*Math.PI)-Math.PI,UnitType.NMILE);}/**
       * Calculates the desired track from the provided leg fixes.
       * @param start The location of the starting fix of the leg.
       * @param end The location of the ending fix of the leg.
       * @param pos The current plane location coordinates.
       * @returns The desired track, in degrees true.
       */static desiredTrack(start,end,pos){const path=NavMath.geoCircleCache[0].setAsGreatCircle(start,end);if(isNaN(path.center[0])){return NaN;}return path.bearingAt(path.closest(pos,NavMath.vec3Cache[0]));}/**
       * Gets the desired track for a given arc.
       * @param center The center of the arc.
       * @param turnDirection The direction of the turn.
       * @param pos The current plane position.
       * @returns The desired track.
       */static desiredTrackArc(center,turnDirection,pos){const northAngle=NavMath.geoPointCache[0].set(pos).bearingFrom(center);//TODO: Clamp the arc angle to the start and end angles
  return NavMath.angleToHeading(northAngle,turnDirection);}/**
       * Gets the percentage along the arc path that the plane currently is.
       * @param start The start of the arc, in degrees north.
       * @param end The end of the arc, in degrees north.
       * @param center The center location of the arc.
       * @param turnDirection The direction of the turn.
       * @param pos The current plane position.
       * @returns The percentage along the arc the plane is.
       */static percentAlongTrackArc(start,end,center,turnDirection,pos){const bearingFromCenter=NavMath.geoPointCache[0].set(center).bearingTo(pos);const sign=turnDirection==='right'?1:-1;const alpha=((end-start)*sign+360)%360;const mid=(start+alpha/2*sign+360)%360;const rotBearing=(bearingFromCenter-mid+540)%360-180;const frac=rotBearing*sign/alpha+0.5;return frac;}/**
       * Gets a position given an arc and a distance from the arc start.
       * @param start The start bearing of the arc.
       * @param center The center of the arc.
       * @param radius The radius of the arc.
       * @param turnDirection The turn direction for the arc.
       * @param distance The distance along the arc to get the position for.
       * @param out The position to write to.
       * @returns The position along the arc that was written to.
       */static positionAlongArc(start,center,radius,turnDirection,distance,out){const convertedRadius=UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius,UnitType.GA_RADIAN)),UnitType.METER);const theta=UnitType.RADIAN.convertTo(distance/convertedRadius,UnitType.DEGREE);const bearing=turnDirection==='right'?start+theta:start-theta;center.offset(NavMath.normalizeHeading(bearing),UnitType.METER.convertTo(radius,UnitType.GA_RADIAN),out);return out;}/**
       * Gets the cross track distance for a given arc.
       * @param center The center of the arc.
       * @param radius The radius of the arc, in meters.
       * @param pos The current plane position.
       * @returns The cross track distance, in NM.
       */static crossTrackArc(center,radius,pos){return UnitType.METER.convertTo(radius,UnitType.NMILE)-UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center),UnitType.NMILE);}/**
       * Gets the total difference in degrees between two angles.
       * @param a The first angle.
       * @param b The second angle.
       * @returns The difference between the two angles, in degrees.
       */static diffAngle(a,b){let diff=b-a;while(diff>180){diff-=360;}while(diff<=-180){diff+=360;}return diff;}/**
       * Finds side a given sides b, c, and angles beta, gamma.
       * @param b The length of side b, as a trigonometric ratio.
       * @param c The length of side c, as a trigonometric ratio.
       * @param beta The angle, in radians, of the opposite of side b.
       * @param gamma The angle, in radians, of the opposite of side c
       * @returns The length of side a, as a trigonometric ratio.
       */static napierSide(b,c,beta,gamma){return 2*Math.atan(Math.tan(0.5*(b-c))*(Math.sin(0.5*(beta+gamma))/Math.sin(0.5*(beta-gamma))));}/**
       * Calculates a normal vector to a provided course in degrees north.
       * @param course The course in degrees north.
       * @param turnDirection The direction of the turn to orient the normal.
       * @param outVector The normal vector for the provided course.
       */static normal(course,turnDirection,outVector){const normalCourse=NavMath.headingToAngle(course,turnDirection);const polarCourse=NavMath.degreesNorthToPolar(normalCourse);outVector[0]=Math.cos(polarCourse);outVector[1]=Math.sin(polarCourse);}}NavMath.vec3Cache=[new Float64Array(3)];NavMath.geoPointCache=[new GeoPoint(0,0),new GeoPoint(0,0)];NavMath.geoCircleCache=[new GeoCircle(new Float64Array(3),0)];/// <reference types="@microsoft/msfs-types/coherent/facilities" />
  /**
   * A utility class for working with magnetic variation (magnetic declination).
   */class MagVar{// eslint-disable-next-line jsdoc/require-jsdoc
  static get(arg1,arg2){return MagVar.getMagVar(arg1,arg2);}// eslint-disable-next-line jsdoc/require-jsdoc
  static magneticToTrue(bearing,arg1,arg2){return NavMath.normalizeHeading(bearing+(typeof arg1==='number'&&arg2===undefined?arg1:MagVar.getMagVar(arg1,arg2)));}// eslint-disable-next-line jsdoc/require-jsdoc
  static trueToMagnetic(bearing,arg1,arg2){return NavMath.normalizeHeading(bearing-(typeof arg1==='number'&&arg2===undefined?arg1:MagVar.getMagVar(arg1,arg2)));}/**
       * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
       * @param arg1 The query point, or the latitude of the query point.
       * @param arg2 The longitude of the query point.
       * @returns The magnetic variation (magnetic declination) at the point.
       */static getMagVar(arg1,arg2){if(typeof Facilities==='undefined'){// In case this code is executed before the Facilities class is created.
  return 0;}let lat,lon;if(typeof arg1==='number'){lat=arg1;lon=arg2;}else {lat=arg1.lat;lon=arg1.lon;}return Facilities.getMagVar(lat,lon);}}/**
   * A Subject which provides a {@link GeoPointInterface} value.
   */class GeoPointSubject extends AbstractSubscribable{/**
       * Constructor.
       * @param value The value of this subject.
       * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
       * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
       */constructor(value,tolerance){super();this.value=value;this.tolerance=tolerance;/** @inheritdoc */this.isMutableSubscribable=true;}/**
       * Creates a GeoPointSubject.
       * @param initialVal The initial value.
       * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
       * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
       * @returns A GeoPointSubject.
       */static create(initialVal,tolerance){return new GeoPointSubject(initialVal,tolerance);}/**
       * Creates a GeoPointSubject.
       * @param initialVal The initial value.
       * @returns A GeoPointSubject.
       * @deprecated Use `GeoPointSubject.create()` instead.
       */static createFromGeoPoint(initialVal){return new GeoPointSubject(initialVal);}/** @inheritdoc */get(){return this.value.readonly;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,arg2){const isArg1Number=typeof arg1==='number';const equals=isArg1Number?this.value.equals(arg1,arg2,this.tolerance):this.value.equals(arg1,this.tolerance);if(!equals){isArg1Number?this.value.set(arg1,arg2):this.value.set(arg1);this.notify();}}}/**
   * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
   * to define the type of projection to be implemented.
   */class AbstractGeoProjection{constructor(){this.center=new GeoPoint(0,0);this.centerTranslation=new Float64Array(2);this.scaleFactor=UnitType.GA_RADIAN.convertTo(1,UnitType.NMILE);// 1 pixel = 1 nautical mile
  this.preRotation=new Float64Array(3);this.translation=new Float64Array(2);this.postRotation=0;this.rotationSin=0;this.rotationCos=1;this.reflectY=1;this.preRotationForwardTransform=new Transform3D();this.preRotationReverseTransform=new Transform3D();this.rotationCache=[new Transform3D(),new Transform3D()];}/** @inheritdoc */getCenter(){return this.center.readonly;}/** @inheritdoc */getScaleFactor(){return this.scaleFactor;}/** @inheritdoc */getPreRotation(){return this.preRotation;}/** @inheritdoc */getTranslation(){return this.translation;}/** @inheritdoc */getPostRotation(){return this.postRotation;}/** @inheritdoc */getReflectY(){return this.reflectY===-1;}/** @inheritdoc */setCenter(point){this.center.set(point);this.updateCenterTranslation();return this;}/** @inheritdoc */setScaleFactor(factor){this.scaleFactor=factor;return this;}/** @inheritdoc */setPreRotation(vec){this.preRotation.set(vec);this.updatePreRotationTransforms();this.updateCenterTranslation();return this;}/** @inheritdoc */setTranslation(vec){this.translation.set(vec);return this;}/** @inheritdoc */setPostRotation(rotation){this.postRotation=rotation;this.rotationCos=Math.cos(rotation);this.rotationSin=Math.sin(rotation);return this;}/** @inheritdoc */setReflectY(val){this.reflectY=val?-1:1;return this;}/** @inheritdoc */copyParametersFrom(other){return this.setCenter(other.getCenter()).setPreRotation(other.getPreRotation()).setScaleFactor(other.getScaleFactor()).setTranslation(other.getTranslation()).setPostRotation(other.getPostRotation()).setReflectY(other.getReflectY());}/**
       * Updates the pre-rotation transformation matrices.
       */updatePreRotationTransforms(){const phi=this.preRotation[1];const gamma=this.preRotation[2];this.rotationCache[0].toRotationX(gamma);this.rotationCache[1].toRotationY(-phi);Transform3D.concat(this.preRotationForwardTransform,this.rotationCache);this.preRotationReverseTransform.set(this.preRotationForwardTransform);this.preRotationReverseTransform.invert();}/**
       * Updates the translation vector to move the center of this projection to the origin.
       */updateCenterTranslation(){const centerArray=AbstractGeoProjection.vec2Cache[0];centerArray[0]=this.center.lon;centerArray[1]=this.center.lat;this.preRotateForward(centerArray,centerArray);this.projectRaw(centerArray,this.centerTranslation);}/**
       * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
       * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
       * @param out - the vector to which to write the result.
       * @returns the rotated lat/lon coordinates.
       */preRotateForward(vec,out){const lambda=this.preRotation[0];const phi=this.preRotation[1];const gamma=this.preRotation[2];if(lambda===0&&phi===0&&gamma===0){out.set(vec);return out;}const lat=vec[1];const lon=vec[0];const rotatedLon=((lon+lambda*Avionics.Utils.RAD2DEG)%360+540)%360-180;// enforce [-180, 180)
  if(phi===0&&gamma===0){return Vec2Math.set(rotatedLon,lat,out);}const cartesianVec=GeoPoint.sphericalToCartesian(lat,rotatedLon,AbstractGeoProjection.vec3Cache[0]);const rotatedCartesianVec=this.preRotationForwardTransform.apply(cartesianVec,cartesianVec);const rotated=AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);return Vec2Math.set(rotated.lon,rotated.lat,out);}/**
       * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
       * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
       * @param out - the vector to which to write the result.
       * @returns the rotated lat/lon coordinates.
       */preRotateReverse(vec,out){const lambda=this.preRotation[0];const phi=this.preRotation[1];const gamma=this.preRotation[2];if(lambda===0&&phi===0&&gamma===0){out.set(vec);return out;}const lat=vec[1];const lon=vec[0];let rotatedLat=lat;let rotatedLon=lon;if(phi!==0||gamma!==0){const rotatedCartesianVec=GeoPoint.sphericalToCartesian(rotatedLat,rotatedLon,AbstractGeoProjection.vec3Cache[0]);const cartesianVec=this.preRotationReverseTransform.apply(rotatedCartesianVec,rotatedCartesianVec);const unrotated=AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);rotatedLat=unrotated.lat;rotatedLon=unrotated.lon;}rotatedLon=((rotatedLon-lambda*Avionics.Utils.RAD2DEG)%360+540)%360-180;// enforce [-180, 180)
  return Vec2Math.set(rotatedLon,rotatedLat,out);}/** @inheritdoc */project(point,out){if(point instanceof Float64Array){out.set(point);}else {out[0]=point.lon;out[1]=point.lat;}this.preRotateForward(out,out);this.projectRaw(out,out);// translate projected center point to origin
  out[0]-=this.centerTranslation[0];out[1]-=this.centerTranslation[1];// apply y-reflection
  out[1]*=this.reflectY;// apply scale factor
  out[0]*=this.scaleFactor;out[1]*=this.scaleFactor;// apply post-projection rotation
  const x=out[0];const y=out[1];out[0]=x*this.rotationCos-y*this.rotationSin;out[1]=x*this.rotationSin+y*this.rotationCos;// apply post-projection translation
  out[0]+=this.translation[0];out[1]+=this.translation[1];return out;}/** @inheritdoc */invert(vec,out){const projected=AbstractGeoProjection.vec2Cache[0];projected.set(vec);// invert post-projection translation
  projected[0]-=this.translation[0];projected[1]-=this.translation[1];// invert post-projection rotation
  const x=projected[0];const y=projected[1];projected[0]=x*this.rotationCos+y*this.rotationSin;projected[1]=-x*this.rotationSin+y*this.rotationCos;// invert scale factor
  projected[0]/=this.scaleFactor;projected[1]/=this.scaleFactor;// invert y-reflection
  projected[1]*=this.reflectY;// translate projected center point to default projected position
  projected[0]+=this.centerTranslation[0];projected[1]+=this.centerTranslation[1];const inverted=this.invertRaw(projected,projected);this.preRotateReverse(inverted,inverted);if(out instanceof Float64Array){out.set(inverted);return out;}else {return out.set(inverted[1],inverted[0]);}}}AbstractGeoProjection.vec2Cache=[new Float64Array(2)];AbstractGeoProjection.vec3Cache=[new Float64Array(3)];AbstractGeoProjection.geoPointCache=[new GeoPoint(0,0)];/**
   * A Mercator projection.
   */class MercatorProjection extends AbstractGeoProjection{/**
       * Applies a raw projection.
       * @param vec - a [lon, lat] vector describing the geographic point to project.
       * @param out - a 2D vector to which to write the result.
       * @returns the projected point.
       */projectRaw(vec,out){out[0]=vec[0]*Avionics.Utils.DEG2RAD;out[1]=Math.log(Math.tan((90+vec[1])*Avionics.Utils.DEG2RAD/2));return out;}/**
       * Inverts a raw projection.
       * @param vec - a 2D vector describing the projected point to invert.
       * @param out - a 2D vector to which to write the result.
       * @returns the inverted point.
       */invertRaw(vec,out){out[0]=vec[0]*Avionics.Utils.RAD2DEG;out[1]=2*Math.atan(Math.exp(vec[1]))*Avionics.Utils.RAD2DEG-90;return out;}}/**
   * Resamples projected great- and small-circle paths between defined endpoints into series of straight line segments and circular arcs.
   */class GeoCircleResampler{/**
       * Constructor.
       * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
       * points, in great-arc radians.
       * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
       * a resampled point during the simplification process.
       * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
       * points is bounded from above by `2^[maxDepth] - 1`.
       */constructor(minDistance,dpTolerance,maxDepth){this.minDistance=minDistance;this.dpTolerance=dpTolerance;this.maxDepth=maxDepth;this.geoPointCache=[new GeoPoint(0,0),new GeoPoint(0,0)];this.vec2Cache=[new Float64Array(2),new Float64Array(2),new Float64Array(2)];this.vec3Cache=[new Float64Array(3),new Float64Array(3),new Float64Array(3),new Float64Array(3),new Float64Array(3)];this.startVector={type:'start',point:new GeoPoint(0,0),projected:new Float64Array(2),index:0};this.lineVector={type:'line',point:new GeoPoint(0,0),projected:new Float64Array(2),index:0};this.arcVector={type:'arc',point:new GeoPoint(0,0),projected:new Float64Array(2),projectedArcCenter:new Float64Array(2),projectedArcRadius:0,projectedArcStartAngle:0,projectedArcEndAngle:0,index:0};this.state={index:0,prevX:0,prevY:0,vectorType:'line',arcCenterX:0,arcCenterY:0,arcRadius:0,isArcCounterClockwise:false};this.cosMinDistance=Math.cos(minDistance);this.dpTolSq=dpTolerance*dpTolerance;}/**
       * Resamples a projected great- or small-circle path.
       * @param projection The projection to use.
       * @param circle The geo circle along which the path lies.
       * @param start The start of the path.
       * @param end The end of the path.
       * @param handler A function to handle the resampled points. The function is called once for each resampled point,
       * in order.
       */resample(projection,circle,start,end,handler){let startPoint,startVec,endPoint,endVec;if(start instanceof Float64Array){startPoint=this.geoPointCache[0].setFromCartesian(start);startVec=start;}else {startPoint=start;startVec=GeoPoint.sphericalToCartesian(start,this.vec3Cache[0]);}if(end instanceof Float64Array){endPoint=this.geoPointCache[0].setFromCartesian(end);endVec=end;}else {endPoint=end;endVec=GeoPoint.sphericalToCartesian(end,this.vec3Cache[1]);}const startLat=startPoint.lat;const startLon=startPoint.lon;const endLat=endPoint.lat;const endLon=endPoint.lon;const startProjected=projection.project(start,this.vec2Cache[0]);const endProjected=projection.project(end,this.vec2Cache[1]);const startX=startProjected[0];const startY=startProjected[1];const endX=endProjected[0];const endY=endProjected[1];this.startVector.point.set(startLat,startLon);Vec2Math.copy(startProjected,this.startVector.projected);handler(this.startVector);this.state.index=1;this.state.prevX=startX;this.state.prevY=startY;this.state.vectorType='line';const state=this.resampleHelper(projection,circle,startLat,startLon,startVec[0],startVec[1],startVec[2],startX,startY,endLat,endLon,endVec[0],endVec[1],endVec[2],endX,endY,handler,0,this.state);this.callHandler(handler,endLat,endLon,endX,endY,state);}/**
       * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
       * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
       * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
       * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
       * and at least one of the following conditions is met:
       * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
       * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
       * this resampler's Douglas-Peucker tolerance.
       * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
       * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
       * @param projection The projection to use.
       * @param circle The geo circle along which the path lies.
       * @param lat1 The latitude of the start of the path, in degrees.
       * @param lon1 The longitude of the start of the path, in degrees.
       * @param x1 The x-component of the Cartesian position vector of the start of the path.
       * @param y1 The y-component of the Cartesian position vector of the start of the path.
       * @param z1 The z-component of the Cartesian position vector of the start of the path.
       * @param projX1 The x-component of the projected location of the start of the path, in pixels.
       * @param projY1 The y-component of the projected location of the start of the path, in pixels.
       * @param lat2 The latitude of the end of the path, in degrees.
       * @param lon2 The longitude of the end of the path, in degrees.
       * @param x2 The x-component of the Cartesian position vector of the end of the path.
       * @param y2 The y-component of the Cartesian position vector of the end of the path.
       * @param z2 The z-component of the Cartesian position vector of the end of the path.
       * @param projX2 The x-component of the projected location of the end of the path, in pixels.
       * @param projY2 The y-component of the projected location of the end of the path, in pixels.
       * @param handler A function to handle the resampled points.
       * @param depth The current depth of the resampling algorithm.
       * @param state The current state of the resampling algorithm.
       * @returns The index of the next resampled point.
       */resampleHelper(projection,circle,lat1,lon1,x1,y1,z1,projX1,projY1,lat2,lon2,x2,y2,z2,projX2,projY2,handler,depth,state){if(depth>=this.maxDepth){return state;}const startVec=Vec3Math.set(x1,y1,z1,this.vec3Cache[0]);const endVec=Vec3Math.set(x2,y2,z2,this.vec3Cache[1]);const angularWidth=circle.angleAlong(startVec,endVec,Math.PI);if(angularWidth<=GeoCircle.ANGULAR_TOLERANCE){return state;}const midVec=circle.offsetAngleAlong(startVec,angularWidth/2,this.vec3Cache[2]);const startProjected=Vec2Math.set(projX1,projY1,this.vec2Cache[0]);const endProjected=Vec2Math.set(projX2,projY2,this.vec2Cache[1]);const deltaProjected=Vec2Math.sub(endProjected,startProjected,this.vec2Cache[2]);const deltaProjectedDot=Vec2Math.dot(deltaProjected,deltaProjected);const midPoint=this.geoPointCache[0].setFromCartesian(midVec);const midProjected=projection.project(midPoint,this.vec2Cache[2]);const lat0=midPoint.lat;const lon0=midPoint.lon;const x0=midVec[0];const y0=midVec[1];const z0=midVec[2];const projX0=midProjected[0];const projY0=midProjected[1];const A=projX2-projX1;const B=projY2-projY1;const C=projX1*projX1-projX2*projX2+projY1*projY1-projY2*projY2;const D=projX0-projX1;const E=projY0-projY1;const F=projX1*projX1-projX0*projX0+projY1*projY1-projY0*projY0;// Calculate the Douglas-Peucker metric
  const det=2*(A*E-B*D);const dpDisSq=det*det/4/deltaProjectedDot;if(dpDisSq>this.dpTolSq){// Attempt to model the projected path with an arc
  // Find the center of circle containing the arc passing through the projected start, end, and mid points.
  const arcCenterX=(B*F-C*E)/det;const arcCenterY=(C*D-A*F)/det;const arcRadius=Math.hypot(arcCenterX-projX1,arcCenterY-projY1);const startToEndVec=Vec3Math.set(A,B,0,this.vec3Cache[3]);const centerToMidVec=Vec3Math.set(projX0-arcCenterX,projY0-arcCenterY,0,this.vec3Cache[4]);const cross=Vec3Math.cross(startToEndVec,centerToMidVec,this.vec3Cache[4]);state.vectorType='arc';state.arcCenterX=arcCenterX;state.arcCenterY=arcCenterY;state.arcRadius=arcRadius;state.isArcCounterClockwise=cross[2]>0;}else {state.vectorType='line';}const cosDistance=Vec3Math.dot(startVec,midVec);if(cosDistance>this.cosMinDistance){// cosine of distance increases with decreasing distance
  // We are below the minimum distance required to continue resampling -> decide if we need to continue or if
  // the path can satisfactorily be modeled as either a straight line or a circular arc.
  if(state.vectorType==='line'){// The path can be modeled as a line.
  return state;}// To find whether the path can be modeled as an arc, we need to project the one-quarter and three-quarter points
  // along the path and find the projected points' distances from the arc modeled above. If the distances are
  // within the D-P tolerance, then the path can be modeled as an arc.
  const query=circle.offsetAngleAlong(startVec,angularWidth/4,this.geoPointCache[0]);const projectedQuery=projection.project(query,this.vec2Cache[0]);let distance=Math.hypot(projectedQuery[0]-state.arcCenterX,projectedQuery[1]-state.arcCenterY);if((distance-state.arcRadius)*(distance-state.arcRadius)<=this.dpTolSq){circle.offsetAngleAlong(startVec,3*angularWidth/4,query);projection.project(query,projectedQuery);distance=Math.hypot(projectedQuery[0]-state.arcCenterX,projectedQuery[1]-state.arcCenterY);if((distance-state.arcRadius)*(distance-state.arcRadius)<=this.dpTolSq){return state;}}}state=this.resampleHelper(projection,circle,lat1,lon1,x1,y1,z1,projX1,projY1,lat0,lon0,x0,y0,z0,projX0,projY0,handler,depth+1,state);this.callHandler(handler,lat0,lon0,projX0,projY0,state);state.index++;state.prevX=projX0;state.prevY=projY0;return this.resampleHelper(projection,circle,lat0,lon0,x0,y0,z0,projX0,projY0,lat2,lon2,x2,y2,z2,projX2,projY2,handler,depth+1,state);}/**
       * Calls a handler function for a resampled point.
       * @param handler The handler function to call.
       * @param lat The latitude of the resampled point, in degrees.
       * @param lon The longitude of the resampled point, in degrees.
       * @param projX The x-coordinate of the projected resampled point, in pixels.
       * @param projY The y-coordinate of the projected resampled point, in pixels.
       * @param state The current state of the resampling algorithm.
       */callHandler(handler,lat,lon,projX,projY,state){let vector;if(state.vectorType==='line'){vector=this.lineVector;}else {vector=this.arcVector;Vec2Math.set(state.arcCenterX,state.arcCenterY,vector.projectedArcCenter);vector.projectedArcRadius=state.arcRadius;vector.projectedArcStartAngle=Math.atan2(state.prevY-state.arcCenterY,state.prevX-state.arcCenterX);vector.projectedArcEndAngle=Math.atan2(projY-state.arcCenterY,projX-state.arcCenterX);if(vector.projectedArcEndAngle<vector.projectedArcStartAngle!==state.isArcCounterClockwise){vector.projectedArcEndAngle+=state.isArcCounterClockwise?-MathUtils.TWO_PI:MathUtils.TWO_PI;}}vector.point.set(lat,lon);Vec2Math.set(projX,projY,vector.projected);vector.index=state.index;handler(vector);}}/**
   * The possible reference norths for navigation angle units.
   */var NavAngleUnitReferenceNorth;(function(NavAngleUnitReferenceNorth){NavAngleUnitReferenceNorth["True"]="true";NavAngleUnitReferenceNorth["Magnetic"]="magnetic";})(NavAngleUnitReferenceNorth||(NavAngleUnitReferenceNorth={}));/**
   * A basic implementation of a navigation angle unit.
   */class BasicNavAngleUnit extends AbstractUnit{/**
       * Constructor.
       * @param referenceNorth The reference north of the new unit.
       * @param magVar The initial magnetic variation of the new unit.
       */constructor(referenceNorth,magVar){super(referenceNorth===NavAngleUnitReferenceNorth.True?'true bearing':'magnetic bearing');/** @inheritdoc */this.family='navangle';this._magVar=0;this._magVar=magVar;}/** @inheritdoc */get magVar(){return this._magVar;}/**
       * Checks whether this nav angle unit is relative to magnetic north.
       * @returns Whether this nav angle unit is relative to magnetic north.
       */isMagnetic(){return this.name==='magnetic bearing';}/**
       * Converts a value of this unit to another unit. This unit's magnetic variation is used for the conversion.
       * @param value The value to convert.
       * @param toUnit The unit to which to convert.
       * @returns The converted value.
       * @throws Error if attempting an invalid conversion.
       */convertTo(value,toUnit){if(!this.canConvert(toUnit)){throw new Error("Invalid conversion from ".concat(this.name," to ").concat(toUnit.name,"."));}if(!isFinite(value)){return NaN;}if(this.isMagnetic()===toUnit.isMagnetic()){return value;}return this.isMagnetic()?MagVar.magneticToTrue(value,this.magVar):MagVar.trueToMagnetic(value,this.magVar);}/**
       * Converts a value of another unit to this unit. This unit's magnetic variation is used for the conversion.
       * @param value The value to convert.
       * @param fromUnit The unit from which to convert.
       * @returns The converted value.
       * @throws Error if attempting an invalid conversion.
       */convertFrom(value,fromUnit){if(!this.canConvert(fromUnit)){throw new Error("Invalid conversion from ".concat(fromUnit.name," to ").concat(this.name,"."));}if(!isFinite(value)){return NaN;}if(this.isMagnetic()===fromUnit.isMagnetic()){return value;}return this.isMagnetic()?MagVar.trueToMagnetic(value,this.magVar):MagVar.magneticToTrue(value,this.magVar);}/**
       * Sets this unit's magnetic variation.
       * @param magVar The magnetic variation to set, in degrees.
       */setMagVar(magVar){this._magVar=magVar;}// eslint-disable-next-line jsdoc/require-jsdoc
  setMagVarFromLocation(arg1,arg2){if(typeof arg1==='number'){this._magVar=MagVar.get(arg1,arg2);}else {this._magVar=MagVar.get(arg1);}}/** @inheritdoc */equals(other){return other instanceof BasicNavAngleUnit&&this.name===other.name&&this.magVar===other.magVar;}// eslint-disable-next-line jsdoc/require-jsdoc
  static create(isMagnetic,arg2,arg3){const referenceNorth=isMagnetic?NavAngleUnitReferenceNorth.Magnetic:NavAngleUnitReferenceNorth.True;let magVar=0;if(arg2!==undefined){if(typeof arg2==='number'){if(arg3===undefined){magVar=arg2;}else {magVar=MagVar.get(arg2,arg3);}}else {magVar=MagVar.get(arg2);}}return new BasicNavAngleUnit(referenceNorth,magVar);}}/**
   * A Subject which provides a navigation angle value.
   */class BasicNavAngleSubject extends AbstractSubscribable{/**
       * Constructor.
       * @param value The value of this subject.
       */constructor(value){super();this.value=value;/** @inheritdoc */this.isMutableSubscribable=true;}/**
       * Creates a BasicNavAngleSubject.
       * @param initialVal The initial value.
       * @returns A BasicNavAngleSubject.
       */static create(initialVal){return new BasicNavAngleSubject(initialVal);}/** @inheritdoc */get(){return this.value.readonly;}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,arg2,arg3){const isArg1Number=typeof arg1==='number';const isArg2Number=typeof arg2==='number';const isArg2LatLon=typeof arg2==='object'&&'lat'in arg2&&'lon'in arg2;const unit=isArg1Number?isArg2Number||isArg2LatLon||arg2===undefined?this.value.unit:arg2:arg1.unit;const oldMagVar=this.value.unit.magVar;const oldValue=this.value.number;if(isArg2LatLon){this.value.unit.setMagVarFromLocation(arg2);}else if(isArg2Number){if(typeof arg3==='number'){this.value.unit.setMagVarFromLocation(arg2,arg3);}else {this.value.unit.setMagVar(arg2);}}else {this.value.unit.setMagVar(unit.magVar);}if(isArg1Number){this.value.set(arg1,unit);}else {this.value.set(arg1);}if(!(isNaN(oldMagVar)&&isNaN(this.value.unit.magVar))&&oldMagVar!==this.value.unit.magVar||!(isNaN(oldValue)&&isNaN(this.value.number))&&oldValue!==this.value.number){this.notify();}}}BasicNavAngleSubject.TRUE_BEARING=BasicNavAngleUnit.create(false);/**
   * A publisher for anti-ice system information.
   */class AntiIcePublisher extends SimVarPublisher{/**
       * Creates an instance of an AntiIcePublisher.
       * @param bus The event bus to use with this instance.
       * @param pacer An optional pacer to use to control the rate of publishing.
       */constructor(bus,pacer){const engineIndexedSimVars=[['anti_ice_engine_switch_on',{name:'ENG ANTI ICE',type:SimVarValueType.Bool}],['anti_ice_prop_switch_on',{name:'PROP DEICE SWITCH',type:SimVarValueType.Bool}]];const simvars=new Map(AntiIcePublisher.nonIndexedSimVars);// add engine-indexed simvars
  const engineCount=SimVar.GetSimVarValue('NUMBER OF ENGINES',SimVarValueType.Number);for(const[topic,simvar]of engineIndexedSimVars){for(let i=1;i<=engineCount;i++){simvars.set("".concat(topic,"_").concat(i),{name:"".concat(simvar.name,":").concat(i),type:simvar.type,map:simvar.map});}}super(simvars,bus,pacer);}}AntiIcePublisher.nonIndexedSimVars=[['anti_ice_structural_switch_on',{name:'STRUCTURAL DEICE SWITCH',type:SimVarValueType.Bool}],['anti_ice_windshield_switch_on',{name:'WINDSHIELD DEICE SWITCH',type:SimVarValueType.Bool}]];var APLockType;(function(APLockType){APLockType[APLockType["Heading"]=0]="Heading";APLockType[APLockType["Nav"]=1]="Nav";APLockType[APLockType["Alt"]=2]="Alt";APLockType[APLockType["Bank"]=3]="Bank";APLockType[APLockType["WingLevel"]=4]="WingLevel";APLockType[APLockType["Vs"]=5]="Vs";APLockType[APLockType["Flc"]=6]="Flc";APLockType[APLockType["Pitch"]=7]="Pitch";APLockType[APLockType["Approach"]=8]="Approach";APLockType[APLockType["Backcourse"]=9]="Backcourse";APLockType[APLockType["Glideslope"]=10]="Glideslope";APLockType[APLockType["VNav"]=11]="VNav";})(APLockType||(APLockType={}));/** base publisher for simvars */class APSimVarPublisher extends SimVarPublisher{/**
       * Create an APSimVarPublisher
       * @param bus The EventBus to publish to
       * @param pacer An optional pacer to use to control the pace of publishing
       */constructor(bus){let pacer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;super(APSimVarPublisher.simvars,bus,pacer);}}APSimVarPublisher.simvars=new Map([['ap_heading_selected',{name:'AUTOPILOT HEADING LOCK DIR:1',type:SimVarValueType.Degree}],['ap_heading_selected_1',{name:'AUTOPILOT HEADING LOCK DIR:1',type:SimVarValueType.Degree}],['ap_heading_selected_2',{name:'AUTOPILOT HEADING LOCK DIR:2',type:SimVarValueType.Degree}],['ap_heading_selected_3',{name:'AUTOPILOT HEADING LOCK DIR:3',type:SimVarValueType.Degree}],['ap_altitude_selected',{name:'AUTOPILOT ALTITUDE LOCK VAR:1',type:SimVarValueType.Feet}],['ap_altitude_selected_1',{name:'AUTOPILOT ALTITUDE LOCK VAR:1',type:SimVarValueType.Feet}],['ap_altitude_selected_2',{name:'AUTOPILOT ALTITUDE LOCK VAR:2',type:SimVarValueType.Feet}],['ap_altitude_selected_3',{name:'AUTOPILOT ALTITUDE LOCK VAR:3',type:SimVarValueType.Feet}],['ap_master_status',{name:'AUTOPILOT MASTER',type:SimVarValueType.Bool}],['ap_yd_status',{name:'AUTOPILOT YAW DAMPER',type:SimVarValueType.Bool}],['ap_heading_hold',{name:'AUTOPILOT HEADING LOCK',type:SimVarValueType.Bool}],['ap_nav_hold',{name:'AUTOPILOT NAV1 LOCK',type:SimVarValueType.Bool}],['ap_bank_hold',{name:'AUTOPILOT BANK HOLD',type:SimVarValueType.Bool}],['ap_max_bank_id',{name:'AUTOPILOT MAX BANK ID',type:SimVarValueType.Number}],['ap_max_bank_value',{name:'AUTOPILOT MAX BANK',type:SimVarValueType.Degree}],['ap_wing_lvl_hold',{name:'AUTOPILOT WING LEVELER',type:SimVarValueType.Bool}],['ap_approach_hold',{name:'AUTOPILOT APPROACH HOLD',type:SimVarValueType.Bool}],['ap_backcourse_hold',{name:'AUTOPILOT BACKCOURSE HOLD',type:SimVarValueType.Bool}],['ap_vs_hold',{name:'AUTOPILOT VERTICAL HOLD',type:SimVarValueType.Bool}],['ap_flc_hold',{name:'AUTOPILOT FLIGHT LEVEL CHANGE',type:SimVarValueType.Bool}],['ap_alt_hold',{name:'AUTOPILOT ALTITUDE LOCK',type:SimVarValueType.Bool}],['ap_glideslope_hold',{name:'AUTOPILOT GLIDESLOPE HOLD',type:SimVarValueType.Bool}],['ap_pitch_hold',{name:'AUTOPILOT PITCH HOLD',type:SimVarValueType.Bool}],['ap_toga_hold',{name:'AUTOPILOT TAKEOFF POWER ACTIVE',type:SimVarValueType.Bool}],['ap_vs_selected',{name:'AUTOPILOT VERTICAL HOLD VAR:1',type:SimVarValueType.FPM}],['ap_fpa_selected',{name:'L:WT_AP_FPA_Target:1',type:SimVarValueType.Degree}],['ap_ias_selected',{name:'AUTOPILOT AIRSPEED HOLD VAR',type:SimVarValueType.Knots}],['ap_mach_selected',{name:'AUTOPILOT MACH HOLD VAR',type:SimVarValueType.Number}],['ap_selected_speed_is_mach',{name:'AUTOPILOT MANAGED SPEED IN MACH',type:SimVarValueType.Bool}],['ap_selected_speed_is_manual',{name:'L:XMLVAR_SpeedIsManuallySet',type:SimVarValueType.Bool}],['flight_director_bank',{name:'AUTOPILOT FLIGHT DIRECTOR BANK',type:SimVarValueType.Degree}],['flight_director_pitch',{name:'AUTOPILOT FLIGHT DIRECTOR PITCH',type:SimVarValueType.Degree}],['flight_director_is_active_1',{name:'AUTOPILOT FLIGHT DIRECTOR ACTIVE:1',type:SimVarValueType.Bool}],['flight_director_is_active_2',{name:'AUTOPILOT FLIGHT DIRECTOR ACTIVE:2',type:SimVarValueType.Bool}],['vnav_active',{name:'L:XMLVAR_VNAVButtonValue',type:SimVarValueType.Bool}],['ap_pitch_selected',{name:'AUTOPILOT PITCH HOLD REF',type:SimVarValueType.Degree}]]);/** The basic radio types. */var RadioType;(function(RadioType){RadioType["Com"]="COM";RadioType["Nav"]="NAV";RadioType["Adf"]="ADF";})(RadioType||(RadioType={}));/** The two frequency "banks", active and standby. */var FrequencyBank;(function(FrequencyBank){FrequencyBank[FrequencyBank["Active"]=0]="Active";FrequencyBank[FrequencyBank["Standby"]=1]="Standby";})(FrequencyBank||(FrequencyBank={}));/** COM frequency spacing on COM radios. */var ComSpacing;(function(ComSpacing){/** 25Khz spacing */ComSpacing[ComSpacing["Spacing25Khz"]=0]="Spacing25Khz";/** 8.33Khz spacing */ComSpacing[ComSpacing["Spacing833Khz"]=1]="Spacing833Khz";})(ComSpacing||(ComSpacing={}));/// <reference types="@microsoft/msfs-types/js/simvar" />
  /**
   * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
   */class NavProcSimVarPublisher extends SimVarPublisher{/**
       * Create a NavProcSimVarPublisher
       * @param bus The EventBus to publish to
       * @param pacer An optional pacer to use to control the pace of publishing
       */constructor(bus){let pacer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;super(NavProcSimVarPublisher.simvars,bus,pacer);}/**
       * Creates an array of nav radio sim var event definitions for an indexed nav radio.
       * @param index The index of the nav radio.
       * @returns An array of nav radio sim var event definitions for the specified nav radio.
       */static createNavRadioDefinitions(index){return [["nav_signal_".concat(index),{name:"NAV SIGNAL:".concat(index),type:SimVarValueType.Number}],["nav_obs_".concat(index),{name:"NAV OBS:".concat(index),type:SimVarValueType.Degree}],["nav_has_dme_".concat(index),{name:"NAV HAS DME:".concat(index),type:SimVarValueType.Bool}],["nav_has_nav_".concat(index),{name:"NAV HAS NAV:".concat(index),type:SimVarValueType.Bool}],["nav_cdi_".concat(index),{name:"NAV CDI:".concat(index),type:SimVarValueType.Number}],["nav_dme_".concat(index),{name:"NAV DME:".concat(index),type:SimVarValueType.NM}],["nav_radial_".concat(index),{name:"NAV RADIAL:".concat(index),type:SimVarValueType.Degree}],["nav_ident_".concat(index),{name:"NAV IDENT:".concat(index),type:SimVarValueType.String}],["nav_to_from_".concat(index),{name:"NAV TOFROM:".concat(index),type:SimVarValueType.Enum}],["nav_localizer_".concat(index),{name:"NAV HAS LOCALIZER:".concat(index),type:SimVarValueType.Bool}],["nav_localizer_crs_".concat(index),{name:"NAV LOCALIZER:".concat(index),type:SimVarValueType.Number}],["nav_loc_airport_ident_".concat(index),{name:"NAV LOC AIRPORT IDENT:".concat(index),type:SimVarValueType.String}],["nav_loc_runway_designator_".concat(index),{name:"NAV LOC RUNWAY DESIGNATOR:".concat(index),type:SimVarValueType.Number}],["nav_loc_runway_number_".concat(index),{name:"NAV LOC RUNWAY NUMBER:".concat(index),type:SimVarValueType.Number}],["nav_glideslope_".concat(index),{name:"NAV HAS GLIDE SLOPE:".concat(index),type:SimVarValueType.Bool}],["nav_gs_error_".concat(index),{name:"NAV GLIDE SLOPE ERROR:".concat(index),type:SimVarValueType.Degree}],["nav_raw_gs_".concat(index),{name:"NAV RAW GLIDE SLOPE:".concat(index),type:SimVarValueType.Degree}],["nav_lla_".concat(index),{name:"NAV VOR LATLONALT:".concat(index),type:SimVarValueType.LLA}],["nav_dme_lla_".concat(index),{name:"NAV DME LATLONALT:".concat(index),type:SimVarValueType.LLA}],["nav_gs_lla_".concat(index),{name:"NAV GS LATLONALT:".concat(index),type:SimVarValueType.LLA}],["nav_magvar_".concat(index),{name:"NAV MAGVAR:".concat(index),type:SimVarValueType.Degree}]];}/**
       * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
       * @param index The index of the ADF radio.
       * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
       */static createAdfRadioDefinitions(index){return [["adf_signal_".concat(index),{name:"ADF SIGNAL:".concat(index),type:SimVarValueType.Number}],["adf_bearing_".concat(index),{name:"ADF RADIAL:".concat(index),type:SimVarValueType.Degree}],["adf_lla_".concat(index),{name:"ADF LATLONALT:".concat(index),type:SimVarValueType.LLA}]];}}NavProcSimVarPublisher.simvars=new Map([...NavProcSimVarPublisher.createNavRadioDefinitions(1),...NavProcSimVarPublisher.createNavRadioDefinitions(2),...NavProcSimVarPublisher.createNavRadioDefinitions(3),...NavProcSimVarPublisher.createNavRadioDefinitions(4),...NavProcSimVarPublisher.createAdfRadioDefinitions(1),...NavProcSimVarPublisher.createAdfRadioDefinitions(2),['gps_dtk',{name:'GPS WP DESIRED TRACK',type:SimVarValueType.Degree}],['gps_xtk',{name:'GPS WP CROSS TRK',type:SimVarValueType.NM}],['gps_wp',{name:'GPS WP NEXT ID',type:SimVarValueType.NM}],['gps_wp_bearing',{name:'GPS WP BEARING',type:SimVarValueType.String}],['gps_wp_distance',{name:'GPS WP DISTANCE',type:SimVarValueType.NM}],['mkr_bcn_state_simvar',{name:'MARKER BEACON STATE',type:SimVarValueType.Number}],['gps_obs_active_simvar',{name:'GPS OBS ACTIVE',type:SimVarValueType.Bool}],['gps_obs_value_simvar',{name:'GPS OBS VALUE',type:SimVarValueType.Degree}]]);//
  // Navigation event configurations
  //
  var NavSourceType;(function(NavSourceType){NavSourceType[NavSourceType["Nav"]=0]="Nav";NavSourceType[NavSourceType["Gps"]=1]="Gps";NavSourceType[NavSourceType["Adf"]=2]="Adf";})(NavSourceType||(NavSourceType={}));//* ENUM for VOR To/From Flag */
  var VorToFrom;(function(VorToFrom){VorToFrom[VorToFrom["OFF"]=0]="OFF";VorToFrom[VorToFrom["TO"]=1]="TO";VorToFrom[VorToFrom["FROM"]=2]="FROM";})(VorToFrom||(VorToFrom={}));/** Marker beacon signal state. */var MarkerBeaconState;(function(MarkerBeaconState){MarkerBeaconState[MarkerBeaconState["Inactive"]=0]="Inactive";MarkerBeaconState[MarkerBeaconState["Outer"]=1]="Outer";MarkerBeaconState[MarkerBeaconState["Middle"]=2]="Middle";MarkerBeaconState[MarkerBeaconState["Inner"]=3]="Inner";})(MarkerBeaconState||(MarkerBeaconState={}));/**
   * A subscribable subject which derives its value from an event consumer.
   */class ConsumerSubject extends AbstractSubscribable{/**
       * Constructor.
       * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
       * not be updated until its consumer is set to a non-null value.
       * @param initialVal This subject's initial value.
       * @param equalityFunc The function this subject uses check for equality between values.
       * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
       * instead.
       */constructor(consumer,initialVal,equalityFunc,mutateFunc){super();this.equalityFunc=equalityFunc;this.mutateFunc=mutateFunc;this.consumerHandler=this.onEventConsumed.bind(this);this._isPaused=false;this.isDestroyed=false;this.value=initialVal;this.consumerSub=consumer===null||consumer===void 0?void 0:consumer.handle(this.consumerHandler);}// eslint-disable-next-line jsdoc/require-returns
  /**
       * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
       * update.
       */get isPaused(){return this._isPaused;}// eslint-disable-next-line jsdoc/require-jsdoc
  static create(consumer,initialVal,equalityFunc,mutateFunc){return new ConsumerSubject(consumer,initialVal,equalityFunc!==null&&equalityFunc!==void 0?equalityFunc:AbstractSubscribable.DEFAULT_EQUALITY_FUNC,mutateFunc);}/**
       * Consumes an event.
       * @param value The value of the event.
       */onEventConsumed(value){if(!this.equalityFunc(this.value,value)){if(this.mutateFunc){this.mutateFunc(this.value,value);}else {this.value=value;}this.notify();}}/**
       * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
       * not be updated until a non-null consumer is set.
       * @param consumer An event consumer.
       * @returns This subject, after its consumer has been set.
       */setConsumer(consumer){var _a;if(this.isDestroyed){return this;}(_a=this.consumerSub)===null||_a===void 0?void 0:_a.destroy();this.consumerSub=consumer===null||consumer===void 0?void 0:consumer.handle(this.consumerHandler,this._isPaused);return this;}/**
       * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
       * @returns This subject, after it has been paused.
       */pause(){var _a;if(this._isPaused){return this;}(_a=this.consumerSub)===null||_a===void 0?void 0:_a.pause();this._isPaused=true;return this;}/**
       * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
       * events.
       * @returns This subject, after it has been resumed.
       */resume(){var _a;if(!this._isPaused){return this;}this._isPaused=false;(_a=this.consumerSub)===null||_a===void 0?void 0:_a.resume(true);return this;}/** @inheritdoc */get(){return this.value;}/**
       * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
       */destroy(){var _a;(_a=this.consumerSub)===null||_a===void 0?void 0:_a.destroy();this.isDestroyed=true;}}/** The kind of data to return. */var CompositeLogicXMLValueType;(function(CompositeLogicXMLValueType){CompositeLogicXMLValueType[CompositeLogicXMLValueType["Any"]=0]="Any";CompositeLogicXMLValueType[CompositeLogicXMLValueType["Number"]=1]="Number";CompositeLogicXMLValueType[CompositeLogicXMLValueType["String"]=2]="String";})(CompositeLogicXMLValueType||(CompositeLogicXMLValueType={}));/* eslint-disable no-inner-declarations */ // eslint-disable-next-line @typescript-eslint/no-namespace
  var DataStore;(function(DataStore){/**
       * Writes a keyed value to the data store.
       * @param key A key.
       * @param value The value to set.
       */function set(key,value){SetStoredData(key,JSON.stringify(value));}DataStore.set=set;/**
       * Retrieves a keyed value from the data store.
       * @param key A key.
       * @returns the value stored under the key, or undefined if one could not be retrieved.
       */function get(key){try{const string=GetStoredData(key);return JSON.parse(string);}catch(e){return undefined;}}DataStore.get=get;/**
       * Removes a key from the data store.
       * @param key The key to remove.
       */function remove(key){DeleteStoredData(key);}DataStore.remove=remove;})(DataStore||(DataStore={}));/**
   * A utility class which provides the current game state.
   */class GameStateProvider{/**
       * Constructor.
       */constructor(){this.gameState=Subject.create(undefined);window.document.addEventListener('OnVCockpitPanelAttributesChanged',this.onAttributesChanged.bind(this));this.onAttributesChanged();}/**
       * Responds to changes in document attributes.
       */onAttributesChanged(){var _a;if((_a=window.parent)===null||_a===void 0?void 0:_a.document.body.hasAttribute('gamestate')){const attribute=window.parent.document.body.getAttribute('gamestate');if(attribute!==null){this.gameState.set(GameState[attribute]);return;}}this.gameState.set(undefined);}/**
       * Gets a subscribable which provides the current game state.
       * @returns A subscribable which provides the current game state.
       */static get(){var _a;return ((_a=GameStateProvider.INSTANCE)!==null&&_a!==void 0?_a:GameStateProvider.INSTANCE=new GameStateProvider()).gameState;}}/**
   * The available facility frequency types.
   */var FacilityFrequencyType;(function(FacilityFrequencyType){FacilityFrequencyType[FacilityFrequencyType["None"]=0]="None";FacilityFrequencyType[FacilityFrequencyType["ATIS"]=1]="ATIS";FacilityFrequencyType[FacilityFrequencyType["Multicom"]=2]="Multicom";FacilityFrequencyType[FacilityFrequencyType["Unicom"]=3]="Unicom";FacilityFrequencyType[FacilityFrequencyType["CTAF"]=4]="CTAF";FacilityFrequencyType[FacilityFrequencyType["Ground"]=5]="Ground";FacilityFrequencyType[FacilityFrequencyType["Tower"]=6]="Tower";FacilityFrequencyType[FacilityFrequencyType["Clearance"]=7]="Clearance";FacilityFrequencyType[FacilityFrequencyType["Approach"]=8]="Approach";FacilityFrequencyType[FacilityFrequencyType["Departure"]=9]="Departure";FacilityFrequencyType[FacilityFrequencyType["Center"]=10]="Center";FacilityFrequencyType[FacilityFrequencyType["FSS"]=11]="FSS";FacilityFrequencyType[FacilityFrequencyType["AWOS"]=12]="AWOS";FacilityFrequencyType[FacilityFrequencyType["ASOS"]=13]="ASOS";/** Clearance Pre-Taxi*/FacilityFrequencyType[FacilityFrequencyType["CPT"]=14]="CPT";/** Remote Clearance Delivery */FacilityFrequencyType[FacilityFrequencyType["GCO"]=15]="GCO";})(FacilityFrequencyType||(FacilityFrequencyType={}));/** Additional Approach Types (additive to those defined in simplane). */var AdditionalApproachType;(function(AdditionalApproachType){AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"]=99]="APPROACH_TYPE_VISUAL";})(AdditionalApproachType||(AdditionalApproachType={}));/**
   * Flags indicating the approach fix type.
   */var FixTypeFlags;(function(FixTypeFlags){FixTypeFlags[FixTypeFlags["None"]=0]="None";FixTypeFlags[FixTypeFlags["IAF"]=1]="IAF";FixTypeFlags[FixTypeFlags["IF"]=2]="IF";FixTypeFlags[FixTypeFlags["MAP"]=4]="MAP";FixTypeFlags[FixTypeFlags["FAF"]=8]="FAF";FixTypeFlags[FixTypeFlags["MAHP"]=16]="MAHP";})(FixTypeFlags||(FixTypeFlags={}));/**
   * Flags indicating the rnav approach type.
   */var RnavTypeFlags;(function(RnavTypeFlags){RnavTypeFlags[RnavTypeFlags["None"]=0]="None";RnavTypeFlags[RnavTypeFlags["LNAV"]=1]="LNAV";RnavTypeFlags[RnavTypeFlags["LNAVVNAV"]=2]="LNAVVNAV";RnavTypeFlags[RnavTypeFlags["LP"]=4]="LP";RnavTypeFlags[RnavTypeFlags["LPV"]=8]="LPV";})(RnavTypeFlags||(RnavTypeFlags={}));/**
   * The class of airport facility.
   */var AirportClass;(function(AirportClass){/** No other airport class could be identified. */AirportClass[AirportClass["None"]=0]="None";/** The airport has at least one hard surface runway. */AirportClass[AirportClass["HardSurface"]=1]="HardSurface";/** The airport has no hard surface runways. */AirportClass[AirportClass["SoftSurface"]=2]="SoftSurface";/** The airport has only water surface runways. */AirportClass[AirportClass["AllWater"]=3]="AllWater";/** The airport has no runways, but does contain helipads. */AirportClass[AirportClass["HeliportOnly"]=4]="HeliportOnly";/** The airport is a non-public use airport. */AirportClass[AirportClass["Private"]=5]="Private";})(AirportClass||(AirportClass={}));/**
   * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
   */var AirportClassMask;(function(AirportClassMask){/** No other airport class could be identified. */AirportClassMask[AirportClassMask["None"]=0]="None";/** The airport has at least one hard surface runway. */AirportClassMask[AirportClassMask["HardSurface"]=2]="HardSurface";/** The airport has no hard surface runways. */AirportClassMask[AirportClassMask["SoftSurface"]=4]="SoftSurface";/** The airport has only water surface runways. */AirportClassMask[AirportClassMask["AllWater"]=8]="AllWater";/** The airport has no runways, but does contain helipads. */AirportClassMask[AirportClassMask["HeliportOnly"]=16]="HeliportOnly";/** The airport is a non-public use airport. */AirportClassMask[AirportClassMask["Private"]=32]="Private";})(AirportClassMask||(AirportClassMask={}));/**
   * An enumeration of possible intersection types.
   */var IntersectionType;(function(IntersectionType){IntersectionType[IntersectionType["None"]=0]="None";IntersectionType[IntersectionType["Named"]=1]="Named";IntersectionType[IntersectionType["Unnamed"]=2]="Unnamed";IntersectionType[IntersectionType["Vor"]=3]="Vor";IntersectionType[IntersectionType["NDB"]=4]="NDB";IntersectionType[IntersectionType["Offroute"]=5]="Offroute";IntersectionType[IntersectionType["IAF"]=6]="IAF";IntersectionType[IntersectionType["FAF"]=7]="FAF";IntersectionType[IntersectionType["RNAV"]=8]="RNAV";IntersectionType[IntersectionType["VFR"]=9]="VFR";})(IntersectionType||(IntersectionType={}));var UserFacilityType;(function(UserFacilityType){UserFacilityType[UserFacilityType["RADIAL_RADIAL"]=0]="RADIAL_RADIAL";UserFacilityType[UserFacilityType["RADIAL_DISTANCE"]=1]="RADIAL_DISTANCE";UserFacilityType[UserFacilityType["LAT_LONG"]=2]="LAT_LONG";})(UserFacilityType||(UserFacilityType={}));/**
   * ARINC 424 Leg Types
   */var LegType;(function(LegType){/** An unknown leg type. */LegType[LegType["Unknown"]=0]="Unknown";/** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/LegType[LegType["AF"]=1]="AF";/** A course-to-altitude leg. */LegType[LegType["CA"]=2]="CA";/**
       * A course-to-DME-distance leg. This leg is flown on a wind corrected course
       * to a specific DME distance from another fix.
       */LegType[LegType["CD"]=3]="CD";/** A course-to-fix leg.*/LegType[LegType["CF"]=4]="CF";/** A course-to-intercept leg. */LegType[LegType["CI"]=5]="CI";/** A course-to-radial intercept leg. */LegType[LegType["CR"]=6]="CR";/** A direct-to-fix leg, from an unspecified starting position. */LegType[LegType["DF"]=7]="DF";/**
       * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
       * specified altitude.
       */LegType[LegType["FA"]=8]="FA";/**
       * A fix-to-distance leg. This leg is flown on a track from a fix to a
       * specific distance from the fix.
       */LegType[LegType["FC"]=9]="FC";/**
       * A fix to DME distance leg. This leg is flown on a track from a fix to
       * a specific DME distance from another fix.
       */LegType[LegType["FD"]=10]="FD";/** A course-to-manual-termination leg. */LegType[LegType["FM"]=11]="FM";/** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */LegType[LegType["HA"]=12]="HA";/**
       * A hold-to-fix leg. This indicates one time around the hold circuit and
       * then an exit.
       */LegType[LegType["HF"]=13]="HF";/** A hold-to-manual-termination leg. */LegType[LegType["HM"]=14]="HM";/** Initial procedure fix. */LegType[LegType["IF"]=15]="IF";/** A procedure turn leg. */LegType[LegType["PI"]=16]="PI";/** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */LegType[LegType["RF"]=17]="RF";/** A track-to-fix leg, from the previous fix to the terminator. */LegType[LegType["TF"]=18]="TF";/** A heading-to-altitude leg. */LegType[LegType["VA"]=19]="VA";/** A heading-to-DME-distance leg. */LegType[LegType["VD"]=20]="VD";/** A heading-to-intercept leg. */LegType[LegType["VI"]=21]="VI";/** A heading-to-manual-termination leg. */LegType[LegType["VM"]=22]="VM";/** A heading-to-radial intercept leg. */LegType[LegType["VR"]=23]="VR";/** A leg representing a lateral and vertical discontinuity in the flight plan. */LegType[LegType["Discontinuity"]=99]="Discontinuity";/** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */LegType[LegType["ThruDiscontinuity"]=100]="ThruDiscontinuity";})(LegType||(LegType={}));/**
   * Types of altitude restrictions on procedure legs.
   */var AltitudeRestrictionType;(function(AltitudeRestrictionType){AltitudeRestrictionType[AltitudeRestrictionType["Unused"]=0]="Unused";AltitudeRestrictionType[AltitudeRestrictionType["At"]=1]="At";AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"]=2]="AtOrAbove";AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"]=3]="AtOrBelow";AltitudeRestrictionType[AltitudeRestrictionType["Between"]=4]="Between";})(AltitudeRestrictionType||(AltitudeRestrictionType={}));var LegTurnDirection;(function(LegTurnDirection){LegTurnDirection[LegTurnDirection["None"]=0]="None";LegTurnDirection[LegTurnDirection["Left"]=1]="Left";LegTurnDirection[LegTurnDirection["Right"]=2]="Right";LegTurnDirection[LegTurnDirection["Either"]=3]="Either";})(LegTurnDirection||(LegTurnDirection={}));var AirwayType;(function(AirwayType){AirwayType[AirwayType["None"]=0]="None";AirwayType[AirwayType["Victor"]=1]="Victor";AirwayType[AirwayType["Jet"]=2]="Jet";AirwayType[AirwayType["Both"]=3]="Both";})(AirwayType||(AirwayType={}));var NdbType;(function(NdbType){NdbType[NdbType["CompassPoint"]=0]="CompassPoint";NdbType[NdbType["MH"]=1]="MH";NdbType[NdbType["H"]=2]="H";NdbType[NdbType["HH"]=3]="HH";})(NdbType||(NdbType={}));var VorType;(function(VorType){VorType[VorType["Unknown"]=0]="Unknown";VorType[VorType["VOR"]=1]="VOR";VorType[VorType["VORDME"]=2]="VORDME";VorType[VorType["DME"]=3]="DME";VorType[VorType["TACAN"]=4]="TACAN";VorType[VorType["VORTAC"]=5]="VORTAC";VorType[VorType["ILS"]=6]="ILS";VorType[VorType["VOT"]=7]="VOT";})(VorType||(VorType={}));var RunwaySurfaceType;(function(RunwaySurfaceType){RunwaySurfaceType[RunwaySurfaceType["Concrete"]=0]="Concrete";RunwaySurfaceType[RunwaySurfaceType["Grass"]=1]="Grass";RunwaySurfaceType[RunwaySurfaceType["WaterFSX"]=2]="WaterFSX";RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"]=3]="GrassBumpy";RunwaySurfaceType[RunwaySurfaceType["Asphalt"]=4]="Asphalt";RunwaySurfaceType[RunwaySurfaceType["ShortGrass"]=5]="ShortGrass";RunwaySurfaceType[RunwaySurfaceType["LongGrass"]=6]="LongGrass";RunwaySurfaceType[RunwaySurfaceType["HardTurf"]=7]="HardTurf";RunwaySurfaceType[RunwaySurfaceType["Snow"]=8]="Snow";RunwaySurfaceType[RunwaySurfaceType["Ice"]=9]="Ice";RunwaySurfaceType[RunwaySurfaceType["Urban"]=10]="Urban";RunwaySurfaceType[RunwaySurfaceType["Forest"]=11]="Forest";RunwaySurfaceType[RunwaySurfaceType["Dirt"]=12]="Dirt";RunwaySurfaceType[RunwaySurfaceType["Coral"]=13]="Coral";RunwaySurfaceType[RunwaySurfaceType["Gravel"]=14]="Gravel";RunwaySurfaceType[RunwaySurfaceType["OilTreated"]=15]="OilTreated";RunwaySurfaceType[RunwaySurfaceType["SteelMats"]=16]="SteelMats";RunwaySurfaceType[RunwaySurfaceType["Bituminous"]=17]="Bituminous";RunwaySurfaceType[RunwaySurfaceType["Brick"]=18]="Brick";RunwaySurfaceType[RunwaySurfaceType["Macadam"]=19]="Macadam";RunwaySurfaceType[RunwaySurfaceType["Planks"]=20]="Planks";RunwaySurfaceType[RunwaySurfaceType["Sand"]=21]="Sand";RunwaySurfaceType[RunwaySurfaceType["Shale"]=22]="Shale";RunwaySurfaceType[RunwaySurfaceType["Tarmac"]=23]="Tarmac";RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"]=24]="WrightFlyerTrack";//SURFACE_TYPE_LAST_FSX
  RunwaySurfaceType[RunwaySurfaceType["Ocean"]=26]="Ocean";RunwaySurfaceType[RunwaySurfaceType["Water"]=27]="Water";RunwaySurfaceType[RunwaySurfaceType["Pond"]=28]="Pond";RunwaySurfaceType[RunwaySurfaceType["Lake"]=29]="Lake";RunwaySurfaceType[RunwaySurfaceType["River"]=30]="River";RunwaySurfaceType[RunwaySurfaceType["WasteWater"]=31]="WasteWater";RunwaySurfaceType[RunwaySurfaceType["Paint"]=32]="Paint";// UNUSED
  // SURFACE_TYPE_ERASE_GRASS
  })(RunwaySurfaceType||(RunwaySurfaceType={}));var RunwayLightingType;(function(RunwayLightingType){RunwayLightingType[RunwayLightingType["Unknown"]=0]="Unknown";RunwayLightingType[RunwayLightingType["None"]=1]="None";RunwayLightingType[RunwayLightingType["PartTime"]=2]="PartTime";RunwayLightingType[RunwayLightingType["FullTime"]=3]="FullTime";RunwayLightingType[RunwayLightingType["Frequency"]=4]="Frequency";})(RunwayLightingType||(RunwayLightingType={}));var AirportPrivateType;(function(AirportPrivateType){AirportPrivateType[AirportPrivateType["Uknown"]=0]="Uknown";AirportPrivateType[AirportPrivateType["Public"]=1]="Public";AirportPrivateType[AirportPrivateType["Military"]=2]="Military";AirportPrivateType[AirportPrivateType["Private"]=3]="Private";})(AirportPrivateType||(AirportPrivateType={}));var GpsBoolean;(function(GpsBoolean){GpsBoolean[GpsBoolean["Unknown"]=0]="Unknown";GpsBoolean[GpsBoolean["No"]=1]="No";GpsBoolean[GpsBoolean["Yes"]=2]="Yes";})(GpsBoolean||(GpsBoolean={}));var VorClass;(function(VorClass){VorClass[VorClass["Unknown"]=0]="Unknown";VorClass[VorClass["Terminal"]=1]="Terminal";VorClass[VorClass["LowAlt"]=2]="LowAlt";VorClass[VorClass["HighAlt"]=3]="HighAlt";VorClass[VorClass["ILS"]=4]="ILS";VorClass[VorClass["VOT"]=5]="VOT";})(VorClass||(VorClass={}));var FacilityType;(function(FacilityType){FacilityType["Airport"]="LOAD_AIRPORT";FacilityType["Intersection"]="LOAD_INTERSECTION";FacilityType["VOR"]="LOAD_VOR";FacilityType["NDB"]="LOAD_NDB";FacilityType["USR"]="USR";FacilityType["RWY"]="RWY";FacilityType["VIS"]="VIS";})(FacilityType||(FacilityType={}));var FacilitySearchType;(function(FacilitySearchType){FacilitySearchType[FacilitySearchType["All"]=0]="All";FacilitySearchType[FacilitySearchType["Airport"]=1]="Airport";FacilitySearchType[FacilitySearchType["Intersection"]=2]="Intersection";FacilitySearchType[FacilitySearchType["Vor"]=3]="Vor";FacilitySearchType[FacilitySearchType["Ndb"]=4]="Ndb";FacilitySearchType[FacilitySearchType["Boundary"]=5]="Boundary";FacilitySearchType[FacilitySearchType["User"]=6]="User";FacilitySearchType[FacilitySearchType["Visual"]=7]="Visual";FacilitySearchType[FacilitySearchType["AllExceptVisual"]=8]="AllExceptVisual";})(FacilitySearchType||(FacilitySearchType={}));/**
   * A type of airspace boundary.
   */var BoundaryType;(function(BoundaryType){BoundaryType[BoundaryType["None"]=0]="None";BoundaryType[BoundaryType["Center"]=1]="Center";BoundaryType[BoundaryType["ClassA"]=2]="ClassA";BoundaryType[BoundaryType["ClassB"]=3]="ClassB";BoundaryType[BoundaryType["ClassC"]=4]="ClassC";BoundaryType[BoundaryType["ClassD"]=5]="ClassD";BoundaryType[BoundaryType["ClassE"]=6]="ClassE";BoundaryType[BoundaryType["ClassF"]=7]="ClassF";BoundaryType[BoundaryType["ClassG"]=8]="ClassG";BoundaryType[BoundaryType["Tower"]=9]="Tower";BoundaryType[BoundaryType["Clearance"]=10]="Clearance";BoundaryType[BoundaryType["Ground"]=11]="Ground";BoundaryType[BoundaryType["Departure"]=12]="Departure";BoundaryType[BoundaryType["Approach"]=13]="Approach";BoundaryType[BoundaryType["MOA"]=14]="MOA";BoundaryType[BoundaryType["Restricted"]=15]="Restricted";BoundaryType[BoundaryType["Prohibited"]=16]="Prohibited";BoundaryType[BoundaryType["Warning"]=17]="Warning";BoundaryType[BoundaryType["Alert"]=18]="Alert";BoundaryType[BoundaryType["Danger"]=19]="Danger";BoundaryType[BoundaryType["NationalPark"]=20]="NationalPark";BoundaryType[BoundaryType["ModeC"]=21]="ModeC";BoundaryType[BoundaryType["Radar"]=22]="Radar";BoundaryType[BoundaryType["Training"]=23]="Training";})(BoundaryType||(BoundaryType={}));/**
   * A type of airspace boundary altitude maxima.
   */var BoundaryAltitudeType;(function(BoundaryAltitudeType){BoundaryAltitudeType[BoundaryAltitudeType["Unknown"]=0]="Unknown";BoundaryAltitudeType[BoundaryAltitudeType["MSL"]=1]="MSL";BoundaryAltitudeType[BoundaryAltitudeType["AGL"]=2]="AGL";BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"]=3]="Unlimited";})(BoundaryAltitudeType||(BoundaryAltitudeType={}));/**
   * A type of boundary geometry vector.
   */var BoundaryVectorType;(function(BoundaryVectorType){BoundaryVectorType[BoundaryVectorType["None"]=0]="None";BoundaryVectorType[BoundaryVectorType["Start"]=1]="Start";BoundaryVectorType[BoundaryVectorType["Line"]=2]="Line";BoundaryVectorType[BoundaryVectorType["Origin"]=3]="Origin";BoundaryVectorType[BoundaryVectorType["ArcCW"]=4]="ArcCW";BoundaryVectorType[BoundaryVectorType["ArcCCW"]=5]="ArcCCW";BoundaryVectorType[BoundaryVectorType["Circle"]=6]="Circle";})(BoundaryVectorType||(BoundaryVectorType={}));/**
   * Wind speed units used by METAR.
   */var MetarWindSpeedUnits;(function(MetarWindSpeedUnits){MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"]=0]="Knot";MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"]=1]="MeterPerSecond";MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"]=2]="KilometerPerHour";})(MetarWindSpeedUnits||(MetarWindSpeedUnits={}));/** Visibility distance units used by METAR. */var MetarVisibilityUnits;(function(MetarVisibilityUnits){MetarVisibilityUnits[MetarVisibilityUnits["Meter"]=0]="Meter";MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"]=1]="StatuteMile";})(MetarVisibilityUnits||(MetarVisibilityUnits={}));/**
   * METAR cloud layer coverage/sky condition.
   */var MetarCloudLayerCoverage;(function(MetarCloudLayerCoverage){MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"]=0]="SkyClear";MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"]=1]="Clear";MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"]=2]="NoSignificant";MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"]=3]="Few";MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"]=4]="Scattered";MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"]=5]="Broken";MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"]=6]="Overcast";})(MetarCloudLayerCoverage||(MetarCloudLayerCoverage={}));/**
   * METAR significant cloud types.
   */var MetarCloudLayerType;(function(MetarCloudLayerType){MetarCloudLayerType[MetarCloudLayerType["Unspecified"]=-1]="Unspecified";MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"]=0]="ToweringCumulus";MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"]=1]="Cumulonimbus";MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"]=2]="AltocumulusCastellanus";})(MetarCloudLayerType||(MetarCloudLayerType={}));/** METAR phenomenon types. */var MetarPhenomenonType;(function(MetarPhenomenonType){MetarPhenomenonType[MetarPhenomenonType["None"]=0]="None";MetarPhenomenonType[MetarPhenomenonType["Mist"]=1]="Mist";MetarPhenomenonType[MetarPhenomenonType["Duststorm"]=2]="Duststorm";MetarPhenomenonType[MetarPhenomenonType["Dust"]=3]="Dust";MetarPhenomenonType[MetarPhenomenonType["Drizzle"]=4]="Drizzle";MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"]=5]="FunnelCloud";MetarPhenomenonType[MetarPhenomenonType["Fog"]=6]="Fog";MetarPhenomenonType[MetarPhenomenonType["Smoke"]=7]="Smoke";MetarPhenomenonType[MetarPhenomenonType["Hail"]=8]="Hail";MetarPhenomenonType[MetarPhenomenonType["SmallHail"]=9]="SmallHail";MetarPhenomenonType[MetarPhenomenonType["Haze"]=10]="Haze";MetarPhenomenonType[MetarPhenomenonType["IceCrystals"]=11]="IceCrystals";MetarPhenomenonType[MetarPhenomenonType["IcePellets"]=12]="IcePellets";MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"]=13]="DustSandWhorls";MetarPhenomenonType[MetarPhenomenonType["Spray"]=14]="Spray";MetarPhenomenonType[MetarPhenomenonType["Rain"]=15]="Rain";MetarPhenomenonType[MetarPhenomenonType["Sand"]=16]="Sand";MetarPhenomenonType[MetarPhenomenonType["SnowGrains"]=17]="SnowGrains";MetarPhenomenonType[MetarPhenomenonType["Shower"]=18]="Shower";MetarPhenomenonType[MetarPhenomenonType["Snow"]=19]="Snow";MetarPhenomenonType[MetarPhenomenonType["Squalls"]=20]="Squalls";MetarPhenomenonType[MetarPhenomenonType["Sandstorm"]=21]="Sandstorm";MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"]=22]="UnknownPrecip";MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"]=23]="VolcanicAsh";})(MetarPhenomenonType||(MetarPhenomenonType={}));/** METAR phenomenon intensities. */var MetarPhenomenonIntensity;(function(MetarPhenomenonIntensity){MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"]=-1]="Light";MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"]=0]="Normal";MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"]=1]="Heavy";})(MetarPhenomenonIntensity||(MetarPhenomenonIntensity={}));/**
   * Methods for working with FS ICAO strings.
   */class ICAO{/**
       * Gets the facility type from an ICAO.
       * @param icao The icao to get the facility type for.
       * @returns The ICAO facility type.
       * @throws An error if the facility type cannot be determined.
       */static getFacilityType(icao){switch(icao[0]){case'A':return FacilityType.Airport;case'W':return FacilityType.Intersection;case'V':return FacilityType.VOR;case'N':return FacilityType.NDB;case'U':return FacilityType.USR;case'R':return FacilityType.RWY;case'S':return FacilityType.VIS;default:throw new Error("ICAO ".concat(icao," has unknown type: ").concat(icao[0]));}}/**
       * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
       * @param icao The icao to get the airport ident for.
       * @returns The airport ident.
       */static getAssociatedAirportIdent(icao){return icao.substr(3,4).trim();}/**
       * Checks whether an ICAO string defines a facility (optionally of a specific type).
       * @param icao An ICAO string.
       * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
       * the ICAO string defines any valid facility type.
       * @returns Whether the given ICAO string defines a facility of the specified type.
       */static isFacility(icao,type){switch(icao[0]){case'A':return type===undefined||type===FacilityType.Airport;case'W':return type===undefined||type===FacilityType.Intersection;case'V':return type===undefined||type===FacilityType.VOR;case'N':return type===undefined||type===FacilityType.NDB;case'U':return type===undefined||type===FacilityType.USR;case'R':return type===undefined||type===FacilityType.RWY;case'S':return type===undefined||type===FacilityType.VIS;default:return false;}}/**
       * Gets the ident for a given ICAO string.
       * @param icao The FS ICAO to get the ident for.
       * @returns The ICAO ident.
       */static getIdent(icao){return icao.substr(7).trim();}/**
       * Gets the region code for a given ICAO string.
       * @param icao The FS ICAO to get the ident for.
       * @returns The two letter region code.
       */static getRegionCode(icao){return icao.substr(1,2).trim();}}/**
   * An empty ICAO.
   */ICAO.emptyIcao='            ';/**
   * Utility functions for working with facilities.
   */class FacilityUtils{/**
       * Checks whether a facility is of a given type.
       * @param facility The facility to check.
       * @param type The facility type to check against.
       * @returns Whether the facility is of the specified type.
       */static isFacilityType(facility,type){// Need to check for the intersection version of VOR/NDB facilities - these facilities have identical ICAOs
  // to their VOR/NDB counterparts, so we need to manually check the __Type property on the facility object.
  if(facility['__Type']==='JS_FacilityIntersection'){return type===FacilityType.Intersection;}return ICAO.isFacility(facility.icao,type);}/**
       * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
       * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
       * is returned.
       * @param facility A facility.
       * @returns The magnetic variation at the specified facility, in degrees.
       */static getMagVar(facility){if(FacilityUtils.isFacilityType(facility,FacilityType.VOR)){return -facility.magneticVariation;// VOR facility magvar is positive west instead of the standard positive east
  }else {return MagVar.get(facility.lat,facility.lon);}}/**
       * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
       * @param reference The reference facility.
       * @param radial The magnetic radial, in degrees.
       * @param distance The distance, in nautical miles.
       * @param out The GeoPoint object to which to write the result.
       * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
       * facility.
       */static getLatLonFromRadialDistance(reference,radial,distance,out){return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial,FacilityUtils.getMagVar(reference)),UnitType.NMILE.convertTo(distance,UnitType.GA_RADIAN),out);}/**
       * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
       * @param reference1 The first reference facility.
       * @param radial1 The first magnetic radial, in degrees.
       * @param reference2 The second reference facility.
       * @param radial2 The second magnetic radial, in degrees.
       * @param out The GeoPoint object to which to write the result.
       * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
       * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
       */static getLatLonFromRadialRadial(reference1,radial1,reference2,radial2,out){const magVar1=FacilityUtils.getMagVar(reference1);const magVar2=FacilityUtils.getMagVar(reference2);const radialCircle1=FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1,MagVar.magneticToTrue(radial1,magVar1));const radialCircle2=FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2,MagVar.magneticToTrue(radial2,magVar2));const radial1IncludesRef2=radialCircle1.includes(reference2);const radial2IncludesRef1=radialCircle2.includes(reference1);if(radial1IncludesRef2&&radial2IncludesRef1){// Radials are parallel or antiparallel, and therefore do not have a unique intersection point.
  return out.set(NaN,NaN);}else if(radial1IncludesRef2){// Reference 2 lies along the great circle of radial 1. The intersection point therefore is either reference 2
  // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
  return radialCircle1.angleAlong(reference1,reference2,Math.PI)<Math.PI?out.set(reference2):out.set(reference2).antipode();}else if(radial2IncludesRef1){// Reference 1 lies along the great circle of radial 2. The intersection point therefore is either reference 1
  // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
  return radialCircle2.angleAlong(reference2,reference1,Math.PI)<Math.PI?out.set(reference1):out.set(reference1).antipode();}// Radials, unlike great circles, do not circumscribe the globe. Therefore, we choose the order of the intersection
  // operation carefully to ensure that the first solution (if it exists) is the "correct" intersection.
  const numIntersections=radialCircle1.encircles(reference2)?radialCircle2.intersectionGeoPoint(radialCircle1,FacilityUtils.intersectionCache):radialCircle1.intersectionGeoPoint(radialCircle2,FacilityUtils.intersectionCache);if(numIntersections===0){return out.set(NaN,NaN);}return out.set(FacilityUtils.intersectionCache[0]);}}FacilityUtils.geoPointCache=[new GeoPoint(0,0)];FacilityUtils.geoCircleCache=[new GeoCircle(Vec3Math.create(),0),new GeoCircle(Vec3Math.create(),0)];FacilityUtils.intersectionCache=[new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoPoint(0,0)];var RunwaySurfaceCategory;(function(RunwaySurfaceCategory){RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"]=1]="Unknown";RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"]=2]="Hard";RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"]=4]="Soft";RunwaySurfaceCategory[RunwaySurfaceCategory["Water"]=8]="Water";})(RunwaySurfaceCategory||(RunwaySurfaceCategory={}));/**
   * Methods for working with Runways and Runway Designations.
   */class RunwayUtils{/**
       * Gets the letter for a runway designator.
       * @param designator A runway designator.
       * @param lowerCase Whether the letter should be lower case. False by default.
       * @returns The letter for the specified runway designator.
       */static getDesignatorLetter(designator){let lowerCase=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const letter=RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];return lowerCase?letter.toLowerCase():letter;}/**
       * Creates an empty one-way runway.
       * @returns an empty one-way runway.
       */static createEmptyOneWayRunway(){return {parentRunwayIndex:-1,designation:'',direction:36,runwayDesignator:RunwayDesignator.RUNWAY_DESIGNATOR_NONE,course:0,elevation:0,elevationEnd:0,gradient:0,latitude:0,longitude:0,length:0,width:0,startThresholdLength:0,endThresholdLength:0,surface:RunwaySurfaceType.Concrete,lighting:RunwayLightingType.Unknown};}/**
       * Utility method to return all of the one-way runways from a single airport facility
       * @param airport is the Airport Facility to evaluate
       * @returns all of the one-way runways in the airport facility, sorted.
       */static getOneWayRunwaysFromAirport(airport){const runways=[];airport.runways.map((r,i)=>RunwayUtils.getOneWayRunways(r,i)).forEach(d=>{runways.push(d[0]);runways.push(d[1]);});runways.sort(RunwayUtils.sortRunways);return runways;}/**
       * Utility method to return two one-way runways from a single runway facility
       * @param runway is the AirportRunway object to evaluate
       * @param index is the index of the AirportRunway in the Facility
       * @returns splitRunways array of OneWayRunway objects
       */static getOneWayRunways(runway,index){const splitRunways=[];const designations=runway.designation.split('-');for(let i=0;i<designations.length;i++){const runwayNumber=parseInt(designations[i]);let designator=RunwayDesignator.RUNWAY_DESIGNATOR_NONE;let course=0;let thresholdDistanceFromCenter=0;let thresholdElevation=0;let endThresholdElevation=0;let ilsFrequency;let startThresholdLength=0,endThresholdLength=0;if(i===0){designator=runway.designatorCharPrimary;course=runway.direction;thresholdDistanceFromCenter=runway.length/2-runway.primaryThresholdLength;thresholdElevation=runway.primaryElevation;endThresholdElevation=runway.secondaryElevation;ilsFrequency=runway.primaryILSFrequency.freqMHz===0?undefined:runway.primaryILSFrequency;startThresholdLength=runway.primaryThresholdLength;endThresholdLength=runway.secondaryThresholdLength;}else if(i===1){designator=runway.designatorCharSecondary;course=NavMath.normalizeHeading(runway.direction+180);thresholdDistanceFromCenter=runway.length/2-runway.secondaryThresholdLength;thresholdElevation=runway.secondaryElevation;endThresholdElevation=runway.primaryElevation;ilsFrequency=runway.secondaryILSFrequency.freqMHz===0?undefined:runway.secondaryILSFrequency;startThresholdLength=runway.secondaryThresholdLength;endThresholdLength=runway.primaryThresholdLength;}const designation=RunwayUtils.getRunwayNameString(runwayNumber,designator);const coordinates=RunwayUtils.tempGeoPoint.set(runway.latitude,runway.longitude).offset(course-180,UnitType.METER.convertTo(thresholdDistanceFromCenter,UnitType.GA_RADIAN));splitRunways.push({parentRunwayIndex:index,designation,direction:runwayNumber,runwayDesignator:designator,course,elevation:thresholdElevation,elevationEnd:endThresholdElevation,gradient:(endThresholdElevation-thresholdElevation)/(runway.length-startThresholdLength-endThresholdLength)*100,latitude:coordinates.lat,longitude:coordinates.lon,ilsFrequency,length:runway.length,width:runway.width,startThresholdLength,endThresholdLength,surface:runway.surface,lighting:runway.lighting});}return splitRunways;}/**
       * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
       * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
       * then the name will be the designation of the primary runway only.
       * @param runway A paired runway.
       * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
       * @returns The name for the specified paired runway.
       */static getRunwayPairNameString(runway){let padded=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const pad=padded?2:0;const dashIndex=runway.designation.search('-');const primary="".concat((dashIndex<0?runway.designation:runway.designation.substring(0,dashIndex)).padStart(pad)).concat(RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary));const secondary=dashIndex<0?'':"-".concat(runway.designation.substring(dashIndex+1).padStart(pad)).concat(RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary));return primary+secondary;}/**
       * Utility method to return the runway name from the number and designator (L/R/C/W)
       * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
       * @param designator is the RunwayDesignator enum for the runway
       * @param padded Whether single-char runways should be 0-padded.
       * @param prefix A prefix to put before the runway name.
       * @returns the runway name string
       */static getRunwayNameString(runwayNumber,designator){let padded=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;let prefix=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'';let numberText="".concat(runwayNumber);if(padded){numberText=numberText.padStart(2,'0');}return prefix+numberText+RunwayUtils.getDesignatorLetter(designator);}/**
       * Gets the primary runway number for a paired runway.
       * @param runway A paired runway.
       * @returns The primary runway number for the specified runway.
       */static getRunwayNumberPrimary(runway){const dashIndex=runway.designation.search('-');if(dashIndex<0){return parseInt(runway.designation);}else {return parseInt(runway.designation.substring(0,dashIndex));}}/**
       * Gets the secondary runway number for a paired runway.
       * @param runway A paired runway.
       * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
       * runway.
       */static getRunwayNumberSecondary(runway){const dashIndex=runway.designation.search('-');if(dashIndex<0){return undefined;}else {return parseInt(runway.designation.substring(dashIndex+1));}}/**
       * Gets a one-way runway from an airport that matches a runway designation by number and designator.
       * @param airport The airport facility in which to search for the match.
       * @param runwayNumber A runway number to match.
       * @param runwayDesignator A runway designator to match.
       * @returns The one-way runway which matches the designation, or undefined if no match could be found.
       */static matchOneWayRunway(airport,runwayNumber,runwayDesignator){const length=airport.runways.length;for(let r=0;r<length;r++){const runway=airport.runways[r];const designation=runway.designation;const primaryRunwayNumber=parseInt(designation.split('-')[0]);const secondaryRunwayNumber=parseInt(designation.split('-')[1]);if(primaryRunwayNumber===runwayNumber&&runway.designatorCharPrimary===runwayDesignator){const oneWayRunways=RunwayUtils.getOneWayRunways(runway,r);return oneWayRunways[0];}else if(secondaryRunwayNumber===runwayNumber&&runway.designatorCharSecondary===runwayDesignator){const oneWayRunways=RunwayUtils.getOneWayRunways(runway,r);return oneWayRunways[1];}}return undefined;}/**
       * Gets a one-way runway from an airport that matches a runway designation string.
       * @param airport The airport facility in which to search for the match.
       * @param designation A runway designation.
       * @returns The one-way runway which matches the designation, or undefined if no match could be found.
       */static matchOneWayRunwayFromDesignation(airport,designation){const length=airport.runways.length;for(let i=0;i<length;i++){const match=RunwayUtils.getOneWayRunways(airport.runways[i],i).find(r=>{return r.designation===designation;});if(match){return match;}}return undefined;}/**
       * Gets a one-way runway from an airport that matches a runway ident.
       * @param airport The airport facility in which to search for the match.
       * @param ident A runway ident.
       * @returns The one-way runway which matches the ident, or undefined if no match could be found.
       */static matchOneWayRunwayFromIdent(airport,ident){return RunwayUtils.matchOneWayRunwayFromDesignation(airport,ident.substr(2).trim());}/**
       * Utility method to return the procedures for a given runway.
       * @param procedures The procedures for the airport.
       * @param runway The given runway to find procedures for.
       * @returns A list of approach procedures for the given runway.
       */static getProceduresForRunway(procedures,runway){const oneways=new Array();// TODO Make the designation splitting logic a common routine too.
  const designations=runway.designation.split('-');for(let i=0;i<designations.length;i++){const runwayNumber=parseInt(designations[i]);let runwayName;if(i===0){runwayName=RunwayUtils.getRunwayNameString(runwayNumber,runway.designatorCharPrimary,false,'');}else {runwayName=RunwayUtils.getRunwayNameString(runwayNumber,runway.designatorCharSecondary,false,'');}oneways.push(runwayName);}const found=new Array();for(const procedure of procedures){if(oneways.includes(procedure.runway.trim())){found.push(procedure);}else if(procedure.runwayNumber===0){found.push(procedure);}}return found;}// eslint-disable-next-line jsdoc/require-jsdoc
  static getLocFrequency(airport,arg1,arg2){let runway;if(typeof arg1==='string'){const matchedRunway=RunwayUtils.matchOneWayRunwayFromDesignation(airport,arg1);if(!matchedRunway){return undefined;}runway=matchedRunway;}else if(typeof arg1==='number'){const matchedRunway=RunwayUtils.matchOneWayRunway(airport,arg1,arg2);if(!matchedRunway){return undefined;}runway=matchedRunway;}else {runway=arg1;}const runwayDesignation=runway.designation;if(runway.ilsFrequency){return runway.ilsFrequency;}for(let i=0;i<airport.frequencies.length;i++){// Note: drop the leading zero in the runway designation for the search because some third-party sceneries
  // format the frequency names without the leading zero.
  const match=airport.frequencies[i].name.search(runwayDesignation.replace(/^0/,''));if(match>-1){return airport.frequencies[i];}}return undefined;}/**
       * Gets the back course frequency for a runway.
       * @param airport The airport to which the query runway belongs.
       * @param runwayNumber The number of the query runway.
       * @param runwayDesignator The designator of the query runway.
       * @returns The bc frequency for the query runway, or undefined if one could not be found.
       */static getBcFrequency(airport,runwayNumber,runwayDesignator){const matchedRunway=RunwayUtils.getOppositeOneWayRunway(airport,runwayNumber,runwayDesignator);if(!matchedRunway){return undefined;}return RunwayUtils.getLocFrequency(airport,matchedRunway);}/**
       * Get the opposite one way runway from a runway number and designator.
       * @param airport The airport to which the query runway belongs.
       * @param runwayNumber The number of the query runway.
       * @param runwayDesignator The designator of the query runway.
       * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
       */static getOppositeOneWayRunway(airport,runwayNumber,runwayDesignator){const oppositeRunwayNumber=Math.round(NavMath.normalizeHeading(10*(runwayNumber+18))/10);let oppositeRunwayDesignator=RunwayDesignator.RUNWAY_DESIGNATOR_NONE;switch(runwayDesignator){case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:oppositeRunwayDesignator=RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;break;case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:oppositeRunwayDesignator=RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;break;default:oppositeRunwayDesignator=runwayDesignator;break;}return RunwayUtils.matchOneWayRunway(airport,oppositeRunwayNumber,oppositeRunwayDesignator);}/**
       * A comparer for sorting runways by number, and then by L, C, and R.
       * @param r1 The first runway to compare.
       * @param r2 The second runway to compare.
       * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
       */static sortRunways(r1,r2){if(r1.direction===r2.direction){let v1=0;if(r1.designation.indexOf('L')!=-1){v1=1;}else if(r1.designation.indexOf('C')!=-1){v1=2;}else if(r1.designation.indexOf('R')!=-1){v1=3;}let v2=0;if(r2.designation.indexOf('L')!=-1){v2=1;}else if(r2.designation.indexOf('C')!=-1){v2=2;}else if(r2.designation.indexOf('R')!=-1){v2=3;}return v1-v2;}return r1.direction-r2.direction;}/**
       * Gets the ICAO string for the runway facility associated with a one-way runway.
       * @param airport The runway's parent airport, or the ICAO of the airport.
       * @param runway A one-way runway.
       * @returns the ICAO string for the runway facility associated with the one-way runway.
       */static getRunwayFacilityIcao(airport,runway){const icao=typeof airport==='string'?airport:airport.icao;return "R  ".concat(icao.substring(7,11),"RW").concat(runway.designation.padEnd(3,' '));}/**
       * Creates a runway waypoint facility from a runway.
       * @param airport The runway's parent airport.
       * @param runway A one-way runway.
       * @returns A runway waypoint facility corresponding to the runway.
       */static createRunwayFacility(airport,runway){return {icao:RunwayUtils.getRunwayFacilityIcao(airport,runway),name:"Runway ".concat(runway.designation),region:airport.region,city:airport.city,lat:runway.latitude,lon:runway.longitude,magvar:airport.magvar,runway};}/**
       * Gets an alpha code from a runway number.
       * @param number is the runway number.
       * @returns a letter.
       */static getRunwayCode(number){const n=Math.round(number);return String.fromCharCode(48+n+(n>9?7:0));}/**
       * Gets the runway surface category from a runway or runway surface type.
       * @param runway A runway or runway surface type.
       * @returns The surface category of the specified runway or runway surface type.
       */static getSurfaceCategory(runway){const surface=typeof runway==='object'?runway.surface:runway;if(this.SURFACES_HARD.includes(surface)){return RunwaySurfaceCategory.Hard;}else if(this.SURFACES_SOFT.includes(surface)){return RunwaySurfaceCategory.Soft;}else if(this.SURFACES_WATER.includes(surface)){return RunwaySurfaceCategory.Water;}else {return RunwaySurfaceCategory.Unknown;}}}RunwayUtils.RUNWAY_DESIGNATOR_LETTERS={[RunwayDesignator.RUNWAY_DESIGNATOR_NONE]:'',[RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]:'L',[RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]:'R',[RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]:'C',[RunwayDesignator.RUNWAY_DESIGNATOR_WATER]:'W',[RunwayDesignator.RUNWAY_DESIGNATOR_A]:'A',[RunwayDesignator.RUNWAY_DESIGNATOR_B]:'B'};RunwayUtils.SURFACES_HARD=[RunwaySurfaceType.Asphalt,RunwaySurfaceType.Bituminous,RunwaySurfaceType.Brick,RunwaySurfaceType.Concrete,RunwaySurfaceType.Ice,RunwaySurfaceType.Macadam,RunwaySurfaceType.Paint,RunwaySurfaceType.Planks,RunwaySurfaceType.SteelMats,RunwaySurfaceType.Tarmac,RunwaySurfaceType.Urban];RunwayUtils.SURFACES_SOFT=[RunwaySurfaceType.Coral,RunwaySurfaceType.Dirt,RunwaySurfaceType.Forest,RunwaySurfaceType.Grass,RunwaySurfaceType.GrassBumpy,RunwaySurfaceType.Gravel,RunwaySurfaceType.HardTurf,RunwaySurfaceType.LongGrass,RunwaySurfaceType.OilTreated,RunwaySurfaceType.Sand,RunwaySurfaceType.Shale,RunwaySurfaceType.ShortGrass,RunwaySurfaceType.Snow,RunwaySurfaceType.WrightFlyerTrack];RunwayUtils.SURFACES_WATER=[RunwaySurfaceType.WaterFSX,RunwaySurfaceType.Lake,RunwaySurfaceType.Ocean,RunwaySurfaceType.Pond,RunwaySurfaceType.River,RunwaySurfaceType.WasteWater,RunwaySurfaceType.Water];RunwayUtils.tempGeoPoint=new GeoPoint(0,0);/**
   * Types of airspaces.
   */var AirspaceType;(function(AirspaceType){AirspaceType[AirspaceType["None"]=0]="None";AirspaceType[AirspaceType["Center"]=1]="Center";AirspaceType[AirspaceType["ClassA"]=2]="ClassA";AirspaceType[AirspaceType["ClassB"]=3]="ClassB";AirspaceType[AirspaceType["ClassC"]=4]="ClassC";AirspaceType[AirspaceType["ClassD"]=5]="ClassD";AirspaceType[AirspaceType["ClassE"]=6]="ClassE";AirspaceType[AirspaceType["ClassF"]=7]="ClassF";AirspaceType[AirspaceType["ClassG"]=8]="ClassG";AirspaceType[AirspaceType["Tower"]=9]="Tower";AirspaceType[AirspaceType["Clearance"]=10]="Clearance";AirspaceType[AirspaceType["Ground"]=11]="Ground";AirspaceType[AirspaceType["Departure"]=12]="Departure";AirspaceType[AirspaceType["Approach"]=13]="Approach";AirspaceType[AirspaceType["MOA"]=14]="MOA";AirspaceType[AirspaceType["Restricted"]=15]="Restricted";AirspaceType[AirspaceType["Prohibited"]=16]="Prohibited";AirspaceType[AirspaceType["Warning"]=17]="Warning";AirspaceType[AirspaceType["Alert"]=18]="Alert";AirspaceType[AirspaceType["Danger"]=19]="Danger";AirspaceType[AirspaceType["Nationalpark"]=20]="Nationalpark";AirspaceType[AirspaceType["ModeC"]=21]="ModeC";AirspaceType[AirspaceType["Radar"]=22]="Radar";AirspaceType[AirspaceType["Training"]=23]="Training";AirspaceType[AirspaceType["Max"]=24]="Max";})(AirspaceType||(AirspaceType={}));/**
   * A viewlistener that gets autopilot mode information.
   */var MSFSAPStates;(function(MSFSAPStates){MSFSAPStates[MSFSAPStates["LogicOn"]=1]="LogicOn";MSFSAPStates[MSFSAPStates["APOn"]=2]="APOn";MSFSAPStates[MSFSAPStates["FDOn"]=4]="FDOn";MSFSAPStates[MSFSAPStates["FLC"]=8]="FLC";MSFSAPStates[MSFSAPStates["Alt"]=16]="Alt";MSFSAPStates[MSFSAPStates["AltArm"]=32]="AltArm";MSFSAPStates[MSFSAPStates["GS"]=64]="GS";MSFSAPStates[MSFSAPStates["GSArm"]=128]="GSArm";MSFSAPStates[MSFSAPStates["Pitch"]=256]="Pitch";MSFSAPStates[MSFSAPStates["VS"]=512]="VS";MSFSAPStates[MSFSAPStates["Heading"]=1024]="Heading";MSFSAPStates[MSFSAPStates["Nav"]=2048]="Nav";MSFSAPStates[MSFSAPStates["NavArm"]=4096]="NavArm";MSFSAPStates[MSFSAPStates["WingLevel"]=8192]="WingLevel";MSFSAPStates[MSFSAPStates["Attitude"]=16384]="Attitude";MSFSAPStates[MSFSAPStates["ThrottleSpd"]=32768]="ThrottleSpd";MSFSAPStates[MSFSAPStates["ThrottleMach"]=65536]="ThrottleMach";MSFSAPStates[MSFSAPStates["ATArm"]=131072]="ATArm";MSFSAPStates[MSFSAPStates["YD"]=262144]="YD";MSFSAPStates[MSFSAPStates["EngineRPM"]=524288]="EngineRPM";MSFSAPStates[MSFSAPStates["TOGAPower"]=1048576]="TOGAPower";MSFSAPStates[MSFSAPStates["Autoland"]=2097152]="Autoland";MSFSAPStates[MSFSAPStates["TOGAPitch"]=4194304]="TOGAPitch";MSFSAPStates[MSFSAPStates["Bank"]=8388608]="Bank";MSFSAPStates[MSFSAPStates["FBW"]=16777216]="FBW";MSFSAPStates[MSFSAPStates["AvionicsManaged"]=33554432]="AvionicsManaged";MSFSAPStates[MSFSAPStates["None"]=-2147483648]="None";})(MSFSAPStates||(MSFSAPStates={}));/// <reference types="@microsoft/msfs-types/js/common" />
  const airportIcaoRegionPattern=new RegExp(/^A../);/**
   * A type map of facility type to facility search type.
   */({/** Airport facility type. */[FacilityType.Airport]:FacilitySearchType.Airport,/** Intersection facility type. */[FacilityType.Intersection]:FacilitySearchType.Intersection,/** NDB facility type. */[FacilityType.NDB]:FacilitySearchType.Ndb,/** VOR facility type. */[FacilityType.VOR]:FacilitySearchType.Vor,/** USR facility type. */[FacilityType.USR]:FacilitySearchType.User,/** Visual facility type. */[FacilityType.VIS]:FacilitySearchType.Visual});/**
   * A class that handles loading facility data from the simulator.
   */class FacilityLoader{/**
       * Creates an instance of the FacilityLoader.
       * @param facilityRepo A local facility repository.
       * @param onInitialized A callback to call when the facility loader has completed initialization.
       */constructor(facilityRepo){let onInitialized=arguments.length>1&&arguments[1]!==undefined?arguments[1]:()=>{};this.facilityRepo=facilityRepo;this.onInitialized=onInitialized;if(FacilityLoader.facilityListener===undefined){FacilityLoader.facilityListener=RegisterViewListener('JS_LISTENER_FACILITY',()=>{FacilityLoader.facilityListener.on('SendAirport',FacilityLoader.onFacilityReceived);FacilityLoader.facilityListener.on('SendIntersection',FacilityLoader.onFacilityReceived);FacilityLoader.facilityListener.on('SendVor',FacilityLoader.onFacilityReceived);FacilityLoader.facilityListener.on('SendNdb',FacilityLoader.onFacilityReceived);FacilityLoader.facilityListener.on('NearestSearchCompleted',FacilityLoader.onNearestSearchCompleted);setTimeout(()=>FacilityLoader.init(),2000);},true);}this.awaitInitialization().then(()=>this.onInitialized());}/**
       * Initializes this facility loader.
       */static init(){FacilityLoader.isInitialized=true;for(const resolve of this.initPromiseResolveQueue){resolve();}this.initPromiseResolveQueue.length=0;}/**
       * Waits until this facility loader is initialized.
       * @returns A Promise which is fulfilled when this facility loader is initialized.
       */awaitInitialization(){if(FacilityLoader.isInitialized){return Promise.resolve();}else {return new Promise(resolve=>{FacilityLoader.initPromiseResolveQueue.push(resolve);});}}/**
       * Retrieves a facility.
       * @param type The type of facility to retrieve.
       * @param icao The ICAO of the facility to retrieve.
       * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
       * retrieved.
       */getFacility(type,icao){switch(type){case FacilityType.USR:case FacilityType.RWY:case FacilityType.VIS:return this.getFacilityFromRepo(type,icao);default:return this.getFacilityFromCoherent(type,icao);}}// eslint-disable-next-line jsdoc/require-throws
  /**
       * Retrieves a facility from the local facility repository.
       * @param type The type of facility to retrieve.
       * @param icao The ICAO of the facility to retrieve.
       * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
       * retrieved.
       */async getFacilityFromRepo(type,icao){const fac=this.facilityRepo.get(icao);if(fac){return fac;}else if(type===FacilityType.RWY){try{const airport=await this.getFacility(FacilityType.Airport,"A      ".concat(icao.substr(3,4)," "));const runway=RunwayUtils.matchOneWayRunwayFromIdent(airport,ICAO.getIdent(icao));if(runway){const runwayFac=RunwayUtils.createRunwayFacility(airport,runway);this.facilityRepo.add(runwayFac);return runwayFac;}}catch(e){// noop
  }}throw "Facility ".concat(icao," could not be found.");}/**
       * Retrieves a facility from Coherent.
       * @param type The type of facility to retrieve.
       * @param icao The ICAO of the facility to retrieve.
       * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
       * retrieved.
       */async getFacilityFromCoherent(type,icao){const isMismatch=ICAO.getFacilityType(icao)!==type;// Remove the region code from the icao
  if(type===FacilityType.Airport){icao=icao.replace(airportIcaoRegionPattern,'A  ');}let queue=FacilityLoader.requestQueue;let cache=FacilityLoader.facCache;if(isMismatch){queue=FacilityLoader.mismatchRequestQueue;cache=FacilityLoader.typeMismatchFacCache;}if(!FacilityLoader.isInitialized){await this.awaitInitialization();}const cachedFac=cache.get(icao);if(cachedFac!==undefined){return Promise.resolve(cachedFac);}const currentTime=Date.now();let request=queue.get(icao);if(request===undefined||currentTime-request.timeStamp>10000){if(request!==undefined){request.reject("Facility request for ".concat(icao," has timed out."));}let resolve=undefined;let reject=undefined;const promise=new Promise((resolution,rejection)=>{resolve=resolution;reject=rejection;Coherent.call(type,icao).then(isValid=>{if(!isValid){rejection("Facility ".concat(icao," could not be found."));queue.delete(icao);}});});request={promise,timeStamp:currentTime,resolve:resolve,reject:reject};queue.set(icao,request);}return request.promise;}/**
       * Gets airway data from the sim.
       * @param airwayName The airway name.
       * @param airwayType The airway type.
       * @param icao The 12 character FS ICAO of at least one intersection in the airway.
       * @returns The retrieved airway.
       * @throws an error if no airway is returned
       */async getAirway(airwayName,airwayType,icao){if(FacilityLoader.airwayCache.has(airwayName)){const cachedAirway=FacilityLoader.airwayCache.get(airwayName);const match=cachedAirway===null||cachedAirway===void 0?void 0:cachedAirway.waypoints.find(w=>{w.icao===icao;});if(match!==undefined&&cachedAirway!==undefined){return cachedAirway;}}const fac=await this.getFacility(FacilityType.Intersection,icao);const route=fac.routes.find(r=>r.name===airwayName);if(route!==undefined){const airwayBuilder=new AirwayBuilder(fac,route,this);const status=await airwayBuilder.startBuild();if(status===AirwayStatus.COMPLETE){const waypoints=airwayBuilder.waypoints;if(waypoints!==null){const airway=new AirwayObject(airwayName,airwayType);airway.waypoints=[...waypoints];FacilityLoader.addToAirwayCache(airway);return airway;}}}throw new Error('Airway could not be found.');}/**
       * Starts a nearest facilities search session.
       * @param type The type of facilities for which to search.
       * @returns A Promise which will be fulfilled with the new nearest search session.
       */async startNearestSearchSession(type){switch(type){case FacilitySearchType.User:case FacilitySearchType.Visual:return this.startRepoNearestSearchSession(type);case FacilitySearchType.AllExceptVisual:return this.startCoherentNearestSearchSession(FacilitySearchType.All);default:return this.startCoherentNearestSearchSession(type);}}/**
       * Starts a sim-side nearest facilities search session through Coherent.
       * @param type The type of facilities for which to search.
       * @returns A Promise which will be fulfilled with the new nearest search session.
       */async startCoherentNearestSearchSession(type){if(!FacilityLoader.isInitialized){await this.awaitInitialization();}const sessionId=await Coherent.call('START_NEAREST_SEARCH_SESSION',type);let session;switch(type){case FacilitySearchType.Airport:session=new NearestAirportSearchSession(sessionId);break;case FacilitySearchType.Intersection:session=new NearestIntersectionSearchSession(sessionId);break;case FacilitySearchType.Vor:session=new NearestVorSearchSession(sessionId);break;case FacilitySearchType.Boundary:session=new NearestBoundarySearchSession(sessionId);break;default:session=new CoherentNearestSearchSession(sessionId);break;}FacilityLoader.searchSessions.set(sessionId,session);return session;}/**
       * Starts a repository facilities search session.
       * @param type The type of facilities for which to search.
       * @returns A Promise which will be fulfilled with the new nearest search session.
       * @throws Error if the search type is not supported.
       */startRepoNearestSearchSession(type){// Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
  // them all to negative numbers
  const sessionId=FacilityLoader.repoSearchSessionId--;switch(type){case FacilitySearchType.User:return new NearestRepoFacilitySearchSession(this.facilityRepo,sessionId);case FacilitySearchType.Visual:return new NearestRepoFacilitySearchSession(this.facilityRepo,sessionId);default:throw new Error();}}// eslint-disable-next-line jsdoc/require-jsdoc
  async getMetar(arg){if(!FacilityLoader.isInitialized){await this.awaitInitialization();}const ident=typeof arg==='string'?arg:ICAO.getIdent(arg.icao);const metar=await Coherent.call('GET_METAR_BY_IDENT',ident);return FacilityLoader.cleanMetar(metar);}/**
       * Searches for the METAR issued for the closest airport to a given location.
       * @param lat The latitude of the center of the search, in degrees.
       * @param lon The longitude of the center of the search, in degrees.
       * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
       */async searchMetar(lat,lon){if(!FacilityLoader.isInitialized){await this.awaitInitialization();}const metar=await Coherent.call('GET_METAR_BY_LATLON',lat,lon);return FacilityLoader.cleanMetar(metar);}/**
       * Cleans up a raw METAR object.
       * @param raw A raw METAR object.
       * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
       */static cleanMetar(raw){if(raw.icao===''){return undefined;}raw.gust<0&&delete raw.gust;raw.vertVis<0&&delete raw.vertVis;isNaN(raw.altimeterA)&&delete raw.altimeterA;raw.altimeterQ<0&&delete raw.altimeterQ;isNaN(raw.slp)&&delete raw.slp;return raw;}/**
       * Searches for ICAOs by their ident portion only.
       * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
       * @param ident The partial or complete ident to search for.
       * @param maxItems The maximum number of matches to return. Defaults to 40.
       * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
       */async searchByIdent(filter,ident){let maxItems=arguments.length>2&&arguments[2]!==undefined?arguments[2]:40;if(!FacilityLoader.isInitialized){await this.awaitInitialization();}let results;if(filter!==FacilitySearchType.User&&filter!==FacilitySearchType.Visual){const coherentFilter=filter===FacilitySearchType.AllExceptVisual?FacilitySearchType.All:filter;results=await Coherent.call('SEARCH_BY_IDENT',ident,coherentFilter,maxItems);}else {results=[];}const facRepositorySearchTypes=FacilityLoader.facRepositorySearchTypes[filter];if(facRepositorySearchTypes){this.facilityRepo.forEach(fac=>{const facIdent=ICAO.getIdent(fac.icao);if(facIdent===ident){results.unshift(fac.icao);}else if(facIdent.startsWith(ident)){results.push(fac.icao);}},facRepositorySearchTypes);}return results;}/**
       * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
       * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
       * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
       * @param lat The latitude to find facilities nearest to.
       * @param lon The longitude to find facilities nearest to.
       * @param maxItems The maximum number of matches to return. Defaults to 40.
       * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
       */async findNearestFacilitiesByIdent(filter,ident,lat,lon){let maxItems=arguments.length>4&&arguments[4]!==undefined?arguments[4]:40;const results=await this.searchByIdent(filter,ident,maxItems);if(!results){return [];}const promises=[];for(let i=0;i<results.length;i++){const icao=results[i];const facIdent=ICAO.getIdent(icao);if(facIdent===ident){const facType=ICAO.getFacilityType(icao);promises.push(this.getFacility(facType,icao));}}const foundFacilities=await Promise.all(promises);if(foundFacilities.length>1){foundFacilities.sort((a,b)=>GeoPoint.distance(lat,lon,a.lat,a.lon)-GeoPoint.distance(lat,lon,b.lat,b.lon));return foundFacilities;}else if(foundFacilities.length===1){return foundFacilities;}else {return [];}}/**
       * A callback called when a facility is received from the simulator.
       * @param facility The received facility.
       */static onFacilityReceived(facility){const isMismatch=facility['__Type']==='JS_FacilityIntersection'&&facility.icao[0]!=='W';const queue=isMismatch?FacilityLoader.mismatchRequestQueue:FacilityLoader.requestQueue;const request=queue.get(facility.icao);if(request!==undefined){request.resolve(facility);FacilityLoader.addToFacilityCache(facility,isMismatch);queue.delete(facility.icao);}}/**
       * A callback called when a search completes.
       * @param results The results of the search.
       */static onNearestSearchCompleted(results){const session=FacilityLoader.searchSessions.get(results.sessionId);if(session instanceof CoherentNearestSearchSession){session.onSearchCompleted(results);}}/**
       * Adds a facility to the cache.
       * @param fac The facility to add.
       * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
       */static addToFacilityCache(fac,isTypeMismatch){const cache=isTypeMismatch?FacilityLoader.typeMismatchFacCache:FacilityLoader.facCache;cache.set(fac.icao,fac);if(cache.size>FacilityLoader.MAX_FACILITY_CACHE_ITEMS){cache.delete(cache.keys().next().value);}}/**
       * Adds an airway to the airway cache.
       * @param airway The airway to add.
       */static addToAirwayCache(airway){FacilityLoader.airwayCache.set(airway.name,airway);if(FacilityLoader.airwayCache.size>FacilityLoader.MAX_AIRWAY_CACHE_ITEMS){FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);}}}FacilityLoader.MAX_FACILITY_CACHE_ITEMS=1000;FacilityLoader.MAX_AIRWAY_CACHE_ITEMS=1000;FacilityLoader.requestQueue=new Map();FacilityLoader.mismatchRequestQueue=new Map();FacilityLoader.facCache=new Map();FacilityLoader.typeMismatchFacCache=new Map();FacilityLoader.airwayCache=new Map();FacilityLoader.searchSessions=new Map();FacilityLoader.facRepositorySearchTypes={[FacilitySearchType.All]:[FacilityType.USR,FacilityType.VIS],[FacilitySearchType.User]:[FacilityType.USR],[FacilitySearchType.Visual]:[FacilityType.VIS],[FacilitySearchType.AllExceptVisual]:[FacilityType.USR]};FacilityLoader.repoSearchSessionId=-1;FacilityLoader.isInitialized=false;FacilityLoader.initPromiseResolveQueue=[];/**
   * A session for searching for nearest facilities through Coherent.
   */class CoherentNearestSearchSession{/**
       * Creates an instance of a CoherentNearestSearchSession.
       * @param sessionId The ID of the session.
       */constructor(sessionId){this.sessionId=sessionId;this.searchQueue=new Map();}/** @inheritdoc */searchNearest(lat,lon,radius,maxItems){const promise=new Promise(resolve=>{Coherent.call('SEARCH_NEAREST',this.sessionId,lat,lon,radius,maxItems).then(searchId=>{this.searchQueue.set(searchId,{promise,resolve});});});return promise;}/**
       * A callback called by the facility loader when a nearest search has completed.
       * @param results The search results.
       */onSearchCompleted(results){const request=this.searchQueue.get(results.searchId);if(request!==undefined){request.resolve(results);this.searchQueue.delete(results.searchId);}}}/**
   * A session for searching for nearest airports.
   */class NearestAirportSearchSession extends CoherentNearestSearchSession{/**
       * Sets the filter for the airport nearest search.
       * @param showClosed Whether or not to show closed airports.
       * @param classMask A bitmask to determine which JS airport classes to show.
       */setAirportFilter(showClosed,classMask){Coherent.call('SET_NEAREST_AIRPORT_FILTER',this.sessionId,showClosed?1:0,classMask);}/**
       * Sets the extended airport filters for the airport nearest search.
       * @param surfaceTypeMask A bitmask of allowable runway surface types.
       * @param approachTypeMask A bitmask of allowable approach types.
       * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
       * @param minRunwayLength The minimum allowable runway length, in meters.
       */setExtendedAirportFilters(surfaceTypeMask,approachTypeMask,toweredMask,minRunwayLength){Coherent.call('SET_NEAREST_EXTENDED_AIRPORT_FILTERS',this.sessionId,surfaceTypeMask,approachTypeMask,toweredMask,minRunwayLength);}}/**
   * Default filters for the nearest airports search session.
   */NearestAirportSearchSession.Defaults={ShowClosed:false,ClassMask:BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface),BitFlags.createFlag(AirportClass.SoftSurface),BitFlags.createFlag(AirportClass.AllWater),BitFlags.createFlag(AirportClass.HeliportOnly),BitFlags.createFlag(AirportClass.Private)),SurfaceTypeMask:2147483647,ApproachTypeMask:2147483647,MinimumRunwayLength:0,ToweredMask:3};/**
   * A session for searching for nearest intersections.
   */class NearestIntersectionSearchSession extends CoherentNearestSearchSession{/**
       * Sets the filter for the intersection nearest search.
       * @param typeMask A bitmask to determine which JS intersection types to show.
       */setIntersectionFilter(typeMask){Coherent.call('SET_NEAREST_INTERSECTION_FILTER',this.sessionId,typeMask);}}/**
   * Default filters for the nearest intersections search session.
   */NearestIntersectionSearchSession.Defaults={TypeMask:BitFlags.union(BitFlags.createFlag(IntersectionType.Named),BitFlags.createFlag(IntersectionType.Unnamed),BitFlags.createFlag(IntersectionType.Offroute),BitFlags.createFlag(IntersectionType.IAF),BitFlags.createFlag(IntersectionType.FAF))};/**
   * A session for searching for nearest VORs.
   */class NearestVorSearchSession extends CoherentNearestSearchSession{/**
       * Sets the filter for the VOR nearest search.
       * @param classMask A bitmask to determine which JS VOR classes to show.
       * @param typeMask A bitmask to determine which JS VOR types to show.
       */setVorFilter(classMask,typeMask){Coherent.call('SET_NEAREST_VOR_FILTER',this.sessionId,classMask,typeMask);}}/**
   * Default filters for the nearest VORs search session.
   */NearestVorSearchSession.Defaults={ClassMask:BitFlags.union(BitFlags.createFlag(VorClass.Terminal),BitFlags.createFlag(VorClass.HighAlt),BitFlags.createFlag(VorClass.LowAlt)),TypeMask:BitFlags.union(BitFlags.createFlag(VorType.VOR),BitFlags.createFlag(VorType.DME),BitFlags.createFlag(VorType.VORDME),BitFlags.createFlag(VorType.VORTAC),BitFlags.createFlag(VorType.TACAN))};/**
   * A session for searching for nearest airspace boundaries.
   */class NearestBoundarySearchSession extends CoherentNearestSearchSession{/**
       * Sets the filter for the boundary nearest search.
       * @param classMask A bitmask to determine which boundary classes to show.
       */setBoundaryFilter(classMask){Coherent.call('SET_NEAREST_BOUNDARY_FILTER',this.sessionId,classMask);}}/**
   * A session for searching for nearest facilities that uses the facility repository.
   */class NearestRepoFacilitySearchSession{/**
       * Creates an instance of a NearestUserSearchSession.
       * @param repo The facility repository in which to search.
       * @param sessionId The ID of the session.
       */constructor(repo,sessionId){this.repo=repo;this.sessionId=sessionId;this.filter=undefined;this.cachedResults=new Set();this.searchId=0;}/** @inheritdoc */searchNearest(lat,lon,radius,maxItems){const radiusGAR=UnitType.METER.convertTo(radius,UnitType.GA_RADIAN);const results=this.repo.search(FacilityType.USR,lat,lon,radiusGAR,maxItems,[],this.filter);const added=[];for(let i=0;i<results.length;i++){const icao=results[i].icao;if(this.cachedResults.has(icao)){this.cachedResults.delete(icao);}else {added.push(icao);}}const removed=Array.from(this.cachedResults);this.cachedResults.clear();for(let i=0;i<results.length;i++){this.cachedResults.add(results[i].icao);}return Promise.resolve({sessionId:this.sessionId,searchId:this.searchId++,added,removed});}/**
       * Sets the filter for this search session.
       * @param filter A function to filter the search results.
       */setUserFacilityFilter(filter){this.filter=filter;}}/**
   * An airway.
   */class AirwayObject{/** Builds a Airway
       * @param name - the name of the new airway.
       * @param type - the type of the new airway.
       */constructor(name,type){this._waypoints=[];this._name=name;this._type=type;}/**
       * Gets the name of the airway
       * @returns the airway name
       */get name(){return this._name;}/**
       * Gets the type of the airway
       * @returns the airway type
       */get type(){return this._type;}/**
       * Gets the waypoints of this airway.
       * @returns the waypoints of this airway.
       */get waypoints(){return this._waypoints;}/**
       * Sets the waypoints of this airway.
       * @param waypoints is the array of waypoints.
       */set waypoints(waypoints){this._waypoints=waypoints;}}/**
   * WT Airway Status Enum
   */var AirwayStatus;(function(AirwayStatus){/**
       * @readonly
       * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
       */AirwayStatus[AirwayStatus["INCOMPLETE"]=0]="INCOMPLETE";/**
       * @readonly
       * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
       */AirwayStatus[AirwayStatus["COMPLETE"]=1]="COMPLETE";/**
       * @readonly
       * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
       */AirwayStatus[AirwayStatus["PARTIAL"]=2]="PARTIAL";})(AirwayStatus||(AirwayStatus={}));/**
   * The Airway Builder.
   */class AirwayBuilder{/** Creates an instance of the AirwayBuilder
       * @param _initialWaypoint is the initial intersection facility
       * @param _initialData is the intersection route to build from
       * @param facilityLoader is an instance of the facility loader
       */constructor(_initialWaypoint,_initialData,facilityLoader){this._initialWaypoint=_initialWaypoint;this._initialData=_initialData;this.facilityLoader=facilityLoader;this._waypointsArray=[];this._hasStarted=false;this._isDone=false;}// constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
  // }
  /**
       * Get whether this builder has started loading waypoints
       * @returns whether this builder has started
       */get hasStarted(){return this._hasStarted;}/**
       * Get whether this builder is done loading waypoints
       * @returns whether this builder is done loading waypoints
       */get isDone(){return this._isDone;}/**
       * Get the airway waypoints
       * @returns the airway waypoints, or null
       */get waypoints(){return this._waypointsArray;}/** Steps through the airway waypoints
       * @param stepForward is the direction to step; true = forward, false = backward
       * @param arrayInsertFunc is the arrayInsertFunc
       */async _step(stepForward,arrayInsertFunc){let isDone=false;let current=this._initialData;while(!isDone&&current){const nextICAO=stepForward?current.nextIcao:current.prevIcao;if(nextICAO&&nextICAO.length>0&&nextICAO[0]!=' '&&this._waypointsArray!==null&&!this._waypointsArray.find(waypoint=>waypoint.icao===nextICAO)){const fac=await this.facilityLoader.getFacility(FacilityType.Intersection,nextICAO);arrayInsertFunc(fac);const next=fac.routes.find(route=>route.name===current.name);if(next!==undefined){current=next;}else {isDone=true;}}else {isDone=true;}}}/** Steps Forward through the airway waypoints
       * @returns the step forward function
       */async _stepForward(){if(this._waypointsArray!==null){return this._step(true,this._waypointsArray.push.bind(this._waypointsArray));}}/** Steps Backward through the airway waypoints
       * @returns the step backward function
       */async _stepBackward(){if(this._waypointsArray!==null){return this._step(false,this._waypointsArray.unshift.bind(this._waypointsArray));}}/**
       * Sets the array into which this builder will load waypoints.
       * @param array is the array into which the builder will load waypoints
       */setWaypointsArray(array){this._waypointsArray=array;}/**
       * Begins loading waypoints for this builder's parent airway.
       * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
       * finished loading waypoints.
       */startBuild(){if(this.hasStarted){return Promise.reject(new Error('Airway builder has already started building.'));}return new Promise(resolve=>{this._hasStarted=true;if(this._waypointsArray!==null){this._waypointsArray.push(this._initialWaypoint);Promise.all([this._stepForward(),this._stepBackward()]).then(()=>{this._isDone=true;resolve(AirwayStatus.COMPLETE);}).catch(()=>{this._isDone=true;resolve(AirwayStatus.PARTIAL);});}});}}/**
   * Utility functions for working with arrays.
   */class ArrayUtils{/**
       * Creates a new array with initialized values.
       * @param length The length of the new array.
       * @param init A function which generates initial values for the new array at each index.
       * @returns A new array of the specified length with initialized values.
       */static create(length,init){const newArray=[];for(let i=0;i<length;i++){newArray[i]=init(i);}return newArray;}/**
       * Gets the element at a specific index in an array.
       * @param array An array.
       * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
       * array (`-1` accesses the last element, `-2` the second to last element, etc).
       * @returns The element at the specified index in the array.
       * @throws RangeError if the index is out of bounds.
       */static at(array,index){if(index<0){index+=array.length;}if(index<0||index>=array.length){throw new RangeError();}return array[index];}/**
       * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
       * @param array An array.
       * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
       * array (`-1` accesses the last element, `-2` the second to last element, etc).
       * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
       */static peekAt(array,index){if(index<0){index+=array.length;}return array[index];}/**
       * Gets the first element of an array.
       * @param array An array.
       * @returns The first element of the specified array.
       * @throws RangeError if the array is empty.
       */static first(array){if(array.length===0){throw new RangeError();}return array[0];}/**
       * Gets the first element of an array if it is not empty, or `undefined` otherwise.
       * @param array An array.
       * @returns The first element of an array if it is not empty, or `undefined` otherwise.
       */static peekFirst(array){return array[0];}/**
       * Gets the last element of an array.
       * @param array An array.
       * @returns The last element of the specified array.
       * @throws RangeError if the array is empty.
       */static last(array){if(array.length===0){throw new RangeError();}return array[array.length-1];}/**
       * Gets the last element of an array if it is not empty, or `undefined` otherwise.
       * @param array An array.
       * @returns The last element of an array if it is not empty, or `undefined` otherwise.
       */static peekLast(array){return array[array.length-1];}/**
       * Checks if a certain element is included in an array.
       * @param array An array.
       * @param searchElement The element to search for.
       * @param fromIndex The position in this array at which to begin searching for `searchElement`.
       * @returns Whether the search element is included in the specified array.
       */static includes(array,searchElement,fromIndex){return array.includes(searchElement,fromIndex);}/**
       * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
       * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
       * @param a The first array.
       * @param b The second array.
       * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
       * to a function which uses the strict equality operator (`===`).
       * @returns Whether the two specified arrays are equal.
       */static equals(a,b){let equalsFunc=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ArrayUtils.STRICT_EQUALS;if(a.length!==b.length){return false;}for(let i=0;i<a.length;i++){if(!equalsFunc(a[i],b[i])){return false;}}return true;}/**
       * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
       * mapped elements to a maximum depth of one, leaving the original array intact.
       * @param array An array.
       * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
       * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
       * elements to a maximum depth of one.
       */static flatMap(array,map){const out=[];for(let i=0;i<array.length;i++){const mapped=map(array[i],i,array);if(Array.isArray(mapped)){for(let j=0;j<mapped.length;j++){out[out.length]=mapped[j];}}else {out[out.length]=mapped;}}return out;}/**
       * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
       * process of flattening replaces each element in the array that is itself an array with the sequence of elements
       * found in the sub-array, recursively up to the maximum depth.
       * @param array An array.
       * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
       * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
       * @returns A new array which was created by flattening the specified array to the specified maximum depth.
       */static flat(array){let depth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;const out=[];this.flatHelper(array,depth,0,out);return out;}/**
       * Recursively flattens an array and writes the flattened sequence of elements into another array.
       * @param array The array to flatten.
       * @param maxDepth The maximum depth to which to flatten.
       * @param depth The current flattening depth.
       * @param out The array to which to write the flattened sequence of elements.
       */static flatHelper(array,maxDepth,depth,out){for(let i=0;i<array.length;i++){const element=array[i];if(Array.isArray(element)&&depth<maxDepth){this.flatHelper(element,maxDepth,depth+1,out);}else {out[out.length]=element;}}}/**
       * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
       * length and the same elements in the same order as the source array.
       * @param source The array to copy.
       * @param target The array to copy into. If not defined, a new array will be created.
       * @returns The target array, after the source array has been copied into it.
       */static shallowCopy(source){let target=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];target.length=source.length;for(let i=0;i<source.length;i++){target[i]=source[i];}return target;}/**
       * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
       * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
       * where `index` is the index at which the query element would be found if it were contained in the sorted array.
       * @param array An array.
       * @param element The element to search for.
       * @param comparator A function which determines the sorting order of elements in the array. The function should
       * return a negative number if the first element is to be sorted before the second, a positive number if the first
       * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
       * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
       * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
       * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
       * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
       * the query element would be found if it were contained in the sorted array, if no element in the array has a
       * sorting order equal to the query.
       */static binarySearch(array,element,comparator){let first=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;let min=0;let max=array.length;let index=Math.floor((min+max)/2);while(min<max){const compare=comparator(element,array[index]);if(compare<0){max=index;}else if(compare>0){min=index+1;}else {const delta=first?-1:1;while(index+delta>=0&&index+delta<array.length&&comparator(element,array[index+delta])===0){index+=delta;}return index;}index=Math.floor((min+max)/2);}return -(index+1);}/**
       * Gets the length of the longest string in the array.
       * @param array The array to search in.
       * @returns length of the longest string
       */static getMaxStringLength(array){return array.reduce((accum,curr)=>curr.length>accum?curr.length:accum,0);}}ArrayUtils.STRICT_EQUALS=(a,b)=>a===b;/**
   * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
   * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
   * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
   * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
   * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
   * the two operations separately.
   */class BinaryHeap{/**
       * Constructor.
       * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
       * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
       * has a greater key than `b`.
       */constructor(comparator){this.comparator=comparator;this.tree=[];}// eslint-disable-next-line jsdoc/require-returns
  /** The number of elements contained in this heap. */get size(){return this.tree.length;}/**
       * Finds the element in this heap with the smallest key.
       * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
       */findMin(){return this.tree[0];}/**
       * Removes and returns the element in this heap with the smallest key.
       * @returns The removed element, or undefined if this heap is empty.
       */removeMin(){if(this.tree.length===0){return undefined;}const min=this.tree[0];this.swap(0,this.tree.length-1);this.tree.length--;this.heapifyDown(0);return min;}/**
       * Inserts an element into this heap.
       * @param element The element to insert.
       * @returns This heap, after the element has been inserted.
       */insert(element){this.tree.push(element);this.heapifyUp(this.tree.length-1);return this;}/**
       * Inserts an element into this heap, then removes the element with the smallest key.
       * @param element The element to insert.
       * @returns The removed element.
       */insertAndRemoveMin(element){if(this.tree.length===0||this.comparator(element,this.tree[0])<=0){return element;}return this.removeMinAndInsert(element);}/**
       * Removes the element in this heap with the smallest key, then inserts a new element.
       * @param element The element to insert.
       * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
       */removeMinAndInsert(element){const min=this.tree[0];this.tree[0]=element;this.heapifyDown(0);return min;}/**
       * Removes all elements from this heap.
       * @returns This heap, after it has been cleared.
       */clear(){this.tree.length=0;return this;}/**
       * Restores the heap property for this heap upwards from a node which potentially violates the property.
       * @param index The index of the node at which to begin the operation.
       */heapifyUp(index){let parent=BinaryHeap.parent(index);while(parent>=0&&this.comparator(this.tree[index],this.tree[parent])<0){this.swap(parent,index);index=parent;parent=BinaryHeap.parent(index);}}/**
       * Restores the heap property for this heap downwards from a node which potentially violates the property.
       * @param index The index of the node at which to begin the operation.
       */heapifyDown(index){const len=this.tree.length;while(index<len){const left=BinaryHeap.left(index);const right=BinaryHeap.right(index);let needSwapFlags=0;if(left<len&&this.comparator(this.tree[index],this.tree[left])>0){needSwapFlags|=1;}if(right<len&&this.comparator(this.tree[index],this.tree[right])>0){needSwapFlags|=2;}if(needSwapFlags===3){needSwapFlags=this.comparator(this.tree[left],this.tree[right])<=0?1:2;}if(needSwapFlags===0){break;}const swapChild=needSwapFlags===1?left:right;this.swap(index,swapChild);index=swapChild;}}/**
       * Swaps two nodes in this heap.
       * @param index1 The index of the first node.
       * @param index2 The index of the second node.
       */swap(index1,index2){const old1=this.tree[index1];this.tree[index1]=this.tree[index2];this.tree[index2]=old1;}/**
       * Finds the index of a node's parent.
       * @param index the index of the node for which to find the parent.
       * @returns The index of the query node's parent.
       */static parent(index){return index-1>>1;}/**
       * Finds the index of a node's left child.
       * @param index The index of the node for which to find the child.
       * @returns The index of the query node's left child.
       */static left(index){return index*2+1;}/**
       * Finds the index of a node's right child.
       * @param index The index of the node for which to find the child.
       * @returns The idnex of the query node's right child.
       */static right(index){return index*2+2;}}/**
   * A k-dimensional search tree.
   */class KdTree{/**
       * Constructor.
       * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
       * be truncated to one.
       * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
       * the dimension count of this tree.
       * @throws Error if the dimension count is less than 2.
       */constructor(dimensionCount,keyFunc){this.keyFunc=keyFunc;this.elements=[];this.keys=[];this.nodes=[];this.minDepth=-1;this.maxDepth=-1;this.dimensionCount=Math.trunc(dimensionCount);if(this.dimensionCount<2){throw new Error("KdTree: cannot create a tree with ".concat(this.dimensionCount," dimensions."));}this.indexArrays=Array.from({length:this.dimensionCount+1},()=>[]);this.indexSortFuncs=Array.from({length:this.dimensionCount},(v,index)=>{return (a,b)=>{const aKey=this.keys[a];const bKey=this.keys[b];for(let i=0;i<this.dimensionCount;i++){const dimension=(i+index)%this.dimensionCount;if(aKey[dimension]<bKey[dimension]){return -1;}else if(aKey[dimension]>bKey[dimension]){return 1;}}return 0;};});this.keyCache=[new Float64Array(this.dimensionCount)];}// eslint-disable-next-line jsdoc/require-returns
  /** The number of elements in this tree. */get size(){return this.elements.length;}// eslint-disable-next-line jsdoc/require-jsdoc
  searchKey(key,radius,arg3,out,filter){if(typeof arg3==='number'){return this.doResultsSearch(undefined,key,radius,arg3,out,filter);}else {this.doVisitorSearch(undefined,key,radius,arg3);}}// eslint-disable-next-line jsdoc/require-jsdoc
  search(element,radius,arg3,out,filter){const key=this.keyFunc(element,this.keyCache[0]);if(typeof arg3==='number'){return this.doResultsSearch(element,key,radius,arg3,out,filter);}else {this.doVisitorSearch(element,key,radius,arg3);}}/**
       * Performs a tree search with a visitor function.
       * @param element The query element, or undefined if none exists.
       * @param key The query key.
       * @param radius The search radius.
       * @param visitor A visitor function. This function will be called once per element found within the search radius.
       * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
       * immediately halt.
       */doVisitorSearch(element,key,radius,visitor){const resultHandler=(elementIndex,elementInner,keyInner,distance,queryKey,queryElement)=>{return visitor(elementInner,keyInner,distance,queryKey,queryElement);};const traversalHandler=(offsetFromPivot,searchRadius,child)=>{return searchRadius+offsetFromPivot*child>=0;};this.searchTree(element,key,radius,0,0,resultHandler,traversalHandler);}/**
       * Performs a tree search and returns an array of search results.
       * @param element The query element, or undefined if none exists.
       * @param key The query key.
       * @param radius The search radius.
       * @param maxResultCount The maximum number of search results to return.
       * @param out An array in which to store the search results.
       * @param filter A function to filter the search results.
       * @returns An array containing the search results, in order of increasing distance from the query key.
       */doResultsSearch(element,key,radius,maxResultCount,out,filter){if(maxResultCount<=0){out.length=0;return out;}const heap=new BinaryHeap((a,b)=>KdTree.distance(key,this.keys[b],this.dimensionCount)-KdTree.distance(key,this.keys[a],this.dimensionCount));const resultHandler=(elementIndex,elementInner,keyInner,distance,queryKey,queryElement)=>{if(!filter||filter(elementInner,keyInner,distance,queryKey,queryElement)){if(heap.size===maxResultCount){heap.insertAndRemoveMin(elementIndex);}else {heap.insert(elementIndex);}}return true;};const traversalHandler=(offsetFromPivot,searchRadius,child)=>{let maxDist=searchRadius;if(heap.size===maxResultCount){maxDist=Math.min(maxDist,KdTree.distance(key,this.keys[heap.findMin()],this.dimensionCount));}return maxDist+offsetFromPivot*child>=0;};this.searchTree(element,key,radius,0,0,resultHandler,traversalHandler);out.length=heap.size;for(let i=out.length-1;i>=0;i--){out[i]=this.elements[heap.removeMin()];}return out;}/**
       * Searches a subtree for elements whose keys are located near a query key.
       * @param element The query element, or undefined if none exists.
       * @param key The query key.
       * @param radius The search radius.
       * @param nodeIndex The index of the root of the subtree to search.
       * @param pivotDimension The dimension in which the root of the subtree is split.
       * @param resultHandler A function which will be called once per element found within the search radius. If the
       * function returns `true`, then the search will continue; if the function returns `false`, the search will
       * immediately halt.
       * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
       * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
       * child.
       * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
       */searchTree(element,key,radius,nodeIndex,pivotDimension,resultHandler,traversalHandler){const elementIndex=this.nodes[nodeIndex];if(elementIndex===undefined){return true;}const nodeKey=this.keys[elementIndex];const distanceFromNode=KdTree.distance(key,nodeKey,this.dimensionCount);if(distanceFromNode<=radius){if(!resultHandler(elementIndex,this.elements[elementIndex],nodeKey,distanceFromNode,key,element)){return false;}}const offsetFromPivot=key[pivotDimension]-nodeKey[pivotDimension];const nextPivotDimension=(pivotDimension+1)%this.dimensionCount;const lesserNodeIndex=KdTree.lesser(nodeIndex);const greaterNodeIndex=KdTree.greater(nodeIndex);if(this.nodes[lesserNodeIndex]!==undefined&&traversalHandler(offsetFromPivot,radius,-1)){if(!this.searchTree(element,key,radius,lesserNodeIndex,nextPivotDimension,resultHandler,traversalHandler)){return false;}}if(this.nodes[greaterNodeIndex]!==undefined&&traversalHandler(offsetFromPivot,radius,1)){if(!this.searchTree(element,key,radius,greaterNodeIndex,nextPivotDimension,resultHandler,traversalHandler)){return false;}}return true;}/**
       * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
       * of this tree's longest branch is more than twice the length of the shortest branch.
       * @param element The element to insert.
       */insert(element){const insertDepth=this.insertElementInTree(element)+1;this.maxDepth=Math.max(this.maxDepth,insertDepth);if(insertDepth===this.minDepth+1){this.minDepth=KdTree.depth(this.nodes.indexOf(undefined,KdTree.leastIndexAtDepth(Math.max(0,this.minDepth))));}// Rebalance the tree if max depth is greater than twice the min depth.
  if(this.maxDepth+1>(this.minDepth+1)*2){this.rebuild();}}/**
       * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
       * @param elements An iterable of the elements to insert.
       */insertAll(elements){for(const element of elements){this.elements.push(element);this.keys.push(this.keyFunc(element,new Float64Array(this.dimensionCount)));const insertedIndex=this.elements.length-1;for(let i=0;i<this.dimensionCount;i++){this.indexArrays[i].push(insertedIndex);}}this.rebuild();}/**
       * Inserts an element into this tree.
       * @param element The element to insert.
       * @returns The depth at which the element was inserted, with 0 being the depth of the root.
       */insertElementInTree(element){const key=this.keyFunc(element,new Float64Array(this.dimensionCount));let index=0;let depth=0;let elementIndex;while((elementIndex=this.nodes[index])!==undefined){const pivotDimension=depth%this.dimensionCount;const keyToCompare=key[pivotDimension];if(keyToCompare<=this.keys[elementIndex][pivotDimension]){index=KdTree.lesser(index);}else {index=KdTree.greater(index);}depth++;}this.elements.push(element);this.keys.push(key);const insertedIndex=this.elements.length-1;this.nodes[index]=insertedIndex;for(let i=0;i<this.dimensionCount;i++){this.indexArrays[i].push(insertedIndex);}return depth;}/**
       * Removes an element from this tree. This tree will be rebalanced after the element is removed.
       * @param element The element to remove.
       * @returns Whether the element was removed.
       */remove(element){if(!this.removeElementFromArrays(element)){return false;}this.resetIndexArrays();this.rebuild();return true;}/**
       * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
       * @param elements An iterable of the elements to remove.
       * @returns Whether at least one element was removed.
       */removeAll(elements){let removed=false;for(const element of elements){removed=this.removeElementFromArrays(element)||removed;}if(removed){this.resetIndexArrays();this.rebuild();}return removed;}/**
       * Removes an element and all references to it from this tree's arrays. This method does not change the structure
       * of this tree to reflect the removal of the element.
       * @param element The element to remove.
       * @returns Whether the element was removed.
       */removeElementFromArrays(element){const index=this.elements.indexOf(element);if(index<0){return false;}const lastIndex=this.elements.length-1;this.elements[index]=this.elements[lastIndex];this.keys[index]=this.keys[lastIndex];this.elements.length--;this.keys.length--;return true;}/**
       * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
       * number of elements in the tree.
       */resetIndexArrays(){for(let i=0;i<this.dimensionCount;i++){const array=this.indexArrays[i];array.length=this.elements.length;for(let j=0;j<array.length;j++){array[j]=j;}}}/**
       * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
       * rebalanced at the end of the operation.
       *
       * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
       * @param toRemove An iterable of the elements to remove.
       * @param toInsert An iterable of the elements to insert.
       */removeAndInsert(toRemove,toInsert){let removed=false;for(const element of toRemove){removed=this.removeElementFromArrays(element)||removed;}if(removed){this.resetIndexArrays();}this.insertAll(toInsert);}/**
       * Rebuilds and balances this tree.
       */rebuild(){// clear the tree structure
  this.nodes.length=0;if(this.size===0){return;}// sort index arrays
  for(let i=0;i<this.dimensionCount;i++){this.indexArrays[i].sort(this.indexSortFuncs[i]);}this.buildSubTree(0,0,0,this.indexArrays[0].length);const log=Math.log2(this.elements.length+1);this.minDepth=Math.floor(log)-1;this.maxDepth=Math.ceil(log)-1;}/**
       * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
       * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
       * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
       * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
       * 0 when reaching `this.dimensionCount`).
       * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
       * pivot key will be placed at this node.
       * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
       * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
       * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
       */buildSubTree(nodeIndex,pivotDimension,start,end){const tempArray=this.indexArrays[this.dimensionCount];const sortedArray=this.indexArrays[0];const medianIndex=Math.trunc((start+end)/2);const medianKeyIndex=sortedArray[medianIndex];// Insert median into its position in the tree
  this.nodes[nodeIndex]=medianKeyIndex;if(end-start===1){return;}if(end-start<=3){const lesserIndex=medianIndex-1;const greaterIndex=medianIndex+1;if(lesserIndex>=start){this.nodes[KdTree.lesser(nodeIndex)]=sortedArray[lesserIndex];}if(greaterIndex<end){this.nodes[KdTree.greater(nodeIndex)]=sortedArray[greaterIndex];}return;}for(let i=start;i<end;i++){tempArray[i]=sortedArray[i];}// Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
  // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
  // index 0.
  for(let i=1;i<this.dimensionCount;i++){const targetArray=this.indexArrays[i-1];const toPartitionArray=this.indexArrays[i];let lesserCount=0;let greaterCount=0;for(let j=start;j<end;j++){const keyIndex=toPartitionArray[j];if(keyIndex===medianKeyIndex){targetArray[medianIndex]=keyIndex;}else {const comparison=this.indexSortFuncs[pivotDimension](keyIndex,medianKeyIndex);if(comparison<=0){const index=start+lesserCount++;targetArray[index]=keyIndex;}else {const index=medianIndex+1+greaterCount++;targetArray[index]=keyIndex;}}}}// Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
  const newSortedArray=this.indexArrays[this.dimensionCount-1];for(let i=start;i<end;i++){newSortedArray[i]=tempArray[i];}const nextPivotDimension=(pivotDimension+1)%this.dimensionCount;this.buildSubTree(KdTree.lesser(nodeIndex),nextPivotDimension,start,medianIndex);this.buildSubTree(KdTree.greater(nodeIndex),nextPivotDimension,medianIndex+1,end);}/**
       * Removes all elements from this tree.
       */clear(){this.elements.length=0;this.keys.length=0;this.nodes.length=0;for(let i=0;i<this.indexArrays.length;i++){this.indexArrays[i].length=0;}this.minDepth=-1;this.maxDepth=-1;}/**
       * Finds the index of a node's parent.
       * @param index the index of the node for which to find the parent.
       * @returns The index of the query node's parent.
       */static parent(index){return index-1>>1;}/**
       * Finds the index of a node's lesser child.
       * @param index The index of the node for which to find the child.
       * @returns The index of the query node's lesser child.
       */static lesser(index){return index*2+1;}/**
       * Finds the index of a node's greater child.
       * @param index The index of the node for which to find the child.
       * @returns The idnex of the query node's greater child.
       */static greater(index){return index*2+2;}/**
       * Finds the least index of any node located at a given depth.
       * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
       * @returns The least index of any node located at the specified depth.
       */static leastIndexAtDepth(depth){return 1<<depth-1;}/**
       * Finds the depth at which a node lies.
       * @param index The index of the node for which to find the depth.
       * @returns The depth at which the node lies. The root of the tree lies at depth 0.
       */static depth(index){return Math.trunc(Math.log2(index+1));}/**
       * Calculates the Euclidean distance between two keys.
       * @param key1 The first key.
       * @param key2 The second key.
       * @param dimensionCount The number of dimensions in which to calculate the distance.
       * @returns The Euclidean distance between the two keys.
       */static distance(key1,key2,dimensionCount){let sumSq=0;for(let i=0;i<dimensionCount;i++){const diff=key1[i]-key2[i];sumSq+=diff*diff;}return Math.sqrt(sumSq);}}/**
   * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
   * circle distances from their keys to a query point.
   */class GeoKdTree{/**
       * Constructor.
       * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
       * Earth's surface.
       * @throws Error if the dimension count is less than 2.
       */constructor(keyFunc){this.keyFunc=keyFunc;this.cartesianTree=new KdTree(3,(element,out)=>{const vec=this.keyFunc(element,GeoKdTree.vec3Cache[0]);out[0]=vec[0];out[1]=vec[1];out[2]=vec[2];return out;});}// eslint-disable-next-line jsdoc/require-jsdoc
  search(arg1,arg2,arg3,arg4,arg5,arg6){let center,radius;let argA,argB,argC;if(typeof arg1==='number'){center=GeoPoint.sphericalToCartesian(arg1,arg2,GeoKdTree.vec3Cache[1]);radius=arg3;argA=arg4;argB=arg5;argC=arg6;}else if(!(arg1 instanceof Float64Array)){center=GeoPoint.sphericalToCartesian(arg1,GeoKdTree.vec3Cache[1]);radius=arg2;argA=arg3;argB=arg4;argC=arg5;}else {center=arg1;radius=arg2;argA=arg3;argB=arg4;argC=arg5;}const radiusCartesian=Math.sqrt(2*(1-Math.cos(Utils.Clamp(radius,0,Math.PI))));if(typeof argA==='number'){return this.doResultsSearch(center,radiusCartesian,argA,argB,argC);}else {this.doVisitorSearch(center,radiusCartesian,argA);}}/**
       * Performs a tree search with a visitor function.
       * @param center The query point.
       * @param radiusCartesian The query radius.
       * @param visitor A visitor function. This function will be called once per element found within the search radius.
       * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
       * immediately halt.
       */doVisitorSearch(center,radiusCartesian,visitor){this.cartesianTree.searchKey(center,radiusCartesian,(element,key)=>{const vec=Vec3Math.set(key[0],key[1],key[2],GeoKdTree.vec3Cache[2]);const greatCircleDist=GeoPoint.distance(vec,center);return visitor(element,vec,greatCircleDist,center);});}/**
       * Performs a tree search and returns an array of search results.
       * @param center The query point.
       * @param radiusCartesian The query radius.
       * @param maxResultCount The maximum number of search results to return.
       * @param out An array in which to store the search results.
       * @param filter A function to filter the search results.
       * @returns An array containing the search results, in order of increasing distance from the query key.
       */doResultsSearch(center,radiusCartesian,maxResultCount,out,filter){const cartesianFilter=filter?(element,key)=>{const vec=Vec3Math.set(key[0],key[1],key[2],GeoKdTree.vec3Cache[2]);const greatCircleDist=GeoPoint.distance(vec,center);return filter(element,vec,greatCircleDist,center);}:undefined;return this.cartesianTree.searchKey(center,radiusCartesian,maxResultCount,out,cartesianFilter);}/**
       * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
       * of this tree's longest branch is more than twice the length of the shortest branch.
       * @param element The element to insert.
       */insert(element){this.cartesianTree.insert(element);}/**
       * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
       * @param elements An iterable of the elements to insert.
       */insertAll(elements){this.cartesianTree.insertAll(elements);}/**
       * Removes an element from this tree. This tree will be rebalanced after the element is removed.
       * @param element The element to remove.
       * @returns Whether the element was removed.
       */remove(element){return this.cartesianTree.remove(element);}/**
       * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
       * @param elements An iterable of the elements to remove.
       * @returns Whether at least one element was removed.
       */removeAll(elements){return this.cartesianTree.removeAll(elements);}/**
       * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
       * rebalanced at the end of the operation.
       *
       * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
       * @param toRemove An iterable of the elements to remove.
       * @param toInsert An iterable of the elements to insert.
       */removeAndInsert(toRemove,toInsert){this.cartesianTree.removeAndInsert(toRemove,toInsert);}/**
       * Rebuilds and balances this tree.
       */rebuild(){this.cartesianTree.rebuild();}/**
       * Removes all elements from this tree.
       */clear(){this.cartesianTree.clear();}}GeoKdTree.vec3Cache=[new Float64Array(3),new Float64Array(3),new Float64Array(3),new Float64Array(3)];/**
   * Types of subscribable array change event.
   */var SubscribableArrayEventType;(function(SubscribableArrayEventType){/** An element was added. */SubscribableArrayEventType["Added"]="Added";/** An element was removed. */SubscribableArrayEventType["Removed"]="Removed";/** The array was cleared. */SubscribableArrayEventType["Cleared"]="Cleared";})(SubscribableArrayEventType||(SubscribableArrayEventType={}));/**
   * An array-like class to observe changes in a list of objects.
   * @class ArraySubject
   * @template T
   */class AbstractSubscribableArray{constructor(){this.subs=[];this.notifyDepth=0;/** A function which sends initial notifications to subscriptions. */this.initialNotifyFunc=this.initialNotify.bind(this);/** A function which responds to when a subscription to this subscribable is destroyed. */this.onSubDestroyedFunc=this.onSubDestroyed.bind(this);}/** @inheritdoc */sub(handler){let initialNotify=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let paused=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const sub=new HandlerSubscription(handler,this.initialNotifyFunc,this.onSubDestroyedFunc);this.subs.push(sub);if(paused){sub.pause();}else if(initialNotify){sub.initialNotify();}return sub;}/** @inheritdoc */unsub(handler){const toDestroy=this.subs.find(sub=>sub.handler===handler);toDestroy===null||toDestroy===void 0?void 0:toDestroy.destroy();}/**
       * Gets an item from the array.
       * @param index Thex index of the item to get.
       * @returns An item.
       * @throws
       */get(index){const array=this.getArray();if(index>array.length-1){throw new Error('Index out of range');}return array[index];}/**
       * Tries to get the value from the array.
       * @param index The index of the item to get.
       * @returns The value or undefined if not found.
       */tryGet(index){return this.getArray()[index];}/**
       * Notifies subscriptions of a change in the array.
       * @param index The index that was changed.
       * @param type The type of subject event.
       * @param modifiedItem The item modified by the operation.
       */notify(index,type,modifiedItem){let needCleanUpSubs=false;this.notifyDepth++;const subLen=this.subs.length;for(let i=0;i<subLen;i++){try{const sub=this.subs[i];if(sub.isAlive&&!sub.isPaused){sub.handler(index,type,modifiedItem,this.getArray());}needCleanUpSubs||(needCleanUpSubs=!sub.isAlive);}catch(error){console.error("ArraySubject: error in handler: ".concat(error));if(error instanceof Error){console.error(error.stack);}}}this.notifyDepth--;if(needCleanUpSubs&&this.notifyDepth===0){this.subs=this.subs.filter(sub=>sub.isAlive);}}/**
       * Notifies a subscription of this array's current state.
       * @param sub The subscription to notify.
       */initialNotify(sub){const array=this.getArray();sub.handler(0,SubscribableArrayEventType.Added,array,array);}/**
       * Responds to when a subscription to this array is destroyed.
       * @param sub The destroyed subscription.
       */onSubDestroyed(sub){// If we are not in the middle of a notify operation, remove the subscription.
  // Otherwise, do nothing and let the post-notify clean-up code handle it.
  if(this.notifyDepth===0){this.subs.splice(this.subs.indexOf(sub),1);}}}/**
   * Types of facility repository sync events.
   */var FacilityRepositorySyncType;(function(FacilityRepositorySyncType){FacilityRepositorySyncType["Add"]="Add";FacilityRepositorySyncType["Remove"]="Remove";FacilityRepositorySyncType["DumpRequest"]="DumpRequest";FacilityRepositorySyncType["DumpResponse"]="DumpResponse";})(FacilityRepositorySyncType||(FacilityRepositorySyncType={}));/**
   * A repository of facilities.
   */class FacilityRepository{/**
       * Constructor.
       * @param bus The event bus.
       */constructor(bus){this.bus=bus;this.publisher=this.bus.getPublisher();this.repos=new Map();this.trees={[FacilityType.USR]:new GeoKdTree(FacilityRepository.treeKeyFunc),[FacilityType.VIS]:new GeoKdTree(FacilityRepository.treeKeyFunc)};this.ignoreSync=false;bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));// Request a dump from any existing instances on other instruments to initialize the repository.
  this.pubSyncEvent({type:FacilityRepositorySyncType.DumpRequest,uid:this.lastDumpRequestUid=Math.random()*Number.MAX_SAFE_INTEGER});}/**
       * Gets the number of facilities stored in this repository.
       * @param types The types of facilities to count. Defaults to all facility types.
       * @returns The number of facilities stored in this repository.
       */size(types){var _a,_b;let size=0;if(types===undefined){for(const repo of this.repos.values()){size+=repo.size;}}else {for(let i=0;i<types.length;i++){size+=(_b=(_a=this.repos.get(types[i]))===null||_a===void 0?void 0:_a.size)!==null&&_b!==void 0?_b:0;}}return size;}/**
       * Retrieves a facility from this repository.
       * @param icao The ICAO of the facility to retrieve.
       * @returns The requested user facility, or undefined if it was not found in this repository.
       */get(icao){var _a;if(!ICAO.isFacility(icao)){return undefined;}return (_a=this.repos.get(ICAO.getFacilityType(icao)))===null||_a===void 0?void 0:_a.get(icao);}// eslint-disable-next-line jsdoc/require-jsdoc
  search(type,lat,lon,radius,arg5,out,filter){if(type!==FacilityType.USR&&type!==FacilityType.VIS){throw new Error("FacilityRepository: spatial searches are not supported for facility type ".concat(type));}if(typeof arg5==='number'){return this.trees[type].search(lat,lon,radius,arg5,out,filter);}else {this.trees[type].search(lat,lon,radius,arg5);}}/**
       * Adds a facility to this repository and all other repositories synced with this one. If this repository already
       * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
       * new one.
       * @param fac The facility to add.
       * @throws Error if the facility has an invalid ICAO.
       */add(fac){if(!ICAO.isFacility(fac.icao)){throw new Error("FacilityRepository: invalid facility ICAO ".concat(fac.icao));}this.addToRepo(fac);this.pubSyncEvent({type:FacilityRepositorySyncType.Add,facs:[fac]});}/**
       * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
       * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
       * replaced with the new one.
       * @param facs The facilities to add.
       */addMultiple(facs){this.addMultipleToRepo(facs);this.pubSyncEvent({type:FacilityRepositorySyncType.Add,facs:Array.from(facs)});}/**
       * Removes a facility from this repository and all other repositories synced with this one.
       * @param fac The facility to remove, or the ICAO of the facility to remove.
       * @throws Error if the facility has an invalid ICAO.
       */remove(fac){const icao=typeof fac==='string'?fac:fac.icao;if(!ICAO.isFacility(icao)){throw new Error("FacilityRepository: invalid facility ICAO ".concat(icao));}this.removeFromRepo(icao);this.pubSyncEvent({type:FacilityRepositorySyncType.Remove,facs:[icao]});}/**
       * Removes multiple facilities from this repository and all other repositories synced with this one.
       * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
       */removeMultiple(facs){this.removeMultipleFromRepo(facs);this.pubSyncEvent({type:FacilityRepositorySyncType.Remove,facs:facs.map(fac=>typeof fac==='object'?fac.icao:fac)});}/**
       * Iterates over every facility in this respository with a visitor function.
       * @param fn A visitor function.
       * @param types The types of facilities over which to iterate. Defaults to all facility types.
       */forEach(fn,types){var _a;if(types===undefined){for(const repo of this.repos.values()){repo.forEach(fn);}}else {for(let i=0;i<types.length;i++){(_a=this.repos.get(types[i]))===null||_a===void 0?void 0:_a.forEach(fn);}}}/**
       * Adds a facility to this repository.
       * @param fac The facility to add.
       */addToRepo(fac){const facilityType=ICAO.getFacilityType(fac.icao);let repo=this.repos.get(facilityType);if(repo===undefined){this.repos.set(facilityType,repo=new Map());}const existing=repo.get(fac.icao);repo.set(fac.icao,fac);if(facilityType===FacilityType.USR||facilityType===FacilityType.VIS){if(existing===undefined){this.trees[facilityType].insert(fac);}else {this.trees[facilityType].removeAndInsert([existing],[fac]);}}if(existing===undefined){this.publisher.pub('facility_added',fac,false,false);}else {this.publisher.pub("facility_changed_".concat(fac.icao),fac,false,false);this.publisher.pub('facility_changed',fac,false,false);}}/**
       * Adds multiple facilities to this repository.
       * @param facs The facilities to add.
       */addMultipleToRepo(facs){if(facs.length===0){return;}const addedFacilities=[];const changedFacilitiesRemoved=[];const changedFacilitiesAdded=[];for(let i=0;i<facs.length;i++){const fac=facs[i];const facilityType=ICAO.getFacilityType(fac.icao);let repo=this.repos.get(facilityType);if(repo===undefined){this.repos.set(facilityType,repo=new Map());}const existing=repo.get(fac.icao);repo.set(fac.icao,fac);if(existing===undefined){addedFacilities.push(fac);}else {changedFacilitiesRemoved.push(existing);changedFacilitiesAdded.push(fac);}}const addedUserFacilities=facs.filter(fac=>FacilityUtils.isFacilityType(fac,FacilityType.USR));if(addedUserFacilities.length>0){const removedUserFacilities=changedFacilitiesRemoved.filter(fac=>FacilityUtils.isFacilityType(fac,FacilityType.USR));this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities,addedUserFacilities);}const addedVisFacilities=facs.filter(fac=>FacilityUtils.isFacilityType(fac,FacilityType.VIS));if(addedVisFacilities.length>0){const removedVisFacilities=changedFacilitiesRemoved.filter(fac=>FacilityUtils.isFacilityType(fac,FacilityType.VIS));this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities,addedVisFacilities);}for(let i=0;i<addedFacilities.length;i++){const fac=addedFacilities[i];this.publisher.pub('facility_added',fac,false,false);}for(let i=0;i<changedFacilitiesAdded.length;i++){const fac=changedFacilitiesAdded[i];this.publisher.pub("facility_changed_".concat(fac.icao),fac,false,false);this.publisher.pub('facility_changed',fac,false,false);}}/**
       * Removes a facility from this repository.
       * @param fac The facility to remove, or the ICAO of the facility to remove.
       */removeFromRepo(fac){const icao=typeof fac==='string'?fac:fac.icao;const facilityType=ICAO.getFacilityType(icao);const repo=this.repos.get(ICAO.getFacilityType(icao));if(repo===undefined){return;}const facilityInRepo=repo.get(icao);if(facilityInRepo===undefined){return;}repo.delete(icao);if(facilityType===FacilityType.USR||facilityType===FacilityType.VIS){this.trees[facilityType].remove(facilityInRepo);}this.publisher.pub("facility_removed_".concat(icao),facilityInRepo,false,false);this.publisher.pub('facility_removed',facilityInRepo,false,false);}/**
       * Removes multiple facilities from this repository.
       * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
       */removeMultipleFromRepo(facs){if(facs.length===0){return;}const removedFacilities=[];for(let i=0;i<facs.length;i++){const fac=facs[i];const icao=typeof fac==='string'?fac:fac.icao;const repo=this.repos.get(ICAO.getFacilityType(icao));if(repo===undefined){continue;}const facilityInRepo=repo.get(icao);if(facilityInRepo===undefined){continue;}repo.delete(icao);removedFacilities.push(facilityInRepo);}const removedUserFacilities=removedFacilities.filter(fac=>FacilityUtils.isFacilityType(fac,FacilityType.USR));if(removedUserFacilities.length>0){this.trees[FacilityType.USR].removeAll(removedUserFacilities);}const removedVisFacilities=removedFacilities.filter(fac=>FacilityUtils.isFacilityType(fac,FacilityType.VIS));if(removedVisFacilities.length>0){this.trees[FacilityType.VIS].removeAll(removedVisFacilities);}for(let i=0;i<removedFacilities.length;i++){const removedFac=removedFacilities[i];this.publisher.pub("facility_removed_".concat(removedFac.icao),removedFac,false,false);this.publisher.pub('facility_removed',removedFac,false,false);}}/**
       * Publishes a facility added or removed sync event over the event bus.
       * @param data The event data.
       */pubSyncEvent(data){this.ignoreSync=true;this.publisher.pub(FacilityRepository.SYNC_TOPIC,data,true,false);this.ignoreSync=false;}/**
       * A callback which is called when a sync event occurs.
       * @param data The event data.
       */onSyncEvent(data){if(this.ignoreSync){return;}switch(data.type){case FacilityRepositorySyncType.DumpResponse:// Only accept responses to your own dump requests.
  if(data.uid!==this.lastDumpRequestUid){break;}else {this.lastDumpRequestUid=undefined;}// eslint-disable-next-line no-fallthrough
  case FacilityRepositorySyncType.Add:if(data.facs.length===1){this.addToRepo(data.facs[0]);}else {this.addMultipleToRepo(data.facs);}break;case FacilityRepositorySyncType.Remove:if(data.facs.length===1){this.removeFromRepo(data.facs[0]);}else {this.removeMultipleFromRepo(data.facs);}break;case FacilityRepositorySyncType.DumpRequest:// Don't respond to your own dump requests.
  if(data.uid!==this.lastDumpRequestUid){const facs=[];this.forEach(fac=>facs.push(fac));this.pubSyncEvent({type:FacilityRepositorySyncType.DumpResponse,uid:data.uid,facs});}break;}}/**
       * Gets an instance of FacilityRepository.
       * @param bus The event bus.
       * @returns an instance of FacilityRepository.
       */static getRepository(bus){var _a;return (_a=FacilityRepository.INSTANCE)!==null&&_a!==void 0?_a:FacilityRepository.INSTANCE=new FacilityRepository(bus);}}FacilityRepository.SYNC_TOPIC='facilityrepo_sync';FacilityRepository.treeKeyFunc=(fac,out)=>{return GeoPoint.sphericalToCartesian(fac,out);};/**
   * Possible types of hold entries
   */var HoldEntryType;(function(HoldEntryType){HoldEntryType[HoldEntryType["Direct"]=0]="Direct";HoldEntryType[HoldEntryType["Teardrop"]=1]="Teardrop";HoldEntryType[HoldEntryType["Parallel"]=2]="Parallel";HoldEntryType[HoldEntryType["None"]=3]="None";})(HoldEntryType||(HoldEntryType={}));var HoldMaxSpeedRule;(function(HoldMaxSpeedRule){HoldMaxSpeedRule[HoldMaxSpeedRule["Faa"]=0]="Faa";HoldMaxSpeedRule[HoldMaxSpeedRule["Icao"]=1]="Icao";})(HoldMaxSpeedRule||(HoldMaxSpeedRule={}));/**
   * Utility methods for working with Subscribables.
   */class SubscribableUtils{/**
       * Checks if a query is a subscribable.
       * @param query A query.
       * @returns Whether the query is a subscribable.
       */static isSubscribable(query){return typeof query==='object'&&query!==null&&query.isSubscribable===true;}/**
       * Checks if a query is a mutable subscribable.
       * @param query A query.
       * @returns Whether the query is a mutable subscribable.
       */static isMutableSubscribable(query){return typeof query==='object'&&query!==null&&query.isMutableSubscribable===true;}/**
       * Converts a value to a subscribable.
       *
       * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
       * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
       * returned.
       * @param value The value to convert to a subscribable.
       * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
       * subscribable.
       * @returns A subscribable.
       */static toSubscribable(value,excludeSubscribables){if(excludeSubscribables&&SubscribableUtils.isSubscribable(value)){return value;}else {return Subject.create(value);}}}/**
   * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
   * `NaN`.
   * @param a The first number to compare.
   * @param b The second number to compare.
   * @returns Whether the two numbers are strictly equal or both `NaN`.
   */SubscribableUtils.NUMERIC_NAN_EQUALITY=(a,b)=>a===b||isNaN(a)&&isNaN(b);/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**
   * A type map of search type to concrete facility loader query type.
   */new Map([[FacilitySearchType.Airport,FacilityType.Airport],[FacilitySearchType.Intersection,FacilityType.Intersection],[FacilitySearchType.Vor,FacilityType.VOR],[FacilitySearchType.Ndb,FacilityType.NDB],[FacilitySearchType.User,FacilityType.USR]]);/**
   * A wrapper for a {@link NearestSearchSession} that automatically adjusts the number of
   * search results requested from the sim to minimize search load while still attempting to
   * provide the total number of results needed by the user.
   */class AdaptiveNearestSubscription extends AbstractSubscribableArray{/**
       * Creates an instance of AdaptiveNearestSubscription.
       * @param innerSubscription A {@link NearestSubscription} to use as our inner search.
       * @param absoluteMaxItems The maximum number of results to request in any search.
       */constructor(innerSubscription,absoluteMaxItems){super();this.innerSubscription=innerSubscription;this.sortFunc=(a,b)=>this.pos.distance(a)-this.pos.distance(b);/** The array that holds the results of our latest search. */this.facilities=[];/** The number of items we are requesting from the inner search to meet current demands. */this.derivedMaxItems=0;/** Whether we have a search in progress already. */this.searchInProgress=false;/** A reusable GeoPoint for sorting by distance. */this.pos=new GeoPoint(0,0);this.diffMap=new Map();this.updatePromiseResolves=[];this.absoluteMaxItems=SubscribableUtils.toSubscribable(absoluteMaxItems,true);}/** @inheritdoc */get length(){return this.facilities.length;}/** @inheritdoc */getArray(){return this.facilities;}/** @inheritdoc */get started(){return this.innerSubscription.started;}/** @inheritdoc */awaitStart(){return this.innerSubscription.awaitStart();}/** @inheritdoc */start(){return this.innerSubscription.start();}/** @inheritdoc */update(lat,lon,radius,maxItems){return new Promise(resolve=>{this.updatePromiseResolves.push(resolve);if(this.searchInProgress){return;}this.doUpdate(lat,lon,radius,maxItems);});}/**
       * Executes an update of the nearest search subscription.
       * @param lat The latitude of the current search position.
       * @param lon The longitude of the current search position.
       * @param radius The radius of the search, in meters.
       * @param maxItems The maximum number of items to return in the search.
       */async doUpdate(lat,lon,radius,maxItems){this.searchInProgress=true;this.pos.set(lat,lon);maxItems=Math.max(0,maxItems);if(maxItems>this.derivedMaxItems){this.derivedMaxItems=maxItems;}// When the subscription updates, any changes from airports added or removed cause
  // onSourceChanged below to trigger.   That will update our facilites store, because
  // it means the airport is no longer in the raw search data.
  await this.innerSubscription.update(lat,lon,radius,this.derivedMaxItems);if(this.innerSubscription.length>maxItems){// We have more returned facilities in our search than the user has asked for.
  // Begin a ramp-down of our search size. Ramp down is less aggressive than
  // ramp up to avoid flapping between the two states.
  this.derivedMaxItems=Math.max(Math.round(this.derivedMaxItems-this.derivedMaxItems*AdaptiveNearestSubscription.RAMP_DOWN_FACTOR),maxItems);}else {// We have either exactly enough or too few facilities.  If we have too few, ramp
  // up our search size until we either have enough or hit the maximum allowed search
  // quantity.
  const absoluteMaxItems=this.absoluteMaxItems.get();while(this.innerSubscription.length<maxItems&&this.derivedMaxItems<absoluteMaxItems){this.derivedMaxItems=Math.min(Math.round(this.derivedMaxItems*AdaptiveNearestSubscription.RAMP_UP_FACTOR),absoluteMaxItems);await this.innerSubscription.update(lat,lon,radius,this.derivedMaxItems);}}if(this.innerSubscription.length>maxItems){if(maxItems>1){// Filter out the farthest results until we have exactly as many results as the user has asked for.
  const sorted=Array.from(this.innerSubscription.getArray()).sort(this.sortFunc);sorted.length=maxItems;this.diffAndNotify(sorted);}else if(maxItems===1){this.diffAndNotify([this.findNearest(this.innerSubscription.getArray())]);}else {this.diffAndNotify(AdaptiveNearestSubscription.EMPTY_ARRAY);}}else {this.diffAndNotify(this.innerSubscription.getArray());}this.searchInProgress=false;this.updatePromiseResolves.forEach(resolve=>{resolve();});this.updatePromiseResolves.length=0;}/**
       * Finds the nearest facility in an array.
       * @param array A non-empty array of facilities.
       * @returns The nearest facility in the specified array.
       */findNearest(array){let nearest=array[0];let nearestDistance=this.pos.distance(nearest);for(let i=1;i<array.length;i++){const fac=array[i];const distance=this.pos.distance(fac);if(distance<nearestDistance){nearest=fac;nearestDistance=distance;}}return nearest;}/**
       * Diffs a new facility array against this subscription's current facility array, makes the necessary changes to
       * the current facility array so that it contains the same facilities as the new one, and notifies subscribers of the
       * changes.
       * @param newArray A new facility array.
       */diffAndNotify(newArray){if(this.facilities.length===0&&newArray.length===0){// Old and new arrays are both empty. Nothing to do.
  return;}if(newArray.length===0){// New array is empty. Clear the old array.
  this.facilities.length=0;this.notify(0,SubscribableArrayEventType.Cleared);return;}if(this.facilities.length===0){// Old array is empty. Add every item from the new array in order.
  for(let i=0;i<newArray.length;i++){this.facilities[i]=newArray[i];}this.facilities.length=newArray.length;this.notify(0,SubscribableArrayEventType.Added,this.facilities);return;}// Remove every item from the old array that is not in the new array.
  for(let i=0;i<newArray.length;i++){this.diffMap.set(newArray[i].icao,newArray[i]);}for(let i=this.facilities.length-1;i>=0;i--){const old=this.facilities[i];if(this.diffMap.has(old.icao)){this.diffMap.delete(old.icao);}else {this.facilities.splice(i,1);this.notify(i,SubscribableArrayEventType.Removed,old);}}// Add every item from the new array that is not in the old array (these items are now contained in diffMap).
  for(const toAdd of this.diffMap.values()){this.facilities.push(toAdd);this.notify(this.facilities.length-1,SubscribableArrayEventType.Added,toAdd);}this.diffMap.clear();}}AdaptiveNearestSubscription.RAMP_UP_FACTOR=1.33;AdaptiveNearestSubscription.RAMP_DOWN_FACTOR=0.1;AdaptiveNearestSubscription.EMPTY_ARRAY=[];[new GeoCircle(new Float64Array(3),0)];new BinaryHeap((a,b)=>b.distanceToFarthestVector-a.distanceToFarthestVector);/**
   * A task queue backed by an array.
   */class ArrayTaskQueue{/**
       * Constructor.
       * @param tasks The array of tasks in this queue.
       */constructor(tasks){this.tasks=tasks;this.head=0;}// eslint-disable-next-line jsdoc/require-jsdoc
  hasNext(){return this.head<this.tasks.length;}// eslint-disable-next-line jsdoc/require-jsdoc
  next(){return this.tasks[this.head++];}}/**
   * A process which dispatches tasks in a task queue potentially over multiple frames.
   */class ThrottledTaskQueueProcess{/**
       * Constructor.
       * @param queue The queue to process.
       * @param handler A handler which defines the behavior of this process.
       */constructor(queue,handler){this.queue=queue;this.handler=handler;this._hasStarted=false;this._hasEnded=false;this._shouldAbort=false;}/**
       * Checks whether this process has been started.
       * @returns whether this process has been started.
       */hasStarted(){return this._hasStarted;}/**
       * Checks whether this process has ended.
       * @returns whether this process has ended.
       */hasEnded(){return this._hasEnded;}/**
       * Starts this process.
       */start(){this._hasStarted=true;this.processQueue(0);}/**
       * Processes the queue.
       * @param elapsedFrameCount The number of frames elapsed since queue processing started.
       */processQueue(elapsedFrameCount){let dispatchCount=0;const t0=performance.now();while(!this._shouldAbort&&this.queue.hasNext()){if(this.handler.canContinue(elapsedFrameCount,dispatchCount,performance.now()-t0)){const task=this.queue.next();task();dispatchCount++;}else {break;}}if(this._shouldAbort){return;}if(!this.queue.hasNext()){this.handler.onFinished(elapsedFrameCount);this._hasEnded=true;}else {this.handler.onPaused(elapsedFrameCount);requestAnimationFrame(this.processQueue.bind(this,elapsedFrameCount+1));}}/**
       * Aborts this process. Has no effect if the process has not been started or if it has already ended.
       */abort(){if(this._hasStarted&&!this._hasEnded){this.handler.onAborted();this._shouldAbort=true;this._hasEnded=true;}}}/**
   * A nearest search session for boundaries (airspaces) in the form of LodBoundary objects.
   */class NearestLodBoundarySearchSession{/**
       * Constructor.
       * @param cache The boundary cache this search session uses.
       * @param session The nearest boundary facility search session this search session uses.
       * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
       * milliseconds.
       */constructor(cache,session,frameBudget){this.cache=cache;this.session=session;this.frameBudget=frameBudget;}/**
       * Searches for the nearest boundaries around a specified location.
       * @param lat The latitude of the search center, in degrees.
       * @param lon The longitude of the search center, in degrees.
       * @param radius The radius of the search, in meters.
       * @param maxItems The maximum number of items for which to search.
       * @returns The nearest search results.
       */async searchNearest(lat,lon,radius,maxItems){const facilityResults=await this.session.searchNearest(lat,lon,radius,maxItems);const results={added:[],removed:facilityResults.removed};const tasks=facilityResults.added.map((fac,index)=>()=>{results.added[index]=this.cache.get(fac);});await new Promise(resolve=>{const taskQueue=new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks),new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget,resolve));taskQueue.start();});return results;}/**
       * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
       * session.
       * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
       * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
       */setFilter(classMask){this.session.setBoundaryFilter(classMask);}}/**
   * A throttled task queue handler for retrieving and creating new LodBoundary objects in response to a nearest search.
   */class NearestLodBoundarySearchTaskQueueHandler{/**
       * Constructor.
       * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
       * milliseconds.
       * @param resolve The Promise resolve function this handler will call when the task queue is finished.
       */constructor(frameBudget,resolve){this.frameBudget=frameBudget;this.resolve=resolve;}/** @inheritdoc */onStarted(){// noop
  }/** @inheritdoc */canContinue(elapsedFrameCount,dispatchedTaskCount,timeElapsed){return timeElapsed<this.frameBudget;}/** @inheritdoc */onPaused(){// noop
  }/** @inheritdoc */onFinished(){this.resolve();}/** @inheritdoc */onAborted(){// noop
  }}/**
   * The transition type to which a flight path vector belongs.
   */var FlightPathVectorFlags;(function(FlightPathVectorFlags){FlightPathVectorFlags[FlightPathVectorFlags["None"]=0]="None";/** A turn to a specific course. */FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"]=1]="TurnToCourse";/** An arcing turn to a specific point. */FlightPathVectorFlags[FlightPathVectorFlags["Arc"]=2]="Arc";/** A direct course to a specific point. */FlightPathVectorFlags[FlightPathVectorFlags["Direct"]=4]="Direct";/** A path to intercept a specific course. */FlightPathVectorFlags[FlightPathVectorFlags["InterceptCourse"]=8]="InterceptCourse";/** Inbound leg of a hold. */FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"]=16]="HoldInboundLeg";/** Outbound leg of a hold. */FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"]=32]="HoldOutboundLeg";/** A direct hold entry. */FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"]=64]="HoldDirectEntry";/** A teardrop hold entry. */FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"]=128]="HoldTeardropEntry";/** A parallel hold entry. */FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"]=256]="HoldParallelEntry";/** A course reversal. */FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"]=512]="CourseReversal";/** A turn from one leg to another. */FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"]=1024]="LegToLegTurn";/** An anticipated turn from one leg to another. */FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"]=2048]="AnticipatedTurn";/** A fallback path. */FlightPathVectorFlags[FlightPathVectorFlags["Fallback"]=4096]="Fallback";})(FlightPathVectorFlags||(FlightPathVectorFlags={}));/**
   * A prototype for signalling application-specific type metadata for plan segments.
   */var FlightPlanSegmentType;(function(FlightPlanSegmentType){FlightPlanSegmentType["Origin"]="Origin";FlightPlanSegmentType["Departure"]="Departure";FlightPlanSegmentType["Enroute"]="Enroute";FlightPlanSegmentType["Arrival"]="Arrival";FlightPlanSegmentType["Approach"]="Approach";FlightPlanSegmentType["Destination"]="Destination";FlightPlanSegmentType["MissedApproach"]="MissedApproach";FlightPlanSegmentType["RandomDirectTo"]="RandomDirectTo";})(FlightPlanSegmentType||(FlightPlanSegmentType={}));/**
   * A segment of a flight plan.
   */class FlightPlanSegment{/**
       * Creates a new FlightPlanSegment.
       * @param segmentIndex The index of the segment within the flight plan.
       * @param offset The leg offset within the original flight plan that
       * the segment starts at.
       * @param legs The legs in the flight plan segment.
       * @param segmentType The type of segment this is.
       * @param airway The airway associated with this segment, if any.
       */constructor(segmentIndex,offset,legs){let segmentType=arguments.length>3&&arguments[3]!==undefined?arguments[3]:FlightPlanSegmentType.Enroute;let airway=arguments.length>4?arguments[4]:undefined;this.segmentIndex=segmentIndex;this.offset=offset;this.legs=legs;this.segmentType=segmentType;this.airway=airway;}}/** An empty flight plan segment. */FlightPlanSegment.Empty=new FlightPlanSegment(-1,-1,[]);/**
   * Bitflags describing a leg definition.
   */var LegDefinitionFlags;(function(LegDefinitionFlags){LegDefinitionFlags[LegDefinitionFlags["None"]=0]="None";LegDefinitionFlags[LegDefinitionFlags["DirectTo"]=1]="DirectTo";LegDefinitionFlags[LegDefinitionFlags["MissedApproach"]=2]="MissedApproach";LegDefinitionFlags[LegDefinitionFlags["Obs"]=4]="Obs";LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"]=8]="VectorsToFinal";LegDefinitionFlags[LegDefinitionFlags["VectorsToFinalFaf"]=16]="VectorsToFinalFaf";})(LegDefinitionFlags||(LegDefinitionFlags={}));/**
   * Vertical flight phase.
   */var VerticalFlightPhase;(function(VerticalFlightPhase){VerticalFlightPhase["Climb"]="Climb";VerticalFlightPhase["Descent"]="Descent";})(VerticalFlightPhase||(VerticalFlightPhase={}));var SpeedUnit;(function(SpeedUnit){SpeedUnit[SpeedUnit["IAS"]=0]="IAS";SpeedUnit[SpeedUnit["MACH"]=1]="MACH";})(SpeedUnit||(SpeedUnit={}));/** Types of speed restrictions on legs. */var SpeedRestrictionType;(function(SpeedRestrictionType){SpeedRestrictionType[SpeedRestrictionType["Unused"]=0]="Unused";SpeedRestrictionType[SpeedRestrictionType["At"]=1]="At";SpeedRestrictionType[SpeedRestrictionType["AtOrAbove"]=2]="AtOrAbove";SpeedRestrictionType[SpeedRestrictionType["AtOrBelow"]=3]="AtOrBelow";SpeedRestrictionType[SpeedRestrictionType["Between"]=4]="Between";})(SpeedRestrictionType||(SpeedRestrictionType={}));/**
   * Utility class for working with flight path calculations.
   */class FlightPathUtils{/**
       * Creates an empty arc vector.
       * @returns An empty arc vector.
       */static createEmptyCircleVector(){return {vectorType:'circle',flags:FlightPathVectorFlags.None,radius:0,centerX:1,centerY:0,centerZ:0,startLat:0,startLon:0,endLat:0,endLon:0,distance:0};}/**
       * Sets the parameters of a circle vector.
       * @param vector The circle vector to set.
       * @param circle The GeoCircle defining the vector's path.
       * @param start The start of the vector.
       * @param end The end of the vector.
       * @param flags The flags to set on the vector.
       * @returns The circle vector, after its parameters have been set.
       */static setCircleVector(vector,circle,start,end,flags){vector.flags=flags;vector.radius=circle.radius;vector.centerX=circle.center[0];vector.centerY=circle.center[1];vector.centerZ=circle.center[2];vector.distance=UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start,end,Math.PI),UnitType.METER);start instanceof Float64Array&&(start=FlightPathUtils.geoPointCache[0].setFromCartesian(start));end instanceof Float64Array&&(end=FlightPathUtils.geoPointCache[1].setFromCartesian(end));vector.startLat=start.lat;vector.startLon=start.lon;vector.endLat=end.lat;vector.endLon=end.lon;return vector;}/**
       * Checks whether a circle vector describes a great-circle path.
       * @param vector A flight path circle vector.
       * @returns Whether the vector describes a great-circle path.
       */static isVectorGreatCircle(vector){return vector.radius===Math.PI/2;}/**
       * Sets the parameters of a GeoCircle from a flight path circle vector.
       * @param vector A flight path circle vector.
       * @param out The GeoCircle to set.
       * @returns The GeoCircle, after its parameters have been set.
       */static setGeoCircleFromVector(vector,out){return out.set(Vec3Math.set(vector.centerX,vector.centerY,vector.centerZ,FlightPathUtils.vec3Cache[0]),vector.radius);}/**
       * Gets the direction of a turn described by a flight path circle vector.
       * @param vector The flight path circle vector describing the turn.
       * @returns The direction of the turn described by the flight path circle vector.
       */static getVectorTurnDirection(vector){return vector.radius>MathUtils.HALF_PI?'right':'left';}/**
       * Gets the radius of a turn described by a flight path circle vector.
       * @param vector The flight path circle vector describing the turn.
       * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
       */static getVectorTurnRadius(vector){return Math.min(vector.radius,Math.PI-vector.radius);}/**
       * Gets the initial true course bearing of a flight path vector.
       * @param vector A flight path vector.
       * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
       */static getVectorInitialCourse(vector){return FlightPathUtils.setGeoCircleFromVector(vector,FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat,vector.startLon),Math.PI);}/**
       * Gets the final true course bearing of a flight path vector.
       * @param vector A flight path vector.
       * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
       */static getVectorFinalCourse(vector){return FlightPathUtils.setGeoCircleFromVector(vector,FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat,vector.endLon),Math.PI);}/**
       * Gets the true course for a flight plan leg.
       * @param leg A flight plan leg.
       * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
       * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
       * @returns The true course for the specified flight plan leg.
       */static getLegTrueCourse(leg,point,magVarFacility){if(leg.trueDegrees){return leg.course;}const magVar=magVarFacility?-magVarFacility.magneticVariation// The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
  :Facilities.getMagVar(point.lat,point.lon);return NavMath.normalizeHeading(leg.course+magVar);}/**
       * Gets the final position of a calculated leg.
       * @param legCalc A set of leg calculations.
       * @param out The GeoPoint object to which to write the result.
       * @returns The final position of the leg, or `undefined` if one could not be obtained.
       */static getLegFinalPosition(legCalc,out){if(legCalc.endLat!==undefined&&legCalc.endLon!==undefined){return out.set(legCalc.endLat,legCalc.endLon);}return undefined;}/**
       * Gets the final true course of a calculated leg.
       * @param legCalc A set of leg calculations.
       * @returns The final true course of the leg, or `undefined` if one could not be obtained.
       */static getLegFinalCourse(legCalc){if(legCalc.flightPath.length>0){const vector=legCalc.flightPath[legCalc.flightPath.length-1];return this.getVectorFinalCourse(vector);}return undefined;}/**
       * Gets the circle describing the path of a turn.
       * @param center The center of the turn.
       * @param radius The radius of the turn, in great-arc radians.
       * @param turnDirection The direction of the turn.
       * @param out A GeoCircle object to which to write the result.
       * @returns The circle describing the path of the turn.
       */static getTurnCircle(center,radius,turnDirection,out){out.set(center,radius);if(turnDirection==='right'){out.reverse();}return out;}/**
       * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
       * @param circle The turn circle to reverse.
       * @param out A GeoCircle object to which to write the result.
       * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
       */static reverseTurnCircle(circle,out){return out.set(Vec3Math.multScalar(circle.center,-1,FlightPathUtils.vec3Cache[0]),Math.PI-circle.radius);}/**
       * Gets the direction of a turn described by a circle.
       * @param circle The geo circle describing the turn.
       * @returns The direction of the turn described by the circle.
       */static getTurnDirectionFromCircle(circle){return circle.radius>MathUtils.HALF_PI?'right':'left';}/**
       * Gets the radius of a turn described by a circle.
       * @param circle The geo circle describing the turn.
       * @returns The radius of the turn described by the circle, in great-arc radians.
       */static getTurnRadiusFromCircle(circle){return Math.min(circle.radius,Math.PI-circle.radius);}/**
       * Gets the center of a turn described by a circle.
       * @param circle The geo circle describing the turn.
       * @param out A GeoPoint or 3D vector object to which to write the result.
       * @returns The center of a turn described by the circle.
       */static getTurnCenterFromCircle(circle,out){return circle.radius>MathUtils.HALF_PI?out instanceof Float64Array?Vec3Math.multScalar(circle.center,-1,out):out.setFromCartesian(-circle.center[0],-circle.center[1],-circle.center[2]):out instanceof Float64Array?Vec3Math.copy(circle.center,out):out.setFromCartesian(circle.center);}/**
       * Calculates and returns a circle describing a turn starting from a path at a specified point.
       * @param start The starting point of the turn.
       * @param path The circle describing the path from which the turn starts.
       * @param turnRadius The radius of the turn, in great-arc radians.
       * @param turnDirection The direction of the turn.
       * @param out A GeoCircle object to which to write the result.
       * @returns The circle describing the path of the specified turn.
       */static getTurnCircleStartingFromPath(start,path,turnRadius,turnDirection,out){if(!(start instanceof Float64Array)){start=GeoPoint.sphericalToCartesian(start,FlightPathUtils.vec3Cache[0]);}const radius=turnDirection==='left'?turnRadius:Math.PI-turnRadius;const turnStartToCenterNormal=Vec3Math.cross(start,path.center,FlightPathUtils.vec3Cache[1]);const turnStartToCenterPath=FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal,MathUtils.HALF_PI);const turnCenter=turnStartToCenterPath.offsetDistanceAlong(start,radius,FlightPathUtils.vec3Cache[1],Math.PI);return out.set(turnCenter,radius);}/**
       * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
       * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
       * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
       * circle that is diametrically opposed to the midpoint of the arc.
       * @param circle The arc's parent circle.
       * @param start The start point of the arc.
       * @param end The end point of the arc.
       * @param pos The query point.
       * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
       * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
       */static getAlongArcSignedDistance(circle,start,end,pos){let tolerance=arguments.length>4&&arguments[4]!==undefined?arguments[4]:GeoCircle.ANGULAR_TOLERANCE;const posAngularDistance=circle.angleAlong(start,pos,Math.PI);if(Math.min(posAngularDistance,MathUtils.TWO_PI-posAngularDistance)<=tolerance){return 0;}const endAngularDistance=circle.angleAlong(start,end,Math.PI);return circle.arcLength((posAngularDistance-endAngularDistance/2+Math.PI)%MathUtils.TWO_PI-Math.PI+endAngularDistance/2);}/**
       * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
       * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
       * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
       * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
       * diametrically opposed to the midpoint of the arc.
       * @param circle The arc's parent circle.
       * @param start The start point of the arc.
       * @param end The end point of the arc.
       * @param pos The query point.
       * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
       * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
       * @returns The normalized distance along the arc from the start point to the query point.
       */static getAlongArcNormalizedDistance(circle,start,end,pos){let tolerance=arguments.length>4&&arguments[4]!==undefined?arguments[4]:GeoCircle.ANGULAR_TOLERANCE;const posAngularDistance=circle.angleAlong(start,pos,Math.PI);if(Math.min(posAngularDistance,MathUtils.TWO_PI-posAngularDistance)<=tolerance){return 0;}const endAngularDistance=circle.angleAlong(start,end,Math.PI);if(Math.min(endAngularDistance,MathUtils.TWO_PI-endAngularDistance)<=tolerance){return posAngularDistance>=Math.PI?-Infinity:Infinity;}return ((posAngularDistance-endAngularDistance/2+Math.PI)%MathUtils.TWO_PI-Math.PI)/endAngularDistance+0.5;}// eslint-disable-next-line jsdoc/require-jsdoc
  static isPointAlongArc(circle,start,end,pos){let inclusive=arguments.length>4&&arguments[4]!==undefined?arguments[4]:true;let tolerance=arguments.length>5&&arguments[5]!==undefined?arguments[5]:GeoCircle.ANGULAR_TOLERANCE;const angularTolerance=circle.angularWidth(tolerance);if(typeof end!=='number'){end=circle.angleAlong(start,end,Math.PI,angularTolerance);}if(inclusive&&Math.abs(end)>=MathUtils.TWO_PI-angularTolerance){return true;}const angle=circle.angleAlong(start,pos,Math.PI);if(inclusive&&angle>=MathUtils.TWO_PI-angularTolerance){return true;}const signedDiff=(angle-end)*(end>=0?1:-1);return inclusive?signedDiff<=angularTolerance:signedDiff<-angularTolerance;}// eslint-disable-next-line jsdoc/require-jsdoc
  static projectVelocityToCircle(speed,position,direction,projectTo){if(projectTo.radius<=GeoCircle.ANGULAR_TOLERANCE){return NaN;}if(speed===0){return 0;}if(!(position instanceof Float64Array)){position=GeoPoint.sphericalToCartesian(position,FlightPathUtils.vec3Cache[0]);}const velocityPath=typeof direction==='number'?FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position,direction):direction.isGreatCircle()?direction:FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position,FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center,position).center);const sign=velocityPath.encircles(projectTo.center)?1:-1;const velocityPathNormal=Vec3Math.copy(velocityPath.center,FlightPathUtils.vec3Cache[1]);const projectedRadialNormal=FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center,position).center;const dot=Vec3Math.dot(projectedRadialNormal,velocityPathNormal);const sinTheta=Math.sqrt(1-MathUtils.clamp(dot*dot,0,1));return speed*sinTheta*sign;}/**
       * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
       * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
       * while following the flight path defined by the vectors in the `flightPath` array.
       * @param legCalc A set of flight plan leg calculations.
       * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
       */static resolveIngressToEgress(legCalc){var _a,_b,_c,_d,_e,_f;var _g,_h,_j,_k,_l,_m;const vectors=legCalc.ingressToEgress;let vectorIndex=0;let flightPathVectorIndex=Math.max(0,legCalc.ingressJoinIndex);const lastIngressVector=legCalc.ingress[legCalc.ingress.length-1];const ingressJoinVector=legCalc.flightPath[legCalc.ingressJoinIndex];const firstEgressVector=legCalc.egress[0];const egressJoinVector=legCalc.flightPath[legCalc.egressJoinIndex];if(lastIngressVector&&ingressJoinVector){// Check if the last ingress vector joins the base flight path before the end of a vector. If so, we need to
  // replace the base flight path vector the ingress joins with a shortened version starting where the ingress
  // ends.
  const ingressEnd=FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat,lastIngressVector.endLon);const ingressJoinVectorStart=FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat,ingressJoinVector.startLon);const ingressJoinVectorEnd=legCalc.ingressJoinIndex===legCalc.egressJoinIndex&&firstEgressVector?FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat,firstEgressVector.startLon):FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat,ingressJoinVector.endLon);const ingressJoinVectorCircle=FlightPathUtils.setGeoCircleFromVector(ingressJoinVector,FlightPathUtils.geoCircleCache[0]);const ingressEndAlongVectorDistance=FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle,ingressJoinVectorStart,ingressJoinVectorEnd,ingressEnd);const normalizedTolerance=GeoCircle.ANGULAR_TOLERANCE/UnitType.METER.convertTo(ingressJoinVector.distance,UnitType.GA_RADIAN);if(ingressEndAlongVectorDistance<1-normalizedTolerance){// Ingress joins the base flight path before the end of the joined vector.
  if(ingressEndAlongVectorDistance>normalizedTolerance){// Ingress joins the base flight path after the start of the joined vector.
  ingressJoinVectorCircle.closest(ingressEnd,ingressEnd);FlightPathUtils.setCircleVector((_a=vectors[_g=vectorIndex++])!==null&&_a!==void 0?_a:vectors[_g]=FlightPathUtils.createEmptyCircleVector(),ingressJoinVectorCircle,ingressEnd,ingressJoinVectorEnd,ingressJoinVector.flags);}else {// Ingress joins the base flight path at or before the start of the joined vector.
  Object.assign((_b=vectors[_h=vectorIndex++])!==null&&_b!==void 0?_b:vectors[_h]=FlightPathUtils.createEmptyCircleVector(),ingressJoinVector);}}flightPathVectorIndex++;}const end=Math.min(legCalc.flightPath.length,legCalc.egressJoinIndex<0?Infinity:legCalc.egressJoinIndex);for(let i=flightPathVectorIndex;i<end;i++){Object.assign((_c=vectors[_j=vectorIndex++])!==null&&_c!==void 0?_c:vectors[_j]=FlightPathUtils.createEmptyCircleVector(),legCalc.flightPath[i]);flightPathVectorIndex++;}if(flightPathVectorIndex===legCalc.egressJoinIndex&&egressJoinVector){if(firstEgressVector){// Check if the first egress vector joins the base flight path in after the start of a vector. If so, we need
  // to replace the base flight path vector the egress joins with a shortened version starting where the egress
  // starts.
  const egressStart=FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat,firstEgressVector.startLon);const egressJoinVectorStart=FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat,egressJoinVector.startLon);const egressJoinVectorEnd=FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat,egressJoinVector.endLon);const egressJoinVectorCircle=FlightPathUtils.setGeoCircleFromVector(egressJoinVector,FlightPathUtils.geoCircleCache[0]);const egressStartAlongVectorDistance=FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle,egressJoinVectorStart,egressJoinVectorEnd,egressStart);const normalizedTolerance=GeoCircle.ANGULAR_TOLERANCE/UnitType.METER.convertTo(egressJoinVector.distance,UnitType.GA_RADIAN);if(egressStartAlongVectorDistance>normalizedTolerance){// Egress joins the base flight path after the start of the joined vector.
  if(egressStartAlongVectorDistance<1-normalizedTolerance){// Egress joins the base flight path before the end of the joined vector.
  egressJoinVectorCircle.closest(egressStart,egressStart);FlightPathUtils.setCircleVector((_d=vectors[_k=vectorIndex++])!==null&&_d!==void 0?_d:vectors[_k]=FlightPathUtils.createEmptyCircleVector(),egressJoinVectorCircle,egressJoinVectorStart,egressStart,egressJoinVector.flags);}else {// Egress joins the base flight path at or after the end of the joined vector.
  Object.assign((_e=vectors[_l=vectorIndex++])!==null&&_e!==void 0?_e:vectors[_l]=FlightPathUtils.createEmptyCircleVector(),egressJoinVector);}}}else {// There is no egress, but there is a base flight path vector flagged as the vector with which the egress
  // joins. This is technically an invalid state, but we can easily just treat this as a regular "no-egress"
  // case and copy the entire egress join vector into the resolved vectors array.
  Object.assign((_f=vectors[_m=vectorIndex++])!==null&&_f!==void 0?_f:vectors[_m]=FlightPathUtils.createEmptyCircleVector(),egressJoinVector);}}vectors.length=vectorIndex;return legCalc;}}FlightPathUtils.vec3Cache=[new Float64Array(3),new Float64Array(3)];FlightPathUtils.geoPointCache=[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)];FlightPathUtils.geoCircleCache=[new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0)];[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoCircle(new Float64Array(3),0)];[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoCircle(new Float64Array(3),0)];[new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[LegType.AF,LegType.RF,LegType.PI];[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoPoint(0,0),new GeoPoint(0,0)];({geoPoint:[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)],geoCircle:[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)]});/** Array of "to altitude" leg types. */[LegType.CA,LegType.FA,LegType.VA];/** Array of "heading to" leg types. */[LegType.VA,LegType.VD,LegType.VI,LegType.VM,LegType.VR];/** Array of "hold" leg types. */[LegType.HA,LegType.HF,LegType.HM];/** Array of manual termination leg types that end in a discontinuity. */[LegType.FM,LegType.VM];/** Array of discontinuity leg types. */[LegType.Discontinuity,LegType.ThruDiscontinuity];/**
   * Modes for calculating airplane speed for use in flight path calculations.
   */var FlightPathAirplaneSpeedMode;(function(FlightPathAirplaneSpeedMode){/** The default airplane speed is always used. */FlightPathAirplaneSpeedMode["Default"]="Default";/** Ground speed is used. */FlightPathAirplaneSpeedMode["GroundSpeed"]="GroundSpeed";/** True airspeed is used. */FlightPathAirplaneSpeedMode["TrueAirspeed"]="TrueAirspeed";/** True airspeed plus wind speed is used. */FlightPathAirplaneSpeedMode["TrueAirspeedPlusWind"]="TrueAirspeedPlusWind";})(FlightPathAirplaneSpeedMode||(FlightPathAirplaneSpeedMode={}));var LegEventType;(function(LegEventType){LegEventType["Added"]="Added";LegEventType["Removed"]="Removed";LegEventType["Changed"]="Changed";})(LegEventType||(LegEventType={}));var SegmentEventType;(function(SegmentEventType){SegmentEventType["Added"]="Added";SegmentEventType["Removed"]="Removed";SegmentEventType["Changed"]="Changed";SegmentEventType["Inserted"]="Inserted";})(SegmentEventType||(SegmentEventType={}));var ActiveLegType;(function(ActiveLegType){ActiveLegType["Lateral"]="Lateral";ActiveLegType["Vertical"]="Vertical";ActiveLegType["Calculating"]="Calculating";})(ActiveLegType||(ActiveLegType={}));var OriginDestChangeType;(function(OriginDestChangeType){OriginDestChangeType["OriginAdded"]="OriginAdded";OriginDestChangeType["OriginRemoved"]="OriginRemoved";OriginDestChangeType["DestinationAdded"]="DestinationAdded";OriginDestChangeType["DestinationRemoved"]="DestinationRemoved";})(OriginDestChangeType||(OriginDestChangeType={}));/**
   * An implementation of {@link SubEventInterface}.
   */class SubEvent{constructor(){this.subs=[];this.notifyDepth=0;this.onSubDestroyedFunc=this.onSubDestroyed.bind(this);}/** @inheritdoc */on(handler){let paused=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;const sub=new HandlerSubscription(handler,undefined,this.onSubDestroyedFunc);this.subs.push(sub);if(paused){sub.pause();}return sub;}/** @inheritdoc */off(handler){const toDestroy=this.subs.find(sub=>sub.handler===handler);toDestroy===null||toDestroy===void 0?void 0:toDestroy.destroy();}/** @inheritdoc */clear(){this.notifyDepth++;for(let i=0;i<this.subs.length;i++){this.subs[i].destroy();}this.notifyDepth--;if(this.notifyDepth===0){this.subs.length=0;}}/** @inheritdoc */notify(sender,data){let needCleanUpSubs=false;this.notifyDepth++;const subLen=this.subs.length;for(let i=0;i<subLen;i++){try{const sub=this.subs[i];if(sub.isAlive&&!sub.isPaused){sub.handler(sender,data);}needCleanUpSubs||(needCleanUpSubs=!sub.isAlive);}catch(error){console.error("SubEvent: error in handler: ".concat(error));if(error instanceof Error){console.error(error.stack);}}}this.notifyDepth--;if(needCleanUpSubs&&this.notifyDepth===0){this.subs=this.subs.filter(sub=>sub.isAlive);}}/**
       * Responds to when a subscription to this event is destroyed.
       * @param sub The destroyed subscription.
       */onSubDestroyed(sub){// If we are not in the middle of a notify operation, remove the subscription.
  // Otherwise, do nothing and let the post-notify clean-up code handle it.
  if(this.notifyDepth===0){this.subs.splice(this.subs.indexOf(sub),1);}}}/**
   * A collection of unique string waypoint type keys.
   */var WaypointTypes;(function(WaypointTypes){WaypointTypes["Custom"]="Custom";WaypointTypes["Airport"]="Airport";WaypointTypes["NDB"]="NDB";WaypointTypes["VOR"]="VOR";WaypointTypes["Intersection"]="Intersection";WaypointTypes["Runway"]="Runway";WaypointTypes["User"]="User";WaypointTypes["Visual"]="Visual";WaypointTypes["FlightPlan"]="FlightPlan";WaypointTypes["VNAV"]="VNAV";})(WaypointTypes||(WaypointTypes={}));/**
   * An abstract implementation of Waypoint.
   */class AbstractWaypoint{// eslint-disable-next-line jsdoc/require-jsdoc
  equals(other){return this.uid===other.uid;}}/**
   * A basic implementation of {@link FacilityWaypoint}.
   */class BasicFacilityWaypoint extends AbstractWaypoint{/**
       * Constructor.
       * @param facility The facility associated with this waypoint.
       * @param bus The event bus.
       */constructor(facility,bus){super();this.bus=bus;/** @inheritdoc */this.isFacilityWaypoint=true;this._facility=Subject.create(facility);this._location=GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat,facility.lon));this._type=BasicFacilityWaypoint.getType(facility);const facType=ICAO.getFacilityType(facility.icao);if(facType===FacilityType.VIS||facType===FacilityType.USR){// These types of facilities can be mutated. So we need to listen to the event bus for change events and respond
  // accordingly.
  this.facChangeSub=this.bus.getSubscriber().on("facility_changed_".concat(facility.icao)).handle(newFacility=>{this._facility.set(newFacility);this._location.set(newFacility.lat,newFacility.lon);});}}/** @inheritdoc */get location(){return this._location;}/** @inheritdoc */get uid(){return this.facility.get().icao;}/** @inheritdoc */get type(){return this._type;}// eslint-disable-next-line jsdoc/require-returns
  /**
       * The facility associated with this waypoint.
       */get facility(){return this._facility;}/**
       * Gets a waypoint type from a facility.
       * @param facility A facility.
       * @returns The waypoint type corresponding to the facility.
       */static getType(facility){switch(ICAO.getFacilityType(facility.icao)){case FacilityType.Airport:return WaypointTypes.Airport;case FacilityType.Intersection:return WaypointTypes.Intersection;case FacilityType.NDB:return WaypointTypes.NDB;case FacilityType.RWY:return WaypointTypes.Runway;case FacilityType.USR:return WaypointTypes.User;case FacilityType.VIS:return WaypointTypes.Visual;case FacilityType.VOR:return WaypointTypes.VOR;default:return WaypointTypes.User;}}}/**
   * A flight path waypoint.
   */class FlightPathWaypoint extends AbstractWaypoint{// eslint-disable-next-line jsdoc/require-jsdoc
  constructor(arg1,arg2,arg3,arg4,arg5){super();if(typeof arg1==='number'){this._location=GeoPointSubject.create(new GeoPoint(arg1,arg2));this._uid="".concat(FlightPathWaypoint.UID_PREFIX,"_").concat(arg4);this.leg=arg3;this.ident=arg5;}else {this._location=arg1;this._uid="".concat(FlightPathWaypoint.UID_PREFIX,"_").concat(arg3);this.leg=arg2;this.ident=arg4;}}/** @inheritdoc */get location(){return this._location;}/** @inheritdoc */get uid(){return this._uid;}/** @inheritdoc */get type(){return WaypointTypes.FlightPlan;}}FlightPathWaypoint.UID_PREFIX='FLPTH';/**
   * A VNAV waypoint.
   */class VNavWaypoint extends AbstractWaypoint{/**
       * Constructor.
       * @param leg The leg that the VNAV waypoint is contained in.
       * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
       * in meters.
       * @param uid A unique ID to assign to the VNAV waypoint.
       * @param ident This waypoint's ident string.
       */constructor(leg,distanceFromEnd,uid,ident){super();this.ident=ident;this._uid=uid;this._location=GeoPointSubject.create(this.getWaypointLocation(leg,distanceFromEnd,new GeoPoint(0,0)));}/** @inheritdoc */get type(){return WaypointTypes.VNAV;}/** @inheritdoc */get location(){return this._location;}/** @inheritdoc */get uid(){return this._uid;}/**
       * Sets this waypoint's location.
       * @param leg The leg that the waypoint resides in.
       * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
       * in meters.
       */setLocation(leg,distanceFromEnd){this._location.set(this.getWaypointLocation(leg,distanceFromEnd,VNavWaypoint.geoPointCache[0]));}/**
       * Gets the waypoint's location in space.
       * @param leg The leg that the waypoint resides in.
       * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
       * in meters.
       * @param out The GeoPoint object to which to write the location.
       * @returns The waypoint's location.
       */getWaypointLocation(leg,distanceFromEnd,out){var _a,_b;if(leg.calculated!==undefined){const vectors=[...leg.calculated.ingress,...leg.calculated.ingressToEgress,...leg.calculated.egress];let vectorIndex=vectors.length-1;while(vectorIndex>=0){const vector=vectors[vectorIndex];const vectorDistance=vector.distance;if(vectorDistance>=distanceFromEnd){const end=GeoPoint.sphericalToCartesian(vector.endLat,vector.endLon,VNavWaypoint.vec3Cache[0]);return FlightPathUtils.setGeoCircleFromVector(vector,VNavWaypoint.geoCircleCache[0]).offsetDistanceAlong(end,UnitType.METER.convertTo(-distanceFromEnd,UnitType.GA_RADIAN),out,Math.PI);}else {distanceFromEnd-=vectorDistance;}vectorIndex--;}if(vectors.length>0){out.set(vectors[0].startLat,vectors[0].startLon);}else {out.set((_a=leg.calculated.endLat)!==null&&_a!==void 0?_a:0,(_b=leg.calculated.endLon)!==null&&_b!==void 0?_b:0);}}return out;}}VNavWaypoint.vec3Cache=[new Float64Array(3)];VNavWaypoint.geoPointCache=[new GeoPoint(0,0)];VNavWaypoint.geoCircleCache=[new GeoCircle(new Float64Array(3),0)];/**
   * A default implementation of {@link FacilityWaypointCache}.
   */class DefaultFacilityWaypointCache{/**
       * Constructor.
       * @param bus The event bus.
       * @param size The maximum size of this cache.
       */constructor(bus,size){this.bus=bus;this.size=size;this.cache=new Map();}/** @inheritdoc */get(facility){const key=DefaultFacilityWaypointCache.getFacilityKey(facility);let existing=this.cache.get(key);if(!existing){existing=new BasicFacilityWaypoint(facility,this.bus);this.addToCache(key,existing);}return existing;}/**
       * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
       * added, a waypoint will be removed from the cache in FIFO order.
       * @param key The key of the waypoint to add.
       * @param waypoint The waypoint to add.
       */addToCache(key,waypoint){this.cache.set(key,waypoint);if(this.cache.size>this.size){this.cache.delete(this.cache.keys().next().value);}}/**
       * Gets a FacilityWaypointCache instance.
       * @param bus The event bus.
       * @returns A FacilityWaypointCache instance.
       */static getCache(bus){var _a;return (_a=DefaultFacilityWaypointCache.INSTANCE)!==null&&_a!==void 0?_a:DefaultFacilityWaypointCache.INSTANCE=new DefaultFacilityWaypointCache(bus,1000);}/**
       * Gets the cache key for a facility.
       * @param facility A facility.
       * @returns The cache key for the specified facility.
       */static getFacilityKey(facility){if(FacilityUtils.isFacilityType(facility,FacilityType.Intersection)&&ICAO.getFacilityType(facility.icao)!==FacilityType.Intersection){return "mismatch.".concat(facility.icao);}return facility.icao;}}/**
   * Utility class for generating common functions for mapping subscribables.
   */class SubscribableMapFunctions{/**
       * Generates a function which maps an input to itself.
       * @returns A function which maps an input to itself.
       */static identity(){return input=>input;}/**
       * Generates a function which maps an input boolean to its negation.
       * @returns A function which maps an input boolean to its negation.
       */static not(){return input=>!input;}/**
       * Generates a function which maps an input number to its negation.
       * @returns A function which maps an input number to its negation.
       */static negate(){return input=>-input;}/**
       * Generates a function which maps an input number to its absolute value.
       * @returns A function which maps an input number to its absolute value.
       */static abs(){return Math.abs;}/**
       * Generates a function which maps an input number to a rounded version of itself at a certain precision.
       * @param precision The precision to which to round the input.
       * @returns A function which maps an input number to a rounded version of itself at the specified precision.
       */static withPrecision(precision){return SubscribableUtils.isSubscribable(precision)?input=>{const precisionVal=precision.get();return Math.round(input/precisionVal)*precisionVal;}:input=>{return Math.round(input/precision)*precision;};}/**
       * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
       * by a certain amount, and to the previous mapped value otherwise.
       * @param threshold The minimum difference between the input and the previous mapped value required to map the input
       * to itself.
       * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
       * by the specified amount, and to the previous mapped value otherwise.
       */static changedBy(threshold){return SubscribableUtils.isSubscribable(threshold)?(input,currentVal)=>currentVal===undefined||Math.abs(input-currentVal)>=threshold.get()?input:currentVal:(input,currentVal)=>currentVal===undefined||Math.abs(input-currentVal)>=threshold?input:currentVal;}/**
       * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
       * value otherwise.
       * @param freq The maximum frequency at which to map the input to itself, in hertz.
       * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
       * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
       * previous mapped value otherwise.
       */static atFrequency(freq){let timeFunc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Date.now;let t0;let timeRemaining=0;if(SubscribableUtils.isSubscribable(freq)){return (input,currentVal)=>{let returnValue=currentVal!==null&&currentVal!==void 0?currentVal:input;const currentTime=timeFunc();const dt=currentTime-(t0!==null&&t0!==void 0?t0:t0=currentTime);t0=currentTime;timeRemaining-=dt;if(timeRemaining<=0){const period=1000/freq.get();timeRemaining=period+timeRemaining%period;returnValue=input;}return returnValue;};}else {const period=1000/freq;return (input,currentVal)=>{let returnValue=currentVal!==null&&currentVal!==void 0?currentVal:input;const currentTime=timeFunc();const dt=currentTime-(t0!==null&&t0!==void 0?t0:t0=currentTime);t0=currentTime;timeRemaining-=dt;if(timeRemaining<=0){timeRemaining=period+timeRemaining%period;returnValue=input;}return returnValue;};}}}/**
   * A subscribable subject that is a mapped stream from one or more input subscribables.
   */class MappedSubject extends AbstractSubscribable{/**
       * Creates a new MappedSubject.
       * @param mapFunc The function which maps this subject's inputs to a value.
       * @param equalityFunc The function which this subject uses to check for equality between values.
       * @param mutateFunc The function which this subject uses to change its value.
       * @param initialVal The initial value of this subject.
       * @param inputs The subscribables which provide the inputs to this subject.
       */constructor(mapFunc,equalityFunc,mutateFunc,initialVal){super();this.mapFunc=mapFunc;this.equalityFunc=equalityFunc;this.isSubscribable=true;this._isAlive=true;this._isPaused=false;for(var _len5=arguments.length,inputs=new Array(_len5>4?_len5-4:0),_key5=4;_key5<_len5;_key5++){inputs[_key5-4]=arguments[_key5];}this.inputs=inputs;this.inputValues=inputs.map(input=>input.get());if(initialVal&&mutateFunc){this.value=initialVal;mutateFunc(this.value,this.mapFunc(this.inputValues,undefined));this.mutateFunc=newVal=>{mutateFunc(this.value,newVal);};}else {this.value=this.mapFunc(this.inputValues,undefined);this.mutateFunc=newVal=>{this.value=newVal;};}this.inputSubs=this.inputs.map((input,index)=>input.sub(inputValue=>{this.inputValues[index]=inputValue;this.updateValue();}));}/** @inheritdoc */get isAlive(){return this._isAlive;}/** @inheritdoc */get isPaused(){return this._isPaused;}// eslint-disable-next-line jsdoc/require-jsdoc
  static create(){let mapFunc,equalityFunc,mutateFunc,initialVal;for(var _len6=arguments.length,args=new Array(_len6),_key6=0;_key6<_len6;_key6++){args[_key6]=arguments[_key6];}if(typeof args[0]==='function'){// Mapping function was supplied.
  mapFunc=args.shift();if(typeof args[0]==='function'){equalityFunc=args.shift();}else {equalityFunc=AbstractSubscribable.DEFAULT_EQUALITY_FUNC;}if(typeof args[0]==='function'){mutateFunc=args.shift();initialVal=args.shift();}}else {mapFunc=MappedSubject.IDENTITY_MAP;equalityFunc=MappedSubject.NEVER_EQUALS;}return new MappedSubject(mapFunc,equalityFunc,mutateFunc,initialVal,...args);}/**
       * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
       * value according to this subject's equality function.
       */updateValue(){const value=this.mapFunc(this.inputValues,this.value);if(!this.equalityFunc(this.value,value)){this.mutateFunc(value);this.notify();}}/** @inheritdoc */get(){return this.value;}/** @inheritdoc */pause(){if(!this._isAlive){throw new Error('MappedSubject: cannot pause a dead subject');}if(this._isPaused){return this;}for(let i=0;i<this.inputSubs.length;i++){this.inputSubs[i].pause();}this._isPaused=true;return this;}/** @inheritdoc */resume(){if(!this._isAlive){throw new Error('MappedSubject: cannot resume a dead subject');}if(!this._isPaused){return this;}this._isPaused=false;for(let i=0;i<this.inputSubs.length;i++){this.inputValues[i]=this.inputs[i].get();this.inputSubs[i].resume();}this.updateValue();return this;}/** @inheritdoc */destroy(){this._isAlive=false;for(let i=0;i<this.inputSubs.length;i++){this.inputSubs[i].destroy();}}}MappedSubject.IDENTITY_MAP=SubscribableMapFunctions.identity();MappedSubject.NEVER_EQUALS=()=>false;/**
   * Types of changes made to {@link SubscribableSet}.
   */var SubscribableSetEventType;(function(SubscribableSetEventType){/** A key was added. */SubscribableSetEventType["Added"]="Added";/** A key was deleted. */SubscribableSetEventType["Deleted"]="Deleted";})(SubscribableSetEventType||(SubscribableSetEventType={}));/**
   * An array-like class to observe changes in a list of objects.
   * @class ArraySubject
   * @template T
   */class ArraySubject extends AbstractSubscribableArray{/**
       * Constructs an observable array.
       * @param arr The initial array elements.
       */constructor(arr){super();this.array=arr;}// eslint-disable-next-line jsdoc/require-returns
  /** The length of this array. */get length(){return this.array.length;}/**
       * Creates and returns a new observable array.
       * @static
       * @template AT The type of the array items.
       * @param arr The initial array elements.
       * @returns A new instance of SubjectArray.
       */static create(){let arr=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];return new ArraySubject(arr);}/**
       * Inserts a new item at the end or the specified index.
       * @param item The item to insert.
       * @param index The optional index to insert the item to. Will add the item at then end if index not given.
       */insert(item,index){if(index===undefined||index>this.array.length-1){index=this.array.length;this.array.push(item);}else {this.array.splice(index,0,item);}this.notify(index,SubscribableArrayEventType.Added,item);}/**
       * Inserts items of an array beginning at the specified index.
       * @param [index] The index to begin inserting the array items.
       * @param arr The array to insert.
       */insertRange(){let index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;let arr=arguments.length>1?arguments[1]:undefined;this.array.splice(index,0,...arr);this.notify(index,SubscribableArrayEventType.Added,arr);}/**
       * Removes the item at the specified index.
       * @param index The index of the item to remove.
       */removeAt(index){const removedItem=this.array.splice(index,1);this.notify(index,SubscribableArrayEventType.Removed,removedItem[0]);}/**
       * Removes the given item from the array.
       * @param item The item to remove.
       * @returns Returns a boolean indicating if the item was found and removed.
       */removeItem(item){const index=this.array.indexOf(item);if(index>-1){this.removeAt(index);return true;}else {return false;}}/**
       * Replaces all items in the array with the new array.
       * @param arr The array.
       */set(arr){this.clear();this.insertRange(0,arr);}/**
       * Clears all data in the array.
       */clear(){this.array.length=0;this.notify(0,SubscribableArrayEventType.Cleared);}/**
       * Gets the array.
       * @returns The array.
       */getArray(){return this.array;}}/**
   * A object-valued subscribable subject which supports setting individual properties on the object and notifying
   * subscribers of any changes to those properties.
   */class ObjectSubject{/**
       * Constructs an observable object Subject.
       * @param obj The initial object.
       */constructor(obj){this.obj=obj;this.isSubscribable=true;this.isMutableSubscribable=true;this.subs=[];this.notifyDepth=0;this.initialNotifyFunc=this.initialNotify.bind(this);this.onSubDestroyedFunc=this.onSubDestroyed.bind(this);}/**
       * Creates and returns a new ObjectSubject.
       * @param v The initial value of the subject.
       * @returns An ObjectSubject instance.
       */static create(v){return new ObjectSubject(v);}/**
       * Gets this subject's object.
       * @returns This subject's object.
       */get(){return this.obj;}/** @inheritdoc */sub(handler){let initialNotify=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let paused=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const sub=new HandlerSubscription(handler,this.initialNotifyFunc,this.onSubDestroyedFunc);this.subs.push(sub);if(paused){sub.pause();}else if(initialNotify){sub.initialNotify();}return sub;}/** @inheritdoc */unsub(handler){const toDestroy=this.subs.find(sub=>sub.handler===handler);toDestroy===null||toDestroy===void 0?void 0:toDestroy.destroy();}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,value){if(typeof arg1==='object'){for(const prop in arg1){if(prop in this.obj){this.set(prop,arg1[prop]);}}}else {const oldValue=this.obj[arg1];if(value!==oldValue){this.obj[arg1]=value;this.notify(arg1,oldValue);}}}/**
       * Notifies subscriptions that one of the properties of this subject's object has changed.
       * @param key The property of the object that changed.
       * @param oldValue The old value of the property that changed.
       */notify(key,oldValue){let needCleanUpSubs=false;this.notifyDepth++;const subLen=this.subs.length;for(let i=0;i<subLen;i++){try{const sub=this.subs[i];if(sub.isAlive&&!sub.isPaused){sub.handler(this.obj,key,this.obj[key],oldValue);}needCleanUpSubs||(needCleanUpSubs=!sub.isAlive);}catch(error){console.error("ObjectSubject: error in handler: ".concat(error));if(error instanceof Error){console.error(error.stack);}}}this.notifyDepth--;if(needCleanUpSubs&&this.notifyDepth===0){this.subs=this.subs.filter(sub=>sub.isAlive);}}/**
       * Notifies a subscription of this subject's current state.
       * @param sub The subscription to notify.
       */initialNotify(sub){for(const key in this.obj){const v=this.obj[key];sub.handler(this.obj,key,v,v);}}/**
       * Responds to when a subscription to this subscribable is destroyed.
       * @param sub The destroyed subscription.
       */onSubDestroyed(sub){// If we are not in the middle of a notify operation, remove the subscription.
  // Otherwise, do nothing and let the post-notify clean-up code handle it.
  if(this.notifyDepth===0){this.subs.splice(this.subs.indexOf(sub),1);}}// eslint-disable-next-line jsdoc/require-jsdoc
  map(fn,equalityFunc,mutateFunc,initialVal){const mapFunc=(inputs,previousVal)=>fn(inputs[0],previousVal);return mutateFunc// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  ?MappedSubject.create(mapFunc,equalityFunc,mutateFunc,initialVal,this):MappedSubject.create(mapFunc,equalityFunc!==null&&equalityFunc!==void 0?equalityFunc:AbstractSubscribable.DEFAULT_EQUALITY_FUNC,this);}// eslint-disable-next-line jsdoc/require-jsdoc
  pipe(to,arg2,arg3){let sub;let paused;if(typeof arg2==='function'){sub=new SubscribablePipe(this,to,arg2,this.onSubDestroyedFunc);paused=arg3!==null&&arg3!==void 0?arg3:false;}else {sub=new SubscribablePipe(this,to,this.onSubDestroyedFunc);paused=arg2!==null&&arg2!==void 0?arg2:false;}this.subs.push(sub);if(paused){sub.pause();}else {sub.initialNotify();}return sub;}}new SubEvent();new SubEvent();var IcaoSearchFilter;(function(IcaoSearchFilter){IcaoSearchFilter[IcaoSearchFilter["ALL"]=0]="ALL";IcaoSearchFilter[IcaoSearchFilter["AIRPORT"]=1]="AIRPORT";IcaoSearchFilter[IcaoSearchFilter["VOR"]=2]="VOR";IcaoSearchFilter[IcaoSearchFilter["NDB"]=3]="NDB";IcaoSearchFilter[IcaoSearchFilter["INTERSECTION"]=4]="INTERSECTION";IcaoSearchFilter[IcaoSearchFilter["USR"]=5]="USR";})(IcaoSearchFilter||(IcaoSearchFilter={}));/**
   * A publisher for electrical information.
   */class ElectricalPublisher extends SimVarPublisher{/**
       * Create an ElectricalPublisher
       * @param bus The EventBus to publish to
       * @param pacer An optional pacer to use to control the rate of publishing
       */constructor(bus){let pacer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;super(ElectricalPublisher.simvars,bus,pacer);this.flightStarted=false;this.avBusList=['elec_av1_bus','elec_av2_bus'];for(const topic of this.avBusList){if(bus.getTopicSubscriberCount(topic)){this.subscribed.add(topic);}}bus.getSubscriber().on('event_bus_topic_first_sub').handle(event=>{if(this.avBusList.includes(event)){this.subscribed.add(event);}});// When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
  // during loading, so we will ignore all power data until the game enters briefing state.
  const gameStateSub=GameStateProvider.get().sub(state=>{if(state===GameState.briefing||state===GameState.ingame){gameStateSub.destroy();this.flightStarted=true;}},false,true);gameStateSub.resume(true);}/** @inheritdoc */onUpdate(){if(this.flightStarted){super.onUpdate();if(this.av1BusLogic&&this.subscribed.has('elec_av1_bus')){this.publish('elec_av1_bus',this.av1BusLogic.getValue()!==0);}if(this.av2BusLogic&&this.subscribed.has('elec_av2_bus')){this.publish('elec_av2_bus',this.av2BusLogic.getValue()!==0);}}}/**
       * Sets the logic element to use for the avionics 1 bus.
       * @param logicElement The logic element to use.
       */setAv1Bus(logicElement){this.av1BusLogic=logicElement;}/**
       * Sets the logic element to use for the avionics 2 bus.
       * @param logicElement The logic element to use.
       */setAv2Bus(logicElement){this.av2BusLogic=logicElement;}}ElectricalPublisher.simvars=new Map([['elec_master_battery',{name:'ELECTRICAL MASTER BATTERY',type:SimVarValueType.Bool}],['elec_circuit_avionics_on_1',{name:'CIRCUIT AVIONICS ON:1',type:SimVarValueType.Bool}],['elec_circuit_avionics_on_2',{name:'CIRCUIT AVIONICS ON:2',type:SimVarValueType.Bool}],['elec_circuit_navcom1_on',{name:'CIRCUIT NAVCOM1 ON',type:SimVarValueType.Bool}],['elec_circuit_navcom2_on',{name:'CIRCUIT NAVCOM2 ON',type:SimVarValueType.Bool}],['elec_circuit_navcom3_on',{name:'CIRCUIT NAVCOM3 ON',type:SimVarValueType.Bool}],['elec_bus_main_v',{name:'ELECTRICAL MAIN BUS VOLTAGE',type:SimVarValueType.Volts}],['elec_bus_main_a',{name:'ELECTRICAL MAIN BUS AMPS',type:SimVarValueType.Amps}],['elec_bus_avionics_v',{name:'ELECTRICAL AVIONICS BUS VOLTAGE',type:SimVarValueType.Volts}],['elec_bus_avionics_a',{name:'ELECTRICAL AVIONICS BUS AMPS',type:SimVarValueType.Amps}],['elec_bus_genalt_1_v',{name:'ELECTRICAL GENALT BUS VOLTAGE:1',type:SimVarValueType.Volts}],['elec_bus_genalt_2_v',{name:'ELECTRICAL GENALT BUS VOLTAGE:2',type:SimVarValueType.Volts}],['elec_bus_genalt_1_a',{name:'ELECTRICAL GENALT BUS AMPS:1',type:SimVarValueType.Amps}],['elec_bus_genalt_2_a',{name:'ELECTRICAL GENALT BUS AMPS:2',type:SimVarValueType.Amps}],['elec_bat_a_1',{name:'ELECTRICAL BATTERY LOAD:1',type:SimVarValueType.Amps}],['elec_bat_v_1',{name:'ELECTRICAL BATTERY VOLTAGE:1',type:SimVarValueType.Volts}],['elec_bat_a_2',{name:'ELECTRICAL BATTERY LOAD:2',type:SimVarValueType.Amps}],['elec_bat_v_2',{name:'ELECTRICAL BATTERY VOLTAGE:2',type:SimVarValueType.Volts}]]);/// <reference types="@microsoft/msfs-types/js/simvar" />
  /**
   * Flight timer modes.
   */var FlightTimerMode;(function(FlightTimerMode){FlightTimerMode[FlightTimerMode["CountingDown"]=0]="CountingDown";FlightTimerMode[FlightTimerMode["CountingUp"]=1]="CountingUp";})(FlightTimerMode||(FlightTimerMode={}));/**
   * SBAS group names.
   */var SBASGroupName;(function(SBASGroupName){/** Wide Area Augmentation System (USA). */SBASGroupName["WAAS"]="WAAS";/** European Geostationary Navigation Overlay Service (EU). */SBASGroupName["EGNOS"]="EGNOS";/** GPS Aided Geo Augmented Navigation System (India). */SBASGroupName["GAGAN"]="GAGAN";/** Multi-functional Satellite Augmentation System (Japan). */SBASGroupName["MSAS"]="MSAS";})(SBASGroupName||(SBASGroupName={}));/**
   * Possible state on GPS satellites.
   */var GPSSatelliteState;(function(GPSSatelliteState){/** There is no current valid state. */GPSSatelliteState["None"]="None";/** The satellite is out of view and cannot be reached. */GPSSatelliteState["Unreachable"]="Unreachable";/** The satellite has been found and data is being downloaded. */GPSSatelliteState["Acquired"]="Acquired";/** The satellite is faulty. */GPSSatelliteState["Faulty"]="Faulty";/** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */GPSSatelliteState["DataCollected"]="DataCollected";/** The satellite is being active used in the GPS solution. */GPSSatelliteState["InUse"]="InUse";/** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */GPSSatelliteState["InUseDiffApplied"]="InUseDiffApplied";})(GPSSatelliteState||(GPSSatelliteState={}));/**
   * Possible {@link GPSSatComputer} states.
   */var GPSSystemState;(function(GPSSystemState){/** The GPS receiver is trying to locate satellites. */GPSSystemState["Searching"]="Searching";/** The GPS receiver has found satellites and is acquiring a solution. */GPSSystemState["Acquiring"]="Acquiring";/** A 3D solution has been acquired. */GPSSystemState["SolutionAcquired"]="SolutionAcquired";/** A 3D solution using differential computations has been acquired. */GPSSystemState["DiffSolutionAcquired"]="DiffSolutionAcquired";})(GPSSystemState||(GPSSystemState={}));/**
   * Possible SBAS connection states.
   */var GPSSystemSBASState;(function(GPSSystemSBASState){/** SBAS is disabled. */GPSSystemSBASState["Disabled"]="Disabled";/** SBAS is enabled but not receiving differential corrections. */GPSSystemSBASState["Inactive"]="Inactive";/** SBAS is enabled and is receiving differential corrections. */GPSSystemSBASState["Active"]="Active";})(GPSSystemSBASState||(GPSSystemSBASState={}));/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
  /** Minimums Modes */var MinimumsMode;(function(MinimumsMode){MinimumsMode[MinimumsMode["OFF"]=0]="OFF";MinimumsMode[MinimumsMode["BARO"]=1]="BARO";MinimumsMode[MinimumsMode["RA"]=2]="RA";MinimumsMode[MinimumsMode["TEMP_COMP_BARO"]=3]="TEMP_COMP_BARO";})(MinimumsMode||(MinimumsMode={}));/** A publisher for minimums simvar events. */class MinimumsSimVarPublisher extends SimVarPublisher{/**
       * @inheritdoc
       */constructor(bus){super(MinimumsSimVarPublisher.simvars,bus);}}MinimumsSimVarPublisher.simvars=new Map([['decision_height_feet',{name:'DECISION HEIGHT',type:SimVarValueType.Feet}],['decision_altitude_feet',{name:'DECISION ALTITUDE MSL',type:SimVarValueType.Feet}],['minimums_mode',{name:'L:WT_MINIMUMS_MODE',type:SimVarValueType.Number}]]);/**
   * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
   */class NavComSimVarPublisher extends SimVarPublisher{/**
       * Create a NavComSimVarPublisher
       * @param bus The EventBus to publish to
       * @param pacer An optional pacer to use to control the pace of publishing
       */constructor(bus){let pacer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;super(NavComSimVarPublisher.simvars,bus,pacer);}/**
       * Creates an array of nav radio sim var event definitions for an indexed nav radio.
       * @param index The index of the nav radio.
       * @returns An array of nav radio sim var event definitions for the specified nav radio.
       */static createNavRadioDefinitions(index){return [["nav_active_frequency_".concat(index),{name:"NAV ACTIVE FREQUENCY:".concat(index),type:SimVarValueType.MHz}],["nav_standby_frequency_".concat(index),{name:"NAV STANDBY FREQUENCY:".concat(index),type:SimVarValueType.MHz}],["nav_signal_".concat(index),{name:"NAV SIGNAL:".concat(index),type:SimVarValueType.Number}],["nav_sound_".concat(index),{name:"NAV SOUND:".concat(index),type:SimVarValueType.Bool}],["nav_ident_".concat(index),{name:"NAV IDENT:".concat(index),type:SimVarValueType.String}],["nav_volume_".concat(index),{name:"NAV VOLUME:".concat(index),type:SimVarValueType.Percent}]];}/**
       * Creates an array of com radio sim var event definitions for an indexed com radio.
       * @param index The index of the com radio.
       * @returns An array of com radio sim var event definitions for the specified com radio.
       */static createComRadioDefinitions(index){return [["com_active_frequency_".concat(index),{name:"COM ACTIVE FREQUENCY:".concat(index),type:SimVarValueType.MHz}],["com_standby_frequency_".concat(index),{name:"COM STANDBY FREQUENCY:".concat(index),type:SimVarValueType.MHz}],["com_active_facility_name_".concat(index),{name:"COM ACTIVE FREQ NAME:".concat(index),type:SimVarValueType.String}],["com_active_facility_type_".concat(index),{name:"COM ACTIVE FREQ TYPE:".concat(index),type:SimVarValueType.String}],["com_active_facility_ident_".concat(index),{name:"COM ACTIVE FREQ IDENT:".concat(index),type:SimVarValueType.String}],// Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
  // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
  ["com_receive_".concat(index),{name:"COM RECEIVE EX1:".concat(index),type:SimVarValueType.Bool}],["com_status_".concat(index),{name:"COM STATUS:".concat(index),type:SimVarValueType.Number}],["com_transmit_".concat(index),{name:"COM TRANSMIT:".concat(index),type:SimVarValueType.Bool}],["com_spacing_mode_".concat(index),{name:"COM SPACING MODE:".concat(index),type:SimVarValueType.Enum}],["com_volume_".concat(index),{name:"COM VOLUME:".concat(index),type:SimVarValueType.Percent}]];}/**
       * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
       * @param index The index of the ADF radio.
       * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
       */static createAdfRadioDefinitions(index){return [["adf_active_frequency_".concat(index),{name:"ADF ACTIVE FREQUENCY:".concat(index),type:SimVarValueType.KHz}],["adf_standby_frequency_".concat(index),{name:"ADF STANDBY FREQUENCY:".concat(index),type:SimVarValueType.KHz}],["adf_sound_".concat(index),{name:"ADF SOUND:".concat(index),type:SimVarValueType.Bool}],["adf_volume_".concat(index),{name:"ADF VOLUME:".concat(index),type:SimVarValueType.Percent}],["adf_ident_".concat(index),{name:"ADF IDENT:".concat(index),type:SimVarValueType.String}],["adf_signal_".concat(index),{name:"ADF SIGNAL:".concat(index),type:SimVarValueType.Number}]];}}NavComSimVarPublisher.simvars=new Map([...NavComSimVarPublisher.createNavRadioDefinitions(1),...NavComSimVarPublisher.createNavRadioDefinitions(2),...NavComSimVarPublisher.createNavRadioDefinitions(3),...NavComSimVarPublisher.createNavRadioDefinitions(4),...NavComSimVarPublisher.createComRadioDefinitions(1),...NavComSimVarPublisher.createComRadioDefinitions(2),...NavComSimVarPublisher.createComRadioDefinitions(3),...NavComSimVarPublisher.createAdfRadioDefinitions(1),...NavComSimVarPublisher.createAdfRadioDefinitions(2),['marker_beacon_hisense_on',{name:'MARKER BEACON SENSITIVITY HIGH',type:SimVarValueType.Bool}],['marker_beacon_sound',{name:'MARKER SOUND',type:SimVarValueType.Bool}]]);/**
   * A publisher for pitot tube information.
   */class PitotPublisher extends SimVarPublisher{/**
       * Creates an instance of an PitotPublisher.
       * @param bus The event bus to use with this instance.
       * @param pitotCount The number of pitot tubes to support.
       * @param pacer An optional pacer to use to control the rate of publishing.
       */constructor(bus,pitotCount,pacer){const indexedSimVars=[['pitot_heat_switch_on',{name:'PITOT HEAT SWITCH',type:SimVarValueType.Bool}]];const simvars=new Map(PitotPublisher.nonIndexedSimVars);// add pitot-indexed simvars
  for(const[topic,simvar]of indexedSimVars){for(let i=1;i<=pitotCount;i++){simvars.set("".concat(topic,"_").concat(i),{name:"".concat(simvar.name,":").concat(i),type:simvar.type,map:simvar.map});}}super(simvars,bus,pacer);}}PitotPublisher.nonIndexedSimVars=[['pitot_heat_on',{name:'PITOT HEAT',type:SimVarValueType.Bool}],['pitot_icing_pct',{name:'PITOT ICE PCT',type:SimVarValueType.Percent}]];/**
   * A publisher for Pressurization information.
   */class PressurizationPublisher extends SimVarPublisher{/**
       * Create an PressurizationPublisher
       * @param bus The EventBus to publish to
       * @param pacer An optional pacer to use to control the rate of publishing
       */constructor(bus){let pacer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;super(PressurizationPublisher.simvars,bus,pacer);}/**
       * Updates the ADC publisher.
       */onUpdate(){super.onUpdate();}}PressurizationPublisher.simvars=new Map([['cabin_altitude',{name:'PRESSURIZATION CABIN ALTITUDE',type:SimVarValueType.Feet}],['cabin_altitude_rate',{name:'PRESSURIZATION CABIN ALTITUDE RATE',type:SimVarValueType.FPM}],['pressure_diff',{name:'PRESSURIZATION PRESSURE DIFFERENTIAL',type:SimVarValueType.PSI}]]);/**
   * A simple timer for handling debounce.
   */class DebounceTimer{constructor(){this.timer=null;}/**
       * Checks whether an action is pending on this timer.
       * @returns Whether an action is pending on this timer.
       */isPending(){return this.timer!==null;}/**
       * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
       * scheduled on this timer during the delay.
       * @param action The action to schedule.
       * @param delay The debounce delay, in milliseconds.
       */schedule(action,delay){this.clear();this.timer=setTimeout(()=>{this.timer=null;action();},delay);}/**
       * Clears this timer of any pending actions. Actions that are cleared will not be executed.
       */clear(){if(this.timer===null){return;}clearTimeout(this.timer);this.timer=null;}}/** Transponder modes. */var XPDRMode;(function(XPDRMode){XPDRMode[XPDRMode["OFF"]=0]="OFF";XPDRMode[XPDRMode["STBY"]=1]="STBY";XPDRMode[XPDRMode["TEST"]=2]="TEST";XPDRMode[XPDRMode["ON"]=3]="ON";XPDRMode[XPDRMode["ALT"]=4]="ALT";XPDRMode[XPDRMode["GROUND"]=5]="GROUND";})(XPDRMode||(XPDRMode={}));new GeoPoint(0,0);/// <reference types="@microsoft/msfs-types/js/simvar" />
  /**
   * A controler for automated backlighting levels based upon the angle of the sun in the sky.
   */class BacklightLevelController{/**
       * Creates an automatic backlight controller.
       * @param bus The event bus.
       * @param paused Whether the controller should be initially paused. Defaults to `false`.
       * @param minIntensity The maximum intensity commanded by the controller. Defaults to 0.
       * @param maxIntensity The minimum intensity commanded by the controller. Defaults to 1.
       */constructor(bus){let paused=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let minIntensity=arguments.length>2&&arguments[2]!==undefined?arguments[2]:BacklightLevelController.DEFAULT_MIN_INTENSITY;let maxIntensity=arguments.length>3&&arguments[3]!==undefined?arguments[3]:BacklightLevelController.DEFAULT_MAX_INTENSITY;this.simTime=ConsumerSubject.create(null,0);this.ppos=new Float64Array(3);this.needRecalcAuto=true;this.lastSimTime=0;this.paused=false;this._intensity=Subject.create(0);this.intensity=this._intensity;this._autoMinIntensity=minIntensity;this._autoMaxIntensity=maxIntensity;this._autoIntensityRange=this.autoMaxIntensity-this.autoMinIntensity;this.needRecalcAuto=true;const sub=bus.getSubscriber();this.simTime.setConsumer(sub.on('simTime'));this.pposSub=sub.on('gps-position').atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onPPosChanged.bind(this));this.updateSub=sub.on('realTime').atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));this.setPaused(paused);}/**
       * Get the max auto intensity value
       * @returns The maximum intensity applied by the auto backlight.
       */get autoMaxIntensity(){return this._autoMaxIntensity;}/**
       * Set the max auto intensity value.
       * @param max_intensity The maximum intensity applied by auto backlight.
       */set autoMaxIntensity(max_intensity){this._autoMaxIntensity=max_intensity;this._autoIntensityRange=this._autoMaxIntensity-this._autoMinIntensity;this.needRecalcAuto=true;}/**
       * Get the min auto intensity value
       * @returns THe minimum intensity applied by the auto backlight.
       */get autoMinIntensity(){return this._autoMinIntensity;}/**
       * Set the min auto intensity value.
       * @param min_intensity The minimum intensity applied by the auto backlight.
       */set autoMinIntensity(min_intensity){this._autoMinIntensity=min_intensity;this._autoIntensityRange=this._autoMinIntensity-min_intensity;this.needRecalcAuto=true;}/**
       * Pause or unpause real-time processing.
       * @param paused Whether to pause or not.
       */setPaused(paused){if(paused!==this.paused){this.paused=paused;if(paused){this.updateSub.pause();this.pposSub.pause();this.simTime.pause();this.needRecalcAuto=false;}else {this.needRecalcAuto=true;this.simTime.resume();this.pposSub.resume(true);this.updateSub.resume(true);}}}/**
       * A callback which is called when the user's location changes.
       * @param ppos The new plane position.
       */onPPosChanged(ppos){const pposVec=GeoPoint.sphericalToCartesian(ppos.lat,ppos.long,BacklightLevelController.tempVec3);if(Vec3Math.dot(pposVec,this.ppos)>=1-1e-4){// ~600 m
  return;}Vec3Math.copy(pposVec,this.ppos);this.needRecalcAuto=true;}/**
       * Updates this controller's commanded backlight intensity if necessary.
       */onUpdate(){const simTime=this.simTime.get();this.needRecalcAuto||(this.needRecalcAuto=Math.abs(simTime-this.lastSimTime)>=BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD);if(this.needRecalcAuto){this.needRecalcAuto=false;this.updateAutoBacklightIntensity(simTime);}}/**
       * Updates this controller's commanded backlight intensity according to the auto setting algorithm.
       * @param simTime The current sim time.
       */updateAutoBacklightIntensity(simTime){this.lastSimTime=simTime;const subSolarPoint=BacklightLevelController.calculateSubSolarPoint(simTime,BacklightLevelController.tempVec3);const sinSolarAngle=Vec3Math.dot(this.ppos,subSolarPoint);const sinSolarAngleClamped=Utils.Clamp(sinSolarAngle,BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN,BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN);const intensityFrac=(sinSolarAngleClamped-BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN)/BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN;this._intensity.set(this._autoMinIntensity+intensityFrac*this._autoIntensityRange);}/**
       * Calculates the subsolar point (the point on Earth's surface directly below the Sun, where solar zenith angle = 0)
       * given a specific time.
       * @param time A UNIX timestamp in milliseconds.
       * @param out A Float64Array object to which to write the result.
       * @returns The subsolar point at the specified time.
       */static calculateSubSolarPoint(time,out){// Source: Zhang, T et al. https://doi.org/10.1016/j.renene.2021.03.047
  const PI2=2*Math.PI;const days=(time-BacklightLevelController.EPOCH)/BacklightLevelController.DAY;const daysFrac=days-Math.floor(days);const L=4.895055+0.01720279*days;const g=6.240041+0.01720197*days;const lambda=L+0.033423*Math.sin(g)+0.000349*Math.sin(2*g);const epsilon=0.40910518-6.98e-9*days;const rAscension=Math.atan2(Math.cos(epsilon)*Math.sin(lambda),Math.cos(lambda));const declination=Math.asin(Math.sin(epsilon)*Math.sin(lambda));// equation of time in days.
  const E=(((L-rAscension)%PI2+3*Math.PI)%PI2-Math.PI)*0.159155;const lat=declination*Avionics.Utils.RAD2DEG;const lon=-15*(daysFrac-0.5+E)*24;return GeoPoint.sphericalToCartesian(lat,lon,out);}}BacklightLevelController.AUTO_MAX_SOLAR_ANGLE=3;// The solar altitude angle at which auto backlight reaches maximum intensity.
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE=-8;// The solar altitude angle at which auto backlight reaches minimum intensity.
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN=Math.sin(BacklightLevelController.AUTO_MAX_SOLAR_ANGLE*Avionics.Utils.DEG2RAD);BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN=Math.sin(BacklightLevelController.AUTO_MIN_SOLAR_ANGLE*Avionics.Utils.DEG2RAD);BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN=BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN-BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN;BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ=10;// max frequency (Hz) of auto backlight level updates in real time
  BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD=60000;// minimum interval (ms) between auto backlight level updates in sim time
  BacklightLevelController.EPOCH=946684800000;// Jan 1, 2000 00:00:00 UTC
  BacklightLevelController.DAY=86400000;// milliseconds in one day
  BacklightLevelController.DEFAULT_MIN_INTENSITY=0;BacklightLevelController.DEFAULT_MAX_INTENSITY=1;BacklightLevelController.tempVec3=new Float64Array(3);/** The acceptable priority types for a given annunciation. */var AnnunciationType;(function(AnnunciationType){AnnunciationType[AnnunciationType["Warning"]=0]="Warning";AnnunciationType[AnnunciationType["Caution"]=1]="Caution";AnnunciationType[AnnunciationType["Advisory"]=2]="Advisory";AnnunciationType[AnnunciationType["SafeOp"]=3]="SafeOp";})(AnnunciationType||(AnnunciationType={}));/* eslint-disable no-inner-declarations */ /** A releative render position. */var RenderPosition;(function(RenderPosition){RenderPosition[RenderPosition["Before"]=0]="Before";RenderPosition[RenderPosition["After"]=1]="After";RenderPosition[RenderPosition["In"]=2]="In";})(RenderPosition||(RenderPosition={}));/**
   * A display component in the component framework.
   * @typedef P The type of properties for this component.
   * @typedef C The type of context that this component might have.
   */class DisplayComponent{/**
       * Creates an instance of a DisplayComponent.
       * @param props The propertis of the component.
       */constructor(props){/** The context on this component, if any. */this.context=undefined;/** The type of context for this component, if any. */this.contextType=undefined;this.props=props;}/**
       * A callback that is called before the component is rendered.
       */onBeforeRender(){return;}/**
       * A callback that is called after the component is rendered.
       * @param node The component's VNode.
       */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onAfterRender(node){return;}/**
       * Destroys this component.
       */destroy(){return;}/**
       * Gets a context data subscription from the context collection.
       * @param context The context to get the subscription for.
       * @returns The requested context.
       * @throws An error if no data for the specified context type could be found.
       */getContext(context){if(this.context!==undefined&&this.contextType!==undefined){const index=this.contextType.indexOf(context);return this.context[index];}throw new Error('Could not find the provided context type.');}}/**
   * A reference to a component or element node.
   */class NodeReference{constructor(){/** The internal reference instance. */this._instance=null;}/**
       * The instance of the element or component.
       * @returns The instance of the element or component.
       */get instance(){if(this._instance!==null){return this._instance;}throw new Error('Instance was null.');}/**
       * Sets the value of the instance.
       */set instance(val){this._instance=val;}/**
       * Gets the instance, or null if the instance is not populated.
       * @returns The component or element instance.
       */getOrDefault(){return this._instance;}}/**
   * Provides a context of data that can be passed down to child components via a provider.
   */class Context{/**
       * Creates an instance of a Context.
       * @param defaultValue The default value of this context.
       */constructor(defaultValue){this.defaultValue=defaultValue;/**
           * The provider component that can be set to a specific context value.
           * @param props The props of the provider component.
           * @returns A new context provider.
           */this.Provider=props=>new ContextProvider(props,this);}}/**
   * A provider component that can be set to a specific context value.
   */class ContextProvider extends DisplayComponent{/**
       * Creates an instance of a ContextProvider.
       * @param props The props on the component.
       * @param parent The parent context instance for this provider.
       */constructor(props,parent){super(props);this.parent=parent;}/** @inheritdoc */render(){var _a;const children=(_a=this.props.children)!==null&&_a!==void 0?_a:[];return FSComponent.buildComponent(FSComponent.Fragment,this.props,...children);}}/**
   * The FS component namespace.
   */ // eslint-disable-next-line @typescript-eslint/no-namespace
  var FSComponent;(function(FSComponent){/**
       * Valid SVG element tags.
       */const svgTags={'circle':true,'clipPath':true,'color-profile':true,'cursor':true,'defs':true,'desc':true,'ellipse':true,'g':true,'image':true,'line':true,'linearGradient':true,'marker':true,'mask':true,'path':true,'pattern':true,'polygon':true,'polyline':true,'radialGradient':true,'rect':true,'stop':true,'svg':true,'text':true};/**
       * A fragment of existing elements with no specific root.
       * @param props The fragment properties.
       * @returns The fragment children.
       */function Fragment(props){return props.children;}FSComponent.Fragment=Fragment;/**
       * Builds a JSX based FSComponent.
       * @param type The DOM element tag that will be built.
       * @param props The properties to apply to the DOM element.
       * @param children Any children of this DOM element.
       * @returns The JSX VNode for the component or element.
       */ // eslint-disable-next-line no-inner-declarations
  function buildComponent(type,props){let vnode=null;for(var _len9=arguments.length,children=new Array(_len9>2?_len9-2:0),_key9=2;_key9<_len9;_key9++){children[_key9-2]=arguments[_key9];}if(typeof type==='string'){let element;if(svgTags[type]!==undefined){element=document.createElementNS('http://www.w3.org/2000/svg',type);}else {element=document.createElement(type);}if(props!==null){for(const key in props){if(key==='ref'&&props.ref!==undefined){props.ref.instance=element;}else {const prop=props[key];if(key==='class'&&typeof prop==='object'&&'isSubscribableSet'in prop){// Bind CSS classes to a subscribable set
  prop.sub((set,eventType,modifiedKey)=>{if(eventType===SubscribableSetEventType.Added){element.classList.add(modifiedKey);}else {element.classList.remove(modifiedKey);}},true);}else if(typeof prop==='object'&&'isSubscribable'in prop){if(key==='style'&&prop instanceof ObjectSubject){// Bind CSS styles to an object subject.
  prop.sub((v,style,newValue)=>{element.style.setProperty(style.toString(),newValue);},true);}else {// Bind an attribute to a subscribable.
  prop.sub(v=>{element.setAttribute(key,v);},true);}}else {element.setAttribute(key,prop);}}}}vnode={instance:element,props:props,children:null};vnode.children=createChildNodes(vnode,children);}else if(typeof type==='function'){if(children!==null&&props===null){props={children:children};}else if(props!==null){props.children=children;}if(typeof type==='function'&&type.name===Fragment.name){let childNodes=type(props);//Handle the case where the single fragment children is an array of nodes passsed down from above
  while(childNodes!==null&&childNodes.length===1&&Array.isArray(childNodes[0])){childNodes=childNodes[0];}vnode={instance:null,props,children:childNodes};}else {let instance;const pluginSystem=window._pluginSystem;try{instance=type(props);}catch(_a){let pluginInstance=undefined;if(pluginSystem!==undefined){pluginInstance=pluginSystem.onComponentCreating(type,props);}if(pluginInstance!==undefined){instance=pluginInstance;}else {instance=new type(props);}}if(props!==null&&props.ref!==null&&props.ref!==undefined){props.ref.instance=instance;}if(instance.contextType!==undefined){instance.context=instance.contextType.map(c=>Subject.create(c.defaultValue));}if(pluginSystem!==undefined){pluginSystem.onComponentCreated(instance);}vnode={instance,props,children:[instance.render()]};}}return vnode;}FSComponent.buildComponent=buildComponent;/**
       * Creates the collection of child VNodes.
       * @param parent The parent VNode.
       * @param children The JSX children to convert to nodes.
       * @returns A collection of child VNodes.
       */function createChildNodes(parent,children){let vnodes=null;if(children!==null&&children!==undefined&&children.length>0){vnodes=[];for(const child of children){if(child!==null){if(child instanceof Array){const arrayNodes=createChildNodes(parent,child);if(arrayNodes!==null){vnodes.push(...arrayNodes);}}else if(typeof child==='object'){if('isSubscribable'in child){const node={instance:child,children:null,props:null,root:undefined};child.sub(v=>{if(node.root!==undefined){// TODO workaround. gotta find a solution for the text node vanishing when text is empty
  node.root.nodeValue=v===''||v===null||v===undefined?' ':v.toString();}});vnodes.push(node);}else {vnodes.push(child);}}else if(typeof child==='string'||typeof child==='number'){vnodes.push(createStaticContentNode(child));}}}}return vnodes;}FSComponent.createChildNodes=createChildNodes;/**
       * Creates a static content VNode.
       * @param content The content to create a node for.
       * @returns A static content VNode.
       */function createStaticContentNode(content){return {instance:content,children:null,props:null};}FSComponent.createStaticContentNode=createStaticContentNode;/**
       * Renders a VNode to a DOM element.
       * @param node The node to render.
       * @param element The DOM element to render to.
       * @param position The RenderPosition to put the item in.
       */function render(node,element){let position=arguments.length>2&&arguments[2]!==undefined?arguments[2]:RenderPosition.In;if(node.children&&node.children.length>0&&element!==null){const componentInstance=node.instance;if(componentInstance!==null&&componentInstance.onBeforeRender!==undefined){componentInstance.onBeforeRender();}if(node.instance instanceof HTMLElement||node.instance instanceof SVGElement){insertNode(node,position,element);}else {if(position===RenderPosition.After){for(let i=node.children.length-1;i>=0;i--){if(node.children[i]===undefined||node.children[i]===null){continue;}insertNode(node.children[i],position,element);}}else {for(let i=0;i<node.children.length;i++){if(node.children[i]===undefined||node.children[i]===null){continue;}insertNode(node.children[i],position,element);}}}const instance=node.instance;if(instance instanceof ContextProvider){visitNodes(node,n=>{if(n===undefined||n===null){return false;}const nodeInstance=n.instance;if(nodeInstance!==null&&nodeInstance.contextType!==undefined){const contextSlot=nodeInstance.contextType.indexOf(instance.parent);if(contextSlot>=0){if(nodeInstance.context===undefined){nodeInstance.context=[];}nodeInstance.context[contextSlot].set(instance.props.value);}if(nodeInstance instanceof ContextProvider&&nodeInstance!==instance&&nodeInstance.parent===instance.parent){return true;}}return false;});}if(componentInstance!==null&&componentInstance.onAfterRender!==undefined){const pluginSystem=window._pluginSystem;componentInstance.onAfterRender(node);if(pluginSystem!==undefined){pluginSystem.onComponentRendered(node);}}}}FSComponent.render=render;/**
       * Inserts a node into the DOM.
       * @param node The node to insert.
       * @param position The position to insert the node in.
       * @param element The element to insert relative to.
       */function insertNode(node,position,element){var _a,_b,_c,_d,_e,_f;if(node.instance instanceof HTMLElement||node.instance instanceof SVGElement){switch(position){case RenderPosition.In:element.appendChild(node.instance);node.root=(_a=element.lastChild)!==null&&_a!==void 0?_a:undefined;break;case RenderPosition.Before:element.insertAdjacentElement('beforebegin',node.instance);node.root=(_b=element.previousSibling)!==null&&_b!==void 0?_b:undefined;break;case RenderPosition.After:element.insertAdjacentElement('afterend',node.instance);node.root=(_c=element.nextSibling)!==null&&_c!==void 0?_c:undefined;break;}if(node.children!==null){for(const child of node.children){insertNode(child,RenderPosition.In,node.instance);}}}else if(typeof node.instance==='string'||typeof node.instance==='object'&&node.instance!==null&&'isSubscribable'in node.instance){let toRender;if(typeof node.instance==='string'){toRender=node.instance;}else {toRender=node.instance.get();if(toRender===''){toRender=' ';// prevent disappearing text node
  }}switch(position){case RenderPosition.In:element.insertAdjacentHTML('beforeend',toRender);node.root=(_d=element.lastChild)!==null&&_d!==void 0?_d:undefined;break;case RenderPosition.Before:element.insertAdjacentHTML('beforebegin',toRender);node.root=(_e=element.previousSibling)!==null&&_e!==void 0?_e:undefined;break;case RenderPosition.After:element.insertAdjacentHTML('afterend',toRender);node.root=(_f=element.nextSibling)!==null&&_f!==void 0?_f:undefined;break;}}else if(Array.isArray(node)){if(position===RenderPosition.After){for(let i=node.length-1;i>=0;i--){render(node[i],element,position);}}else {for(let i=0;i<node.length;i++){render(node[i],element,position);}}}else {render(node,element,position);}}/**
       * Render a node before a DOM element.
       * @param node The node to render.
       * @param element The element to render boeore.
       */function renderBefore(node,element){render(node,element,RenderPosition.Before);}FSComponent.renderBefore=renderBefore;/**
       * Render a node after a DOM element.
       * @param node The node to render.
       * @param element The element to render after.
       */function renderAfter(node,element){render(node,element,RenderPosition.After);}FSComponent.renderAfter=renderAfter;/**
       * Remove a previously rendered element.  Currently, this is just a simple
       * wrapper so that all of our high-level "component maniuplation" state is kept
       * in the FSComponent API, but it's not doing anything other than a simple
       * remove() on the element.   This can probably be enhanced.
       * @param element The element to remove.
       */function remove(element){if(element!==null){element.remove();}}FSComponent.remove=remove;/**
       * Creates a component or element node reference.
       * @returns A new component or element node reference.
       */function createRef(){return new NodeReference();}FSComponent.createRef=createRef;/**
       * Creates a new context to hold data for passing to child components.
       * @param defaultValue The default value of this context.
       * @returns A new context.
       */function createContext(defaultValue){return new Context(defaultValue);}FSComponent.createContext=createContext;/**
       * Visits VNodes with a supplied visitor function within the given children tree.
       * @param node The node to visit.
       * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
       * node and not proceed any further down the node's children.
       */function visitNodes(node,visitor){if(node===undefined||node===null){return;}const stopVisitation=visitor(node);if(!stopVisitation&&node.children!==undefined&&node.children!==null){for(let i=0;i<node.children.length;i++){const child=node.children[i];if(Array.isArray(child)){for(let childIndex=0;childIndex<child.length;childIndex++){visitNodes(child[childIndex],visitor);}}else {visitNodes(child,visitor);}}}return;}FSComponent.visitNodes=visitNodes;/**
       * Parses a space-delimited CSS class string into an array of CSS classes.
       * @param classString A space-delimited CSS class string.
       * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
       * class should be included in the output array and `false` otherwise.
       * @returns An array of CSS classes derived from the specified CSS class string.
       */function parseCssClassesFromString(classString,filter){return classString.split(' ').filter(str=>str!==''&&(filter===undefined||filter(str)));}FSComponent.parseCssClassesFromString=parseCssClassesFromString;/**
       * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
       * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
       * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
       * set; these reserved classes may be freely added to and removed from the bound set.
       * @param setToBind The set to bind.
       * @param classesToSubscribe A set of CSS classes to which to subscribe.
       * @param reservedClasses An iterable of reserved classes.
       * @returns The newly created subscription to the subscribed CSS class set.
       */function bindCssClassSet(setToBind,classesToSubscribe,reservedClasses){const reservedClassSet=new Set(reservedClasses);if(reservedClassSet.size===0){return classesToSubscribe.sub((set,type,key)=>{if(type===SubscribableSetEventType.Added){setToBind.add(key);}else {setToBind.delete(key);}},true);}else {return classesToSubscribe.sub((set,type,key)=>{if(reservedClassSet.has(key)){return;}if(type===SubscribableSetEventType.Added){setToBind.add(key);}else {setToBind.delete(key);}},true);}}FSComponent.bindCssClassSet=bindCssClassSet;/**
       * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
       * branch of the tree.
       * @param root The root of the tree to traverse.
       */function shallowDestroy(root){FSComponent.visitNodes(root,node=>{if(node!==root&&node.instance instanceof DisplayComponent){node.instance.destroy();return true;}return false;});}FSComponent.shallowDestroy=shallowDestroy;/**
       * An empty callback handler.
       */FSComponent.EmptyHandler=()=>{return;};})(FSComponent||(FSComponent={}));FSComponent.Fragment;/// <reference types="@microsoft/msfs-types/js/common" />
  /**
   * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
   */class BingComponent extends DisplayComponent{constructor(){var _a,_b,_c,_d,_e,_f,_g,_h;super(...arguments);this.modeFlags=this.props.mode===EBingMode.HORIZON?4:0;this.isListenerRegistered=false;this.imgRef=FSComponent.createRef();this.uid=0;this._isBound=false;this._isAwake=true;this.isDestroyed=false;this.pos=new LatLong(0,0);this.radius=10;this.resolution=(_a=this.props.resolution)!==null&&_a!==void 0?_a:Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION,BingComponent.DEFAULT_RESOLUTION));this.earthColors=(_b=this.props.earthColors)!==null&&_b!==void 0?_b:ArraySubject.create(ArrayUtils.create(2,()=>BingComponent.hexaToRGBColor('#000000')));this.earthColorsElevationRange=(_c=this.props.earthColorsElevationRange)!==null&&_c!==void 0?_c:Vec2Subject.create(Vec2Math.create(0,30000));this.skyColor=(_d=this.props.skyColor)!==null&&_d!==void 0?_d:Subject.create(BingComponent.hexaToRGBColor('#000000'));this.reference=(_e=this.props.reference)!==null&&_e!==void 0?_e:Subject.create(EBingReference.SEA);this.wxrMode=(_f=this.props.wxrMode)!==null&&_f!==void 0?_f:Subject.create({mode:EWeatherRadar.OFF,arcRadians:0.5});this.wxrColors=(_g=this.props.wxrColors)!==null&&_g!==void 0?_g:ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));this.isoLines=(_h=this.props.isoLines)!==null&&_h!==void 0?_h:Subject.create(false);this.wxrColorsArray=[];this.wxrRateArray=[];this.resolutionHandler=resolution=>{Coherent.call('SET_MAP_RESOLUTION',this.uid,resolution[0],resolution[1]);// The sim ignores position/radius updates within a certain number of frames of sending a resolution change, so we
  // will keep trying to send pending updates for a few frames after any resolution change.
  this.positionRadiusInhibitFramesRemaining=BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;if(!this.positionRadiusInhibitTimer.isPending()){this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius,0);}};this.earthColorsHandler=()=>{const colors=this.earthColors.getArray();if(colors.length<2){return;}Coherent.call('SET_MAP_HEIGHT_COLORS',this.uid,colors);};this.earthColorsElevationRangeHandler=()=>{const colors=this.earthColors.getArray();if(colors.length<2){return;}// The way the map assigns colors to elevations is as follows:
  // ----------------------------------------------------------------------------------
  // - altitude range = MIN to MAX
  // - colors = array of length N >= 2 (colors[0] is the water color)
  // - STEP = (MAX - MIN) / N
  // - colors[i] is assigned to elevations from MIN + STEP * i to MIN + STEP * (i + 1)
  // - colors[1] is also assigned to all elevations < MIN + STEP
  // - colors[N - 1] is also assigned to all elevations > MIN + STEP * N
  // ----------------------------------------------------------------------------------
  const range=this.earthColorsElevationRange.get();const terrainColorCount=colors.length-1;const desiredElevationStep=(range[1]-range[0])/Math.max(terrainColorCount-1,1);const requiredMin=range[0]-desiredElevationStep;const requiredMax=range[1]+desiredElevationStep;Coherent.call('SET_MAP_ALTITUDE_RANGE',this.uid,requiredMin,requiredMax);};this.skyColorHandler=color=>{Coherent.call('SET_MAP_CLEAR_COLOR',this.uid,color);};this.referenceHandler=reference=>{const flags=this.modeFlags|(reference===EBingReference.PLANE?1:0);this.mapListener.trigger('JS_BIND_BINGMAP',this.props.id,flags);};this.wxrModeHandler=wxrMode=>{Coherent.call('SHOW_MAP_WEATHER',this.uid,wxrMode.mode,wxrMode.arcRadians);};this.wxrColorsHandler=()=>{const array=this.wxrColors.getArray();if(array.length===0){return;}this.wxrColorsArray.length=array.length;this.wxrRateArray.length=array.length;for(let i=0;i<array.length;i++){this.wxrColorsArray[i]=array[i][0];this.wxrRateArray[i]=array[i][1];}Coherent.call('SET_MAP_WEATHER_RADAR_COLORS',this.uid,this.wxrColorsArray,this.wxrRateArray);};this.isoLinesHandler=showIsolines=>{Coherent.call('SHOW_MAP_ISOLINES',this.uid,showIsolines);};this.setCurrentMapParamsTimer=null;this.positionRadiusInhibitFramesRemaining=0;this.isPositionRadiusPending=false;this.positionRadiusInhibitTimer=new DebounceTimer();this.processPendingPositionRadius=()=>{if(this.isPositionRadiusPending){Coherent.call('SET_MAP_PARAMS',this.uid,this.pos,this.radius,1);}if(--this.positionRadiusInhibitFramesRemaining>0){this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius,0);}else {this.isPositionRadiusPending=false;}};/**
           * A callback called when the listener is fully bound.
           * @param binder The binder from the listener.
           * @param uid The unique ID of the bound map.
           */this.onListenerBound=(binder,uid)=>{if(this.isDestroyed){return;}if(binder.friendlyName===this.props.id){// console.log('Bing map listener bound.');
  this.binder=binder;this.uid=uid;if(this._isBound){return;}this._isBound=true;Coherent.call('SHOW_MAP',uid,true);const pause=!this._isAwake;this.earthColorsSub=this.earthColors.sub(()=>{this.earthColorsHandler();this.earthColorsElevationRangeHandler();},true,pause);this.earthColorsElevationRangeSub=this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler,true,pause);this.skyColorSub=this.skyColor.sub(this.skyColorHandler,true,pause);this.referenceSub=this.reference.sub(this.referenceHandler,true,pause);this.wxrModeSub=this.wxrMode.sub(this.wxrModeHandler,true,pause);this.wxrColorsSub=this.wxrColors.sub(this.wxrColorsHandler,true,pause);this.resolutionSub=this.resolution.sub(this.resolutionHandler,true,pause);this.isoLinesSub=this.isoLines.sub(this.isoLinesHandler,true,pause);// Only when not SVT, send in initial map params (even if we are asleep), because a bing instance that doesn't
  // have params initialized causes GPU perf issues.
  if(this.modeFlags!==4){Coherent.call('SET_MAP_PARAMS',this.uid,this.pos,this.radius,1);}this.props.onBoundCallback&&this.props.onBoundCallback(this);}};/**
           * A callback called when the map image is updated.
           * @param uid The unique ID of the bound map.
           * @param imgSrc The img tag src attribute to assign to the bing map image.
           */this.onMapUpdate=(uid,imgSrc)=>{if(this.binder!==undefined&&this.uid===uid&&this.imgRef.instance!==null){if(this.imgRef.instance.src!==imgSrc){this.imgRef.instance.src=imgSrc;}}};/**
           * Calls the position and radius set function to set map parameters.
           */this.setCurrentMapParams=()=>{this.setPositionRadius(this.pos,this.radius);};}/**
       * Checks whether this Bing component has been bound.
       * @returns whether this Bing component has been bound.
       */isBound(){return this._isBound;}/**
       * Checks whether this Bing component is awake.
       * @returns whether this Bing component is awake.
       */isAwake(){return this._isAwake;}/** @inheritdoc */onAfterRender(){if(window['IsDestroying']){this.destroy();return;}const gameStateSubscribable=GameStateProvider.get();const gameState=gameStateSubscribable.get();if(gameState===GameState.briefing||gameState===GameState.ingame){this.registerListener();}else {this.gameStateSub=gameStateSubscribable.sub(state=>{var _a;if(this.isDestroyed){return;}if(state===GameState.briefing||state===GameState.ingame){(_a=this.gameStateSub)===null||_a===void 0?void 0:_a.destroy();this.registerListener();}});}window.addEventListener('OnDestroy',this.destroy.bind(this));}/**
       * Registers this component's Bing map listener.
       */registerListener(){var _a;if(((_a=this.props.delay)!==null&&_a!==void 0?_a:0)>0){setTimeout(()=>{if(this.isDestroyed){return;}this.mapListener=RegisterViewListener('JS_LISTENER_MAPS',this.onListenerRegistered.bind(this));},this.props.delay);}else {this.mapListener=RegisterViewListener('JS_LISTENER_MAPS',this.onListenerRegistered.bind(this));}}/**
       * A callback called when this component's Bing map listener is registered.
       */onListenerRegistered(){if(this.isDestroyed||this.isListenerRegistered){return;}this.mapListener.on('MapBinded',this.onListenerBound);this.mapListener.on('MapUpdated',this.onMapUpdate);this.isListenerRegistered=true;this.mapListener.trigger('JS_BIND_BINGMAP',this.props.id,this.modeFlags);}/**
       * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
       * to the Bing instance to which it is bound.
       */wake(){var _a,_b,_c,_d,_e,_f,_g,_h;this._isAwake=true;if(!this._isBound){return;}this.setCurrentMapParams();// Only when not SVT, periodically send map params to Coherent in case another BingComponent binds to the same
  // bing instance and sends in the initial params set and overrides our params.
  if(this.modeFlags!==4){this.setCurrentMapParamsTimer=setInterval(this.setCurrentMapParams,200);}(_a=this.earthColorsSub)===null||_a===void 0?void 0:_a.resume(true);(_b=this.earthColorsElevationRangeSub)===null||_b===void 0?void 0:_b.resume(true);(_c=this.skyColorSub)===null||_c===void 0?void 0:_c.resume(true);(_d=this.referenceSub)===null||_d===void 0?void 0:_d.resume(true);(_e=this.wxrModeSub)===null||_e===void 0?void 0:_e.resume(true);(_f=this.wxrColorsSub)===null||_f===void 0?void 0:_f.resume(true);(_g=this.resolutionSub)===null||_g===void 0?void 0:_g.resume(true);(_h=this.isoLinesSub)===null||_h===void 0?void 0:_h.resume(true);}/**
       * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
       * it is bound.
       */sleep(){var _a,_b,_c,_d,_e,_f,_g,_h;this._isAwake=false;if(!this._isBound){return;}if(this.setCurrentMapParamsTimer!==null){clearInterval(this.setCurrentMapParamsTimer);}(_a=this.earthColorsSub)===null||_a===void 0?void 0:_a.pause();(_b=this.earthColorsElevationRangeSub)===null||_b===void 0?void 0:_b.pause();(_c=this.skyColorSub)===null||_c===void 0?void 0:_c.pause();(_d=this.referenceSub)===null||_d===void 0?void 0:_d.pause();(_e=this.wxrModeSub)===null||_e===void 0?void 0:_e.pause();(_f=this.wxrColorsSub)===null||_f===void 0?void 0:_f.pause();(_g=this.resolutionSub)===null||_g===void 0?void 0:_g.pause();(_h=this.isoLinesSub)===null||_h===void 0?void 0:_h.pause();}/**
       * Sets the center position and radius.
       * @param pos The center position.
       * @param radius The radius, in meters.
       */setPositionRadius(pos,radius){this.pos=pos;this.radius=Math.max(radius,10);// Not sure if bad things happen when radius is 0, so we just clamp it to 10 meters.
  if(this._isBound&&this._isAwake){if(this.positionRadiusInhibitFramesRemaining>0){this.isPositionRadiusPending=true;}else {Coherent.call('SET_MAP_PARAMS',this.uid,this.pos,this.radius,1);}}}/** @inheritdoc */render(){var _a;return FSComponent.buildComponent("img",{ref:this.imgRef,src:'',style:'position: absolute; left: 0; top: 0; width: 100%; height: 100%;',class:(_a=this.props.class)!==null&&_a!==void 0?_a:''});}/** @inheritdoc */destroy(){var _a,_b,_c,_d,_e,_f,_g,_h,_j,_k,_l,_m,_o;this.isDestroyed=true;this._isBound=false;if(this.setCurrentMapParamsTimer!==null){clearInterval(this.setCurrentMapParamsTimer);}(_a=this.gameStateSub)===null||_a===void 0?void 0:_a.destroy();(_b=this.earthColorsSub)===null||_b===void 0?void 0:_b.destroy();(_c=this.earthColorsElevationRangeSub)===null||_c===void 0?void 0:_c.destroy();(_d=this.skyColorSub)===null||_d===void 0?void 0:_d.destroy();(_e=this.referenceSub)===null||_e===void 0?void 0:_e.destroy();(_f=this.wxrModeSub)===null||_f===void 0?void 0:_f.destroy();(_g=this.wxrColorsSub)===null||_g===void 0?void 0:_g.destroy();(_h=this.resolutionSub)===null||_h===void 0?void 0:_h.destroy();(_j=this.isoLinesSub)===null||_j===void 0?void 0:_j.destroy();(_k=this.mapListener)===null||_k===void 0?void 0:_k.off('MapBinded',this.onListenerBound);(_l=this.mapListener)===null||_l===void 0?void 0:_l.off('MapUpdated',this.onMapUpdate);(_m=this.mapListener)===null||_m===void 0?void 0:_m.trigger('JS_UNBIND_BINGMAP',this.props.id);this.isListenerRegistered=false;this.imgRef.instance.src='';(_o=this.imgRef.instance.parentNode)===null||_o===void 0?void 0:_o.removeChild(this.imgRef.instance);super.destroy();}/**
       * Resets the img element's src attribute.
       */resetImgSrc(){const imgRef=this.imgRef.getOrDefault();if(imgRef!==null){const currentSrc=imgRef.src;imgRef.src='';imgRef.src=currentSrc;}}/**
       * Converts an HTML hex color string to a numerical RGB value, as `R + G * 256 + B * 256^2`.
       * @param hexColor The hex color string to convert.
       * @returns The numerical RGB value equivalent of the specified hex color string, as `R + G * 256 + B * 256^2`.
       */static hexaToRGBColor(hexColor){const hexStringColor=hexColor;let offset=0;if(hexStringColor[0]==='#'){offset=1;}const r=parseInt(hexStringColor.substr(0+offset,2),16);const g=parseInt(hexStringColor.substr(2+offset,2),16);const b=parseInt(hexStringColor.substr(4+offset,2),16);return BingComponent.rgbColor(r,g,b);}/**
       * Converts a numerical RGB value to an HTML hex color string.
       * @param rgb The numerical RGB value to convert, as `R + G * 256 + B * 256^2`.
       * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
       * @returns The HTML hex color string equivalent of the specified numerical RGB value.
       */static rgbToHexaColor(rgb){let poundPrefix=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const b=Math.floor(rgb%(256*256*256)/(256*256));const g=Math.floor(rgb%(256*256)/256);const r=rgb%256;return "".concat(poundPrefix?'#':'').concat(r.toString(16).padStart(2,'0')).concat(g.toString(16).padStart(2,'0')).concat(b.toString(16).padStart(2,'0'));}/**
       * Converts RGB color components to a numerical RGB value, as `R + G * 256 + B * 256^2`.
       * @param r The red component, from 0 to 255.
       * @param g The green component, from 0 to 255.
       * @param b The blue component, from 0 to 255.
       * @returns The numerical RGB value of the specified components, as `R + G * 256 + B * 256^2`.
       */static rgbColor(r,g,b){return 256*256*b+256*g+r;}/**
       * Converts an HTML hex color string to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
       * @param hexColor The hex color string to convert.
       * @returns The numerical RGBA value equivalent of the specified hex color string, as
       * `R + G * 256 + B * 256^2 + A * 256^3`.
       */static hexaToRGBAColor(hexColor){const hexStringColor=hexColor;let offset=0;if(hexStringColor[0]==='#'){offset=1;}const r=parseInt(hexStringColor.substr(0+offset,2),16);const g=parseInt(hexStringColor.substr(2+offset,2),16);const b=parseInt(hexStringColor.substr(4+offset,2),16);const a=parseInt(hexStringColor.substr(6+offset,2),16);return BingComponent.rgbaColor(r,g,b,a);}/**
       * Converts a numerical RGBA value to an HTML hex color string.
       * @param rgba The numerical RGBA value to convert, as `R + G * 256 + B * 256^2 + A * 256^3`.
       * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
       * @returns The HTML hex color string equivalent of the specified numerical RGBA value.
       */static rgbaToHexaColor(rgba){let poundPrefix=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;const a=Math.floor(rgba%(256*256*256*256)/(256*256*256));const b=Math.floor(rgba%(256*256*256)/(256*256));const g=Math.floor(rgba%(256*256)/256);const r=rgba%256;return "".concat(poundPrefix?'#':'').concat(r.toString(16).padStart(2,'0')).concat(g.toString(16).padStart(2,'0')).concat(b.toString(16).padStart(2,'0')).concat(a.toString(16).padStart(2,'0'));}/**
       * Converts RGBA color components to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
       * @param r The red component, from 0 to 255.
       * @param g The green component, from 0 to 255.
       * @param b The blue component, from 0 to 255.
       * @param a The alpha component, from 0 to 255.
       * @returns The numerical RGBA value of the specified components, as `R + G * 256 + B * 256^2 + A * 256^3`.
       */static rgbaColor(r,g,b,a){return 256*256*256*a+256*256*b+256*g+r;}/**
       * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
       * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
       * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
       * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
       * feet and colors as hex strings with the format `#hhhhhh`.
       * @param minElevation The minimum elevation to which to assign a color, in feet. Defaults to 0.
       * @param maxElevation The maximum elevation to which to assign a color, in feet. Defaults to 30000.
       * @param stepCount The number of terrain color steps. Defaults to 61.
       * @returns a full Bing component earth colors array.
       */ // eslint-disable-next-line jsdoc/require-jsdoc
  static createEarthColorsArray(waterColor,terrainColors){let minElevation=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let maxElevation=arguments.length>3&&arguments[3]!==undefined?arguments[3]:30000;let stepCount=arguments.length>4&&arguments[4]!==undefined?arguments[4]:61;const earthColors=[BingComponent.hexaToRGBColor(waterColor)];const curve=new Avionics.Curve();curve.interpolationFunction=Avionics.CurveTool.StringColorRGBInterpolation;for(let i=0;i<terrainColors.length;i++){curve.add(terrainColors[i].elev,terrainColors[i].color);}const elevationStep=(maxElevation-minElevation)/Math.max(stepCount-1,1);for(let i=0;i<stepCount;i++){const color=curve.evaluate(minElevation+i*elevationStep);earthColors[i+1]=BingComponent.hexaToRGBColor(color);}return earthColors;}}/** The default resolution of the Bing Map along both horizontal and vertical axes, in pixels. */BingComponent.DEFAULT_RESOLUTION=1024;BingComponent.DEFAULT_WEATHER_COLORS=[[BingComponent.hexaToRGBAColor('#00000000'),0.5],[BingComponent.hexaToRGBAColor('#004d00ff'),2.75],[BingComponent.hexaToRGBAColor('#cb7300ff'),12.5],[BingComponent.hexaToRGBAColor('#ff0000ff'),12.5]];BingComponent.POSITION_RADIUS_INHIBIT_FRAMES=10;var DurationDisplayFormat;(function(DurationDisplayFormat){/** hh:mm:ss. */DurationDisplayFormat[DurationDisplayFormat["hh_mm_ss"]=0]="hh_mm_ss";/** hh:mm. */DurationDisplayFormat[DurationDisplayFormat["hh_mm"]=1]="hh_mm";/** mm:ss. */DurationDisplayFormat[DurationDisplayFormat["mm_ss"]=2]="mm_ss";/** hh:mm if value is greater or equal to 1 hour, otherwise mm:ss. */DurationDisplayFormat[DurationDisplayFormat["hh_mm_or_mm_ss"]=3]="hh_mm_or_mm_ss";})(DurationDisplayFormat||(DurationDisplayFormat={}));var DurationDisplayDelim;(function(DurationDisplayDelim){/** Colon (`:`). */DurationDisplayDelim[DurationDisplayDelim["Colon"]=0]="Colon";/** `:` if hh:mm:ss or mm:ss, `+` if hh:mm. */DurationDisplayDelim[DurationDisplayDelim["ColonOrCross"]=1]="ColonOrCross";/** Space (` `). */DurationDisplayDelim[DurationDisplayDelim["Space"]=2]="Space";})(DurationDisplayDelim||(DurationDisplayDelim={}));/**
   * A component which displays duration values.
   */class DurationDisplay extends DisplayComponent{/** @inheritdoc */constructor(props){super(props);this.value='isSubscribable'in this.props.value?this.props.value:Subject.create(this.props.value);this.options=Object.assign({},DurationDisplay.DEFAULT_OPTIONS,this.props.options);this.negativeSign=this.options.useMinusSign?'':'-';this.positiveSign=this.options.forceSign?'+':'';this.text=Subject.create('');switch(this.options.delim){case DurationDisplayDelim.Colon:this.delim=':';break;case DurationDisplayDelim.Space:this.delim=' ';break;default:this.delim='';}}/** @inheritdoc */onAfterRender(){this.valueSub=this.value.sub(this.onValueChanged.bind(this),true);}/**
       * A callback which is called when this component's bound value changes.
       * @param value The new value.
       */onValueChanged(value){this.setDisplay(value);}/**
       * Displays this component's current value.
       * @param value The current value.
       */setDisplay(value){let text;if(value.isNaN()){text=this.options.nanString;}else {let hrText='';let minText='';let secText='';let hrUnitText='';let minUnitText='';let secUnitText='';let hrDelim='';let minDelim='';const valueAsSeconds=Math.abs(value.asUnit(UnitType.SECOND));const isNegative=value.number<0;let hours=Math.floor(valueAsSeconds/3600);if(this.options.format!=DurationDisplayFormat.mm_ss&&!(this.options.format===DurationDisplayFormat.hh_mm_or_mm_ss&&hours==0)){hrText=hours.toFixed(0);if(this.options.delim===DurationDisplayDelim.ColonOrCross){if(this.options.format===DurationDisplayFormat.hh_mm_or_mm_ss||this.options.format===DurationDisplayFormat.hh_mm){hrDelim='+';}else {hrDelim=':';}}else {hrDelim=this.delim;}}const hoursInMinutes=hours*60;let minutes;let seconds;if(this.options.format===DurationDisplayFormat.hh_mm||this.options.format===DurationDisplayFormat.hh_mm_or_mm_ss&&hours!==0){minutes=valueAsSeconds/60-hoursInMinutes;minText=this.options.numberFormatter(minutes);}else {minutes=Math.floor(valueAsSeconds/60-hoursInMinutes);minText=minutes.toFixed(0);minDelim=this.options.delim===DurationDisplayDelim.ColonOrCross?':':this.delim;seconds=valueAsSeconds-(hoursInMinutes+minutes)*60;secText=this.options.numberFormatter(seconds);}if(secText&&secText.replace(/\b0+/,'').substring(0,2)==='60'){seconds=parseFloat(secText)-60;minutes++;secText=this.options.numberFormatter(seconds);minText="".concat(minutes);}if(minText&&minText.replace(/\b0+/,'').substring(0,2)==='60'&&hrText){if(secText){minutes=0;minText='00';}else {minutes=parseFloat(minText)-60;minText=this.options.numberFormatter(minutes);}hours++;hrText="".concat(hours);}// pad parts with leading zeroes
  if(hrText){hrText=hrText.padStart(this.options.pad,'0');if(secText){minText=minText.padStart(2,'0');secText=DurationDisplay.padIntegerPart(secText.replace(/^0+/,''),2,'0');}else {minText=DurationDisplay.padIntegerPart(minText.replace(/^0+/,''),2,'0');}}else {minText=minText.padStart(this.options.pad,'0');secText=DurationDisplay.padIntegerPart(secText.replace(/^0+/,''),2,'0');}// format units
  if(this.options.showUnits){hrText&&(hrUnitText=this.options.unitFormatter(parseFloat(hrText),UnitType.HOUR));minUnitText=this.options.unitFormatter(parseFloat(minText),UnitType.MINUTE);secText&&(secUnitText=this.options.unitFormatter(parseFloat(secText),UnitType.SECOND));}// compute sign
  const sign=isNegative?this.negativeSign:this.positiveSign;text="".concat(sign).concat(hrText).concat(hrUnitText).concat(hrDelim).concat(minText).concat(minUnitText).concat(minDelim).concat(secText).concat(secUnitText);}this.text.set(text);}/**
       * Pads the integer part of a string which represents a number.
       * @param str A string which represents a number.
       * @param maxLength The length to which the integer part of the string will be padded.
       * @param fillString The string with which to pad the original string.
       * @returns a new string which is the result of padding the original string.
       */static padIntegerPart(str,maxLength,fillString){const decimalIndex=str.indexOf('.');return str.padStart(decimalIndex<0?maxLength:str.length-decimalIndex+maxLength,fillString);}/** @inheritdoc */render(){var _a;return FSComponent.buildComponent("div",{class:(_a=this.props.class)!==null&&_a!==void 0?_a:'',style:'white-space: nowrap;'},this.text);}/** @inheritdoc */destroy(){var _a;(_a=this.valueSub)===null||_a===void 0?void 0:_a.destroy();}}/** Default formatting options. */DurationDisplay.DEFAULT_OPTIONS={pad:0,format:DurationDisplayFormat.hh_mm_ss,delim:DurationDisplayDelim.Colon,showUnits:false,numberFormatter:value=>value.toFixed(0),unitFormatter:(value,unit)=>unit.name[0],useMinusSign:false,forceSign:false,nanString:''};var DmsDirection;(function(DmsDirection){DmsDirection["NORTH"]="N";DmsDirection["SOUTH"]="S";DmsDirection["WEST"]="W";DmsDirection["EAST"]="E";})(DmsDirection||(DmsDirection={}));/**
   * The item position to focus a component's children when performing a focus operation.
   */var FocusPosition;(function(FocusPosition){/** The component's most recently focused descendants will be focused. */FocusPosition["MostRecent"]="MostRecent";/** The first focus-able child at each node in the descendant tree will be focused. */FocusPosition["First"]="First";/** The last focus-able child at each node in the descendant tree will be focused. */FocusPosition["Last"]="Last";/** No child components will be focused. */FocusPosition["None"]="None";})(FocusPosition||(FocusPosition={}));/**
   * A strategy to focus a component's children as part of a blur reconciliation operation.
   */var BlurReconciliation;(function(BlurReconciliation){/** The component's first focus-able child will be focused. */BlurReconciliation["First"]="First";/** The component's last focus-able child will be focused. */BlurReconciliation["Last"]="Last";/**
       * The component's next focus-able child after the child that was blurred will be focused. If no such child exists,
       * then the last focus-able child before the child that was blurred will be focused.
       */BlurReconciliation["Next"]="Next";/**
       * The component's last focus-able child before the child that was blurred will be focused. If no such child exists,
       * then the next focus-able child after the child that was blurred will be focused.
       */BlurReconciliation["Prev"]="Prev";/** No child components will be focused. */BlurReconciliation["None"]="None";})(BlurReconciliation||(BlurReconciliation={}));/**
   * The different types of horizon projection changes.
   */var HorizonProjectionChangeType;(function(HorizonProjectionChangeType){HorizonProjectionChangeType[HorizonProjectionChangeType["Position"]=1]="Position";HorizonProjectionChangeType[HorizonProjectionChangeType["Altitude"]=2]="Altitude";HorizonProjectionChangeType[HorizonProjectionChangeType["Heading"]=4]="Heading";HorizonProjectionChangeType[HorizonProjectionChangeType["Pitch"]=8]="Pitch";HorizonProjectionChangeType[HorizonProjectionChangeType["Roll"]=16]="Roll";HorizonProjectionChangeType[HorizonProjectionChangeType["Offset"]=32]="Offset";HorizonProjectionChangeType[HorizonProjectionChangeType["ProjectedSize"]=64]="ProjectedSize";HorizonProjectionChangeType[HorizonProjectionChangeType["Fov"]=128]="Fov";HorizonProjectionChangeType[HorizonProjectionChangeType["FovEndpoints"]=256]="FovEndpoints";HorizonProjectionChangeType[HorizonProjectionChangeType["ScaleFactor"]=512]="ScaleFactor";HorizonProjectionChangeType[HorizonProjectionChangeType["ProjectedOffset"]=1024]="ProjectedOffset";HorizonProjectionChangeType[HorizonProjectionChangeType["OffsetCenterProjected"]=2048]="OffsetCenterProjected";})(HorizonProjectionChangeType||(HorizonProjectionChangeType={}));[Vec2Math.create()];[Vec3Math.create()];[new GeoPoint(0,0)];[Vec3Math.create()];/**
   * A base component for map layers.
   */class MapLayer extends DisplayComponent{constructor(){super(...arguments);this._isVisible=true;}/**
       * Checks whether this layer is visible.
       * @returns whether this layer is visible.
       */isVisible(){return this._isVisible;}/**
       * Sets this layer's visibility.
       * @param val Whether this layer should be visible.
       */setVisible(val){if(this._isVisible===val){return;}this._isVisible=val;this.onVisibilityChanged(val);}/**
       * This method is called when this layer's visibility changes.
       * @param isVisible Whether the layer is now visible.
       */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onVisibilityChanged(isVisible){// noop
  }/**
       * This method is called when this layer is attached to its parent map component.
       */onAttached(){// noop
  }/**
       * This method is called when this layer's parent map is woken.
       */onWake(){// noop
  }/**
       * This method is called when this layer's parent map is put to sleep.
       */onSleep(){// noop
  }/**
       * This method is called when the map projection changes.
       * @param mapProjection - this layer's map projection.
       * @param changeFlags The types of changes made to the projection.
       */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMapProjectionChanged(mapProjection,changeFlags){// noop
  }/**
       * This method is called once every map update cycle.
       * @param time The current time as a UNIX timestamp.
       * @param elapsed The elapsed time, in milliseconds, since the last update.
       */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdated(time,elapsed){// noop
  }/**
       * This method is called when this layer is detached from its parent map component.
       */onDetached(){// noop
  }}/**
   * The different types of map projection changes.
   */var MapProjectionChangeType;(function(MapProjectionChangeType){MapProjectionChangeType[MapProjectionChangeType["Target"]=1]="Target";MapProjectionChangeType[MapProjectionChangeType["Center"]=2]="Center";MapProjectionChangeType[MapProjectionChangeType["TargetProjected"]=4]="TargetProjected";MapProjectionChangeType[MapProjectionChangeType["Range"]=8]="Range";MapProjectionChangeType[MapProjectionChangeType["RangeEndpoints"]=16]="RangeEndpoints";MapProjectionChangeType[MapProjectionChangeType["ScaleFactor"]=32]="ScaleFactor";MapProjectionChangeType[MapProjectionChangeType["Rotation"]=64]="Rotation";MapProjectionChangeType[MapProjectionChangeType["ProjectedSize"]=128]="ProjectedSize";MapProjectionChangeType[MapProjectionChangeType["ProjectedResolution"]=256]="ProjectedResolution";})(MapProjectionChangeType||(MapProjectionChangeType={}));UnitType.GA_RADIAN.convertTo(1,UnitType.NMILE);new GeoPoint(0,0);new GeoPoint(0,0);[Vec3Math.create()];/**
   * A path stream which does nothing on any input.
   */class NullPathStream{/**
       * Does nothing.
       */beginPath(){// noop
  }/**
       * Does nothing.
       */moveTo(){// noop
  }/**
       * Does nothing.
       */lineTo(){// noop
  }/**
       * Does nothing.
       */bezierCurveTo(){// noop
  }/**
       * Does nothing.
       */quadraticCurveTo(){// noop
  }/**
       * Does nothing.
       */arc(){// noop
  }/**
       * Does nothing.
       */closePath(){// noop
  }}/** An instance of a {@link NullPathStream}. */NullPathStream.INSTANCE=new NullPathStream();/**
   * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
   * stream.
   */class AbstractTransformingPathStream{/**
       * Constructor.
       * @param consumer The path stream that consumes this stream's transformed output.
       */constructor(consumer){this.consumer=consumer;}/** @inheritdoc */getConsumer(){return this.consumer;}/** @inheritdoc */setConsumer(consumer){this.consumer=consumer;}}/**
   * Bitflags describing the relative location of a point with respect to a rectangular bounding box.
   */var Outcode;(function(Outcode){Outcode[Outcode["Inside"]=0]="Inside";Outcode[Outcode["Left"]=1]="Left";Outcode[Outcode["Top"]=2]="Top";Outcode[Outcode["Right"]=4]="Right";Outcode[Outcode["Bottom"]=8]="Bottom";})(Outcode||(Outcode={}));/**
   * A path stream which performs clipping to an axis-aligned rectangular bounding box before sending the clipped path
   * to another stream. Clipping is only supported for path segments added via the `lineTo()` and `arc()` methods. Path
   * segments added via `bezierCurveTo()` and `quadraticCurveTo()` will be passed to the consumer stream unclipped.
   */class ClippedPathStream extends AbstractTransformingPathStream{/**
       * Constructor.
       * @param consumer The path stream that consumes this stream's transformed output.
       * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
       * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
       */constructor(consumer,bounds){super(consumer);this.bounds=bounds;this.boundsHandler=this.onBoundsChanged.bind(this);this.boundsLines=[new Float64Array(3),new Float64Array(3),new Float64Array(3),new Float64Array(3)];this.isBoundingRectNonZero=false;this.firstPoint=new Float64Array([NaN,NaN]);this.prevPoint=new Float64Array([NaN,NaN]);this.prevPointOutcode=0;bounds.sub(this.boundsHandler,true);}/** @inheritdoc */beginPath(){this.reset();this.consumer.beginPath();}/** @inheritdoc */moveTo(x,y){if(!this.isBoundingRectNonZero){return;}if(!(isFinite(x)&&isFinite(y))){return;}if(this.prevPoint[0]===x&&this.prevPoint[1]===y){return;}if(isNaN(this.firstPoint[0])){Vec2Math.set(x,y,this.firstPoint);}Vec2Math.set(x,y,this.prevPoint);this.prevPointOutcode=this.getOutcode(x,y);if(this.prevPointOutcode===0){this.consumer.moveTo(x,y);}}/** @inheritdoc */lineTo(x,y){if(!this.isBoundingRectNonZero){return;}if(!(isFinite(x)&&isFinite(y))){return;}if(this.prevPoint[0]===x&&this.prevPoint[1]===y){return;}if(isNaN(this.prevPoint[0])){this.moveTo(x,y);return;}const outcode=this.getOutcode(x,y);if((this.prevPointOutcode|outcode)===0){// Both the previous point and current point are within bounds.
  this.consumer.lineTo(x,y);}else if((this.prevPointOutcode&outcode)===0){// One or both of the previous point and current point are out of bounds, and the line connecting them may
  // cross through the bounding rect
  const bounds=this.bounds.get();const line=ClippedPathStream.getLineCoordinates(this.prevPoint[0],this.prevPoint[1],x,y,ClippedPathStream.vec3Cache[1]);let entryPoint,exitPoint;const outcodeOr=this.prevPointOutcode|outcode;if((outcodeOr&~(Outcode.Left|Outcode.Right))===0||(outcodeOr&~(Outcode.Top|Outcode.Bottom))===0){// The connecting line does not cross zones diagonally -> no need to check if the intersection of the line and
  // boundary falls outside the bounds of the orthogonal axis.
  // find entry point
  for(let i=0;i<4;i++){if(this.prevPointOutcode&1<<i){entryPoint=ClippedPathStream.findLineLineIntersection(line,this.boundsLines[i],ClippedPathStream.vec2Cache[0]);break;}}// find exit point
  for(let i=0;i<4;i++){if(outcode&1<<i){exitPoint=ClippedPathStream.findLineLineIntersection(line,this.boundsLines[i],ClippedPathStream.vec2Cache[1]);break;}}}else {// find entry point
  for(let i=0;i<4;i++){if(this.prevPointOutcode&1<<i){const boundsAxisIndex=i%2;const intersection=ClippedPathStream.findLineLineIntersection(line,this.boundsLines[i],ClippedPathStream.vec2Cache[0]);if(intersection&&intersection[boundsAxisIndex]>=bounds[boundsAxisIndex]&&intersection[boundsAxisIndex]<=bounds[boundsAxisIndex+2]){entryPoint=intersection;break;}}}// find exit point
  for(let i=0;i<4;i++){if(outcode&1<<i){const boundsAxisIndex=i%2;const intersection=ClippedPathStream.findLineLineIntersection(line,this.boundsLines[i],ClippedPathStream.vec2Cache[1]);if(intersection&&intersection[boundsAxisIndex]>=bounds[boundsAxisIndex]&&intersection[boundsAxisIndex]<=bounds[boundsAxisIndex+2]){exitPoint=intersection;break;}}}}if(entryPoint){this.consumer.moveTo(entryPoint[0],entryPoint[1]);}if(exitPoint){this.consumer.lineTo(exitPoint[0],exitPoint[1]);}else if(outcode===Outcode.Inside){this.consumer.lineTo(x,y);}}Vec2Math.set(x,y,this.prevPoint);this.prevPointOutcode=outcode;}/** @inheritdoc */bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){if(!this.isBoundingRectNonZero){return;}if(!(isFinite(x)&&isFinite(y)&&isFinite(cp1x)&&isFinite(cp1y)&&isFinite(cp2x)&&isFinite(cp2y))){return;}if(isNaN(this.prevPoint[0])){this.moveTo(x,y);return;}if(this.prevPointOutcode!==Outcode.Inside){this.consumer.moveTo(this.prevPoint[0],this.prevPoint[1]);}this.consumer.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);Vec2Math.set(x,y,this.prevPoint);this.prevPointOutcode=this.getOutcode(x,y);}/** @inheritdoc */quadraticCurveTo(cpx,cpy,x,y){if(!this.isBoundingRectNonZero){return;}if(!(isFinite(x)&&isFinite(y)&&isFinite(cpx)&&isFinite(cpy))){return;}if(isNaN(this.prevPoint[0])){this.moveTo(x,y);return;}if(this.prevPointOutcode!==Outcode.Inside){this.consumer.moveTo(this.prevPoint[0],this.prevPoint[1]);}this.consumer.quadraticCurveTo(cpx,cpy,x,y);Vec2Math.set(x,y,this.prevPoint);this.prevPointOutcode=this.getOutcode(x,y);}/** @inheritdoc */arc(x,y,radius,startAngle,endAngle){let counterClockwise=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;if(!this.isBoundingRectNonZero){return;}if(!(isFinite(x)&&isFinite(y)&&isFinite(radius)&&isFinite(startAngle)&&isFinite(endAngle))){return;}if(radius===0||startAngle===endAngle){return;}const pi2=2*Math.PI;const directionSign=counterClockwise?-1:1;if(Math.sign(endAngle-startAngle)!==directionSign){// Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
  // doesn't match the counterClockwise flag.
  const angleDiff=((counterClockwise?startAngle-endAngle:endAngle-startAngle)%pi2+pi2)%pi2;endAngle=startAngle+angleDiff*directionSign;}// Clamp to 2pi because we don't need to draw anything past a full circle.
  const angularWidth=Math.min(pi2,(endAngle-startAngle)*directionSign);const bounds=this.bounds.get();const radiusSq=radius*radius;const startPoint=Vec2Math.add(Vec2Math.set(x,y,ClippedPathStream.vec2Cache[2]),Vec2Math.setFromPolar(radius,startAngle,ClippedPathStream.vec2Cache[0]),ClippedPathStream.vec2Cache[2]);const startPointOutcode=this.getOutcode(startPoint[0],startPoint[1]);const endPoint=Vec2Math.add(Vec2Math.set(x,y,ClippedPathStream.vec2Cache[3]),Vec2Math.setFromPolar(radius,endAngle,ClippedPathStream.vec2Cache[0]),ClippedPathStream.vec2Cache[3]);const endPointOutcode=this.getOutcode(endPoint[0],endPoint[1]);if(isNaN(this.prevPoint[0])){this.moveTo(startPoint[0],startPoint[1]);}else if(!Vec2Math.equals(this.prevPoint,startPoint)){this.lineTo(startPoint[0],startPoint[1]);}// find all intersections of the arc circle with the clipping bounds; there can be up to 8 (two for each boundary
  // line)
  const intersections=ClippedPathStream.intersectionCache;let intersectionCount=0;for(let i=0;i<4;i++){const axisCoordIndex=i%2;const crossAxisCoordIndex=(i+1)%2;const centerAxisCoord=i%2===0?x:y;const centerCrossAxisCoord=i%2===0?y:x;const deltaToBound=bounds[i]-centerAxisCoord;if(Math.abs(deltaToBound)<radius){const crossAxisBoundMin=bounds[crossAxisCoordIndex];const crossAxisBoundMax=bounds[crossAxisCoordIndex+2];//const radialOffset = Math.acos(deltaToBound / radius);
  const crossAxisOffset=Math.sqrt(radiusSq-deltaToBound*deltaToBound);let intersectionRadialOffset;{const intersectionCrossAxisCoord=centerCrossAxisCoord+crossAxisOffset;if(intersectionCrossAxisCoord>=crossAxisBoundMin&&intersectionCrossAxisCoord<=crossAxisBoundMax){const intersection=intersections[intersectionCount];intersection.point[axisCoordIndex]=bounds[i];intersection.point[crossAxisCoordIndex]=intersectionCrossAxisCoord;const radial=axisCoordIndex*Math.PI/2+(intersectionRadialOffset!==null&&intersectionRadialOffset!==void 0?intersectionRadialOffset:intersectionRadialOffset=Math.acos(deltaToBound/radius))*(axisCoordIndex===0?1:-1);intersection.radial=(radial+pi2)%pi2;// [0, 2 * pi)
  intersectionCount++;}}{const intersectionCrossAxisCoord=centerCrossAxisCoord-crossAxisOffset;if(intersectionCrossAxisCoord>=crossAxisBoundMin&&intersectionCrossAxisCoord<=crossAxisBoundMax){const intersection=intersections[intersectionCount];intersection.point[axisCoordIndex]=bounds[i];intersection.point[crossAxisCoordIndex]=intersectionCrossAxisCoord;const radial=axisCoordIndex*Math.PI/2-(intersectionRadialOffset!==null&&intersectionRadialOffset!==void 0?intersectionRadialOffset:intersectionRadialOffset=Math.acos(deltaToBound/radius))*(axisCoordIndex===0?1:-1);intersection.radial=(radial+pi2)%pi2;// [0, 2 * pi)
  intersectionCount++;}}}}// Begin at the start radial, then in order (either clockwise or counterclockwise depending on the arc direction)
  // iterate through the intersection points. At each intersection, move to the point if we are currently out of
  // bounds or path an arc from the last visited radial to the point if we are inbounds. Every time we visit an
  // intersection we go from out of bounds to in bounds and vice versa. Stop when the radial to the intersection
  // is past the end radial of the arc.
  let isOutside=startPointOutcode!==Outcode.Inside;const startAngleNormalized=(startAngle%pi2+pi2)%pi2;// [0, 2 * pi)
  let lastRadial=startAngleNormalized;let intersectionStartIndex=-1;let minAngularDiff=Infinity;for(let i=0;i<intersectionCount;i++){const angularDiff=((intersections[i].radial-startAngleNormalized)*directionSign+pi2)%pi2;if(angularDiff<minAngularDiff){intersectionStartIndex=i;minAngularDiff=angularDiff;}}if(intersectionStartIndex>=0){for(let i=0;i<intersectionCount;i++){const index=(intersectionStartIndex+intersectionCount+i*directionSign)%intersectionCount;const intersection=intersections[index];if(((intersection.radial-startAngleNormalized)*directionSign+pi2)%pi2>=angularWidth){break;}if(isOutside){this.consumer.moveTo(intersection.point[0],intersection.point[1]);}else {const segmentAngularWidth=((intersection.radial-lastRadial)*directionSign+pi2)%pi2;this.consumer.arc(x,y,radius,lastRadial,lastRadial+segmentAngularWidth*directionSign,counterClockwise);}isOutside=!isOutside;lastRadial=intersection.radial;}}const endAngleNormalized=(startAngleNormalized+angularWidth*directionSign+pi2)%pi2;// [0, 2 * pi)
  if(!isOutside){const segmentAngularWidth=((endAngleNormalized-lastRadial)*directionSign+pi2)%pi2;this.consumer.arc(x,y,radius,lastRadial,lastRadial+segmentAngularWidth*directionSign,counterClockwise);if(Math.abs((endAngleNormalized-endAngle)%pi2)>1e-14){// This can happen if we clamped the angular width to 2pi -> we need to move the current point to the actual
  // end point to keep the state of the consumer stream consistent with ours.
  this.consumer.moveTo(endPoint[0],endPoint[1]);}}Vec2Math.copy(endPoint,this.prevPoint);this.prevPointOutcode=endPointOutcode;}/** @inheritdoc */closePath(){if(!isNaN(this.firstPoint[0])){this.lineTo(this.firstPoint[0],this.firstPoint[1]);}}/**
       * Resets the state of this stream.
       */reset(){Vec2Math.set(NaN,NaN,this.firstPoint);Vec2Math.set(NaN,NaN,this.prevPoint);this.prevPointOutcode=0;}/**
       * Gets the Cohen-Sutherland outcode for a point.
       * @param x The x-coordinate of the query point.
       * @param y The y-coordinate of the query point.
       * @returns The outcode for the point.
       */getOutcode(x,y){const bounds=this.bounds.get();let code=0;if(x<bounds[0]){code|=Outcode.Left;}else if(x>bounds[2]){code|=Outcode.Right;}if(y<bounds[1]){code|=Outcode.Top;}else if(y>bounds[3]){code|=Outcode.Bottom;}return code;}/**
       * Handles clipping bounds change events.
       */onBoundsChanged(){const bounds=this.bounds.get();Vec3Math.set(1,0,-bounds[0],this.boundsLines[0]);Vec3Math.set(0,1,-bounds[1],this.boundsLines[1]);Vec3Math.set(1,0,-bounds[2],this.boundsLines[2]);Vec3Math.set(0,1,-bounds[3],this.boundsLines[3]);this.isBoundingRectNonZero=bounds[0]<bounds[2]&&bounds[1]<bounds[3];this.beginPath();}/**
       * Destroys this stream.
       */destroy(){this.bounds.unsub(this.boundsHandler);}/**
       * Gets the line coordinate vector for a line passing through two points.
       * @param x1 The x-coordinate of the first point on the line.
       * @param y1 The y-coordinate of the first point on the line.
       * @param x2 The x-coordinate of the second point on the line.
       * @param y2 The y-coordinate of the second point on the line.
       * @param out A Float64Array object to which to write the result.
       * @returns The line coordinate vector of the line passing through the two points.
       */static getLineCoordinates(x1,y1,x2,y2,out){const a=y1-y2;const b=x2-x1;const c=-(a*x1+b*y1);return Vec3Math.set(a,b,c,out);}/**
       * Finds the intersection point between two lines in 2D Euclidean space.
       * @param line1 The line coordinate vector of the first line.
       * @param line2 The line coordinate vector of the second line.
       * @param out A Float64Array object to which to write the result.
       * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
       */static findLineLineIntersection(line1,line2,out){const cross=Vec3Math.cross(line1,line2,ClippedPathStream.vec3Cache[0]);const w=cross[2];if(w===0){return undefined;}return Vec2Math.set(cross[0]/w,cross[1]/w,out);}}ClippedPathStream.vec2Cache=[new Float64Array(2),new Float64Array(2),new Float64Array(2),new Float64Array(2)];ClippedPathStream.vec3Cache=[new Float64Array(3),new Float64Array(3)];ClippedPathStream.intersectionCache=Array.from({length:8},()=>{return {point:new Float64Array(2),radial:0};});/**
   * A path stream which transforms a path stream in geographic spherical coordinates to one in projected planar
   * coordinates.
   */class GeoProjectionPathStream extends AbstractTransformingPathStream{// eslint-disable-next-line jsdoc/require-jsdoc
  constructor(consumer,projection,arg1,arg2,arg3){super(consumer);this.projection=projection;this.firstPoint=new GeoPoint(NaN,NaN);this.prevPoint=new GeoPoint(NaN,NaN);this.prevPointProjected=new Float64Array(2);this.resampleHandler=this.onResampled.bind(this);if(arg1 instanceof GeoCircleResampler){this.resampler=arg1;}else {this.resampler=new GeoCircleResampler(arg1,arg2,arg3);}}/**
       * Gets the projection used by this stream.
       * @returns The projection used by this stream.
       */getProjection(){return this.projection;}/**
       * Sets the projection used by this stream.
       * @param projection A projection.
       */setProjection(projection){this.projection=projection;}/** @inheritdoc */beginPath(){this.reset();this.consumer.beginPath();}/**
       * Moves to a specified point.
       * @param lon The longitude of the point to which to move, in degrees.
       * @param lat The latitude of the point to which to move, in degrees.
       */moveTo(lon,lat){if(!(isFinite(lon)&&isFinite(lat))){return;}if(isNaN(this.firstPoint.lat)){this.firstPoint.set(lat,lon);}this.prevPoint.set(lat,lon);const projected=this.projection.project(this.prevPoint,this.prevPointProjected);this.consumer.moveTo(projected[0],projected[1]);}/**
       * Paths a great-circle arc from the current point to a specified point.
       * @param lon The longitude of the end point, in degrees.
       * @param lat The latitude of the end point, in degrees.
       * @throws Error if the specified point is antipodal to the last pathed point.
       */lineTo(lon,lat){if(!(isFinite(lon)&&isFinite(lat))){return;}if(!isNaN(this.prevPoint.lat)&&this.prevPoint.equals(lat,lon)){return;}if(isNaN(this.prevPoint.lat)){this.moveTo(lon,lat);return;}const point=GeoProjectionPathStream.geoPointCache[0].set(lat,lon);const circle=GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint,point);if(!isFinite(circle.center[0])){throw new Error("Cannot unambiguously path a great circle from ".concat(this.prevPoint.lat," lat, ").concat(this.prevPoint.lon," lon to ").concat(lat," lat, ").concat(lon," lon"));}this.resampler.resample(this.projection,circle,this.prevPoint,point,this.resampleHandler);this.prevPoint.set(lat,lon);}/**
       * Not supported by this path stream.
       * @throws Error when called.
       */bezierCurveTo(){throw new Error('GeodesicResamplerStream: bezierCurveTo() is not supported');}/**
       * Not supported by this path stream.
       * @throws Error when called.
       */quadraticCurveTo(){throw new Error('GeodesicResamplerStream: quadraticCurveTo() is not supported');}/**
       * Paths a small-circle arc.
       * @param lon The longitude of the center of the circle containing the arc, in degrees.
       * @param lat The latitude of the center of the circle containing the arc, in degrees.
       * @param radius The radius of the arc, in great-arc radians.
       * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
       * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
       * of the arc.
       * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
       * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
       * the arc.
       * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
       */arc(lon,lat,radius,startAngle,endAngle,counterClockwise){if(!(isFinite(lon)&&isFinite(lat)&&isFinite(radius)&&isFinite(startAngle)&&isFinite(endAngle))){return;}if(radius===0||Math.abs(startAngle-endAngle)<=GeoCircle.ANGULAR_TOLERANCE*Avionics.Utils.RAD2DEG){return;}if(MathUtils.diffAngle(startAngle*Avionics.Utils.DEG2RAD,endAngle*Avionics.Utils.DEG2RAD,false)<=GeoCircle.ANGULAR_TOLERANCE){// Since we early return above if startAngle and endAngle are equal, hitting this case means they are a multiple
  // of 360 degrees apart. The resampler will interpret them as being the same point and won't draw a full circle
  // so we will split the arc into two.
  const midAngle=startAngle+180*Math.sign(endAngle-startAngle);this.arc(lon,lat,radius,startAngle,midAngle,counterClockwise);this.arc(lon,lat,radius,midAngle,endAngle,counterClockwise);return;}const center=GeoProjectionPathStream.geoPointCache[1].set(lat,lon);const start=GeoProjectionPathStream.geoPointCache[2];const end=GeoProjectionPathStream.geoPointCache[3];if(Math.abs(lat)>=90-GeoCircle.ANGULAR_TOLERANCE*Avionics.Utils.RAD2DEG){// The center of the arc circle is one of the poles
  const circleLat=Math.sign(lat)*(MathUtils.HALF_PI-radius)*Avionics.Utils.RAD2DEG;start.set(circleLat,startAngle);end.set(circleLat,endAngle);}else {center.offset(startAngle,radius,start);center.offset(endAngle,radius,end);}if(isNaN(start.lat)||isNaN(start.lon)||isNaN(end.lat)||isNaN(end.lon)){return;}if(isNaN(this.prevPoint.lat)){this.moveTo(start.lon,start.lat);}else if(!start.equals(this.prevPoint)){this.lineTo(start.lon,start.lat);}const circle=GeoProjectionPathStream.geoCircleCache[0].set(center,radius);if(!counterClockwise){circle.reverse();}this.resampler.resample(this.projection,circle,start,end,this.resampleHandler);this.prevPoint.set(end);}/**
       * Paths a great-circle arc from the current point to the first point defined by the current path.
       */closePath(){if(!isNaN(this.firstPoint.lat)){this.lineTo(this.firstPoint.lon,this.firstPoint.lat);}}/**
       * Resets the state of this stream.
       */reset(){this.firstPoint.set(NaN,NaN);this.prevPoint.set(NaN,NaN);}/**
       * Handles resampled points.
       * @param vector A vector which describes the projected path terminating at the resampled point.
       */onResampled(vector){switch(vector.type){case'start':return;case'line':this.consumer.lineTo(vector.projected[0],vector.projected[1]);break;case'arc':this.consumer.arc(vector.projectedArcCenter[0],vector.projectedArcCenter[1],vector.projectedArcRadius,vector.projectedArcStartAngle,vector.projectedArcEndAngle,vector.projectedArcStartAngle>vector.projectedArcEndAngle);break;}Vec2Math.copy(vector.projected,this.prevPointProjected);}}GeoProjectionPathStream.geoPointCache=[new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0),new GeoPoint(0,0)];GeoProjectionPathStream.geoCircleCache=[new GeoCircle(new Float64Array(3),0)];/**
   * A {@link TransformingPathStream} which applies an affine transformation to its input.
   *
   * The types of transformation supported by this class are:
   * * Translation.
   * * Uniform scaling.
   * * Rotation.
   */class AffineTransformPathStream extends AbstractTransformingPathStream{constructor(){super(...arguments);this.transform=new Transform2D();this.concatCache=[];this.scale=1;this.rotation=0;}/**
       * Adds a translation to this stream's transformation.
       * @param x The x translation.
       * @param y The y translation.
       * @param order The order in which to add the translation (defaults to `'after'`):
       * * `'before'` - Applies the translation before this stream's current transformation.
       * * `'after'` - Applies the translation after this stream's current transformation.
       * @returns This stream, after its transformation has been changed.
       */addTranslation(x,y){let order=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'after';const translation=AffineTransformPathStream.transformCache[0].toTranslation(x,y);if(order==='before'){this.concatCache[0]=translation;this.concatCache[1]=this.transform;}else {this.concatCache[0]=this.transform;this.concatCache[1]=translation;}Transform2D.concat(this.transform,this.concatCache);return this;}/**
       * Adds a uniform scaling to this stream's transformation.
       * @param factor The scaling factor.
       * @param order The order in which to add the translation (defaults to `'after'`):
       * * `'before'` - Applies the scaling before this stream's current transformation.
       * * `'after'` - Applies the scaling after this stream's current transformation.
       * @returns This stream, after its transformation has been changed.
       */addScale(factor){let order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'after';const scale=AffineTransformPathStream.transformCache[0].toScale(factor,factor);if(order==='before'){this.concatCache[0]=scale;this.concatCache[1]=this.transform;}else {this.concatCache[0]=this.transform;this.concatCache[1]=scale;}Transform2D.concat(this.transform,this.concatCache);this.updateScaleRotation();return this;}/**
       * Adds a rotation to this stream's transformation.
       * @param angle The rotation angle, in radians.
       * @param order The order in which to add the translation (defaults to `'after'`):
       * * `'before'` - Applies the rotation before this stream's current transformation.
       * * `'after'` - Applies the rotation after this stream's current transformation.
       * @returns This stream, after its transformation has been changed.
       */addRotation(angle){let order=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'after';const rotation=AffineTransformPathStream.transformCache[0].toRotation(angle);if(order==='before'){this.concatCache[0]=rotation;this.concatCache[1]=this.transform;}else {this.concatCache[0]=this.transform;this.concatCache[1]=rotation;}Transform2D.concat(this.transform,this.concatCache);this.updateScaleRotation();return this;}/**
       * Resets this stream's transformation to the identity transformation.
       * @returns This stream, after its transformation has been changed.
       */resetTransform(){this.transform.toIdentity();this.updateScaleRotation();return this;}/** @inheritdoc */beginPath(){this.consumer.beginPath();}/** @inheritdoc */moveTo(x,y){const transformed=this.applyTransform(x,y);this.consumer.moveTo(transformed[0],transformed[1]);}/** @inheritdoc */lineTo(x,y){const transformed=this.applyTransform(x,y);this.consumer.lineTo(transformed[0],transformed[1]);}/** @inheritdoc */bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){const cp1Transformed=this.applyTransform(cp1x,cp1y);cp1x=cp1Transformed[0];cp1y=cp1Transformed[1];const cp2Transformed=this.applyTransform(cp2x,cp2y);cp2x=cp2Transformed[0];cp2y=cp2Transformed[1];const endTransformed=this.applyTransform(x,y);x=endTransformed[0];y=endTransformed[1];this.consumer.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);}/** @inheritdoc */quadraticCurveTo(cpx,cpy,x,y){const cpTransformed=this.applyTransform(cpx,cpy);cpx=cpTransformed[0];cpy=cpTransformed[1];const endTransformed=this.applyTransform(x,y);x=endTransformed[0];y=endTransformed[1];this.consumer.quadraticCurveTo(cpx,cpy,x,y);}/** @inheritdoc */arc(x,y,radius,startAngle,endAngle,counterClockwise){const transformed=this.applyTransform(x,y);this.consumer.arc(transformed[0],transformed[1],radius*this.scale,startAngle+this.rotation,endAngle+this.rotation,counterClockwise);}/** @inheritdoc */closePath(){this.consumer.closePath();}/**
       * Updates this stream's cached scale and rotation values from its transformation.
       */updateScaleRotation(){const params=this.transform.getParameters();this.scale=Math.sqrt(params[0]*params[0]+params[3]*params[3]);this.rotation=Math.atan2(params[3],params[0]);}/**
       * Applies this stream's transformation to a point.
       * @param x The x-coordinate of the point to transform.
       * @param y The y-coordinate of the point to transform.
       * @returns The transformed point.
       */applyTransform(x,y){const vec=Vec2Math.set(x,y,AffineTransformPathStream.vec2Cache[0]);return this.transform.apply(vec,vec);}}AffineTransformPathStream.vec2Cache=[new Float64Array(2)];AffineTransformPathStream.transformCache=[new Transform2D()];/**
   * A stack of {@link TransformingPathStream}s. Inputs are passed through the entire stack from top to bottom before the
   * final transformed output is sent to a consuming stream.
   */class TransformingPathStreamStack extends AbstractTransformingPathStream{constructor(){super(...arguments);this.stack=[];}/**
       * Adds a transforming path stream to the top of this stack.
       * @param stream A transforming path stream.
       */push(stream){var _a;stream.setConsumer((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer);this.stack.push(stream);}/**
       * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
       * {@link NullPathStream.INSTANCE}.
       * @returns The removed path stream, or undefined if this stack was empty.
       */pop(){const removed=this.stack.pop();removed===null||removed===void 0?void 0:removed.setConsumer(NullPathStream.INSTANCE);return removed;}/**
       * Adds a transforming path stream to the bottom of this stack.
       * @param stream A transforming path stream.
       */unshift(stream){const displaced=this.stack[0];displaced===null||displaced===void 0?void 0:displaced.setConsumer(stream);stream.setConsumer(this.consumer);this.stack.unshift(stream);}/**
       * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
       * {@link NullPathStream.INSTANCE}.
       * @returns The removed path stream, or undefined if this stack was empty.
       */shift(){var _a;const removed=this.stack.shift();removed===null||removed===void 0?void 0:removed.setConsumer(NullPathStream.INSTANCE);(_a=this.stack[0])===null||_a===void 0?void 0:_a.setConsumer(this.consumer);return removed;}/** @inheritdoc */setConsumer(consumer){var _a;(_a=this.stack[0])===null||_a===void 0?void 0:_a.setConsumer(consumer);super.setConsumer(consumer);}/** @inheritdoc */beginPath(){var _a;((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer).beginPath();}/** @inheritdoc */moveTo(x,y){var _a;((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer).moveTo(x,y);}/** @inheritdoc */lineTo(x,y){var _a;((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer).lineTo(x,y);}/** @inheritdoc */bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){var _a;((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer).bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);}/** @inheritdoc */quadraticCurveTo(cpx,cpy,x,y){var _a;((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer).quadraticCurveTo(cpx,cpy,x,y);}/** @inheritdoc */arc(x,y,radius,startAngle,endAngle,counterClockwise){var _a;((_a=this.stack[this.stack.length-1])!==null&&_a!==void 0?_a:this.consumer).arc(x,y,radius,startAngle,endAngle,counterClockwise);}/** @inheritdoc */closePath(){this.stack[this.stack.length-1].closePath();}}/**
   * A stack of {@link TransformingPathStream}s which transforms an input in spherical geographic coordinates to planar
   * projected coordinates. The stack contains two sub-stacks: a pre-projected stack which transforms the path before
   * it is projected, and a post-projected stack which transforms the projected path before it is sent to the consumer.
   * Transforming streams can be added to the top and bottom of each sub-stack. The input will be passed through each
   * stream in the pre-projected stack from top to bottom, then projected, then passed through each stream in the post-
   * projected stack from top to bottom, and the final transformed output will be passed to the consumer.
   */class GeoProjectionPathStreamStack extends AbstractTransformingPathStream{// eslint-disable-next-line jsdoc/require-jsdoc
  constructor(consumer,projection,arg1,arg2,arg3){super(consumer);this.postStack=new TransformingPathStreamStack(consumer);if(arg1 instanceof GeoCircleResampler){this.projectionStream=new GeoProjectionPathStream(this.postStack,projection,arg1);}else {this.projectionStream=new GeoProjectionPathStream(this.postStack,projection,arg1,arg2,arg3);}this.preStack=new TransformingPathStreamStack(this.projectionStream);}/**
       * Gets the projection used by this stream.
       * @returns The projection used by this stream.
       */getProjection(){return this.projectionStream.getProjection();}/**
       * Sets the projection used by this stream.
       * @param projection A projection.
       */setProjection(projection){this.projectionStream.setProjection(projection);}/**
       * Adds a transforming path stream to the top of the pre-projected stack.
       * @param stream A transforming path stream.
       */pushPreProjected(stream){this.preStack.push(stream);}/**
       * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
       * {@link NullPathStream.INSTANCE}.
       * @returns The removed path stream, or undefined if this stack was empty.
       */popPreProjected(){return this.preStack.pop();}/**
       * Adds a transforming path stream to the bottom of the pre-projected stack.
       * @param stream A transforming path stream.
       */unshiftPreProjected(stream){this.preStack.unshift(stream);}/**
       * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
       * {@link NullPathStream.INSTANCE}.
       * @returns The removed path stream, or undefined if this stack was empty.
       */shiftPreProjected(){return this.preStack.shift();}/**
       * Adds a transforming path stream to the top of the post-projected stack.
       * @param stream A transforming path stream.
       */pushPostProjected(stream){this.postStack.push(stream);}/**
       * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
       * {@link NullPathStream.INSTANCE}.
       * @returns The removed path stream, or undefined if this stack was empty.
       */popPostProjected(){return this.postStack.pop();}/**
       * Adds a transforming path stream to the bottom of the post-projected stack.
       * @param stream A transforming path stream.
       */unshiftPostProjected(stream){this.postStack.unshift(stream);}/**
       * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
       * to {@link NullPathStream.INSTANCE}.
       * @returns The removed path stream, or undefined if this stack was empty.
       */shiftPostProjected(){return this.postStack.shift();}/** @inheritdoc */setConsumer(consumer){this.postStack.setConsumer(consumer);super.setConsumer(consumer);}/** @inheritdoc */beginPath(){this.preStack.beginPath();}/** @inheritdoc */moveTo(x,y){this.preStack.moveTo(x,y);}/** @inheritdoc */lineTo(x,y){this.preStack.lineTo(x,y);}/** @inheritdoc */bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){this.preStack.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);}/** @inheritdoc */quadraticCurveTo(cpx,cpy,x,y){this.preStack.quadraticCurveTo(cpx,cpy,x,y);}/** @inheritdoc */arc(x,y,radius,startAngle,endAngle,counterClockwise){this.preStack.arc(x,y,radius,startAngle,endAngle,counterClockwise);}/** @inheritdoc */closePath(){this.preStack.closePath();}}[new GeoPoint(0,0),new GeoPoint(0,0)];/**
   * Parts of a flight plan leg path to render.
   */var FlightPathLegRenderPart;(function(FlightPathLegRenderPart){/** None. */FlightPathLegRenderPart[FlightPathLegRenderPart["None"]=0]="None";/** The ingress transition. */FlightPathLegRenderPart[FlightPathLegRenderPart["Ingress"]=1]="Ingress";/** The base path. */FlightPathLegRenderPart[FlightPathLegRenderPart["Base"]=2]="Base";/** The egress transition. */FlightPathLegRenderPart[FlightPathLegRenderPart["Egress"]=4]="Egress";/** The entire leg path. */FlightPathLegRenderPart[FlightPathLegRenderPart["All"]=7]="All";})(FlightPathLegRenderPart||(FlightPathLegRenderPart={}));[new GeoPoint(0,0),new GeoPoint(0,0)];[new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0),new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0)];[new GeoCircle(new Float64Array(3),0)];[new GeoPoint(0,0)];[new GeoPoint(0,0)];[new Transform2D(),new Transform2D()];[new GeoPoint(0,0),new GeoPoint(0,0)];[Vec2Math.create(),Vec2Math.create()];[Vec3Math.create(),Vec3Math.create()];/**
   * Map own airplane icon orientations.
   */var MapOwnAirplaneIconOrientation;(function(MapOwnAirplaneIconOrientation){MapOwnAirplaneIconOrientation["HeadingUp"]="HeadingUp";MapOwnAirplaneIconOrientation["TrackUp"]="TrackUp";MapOwnAirplaneIconOrientation["MapUp"]="MapUp";})(MapOwnAirplaneIconOrientation||(MapOwnAirplaneIconOrientation={}));/**
   * An abstract implementation of {@link CssTransform}
   */class AbstractCssTransform{/**
       * Constructor.
       * @param initialParams The transform's initial parameters.
       */constructor(initialParams){this.params=new Float64Array(initialParams);this.cachedParams=new Float64Array(initialParams);}/** @inheritdoc */resolve(){if(this.stringValue!==undefined&&VecNMath.equals(this.params,this.cachedParams)){return this.stringValue;}VecNMath.copy(this.params,this.cachedParams);this.stringValue=this.buildString(this.params);return this.stringValue;}}/**
   * A CSS `matrix` transform.
   */class CssMatrixTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
       */constructor(){super(CssMatrixTransform.DEFAULT_PARAMS);}// eslint-disable-next-line jsdoc/require-jsdoc
  set(arg1,skewY,skewX,scaleY,translateX,translateY){let scaleX;if(typeof arg1==='number'){scaleX=arg1;}else {[scaleX,skewX,skewY,scaleY,translateX,translateY]=arg1.getParameters();}this.params[0]=scaleX;this.params[1]=skewY;this.params[2]=skewX;this.params[3]=scaleY;this.params[4]=translateX;this.params[5]=translateY;}/** @inheritdoc */buildString(params){return "matrix(".concat(params.join(', '),")");}}CssMatrixTransform.DEFAULT_PARAMS=[1,0,0,1,0,0];/**
   * A CSS `rotate` transform.
   */class CssRotateTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
       * @param unit The angle unit to use for this transform.
       */constructor(unit){super(CssRotateTransform.DEFAULT_PARAMS);this.unit=unit;}/**
       * Sets this transform's rotation angle.
       * @param angle The angle to set.
       * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
       * to `0`.
       */set(angle){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?angle:MathUtils.round(angle,precision);}/** @inheritdoc */buildString(params){return "rotate(".concat(params[0]).concat(this.unit,")");}}CssRotateTransform.DEFAULT_PARAMS=[0];/**
   * A CSS `rotate3d` transform.
   */class CssRotate3dTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
       * @param unit The angle unit to use for this transform.
       */constructor(unit){super(CssRotate3dTransform.DEFAULT_PARAMS);this.unit=unit;}/**
       * Sets this transform's rotation.
       * @param x The x component of the rotation axis vector.
       * @param y The y component of the rotation axis vector.
       * @param z The z component of the rotation axis vector.
       * @param angle The rotation angle to set.
       * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
       * to `0`.
       */set(x,y,z,angle){let precision=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;this.params[0]=x;this.params[1]=y;this.params[2]=z;this.params[3]=precision===0?angle:MathUtils.round(angle,precision);}/** @inheritdoc */buildString(params){return "rotate3d(".concat(params[0],", ").concat(params[1],", ").concat(params[2],", ").concat(params[3]).concat(this.unit,")");}}CssRotate3dTransform.DEFAULT_PARAMS=[0,0,1,0];/**
   * A CSS `translateX` transform.
   */class CssTranslateXTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
       * @param unit The unit to use for this transform.
       */constructor(unit){super(CssTranslateXTransform.DEFAULT_PARAMS);this.unit=unit;}/**
       * Sets this transform's translation.
       * @param x The translation to set.
       * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       */set(x){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?x:MathUtils.round(x,precision);}/** @inheritdoc */buildString(params){return "translateX(".concat(params[0]).concat(this.unit,")");}}CssTranslateXTransform.DEFAULT_PARAMS=[0];/**
   * A CSS `translateY` transform.
   */class CssTranslateYTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
       * @param unit The unit to use for this transform.
       */constructor(unit){super(CssTranslateYTransform.DEFAULT_PARAMS);this.unit=unit;}/**
       * Sets this transform's translation.
       * @param y The translation to set.
       * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       */set(y){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?y:MathUtils.round(y,precision);}/** @inheritdoc */buildString(params){return "translateY(".concat(params[0]).concat(this.unit,")");}}CssTranslateYTransform.DEFAULT_PARAMS=[0];/**
   * A CSS `translateZ` transform.
   */class CssTranslateZTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
       * @param unit The unit to use for this transform.
       */constructor(unit){super(CssTranslateZTransform.DEFAULT_PARAMS);this.unit=unit;}/**
       * Sets this transform's translation.
       * @param z The translation to set.
       * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       */set(z){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?z:MathUtils.round(z,precision);}/** @inheritdoc */buildString(params){return "translateZ(".concat(params[0]).concat(this.unit,")");}}CssTranslateZTransform.DEFAULT_PARAMS=[0];/**
   * A CSS `translate` transform.
   */class CssTranslateTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
       * @param unitX The unit to use for this transform's x translation.
       * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
       */constructor(unitX){let unitY=arguments.length>1&&arguments[1]!==undefined?arguments[1]:unitX;super(CssTranslateTransform.DEFAULT_PARAMS);this.unitX=unitX;this.unitY=unitY;}/**
       * Sets this transform's translation.
       * @param x The x translation to set.
       * @param y The y translation to set.
       * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
       * Defaults to the x translation precision value.
       */set(x,y){let precisionX=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let precisionY=arguments.length>3&&arguments[3]!==undefined?arguments[3]:precisionX;this.params[0]=precisionX===0?x:MathUtils.round(x,precisionX);this.params[1]=precisionY===0?y:MathUtils.round(y,precisionY);}/** @inheritdoc */buildString(params){return "translate(".concat(params[0]).concat(this.unitX,", ").concat(params[1]).concat(this.unitY,")");}}CssTranslateTransform.DEFAULT_PARAMS=[0,0];/**
   * A CSS `translate3d` transform.
   */class CssTranslate3dTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
       * @param unitX The unit to use for this transform's x translation.
       * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
       * @param unitZ The unit to use for this transform's z translation. Defaults to the same unit as the x translation.
       */constructor(unitX){let unitY=arguments.length>1&&arguments[1]!==undefined?arguments[1]:unitX;let unitZ=arguments.length>2&&arguments[2]!==undefined?arguments[2]:unitX;super(CssTranslate3dTransform.DEFAULT_PARAMS);this.unitX=unitX;this.unitY=unitY;this.unitZ=unitZ;}/**
       * Sets this transform's translation.
       * @param x The x translation to set.
       * @param y The y translation to set.
       * @param z The z translation to set.
       * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
       * Defaults to the x translation precision value.
       * @param precisionZ The precision with which to set the z translation. A value of `0` denotes infinite precision.
       * Defaults to the x translation precision value.
       */set(x,y,z){let precisionX=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;let precisionY=arguments.length>4&&arguments[4]!==undefined?arguments[4]:precisionX;let precisionZ=arguments.length>5&&arguments[5]!==undefined?arguments[5]:precisionX;this.params[0]=precisionX===0?x:MathUtils.round(x,precisionX);this.params[1]=precisionY===0?y:MathUtils.round(y,precisionY);this.params[2]=precisionZ===0?z:MathUtils.round(z,precisionZ);}/** @inheritdoc */buildString(params){return "translate3d(".concat(params[0]).concat(this.unitX,", ").concat(params[1]).concat(this.unitY,", ").concat(params[2]).concat(this.unitZ,")");}}CssTranslate3dTransform.DEFAULT_PARAMS=[0,0,0];/**
   * A CSS `scaleX` transform.
   */class CssScaleXTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
       */constructor(){super(CssScaleXTransform.DEFAULT_PARAMS);}/**
       * Sets this transform's scaling.
       * @param x The scaling to set.
       * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
       * to `0`.
       */set(x){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?x:MathUtils.round(x,precision);}/** @inheritdoc */buildString(params){return "scaleX(".concat(params[0],")");}}CssScaleXTransform.DEFAULT_PARAMS=[1];/**
   * A CSS `scaleY` transform.
   */class CssScaleYTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
       */constructor(){super(CssScaleYTransform.DEFAULT_PARAMS);}/**
       * Sets this transform's scaling.
       * @param y The scaling to set.
       * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
       * to `0`.
       */set(y){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?y:MathUtils.round(y,precision);}/** @inheritdoc */buildString(params){return "scaleY(".concat(params[0],")");}}CssScaleYTransform.DEFAULT_PARAMS=[1];/**
   * A CSS `scaleZ` transform.
   */class CssScaleZTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
       */constructor(){super(CssScaleZTransform.DEFAULT_PARAMS);}/**
       * Sets this transform's scaling.
       * @param z The scaling to set.
       * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
       * to `0`.
       */set(z){let precision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;this.params[0]=precision===0?z:MathUtils.round(z,precision);}/** @inheritdoc */buildString(params){return "scaleZ(".concat(params[0],")");}}CssScaleZTransform.DEFAULT_PARAMS=[1];/**
   * A CSS `scale` transform.
   */class CssScaleTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
       */constructor(){super(CssScaleTransform.DEFAULT_PARAMS);}/**
       * Sets this transform's scaling.
       * @param x The x scaling to set.
       * @param y The y scaling to set.
       * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
       * Defaults to the x scaling precision value.
       */set(x,y){let precisionX=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;let precisionY=arguments.length>3&&arguments[3]!==undefined?arguments[3]:precisionX;this.params[0]=precisionX===0?x:MathUtils.round(x,precisionX);this.params[1]=precisionY===0?y:MathUtils.round(y,precisionY);}/** @inheritdoc */buildString(params){return "scale(".concat(params[0],", ").concat(params[1],")");}}CssScaleTransform.DEFAULT_PARAMS=[1,1];/**
   * A CSS `scale3d` transform.
   */class CssScale3dTransform extends AbstractCssTransform{/**
       * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
       */constructor(){super(CssScale3dTransform.DEFAULT_PARAMS);}/**
       * Sets this transform's scaling.
       * @param x The x scaling to set.
       * @param y The y scaling to set.
       * @param z The z scaling to set.
       * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
       * Defaults to `0`.
       * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
       * Defaults to the x scaling precision value.
       * @param precisionZ The precision with which to set the z scaling. A value of `0` denotes infinite precision.
       * Defaults to the x scaling precision value.
       */set(x,y,z){let precisionX=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;let precisionY=arguments.length>4&&arguments[4]!==undefined?arguments[4]:precisionX;let precisionZ=arguments.length>5&&arguments[5]!==undefined?arguments[5]:precisionX;this.params[0]=precisionX===0?x:MathUtils.round(x,precisionX);this.params[1]=precisionY===0?y:MathUtils.round(y,precisionY);this.params[2]=precisionZ===0?z:MathUtils.round(y,precisionZ);}/** @inheritdoc */buildString(params){return "scale3d(".concat(params[0],", ").concat(params[1],", ").concat(params[2],")");}}CssScale3dTransform.DEFAULT_PARAMS=[1,1,1];/**
   * A concatenated chain of CSS transforms.
   */class CssTransformChain{/**
       * Creates a new chain of CSS transforms.
       * @param transforms The individual child transforms that will constitute the new transform chain. The order of
       * the children passed to the constructor determines the order of concatenation. Concatenation follows the standard
       * CSS transform convention: for a concatenation of transforms `[A, B, C]`, the resulting transformation is
       * equivalent to the one produced by multiplying the transformation matrices in the order `(A * B) * C`.
       */constructor(){this.stringValues=[];for(var _len17=arguments.length,transforms=new Array(_len17),_key17=0;_key17<_len17;_key17++){transforms[_key17]=arguments[_key17];}this.transforms=transforms;}/**
       * Gets one of this chain's child transforms.
       * @param index The index of the child to get.
       * @returns The child transform at the specified index in this chain.
       * @throws RangeError if `index` is out of bounds.
       */getChild(index){if(index<0||index>=this.transforms.length){throw new RangeError();}return this.transforms[index];}/** @inheritdoc */resolve(){let needRebuildString=false;for(let i=0;i<this.transforms.length;i++){const stringValue=this.transforms[i].resolve();if(this.stringValues[i]!==stringValue){this.stringValues[i]=stringValue;needRebuildString=true;}}if(needRebuildString||this.chainedStringValue===undefined){this.chainedStringValue=this.stringValues.join(' ');}return this.chainedStringValue;}}/**
   * A subscribable subject whose value is a CSS transform string resolved from a {@link CssTransform}.
   */class CssTransformSubject extends AbstractSubscribable{/**
       * Constructor.
       * @param transform The new subject's CSS transform.
       */constructor(transform){super();this._transform=transform;this.stringValue=transform.resolve();this.transform=transform;}/** @inheritdoc */get(){return this.stringValue;}/**
       * Resolves this subject's CSS transform to a CSS transform string, and sets this subject's value to the resolved
       * string. If this changes this subject's value, subscribers will be notified.
       */resolve(){const stringValue=this._transform.resolve();if(stringValue!==this.stringValue){this.stringValue=stringValue;this.notify();}}/**
       * Creates a new instance of {@link CssTransformSubject} whose value is resolved from a CSS transform.
       * @param transform A CSS transform.
       * @returns A new instance of {@link CssTransformSubject} whose value is resolved from the specified CSS transform.
       */static create(transform){return new CssTransformSubject(transform);}}/**
   * A utility class for building CSS transforms.
   */class CssTransformBuilder{/**
       * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
       * @returns A new instance of a CSS `matrix` transform, initialized to the identity transformation.
       */static matrix(){return new CssMatrixTransform();}/**
       * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
       * @param unit The angle unit to use for the new transform.
       * @returns A new instance of a CSS `rotate` transform, initialized to zero rotation.
       */static rotate(unit){return new CssRotateTransform(unit);}/**
       * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
       * @param unit The angle unit to use for the new transform.
       * @returns A new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
       */static rotate3d(unit){return new CssRotate3dTransform(unit);}/**
       * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
       * @param unit The unit to use for the new transform.
       * @returns A new instance of a CSS `translateX` transform, initialized to zero translation.
       */static translateX(unit){return new CssTranslateXTransform(unit);}/**
       * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
       * @param unit The unit to use for the new transform.
       * @returns A new instance of a CSS `translateY` transform, initialized to zero translation.
       */static translateY(unit){return new CssTranslateYTransform(unit);}/**
       * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
       * @param unit The unit to use for the new transform.
       * @returns A new instance of a CSS `translateZ` transform, initialized to zero translation.
       */static translateZ(unit){return new CssTranslateZTransform(unit);}/**
       * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
       * @param unitX The unit to use for the new transform's x translation.
       * @param unitY The unit to use for the new transform's y translation.
       * @returns A new instance of a CSS `translate` transform, initialized to zero translation.
       */static translate(unitX,unitY){return new CssTranslateTransform(unitX,unitY);}/**
       * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
       * @param unitX The unit to use for the new transform's x translation.
       * @param unitY The unit to use for the new transform's y translation.
       * @param unitZ The unit to use for the new transform's z translation.
       * @returns A new instance of a CSS `translate3d` transform, initialized to zero translation.
       */static translate3d(unitX,unitY,unitZ){return new CssTranslate3dTransform(unitX,unitY,unitZ);}/**
       * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
       * @returns A new instance of a CSS `scaleX` transform, initialized to the identity scaling.
       */static scaleX(){return new CssScaleXTransform();}/**
       * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
       * @returns A new instance of a CSS `scaleY` transform, initialized to the identity scaling.
       */static scaleY(){return new CssScaleYTransform();}/**
       * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
       * @returns A new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
       */static scaleZ(){return new CssScaleZTransform();}/**
       * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
       * @returns A new instance of a CSS `scale` transform, initialized to the identity scaling.
       */static scale(){return new CssScaleTransform();}/**
       * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
       * @returns A new instance of a CSS `scale3d` transform, initialized to the identity scaling.
       */static scale3d(){return new CssScale3dTransform();}/**
       * Concatenates zero or more CSS transformations.
       * @param transforms The individual transforms to concatentate. The order of the transforms passed to the function
       * determines the order of concatenation. Concatenation follows the standard CSS transform convention: for a
       * concatenation of transforms `[A, B, C]`, the resulting transformation is equivalent to the one produced by
       * multiplying the transformation matrices in the order `(A * B) * C`.
       * @returns A new {@link CssTransformChain} object representing the concatenation of the specified transforms.
       */static concat(){for(var _len18=arguments.length,transforms=new Array(_len18),_key18=0;_key18<_len18;_key18++){transforms[_key18]=arguments[_key18];}return new CssTransformChain(...transforms);}}/**
   * A utility class for creating number formatters.
   *
   * Each number formatter is a function which generates output strings from input numeric values. The formatting
   * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
   * documentation for more information on each individual option.
   */class NumberFormatter{/**
       * Formats a number to a string.
       * @param number The number to format.
       * @param opts Options describing how to format the number.
       * @returns The formatted string representation of the specified number.
       */static formatNumber(number,opts){if(isNaN(number)){return opts.nanString;}const{precision,roundFunc,maxDigits,forceDecimalZeroes,pad,showCommas,useMinusSign,forceSign,cache}=opts;const sign=number<0?-1:1;const abs=Math.abs(number);let rounded=abs;if(precision!==0){rounded=roundFunc(abs/precision)*precision;}if(cache){if(opts.cachedString!==undefined&&opts.cachedNumber===rounded){return opts.cachedString;}opts.cachedNumber=rounded;}const signText=sign===-1?useMinusSign?'':'-':'+';let formatted;if(precision!=0){const precisionString="".concat(precision);const decimalIndex=precisionString.indexOf('.');if(decimalIndex>=0){formatted=rounded.toFixed(precisionString.length-decimalIndex-1);}else {formatted="".concat(rounded);}}else {formatted="".concat(abs);}let decimalIndex=formatted.indexOf('.');if(!forceDecimalZeroes&&decimalIndex>=0){formatted=formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX,'');if(formatted.indexOf('.')==formatted.length-1){formatted=formatted.substring(0,formatted.length-1);}}decimalIndex=formatted.indexOf('.');if(decimalIndex>=0&&formatted.length-1>maxDigits){const shift=Math.max(maxDigits-decimalIndex,0);const shiftPrecision=Math.pow(0.1,shift);formatted=(roundFunc(abs/shiftPrecision)*shiftPrecision).toFixed(shift);}if(pad===0){formatted=formatted.replace(NumberFormatter.LEADING_ZERO_REGEX,'.');}else if(pad>1){decimalIndex=formatted.indexOf('.');if(decimalIndex<0){decimalIndex=formatted.length;}formatted=formatted.padStart(pad+formatted.length-decimalIndex,'0');}if(showCommas){const parts=formatted.split('.');parts[0]=parts[0].replace(NumberFormatter.COMMAS_REGEX,',');formatted=parts.join('.');}formatted=(forceSign||signText!=='+'?signText:'')+formatted;if(cache){opts.cachedString=formatted;}return formatted;}/**
       * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
       * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
       * more information on each individual option.
       * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
       * default values:
       * * `precision = 0`
       * * `round = 0`
       * * `maxDigits = Infinity`
       * * `forceDecimalZeroes = true`
       * * `pad = 1`
       * * `showCommas = false`
       * * `useMinusSign = false`
       * * `forceSign = false`
       * * `nanString = 'NaN'`
       * * `cache = false`
       * @returns A function which formats numeric values to strings.
       */static create(options){const optsToUse=Object.assign({},NumberFormatter.DEFAULT_OPTIONS,options);optsToUse.roundFunc=NumberFormatter.roundFuncs[optsToUse.round];return number=>{return NumberFormatter.formatNumber(number,optsToUse);};}}NumberFormatter.DEFAULT_OPTIONS={precision:0,round:0,maxDigits:Infinity,forceDecimalZeroes:true,pad:1,showCommas:false,useMinusSign:false,forceSign:false,nanString:'NaN',cache:false};NumberFormatter.roundFuncs={[-1]:Math.floor,[0]:Math.round,[1]:Math.ceil};NumberFormatter.TRAILING_ZERO_REGEX=/0+$/;NumberFormatter.LEADING_ZERO_REGEX=/^0\./;NumberFormatter.COMMAS_REGEX=/\B(?=(\d{3})+(?!\d))/g;/**
   * A path stream which builds SVG path strings from its input path commands.
   */class SvgPathStream{/**
       * Constructor.
       * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
       * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
       */constructor(){let precision=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;this.svgPath='';this.firstPoint=new Float64Array([NaN,NaN]);this.prevPoint=new Float64Array([NaN,NaN]);this.precision=precision;this.formatter=NumberFormatter.create({precision,forceDecimalZeroes:false});}/**
       * Gets the SVG path string describing all path commands consumed by this stream since the last call to
       * `beginPath()`.
       * @returns The SVG path string describing all path commands consumed by this stream since the last call to
       * `beginPath()`.
       */getSvgPath(){return this.svgPath.trim();}/**
       * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
       * SVG path string. A value of `0` indicates infinite precision.
       * @returns The precision of this stream.
       */getPrecision(){return this.precision;}/**
       * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
       * SVG path string. A value of `0` indicates infinite precision.
       * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
       */setPrecision(precision){this.precision=Math.abs(precision);this.formatter=NumberFormatter.create({precision:this.precision,forceDecimalZeroes:false});}/** @inheritdoc */beginPath(){this.reset();}/** @inheritdoc */moveTo(x,y){if(!(isFinite(x)&&isFinite(y))){return;}if(isNaN(this.firstPoint[0])){Vec2Math.set(x,y,this.firstPoint);}this.svgPath+="M ".concat(this.formatter(x)," ").concat(this.formatter(y)," ");Vec2Math.set(x,y,this.prevPoint);}/** @inheritdoc */lineTo(x,y){if(!(isFinite(x)&&isFinite(y))){return;}if(isNaN(this.prevPoint[0])){this.moveTo(x,y);return;}this.svgPath+="L ".concat(this.formatter(x)," ").concat(this.formatter(y)," ");Vec2Math.set(x,y,this.prevPoint);}/** @inheritdoc */bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){if(!(isFinite(x)&&isFinite(y)&&isFinite(cp1x)&&isFinite(cp1y)&&isFinite(cp2x)&&isFinite(cp2y))){return;}if(isNaN(this.prevPoint[0])){this.moveTo(x,y);return;}this.svgPath+="C ".concat(this.formatter(cp1x)," ").concat(this.formatter(cp1y)," ").concat(this.formatter(cp2x)," ").concat(this.formatter(cp2y)," ").concat(this.formatter(x)," ").concat(this.formatter(y)," ");Vec2Math.set(x,y,this.prevPoint);}/** @inheritdoc */quadraticCurveTo(cpx,cpy,x,y){if(!(isFinite(x)&&isFinite(y)&&isFinite(cpx)&&isFinite(cpy))){return;}if(isNaN(this.prevPoint[0])){this.moveTo(x,y);return;}this.svgPath+="Q ".concat(this.formatter(cpx)," ").concat(this.formatter(cpy)," ").concat(this.formatter(x)," ").concat(this.formatter(y)," ");Vec2Math.set(x,y,this.prevPoint);}/** @inheritdoc */arc(x,y,radius,startAngle,endAngle,counterClockwise){if(!(isFinite(x)&&isFinite(y)&&isFinite(radius)&&isFinite(startAngle)&&isFinite(endAngle))){return;}const directionSign=counterClockwise?-1:1;if(Math.sign(endAngle-startAngle)!==directionSign){// Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
  // doesn't match the counterClockwise flag.
  const angleDiff=counterClockwise?MathUtils.diffAngle(endAngle,startAngle):MathUtils.diffAngle(startAngle,endAngle);endAngle=startAngle+angleDiff*directionSign;}// Clamp to 2pi because we don't need to draw anything past a full circle.
  const angularWidth=Math.min(MathUtils.TWO_PI,(endAngle-startAngle)*directionSign);if(angularWidth===MathUtils.TWO_PI){// SVG arc commands cannot draw a full circle, so we need to split the circle into two half circles
  const midAngle=startAngle+Math.PI*directionSign;this.arc(x,y,radius,startAngle,midAngle,counterClockwise);this.arc(x,y,radius,midAngle,startAngle,counterClockwise);return;}const startPoint=Vec2Math.add(Vec2Math.set(x,y,SvgPathStream.vec2Cache[0]),Vec2Math.setFromPolar(radius,startAngle,SvgPathStream.vec2Cache[2]),SvgPathStream.vec2Cache[0]);if(isNaN(this.prevPoint[0])){this.moveTo(startPoint[0],startPoint[1]);}else if(!Vec2Math.equals(this.prevPoint,startPoint)){this.lineTo(startPoint[0],startPoint[1]);}const endPoint=Vec2Math.add(Vec2Math.set(x,y,SvgPathStream.vec2Cache[1]),Vec2Math.setFromPolar(radius,endAngle,SvgPathStream.vec2Cache[2]),SvgPathStream.vec2Cache[1]);const radiusString=this.formatter(radius);this.svgPath+="A ".concat(radiusString," ").concat(radiusString," 0 ").concat(angularWidth>Math.PI?1:0," ").concat(counterClockwise?0:1," ").concat(this.formatter(endPoint[0])," ").concat(this.formatter(endPoint[1])," ");Vec2Math.copy(endPoint,this.prevPoint);}/** @inheritdoc */closePath(){if(!isNaN(this.firstPoint[0])){this.lineTo(this.firstPoint[0],this.firstPoint[1]);}}/**
       * Resets the state of this stream.
       */reset(){Vec2Math.set(NaN,NaN,this.firstPoint);Vec2Math.set(NaN,NaN,this.prevPoint);this.svgPath='';}}SvgPathStream.vec2Cache=[new Float64Array(2),new Float64Array(2),new Float64Array(2),new Float64Array(2)];/**
   * A collection of common keys used by the MapSystem API.
   */class MapSystemKeys{}MapSystemKeys.TargetControl='targetControlModerator';MapSystemKeys.RotationControl='rotationControlModerator';MapSystemKeys.RangeControl='rangeControlModerator';MapSystemKeys.ClockUpdate='clockUpdate';MapSystemKeys.OwnAirplaneProps='ownAirplaneProps';MapSystemKeys.AutopilotProps='autopilotProps';MapSystemKeys.AltitudeArc='altitudeArc';MapSystemKeys.TerrainColors='terrainColors';MapSystemKeys.Weather='weather';MapSystemKeys.FollowAirplane='followAirplane';MapSystemKeys.Rotation='rotation';MapSystemKeys.OwnAirplaneIcon='ownAirplaneIcon';MapSystemKeys.OwnAirplaneIconOrientation='ownAirplaneIconOrientation';MapSystemKeys.TextLayer='text';MapSystemKeys.TextManager='textManager';MapSystemKeys.Bing='bing';MapSystemKeys.WaypointRenderer='waypointRenderer';MapSystemKeys.IconFactory='iconFactory';MapSystemKeys.LabelFactory='labelFactory';MapSystemKeys.NearestWaypoints='nearestWaypoints';MapSystemKeys.FlightPlan='flightPlan';MapSystemKeys.FlightPlanner='flightPlanner';MapSystemKeys.FlightPathRenderer='flightPathRenderer';MapSystemKeys.Airspace='airspace';MapSystemKeys.AirspaceManager='airspaceRenderManager';MapSystemKeys.Traffic='traffic';MapSystemKeys.DataIntegrity='dataIntegrity';/**
   * An implementation of MapCanvasLayerCanvasInstance.
   */class MapCanvasLayerCanvasInstanceClass{/**
       * Creates a new canvas instance.
       * @param canvas The canvas element.
       * @param context The canvas 2D rendering context.
       * @param isDisplayed Whether the canvas is displayed.
       */constructor(canvas,context,isDisplayed){this.canvas=canvas;this.context=context;this.isDisplayed=isDisplayed;}// eslint-disable-next-line jsdoc/require-jsdoc
  clear(){this.context.clearRect(0,0,this.canvas.width,this.canvas.height);}// eslint-disable-next-line jsdoc/require-jsdoc
  reset(){const width=this.canvas.width;this.canvas.width=0;this.canvas.width=width;}}/**
   * A layer which uses a canvas to draw graphics.
   */class MapCanvasLayer extends MapLayer{constructor(){super(...arguments);this.displayCanvasRef=FSComponent.createRef();this.width=0;this.height=0;this.displayCanvasContext=null;this.isInit=false;}/**
       * Gets this layer's display canvas instance.
       * @returns This layer's display canvas instance.
       * @throws Error if this layer's display canvas instance has not been initialized.
       */get display(){if(!this._display){throw new Error('MapCanvasLayer: attempted to access display before it was initialized');}return this._display;}/**
       * Gets this layer's buffer canvas instance.
       * @returns This layer's buffer canvas instance.
       * @throws Error if this layer's buffer canvas instance has not been initialized.
       */get buffer(){if(!this._buffer){throw new Error('MapCanvasLayer: attempted to access buffer before it was initialized');}return this._buffer;}/**
       * Attempts to get this layer's display canvas instance.
       * @returns This layer's display canvas instance, or undefined if it has not been initialized.
       */tryGetDisplay(){return this._display;}/**
       * Attempts to get this layer's buffer canvas instance.
       * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
       */tryGetBuffer(){return this._buffer;}/**
       * Gets the width of the canvas element, in pixels.
       * @returns the width of the canvas element.
       */getWidth(){return this.width;}/**
       * Gets the height of the canvas element, in pixels.
       * @returns the height of the canvas element.
       */getHeight(){return this.height;}/**
       * Sets the width of the canvas element, in pixels.
       * @param width The new width.
       */setWidth(width){if(width===this.width){return;}this.width=width;if(this.isInit){this.updateCanvasSize();}}/**
       * Sets the height of the canvas element, in pixels.
       * @param height The new height.
       */setHeight(height){if(height===this.height){return;}this.height=height;if(this.isInit){this.updateCanvasSize();}}/**
       * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
       */copyBufferToDisplay(){if(!this.isInit||!this.props.useBuffer){return;}this.display.context.drawImage(this.buffer.canvas,0,0,this.width,this.height);}/**
       * A callback called after the component renders.
       */onAfterRender(){this.displayCanvasContext=this.displayCanvasRef.instance.getContext('2d');}// eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
  onVisibilityChanged(isVisible){if(this.isInit){this.updateCanvasVisibility();}}/**
       * Updates this layer according to its current visibility.
       */updateFromVisibility(){this.display.canvas.style.display=this.isVisible()?'block':'none';}// eslint-disable-next-line jsdoc/require-jsdoc
  onAttached(){this.initCanvasInstances();this.isInit=true;this.updateCanvasVisibility();this.updateCanvasSize();}/**
       * Initializes this layer's canvas instances.
       */initCanvasInstances(){this._display=this.createCanvasInstance(this.displayCanvasRef.instance,this.displayCanvasContext,true);if(this.props.useBuffer){const canvas=document.createElement('canvas');const context=canvas.getContext('2d');this._buffer=this.createCanvasInstance(canvas,context,false);}}/**
       * Creates a canvas instance.
       * @param canvas The canvas element.
       * @param context The canvas 2D rendering context.
       * @param isDisplayed Whether the canvas is displayed.
       * @returns a canvas instance.
       */createCanvasInstance(canvas,context,isDisplayed){return new MapCanvasLayerCanvasInstanceClass(canvas,context,isDisplayed);}/**
       * Updates the canvas element's size.
       */updateCanvasSize(){const displayCanvas=this.display.canvas;displayCanvas.width=this.width;displayCanvas.height=this.height;displayCanvas.style.width="".concat(this.width,"px");displayCanvas.style.height="".concat(this.height,"px");if(this._buffer){const bufferCanvas=this._buffer.canvas;bufferCanvas.width=this.width;bufferCanvas.height=this.height;}}/**
       * Updates the visibility of the display canvas.
       */updateCanvasVisibility(){this.display.canvas.style.display=this.isVisible()?'block':'none';}/** @inheritdoc */render(){var _a;return FSComponent.buildComponent("canvas",{ref:this.displayCanvasRef,class:(_a=this.props.class)!==null&&_a!==void 0?_a:'',width:'0',height:'0',style:'position: absolute;'});}}/**
   * A canvas map layer whose size and position is synced with the map projection window.
   */class MapSyncedCanvasLayer extends MapCanvasLayer{// eslint-disable-next-line jsdoc/require-jsdoc
  onAttached(){super.onAttached();this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());}/**
       * Updates this layer according to the current size of the projected map window.
       * @param projectedSize The size of the projected map window.
       */updateFromProjectedSize(projectedSize){this.setWidth(projectedSize[0]);this.setHeight(projectedSize[1]);const displayCanvas=this.display.canvas;displayCanvas.style.left='0px';displayCanvas.style.top='0px';}// eslint-disable-next-line jsdoc/require-jsdoc
  onMapProjectionChanged(mapProjection,changeFlags){if(BitFlags.isAll(changeFlags,MapProjectionChangeType.ProjectedSize)){this.updateFromProjectedSize(mapProjection.getProjectedSize());}}}/**
   * A map layer which displays an altitude intercept arc.
   */class MapAltitudeArcLayer extends MapLayer{constructor(){var _a,_b,_c,_d,_e,_f,_g,_h;super(...arguments);this.layerRef=FSComponent.createRef();this.arcAngularWidth=((_a=this.props.arcAngularWidth)!==null&&_a!==void 0?_a:MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH)*Avionics.Utils.DEG2RAD;this.arcRadius=(_b=this.props.arcRadius)!==null&&_b!==void 0?_b:MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;this.strokeWidth=(_c=this.props.strokeWidth)!==null&&_c!==void 0?_c:MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;this.strokeStyle=(_d=this.props.strokeStyle)!==null&&_d!==void 0?_d:MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;this.strokeLineCap=(_e=this.props.strokeLineCap)!==null&&_e!==void 0?_e:MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;this.outlineWidth=(_f=this.props.outlineWidth)!==null&&_f!==void 0?_f:MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;this.outlineStyle=(_g=this.props.outlineStyle)!==null&&_g!==void 0?_g:MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;this.outlineLineCap=(_h=this.props.outlineLineCap)!==null&&_h!==void 0?_h:MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;this.ownAirplanePropsModule=this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);this.autopilotModule=this.props.model.getModule(MapSystemKeys.AutopilotProps);this.vsPrecisionFpm='isSubscribable'in this.props.verticalSpeedPrecision?this.vsPrecisionMap=this.props.verticalSpeedPrecision.map(v=>v.asUnit(UnitType.FPM)):Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));this.vsThresholdFpm='isSubscribable'in this.props.verticalSpeedThreshold?this.vsThresholdMap=this.props.verticalSpeedThreshold.map(v=>v.asUnit(UnitType.FPM)):Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));this.altDevThresholdFeet='isSubscribable'in this.props.altitudeDeviationThreshold?this.altDevThresholdMap=this.props.altitudeDeviationThreshold.map(v=>v.asUnit(UnitType.FOOT)):Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));this.vsFpm=this.ownAirplanePropsModule.verticalSpeed.map(vs=>vs.asUnit(UnitType.FPM));this.vsFpmQuantized=MappedSubject.create(_ref2=>{let[vsFpm,precision]=_ref2;return Math.round(vsFpm/precision)*precision;},this.vsFpm,this.vsPrecisionFpm);this.projectedPlanePosition=Vec2Subject.create(Vec2Math.create());this.projectPlanePositionHandler=()=>{const projected=this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(),MapAltitudeArcLayer.vec2Cache[0]);this.projectedPlanePosition.set(projected);};this.isArcVisibleDynamic=MappedSubject.create(_ref3=>{let[vsFpm,alt,selectedAlt,vsThreshold,altDevThresholdFeet]=_ref3;if(Math.abs(vsFpm)<vsThreshold){return false;}const altDevFeet=selectedAlt.asUnit(UnitType.FOOT)-alt.asUnit(UnitType.FOOT);return Math.abs(altDevFeet)>=altDevThresholdFeet&&altDevFeet*vsFpm>0;},this.vsFpmQuantized,this.ownAirplanePropsModule.altitude,this.autopilotModule.selectedAltitude,this.vsThresholdFpm,this.altDevThresholdFeet).pause();this.projectedArcPosition=Vec2Subject.create(Vec2Math.create());this.projectedArcAngle=Subject.create(0);this.needUpdate=false;this.subscriptions=[];}/** @inheritdoc */onVisibilityChanged(isVisible){var _a;(_a=this.layerRef.getOrDefault())===null||_a===void 0?void 0:_a.setVisible(isVisible);if(isVisible){this.needUpdate=true;}}/** @inheritdoc */onAttached(){var _a,_b;this.layerRef.instance.onAttached();this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));const scheduleUpdate=()=>{this.needUpdate=true;};const altitudeArcModule=this.props.model.getModule(MapSystemKeys.AltitudeArc);const dataIntegrityModule=this.props.model.getModule(MapSystemKeys.DataIntegrity);this.isArcVisibleStatic=MappedSubject.create(_ref4=>{let[show,isGpsValid,isAdcValid]=_ref4;return show&&isGpsValid&&isAdcValid;},altitudeArcModule.show,(_a=dataIntegrityModule===null||dataIntegrityModule===void 0?void 0:dataIntegrityModule.gpsSignalValid)!==null&&_a!==void 0?_a:Subject.create(true),(_b=dataIntegrityModule===null||dataIntegrityModule===void 0?void 0:dataIntegrityModule.adcSignalValid)!==null&&_b!==void 0?_b:Subject.create(true));const isArcVisibleDynamicSub=this.isArcVisibleDynamic.sub(isVisible=>{this.setVisible(isVisible);},false,true);this.isArcVisibleStatic.sub(isVisible=>{if(isVisible){this.isArcVisibleDynamic.resume();isArcVisibleDynamicSub.resume(true);}else {this.isArcVisibleDynamic.pause();isArcVisibleDynamicSub.pause();this.setVisible(false);}},true);this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate),this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate),this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate),this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));this.vsFpmQuantized.sub(scheduleUpdate);this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate,true));this.layerRef.instance.setVisible(this.isVisible());}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){this.layerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);this.projectPlanePositionHandler();this.needUpdate=true;}/** @inheritdoc */onUpdated(){if(!this.needUpdate||!this.isVisible()){return;}const track=this.ownAirplanePropsModule.trackTrue.get();const groundSpeed=this.ownAirplanePropsModule.groundSpeed.get();const altitude=this.ownAirplanePropsModule.altitude.get();const selectedAltitude=this.autopilotModule.selectedAltitude.get();const vsFpm=this.vsFpmQuantized.get();const timeToAltitudeMinute=(selectedAltitude.asUnit(UnitType.FOOT)-altitude.asUnit(UnitType.FOOT))/vsFpm;const distanceToAltitudeFeet=groundSpeed.asUnit(UnitType.FPM)*timeToAltitudeMinute;const distancePx=UnitType.FOOT.convertTo(distanceToAltitudeFeet,UnitType.GA_RADIAN)/this.props.mapProjection.getProjectedResolution();const projectedTrackAngle=track*Avionics.Utils.DEG2RAD+this.props.mapProjection.getRotation()-MathUtils.HALF_PI;const projectedPlanePos=this.projectedPlanePosition.get();const projectedArcPos=Vec2Math.add(Vec2Math.setFromPolar(distancePx,projectedTrackAngle,MapAltitudeArcLayer.vec2Cache[0]),projectedPlanePos,MapAltitudeArcLayer.vec2Cache[0]);this.projectedArcPosition.set(projectedArcPos);this.projectedArcAngle.set(projectedTrackAngle);this.layerRef.instance.onUpdated();this.needUpdate=false;}/** @inheritdoc */render(){const props={ref:this.layerRef,model:this.props.model,mapProjection:this.props.mapProjection,arcAngularWidth:this.arcAngularWidth,arcRadius:this.arcRadius,strokeWidth:this.strokeWidth,strokeStyle:this.strokeStyle,strokeLineCap:this.strokeLineCap,outlineWidth:this.outlineWidth,outlineStyle:this.outlineStyle,outlineLineCap:this.outlineLineCap,projectedArcPosition:this.projectedArcPosition,projectedArcAngle:this.projectedArcAngle};return this.props.renderMethod==='canvas'?FSComponent.buildComponent(MapAltitudeArcCanvasLayer,Object.assign({},props)):FSComponent.buildComponent(MapAltitudeArcSvgLayer,Object.assign({},props));}/** @inheritdoc */destroy(){var _a,_b,_c,_d,_e;(_a=this.layerRef.getOrDefault())===null||_a===void 0?void 0:_a.destroy();(_b=this.vsPrecisionMap)===null||_b===void 0?void 0:_b.destroy();(_c=this.vsThresholdMap)===null||_c===void 0?void 0:_c.destroy();(_d=this.altDevThresholdMap)===null||_d===void 0?void 0:_d.destroy();this.vsFpm.destroy();(_e=this.isArcVisibleStatic)===null||_e===void 0?void 0:_e.destroy();this.isArcVisibleDynamic.destroy();this.subscriptions.forEach(sub=>sub.destroy());super.destroy();}}MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH=60;// degrees
  MapAltitudeArcLayer.DEFAULT_ARC_RADIUS=64;// px
  MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH=2;// px
  MapAltitudeArcLayer.DEFAULT_STROKE_STYLE='cyan';MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP='butt';MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH=1;// px
  MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE='#505050';MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP='butt';MapAltitudeArcLayer.vec2Cache=[new Float64Array(2),new Float64Array(2)];/**
   * A map layer which draws an altitude intercept arc using canvas.
   */class MapAltitudeArcCanvasLayer extends MapLayer{constructor(){super(...arguments);this.arcHalfAngularWidth=this.props.arcAngularWidth/2;this.totalArcThickness=this.props.strokeWidth+this.props.outlineWidth*2;this.canvasLayerRef=FSComponent.createRef();this.subscriptions=[];this.needUpdate=false;}/** @inheritdoc */onVisibilityChanged(isVisible){var _a,_b;if(isVisible){this.needUpdate=true;}else {(_b=(_a=this.canvasLayerRef.getOrDefault())===null||_a===void 0?void 0:_a.tryGetDisplay())===null||_b===void 0?void 0:_b.clear();}}/** @inheritdoc */onAttached(){this.canvasLayerRef.instance.onAttached();const scheduleUpdate=()=>{this.needUpdate=true;};this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate,false),this.props.projectedArcAngle.sub(scheduleUpdate,false));this.needUpdate=true;}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);}/** @inheritdoc */onUpdated(){if(!this.needUpdate||!this.isVisible()){return;}const arcPos=this.props.projectedArcPosition.get();const display=this.canvasLayerRef.instance.display;display.clear();// Do not draw the arc if it is out of bounds.
  const projectedSize=this.props.mapProjection.getProjectedSize();const arcX=arcPos[0];const arcY=arcPos[1];const twiceRadius=this.props.arcRadius*2;if(arcX<=-twiceRadius||arcX>=projectedSize[0]+twiceRadius||arcY<=-twiceRadius||arcY>=projectedSize[1]+twiceRadius){return;}display.context.beginPath();const projectedArcAngle=this.props.projectedArcAngle.get();const center=Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius,projectedArcAngle,MapAltitudeArcCanvasLayer.vec2Cache[0]),arcPos,MapAltitudeArcCanvasLayer.vec2Cache[0]);const arcStart=Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius,projectedArcAngle-this.arcHalfAngularWidth,MapAltitudeArcCanvasLayer.vec2Cache[1]),center,MapAltitudeArcCanvasLayer.vec2Cache[1]);display.context.moveTo(arcStart[0],arcStart[1]);display.context.arc(center[0],center[1],this.props.arcRadius,projectedArcAngle-this.arcHalfAngularWidth,projectedArcAngle+this.arcHalfAngularWidth);if(this.props.outlineWidth>0){display.context.lineWidth=this.totalArcThickness;display.context.strokeStyle=this.props.outlineStyle;display.context.lineCap=this.props.outlineLineCap;display.context.stroke();}if(this.props.strokeWidth>0){display.context.lineWidth=this.props.strokeWidth;display.context.strokeStyle=this.props.strokeStyle;display.context.lineCap=this.props.strokeLineCap;display.context.stroke();}this.needUpdate=false;}/** @inheritdoc */render(){return FSComponent.buildComponent(MapSyncedCanvasLayer,{ref:this.canvasLayerRef,model:this.props.model,mapProjection:this.props.mapProjection});}/** @inheritdoc */destroy(){var _a;(_a=this.canvasLayerRef.getOrDefault())===null||_a===void 0?void 0:_a.destroy();this.subscriptions.forEach(sub=>sub.destroy());super.destroy();}}MapAltitudeArcCanvasLayer.vec2Cache=[new Float64Array(2),new Float64Array(2)];/**
   * A map layer which draws an altitude intercept arc using SVG.
   */class MapAltitudeArcSvgLayer extends MapLayer{constructor(){super(...arguments);this.arcHalfAngularWidth=this.props.arcAngularWidth/2;this.totalArcThickness=this.props.strokeWidth+this.props.outlineWidth*2;this.width=this.props.arcRadius*(1-Math.cos(this.arcHalfAngularWidth))+this.totalArcThickness+2;this.height=2*this.props.arcRadius*Math.sin(Math.min(this.arcHalfAngularWidth,MathUtils.HALF_PI))+this.totalArcThickness+2;this.svgStyle=ObjectSubject.create({'display':'','position':'absolute','left':"".concat(this.totalArcThickness/2+1-this.width,"px"),'top':"".concat(-this.height/2,"px"),'width':"".concat(this.width,"px"),'height':"".concat(this.height,"px"),'transform':'translate3d(0px, 0px, 0px) rotate(0rad)','transform-origin':"".concat(this.width-(this.totalArcThickness/2+1),"px ").concat(this.height/2,"px")});this.svgTransform=CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'),CssTransformBuilder.rotate('rad'));this.needUpdate=false;this.subscriptions=[];}/** @inheritdoc */onVisibilityChanged(isVisible){if(isVisible){this.needUpdate=true;}else {this.svgStyle.set('display','none');}}/** @inheritdoc */onAttached(){const scheduleUpdate=()=>{this.needUpdate=true;};this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate,false),this.props.projectedArcAngle.sub(scheduleUpdate,false));}/** @inheritdoc */onUpdated(){if(!this.needUpdate||!this.isVisible()){return;}const arcPos=this.props.projectedArcPosition.get();// Hide the arc if it is out of bounds.
  const projectedSize=this.props.mapProjection.getProjectedSize();const arcX=arcPos[0];const arcY=arcPos[1];const twiceRadius=this.props.arcRadius*2;if(arcX<=-twiceRadius||arcX>=projectedSize[0]+twiceRadius||arcY<=-twiceRadius||arcY>=projectedSize[1]+twiceRadius){this.svgStyle.set('display','none');}else {this.svgStyle.set('display','');this.svgTransform.getChild(0).set(arcX,arcY,0,0.1);this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(),1e-4);this.svgStyle.set('transform',this.svgTransform.resolve());}this.needUpdate=false;}/** @inheritdoc */render(){const svgPathStream=new SvgPathStream(0.01);const transformPathStream=new AffineTransformPathStream(svgPathStream);// Top of the arc is at (0, 0), so the center is at (-radius, 0).
  transformPathStream.beginPath();transformPathStream.addRotation(-this.arcHalfAngularWidth).addTranslation(-this.props.arcRadius,0);transformPathStream.moveTo(this.props.arcRadius,0);transformPathStream.arc(0,0,this.props.arcRadius,0,this.props.arcAngularWidth);const path=svgPathStream.getSvgPath();return FSComponent.buildComponent("svg",{viewBox:"".concat(this.totalArcThickness/2+1-this.width," ").concat(-this.height/2," ").concat(this.width," ").concat(this.height),style:this.svgStyle},FSComponent.buildComponent("path",{d:path,fill:"none",stroke:this.props.outlineStyle,"stroke-width":this.totalArcThickness,"stroke-linecap":this.props.outlineLineCap}),FSComponent.buildComponent("path",{d:path,fill:'none',stroke:this.props.strokeStyle,"stroke-width":this.props.strokeWidth,"stroke-linecap":this.props.strokeLineCap}));}/** @inheritdoc */destroy(){this.subscriptions.forEach(sub=>sub.destroy());super.destroy();}}/// <reference types="@microsoft/msfs-types/js/common" />
  /**
   * Implementation of MapCachedCanvasLayerReference.
   */class MapCachedCanvasLayerReferenceClass{constructor(){this._center=new GeoPoint(0,0);this._scaleFactor=1;this._rotation=0;}/** @inheritdoc */get center(){return this._center.readonly;}/** @inheritdoc */get scaleFactor(){return this._scaleFactor;}/** @inheritdoc */get rotation(){return this._rotation;}/**
       * Syncs this reference with the current state of a map projection.
       * @param mapProjection The map projection with which to sync.
       */syncWithMapProjection(mapProjection){this._center.set(mapProjection.getCenter());this._scaleFactor=mapProjection.getScaleFactor();this._rotation=mapProjection.getRotation();}/**
       * Syncs this reference with another reference.
       * @param reference - the reference with which to sync.
       */syncWithReference(reference){this._center.set(reference.center);this._scaleFactor=reference.scaleFactor;this._rotation=reference.rotation;}}/**
   * Implementation of MapCachedCanvasLayerTransform.
   */class MapCachedCanvasLayerTransformClass{constructor(){this._scale=0;this._rotation=0;this._translation=new Float64Array(2);this._margin=0;this._marginRemaining=0;}/** @inheritdoc */get scale(){return this._scale;}/** @inheritdoc */get rotation(){return this._rotation;}/** @inheritdoc */get translation(){return this._translation;}/** @inheritdoc */get margin(){return this._margin;}/** @inheritdoc */get marginRemaining(){return this._marginRemaining;}/**
       * Updates this transform given the current map projection and a reference.
       * @param mapProjection The current map projection.
       * @param reference The reference to use.
       * @param referenceMargin The reference margin, in pixels.
       */update(mapProjection,reference,referenceMargin){this._scale=mapProjection.getScaleFactor()/reference.scaleFactor;this._rotation=mapProjection.getRotation()-reference.rotation;mapProjection.project(reference.center,this._translation);Vec2Math.sub(this._translation,mapProjection.getCenterProjected(),this._translation);this._margin=referenceMargin*this._scale;this._marginRemaining=this._margin-Math.max(Math.abs(this._translation[0]),Math.abs(this._translation[1]));}/**
       * Copies another transform's parameters to this one.
       * @param other The other transform.
       */copyFrom(other){this._scale=other.scale;this._rotation=other.rotation;this._translation.set(other.translation);this._margin=other.margin;}}/**
   * An implementation of MapCachedCanvasLayerCanvasInstance.
   */class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass{/**
       * Creates a new canvas instance.
       * @param canvas The canvas element.
       * @param context The canvas 2D rendering context.
       * @param isDisplayed Whether the canvas is displayed.
       * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
       * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
       */constructor(canvas,context,isDisplayed,getReferenceMargin){super(canvas,context,isDisplayed);this.getReferenceMargin=getReferenceMargin;this._reference=new MapCachedCanvasLayerReferenceClass();this._transform=new MapCachedCanvasLayerTransformClass();this._isInvalid=false;this._geoProjection=new MercatorProjection();this.canvasTransform=CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(),CssTransformBuilder.translate('px'),CssTransformBuilder.rotate('rad')));this.canvasTransform.sub(transform=>{this.canvas.style.transform=transform;},true);}/** @inheritdoc */get reference(){return this._reference;}/** @inheritdoc */get transform(){return this._transform;}/** @inheritdoc */get isInvalid(){return this._isInvalid;}/** @inheritdoc */get geoProjection(){return this._geoProjection;}/** @inheritdoc */syncWithMapProjection(mapProjection){const projectedCenter=Vec2Math.set(this.canvas.width/2,this.canvas.height/2,MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);this._reference.syncWithMapProjection(mapProjection);this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);this._transform.update(mapProjection,this.reference,this.getReferenceMargin());this._isInvalid=false;if(this.isDisplayed){this.transformCanvasElement();}}/** @inheritdoc */syncWithCanvasInstance(other){this._reference.syncWithReference(other.reference);this._geoProjection.copyParametersFrom(other.geoProjection);this._transform.copyFrom(other.transform);this._isInvalid=other.isInvalid;if(this.isDisplayed&&!this._isInvalid){this.transformCanvasElement();}}/**
       * Updates this canvas instance's transform given the current map projection.
       * @param mapProjection The current map projection.
       */updateTransform(mapProjection){this._transform.update(mapProjection,this.reference,this.getReferenceMargin());if(!this._isInvalid){const scaleFactorRatio=mapProjection.getScaleFactor()/this._reference.scaleFactor;this._isInvalid=scaleFactorRatio>=MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD||scaleFactorRatio<=1/MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD||this._transform.marginRemaining<0;}if(this.isDisplayed&&!this._isInvalid){this.transformCanvasElement();}}/**
       * Transforms this instance's canvas element.
       */transformCanvasElement(){const transform=this.transform;const offsetX=transform.translation[0]/transform.scale;const offsetY=transform.translation[1]/transform.scale;this.canvasTransform.transform.getChild(0).set(transform.scale,transform.scale,0.001);this.canvasTransform.transform.getChild(1).set(offsetX,offsetY,0.1);this.canvasTransform.transform.getChild(2).set(transform.rotation,1e-4);this.canvasTransform.resolve();}/** @inheritdoc */invalidate(){this._isInvalid=true;this.clear();}}MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD=1.2;MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1=new Float64Array(2);/**
   * A canvas map layer whose image can be cached and transformed as the map projection changes.
   */class MapCachedCanvasLayer extends MapCanvasLayer{/** @inheritdoc */constructor(props){super(props);this.size=0;this.referenceMargin=0;this.needUpdateTransforms=false;this.props.overdrawFactor=Math.max(1,this.props.overdrawFactor);}/**
       * Gets the size, in pixels, of this layer's canvas.
       * @returns the size of this layer's canvas.
       */getSize(){return this.size;}/**
       * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
       * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
       * @returns the reference translation margin of this layer's display canvas.
       */getReferenceMargin(){return this.referenceMargin;}/** @inheritdoc */onAttached(){super.onAttached();this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());this.needUpdateTransforms=true;}/** @inheritdoc */createCanvasInstance(canvas,context,isDisplayed){return new MapCachedCanvasLayerCanvasInstanceClass(canvas,context,isDisplayed,this.getReferenceMargin.bind(this));}/**
       * Updates this layer according to the current size of the projected map window.
       * @param projectedSize The size of the projected map window.
       */updateFromProjectedSize(projectedSize){const projectedWidth=projectedSize[0];const projectedHeight=projectedSize[1];const diag=Math.hypot(projectedWidth,projectedHeight);this.size=diag*this.props.overdrawFactor;this.referenceMargin=(this.size-diag)/2;this.setWidth(this.size);this.setHeight(this.size);const posX=(projectedWidth-this.size)/2;const posY=(projectedHeight-this.size)/2;const displayCanvas=this.display.canvas;displayCanvas.style.left="".concat(posX,"px");displayCanvas.style.top="".concat(posY,"px");}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){var _a;if(BitFlags.isAll(changeFlags,MapProjectionChangeType.ProjectedSize)){this.updateFromProjectedSize(mapProjection.getProjectedSize());this.display.invalidate();(_a=this.tryGetBuffer())===null||_a===void 0?void 0:_a.invalidate();}this.needUpdateTransforms=true;}/** @inheritdoc */onUpdated(time,elapsed){super.onUpdated(time,elapsed);if(!this.needUpdateTransforms){return;}this.updateTransforms();}/**
       * Updates this layer's canvas instances' transforms.
       */updateTransforms(){var _a;const mapProjection=this.props.mapProjection;this.display.updateTransform(mapProjection);(_a=this.tryGetBuffer())===null||_a===void 0?void 0:_a.updateTransform(mapProjection);this.needUpdateTransforms=false;}}/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**
   * A layer which draws an own airplane icon. The icon is positioned at the projected location of the airplane and is
   * rotated to match the airplane's heading.
   */class MapOwnAirplaneLayer extends MapLayer{constructor(){super(...arguments);this.imageFilePath=SubscribableUtils.isSubscribable(this.props.imageFilePath)?this.props.imageFilePath.map(SubscribableMapFunctions.identity()):this.props.imageFilePath;this.style=ObjectSubject.create({display:'',position:'absolute',left:'0px',top:'0px',width:'0px',height:'0px',transform:'translate3d(0, 0, 0) rotate(0deg)','transform-origin':'50% 50%'});this.ownAirplanePropsModule=this.props.model.getModule('ownAirplaneProps');this.ownAirplaneIconModule=this.props.model.getModule('ownAirplaneIcon');this.iconSize=SubscribableUtils.toSubscribable(this.props.iconSize,true);this.iconAnchor=SubscribableUtils.toSubscribable(this.props.iconAnchor,true);this.iconOffset=Vec2Math.create();this.visibilityBounds=VecNMath.create(4);this.iconTransform=CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'),CssTransformBuilder.rotate('deg'));this.isGsAboveTrackThreshold=this.ownAirplanePropsModule.groundSpeed.map(gs=>gs.asUnit(UnitType.KNOT)>=5).pause();this.showIcon=true;this.isInsideVisibilityBounds=true;this.planeRotation=0;this.needUpdateVisibility=false;this.needUpdatePositionRotation=false;}/** @inheritdoc */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onVisibilityChanged(isVisible){this.needUpdateVisibility=true;this.needUpdatePositionRotation=this.showIcon=isVisible&&this.ownAirplaneIconModule.show.get();}/** @inheritdoc */onAttached(){this.showSub=this.ownAirplaneIconModule.show.sub(show=>{this.needUpdateVisibility=true;this.needUpdatePositionRotation=this.showIcon=show&&this.isVisible();});this.positionSub=this.ownAirplanePropsModule.position.sub(()=>{this.needUpdatePositionRotation=this.showIcon;});this.headingSub=this.ownAirplanePropsModule.hdgTrue.sub(hdg=>{this.planeRotation=hdg;this.needUpdatePositionRotation=this.showIcon;},false,true);this.trackSub=this.ownAirplanePropsModule.trackTrue.sub(track=>{this.planeRotation=track;this.needUpdatePositionRotation=this.showIcon;},false,true);this.trackThresholdSub=this.isGsAboveTrackThreshold.sub(isAboveThreshold=>{if(isAboveThreshold){this.headingSub.pause();this.trackSub.resume(true);}else {this.trackSub.pause();this.headingSub.resume(true);}},false,true);this.iconSizeSub=this.iconSize.sub(size=>{this.style.set('width',"".concat(size,"px"));this.style.set('height',"".concat(size,"px"));this.updateOffset();},true);this.iconAnchorSub=this.iconAnchor.sub(()=>{this.updateOffset();});this.orientationSub=this.ownAirplaneIconModule.orientation.sub(orientation=>{switch(orientation){case MapOwnAirplaneIconOrientation.HeadingUp:this.isGsAboveTrackThreshold.pause();this.trackThresholdSub.pause();this.trackSub.pause();this.headingSub.resume(true);break;case MapOwnAirplaneIconOrientation.TrackUp:this.headingSub.pause();this.trackSub.pause();this.isGsAboveTrackThreshold.resume();this.trackThresholdSub.resume(true);break;default:this.needUpdatePositionRotation=this.showIcon;this.isGsAboveTrackThreshold.pause();this.trackThresholdSub.pause();this.headingSub.pause();this.trackSub.pause();this.planeRotation=0;}},true);this.needUpdateVisibility=true;this.needUpdatePositionRotation=true;}/**
       * Updates the icon's offset from the projected position of the airplane.
       */updateOffset(){const anchor=this.iconAnchor.get();this.iconOffset.set(anchor);Vec2Math.multScalar(this.iconOffset,-this.iconSize.get(),this.iconOffset);this.style.set('left',"".concat(this.iconOffset[0],"px"));this.style.set('top',"".concat(this.iconOffset[1],"px"));this.style.set('transform-origin',"".concat(anchor[0]*100,"% ").concat(anchor[1]*100,"%"));this.updateVisibilityBounds();}/**
       * Updates the boundaries within the map's projected window that define a region such that if the airplane's
       * projected position falls outside of it, the icon is not visible and therefore does not need to be updated.
       */updateVisibilityBounds(){const size=this.iconSize.get();// Find the maximum possible protrusion of the icon from its anchor point, defined as the distance from the
  // anchor point to the farthest point within the bounds of the icon. This farthest point is always one of the
  // four corners of the icon.
  const maxProtrusion=Math.max(Math.hypot(this.iconOffset[0],this.iconOffset[1]),// top left corner
  Math.hypot(this.iconOffset[0]+size,this.iconOffset[1]),// top right corner
  Math.hypot(this.iconOffset[0]+size,this.iconOffset[1]+size),// bottom right corner
  Math.hypot(this.iconOffset[0],this.iconOffset[1]+size));const boundsOffset=maxProtrusion+50;// Add some additional buffer
  const projectedSize=this.props.mapProjection.getProjectedSize();this.visibilityBounds[0]=-boundsOffset;this.visibilityBounds[1]=-boundsOffset;this.visibilityBounds[2]=projectedSize[0]+boundsOffset;this.visibilityBounds[3]=projectedSize[1]+boundsOffset;this.needUpdatePositionRotation=this.showIcon;}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){if(BitFlags.isAll(changeFlags,MapProjectionChangeType.ProjectedSize)){this.updateVisibilityBounds();}this.needUpdatePositionRotation=this.showIcon;}/** @inheritdoc */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdated(time,elapsed){if(this.needUpdatePositionRotation){this.updateIconPositionRotation();this.needUpdatePositionRotation=false;this.needUpdateVisibility=false;}else if(this.needUpdateVisibility){this.updateIconVisibility();this.needUpdateVisibility=false;}}/**
       * Updates the airplane icon's visibility.
       */updateIconVisibility(){this.style.set('display',this.isInsideVisibilityBounds&&this.showIcon?'':'none');}/**
       * Updates the airplane icon's projected position and rotation.
       */updateIconPositionRotation(){const projected=this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(),MapOwnAirplaneLayer.vec2Cache[0]);this.isInsideVisibilityBounds=this.props.mapProjection.isInProjectedBounds(projected,this.visibilityBounds);// If the projected position of the icon is far enough out of bounds that the icon is not visible, do not bother to
  // update the icon.
  if(this.isInsideVisibilityBounds){let rotation;switch(this.ownAirplaneIconModule.orientation.get()){case MapOwnAirplaneIconOrientation.HeadingUp:case MapOwnAirplaneIconOrientation.TrackUp:rotation=this.planeRotation+this.props.mapProjection.getRotation()*Avionics.Utils.RAD2DEG;break;default:rotation=0;}this.iconTransform.getChild(0).set(projected[0],projected[1],0,0.1);this.iconTransform.getChild(1).set(rotation,0.1);this.style.set('transform',this.iconTransform.resolve());}this.updateIconVisibility();}/** @inheritdoc */render(){var _a;return FSComponent.buildComponent("img",{src:this.imageFilePath,class:(_a=this.props.class)!==null&&_a!==void 0?_a:'',style:this.style});}/** @inheritdoc */destroy(){var _a,_b,_c,_d,_e,_f,_g,_h;if(SubscribableUtils.isSubscribable(this.imageFilePath)){this.imageFilePath.destroy();}this.isGsAboveTrackThreshold.destroy();(_a=this.showSub)===null||_a===void 0?void 0:_a.destroy();(_b=this.positionSub)===null||_b===void 0?void 0:_b.destroy();(_c=this.headingSub)===null||_c===void 0?void 0:_c.destroy();(_d=this.trackSub)===null||_d===void 0?void 0:_d.destroy();(_e=this.trackThresholdSub)===null||_e===void 0?void 0:_e.destroy();(_f=this.iconSizeSub)===null||_f===void 0?void 0:_f.destroy();(_g=this.iconAnchorSub)===null||_g===void 0?void 0:_g.destroy();(_h=this.orientationSub)===null||_h===void 0?void 0:_h.destroy();super.destroy();}}MapOwnAirplaneLayer.vec2Cache=[Vec2Math.create()];/**
   * A layer which draws airspaces.
   */class MapAirspaceLayer extends MapLayer{constructor(){var _a,_b;super(...arguments);this.canvasLayerRef=FSComponent.createRef();this.clipBoundsSub=VecNSubject.createFromVector(new Float64Array(4));this.facLoader=new FacilityLoader(FacilityRepository.getRepository(this.props.bus),async()=>{this.searchSession=new NearestLodBoundarySearchSession(this.props.lodBoundaryCache,await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary),0.5);this.isAttached&&this.scheduleSearch(0,true);});this.searchedAirspaces=new Map();this.searchDebounceDelay=(_a=this.props.searchDebounceDelay)!==null&&_a!==void 0?_a:MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;this.renderTimeBudget=(_b=this.props.renderTimeBudget)!==null&&_b!==void 0?_b:MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;this.activeRenderProcess=null;this.renderTaskQueueHandler={renderTimeBudget:this.renderTimeBudget,// eslint-disable-next-line jsdoc/require-jsdoc
  onStarted(){// noop
  },// eslint-disable-next-line jsdoc/require-jsdoc
  canContinue(elapsedFrameCount,dispatchedTaskCount,timeElapsed){return timeElapsed<this.renderTimeBudget;},// eslint-disable-next-line jsdoc/require-jsdoc
  onPaused:this.onRenderPaused.bind(this),// eslint-disable-next-line jsdoc/require-jsdoc
  onFinished:this.onRenderFinished.bind(this),// eslint-disable-next-line jsdoc/require-jsdoc
  onAborted:this.onRenderAborted.bind(this)};this.searchDebounceTimer=0;this.isSearchScheduled=false;this.needRefilter=false;this.isSearchBusy=false;this.lastDesiredSearchRadius=0;// meters
  this.lastSearchRadius=0;// meters
  this.isRenderScheduled=false;this.isBackgroundRenderScheduled=false;this.isDisplayInvalidated=true;this.isAttached=false;}/** @inheritdoc */onAttached(){this.canvasLayerRef.instance.onAttached();this.updateClipBounds();this.clippedPathStream=new ClippedPathStream(this.canvasLayerRef.instance.buffer.context,this.clipBoundsSub);this.props.maxSearchRadius.sub(radius=>{const radiusMeters=radius.asUnit(UnitType.METER);if(radiusMeters<this.lastSearchRadius||radiusMeters>this.lastDesiredSearchRadius){this.scheduleSearch(0,false);}});this.props.maxSearchItemCount.sub(()=>{this.scheduleSearch(0,false);});this.initModuleListeners();this.isAttached=true;this.searchSession&&this.scheduleSearch(0,true);}/**
       * Initializes this layer's airspace module property listeners.
       */initModuleListeners(){const airspaceModule=this.props.model.getModule('airspace');for(const type of Object.values(airspaceModule.show)){type.sub(this.onAirspaceTypeShowChanged.bind(this));}}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);if(BitFlags.isAll(changeFlags,MapProjectionChangeType.ProjectedSize)){this.updateClipBounds();}}/**
       * Updates this layer's canvas clipping bounds.
       */updateClipBounds(){const size=this.canvasLayerRef.instance.getSize();this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER,-MapAirspaceLayer.CLIP_BOUNDS_BUFFER,size+MapAirspaceLayer.CLIP_BOUNDS_BUFFER,size+MapAirspaceLayer.CLIP_BOUNDS_BUFFER);}/**
       * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
       * replace the old one.
       * @param delay The delay, in milliseconds, before the search is executed.
       * @param refilter Whether to update the search's boundary class filter.
       */scheduleSearch(delay,refilter){if(!this.searchSession){return;}this.searchDebounceTimer=delay;this.isSearchScheduled=true;this.needRefilter||(this.needRefilter=refilter);}/**
       * Schedules a render to be executed during the next update cycle.
       */scheduleRender(){this.isRenderScheduled=true;}/**
       * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
       * and, if necessary, rendered.
       * @param refilter Whether to update the search's boundary class filter.
       */async searchAirspaces(refilter){this.isSearchBusy=true;const center=this.props.mapProjection.getCenter();const drawableDiag=this.canvasLayerRef.instance.display.canvas.width*Math.SQRT2;this.lastDesiredSearchRadius=UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution()*drawableDiag/2,UnitType.METER);this.lastSearchRadius=Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER),this.lastDesiredSearchRadius);// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const session=this.searchSession;refilter&&session.setFilter(this.getBoundaryFilter());const results=await session.searchNearest(center.lat,center.lon,this.lastSearchRadius,this.props.maxSearchItemCount.get());for(let i=0;i<results.added.length;i++){const airspace=results.added[i];this.searchedAirspaces.set(airspace.facility.id,airspace);}for(let i=0;i<results.removed.length;i++){this.searchedAirspaces.delete(results.removed[i]);}this.isSearchBusy=false;this.scheduleRender();}/**
       * Gets the boundary class filter based on the current airspace type visibility settings.
       * @returns The boundary class filter based on the current airspace type visibility settings.
       */getBoundaryFilter(){const module=this.props.model.getModule('airspace');const show=module.show;let filter=0;for(const type in show){if(show[type].get()){filter|=module.showTypes[type];}}return filter;}// eslint-disable-next-line jsdoc/require-jsdoc
  onUpdated(time,elapsed){this.canvasLayerRef.instance.onUpdated(time,elapsed);this.updateFromInvalidation();this.updateScheduledRender();this.updateScheduledSearch(elapsed);}/**
       * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
       */updateFromInvalidation(){const canvasLayer=this.canvasLayerRef.instance;const display=canvasLayer.display;const buffer=canvasLayer.buffer;const needBackgroundRender=!this.isBackgroundRenderScheduled&&!this.activeRenderProcess&&display.transform.marginRemaining/display.transform.margin<=MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD;const shouldScheduleSearch=needBackgroundRender||display.isInvalid||buffer.isInvalid&&this.activeRenderProcess;this.isBackgroundRenderScheduled||(this.isBackgroundRenderScheduled=needBackgroundRender);if(display.isInvalid){this.isDisplayInvalidated=true;this.isBackgroundRenderScheduled=false;display.clear();display.syncWithMapProjection(this.props.mapProjection);}if(buffer.isInvalid){if(this.activeRenderProcess){this.activeRenderProcess.abort();this.cleanUpRender();}buffer.clear();buffer.syncWithMapProjection(this.props.mapProjection);}if(shouldScheduleSearch){this.scheduleSearch(this.searchDebounceDelay,false);}}/**
       * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
       * @param elapsed The time elapsed, in milliseconds, since the last update.
       */updateScheduledSearch(elapsed){if(!this.isSearchScheduled){return;}this.searchDebounceTimer=Math.max(0,this.searchDebounceTimer-elapsed);if(this.searchDebounceTimer===0&&!this.isSearchBusy){this.searchAirspaces(this.needRefilter);this.isSearchScheduled=false;this.needRefilter=false;}}/**
       * Executes a render if one is scheduled.
       */updateScheduledRender(){if(!this.isRenderScheduled){return;}this.startRenderProcess();this.isRenderScheduled=false;this.isBackgroundRenderScheduled=false;}/**
       * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
       * the display.
       */startRenderProcess(){const canvasLayer=this.canvasLayerRef.instance;if(this.activeRenderProcess){this.activeRenderProcess.abort();}const buffer=canvasLayer.buffer;buffer.clear();buffer.syncWithMapProjection(this.props.mapProjection);this.props.airspaceRenderManager.clearRegisteredAirspaces();for(const airspace of this.searchedAirspaces.values()){if(this.isAirspaceInBounds(airspace,buffer)){this.props.airspaceRenderManager.registerAirspace(airspace);}}const lod=this.selectLod(this.props.mapProjection.getProjectedResolution());this.activeRenderProcess=this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection,buffer.context,this.renderTaskQueueHandler,lod,this.clippedPathStream);this.activeRenderProcess.start();}/**
       * Checks whether an airspace is within the projected bounds of a cached canvas instance.
       * @param airspace An airspace.
       * @param canvas A cached canvas instance.
       * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
       */isAirspaceInBounds(airspace,canvas){const corner=MapAirspaceLayer.geoPointCache[0];const cornerProjected=MapAirspaceLayer.vec2Cache[0];let minX,maxX,minY,maxY;canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat,airspace.facility.topLeft.long),cornerProjected);minX=maxX=cornerProjected[0];minY=maxY=cornerProjected[1];canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat,airspace.facility.bottomRight.long),cornerProjected);minX=Math.min(minX,cornerProjected[0]);maxX=Math.max(maxX,cornerProjected[0]);minY=Math.min(minY,cornerProjected[1]);maxY=Math.max(maxY,cornerProjected[1]);canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat,airspace.facility.bottomRight.long),cornerProjected);minX=Math.min(minX,cornerProjected[0]);maxX=Math.max(maxX,cornerProjected[0]);minY=Math.min(minY,cornerProjected[1]);maxY=Math.max(maxY,cornerProjected[1]);canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat,airspace.facility.topLeft.long),cornerProjected);minX=Math.min(minX,cornerProjected[0]);maxX=Math.max(maxX,cornerProjected[0]);minY=Math.min(minY,cornerProjected[1]);maxY=Math.max(maxY,cornerProjected[1]);const width=canvas.canvas.width;const height=canvas.canvas.height;return minX<width&&maxX>0&&minY<height&&maxY>0;}/**
       * Selects an LOD level based on projected map resolution.
       * @param resolution A projected map resolution, in great-arc radians per pixel.
       * @returns An LOD level based on the projected map resolution.
       */selectLod(resolution){const thresholds=this.props.lodBoundaryCache.lodDistanceThresholds;let i=thresholds.length-1;while(i>=0){if(resolution*2>=thresholds[i]){break;}i--;}return i;}/**
       * Cleans up the active render process.
       */cleanUpRender(){this.canvasLayerRef.instance.buffer.reset();this.activeRenderProcess=null;}/**
       * Renders airspaces from the buffer to the display.
       */renderAirspacesToDisplay(){const display=this.canvasLayerRef.instance.display;const buffer=this.canvasLayerRef.instance.buffer;display.clear();display.syncWithCanvasInstance(buffer);this.canvasLayerRef.instance.copyBufferToDisplay();}/**
       * This method is called when the airspace render process pauses.
       */onRenderPaused(){if(this.isDisplayInvalidated){this.renderAirspacesToDisplay();}}/**
       * This method is called when the airspace render process finishes.
       */onRenderFinished(){this.renderAirspacesToDisplay();this.cleanUpRender();this.isDisplayInvalidated=false;}/**
       * This method is called when the airspace render process is aborted.
       */onRenderAborted(){this.cleanUpRender();}/**
       * This method is called when an airspace show property changes.
       */onAirspaceTypeShowChanged(){this.scheduleSearch(0,true);}/** @inheritdoc */render(){return FSComponent.buildComponent(MapCachedCanvasLayer,{ref:this.canvasLayerRef,model:this.props.model,mapProjection:this.props.mapProjection,useBuffer:true,overdrawFactor:Math.SQRT2});}}MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY=500;// milliseconds
  MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET=0.2;// milliseconds per frame
  MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD=0.1;// relative to total margin
  MapAirspaceLayer.CLIP_BOUNDS_BUFFER=10;// number of pixels from edge of canvas to extend the clipping bounds, in pixels
  MapAirspaceLayer.geoPointCache=[new GeoPoint(0,0)];MapAirspaceLayer.vec2Cache=[new Float64Array(2)];/**
   * An abstract implementation of a map layer which displays waypoints (airports, navaids, and intersections) within a
   * search radius.
   */class MapNearestWaypointsLayer extends MapLayer{constructor(){var _a;super(...arguments);this.canvasLayerRef=FSComponent.createRef();this.searchDebounceDelay=(_a=this.props.searchDebounceDelay)!==null&&_a!==void 0?_a:500;this.facLoader=new FacilityLoader(FacilityRepository.getRepository(this.props.bus),this.onFacilityLoaderInitialized.bind(this));this.searchRadius=0;this.searchMargin=0;this.userFacilityHasChanged=false;/** A set of the ICAOs of all waypoints that should be rendered. */this.icaosToRender=new Set();/** A map of rendered waypoints from their ICAOs. */this.cachedRenderedWaypoints=new Map();this.isInit=false;this.facilityRepoSubs=[];}/**
       * A callback called when the facility loaded finishes initialization.
       */onFacilityLoaderInitialized(){Promise.all([this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),this.facLoader.startNearestSearchSession(FacilitySearchType.User)]).then(value=>{const[airportSession,vorSession,ndbSession,intSession,userSession]=value;this.onSessionsStarted(airportSession,vorSession,ndbSession,intSession,userSession);});}/**
       * A callback called when the nearest facility search sessions have been started.
       * @param airportSession The airport search session.
       * @param vorSession The VOR search session.
       * @param ndbSession The NDB search session.
       * @param intSession The intersection search session.
       * @param userSession The user facility search session.
       */onSessionsStarted(airportSession,vorSession,ndbSession,intSession,userSession){const callback=this.processSearchResults.bind(this);this.facilitySearches={[FacilitySearchType.Airport]:new MapNearestWaypointsLayerSearch(airportSession,callback),[FacilitySearchType.Vor]:new MapNearestWaypointsLayerSearch(vorSession,callback),[FacilitySearchType.Ndb]:new MapNearestWaypointsLayerSearch(ndbSession,callback),[FacilitySearchType.Intersection]:new MapNearestWaypointsLayerSearch(intSession,callback),[FacilitySearchType.User]:new MapNearestWaypointsLayerSearch(userSession,callback)};const sub=this.props.bus.getSubscriber();// Watch for changes to user facilities so that we can trigger search refreshes to ensure that the layer does not
  // display outdated user waypoints.
  this.facilityRepoSubs.push(sub.on('facility_added').handle(fac=>{if(ICAO.isFacility(fac.icao,FacilityType.USR)){this.userFacilityHasChanged=true;}}),sub.on('facility_changed').handle(fac=>{if(ICAO.isFacility(fac.icao,FacilityType.USR)){this.userFacilityHasChanged=true;}}),sub.on('facility_removed').handle(fac=>{if(ICAO.isFacility(fac.icao,FacilityType.USR)){this.userFacilityHasChanged=true;}}));this.props.onSessionsStarted&&this.props.onSessionsStarted(airportSession,vorSession,ndbSession,intSession,userSession);if(this.isInit){this._tryRefreshAllSearches(this.getSearchCenter(),this.searchRadius);}}/** @inheritdoc */onAttached(){super.onAttached();this.canvasLayerRef.instance.onAttached();this.doInit();this.isInit=true;this._tryRefreshAllSearches(this.getSearchCenter(),this.searchRadius);}/**
       * Initializes this layer.
       */doInit(){this.initWaypointRenderer();this.updateSearchRadius();}/**
       * Gets the search center for the waypoint searches on this layer.
       * @returns The waypoint search center geo point.
       */getSearchCenter(){return this.props.getSearchCenter?this.props.getSearchCenter(this.props.mapProjection):this.props.mapProjection.getCenter();}/**
       * Initializes this layer's waypoint renderer.
       */initWaypointRenderer(){this.props.initRenderer&&this.props.initRenderer(this.props.waypointRenderer,this.canvasLayerRef.instance);}/** Forces a refresh of all the waypoints. */refreshWaypoints(){this.tryRefreshAllSearches(undefined,undefined,true);this.cachedRenderedWaypoints.forEach(w=>{this.props.deregisterWaypoint(w,this.props.waypointRenderer);});this.cachedRenderedWaypoints.forEach(w=>{this.props.registerWaypoint(w,this.props.waypointRenderer);});}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);if(BitFlags.isAny(changeFlags,MapProjectionChangeType.Range|MapProjectionChangeType.RangeEndpoints|MapProjectionChangeType.ProjectedSize)){this.updateSearchRadius();this._tryRefreshAllSearches(this.getSearchCenter(),this.searchRadius);}else if(BitFlags.isAll(changeFlags,MapProjectionChangeType.Center)){this._tryRefreshAllSearches(this.getSearchCenter(),this.searchRadius);}}/**
       * Updates the desired nearest facility search radius based on the current map projection.
       */updateSearchRadius(){let mapHalfDiagRange=Vec2Math.abs(this.props.mapProjection.getProjectedSize())*this.props.mapProjection.getProjectedResolution()/2;//Limit lower end of radius so that even at high zooms the surrounding area waypoints are captured.
  mapHalfDiagRange=Math.max(mapHalfDiagRange,UnitType.NMILE.convertTo(5,UnitType.GA_RADIAN));this.searchRadius=mapHalfDiagRange*MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;this.searchMargin=mapHalfDiagRange*(MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR-1);}/** @inheritdoc */onUpdated(time,elapsed){var _a;// If a user facility was added, changed, or removed, schedule a user waypoint search refresh so that we always
  // have the latest user facility data.
  if(this.userFacilityHasChanged){const search=(_a=this.facilitySearches)===null||_a===void 0?void 0:_a[FacilitySearchType.User];if(search!==undefined){this.userFacilityHasChanged=false;this.scheduleSearchRefresh(FacilitySearchType.User,search,this.getSearchCenter(),this.searchRadius);}}this.updateSearches(elapsed);}/**
       * Updates this layer's facility searches.
       * @param elapsed The elapsed time, in milliseconds, since the last update.
       */updateSearches(elapsed){if(!this.facilitySearches){return;}this.facilitySearches[FacilitySearchType.Airport].update(elapsed);this.facilitySearches[FacilitySearchType.Vor].update(elapsed);this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);this.facilitySearches[FacilitySearchType.User].update(elapsed);}/**
       * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
       * radius is different from the last refreshed search radius or the desired search center is outside of the margin
       * of the last refreshed search center.
       * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
       * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
       * calculated search radius.
       * @param force Whether to force a refresh of all waypoints. Defaults to false.
       */tryRefreshAllSearches(center,radius,force){center!==null&&center!==void 0?center:center=this.getSearchCenter();radius!==null&&radius!==void 0?radius:radius=this.searchRadius;this._tryRefreshAllSearches(center,radius,force);}/**
       * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
       * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
       * search center.
       * @param type The type of nearest search to refresh.
       * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
       * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
       * calculated search radius.
       * @param force Whether to force a refresh of all waypoints. Defaults to false.
       */tryRefreshSearch(type,center,radius,force){center!==null&&center!==void 0?center:center=this.getSearchCenter();radius!==null&&radius!==void 0?radius:radius=this.searchRadius;this._tryRefreshSearch(type,center,radius,force);}/**
       * Attempts to refresh all of the nearest facility searches.
       * @param center The center of the search area.
       * @param radius The radius of the search area, in great-arc radians.
       * @param force Whether to force a refresh of all waypoints. Defaults to false.
       */_tryRefreshAllSearches(center,radius,force){this._tryRefreshSearch(FacilitySearchType.Airport,center,radius,force);this._tryRefreshSearch(FacilitySearchType.Vor,center,radius,force);this._tryRefreshSearch(FacilitySearchType.Ndb,center,radius,force);this._tryRefreshSearch(FacilitySearchType.Intersection,center,radius,force);this._tryRefreshSearch(FacilitySearchType.User,center,radius,force);}/**
       * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
       * true and and the desired search radius is different from the last refreshed search radius or the desired search
       * center is outside of the margin of the last refreshed search center.
       * @param type The type of nearest search to refresh.
       * @param center The center of the search area.
       * @param radius The radius of the search area, in great-arc radians.
       * @param force Whether to force a refresh of all waypoints. Defaults to false.
       */_tryRefreshSearch(type,center,radius,force){const search=this.facilitySearches&&this.facilitySearches[type];if(!search||!force&&!this.shouldRefreshSearch(type,center,radius)){return;}const radiusLimit=this.props.searchRadiusLimit?this.props.searchRadiusLimit(type,center,radius):undefined;if(radiusLimit!==undefined&&isFinite(radiusLimit)){radius=Math.min(radius,Math.max(0,radiusLimit));}if(force||search.lastRadius!==radius||search.lastCenter.distance(center)>=this.searchMargin){this.scheduleSearchRefresh(type,search,center,radius);}}/**
       * Checks whether one of this layer's searches should be refreshed.
       * @param type The type of nearest search to refresh.
       * @param center The center of the search area.
       * @param radius The radius of the search area, in great-arc radians.
       * @returns Whether the search should be refreshed.
       */shouldRefreshSearch(type,center,radius){return this.props.shouldRefreshSearch?this.props.shouldRefreshSearch(type,center,radius):true;}/**
       * Schedules a refresh of this one of this layer's searches.
       * @param type The type of nearest search to refresh.
       * @param search The search to refresh.
       * @param center The center of the search area.
       * @param radius The radius of the search area, in great-arc radians.
       */scheduleSearchRefresh(type,search,center,radius){const itemLimit=this.props.searchItemLimit?this.props.searchItemLimit(type,center,radius):100;search.scheduleRefresh(center,radius,itemLimit,this.searchDebounceDelay);}/**
       * Processes nearest facility search results. New facilities are registered, while removed facilities are
       * deregistered.
       * @param results Nearest facility search results.
       */processSearchResults(results){if(!results){return;}const numAdded=results.added.length;for(let i=0;i<numAdded;i++){const icao=results.added[i];if(icao===undefined||icao===ICAO.emptyIcao){continue;}this.registerIcao(icao);}const numRemoved=results.removed.length;for(let i=0;i<numRemoved;i++){const icao=results.removed[i];if(icao===undefined||icao===ICAO.emptyIcao){continue;}this.deregisterIcao(icao);}}/**
       * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
       * layer using a waypoint renderer.
       * @param icao The ICAO string to register.
       */async registerIcao(icao){this.icaosToRender.add(icao);try{const facility=await this.facLoader.getFacility(ICAO.getFacilityType(icao),icao);if(!this.icaosToRender.has(icao)){return;}this.registerWaypointWithRenderer(this.props.waypointRenderer,facility);}catch(_a){// noop
  }}/**
       * Registers a facility with this layer's waypoint renderer.
       * @param renderer This layer's waypoint renderer.
       * @param facility The facility to register.
       */registerWaypointWithRenderer(renderer,facility){const waypoint=this.props.waypointForFacility(facility);this.cachedRenderedWaypoints.set(facility.icao,waypoint);this.props.registerWaypoint(waypoint,renderer);}/**
       * Deregisters an ICAO string from this layer.
       * @param icao The ICAO string to deregister.
       */async deregisterIcao(icao){this.icaosToRender.delete(icao);try{const facility=await this.facLoader.getFacility(ICAO.getFacilityType(icao),icao);if(this.icaosToRender.has(icao)){return;}this.deregisterWaypointWithRenderer(this.props.waypointRenderer,facility);}catch(_a){if(this.icaosToRender.has(icao)){return;}// If we can't find the facility from the ICAO, it could be that the facility has been removed, in which case
  // we grab the cached waypoint (the waypoint that was most recently registered with the renderer under the
  // removed ICAO) and deregister it.
  const cachedWaypoint=this.cachedRenderedWaypoints.get(icao);if(cachedWaypoint!==undefined){this.cachedRenderedWaypoints.delete(icao);this.props.deregisterWaypoint(cachedWaypoint,this.props.waypointRenderer);}}}/**
       * Deregisters a facility from this layer's waypoint renderer.
       * @param renderer This layer's waypoint renderer.
       * @param facility The facility to deregister.
       */deregisterWaypointWithRenderer(renderer,facility){const waypoint=this.props.waypointForFacility(facility);this.cachedRenderedWaypoints.delete(facility.icao);this.props.deregisterWaypoint(waypoint,renderer);}/** @inheritdoc */setVisible(val){super.setVisible(val);this.canvasLayerRef.instance.setVisible(val);}/** @inheritdoc */render(){var _a;return FSComponent.buildComponent(MapSyncedCanvasLayer,{ref:this.canvasLayerRef,model:this.props.model,mapProjection:this.props.mapProjection,class:(_a=this.props.class)!==null&&_a!==void 0?_a:''});}/** @inheritdoc */destroy(){var _a;(_a=this.canvasLayerRef.getOrDefault())===null||_a===void 0?void 0:_a.destroy();this.facilityRepoSubs.forEach(sub=>{sub.destroy();});super.destroy();}}MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR=Math.SQRT2;/**
   * A nearest facility search for MapAbstractNearestWaypointsLayer.
   */class MapNearestWaypointsLayerSearch{/**
       * Constructor.
       * @param session The session used by this search.
       * @param refreshCallback A callback which is called every time the search refreshes.
       */constructor(session,refreshCallback){this.session=session;this.refreshCallback=refreshCallback;this._lastCenter=new GeoPoint(0,0);this._lastRadius=0;this.maxItemCount=0;this.refreshDebounceTimer=0;this.isRefreshScheduled=false;}// eslint-disable-next-line jsdoc/require-returns
  /**
       * The center of this search's last refresh.
       */get lastCenter(){return this._lastCenter.readonly;}// eslint-disable-next-line jsdoc/require-returns
  /**
       * The radius of this search's last refresh, in great-arc radians.
       */get lastRadius(){return this._lastRadius;}/**
       * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
       * scheduled refresh will replace the old one.
       * @param center The center of the search area.
       * @param radius The radius of the search area, in great-arc radians.
       * @param maxItemCount The maximum number of results returned by the refresh.
       * @param delay The delay, in milliseconds, before the refresh is executed.
       */scheduleRefresh(center,radius,maxItemCount,delay){this._lastCenter.set(center);this._lastRadius=radius;this.maxItemCount=maxItemCount;if(!this.isRefreshScheduled){this.refreshDebounceTimer=delay;this.isRefreshScheduled=true;}}/**
       * Updates this search. Executes any pending refreshes if their delay timers have expired.
       * @param elapsed The elapsed time, in milliseconds, since the last update.
       */update(elapsed){if(!this.isRefreshScheduled){return;}this.refreshDebounceTimer=Math.max(0,this.refreshDebounceTimer-elapsed);if(this.refreshDebounceTimer===0){this.refresh();this.isRefreshScheduled=false;}}/**
       * Refreshes this search.
       * @returns a Promise which is fulfilled when the refresh completes.
       */async refresh(){const results=await this.session.searchNearest(this._lastCenter.lat,this._lastCenter.lon,UnitType.GA_RADIAN.convertTo(this._lastRadius,UnitType.METER),this.maxItemCount);this.refreshCallback(results);}}/**
   * A map layer that draws a line between two points. The line is drawn in projected coordinate space, so it will always
   * be straight on the projected map.
   */class MapLineLayer extends MapSyncedCanvasLayer{constructor(){var _a,_b,_c,_d,_e,_f;super(...arguments);this.strokeWidth=(_a=this.props.strokeWidth)!==null&&_a!==void 0?_a:MapLineLayer.DEFAULT_STROKE_WIDTH;this.strokeStyle=(_b=this.props.strokeStyle)!==null&&_b!==void 0?_b:MapLineLayer.DEFAULT_STROKE_STYLE;this.strokeDash=(_c=this.props.strokeDash)!==null&&_c!==void 0?_c:MapLineLayer.DEFAULT_STROKE_DASH;this.outlineWidth=(_d=this.props.outlineWidth)!==null&&_d!==void 0?_d:MapLineLayer.DEFAULT_OUTLINE_WIDTH;this.outlineStyle=(_e=this.props.outlineStyle)!==null&&_e!==void 0?_e:MapLineLayer.DEFAULT_OUTLINE_STYLE;this.outlineDash=(_f=this.props.outlineDash)!==null&&_f!==void 0?_f:MapLineLayer.DEFAULT_OUTLINE_DASH;this.vec=new Float64Array([0,0]);this.isUpdateScheduled=false;}/** @inheritdoc */onAttached(){super.onAttached();this.props.start.sub(()=>{this.scheduleUpdate();});this.props.end.sub(()=>{this.scheduleUpdate();});this.scheduleUpdate();}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){super.onMapProjectionChanged(mapProjection,changeFlags);this.scheduleUpdate();}/**
       * Schedules the layer for a draw update.
       */scheduleUpdate(){this.isUpdateScheduled=true;}/** @inheritdoc */onUpdated(time,elapsed){super.onUpdated(time,elapsed);if(this.isUpdateScheduled){this.display.clear();const start=this.props.start.get();const end=this.props.end.get();if(start!==null&&end!==null){const[x1,y1]=start instanceof Float64Array?start:this.props.mapProjection.project(start,this.vec);const[x2,y2]=end instanceof Float64Array?end:this.props.mapProjection.project(end,this.vec);this.drawLine(x1,y1,x2,y2);}this.isUpdateScheduled=false;}}/**
       * Draws this layer's line.
       * @param x1 The x coordinate of the start of the line.
       * @param y1 The y coordinate of the start of the line.
       * @param x2 The x coordinate of the end of the line.
       * @param y2 The y coordinate of the end of the line.
       */drawLine(x1,y1,x2,y2){const context=this.display.context;context.beginPath();context.moveTo(x1,y1);context.lineTo(x2,y2);if(this.outlineWidth>0){this.stroke(context,this.strokeWidth+this.outlineWidth*2,this.outlineStyle,this.outlineDash);}if(this.strokeWidth>0){this.stroke(context,this.strokeWidth,this.strokeStyle,this.strokeDash);}}/**
       * Applies a stroke to a canvas rendering context.
       * @param context A canvas rendering context.
       * @param width The width of the stroke, in pixels.
       * @param style The style of the stroke.
       * @param dash The dash array of the stroke.
       */stroke(context,width,style,dash){context.lineWidth=width;context.strokeStyle=style;context.setLineDash(dash);context.stroke();}}MapLineLayer.DEFAULT_STROKE_WIDTH=2;// px
  MapLineLayer.DEFAULT_STROKE_STYLE='white';MapLineLayer.DEFAULT_STROKE_DASH=[];MapLineLayer.DEFAULT_OUTLINE_WIDTH=0;// px
  MapLineLayer.DEFAULT_OUTLINE_STYLE='black';MapLineLayer.DEFAULT_OUTLINE_DASH=[];/**
   * An enumeration of possible map rotation types.
   */var MapRotation;(function(MapRotation){/** Map up position does not follow a defined pattern. */MapRotation["Undefined"]="Undefined";/** Map up position points towards true north. */MapRotation["NorthUp"]="NorthUp";/** Map up position points towards the current airplane track. */MapRotation["TrackUp"]="TrackUp";/** Map up position points towards the current airplane heading. */MapRotation["HeadingUp"]="HeadingUp";/** Map up position points towards the current nav desired track. */MapRotation["DtkUp"]="DtkUp";})(MapRotation||(MapRotation={}));/**
   * Waypoint roles used by the map system waypoint display system.
   */var MapSystemWaypointRoles;(function(MapSystemWaypointRoles){/** The normal waypoint display role. */MapSystemWaypointRoles["Normal"]="Normal";/** The waypoint role for displaying waypoints along the flight plan. */MapSystemWaypointRoles["FlightPlan"]="FlightPlan";})(MapSystemWaypointRoles||(MapSystemWaypointRoles={}));/**
   * A map system layer that draws the flight plan.
   */class MapSystemFlightPlanLayer extends MapLayer{constructor(){var _a;super(...arguments);this.instanceId=MapSystemFlightPlanLayer.instanceId++;this.flightPathLayerRef=FSComponent.createRef();this.waypointLayerRef=FSComponent.createRef();this.defaultRoleId=(_a=this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan))!==null&&_a!==void 0?_a:0;this.planModule=this.props.model.getModule(MapSystemKeys.FlightPlan);this.waypointPrefix="".concat(MapSystemFlightPlanLayer.WAYPOINT_PREFIX,"_").concat(this.instanceId);this.legWaypoints=new Map();this.waypointsUpdating=false;this.waypointId=0;this.facLoader=new FacilityLoader(FacilityRepository.getRepository(this.props.bus));this.facWaypointCache=DefaultFacilityWaypointCache.getCache(this.props.bus);this.clipBounds=VecNSubject.create(new Float64Array(4));this.clippedPathStream=new ClippedPathStream(NullPathStream.INSTANCE,this.clipBounds);this.pathStreamStack=new GeoProjectionPathStreamStack(NullPathStream.INSTANCE,this.props.mapProjection.getGeoProjection(),Math.PI/12,0.25,8);this.updateScheduled=false;}/** @inheritdoc */onAttached(){this.flightPathLayerRef.instance.onAttached();this.waypointLayerRef.instance.onAttached();this.pathStreamStack.pushPostProjected(this.clippedPathStream);this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);this.initWaypointRenderer();this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(()=>this.updateScheduled=true);this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(()=>this.updateScheduled=true);this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(()=>this.updateScheduled=true);this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(()=>this.updateScheduled=true);this.props.waypointRenderer.onRolesAdded.on(()=>this.initWaypointRenderer());super.onAttached();}/**
       * Initializes the waypoint renderer for this layer.
       */initWaypointRenderer(){let hasDefaultRole=false;const flightPlanRoles=this.props.waypointRenderer.getRoleNamesByGroup("".concat(MapSystemWaypointRoles.FlightPlan,"_").concat(this.props.planIndex));for(let i=0;i<flightPlanRoles.length;i++){const roleId=this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);if(roleId!==undefined){this.props.waypointRenderer.setCanvasContext(roleId,this.waypointLayerRef.instance.display.context);this.props.waypointRenderer.setIconFactory(roleId,this.props.iconFactory);this.props.waypointRenderer.setLabelFactory(roleId,this.props.labelFactory);if(!hasDefaultRole){this.props.flightPathRenderer.defaultRoleId=roleId;hasDefaultRole=true;}}}}/** @inheritdoc */onUpdated(time,elapsed){this.flightPathLayerRef.instance.onUpdated(time,elapsed);this.waypointLayerRef.instance.onUpdated(time,elapsed);if(this.isVisible()){const display=this.flightPathLayerRef.instance.display;if(display.isInvalid){display.clear();display.syncWithMapProjection(this.props.mapProjection);this.updateScheduled=true;}if(this.updateScheduled){if(!this.waypointsUpdating){this.updateWaypoints();}const context=display.context;display.clear();const plan=this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();if(plan!==undefined){this.pathStreamStack.setProjection(display.geoProjection);this.props.flightPathRenderer.render(plan,undefined,undefined,context,this.pathStreamStack);}this.updateScheduled=false;}}}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);const size=this.flightPathLayerRef.instance.getSize();this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER,-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER,size+MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER,size+MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);}/** @inheritdoc */setVisible(val){super.setVisible(val);this.waypointLayerRef.instance.setVisible(val);this.flightPathLayerRef.instance.setVisible(val);}/**
       * Updates waypoints for the flight plan.
       * @throws An error if the waypoints are already updating.
       */async updateWaypoints(){if(this.waypointsUpdating){throw new Error('A flight plan waypoint update is already in progress.');}this.waypointsUpdating=true;const flightPlan=this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();const activeLegIndex=this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();if(flightPlan===undefined){for(const legWaypoint of this.legWaypoints.values()){const[waypoint,roleId]=legWaypoint;this.props.waypointRenderer.deregister(waypoint,roleId,MapSystemWaypointRoles.FlightPlan);}this.legWaypoints.clear();this.waypointsUpdating=false;return;}const activeLeg=flightPlan.tryGetLeg(activeLegIndex);const legsToDisplay=new Map();let legIndex=0;for(const leg of flightPlan.legs()){let roleId=this.defaultRoleId;const handler=this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);if(handler!==undefined){roleId=handler(flightPlan,leg,activeLeg,legIndex,activeLegIndex);}if(roleId!==0){legsToDisplay.set(leg,roleId);}legIndex++;}// Remove records of legs that are no longer in the set of legs to display.
  for(const leg of this.legWaypoints){const[legDefinition,legWaypoint]=leg;const[waypoint,roleId]=legWaypoint;if(!legsToDisplay.has(legDefinition)){this.props.waypointRenderer.deregister(waypoint,roleId,MapSystemWaypointRoles.FlightPlan);this.legWaypoints.delete(legDefinition);}}const waypointRefreshes=[];// Create or refresh waypoints to display
  for(const leg of legsToDisplay){waypointRefreshes.push(this.buildPlanWaypoint(leg[0],leg[1]));}await Promise.all(waypointRefreshes);this.waypointsUpdating=false;}/**
       * Builds or refreshes a flight plan waypoint.
       * @param leg The leg to build the waypoint for.
       * @param roleId The role ID to assign to the waypoint.
       */async buildPlanWaypoint(leg,roleId){switch(leg.leg.type){case LegType.CD:case LegType.VD:case LegType.CR:case LegType.VR:case LegType.FC:case LegType.FD:case LegType.FA:case LegType.CA:case LegType.VA:case LegType.FM:case LegType.VM:case LegType.CI:case LegType.VI:await this.buildTerminatorWaypoint(leg,roleId);break;case LegType.Discontinuity:case LegType.ThruDiscontinuity:break;default:await this.buildFixWaypoint(leg,roleId);break;}}/**
       * Builds a flight path terminator based waypoint.
       * @param leg The leg to build the waypoint for.
       * @param roleId The role ID to assign to the waypoint.
       */async buildTerminatorWaypoint(leg,roleId){var _a,_b,_c,_d,_e,_f;const currentLeg=this.legWaypoints.get(leg);if(currentLeg!==undefined){const[waypoint,currentRoleId]=currentLeg;const lastVector=(_a=leg.calculated)===null||_a===void 0?void 0:_a.flightPath[((_b=leg.calculated)===null||_b===void 0?void 0:_b.flightPath.length)-1];if(lastVector!==undefined){if(!waypoint.location.get().equals(lastVector.endLat,lastVector.endLon)){this.props.waypointRenderer.deregister(waypoint,currentRoleId,MapSystemWaypointRoles.FlightPlan);const ident=(_c=leg.name)!==null&&_c!==void 0?_c:'';const newWaypoint=new FlightPathWaypoint(lastVector.endLat,lastVector.endLon,leg,"".concat(this.waypointPrefix,"_").concat(this.waypointId++,"_").concat(ident),ident);this.legWaypoints.set(leg,[newWaypoint,roleId]);this.props.waypointRenderer.register(newWaypoint,roleId,MapSystemWaypointRoles.FlightPlan);}else if(currentRoleId!==roleId){this.props.waypointRenderer.deregister(waypoint,currentRoleId,MapSystemWaypointRoles.FlightPlan);this.props.waypointRenderer.register(waypoint,roleId,MapSystemWaypointRoles.FlightPlan);this.legWaypoints.set(leg,[waypoint,roleId]);}}else {this.props.waypointRenderer.deregister(waypoint,currentRoleId,MapSystemWaypointRoles.FlightPlan);}}else {const lastVector=(_d=leg.calculated)===null||_d===void 0?void 0:_d.flightPath[((_e=leg.calculated)===null||_e===void 0?void 0:_e.flightPath.length)-1];if(lastVector!==undefined){const ident=(_f=leg.name)!==null&&_f!==void 0?_f:'';const newWaypoint=new FlightPathWaypoint(lastVector.endLat,lastVector.endLon,leg,"".concat(this.waypointPrefix,"_").concat(this.waypointId++,"_").concat(ident),ident);this.legWaypoints.set(leg,[newWaypoint,roleId]);this.props.waypointRenderer.register(newWaypoint,roleId,MapSystemWaypointRoles.FlightPlan);}}}/**
       * Builds a standard facility fix waypoint for flight plan waypoint display.
       * @param leg The leg to build the waypoint for.
       * @param roleId The role ID to assign to the waypoint.
       */async buildFixWaypoint(leg,roleId){var _a;const legWaypoint=this.legWaypoints.get(leg);if(legWaypoint===undefined){const facIcao=leg.leg.fixIcao;let facility;try{facility=await this.facLoader.getFacility(ICAO.getFacilityType(facIcao),facIcao);}catch(err){/* continue */}if(facility!==undefined){const waypoint=this.facWaypointCache.get(facility);const ident=(_a=leg.name)!==null&&_a!==void 0?_a:'';const newWaypoint=new FlightPathWaypoint(waypoint.location,leg,"".concat(this.waypointPrefix,"_").concat(this.waypointId++,"_").concat(ident),ident);this.props.waypointRenderer.register(newWaypoint,roleId,MapSystemWaypointRoles.FlightPlan);this.legWaypoints.set(leg,[newWaypoint,roleId]);}}else {const[waypoint,currentRoleId]=legWaypoint;if(currentRoleId!==roleId){this.props.waypointRenderer.deregister(waypoint,currentRoleId,MapSystemWaypointRoles.FlightPlan);this.props.waypointRenderer.register(waypoint,roleId,MapSystemWaypointRoles.FlightPlan);this.legWaypoints.set(leg,[waypoint,roleId]);}}}/** @inheritdoc */render(){var _a,_b;return FSComponent.buildComponent(FSComponent.Fragment,null,FSComponent.buildComponent(MapCachedCanvasLayer,{ref:this.flightPathLayerRef,model:this.props.model,mapProjection:this.props.mapProjection,overdrawFactor:Math.SQRT2,class:(_a=this.props.class)!==null&&_a!==void 0?_a:''}),FSComponent.buildComponent(MapSyncedCanvasLayer,{ref:this.waypointLayerRef,model:this.props.model,mapProjection:this.props.mapProjection,class:(_b=this.props.class)!==null&&_b!==void 0?_b:''}));}}MapSystemFlightPlanLayer.WAYPOINT_PREFIX='MapSystemFplLayer';MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER=10;MapSystemFlightPlanLayer.instanceId=0;/**
   * ADS-B operating modes.
   */var AdsbOperatingMode;(function(AdsbOperatingMode){AdsbOperatingMode["Standby"]="Standby";AdsbOperatingMode["Surface"]="Surface";AdsbOperatingMode["Airborne"]="Airborne";})(AdsbOperatingMode||(AdsbOperatingMode={}));/**
   * TCAS operating modes.
   */var TcasOperatingMode;(function(TcasOperatingMode){TcasOperatingMode["Off"]="Off";TcasOperatingMode["Standby"]="Standby";TcasOperatingMode["TAOnly"]="TAOnly";TcasOperatingMode["TA_RA"]="TA/RA";TcasOperatingMode["Test"]="Test";TcasOperatingMode["Failed"]="Failed";})(TcasOperatingMode||(TcasOperatingMode={}));/**
   * TCAS alert level.
   */var TcasAlertLevel;(function(TcasAlertLevel){TcasAlertLevel[TcasAlertLevel["None"]=0]="None";TcasAlertLevel[TcasAlertLevel["ProximityAdvisory"]=1]="ProximityAdvisory";TcasAlertLevel[TcasAlertLevel["TrafficAdvisory"]=2]="TrafficAdvisory";TcasAlertLevel[TcasAlertLevel["ResolutionAdvisory"]=3]="ResolutionAdvisory";})(TcasAlertLevel||(TcasAlertLevel={}));/**
   * Bit flags describing TCAS resolution advisories.
   */var TcasResolutionAdvisoryFlags;(function(TcasResolutionAdvisoryFlags){/** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Corrective"]=1]="Corrective";/** An upward sense resolution advisory. Commands a vertical speed above a certain value. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["UpSense"]=2]="UpSense";/** A downward sense resolution advisory. Commands a vertical speed below a certain value. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DownSense"]=4]="DownSense";/** A resolution advisory which crosses an intruder's altitude. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Crossing"]=8]="Crossing";/** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Climb"]=16]="Climb";/** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Descend"]=32]="Descend";/** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Increase"]=64]="Increase";/** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Reversal"]=128]="Reversal";/** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceClimb"]=256]="ReduceClimb";/** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceDescent"]=512]="ReduceDescent";/** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotClimb"]=1024]="DoNotClimb";/** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotDescend"]=2048]="DoNotDescend";})(TcasResolutionAdvisoryFlags||(TcasResolutionAdvisoryFlags={}));/**
   * Types of TCAS resolution advisories.
   */var TcasResolutionAdvisoryType;(function(TcasResolutionAdvisoryType){/** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */TcasResolutionAdvisoryType["Climb"]="Climb";/** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */TcasResolutionAdvisoryType["CrossingClimb"]="CrossingClimb";/** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */TcasResolutionAdvisoryType["MaintainClimb"]="MaintainClimb";/** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */TcasResolutionAdvisoryType["CrossingMaintainClimb"]="CrossingMaintainClimb";/** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */TcasResolutionAdvisoryType["IncreaseClimb"]="IncreaseClimb";/** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */TcasResolutionAdvisoryType["ReversalClimb"]="ReversalClimb";/** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */TcasResolutionAdvisoryType["ReduceDescent"]="ReduceDescent";/** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */TcasResolutionAdvisoryType["DoNotDescend0"]="DoNotDescend0";/** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */TcasResolutionAdvisoryType["DoNotDescend500"]="DoNotDescend500";/** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */TcasResolutionAdvisoryType["DoNotDescend1000"]="DoNotDescend1000";/** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */TcasResolutionAdvisoryType["DoNotDescend1500"]="DoNotDescend1500";/** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */TcasResolutionAdvisoryType["DoNotDescend2000"]="DoNotDescend2000";/** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */TcasResolutionAdvisoryType["Descend"]="Descend";/** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */TcasResolutionAdvisoryType["CrossingDescend"]="CrossingDescend";/** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */TcasResolutionAdvisoryType["MaintainDescend"]="MaintainDescend";/** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */TcasResolutionAdvisoryType["CrossingMaintainDescend"]="CrossingMaintainDescend";/** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */TcasResolutionAdvisoryType["IncreaseDescend"]="IncreaseDescend";/** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */TcasResolutionAdvisoryType["ReversalDescend"]="ReversalDescend";/** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */TcasResolutionAdvisoryType["ReduceClimb"]="ReduceClimb";/** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */TcasResolutionAdvisoryType["DoNotClimb0"]="DoNotClimb0";/** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */TcasResolutionAdvisoryType["DoNotClimb500"]="DoNotClimb500";/** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */TcasResolutionAdvisoryType["DoNotClimb1000"]="DoNotClimb1000";/** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */TcasResolutionAdvisoryType["DoNotClimb1500"]="DoNotClimb1500";/** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */TcasResolutionAdvisoryType["DoNotClimb2000"]="DoNotClimb2000";/** Clear of conflict. */TcasResolutionAdvisoryType["Clear"]="Clear";})(TcasResolutionAdvisoryType||(TcasResolutionAdvisoryType={}));({initialResponseTime:UnitType.SECOND.createNumber(5),initialAcceleration:UnitType.G_ACCEL.createNumber(0.25),subsequentResponseTime:UnitType.SECOND.createNumber(2.5),subsequentAcceleration:UnitType.G_ACCEL.createNumber(0.35)});UnitType.KNOT.createNumber(30);UnitType.FPM.convertTo(1500,UnitType.MPS);UnitType.FPM.convertTo(2500,UnitType.MPS);({[TcasResolutionAdvisoryType.Clear]:{flags:0,minVerticalSpeed:-Infinity,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.Climb]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.Climb|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:1500,maxVerticalSpeed:2000},[TcasResolutionAdvisoryType.MaintainClimb]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.Climb,minVerticalSpeed:1500,maxVerticalSpeed:4400},[TcasResolutionAdvisoryType.CrossingClimb]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.Climb|TcasResolutionAdvisoryFlags.Crossing|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:1500,maxVerticalSpeed:2000},[TcasResolutionAdvisoryType.CrossingMaintainClimb]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.Climb|TcasResolutionAdvisoryFlags.Crossing,minVerticalSpeed:1500,maxVerticalSpeed:4400},[TcasResolutionAdvisoryType.IncreaseClimb]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.Climb|TcasResolutionAdvisoryFlags.Increase|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:2500,maxVerticalSpeed:3000},[TcasResolutionAdvisoryType.ReversalClimb]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.Climb|TcasResolutionAdvisoryFlags.Reversal|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:1500,maxVerticalSpeed:2000},[TcasResolutionAdvisoryType.ReduceDescent]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.ReduceDescent|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:0,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.DoNotDescend0]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.DoNotDescend,minVerticalSpeed:0,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.DoNotDescend500]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.DoNotDescend,minVerticalSpeed:-500,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.DoNotDescend1000]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.DoNotDescend,minVerticalSpeed:-1000,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.DoNotDescend1500]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.DoNotDescend,minVerticalSpeed:-1500,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.DoNotDescend2000]:{flags:TcasResolutionAdvisoryFlags.UpSense|TcasResolutionAdvisoryFlags.DoNotDescend,minVerticalSpeed:-2000,maxVerticalSpeed:Infinity},[TcasResolutionAdvisoryType.Descend]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.Descend|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:-2000,maxVerticalSpeed:-1500},[TcasResolutionAdvisoryType.MaintainDescend]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.Descend,minVerticalSpeed:-4400,maxVerticalSpeed:-1500},[TcasResolutionAdvisoryType.CrossingDescend]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.Descend|TcasResolutionAdvisoryFlags.Crossing|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:-2000,maxVerticalSpeed:-1500},[TcasResolutionAdvisoryType.CrossingMaintainDescend]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.Descend|TcasResolutionAdvisoryFlags.Crossing,minVerticalSpeed:-4400,maxVerticalSpeed:-1500},[TcasResolutionAdvisoryType.IncreaseDescend]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.Descend|TcasResolutionAdvisoryFlags.Increase|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:-3000,maxVerticalSpeed:-2500},[TcasResolutionAdvisoryType.ReversalDescend]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.Descend|TcasResolutionAdvisoryFlags.Reversal|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:-2000,maxVerticalSpeed:-1500},[TcasResolutionAdvisoryType.ReduceClimb]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.ReduceClimb|TcasResolutionAdvisoryFlags.Corrective,minVerticalSpeed:-Infinity,maxVerticalSpeed:0},[TcasResolutionAdvisoryType.DoNotClimb0]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.DoNotClimb,minVerticalSpeed:-Infinity,maxVerticalSpeed:0},[TcasResolutionAdvisoryType.DoNotClimb500]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.DoNotClimb,minVerticalSpeed:-Infinity,maxVerticalSpeed:500},[TcasResolutionAdvisoryType.DoNotClimb1000]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.DoNotClimb,minVerticalSpeed:-Infinity,maxVerticalSpeed:1000},[TcasResolutionAdvisoryType.DoNotClimb1500]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.DoNotClimb,minVerticalSpeed:-Infinity,maxVerticalSpeed:1500},[TcasResolutionAdvisoryType.DoNotClimb2000]:{flags:TcasResolutionAdvisoryFlags.DownSense|TcasResolutionAdvisoryFlags.DoNotClimb,minVerticalSpeed:-Infinity,maxVerticalSpeed:2000}});({protectedRadius:UnitType.NMILE.createNumber(6),protectedHeight:UnitType.FOOT.createNumber(1200)});[{tau:UnitType.SECOND.createNumber(20),protectedRadius:UnitType.NMILE.createNumber(0.3),protectedHeight:UnitType.FOOT.createNumber(850)},{tau:UnitType.SECOND.createNumber(25),protectedRadius:UnitType.NMILE.createNumber(0.33),protectedHeight:UnitType.FOOT.createNumber(850)},{tau:UnitType.SECOND.createNumber(30),protectedRadius:UnitType.NMILE.createNumber(0.48),protectedHeight:UnitType.FOOT.createNumber(850)},{tau:UnitType.SECOND.createNumber(40),protectedRadius:UnitType.NMILE.createNumber(0.75),protectedHeight:UnitType.FOOT.createNumber(850)},{tau:UnitType.SECOND.createNumber(45),protectedRadius:UnitType.NMILE.createNumber(1),protectedHeight:UnitType.FOOT.createNumber(850)},{tau:UnitType.SECOND.createNumber(48),protectedRadius:UnitType.NMILE.createNumber(1.3),protectedHeight:UnitType.FOOT.createNumber(850)},{tau:UnitType.SECOND.createNumber(48),protectedRadius:UnitType.NMILE.createNumber(1.3),protectedHeight:UnitType.FOOT.createNumber(1200)}];[{tau:UnitType.SECOND.createNumber(15),protectedRadius:UnitType.NMILE.createNumber(0.2),protectedHeight:UnitType.FOOT.createNumber(600),alim:UnitType.FOOT.createNumber(300),hmd:UnitType.NMILE.createNumber(0.4)},{tau:UnitType.SECOND.createNumber(15),protectedRadius:UnitType.NMILE.createNumber(0.2),protectedHeight:UnitType.FOOT.createNumber(600),alim:UnitType.FOOT.createNumber(300),hmd:UnitType.NMILE.createNumber(0.4)},{tau:UnitType.SECOND.createNumber(20),protectedRadius:UnitType.NMILE.createNumber(0.35),protectedHeight:UnitType.FOOT.createNumber(600),alim:UnitType.FOOT.createNumber(300),hmd:UnitType.NMILE.createNumber(0.57)},{tau:UnitType.SECOND.createNumber(25),protectedRadius:UnitType.NMILE.createNumber(0.55),protectedHeight:UnitType.FOOT.createNumber(600),alim:UnitType.FOOT.createNumber(350),hmd:UnitType.NMILE.createNumber(0.74)},{tau:UnitType.SECOND.createNumber(30),protectedRadius:UnitType.NMILE.createNumber(0.8),protectedHeight:UnitType.FOOT.createNumber(600),alim:UnitType.FOOT.createNumber(400),hmd:UnitType.NMILE.createNumber(0.82)},{tau:UnitType.SECOND.createNumber(35),protectedRadius:UnitType.NMILE.createNumber(1.1),protectedHeight:UnitType.FOOT.createNumber(700),alim:UnitType.FOOT.createNumber(600),hmd:UnitType.NMILE.createNumber(0.98)},{tau:UnitType.SECOND.createNumber(35),protectedRadius:UnitType.NMILE.createNumber(1.1),protectedHeight:UnitType.FOOT.createNumber(800),alim:UnitType.FOOT.createNumber(700),hmd:UnitType.NMILE.createNumber(0.98)}];/**
   * Traffic alert level modes.
   */var MapTrafficAlertLevelVisibility;(function(MapTrafficAlertLevelVisibility){MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["Other"]=1]="Other";MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ProximityAdvisory"]=2]="ProximityAdvisory";MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["TrafficAdvisory"]=4]="TrafficAdvisory";MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ResolutionAdvisory"]=8]="ResolutionAdvisory";MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["All"]=15]="All";})(MapTrafficAlertLevelVisibility||(MapTrafficAlertLevelVisibility={}));/**
   * A map layer which displays traffic intruders.
   */class MapSystemTrafficLayer extends MapLayer{constructor(){var _a;super(...arguments);this.iconLayerRef=FSComponent.createRef();this.trafficModule=this.props.model.getModule(MapSystemKeys.Traffic);this.intruderIcons={[TcasAlertLevel.None]:new Map(),[TcasAlertLevel.ProximityAdvisory]:new Map(),[TcasAlertLevel.TrafficAdvisory]:new Map(),[TcasAlertLevel.ResolutionAdvisory]:new Map()};this.needHandleOffscaleOob=this.props.offScaleIntruders!==undefined||this.props.oobIntruders!==undefined;this.oobOffset=(_a=this.props.oobOffset)!==null&&_a!==void 0?_a:Subject.create(VecNMath.create(4));this.oobBounds=VecNSubject.createFromVector(VecNMath.create(4));this.isInit=false;}/** @inheritdoc */onVisibilityChanged(isVisible){var _a,_b;if(!isVisible){if(this.isInit){// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  this.iconLayerRef.instance.display.clear();}(_a=this.props.offScaleIntruders)===null||_a===void 0?void 0:_a.clear();(_b=this.props.oobIntruders)===null||_b===void 0?void 0:_b.clear();}}/** @inheritdoc */onAttached(){this.iconLayerRef.instance.onAttached();this.oobOffset.sub(this.updateOobBounds.bind(this),true);this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));this.trafficModule.show.sub(this.updateVisibility.bind(this),true);this.initCanvasStyles();this.initIntruders();this.initTCASHandlers();this.isInit=true;}/**
       * Initializes canvas styles.
       */initCanvasStyles(){this.props.initCanvasStyles&&this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);}/**
       * Initializes all currently existing TCAS intruders.
       */initIntruders(){const intruders=this.trafficModule.tcas.getIntruders();const len=intruders.length;for(let i=0;i<len;i++){this.onIntruderAdded(intruders[i]);}}/**
       * Initializes handlers to respond to TCAS events.
       */initTCASHandlers(){const tcasSub=this.props.context.bus.getSubscriber();tcasSub.on('tcas_intruder_added').handle(this.onIntruderAdded.bind(this));tcasSub.on('tcas_intruder_removed').handle(this.onIntruderRemoved.bind(this));tcasSub.on('tcas_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));}/** @inheritdoc */onMapProjectionChanged(mapProjection,changeFlags){this.iconLayerRef.instance.onMapProjectionChanged(mapProjection,changeFlags);if(BitFlags.isAll(changeFlags,MapProjectionChangeType.ProjectedSize)){this.initCanvasStyles();this.updateOobBounds();}}/**
       * Updates the boundaries of the intruder out-of-bounds area.
       */updateOobBounds(){const projectedSize=this.props.mapProjection.getProjectedSize();const oobOffset=this.oobOffset.get();this.oobBounds.set(oobOffset[0],oobOffset[1],projectedSize[0]-oobOffset[2],projectedSize[1]-oobOffset[3]);}/** @inheritdoc */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUpdated(time,elapsed){if(!this.isVisible()){return;}this.redrawIntruders();}/**
       * Redraws all tracked intruders.
       */redrawIntruders(){const alertLevelVisFlags=this.trafficModule.alertLevelVisibility.get();const offScaleRange=this.trafficModule.offScaleRange.get();const oobBounds=this.oobBounds.get();const iconDisplay=this.iconLayerRef.instance.display;iconDisplay.clear();for(let i=0;i<MapSystemTrafficLayer.DRAW_GROUPS.length;i++){const group=MapSystemTrafficLayer.DRAW_GROUPS[i];if(BitFlags.isAll(alertLevelVisFlags,group.alertLevelVisFlag)){this.intruderIcons[group.alertLevel].forEach(icon=>{var _a,_b,_c,_d,_e,_f;icon.draw(this.props.mapProjection,iconDisplay.context,offScaleRange);if(this.needHandleOffscaleOob){if(icon.isOffScale){(_a=this.props.oobIntruders)===null||_a===void 0?void 0:_a.delete(icon.intruder);(_b=this.props.offScaleIntruders)===null||_b===void 0?void 0:_b.add(icon.intruder);}else if(!this.props.mapProjection.isInProjectedBounds(icon.projectedPos,oobBounds)){(_c=this.props.offScaleIntruders)===null||_c===void 0?void 0:_c.delete(icon.intruder);(_d=this.props.oobIntruders)===null||_d===void 0?void 0:_d.add(icon.intruder);}else {(_e=this.props.offScaleIntruders)===null||_e===void 0?void 0:_e.delete(icon.intruder);(_f=this.props.oobIntruders)===null||_f===void 0?void 0:_f.delete(icon.intruder);}}});}else if(this.needHandleOffscaleOob){this.intruderIcons[group.alertLevel].forEach(icon=>{var _a,_b;(_a=this.props.offScaleIntruders)===null||_a===void 0?void 0:_a.delete(icon.intruder);(_b=this.props.oobIntruders)===null||_b===void 0?void 0:_b.delete(icon.intruder);});}}}/**
       * Updates this layer's visibility.
       */updateVisibility(){const operatingMode=this.trafficModule.tcas.getOperatingMode();this.setVisible(this.trafficModule.show.get()&&(operatingMode===TcasOperatingMode.TAOnly||operatingMode===TcasOperatingMode.TA_RA||operatingMode===TcasOperatingMode.Test));}/**
       * A callback which is called when a TCAS intruder is added.
       * @param intruder The new intruder.
       */onIntruderAdded(intruder){const icon=this.props.iconFactory(intruder,this.props.context);this.intruderIcons[intruder.alertLevel.get()].set(intruder,icon);}/**
       * A callback which is called when a TCAS intruder is removed.
       * @param intruder The removed intruder.
       */onIntruderRemoved(intruder){var _a,_b;(_a=this.props.offScaleIntruders)===null||_a===void 0?void 0:_a.delete(intruder);(_b=this.props.oobIntruders)===null||_b===void 0?void 0:_b.delete(intruder);this.intruderIcons[intruder.alertLevel.get()].delete(intruder);}/**
       * A callback which is called when the alert level of a TCAS intruder is changed.
       * @param intruder The intruder.
       */onIntruderAlertLevelChanged(intruder){let oldAlertLevel;let view=this.intruderIcons[oldAlertLevel=TcasAlertLevel.None].get(intruder);view!==null&&view!==void 0?view:view=this.intruderIcons[oldAlertLevel=TcasAlertLevel.ProximityAdvisory].get(intruder);view!==null&&view!==void 0?view:view=this.intruderIcons[oldAlertLevel=TcasAlertLevel.TrafficAdvisory].get(intruder);view!==null&&view!==void 0?view:view=this.intruderIcons[oldAlertLevel=TcasAlertLevel.ResolutionAdvisory].get(intruder);if(view){this.intruderIcons[oldAlertLevel].delete(intruder);this.intruderIcons[intruder.alertLevel.get()].set(intruder,view);}}/** @inheritdoc */render(){var _a;return FSComponent.buildComponent(MapSyncedCanvasLayer,{ref:this.iconLayerRef,model:this.props.model,mapProjection:this.props.mapProjection,class:(_a=this.props.class)!==null&&_a!==void 0?_a:''});}}MapSystemTrafficLayer.DRAW_GROUPS=[{alertLevelVisFlag:MapTrafficAlertLevelVisibility.Other,alertLevel:TcasAlertLevel.None},{alertLevelVisFlag:MapTrafficAlertLevelVisibility.ProximityAdvisory,alertLevel:TcasAlertLevel.ProximityAdvisory},{alertLevelVisFlag:MapTrafficAlertLevelVisibility.TrafficAdvisory,alertLevel:TcasAlertLevel.TrafficAdvisory},{alertLevelVisFlag:MapTrafficAlertLevelVisibility.ResolutionAdvisory,alertLevel:TcasAlertLevel.ResolutionAdvisory}];[new GeoPoint(0,0)];/** The acceptable priority types for a given warning. */var WarningType;(function(WarningType){WarningType[WarningType["Warning"]=0]="Warning";WarningType[WarningType["Caution"]=1]="Caution";WarningType[WarningType["Test"]=2]="Test";WarningType[WarningType["SoundOnly"]=3]="SoundOnly";})(WarningType||(WarningType={}));/**
   * The style of cursor to use on a circular gauge.
   * This is treated as though it may have multiple options in the original
   * source.  For the sake of future expansion we'll make this an enum even
   * though it currently only has one option.  Maybe it can be used for future
   * expansion.
   */var XMLCircularGaugeCursor;(function(XMLCircularGaugeCursor){/** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */XMLCircularGaugeCursor[XMLCircularGaugeCursor["Triangle"]=1]="Triangle";})(XMLCircularGaugeCursor||(XMLCircularGaugeCursor={}));/**
   * The possible locations for value text.
   * This is treated as though it may have multiple options in the original
   * source.  For the sake of future expansion we'll make this an enum even
   * though it currently only has one option.  Maybe it can be used for future
   * expansion.
   */var XMLCircularGaugeValuePos;(function(XMLCircularGaugeValuePos){/** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */XMLCircularGaugeValuePos[XMLCircularGaugeValuePos["End"]=1]="End";})(XMLCircularGaugeValuePos||(XMLCircularGaugeValuePos={}));/**
   * This provides the valid values for the ValuePos tag on a horizontal gauge.
   */var XMLHorizontalGaugeValuePos;(function(XMLHorizontalGaugeValuePos){/** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */XMLHorizontalGaugeValuePos[XMLHorizontalGaugeValuePos["End"]=1]="End";XMLHorizontalGaugeValuePos[XMLHorizontalGaugeValuePos["Right"]=2]="Right";})(XMLHorizontalGaugeValuePos||(XMLHorizontalGaugeValuePos={}));/**
   * This provides the valid values for the ValuePos tag on a vertical gauge.
   */var XMLVerticalGaugeValuePos;(function(XMLVerticalGaugeValuePos){/** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */XMLVerticalGaugeValuePos[XMLVerticalGaugeValuePos["None"]=1]="None";})(XMLVerticalGaugeValuePos||(XMLVerticalGaugeValuePos={}));/**
   * The possible locations for value text.
   * This is treated as though it may have multiple options in the original
   * source.  For the sake of future expansion we'll make this an enum even
   * though it currently only has one option.  Maybe it can be used for future
   * expansion.
   */var XMLDoubleHorizontalGaugeValuePos;(function(XMLDoubleHorizontalGaugeValuePos){/** Starting the enum at 2 to match its value in the stock XMLEngineDisplay.js */XMLDoubleHorizontalGaugeValuePos[XMLDoubleHorizontalGaugeValuePos["Right"]=2]="Right";})(XMLDoubleHorizontalGaugeValuePos||(XMLDoubleHorizontalGaugeValuePos={}));/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
  /**
   * The type of gauges available, as defined in XMLEngineDisplay.js.
   */var XMLGaugeType;(function(XMLGaugeType){XMLGaugeType["Circular"]="Circular";XMLGaugeType["Horizontal"]="Horizontal";XMLGaugeType["DoubleHorizontal"]="DoubleHorizontal";XMLGaugeType["Vertical"]="Vertical";XMLGaugeType["DoubleVertical"]="DoubleVertical";XMLGaugeType["Text"]="Text";XMLGaugeType["ColumnGroup"]="ColumnGroup";XMLGaugeType["Column"]="Column";XMLGaugeType["Cylinder"]="Cylinder";XMLGaugeType["TwinCylinder"]="TwinCylinder";})(XMLGaugeType||(XMLGaugeType={}));/** An alert can be either new or acknowledged. */var AlertState;(function(AlertState){/** A newly arrived, unackowledged alert message. */AlertState[AlertState["New"]=0]="New";/** An alert message that has been acknowledged. */AlertState[AlertState["Acked"]=1]="Acked";})(AlertState||(AlertState={}));var APVerticalModes;(function(APVerticalModes){APVerticalModes[APVerticalModes["NONE"]=0]="NONE";APVerticalModes[APVerticalModes["PITCH"]=1]="PITCH";APVerticalModes[APVerticalModes["VS"]=2]="VS";APVerticalModes[APVerticalModes["FLC"]=3]="FLC";APVerticalModes[APVerticalModes["ALT"]=4]="ALT";APVerticalModes[APVerticalModes["PATH"]=5]="PATH";APVerticalModes[APVerticalModes["GP"]=6]="GP";APVerticalModes[APVerticalModes["GS"]=7]="GS";APVerticalModes[APVerticalModes["CAP"]=8]="CAP";APVerticalModes[APVerticalModes["TO"]=9]="TO";APVerticalModes[APVerticalModes["GA"]=10]="GA";APVerticalModes[APVerticalModes["FPA"]=11]="FPA";APVerticalModes[APVerticalModes["FLARE"]=12]="FLARE";})(APVerticalModes||(APVerticalModes={}));var APLateralModes;(function(APLateralModes){APLateralModes[APLateralModes["NONE"]=0]="NONE";APLateralModes[APLateralModes["ROLL"]=1]="ROLL";APLateralModes[APLateralModes["LEVEL"]=2]="LEVEL";APLateralModes[APLateralModes["GPSS"]=3]="GPSS";APLateralModes[APLateralModes["HEADING"]=4]="HEADING";APLateralModes[APLateralModes["VOR"]=5]="VOR";APLateralModes[APLateralModes["LOC"]=6]="LOC";APLateralModes[APLateralModes["BC"]=7]="BC";APLateralModes[APLateralModes["ROLLOUT"]=8]="ROLLOUT";APLateralModes[APLateralModes["NAV"]=9]="NAV";APLateralModes[APLateralModes["TO"]=10]="TO";APLateralModes[APLateralModes["GA"]=11]="GA";APLateralModes[APLateralModes["HEADING_HOLD"]=12]="HEADING_HOLD";APLateralModes[APLateralModes["TRACK"]=13]="TRACK";APLateralModes[APLateralModes["TRACK_HOLD"]=14]="TRACK_HOLD";})(APLateralModes||(APLateralModes={}));var APAltitudeModes;(function(APAltitudeModes){APAltitudeModes[APAltitudeModes["NONE"]=0]="NONE";APAltitudeModes[APAltitudeModes["ALTS"]=1]="ALTS";APAltitudeModes[APAltitudeModes["ALTV"]=2]="ALTV";})(APAltitudeModes||(APAltitudeModes={}));var APStates;(function(APStates){APStates[APStates["None"]=0]="None";APStates[APStates["APActive"]=1]="APActive";APStates[APStates["YawDamper"]=2]="YawDamper";APStates[APStates["Heading"]=4]="Heading";APStates[APStates["Nav"]=8]="Nav";APStates[APStates["NavArmed"]=16]="NavArmed";APStates[APStates["Approach"]=32]="Approach";APStates[APStates["ApproachArmed"]=64]="ApproachArmed";APStates[APStates["Backcourse"]=128]="Backcourse";APStates[APStates["BackcourseArmed"]=256]="BackcourseArmed";APStates[APStates["Alt"]=512]="Alt";APStates[APStates["AltS"]=1024]="AltS";APStates[APStates["AltV"]=2048]="AltV";APStates[APStates["VS"]=4096]="VS";APStates[APStates["FLC"]=8192]="FLC";APStates[APStates["GP"]=16384]="GP";APStates[APStates["GPArmed"]=32768]="GPArmed";APStates[APStates["GS"]=65536]="GS";APStates[APStates["GSArmed"]=131072]="GSArmed";APStates[APStates["Path"]=262144]="Path";APStates[APStates["PathArmed"]=524288]="PathArmed";APStates[APStates["PathInvalid"]=1048576]="PathInvalid";APStates[APStates["Pitch"]=2097152]="Pitch";APStates[APStates["Roll"]=4194304]="Roll";APStates[APStates["VNAV"]=8388608]="VNAV";APStates[APStates["ATSpeed"]=16777216]="ATSpeed";APStates[APStates["ATMach"]=33554432]="ATMach";APStates[APStates["ATArmed"]=67108864]="ATArmed";APStates[APStates["FD"]=134217728]="FD";})(APStates||(APStates={}));/**
   * The state of a given plane director.
   */var DirectorState;(function(DirectorState){/** The plane director is not currently armed or active. */DirectorState["Inactive"]="Inactive";/** The plane director is currently armed. */DirectorState["Armed"]="Armed";/** The plane director is currently active. */DirectorState["Active"]="Active";})(DirectorState||(DirectorState={}));/* eslint-disable @typescript-eslint/no-empty-function */ /**
   * A plane director that provides no behavior.
   */class EmptyDirector{constructor(){/** No-op. */this.onActivate=()=>{};/** No-op */this.onArm=()=>{};this.state=DirectorState.Inactive;}/** No-op. */activate(){}/** No-op. */deactivate(){}/** No-op. */update(){}/** No-op. */arm(){}}/** An instance of the empty plane director. */EmptyDirector.instance=new EmptyDirector();/**
   * The current vertical navigation state.
   */var VNavState;(function(VNavState){/** VNAV Disabled. */VNavState[VNavState["Disabled"]=0]="Disabled";/** VNAV Enabled and Inactive. */VNavState[VNavState["Enabled_Inactive"]=1]="Enabled_Inactive";/** VNAV Enabled and Active. */VNavState[VNavState["Enabled_Active"]=2]="Enabled_Active";})(VNavState||(VNavState={}));/**
   * The current VNAV path mode.
   */var VNavPathMode;(function(VNavPathMode){/** VNAV path is not active. */VNavPathMode[VNavPathMode["None"]=0]="None";/** VNAV path is armed for capture. */VNavPathMode[VNavPathMode["PathArmed"]=1]="PathArmed";/** VNAV path is actively navigating. */VNavPathMode[VNavPathMode["PathActive"]=2]="PathActive";/** The current VNAV path is not valid. */VNavPathMode[VNavPathMode["PathInvalid"]=3]="PathInvalid";})(VNavPathMode||(VNavPathMode={}));/**
   * The current Approach Guidance Mode.
   */var ApproachGuidanceMode;(function(ApproachGuidanceMode){/** VNAV is not currently following approach guidance. */ApproachGuidanceMode[ApproachGuidanceMode["None"]=0]="None";/** VNAV has armed ILS glideslope guidance for capture. */ApproachGuidanceMode[ApproachGuidanceMode["GSArmed"]=1]="GSArmed";/** VNAV is actively following ILS glideslope guidance. */ApproachGuidanceMode[ApproachGuidanceMode["GSActive"]=2]="GSActive";/** VNAV RNAV glidepath guidance is armed for capture. */ApproachGuidanceMode[ApproachGuidanceMode["GPArmed"]=3]="GPArmed";/** VNAV is actively follow RNAV glidepath guidance. */ApproachGuidanceMode[ApproachGuidanceMode["GPActive"]=4]="GPActive";})(ApproachGuidanceMode||(ApproachGuidanceMode={}));/**
   * The current VNAV altitude capture type.
   */var VNavAltCaptureType;(function(VNavAltCaptureType){/** Altitude capture is not armed. */VNavAltCaptureType[VNavAltCaptureType["None"]=0]="None";/** Altitude will capture the selected altitude. */VNavAltCaptureType[VNavAltCaptureType["Selected"]=1]="Selected";/** Altitude will capture the VANV target altitude. */VNavAltCaptureType[VNavAltCaptureType["VNAV"]=2]="VNAV";})(VNavAltCaptureType||(VNavAltCaptureType={}));/**
   * The current state of VNAV availability from the director.
   */var VNavAvailability;(function(VNavAvailability){VNavAvailability["Available"]="Available";VNavAvailability["InvalidLegs"]="InvalidLegs";})(VNavAvailability||(VNavAvailability={}));/// <reference types="@microsoft/msfs-types/coherent/apcontroller" />
  /**
   * LNAV transition modes.
   */var LNavTransitionMode;(function(LNavTransitionMode){/** LNAV is attempting to track a non-transition vector. */LNavTransitionMode[LNavTransitionMode["None"]=0]="None";/** LNAV is attempting to track an ingress vector. */LNavTransitionMode[LNavTransitionMode["Ingress"]=1]="Ingress";/** LNAV is attempting to track an egress vector. */LNavTransitionMode[LNavTransitionMode["Egress"]=2]="Egress";/**
       * LNAV is attempting to track a non-transition vector prior to where the ingress transition joins the base flight
       * path after deactivating suspend mode.
       */LNavTransitionMode[LNavTransitionMode["Unsuspend"]=3]="Unsuspend";})(LNavTransitionMode||(LNavTransitionMode={}));/**
   * Sim var names for LNAV data.
   */var LNavVars;(function(LNavVars){/** The current desired track, in degrees true. */LNavVars["DTK"]="L:WTAP_LNav_DTK";/**
       * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
       * direction of the track. Positive values indicate deviation to the right.
       */LNavVars["XTK"]="L:WTAP_LNav_XTK";/** Whether LNAV is tracking a path. */LNavVars["IsTracking"]="L:WTAP_LNav_Is_Tracking";/** The global leg index of the flight plan leg LNAV is currently tracking. */LNavVars["TrackedLegIndex"]="L:WTAP_LNav_Tracked_Leg_Index";/** The currently active LNAV transition mode. */ // eslint-disable-next-line @typescript-eslint/no-shadow
  LNavVars["TransitionMode"]="L:WTAP_LNav_Transition_Mode";/** The index of the vector LNAV is currently tracking. */LNavVars["TrackedVectorIndex"]="L:WTAP_LNav_Tracked_Vector_Index";/** The current course LNAV is attempting to steer, in degrees true. */LNavVars["CourseToSteer"]="L:WTAP_LNav_Course_To_Steer";/** Whether LNAV sequencing is suspended. */LNavVars["IsSuspended"]="L:WTAP_LNav_Is_Suspended";/**
       * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
       * distance indicates the plane is before the start of the leg.
       */LNavVars["LegDistanceAlong"]="L:WTAP_LNav_Leg_Distance_Along";/**
       * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
       * the end of the leg.
       */LNavVars["LegDistanceRemaining"]="L:WTAP_LNav_Leg_Distance_Remaining";/**
       * The along-track distance from the start of the currently tracked vector to the plane's present position. A
       * negative distance indicates the plane is before the start of the vector.
       */LNavVars["VectorDistanceAlong"]="L:WTAP_LNav_Vector_Distance_Along";/**
       * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
       * past the end of the vector.
       */LNavVars["VectorDistanceRemaining"]="L:WTAP_LNav_Vector_Distance_Remaining";/**
       * The along-track distance from the current vector end where LNAV will sequence to the next vector.
       * A positive value means the vector will be sequenced this distance prior to the vector end.
       */LNavVars["VectorAnticipationDistance"]="L:WTAP_LNav_Vector_Anticipation_Distance";/** The current along-track ground speed of the airplane. */LNavVars["AlongTrackSpeed"]="L:WTAP_LNav_Along_Track_Speed";})(LNavVars||(LNavVars={}));/**
   * A publisher for LNAV sim var events.
   */class LNavSimVarPublisher extends SimVarPublisher{/**
       * Constructor.
       * @param bus The event bus to which to publish.
       */constructor(bus){super(LNavSimVarPublisher.simvars,bus);}}LNavSimVarPublisher.simvars=new Map([['lnav_dtk',{name:LNavVars.DTK,type:SimVarValueType.Degree}],['lnav_xtk',{name:LNavVars.XTK,type:SimVarValueType.NM}],['lnav_is_tracking',{name:LNavVars.IsTracking,type:SimVarValueType.Bool}],['lnav_tracked_leg_index',{name:LNavVars.TrackedLegIndex,type:SimVarValueType.Number}],['lnav_transition_mode',{name:LNavVars.TransitionMode,type:SimVarValueType.Number}],['lnav_tracked_vector_index',{name:LNavVars.TrackedVectorIndex,type:SimVarValueType.Number}],['lnav_course_to_steer',{name:LNavVars.CourseToSteer,type:SimVarValueType.Degree}],['lnav_is_suspended',{name:LNavVars.IsSuspended,type:SimVarValueType.Bool}],['lnav_leg_distance_along',{name:LNavVars.LegDistanceAlong,type:SimVarValueType.NM}],['lnav_leg_distance_remaining',{name:LNavVars.LegDistanceRemaining,type:SimVarValueType.NM}],['lnav_vector_distance_along',{name:LNavVars.VectorDistanceAlong,type:SimVarValueType.NM}],['lnav_vector_distance_remaining',{name:LNavVars.VectorDistanceRemaining,type:SimVarValueType.NM}],['lnav_vector_anticipation_distance',{name:LNavVars.VectorAnticipationDistance,type:SimVarValueType.NM}],['lnav_along_track_speed',{name:LNavVars.AlongTrackSpeed,type:SimVarValueType.Knots}]]);/**
   * Sim var names for VNAV data.
   */var VNavVars;(function(VNavVars){/** The vertical deviation in feet. */VNavVars["VerticalDeviation"]="L:WTAP_VNav_Vertical_Deviation";/** The VNAV target altitude in feet. */VNavVars["TargetAltitude"]="L:WTAP_VNav_Target_Altitude";/** The VNAV path mode. */VNavVars["PathMode"]="L:WTAP_VNav_Path_Mode";/** The VNAV State. */VNavVars["VNAVState"]="L:WTAP_VNav_State";/** Whether a VNAV Path Exists for the current leg. */VNavVars["PathAvailable"]="L:WTAP_VNav_Path_Available";/** The VNAV current altitude capture type. */VNavVars["CaptureType"]="L:WTAP_VNav_Alt_Capture_Type";/** The distance to the next TOD in meters, or -1 if one does not exist. */VNavVars["TODDistance"]="L:WTAP_VNav_Distance_To_TOD";/** The distance to the next BOD in meters, or -1 if one does not exist. */VNavVars["BODDistance"]="L:WTAP_VNav_Distance_To_BOD";/** The index of the leg for the next TOD. */VNavVars["TODLegIndex"]="L:WTAP_VNav_TOD_Leg_Index";/** The distance from the end of the TOD leg that the TOD is, in meters. */VNavVars["TODDistanceInLeg"]="L:WTAP_VNav_TOD_Distance_In_Leg";/** The index of the leg for the next BOD. */VNavVars["BODLegIndex"]="L:WTAP_VNav_BOD_Leg_Index";/** The distance to the next TOC in meters, or -1 if one does not exist. */VNavVars["TOCDistance"]="L:WTAP_VNav_Distance_To_TOC";/** The distance to the next BOC in meters, or -1 if one does not exist. */VNavVars["BOCDistance"]="L:WTAP_VNav_Distance_To_BOC";/** The index of the leg for the next TOC. */VNavVars["TOCLegIndex"]="L:WTAP_VNav_TOC_Leg_Index";/** The distance from the end of the TOC leg that the TOC is, in meters. */VNavVars["TOCDistanceInLeg"]="L:WTAP_VNav_TOC_Distance_In_Leg";/** The index of the leg for the next BOC. */VNavVars["BOCLegIndex"]="L:WTAP_VNav_BOC_Leg_Index";/** The index of the leg for the next constraint. */VNavVars["CurrentConstraintLegIndex"]="L:WTAP_VNav_Constraint_Leg_Index";/** The current constraint altitude, in feet. */VNavVars["CurrentConstraintAltitude"]="L:WTAP_VNav_Constraint_Altitude";/** The next constraint altitude, in feet. */VNavVars["NextConstraintAltitude"]="L:WTAP_VNav_Next_Constraint_Altitude";/** The current required flight path angle, in degrees. */VNavVars["FPA"]="L:WTAP_VNav_FPA";/** The required VS to the current constraint, in FPM. */VNavVars["RequiredVS"]="L:WTAP_VNAV_Required_VS";/** The VNAV approach guidance mode. */VNavVars["GPApproachMode"]="L:WTAP_GP_Approach_Mode";/** The current LPV vertical deviation in feet. */VNavVars["GPVerticalDeviation"]="L:WTAP_GP_Vertical_Deviation";/** The current remaining LPV distance in meters. */VNavVars["GPDistance"]="L:WTAP_GP_Distance";/** The current LPV FPA, in degrees. */VNavVars["GPFpa"]="L:WTAP_GP_FPA";/** The required VS to the current constraint, in FPM. */VNavVars["GPRequiredVS"]="L:WTAP_GP_Required_VS";/** The approach glidepath service level. */VNavVars["GPServiceLevel"]="L:WTAP_GP_Service_Level";})(VNavVars||(VNavVars={}));/** A publisher for VNAV sim var events. */class VNavSimVarPublisher extends SimVarPublisher{/**
       * Create a VNavSimVarPublisher
       * @param bus The EventBus to publish to
       */constructor(bus){super(VNavSimVarPublisher.simvars,bus);}/**
       * Publish a control event.
       * @param event The event from ControlEvents.
       * @param value The value of the event.
       */publishEvent(event,value){this.publish(event,value,true);}}VNavSimVarPublisher.simvars=new Map([['vnav_vertical_deviation',{name:VNavVars.VerticalDeviation,type:SimVarValueType.Feet}],['vnav_target_altitude',{name:VNavVars.TargetAltitude,type:SimVarValueType.Feet}],['vnav_path_mode',{name:VNavVars.PathMode,type:SimVarValueType.Number}],['vnav_path_available',{name:VNavVars.PathAvailable,type:SimVarValueType.Bool}],['vnav_state',{name:VNavVars.VNAVState,type:SimVarValueType.Number}],['vnav_altitude_capture_type',{name:VNavVars.CaptureType,type:SimVarValueType.Number}],['vnav_tod_distance',{name:VNavVars.TODDistance,type:SimVarValueType.Meters}],['vnav_tod_leg_distance',{name:VNavVars.TODDistanceInLeg,type:SimVarValueType.Meters}],['vnav_bod_distance',{name:VNavVars.BODDistance,type:SimVarValueType.Meters}],['vnav_tod_global_leg_index',{name:VNavVars.TODLegIndex,type:SimVarValueType.Number}],['vnav_bod_global_leg_index',{name:VNavVars.BODLegIndex,type:SimVarValueType.Number}],['vnav_toc_distance',{name:VNavVars.TOCDistance,type:SimVarValueType.Meters}],['vnav_toc_leg_distance',{name:VNavVars.TOCDistanceInLeg,type:SimVarValueType.Meters}],['vnav_boc_distance',{name:VNavVars.BOCDistance,type:SimVarValueType.Meters}],['vnav_toc_global_leg_index',{name:VNavVars.TOCLegIndex,type:SimVarValueType.Number}],['vnav_boc_global_leg_index',{name:VNavVars.BOCLegIndex,type:SimVarValueType.Number}],['vnav_constraint_global_leg_index',{name:VNavVars.CurrentConstraintLegIndex,type:SimVarValueType.Number}],['vnav_constraint_altitude',{name:VNavVars.CurrentConstraintAltitude,type:SimVarValueType.Feet}],['vnav_next_constraint_altitude',{name:VNavVars.NextConstraintAltitude,type:SimVarValueType.Feet}],['vnav_fpa',{name:VNavVars.FPA,type:SimVarValueType.Degree}],['vnav_required_vs',{name:VNavVars.RequiredVS,type:SimVarValueType.FPM}],['gp_approach_mode',{name:VNavVars.GPApproachMode,type:SimVarValueType.Number}],['gp_vertical_deviation',{name:VNavVars.GPVerticalDeviation,type:SimVarValueType.Feet}],['gp_distance',{name:VNavVars.GPDistance,type:SimVarValueType.Feet}],['gp_fpa',{name:VNavVars.GPFpa,type:SimVarValueType.Degree}],['gp_required_vs',{name:VNavVars.GPRequiredVS,type:SimVarValueType.FPM}],['gp_service_level',{name:VNavVars.GPServiceLevel,type:SimVarValueType.Number}]]);/// <reference types="@microsoft/msfs-types/js/simvar" />
  UnitType.GA_RADIAN.convertTo(GeoCircle.ANGULAR_TOLERANCE,UnitType.METER);/**
   * Sim var names for LNAV-related data.
   */var LNavDataVars;(function(LNavDataVars){/** The current nominal desired track, in degrees true. */LNavDataVars["DTKTrue"]="L:WT_LNavData_DTK_True";/** The current nominal desired track, in degrees magnetic. */LNavDataVars["DTKMagnetic"]="L:WT_LNavData_DTK_Mag";/**
       * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
       * direction of the track. Positive values indicate deviation to the right.
       */LNavDataVars["XTK"]="L:WT_LNavData_XTK";/** The current CDI scale. */LNavDataVars["CDIScale"]="L:WT_LNavData_CDI_Scale";/** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */LNavDataVars["WaypointBearingTrue"]="L:WT_LNavData_Waypoint_Bearing_True";/** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */LNavDataVars["WaypointBearingMagnetic"]="L:WT_LNavData_Waypoint_Bearing_Mag";/** The nominal distance remaining to the next waypoint currently tracked by LNAV. */LNavDataVars["WaypointDistance"]="L:WT_LNavData_Waypoint_Distance";/** The nominal distance remaining to the destination. */LNavDataVars["DestinationDistance"]="L:WT_LNavData_Destination_Distance";})(LNavDataVars||(LNavDataVars={}));/**
   * A publisher for LNAV-related data sim var events.
   */class LNavDataSimVarPublisher extends SimVarPublisher{/**
       * Constructor.
       * @param bus The event bus to which to publish.
       */constructor(bus){super(LNavDataSimVarPublisher.simvars,bus);}}LNavDataSimVarPublisher.simvars=new Map([['lnavdata_dtk_true',{name:LNavDataVars.DTKTrue,type:SimVarValueType.Degree}],['lnavdata_dtk_mag',{name:LNavDataVars.DTKMagnetic,type:SimVarValueType.Degree}],['lnavdata_xtk',{name:LNavDataVars.XTK,type:SimVarValueType.NM}],['lnavdata_cdi_scale',{name:LNavDataVars.CDIScale,type:SimVarValueType.NM}],['lnavdata_waypoint_bearing_true',{name:LNavDataVars.WaypointBearingTrue,type:SimVarValueType.Degree}],['lnavdata_waypoint_bearing_mag',{name:LNavDataVars.WaypointBearingMagnetic,type:SimVarValueType.Degree}],['lnavdata_waypoint_distance',{name:LNavDataVars.WaypointDistance,type:SimVarValueType.NM}],['lnavdata_destination_distance',{name:LNavDataVars.DestinationDistance,type:SimVarValueType.NM}]]);/** AP Mode Types */var APModeType;(function(APModeType){APModeType[APModeType["LATERAL"]=0]="LATERAL";APModeType[APModeType["VERTICAL"]=1]="VERTICAL";APModeType[APModeType["APPROACH"]=2]="APPROACH";})(APModeType||(APModeType={}));/**
   * Autothrottle target modes.
   */var AutothrottleTargetMode;(function(AutothrottleTargetMode){/** No target. */AutothrottleTargetMode["None"]="None";/** Autothrottle targets a specific airspeed. */AutothrottleTargetMode["Speed"]="Speed";/** Autothrottle targets a specific engine power setting. */AutothrottleTargetMode["Power"]="Power";/** Autothrottle targets a specific throttle lever position. */AutothrottleTargetMode["ThrottlePos"]="ThrottlePos";})(AutothrottleTargetMode||(AutothrottleTargetMode={}));/**
   * Represents possible lifetimes for FmcPages
   */var FmcPageLifecyclePolicy;(function(FmcPageLifecyclePolicy){/**
       * Page is only created and initialized once, the first time it is navigated to, the reloaded and resumed.
       */FmcPageLifecyclePolicy[FmcPageLifecyclePolicy["Singleton"]=0]="Singleton";/**
       * Page is re-created and re-initialized every time it is navigated to.
       */FmcPageLifecyclePolicy[FmcPageLifecyclePolicy["Transient"]=1]="Transient";})(FmcPageLifecyclePolicy||(FmcPageLifecyclePolicy={}));/**
   * Configures the {@link FmcPageLifecyclePolicy} for this page
   */FmcPageLifecyclePolicy.Singleton;/**
   * The state of an avionics system.
   */var AvionicsSystemState;(function(AvionicsSystemState){AvionicsSystemState["Off"]="Off";AvionicsSystemState["Initializing"]="Initializing";AvionicsSystemState["On"]="On";AvionicsSystemState["Failed"]="Failed";})(AvionicsSystemState||(AvionicsSystemState={}));/**
   * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
   */class FsBaseInstrument extends BaseInstrument{/**
       * A callback called when the element is attached to the DOM.
       */connectedCallback(){super.connectedCallback();this.fsInstrument=this.constructInstrument();}/**
       * Update method called by BaseInstrument
       */Update(){super.Update();if(this.fsInstrument){this.fsInstrument.Update();}}/** @inheritdoc */onInteractionEvent(_args){if(this.fsInstrument){this.fsInstrument.onInteractionEvent(_args);}}/** @inheritdoc */onGameStateChanged(oldState,newState){super.onGameStateChanged(oldState,newState);if(this.fsInstrument){this.fsInstrument.onGameStateChanged(oldState,newState);}}/** @inheritdoc */onFlightStart(){super.onFlightStart();if(this.fsInstrument){this.fsInstrument.onFlightStart();}}/** @inheritdoc */onSoundEnd(soundEventId){super.onSoundEnd(soundEventId);if(this.fsInstrument){this.fsInstrument.onSoundEnd(soundEventId);}}/**
       * Whether or not the instrument is interactive (a touchscreen instrument).
       * @returns True
       */get isInteractive(){return false;}}

  // TODO: Consider encapsulating arguments in an object to avoid having to guess paramet.er order.

  class VerticalSpeedStrategy {
    constructor(observer, atmosphericConditions, verticalSpeed) {
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
      this.verticalSpeed = verticalSpeed;
    }
    predictToAltitude(initialAltitude, finalAltitude, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      return Predictions.verticalSpeedStep(initialAltitude, finalAltitude, this.verticalSpeed, speed, mach, zeroFuelWeight, fuelOnBoard, this.atmosphericConditions.isaDeviation, headwindComponent.value, tropoPause, config.gearExtended, config.flapConfig, config.gearExtended, perfFactor);
    }
    predictToDistance(initialAltitude, distance, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      return Predictions.verticalSpeedDistanceStep(initialAltitude, distance, this.verticalSpeed, speed, mach, zeroFuelWeight, fuelOnBoard, this.atmosphericConditions.isaDeviation, headwindComponent.value, tropoPause, config.speedbrakesExtended, config.flapConfig, config.gearExtended, perfFactor);
    }
    predictToSpeed(initialAltitude, finalSpeed, initialSpeed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause,
        managedClimbSpeedMach
      } = this.observer.get();
      const computedMach = Math.min(this.atmosphericConditions.computeMachFromCas(initialAltitude, initialSpeed), mach);
      const n1 = this.verticalSpeed > 0 ? getClimbThrustN1Limit$1(this.atmosphericConditions, initialAltitude, initialSpeed, managedClimbSpeedMach) : EngineModel.getIdleN1(initialAltitude, computedMach, tropoPause) + VnavConfig.IDLE_N1_MARGIN;
      return Predictions.verticalSpeedStepWithSpeedChange(initialAltitude, initialSpeed, finalSpeed, this.verticalSpeed, mach, n1, zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, config.speedbrakesExtended, config.flapConfig, config.gearExtended, perfFactor);
    }
  }
  class FlightPathAngleStrategy {
    constructor(observer, atmosphericConditions, flightPathAngle) {
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
      this.flightPathAngle = flightPathAngle;
    }
    predictToAltitude(initialAltitude, finalAltitude, initialSpeed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      const distance = UnitType.FOOT.convertTo(finalAltitude - initialAltitude, UnitType.NMILE) / Math.tan(this.flightPathAngle * MathUtils$1.DEGREES_TO_RADIANS);
      return Predictions.geometricStep(initialAltitude, finalAltitude, distance, initialSpeed, mach, zeroFuelWeight, fuelOnBoard, this.atmosphericConditions.isaDeviation, headwindComponent.value, tropoPause, config.gearExtended, config.flapConfig, config.speedbrakesExtended, perfFactor);
    }
    predictToDistance(initialAltitude, distance, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause
      } = this.observer.get();
      const finalAltitude = initialAltitude + UnitType.NMILE.convertTo(distance, UnitType.FOOT) * Math.tan(this.flightPathAngle * MathUtils$1.DEGREES_TO_RADIANS);
      return Predictions.geometricStep(initialAltitude, finalAltitude, distance, speed, mach, zeroFuelWeight, fuelOnBoard, this.atmosphericConditions.isaDeviation, headwindComponent.value, tropoPause, config.gearExtended, config.flapConfig, config.speedbrakesExtended, perfFactor);
    }

    /**
     * If the path is being built backwards and we are trying to calculate a deceleration segment, `finalSpeed` should be greater than `speed`.
     * In this case, this predicts a segment where the aircraft decelerates to `finalSpeed` from `speed`.
     */
    predictToSpeed(initialAltitude, finalSpeed, initialSpeed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause,
        managedClimbSpeedMach
      } = this.observer.get();
      const computedMach = Math.min(this.atmosphericConditions.computeMachFromCas(initialAltitude, initialSpeed), mach);
      const predictedN1 = this.flightPathAngle > 0 ? getClimbThrustN1Limit$1(this.atmosphericConditions, initialAltitude, initialSpeed, managedClimbSpeedMach) : EngineModel.getIdleN1(initialAltitude, computedMach, tropoPause) + VnavConfig.IDLE_N1_MARGIN;
      return Predictions.speedChangeStep(this.flightPathAngle, initialAltitude, initialSpeed, finalSpeed, mach, mach, predictedN1, zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, config.gearExtended, config.flapConfig, config.speedbrakesExtended, 0, perfFactor);
    }
  }
  class ClimbThrustClimbStrategy {
    constructor(observer, atmosphericConditions) {
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
    }
    predictToAltitude(initialAltitude, finalAltitude, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        tropoPause,
        perfFactor,
        managedClimbSpeedMach
      } = this.observer.get();
      return Predictions.altitudeStep(initialAltitude, finalAltitude - initialAltitude, speed, mach, getClimbThrustN1Limit$1(this.atmosphericConditions, (initialAltitude + finalAltitude) / 2, speed, managedClimbSpeedMach), zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, config.speedbrakesExtended, config.flapConfig, config.speedbrakesExtended, perfFactor);
    }
    predictToDistance(initialAltitude, distance, speed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        tropoPause,
        perfFactor,
        managedClimbSpeedMach
      } = this.observer.get();
      return Predictions.distanceStep(initialAltitude, distance, speed, mach, getClimbThrustN1Limit$1(this.atmosphericConditions, initialAltitude, speed, managedClimbSpeedMach), zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, config.speedbrakesExtended, config.flapConfig, config.gearExtended, perfFactor);
    }
    predictToSpeed(initialAltitude, finalSpeed, initialSpeed, mach, fuelOnBoard, headwindComponent) {
      let config = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_AIRCRAFT_CONFIG;
      const {
        zeroFuelWeight,
        perfFactor,
        tropoPause,
        managedClimbSpeedMach
      } = this.observer.get();
      return Predictions.altitudeStepWithSpeedChange(initialAltitude, initialSpeed, finalSpeed, mach, getClimbThrustN1Limit$1(this.atmosphericConditions, initialAltitude, initialSpeed, managedClimbSpeedMach), zeroFuelWeight, fuelOnBoard, headwindComponent.value, this.atmosphericConditions.isaDeviation, tropoPause, config.speedbrakesExtended, config.flapConfig, config.gearExtended, perfFactor);
    }
  }
  function getClimbThrustN1Limit$1(atmosphericConditions, altitude, speed, maxMach) {
    const climbSpeedMach = Math.min(maxMach, atmosphericConditions.computeMachFromCas(altitude, speed));
    const estimatedTat = atmosphericConditions.totalAirTemperatureFromMach(altitude, climbSpeedMach);
    return EngineModel.tableInterpolation(EngineModel.maxClimbThrustTableLeap, estimatedTat, altitude);
  }

  class TemporaryCheckpointSequence {
    constructor() {
      _defineProperty(this, "checkpoints", void 0);
      for (var _len = arguments.length, checkpoints = new Array(_len), _key = 0; _key < _len; _key++) {
        checkpoints[_key] = arguments[_key];
      }
      this.checkpoints = checkpoints;
    }
    at(index) {
      return this.checkpoints[index];
    }
    get length() {
      return this.checkpoints.length;
    }
    reset() {
      for (var _len2 = arguments.length, checkpoints = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        checkpoints[_key2] = arguments[_key2];
      }
      this.checkpoints = checkpoints;
    }
    undoLastStep() {
      this.checkpoints.splice(this.checkpoints.length - 1);
    }
    addCheckpointFromStep(step, reason) {
      this.checkpoints.push({
        reason,
        distanceFromStart: this.lastCheckpoint.distanceFromStart + step.distanceTraveled,
        altitude: step.finalAltitude,
        secondsFromPresent: this.lastCheckpoint.secondsFromPresent + step.timeElapsed,
        remainingFuelOnBoard: this.lastCheckpoint.remainingFuelOnBoard - step.fuelBurned,
        speed: step.speed,
        mach: this.lastCheckpoint.mach
      });
    }
    addDecelerationCheckpointFromStep(step, reason, targetSpeed) {
      this.checkpoints.push({
        reason,
        distanceFromStart: this.lastCheckpoint.distanceFromStart + step.distanceTraveled,
        altitude: step.finalAltitude,
        secondsFromPresent: this.lastCheckpoint.secondsFromPresent + step.timeElapsed,
        remainingFuelOnBoard: this.lastCheckpoint.remainingFuelOnBoard - step.fuelBurned,
        speed: step.speed,
        mach: this.lastCheckpoint.mach,
        targetSpeed
      });
    }
    get() {
      let includeStartingPoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.checkpoints.slice(includeStartingPoint ? 0 : 1);
    }
    copyLastCheckpoint(newProperties) {
      this.checkpoints.push(_objectSpread2(_objectSpread2({}, this.lastCheckpoint), newProperties));
    }
    get lastCheckpoint() {
      return this.checkpoints[this.checkpoints.length - 1];
    }
    push() {
      this.checkpoints.push(...arguments);
    }
    interpolateAltitudeBackwards(distanceFromStart) {
      if (distanceFromStart >= this.checkpoints[0].distanceFromStart) {
        return this.checkpoints[0].altitude;
      }
      for (let i = 1; i < this.checkpoints.length - 1; i++) {
        if (distanceFromStart >= this.checkpoints[i].distanceFromStart) {
          return Common.interpolate(distanceFromStart, this.checkpoints[i - 1].distanceFromStart, this.checkpoints[i].distanceFromStart, this.checkpoints[i - 1].altitude, this.checkpoints[i].altitude);
        }
      }
      return this.lastCheckpoint.altitude;
    }
  }

  class GeometricPathBuilder {
    constructor(observer, atmosphericConditions) {
      this.observer = observer;
      _defineProperty(this, "flightPathAngleStrategy", void 0);
      this.flightPathAngleStrategy = new FlightPathAngleStrategy(observer, atmosphericConditions, -3.0);
    }
    executeGeometricSegments(sequence, segments, speedConstraints, windProfile) {
      const accelerationTargets = this.buildAccelerationTargets(sequence.lastCheckpoint, segments, speedConstraints);
      const lastTarget = null;
      for (const segment of segments) {
        const currentSegmentSequence = new TemporaryCheckpointSequence(sequence.lastCheckpoint);
        if (!this.executeGeometricSegment(currentSegmentSequence, segment, accelerationTargets, windProfile, false, lastTarget)) {
          if (!this.executeGeometricSegment(currentSegmentSequence, segment, accelerationTargets, windProfile, true, lastTarget)) {
            // Marking the segment as too steep, so that we ignore speed constraints on the next try and just fly at the maximum possible gradient
            segment.isTooSteep = true;
            this.executeGeometricSegment(currentSegmentSequence, segment, accelerationTargets, windProfile, true, lastTarget);
            sequence.push(...currentSegmentSequence.get());
            sequence.copyLastCheckpoint({
              reason: VerticalCheckpointReason.GeometricPathTooSteep,
              altitude: segment.end.altitude
            });
            continue;
          }
        }
        sequence.push(...currentSegmentSequence.get());
      }
    }
    executeGeometricSegment(sequence, segment, accelerationTargets, windProfile, useSpeedbrakes, lastTarget) {
      const {
        managedDescentSpeedMach
      } = this.observer.get();
      this.flightPathAngleStrategy.flightPathAngle = MathUtils$1.RADIANS_TO_DEGREES * Math.atan(segment.gradient / 6076.12);
      for (let i = 0; i < accelerationTargets.length && !segment.isTooSteep; i++) {
        const accelerationTarget = accelerationTargets[i];
        const maxDistance = segment.end.distanceFromStart - sequence.lastCheckpoint.distanceFromStart;
        if (accelerationTarget.distanceFromStart > sequence.lastCheckpoint.distanceFromStart || maxDistance >= 0) {
          continue;
        }
        if (lastTarget == null) {
          lastTarget = accelerationTarget;
        }

        // Decelerate to speed target
        const decelerationStep = this.flightPathAngleStrategy.predictToSpeed(sequence.lastCheckpoint.altitude, accelerationTarget.speed, sequence.lastCheckpoint.speed, managedDescentSpeedMach, sequence.lastCheckpoint.remainingFuelOnBoard, windProfile.getHeadwindComponent(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude), {
          speedbrakesExtended: useSpeedbrakes,
          flapConfig: FlapConf.CLEAN,
          gearExtended: false
        });
        if (decelerationStep.error === VnavStepError.AVAILABLE_GRADIENT_INSUFFICIENT) {
          if (!useSpeedbrakes) {

            // Break out and try the whole segment with speedbrakes
            return false;
          }
          segment.gradient = Math.tan(decelerationStep.pathAngle * MathUtils$1.DEGREES_TO_RADIANS) * 6076.12;
          return false;
        }

        // These are negative distances
        // Check if the deceleration takes us past the segment bounds.
        if (decelerationStep.distanceTraveled < Math.min(maxDistance, 0)) {
          const scaling = maxDistance / decelerationStep.distanceTraveled;
          this.scaleStepBasedOnLastCheckpoint(sequence.lastCheckpoint, decelerationStep, scaling);
          sequence.addCheckpointFromStep(decelerationStep, VerticalCheckpointReason.SpeedConstraint);
        } else if (Math.max(accelerationTarget.distanceFromStart, segment.end.distanceFromStart) < sequence.lastCheckpoint.distanceFromStart + decelerationStep.distanceTraveled) {
          if (decelerationStep.distanceTraveled < 0) {
            const decelerationReason = lastTarget.isSpeedLimit ? VerticalCheckpointReason.StartDecelerationToLimit : VerticalCheckpointReason.StartDecelerationToConstraint;
            sequence.addDecelerationCheckpointFromStep(decelerationStep, decelerationReason, lastTarget.speed);
          }

          // Fly to constraint
          const stepToConstraint = this.flightPathAngleStrategy.predictToDistance(sequence.lastCheckpoint.altitude, Math.max(accelerationTarget.distanceFromStart, segment.end.distanceFromStart) - sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.speed, managedDescentSpeedMach, sequence.lastCheckpoint.remainingFuelOnBoard, windProfile.getHeadwindComponent(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude));
          const checkpointReason = accelerationTarget.isSpeedLimit ? VerticalCheckpointReason.CrossingDescentSpeedLimit : VerticalCheckpointReason.SpeedConstraint;
          sequence.addCheckpointFromStep(stepToConstraint, checkpointReason);
          lastTarget = accelerationTarget;
        }
      }
      if (segment.end.distanceFromStart - sequence.lastCheckpoint.distanceFromStart < 0) {
        // Fly to end of segment
        const stepToEndOfSegment = this.flightPathAngleStrategy.predictToDistance(sequence.lastCheckpoint.altitude, segment.end.distanceFromStart - sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.speed, managedDescentSpeedMach, sequence.lastCheckpoint.remainingFuelOnBoard, windProfile.getHeadwindComponent(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude));
        sequence.addCheckpointFromStep(stepToEndOfSegment, VerticalCheckpointReason.AtmosphericConditions);
      }
      return true;
    }
    scaleStepBasedOnLastCheckpoint(lastCheckpoint, step, scaling) {
      step.distanceTraveled *= scaling;
      step.fuelBurned *= scaling;
      step.timeElapsed *= scaling;
      step.finalAltitude = (1 - scaling) * lastCheckpoint.altitude + scaling * step.finalAltitude;
      step.speed = (1 - scaling) * lastCheckpoint.speed + scaling * step.speed;
    }
    buildAccelerationTargets(startingPoint, segments, speedConstraints) {
      const {
        managedDescentSpeed,
        descentSpeedLimit
      } = this.observer.get();
      const distanceAtSpeedLimitCrossing = this.findDistanceAtAltitude(descentSpeedLimit.underAltitude, startingPoint, segments);
      let shouldAddSpeedLimit = distanceAtSpeedLimitCrossing !== null;
      const speedLimitTarget = {
        distanceFromStart: distanceAtSpeedLimitCrossing,
        speed: descentSpeedLimit.speed,
        isSpeedLimit: true
      };
      const targets = [];
      for (let i = speedConstraints.length - 1; i >= 0; i--) {
        const sc = speedConstraints[i];
        if (shouldAddSpeedLimit && sc.distanceFromStart < distanceAtSpeedLimitCrossing) {
          targets.push(speedLimitTarget);
          shouldAddSpeedLimit = false;
        }
        const target = {
          distanceFromStart: sc.distanceFromStart,
          speed: sc.maxSpeed,
          isSpeedLimit: false
        };
        targets.push(target);
      }
      const econSpeedTarget = {
        distanceFromStart: -Infinity,
        speed: managedDescentSpeed,
        isSpeedLimit: false
      };

      // If we figured that we should add the speed limit as a target, but haven't yet, add it now.
      if (shouldAddSpeedLimit) {
        targets.push(speedLimitTarget);
      }
      targets.push(econSpeedTarget);

      // Propagate speed constraints forwards
      targets.reduceRight((maxSpeed, target) => {
        maxSpeed = Math.min(maxSpeed, target.speed);
        target.speed = maxSpeed;
        return maxSpeed;
      }, Infinity);
      return targets;
    }
    findDistanceAtAltitude(altitude, startingPoint, segments) {
      if (startingPoint.altitude > altitude) {
        return null;
      }
      for (const segment of segments) {
        if (altitude <= segment.end.altitude) {
          return segment.end.distanceFromStart + (altitude - segment.end.altitude) / segment.gradient;
        }
      }

      // If we don't cross the speed limit on the geometric
      return -Infinity;
    }
  }

  class DescentPathBuilder {
    constructor(computationParametersObserver, atmosphericConditions) {
      this.computationParametersObserver = computationParametersObserver;
      this.atmosphericConditions = atmosphericConditions;
      _defineProperty(this, "geometricPathBuilder", void 0);
      _defineProperty(this, "idleDescentStrategy", void 0);
      this.geometricPathBuilder = new GeometricPathBuilder(computationParametersObserver, atmosphericConditions);
      this.idleDescentStrategy = new IdleDescentStrategy(computationParametersObserver, atmosphericConditions);
    }
    computeManagedDescentPath(sequence, profile, speedProfile, windProfile, cruiseAltitude) {
      const TOL = 10;
      const decelPoint = _objectSpread2({}, sequence.lastCheckpoint);
      const geometricSequence = new TemporaryCheckpointSequence(decelPoint);
      const idleSequence = new TemporaryCheckpointSequence(decelPoint);
      this.buildIdlePath(idleSequence, profile, speedProfile, windProfile, cruiseAltitude);
      for (let i = profile.descentAltitudeConstraints.length - 1; i >= 0; i -= 1) {
        const constraintPoint = profile.descentAltitudeConstraints[i];
        if (constraintPoint.distanceFromStart >= decelPoint.distanceFromStart) {
          // If we've found a constraint that's beyond the decel point, we can ignore it.
          continue;
        } else if (!this.isConstraintBelowCruisingAltitude(constraintPoint.constraint, cruiseAltitude)) {
          // Constraints above the cruise altitude are ignored
          break;
        }
        const altAtConstraint = idleSequence.interpolateAltitudeBackwards(constraintPoint.distanceFromStart);
        const [isAltitudeConstraintMet, altitudeToContinueFrom] = evaluateAltitudeConstraint(constraintPoint.constraint, altAtConstraint, TOL);
        if (!isAltitudeConstraintMet) {
          const geometricPathPoint = {
            distanceFromStart: constraintPoint.distanceFromStart,
            altitude: altitudeToContinueFrom
          };

          // Plan geometric path between decel point and geometric path point (point between geometric and idle path)
          const geometricSegments = [];
          GeometricPathPlanner.planDescentSegments(profile.descentAltitudeConstraints, decelPoint, geometricPathPoint, geometricSegments, TOL);

          // Execute
          geometricSequence.reset(geometricSequence.at(0));
          this.geometricPathBuilder.executeGeometricSegments(geometricSequence, geometricSegments, profile.descentSpeedConstraints.slice(), windProfile);
          idleSequence.reset(geometricSequence.lastCheckpoint);
          this.buildIdlePath(idleSequence, profile, speedProfile, windProfile, cruiseAltitude);
        }
      }
      if (geometricSequence.length > 1) {
        geometricSequence.lastCheckpoint.reason = VerticalCheckpointReason.GeometricPathStart;
      } else {
        geometricSequence.copyLastCheckpoint({
          reason: VerticalCheckpointReason.GeometricPathStart
        });
      }
      sequence.push(...geometricSequence.get());
      sequence.push(...idleSequence.get());
    }
    buildIdlePath(sequence, profile, speedProfile, windProfile, topOfDescentAltitude) {
      var _this$tryGetAnticipat;
      // Assume the last checkpoint is the start of the geometric path
      sequence.copyLastCheckpoint({
        reason: VerticalCheckpointReason.IdlePathEnd
      });
      const {
        managedDescentSpeedMach,
        descentSpeedLimit
      } = this.computationParametersObserver.get();
      const speedConstraintsAhead = this.speedConstraintGenerator(profile.descentSpeedConstraints, sequence);

      // We try to figure out what speed we might be decelerating for
      let previousCasTarget = (_this$tryGetAnticipat = this.tryGetAnticipatedTarget(sequence, profile.descentSpeedConstraints, speedProfile.shouldTakeDescentSpeedLimitIntoAccount() ? descentSpeedLimit : null)) !== null && _this$tryGetAnticipat !== void 0 ? _this$tryGetAnticipat : speedProfile.getTarget(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude, ManagedSpeedType.Descent);
      let wasPreviouslyUnderSpeedLimitAltitude = speedProfile.shouldTakeDescentSpeedLimitIntoAccount() && sequence.lastCheckpoint.altitude < descentSpeedLimit.underAltitude;
      for (let i = 0; i < 100 && topOfDescentAltitude - sequence.lastCheckpoint.altitude > 1; i++) {
        const {
          distanceFromStart,
          altitude,
          speed,
          remainingFuelOnBoard
        } = sequence.lastCheckpoint;
        const headwind = windProfile.getHeadwindComponent(distanceFromStart, altitude);
        const isUnderSpeedLimitAltitude = speedProfile.shouldTakeDescentSpeedLimitIntoAccount() && altitude < descentSpeedLimit.underAltitude;
        const casTarget = speedProfile.getTarget(distanceFromStart - 1e-4, altitude + 1e-4, ManagedSpeedType.Descent);
        const currentSpeedTarget = Math.min(casTarget, this.atmosphericConditions.computeCasFromMach(managedDescentSpeedMach, altitude));
        const canAccelerate = currentSpeedTarget > speed;
        if (canAccelerate) {
          // Build acceleration path
          const speedStep = this.idleDescentStrategy.predictToSpeed(altitude, casTarget, speed, managedDescentSpeedMach, remainingFuelOnBoard, headwind);
          const scaling = Math.min(1, (topOfDescentAltitude - altitude) / (speedStep.finalAltitude - altitude));
          this.scaleStepBasedOnLastCheckpoint(sequence.lastCheckpoint, speedStep, scaling);
          const didCrossoverSpeedLimitAltitude = wasPreviouslyUnderSpeedLimitAltitude && !isUnderSpeedLimitAltitude;
          const checkpointReason = didCrossoverSpeedLimitAltitude ? VerticalCheckpointReason.StartDecelerationToLimit : VerticalCheckpointReason.StartDecelerationToConstraint;
          sequence.addDecelerationCheckpointFromStep(speedStep, checkpointReason, previousCasTarget);
        } else {
          // Try alt path
          let finalAltitude = Math.min(altitude + 1500, topOfDescentAltitude);
          let reason = VerticalCheckpointReason.IdlePathAtmosphericConditions;
          if (isUnderSpeedLimitAltitude && finalAltitude >= descentSpeedLimit.underAltitude) {
            finalAltitude = descentSpeedLimit.underAltitude;
            reason = VerticalCheckpointReason.CrossingDescentSpeedLimit;
          }
          const altitudeStep = this.idleDescentStrategy.predictToAltitude(altitude, finalAltitude, speed, managedDescentSpeedMach, remainingFuelOnBoard, headwind);
          // Check if constraint violated
          const nextSpeedConstraint = speedConstraintsAhead.next();
          if (!nextSpeedConstraint.done && distanceFromStart + altitudeStep.distanceTraveled < nextSpeedConstraint.value.distanceFromStart) {
            // Constraint violated
            const distanceToConstraint = nextSpeedConstraint.value.distanceFromStart - distanceFromStart;
            const distanceStep = this.idleDescentStrategy.predictToDistance(altitude, distanceToConstraint, speed, managedDescentSpeedMach, remainingFuelOnBoard, headwind);
            sequence.addCheckpointFromStep(distanceStep, VerticalCheckpointReason.SpeedConstraint);
          } else {
            sequence.addCheckpointFromStep(altitudeStep, reason);
          }
        }
        previousCasTarget = casTarget;
        wasPreviouslyUnderSpeedLimitAltitude = isUnderSpeedLimitAltitude;
      }
      if (sequence.lastCheckpoint.reason === VerticalCheckpointReason.IdlePathAtmosphericConditions) {
        sequence.lastCheckpoint.reason = VerticalCheckpointReason.TopOfDescent;
      } else {
        sequence.copyLastCheckpoint({
          reason: VerticalCheckpointReason.TopOfDescent
        });
      }
    }

    // TODO: I really don't know if this function does what it's supposed to, so I hope I don't have to return to it.
    // The problem it's trying to solve is this: After having built the geometric path to the first violating altitude constraint, we might not be at econ speed yet.
    // So then we need to accelerate to it on the idle path. However, we want to figure out what the reason for this acceleration is, i.e whether it is due
    // to the speed limit or a constraint. We need to know this to place the correct checkpoint reason.
    // What the function does is to try and figure this out based on different criteria.
    tryGetAnticipatedTarget(sequence, speedConstraints, speedLimit) {
      const {
        distanceFromStart: pposDistanceFromStart,
        speed: currentSpeed,
        altitude: currentAltitude
      } = sequence.lastCheckpoint;

      // Find next constraint
      const nextSpeedConstraint = speedConstraints.find(c => c.distanceFromStart >= pposDistanceFromStart && c.maxSpeed <= currentSpeed);
      const isSpeedLimitValidCandidate = speedLimit && currentAltitude > speedLimit.underAltitude && currentSpeed > speedLimit.speed;
      if (nextSpeedConstraint) {
        // Try to figure out which speed is more important
        if (isSpeedLimitValidCandidate) {
          const altAtConstraint = sequence.interpolateAltitudeBackwards(nextSpeedConstraint.distanceFromStart);
          if (speedLimit.underAltitude > altAtConstraint) {
            return speedLimit.speed;
          }
        }
        return nextSpeedConstraint.maxSpeed;
      }

      // If we did not find a valid speed constraint candidate, see if the speed limit might be a candidate. If so, return it.
      if (isSpeedLimitValidCandidate) {
        return speedLimit.speed;
      }
      return null;
    }
    scaleStepBasedOnLastCheckpoint(lastCheckpoint, step, scaling) {
      step.distanceTraveled *= scaling;
      step.fuelBurned *= scaling;
      step.timeElapsed *= scaling;
      step.finalAltitude = (1 - scaling) * lastCheckpoint.altitude + scaling * step.finalAltitude;
      step.speed = (1 - scaling) * lastCheckpoint.speed + scaling * step.speed;
    }
    isConstraintBelowCruisingAltitude(constraint, finalCruiseAltitude) {
      if (constraint.type === AltitudeConstraintType.at) {
        return constraint.altitude1 <= finalCruiseAltitude;
      }
      if (constraint.type === AltitudeConstraintType.atOrAbove) {
        return constraint.altitude1 <= finalCruiseAltitude;
      }
      if (constraint.type === AltitudeConstraintType.atOrBelow) {
        return true;
      }
      if (constraint.type === AltitudeConstraintType.range) {
        return constraint.altitude2 <= finalCruiseAltitude;
      }
      return true;
    }
    *speedConstraintGenerator(constraints, sequence) {
      for (let i = constraints.length - 1; i >= 0;) {
        // Small tolerance here, so we don't get stuck on a constraint
        if (constraints[i].distanceFromStart - sequence.lastCheckpoint.distanceFromStart > -1e-4) {
          i--;
          continue;
        }
        yield constraints[i];
      }
    }
  }
  class GeometricPathPlanner {
    static planDescentSegments(constraints, start, end) {
      let segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      let tolerance = arguments.length > 4 ? arguments[4] : undefined;
      // A "gradient" is just a quantity of units Feet / NauticalMiles
      const gradient = calculateGradient(start, end);
      for (let i = 0; i < constraints.length; i++) {
        const constraintPoint = constraints[i];
        if (constraintPoint.distanceFromStart >= start.distanceFromStart || constraintPoint.distanceFromStart <= end.distanceFromStart) {
          continue;
        }
        const altAtConstraint = start.altitude + gradient * (constraintPoint.distanceFromStart - start.distanceFromStart);
        const [isAltitudeConstraintMet, altitudeToContinueFrom] = evaluateAltitudeConstraint(constraintPoint.constraint, altAtConstraint, tolerance);
        if (!isAltitudeConstraintMet) {
          const center = {
            distanceFromStart: constraintPoint.distanceFromStart,
            altitude: altitudeToContinueFrom
          };
          this.planDescentSegments(constraints, start, center, segments, tolerance);
          this.planDescentSegments(constraints, center, end, segments, tolerance);
          return;
        }
      }
      segments.push({
        end,
        gradient
      });
    }
  }
  function evaluateAltitudeConstraint(constraint, altitude, tol) {
    // Even though in the MCDU constraints count as met if within 250 ft, we use 10 ft here for the initial path construction.
    switch (constraint.type) {
      case AltitudeConstraintType.at:
        return [isAltitudeConstraintMet(constraint, altitude, tol), MathUtils$1.clamp(altitude, constraint.altitude1, constraint.altitude1)];
      case AltitudeConstraintType.atOrAbove:
        return [isAtOrAboveAltitudeConstraintMet(constraint, altitude, tol), Math.max(altitude, constraint.altitude1)];
      case AltitudeConstraintType.atOrBelow:
        return [isAtOrBelowAltitudeConstraintMet(constraint, altitude, tol), Math.min(altitude, constraint.altitude1)];
      case AltitudeConstraintType.range:
        return [isRangeAltitudeConstraintMet(constraint, altitude, tol), MathUtils$1.clamp(altitude, constraint.altitude2, constraint.altitude1)];
      default:
        console.error('[FMS/VNAV] Invalid altitude constraint type');
        return [true, altitude];
    }
  }
  const isAtAltitudeConstraintMet = function (constraint, altitude) {
    let tol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;
    return Math.abs(altitude - constraint.altitude1) < tol;
  };
  const isAtOrAboveAltitudeConstraintMet = function (constraint, altitude) {
    let tol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;
    return altitude - constraint.altitude1 > -tol;
  };
  const isAtOrBelowAltitudeConstraintMet = function (constraint, altitude) {
    let tol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;
    return altitude - constraint.altitude1 < tol;
  };
  const isRangeAltitudeConstraintMet = function (constraint, altitude) {
    let tol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;
    return altitude - constraint.altitude2 > -tol && altitude - constraint.altitude1 < tol;
  };
  const isAltitudeConstraintMet = function (constraint, altitude) {
    let tol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 250;
    switch (constraint.type) {
      case AltitudeConstraintType.at:
        return isAtAltitudeConstraintMet(constraint, altitude, tol);
      case AltitudeConstraintType.atOrAbove:
        return isAtOrAboveAltitudeConstraintMet(constraint, altitude, tol);
      case AltitudeConstraintType.atOrBelow:
        return isAtOrBelowAltitudeConstraintMet(constraint, altitude, tol);
      case AltitudeConstraintType.range:
        return isRangeAltitudeConstraintMet(constraint, altitude, tol);
      default:
        return true;
    }
  };
  function calculateGradient(start, end) {
    return Math.abs(start.distanceFromStart - end.distanceFromStart) < 1e-9 ? 0 : (start.altitude - end.altitude) / (start.distanceFromStart - end.distanceFromStart);
  }

  // TODO: Merge this with VerticalCheckpoint

  let VerticalCheckpointReason = /*#__PURE__*/function (VerticalCheckpointReason) {
    VerticalCheckpointReason["Liftoff"] = "Liftoff";
    VerticalCheckpointReason["ThrustReductionAltitude"] = "ThrustReductionAltitude";
    VerticalCheckpointReason["AccelerationAltitude"] = "AccelerationAltitude";
    VerticalCheckpointReason["TopOfClimb"] = "TopOfClimb";
    VerticalCheckpointReason["AtmosphericConditions"] = "AtmosphericConditions";
    VerticalCheckpointReason["PresentPosition"] = "PresentPosition";
    VerticalCheckpointReason["LevelOffForClimbConstraint"] = "LevelOffForClimbConstraint";
    VerticalCheckpointReason["AltitudeConstraint"] = "AltitudeConstraint";
    VerticalCheckpointReason["ContinueClimb"] = "ContinueClimb";
    VerticalCheckpointReason["CrossingClimbSpeedLimit"] = "CrossingClimbSpeedLimit";
    VerticalCheckpointReason["SpeedConstraint"] = "SpeedConstraint";
    VerticalCheckpointReason["CrossingFcuAltitudeClimb"] = "FcuAltitudeClimb";
    VerticalCheckpointReason["StepClimb"] = "StepClimb";
    VerticalCheckpointReason["TopOfStepClimb"] = "TopOfStepClimb";
    VerticalCheckpointReason["StepDescent"] = "StepDescent";
    VerticalCheckpointReason["BottomOfStepDescent"] = "BottomOfStepDescent";
    VerticalCheckpointReason["CrossingFcuAltitudeDescent"] = "FcuAltitudeDescent";
    VerticalCheckpointReason["InterceptDescentProfileManaged"] = "InterceptDescentProfileManaged";
    VerticalCheckpointReason["InterceptDescentProfileSelected"] = "InterceptDescentProfileSelected";
    VerticalCheckpointReason["LevelOffForDescentConstraint"] = "LevelOffForDescentConstraint";
    VerticalCheckpointReason["ContinueDescent"] = "ContinueDescent";
    VerticalCheckpointReason["ContinueDescentArmed"] = "ContinueDescentArmed";
    VerticalCheckpointReason["TopOfDescent"] = "TopOfDescent";
    VerticalCheckpointReason["CrossingDescentSpeedLimit"] = "CrossingDescentSpeedLimit";
    VerticalCheckpointReason["IdlePathAtmosphericConditions"] = "IdlePathAtmosphericConditions";
    VerticalCheckpointReason["IdlePathEnd"] = "IdlePathEnd";
    VerticalCheckpointReason["GeometricPathStart"] = "GeometricPathStart";
    VerticalCheckpointReason["GeometricPathConstraint"] = "GeometricPathConstraint";
    VerticalCheckpointReason["GeometricPathTooSteep"] = "GeometricPathTooSteep";
    VerticalCheckpointReason["GeometricPathEnd"] = "GeometricPathEnd";
    VerticalCheckpointReason["StartDecelerationToConstraint"] = "StartDecelerationToConstraint";
    VerticalCheckpointReason["StartDecelerationToLimit"] = "StartDecelerationToLimit";
    VerticalCheckpointReason["Decel"] = "Decel";
    VerticalCheckpointReason["Flaps1"] = "Flaps1";
    VerticalCheckpointReason["Flaps2"] = "Flaps2";
    VerticalCheckpointReason["Flaps3"] = "Flaps3";
    VerticalCheckpointReason["FlapsFull"] = "FlapsFull";
    VerticalCheckpointReason["Landing"] = "Landing";
    return VerticalCheckpointReason;
  }({});
  // I'm sure there's a better way to handle the distinction between `VerticalCheckpoint` and `VerticalCheckpointForDeceleration`
  function isSpeedChangePoint(checkpoint) {
    return checkpoint.reason === VerticalCheckpointReason.StartDecelerationToConstraint || checkpoint.reason === VerticalCheckpointReason.StartDecelerationToLimit;
  }
  function isApproachCheckpoint(checkpoint) {
    return checkpoint.reason === VerticalCheckpointReason.Decel || checkpoint.reason === VerticalCheckpointReason.Flaps1 || checkpoint.reason === VerticalCheckpointReason.Flaps2 || checkpoint.reason === VerticalCheckpointReason.Flaps3 || checkpoint.reason === VerticalCheckpointReason.FlapsFull;
  }
  class NavGeometryProfile extends BaseGeometryProfile {
    constructor(guidanceController, constraintReader, atmosphericConditions) {
      super();
      this.guidanceController = guidanceController;
      this.constraintReader = constraintReader;
      this.atmosphericConditions = atmosphericConditions;
      _defineProperty(this, "waypointPredictions", new Map());
    }
    get maxAltitudeConstraints() {
      return this.constraintReader.climbAlitudeConstraints;
    }
    get descentAltitudeConstraints() {
      return this.constraintReader.descentAltitudeConstraints;
    }
    get maxClimbSpeedConstraints() {
      return this.constraintReader.climbSpeedConstraints;
    }
    get descentSpeedConstraints() {
      return this.constraintReader.descentSpeedConstraints;
    }
    get distanceToPresentPosition() {
      return this.constraintReader.distanceToPresentPosition;
    }
    get cruiseSteps() {
      return this.constraintReader.cruiseSteps;
    }
    get totalFlightPlanDistance() {
      return this.constraintReader.totalFlightPlanDistance;
    }
    get lastCheckpoint() {
      if (this.checkpoints.length < 1) {
        return null;
      }
      return this.checkpoints[this.checkpoints.length - 1];
    }
    get finalDescentAngle() {
      return this.constraintReader.finalDescentAngle;
    }
    get fafDistanceToEnd() {
      return this.constraintReader.fafDistanceToEnd;
    }
    get finalAltitude() {
      return this.constraintReader.finalAltitude;
    }
    addCheckpointFromLast(checkpointBuilder) {
      this.checkpoints.push(_objectSpread2(_objectSpread2({}, this.lastCheckpoint), checkpointBuilder(this.lastCheckpoint)));
    }

    /**
     * This is used to display predictions in the MCDU
     */
    computePredictionsAtWaypoints() {
      const predictions = new Map();
      const fpm = this.guidanceController.flightPlanManager;
      if (!this.isReadyToDisplay) {
        return predictions;
      }
      const topOfDescent = this.findVerticalCheckpoint(VerticalCheckpointReason.TopOfDescent);
      const distanceToPresentPosition = this.distanceToPresentPosition;
      for (let i = this.guidanceController.activeLegIndex - 1; i < fpm.getWaypointsCount(FlightPlans.Active); i++) {
        const waypoint = fpm.getWaypoint(i, FlightPlans.Active);
        if (!waypoint) {
          continue;
        }
        const distanceFromStart = this.getDistanceFromStart(waypoint.additionalData.distanceToEnd);
        const {
          secondsFromPresent,
          altitude,
          speed,
          mach,
          remainingFuelOnBoard
        } = this.interpolateEverythingFromStart(distanceFromStart);
        const altitudeConstraint = getAltitudeConstraintFromWaypoint(waypoint);
        const speedConstraint = getSpeedConstraintFromWaypoint(waypoint);
        predictions.set(i, {
          waypointIndex: i,
          distanceFromStart,
          secondsFromPresent,
          altitude,
          speed: this.atmosphericConditions.casOrMach(speed, mach, altitude),
          altitudeConstraint,
          isAltitudeConstraintMet: altitudeConstraint && isAltitudeConstraintMet(altitudeConstraint, altitude, 250),
          speedConstraint,
          isSpeedConstraintMet: this.isSpeedConstraintMet(speed, speedConstraint),
          altError: this.computeAltError(altitude, altitudeConstraint),
          distanceToTopOfDescent: topOfDescent ? topOfDescent.distanceFromStart - distanceFromStart : null,
          estimatedFuelOnBoard: remainingFuelOnBoard,
          distanceFromAircraft: distanceFromStart - distanceToPresentPosition
        });
      }
      return predictions;
    }
    isSpeedConstraintMet(speed, constraint) {
      if (!constraint) {
        return true;
      }
      switch (constraint.type) {
        case SpeedConstraintType.at:
          return Math.abs(speed - constraint.speed) < 5;
        case SpeedConstraintType.atOrBelow:
          return speed - constraint.speed < 5;
        case SpeedConstraintType.atOrAbove:
          return speed - constraint.speed > -5;
        default:
          console.error('Invalid speed constraint type');
          return null;
      }
    }
    computeAltError(predictedAltitude, constraint) {
      if (!constraint) {
        return 0;
      }
      switch (constraint.type) {
        case AltitudeConstraintType.at:
          return predictedAltitude - constraint.altitude1;
        case AltitudeConstraintType.atOrAbove:
          return Math.min(predictedAltitude - constraint.altitude1, 0);
        case AltitudeConstraintType.atOrBelow:
          return Math.max(predictedAltitude - constraint.altitude1, 0);
        case AltitudeConstraintType.range:
          if (predictedAltitude >= constraint.altitude1) {
            return predictedAltitude - constraint.altitude1;
          }
          if (predictedAltitude <= constraint.altitude2) {
            return predictedAltitude - constraint.altitude1;
          }
          return 0;
        default:
          console.error('Invalid altitude constraint type');
          return 0;
      }
    }
    finalizeProfile() {
      super.finalizeProfile();
      this.waypointPredictions = this.computePredictionsAtWaypoints();
    }
    invalidate() {
      this.isReadyToDisplay = false;
      this.waypointPredictions = new Map();
    }
    getDistanceFromStart(distanceFromEnd) {
      return this.constraintReader.totalFlightPlanDistance - distanceFromEnd;
    }
    resetAltitudeConstraints() {
      this.constraintReader.climbAlitudeConstraints = [];
      this.constraintReader.descentAltitudeConstraints = [];
    }
    resetSpeedConstraints() {
      this.constraintReader.climbSpeedConstraints = [];
      this.constraintReader.descentSpeedConstraints = [];
    }
    ignoreCruiseStep(waypointIndex) {
      this.constraintReader.ignoreCruiseStep(waypointIndex);
    }
  }

  const PWP_IDENT_TOC = '(T/C)';
  const PWP_IDENT_STEP_CLIMB = '(S/C)';
  const PWP_IDENT_STEP_DESCENT = '(S/D)';
  const PWP_IDENT_SPD_LIM = '(LIM)';
  const PWP_IDENT_TOD = '(T/D)';
  const PWP_IDENT_DECEL = '(DECEL)';
  const PWP_IDENT_FLAP1 = '(FLAP1)';
  const PWP_IDENT_FLAP2 = '(FLAP2)';
  const CHECKPOINTS_TO_PUT_IN_MCDU = new Set([VerticalCheckpointReason.TopOfClimb, VerticalCheckpointReason.CrossingClimbSpeedLimit, VerticalCheckpointReason.StepClimb, VerticalCheckpointReason.StepDescent,
  // Descent
  VerticalCheckpointReason.TopOfDescent, VerticalCheckpointReason.CrossingDescentSpeedLimit,
  // Approach
  VerticalCheckpointReason.Decel, VerticalCheckpointReason.Flaps1, VerticalCheckpointReason.Flaps2]);
  const isCheckpointForMcduPwp = checkpoint => CHECKPOINTS_TO_PUT_IN_MCDU.has(checkpoint.reason);
  const CHECKPOINTS_TO_DRAW_ON_ND = new Set([VerticalCheckpointReason.TopOfClimb, VerticalCheckpointReason.LevelOffForClimbConstraint, VerticalCheckpointReason.ContinueClimb, VerticalCheckpointReason.CrossingFcuAltitudeClimb, VerticalCheckpointReason.TopOfDescent, VerticalCheckpointReason.CrossingFcuAltitudeDescent, VerticalCheckpointReason.ContinueDescent, VerticalCheckpointReason.ContinueDescentArmed, VerticalCheckpointReason.LevelOffForDescentConstraint, VerticalCheckpointReason.InterceptDescentProfileManaged, VerticalCheckpointReason.InterceptDescentProfileSelected, VerticalCheckpointReason.Decel, VerticalCheckpointReason.Flaps1, VerticalCheckpointReason.Flaps2]);
  const isCheckpointForNdPwp = checkpoint => CHECKPOINTS_TO_DRAW_ON_ND.has(checkpoint.reason);
  const CHECKPOINT_REASONS_BEFORE_FCU_ALT_FOR_PWP = [VerticalCheckpointReason.LevelOffForClimbConstraint, VerticalCheckpointReason.ContinueClimb, VerticalCheckpointReason.CrossingClimbSpeedLimit, VerticalCheckpointReason.CrossingFcuAltitudeClimb];
  const CDA_CHECKPOINT_FOR_PWP = new Set([VerticalCheckpointReason.Flaps1, VerticalCheckpointReason.Flaps2]);
  const isCheckpointForCdaPwp = checkpoint => CDA_CHECKPOINT_FOR_PWP.has(checkpoint.reason);
  class PseudoWaypoints {
    constructor(guidanceController, atmosphericConditions) {
      this.guidanceController = guidanceController;
      this.atmosphericConditions = atmosphericConditions;
      _defineProperty(this, "pseudoWaypoints", []);
    }
    acceptVerticalProfile() {
      this.recompute();
    }
    acceptMultipleLegGeometry(_geometry) {
      this.recompute();
    }
    recompute() {
      var _this$guidanceControl;
      const geometry = this.guidanceController.activeGeometry;
      const wptCount = this.guidanceController.flightPlanManager.getWaypointsCount();
      const navGeometryProfile = this.guidanceController.vnavDriver.mcduProfile;
      if (!geometry || geometry.legs.size < 1 || !(navGeometryProfile !== null && navGeometryProfile !== void 0 && navGeometryProfile.isReadyToDisplay)) {
        this.pseudoWaypoints.length = 0;
        return;
      }
      const ndPseudoWaypointCandidates = (_this$guidanceControl = this.guidanceController.vnavDriver.ndProfile) !== null && _this$guidanceControl !== void 0 && _this$guidanceControl.isReadyToDisplay ? this.guidanceController.vnavDriver.ndProfile.checkpoints.filter(isCheckpointForNdPwp) : [];
      const newPseudoWaypoints = [];
      const totalDistance = navGeometryProfile.totalFlightPlanDistance;
      const shouldEmitCdaPwp = VnavConfig.VNAV_DESCENT_MODE === VnavDescentMode.CDA && VnavConfig.VNAV_EMIT_CDA_FLAP_PWP;

      // We do this so we only draw the first of each waypoint type
      const waypointsLeftToDraw = new Set([...CHECKPOINTS_TO_PUT_IN_MCDU, ...CHECKPOINTS_TO_DRAW_ON_ND]);
      for (const checkpoint of [...navGeometryProfile.checkpoints.filter(isCheckpointForMcduPwp), ...ndPseudoWaypointCandidates]) {
        if (!waypointsLeftToDraw.has(checkpoint.reason) || !shouldEmitCdaPwp && isCheckpointForCdaPwp(checkpoint)) {
          continue;
        }

        // Do not draw climb PWP past the FCU altitude
        if (!waypointsLeftToDraw.has(VerticalCheckpointReason.CrossingFcuAltitudeClimb) && CHECKPOINT_REASONS_BEFORE_FCU_ALT_FOR_PWP.includes(checkpoint.reason)) {
          continue;
        }
        waypointsLeftToDraw.delete(checkpoint.reason);
        const pwp = this.createPseudoWaypointFromVerticalCheckpoint(geometry, wptCount, totalDistance, checkpoint);
        if (pwp) {
          newPseudoWaypoints.push(pwp);
        }
      }

      // Speed Changes
      const firstSpeedChange = this.guidanceController.vnavDriver.findNextSpeedChange();
      if (Number.isFinite(firstSpeedChange)) {
        let [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = [undefined, undefined, undefined];
        if (this.guidanceController.vnavDriver.isLatAutoControlActive()) {
          const pwp = this.pointFromEndOfPath(geometry, wptCount, totalDistance - firstSpeedChange);
          if (pwp) {
            [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = pwp;
          }
        }
        newPseudoWaypoints.push({
          ident: 'Speed change',
          alongLegIndex,
          distanceFromLegTermination,
          efisSymbolFlag: NdSymbolTypeFlags.PwpSpeedChange | NdSymbolTypeFlags.MagentaColor,
          efisSymbolLla,
          distanceFromStart: firstSpeedChange,
          displayedOnMcdu: false,
          displayedOnNd: true
        });
      }
      this.pseudoWaypoints = newPseudoWaypoints;
    }
    init() {
      console.log('[FMGC/Guidance] PseudoWaypoints initialized!');
    }
    update(_) {
      // Pass our pseudo waypoints to the GuidanceController
      this.guidanceController.currentPseudoWaypoints.length = 0;
      let idx = 0;
      for (const pseudoWaypoint of this.pseudoWaypoints) {
        const onPreviousLeg = pseudoWaypoint.alongLegIndex === this.guidanceController.activeLegIndex - 1;
        const onActiveLeg = pseudoWaypoint.alongLegIndex === this.guidanceController.activeLegIndex;
        const afterActiveLeg = pseudoWaypoint.alongLegIndex > this.guidanceController.activeLegIndex;
        const inSelectedHdg = !this.guidanceController.vnavDriver.isLatAutoControlActive();

        // TODO we also consider the previous leg as active because we sequence Type I transitions at the same point
        // for both guidance and legs list. IRL, the display sequences after the guidance, which means the pseudo-waypoints
        // on the first half of the transition are considered on the active leg, whereas without this hack they are
        // on the previous leg by the time we try to re-add them to the list.

        // We only want to add the pseudo waypoint if it's after the active leg or it isn't yet passed
        if (inSelectedHdg || afterActiveLeg || onPreviousLeg && this.guidanceController.displayActiveLegCompleteLegPathDtg > pseudoWaypoint.distanceFromLegTermination || onActiveLeg && this.guidanceController.activeLegCompleteLegPathDtg > pseudoWaypoint.distanceFromLegTermination) {
          this.guidanceController.currentPseudoWaypoints[++idx] = pseudoWaypoint;
        }
      }
    }

    /**
     * Notifies the FMS that a pseudo waypoint must be sequenced.
     *
     * This is to be sued by {@link GuidanceController} only.
     *
     * @param pseudoWaypoint the {@link PseudoWaypoint} to sequence.
     */
    sequencePseudoWaypoint(pseudoWaypoint) {
      {
        console.log("[FMS/PseudoWaypoints] Pseudo-waypoint '".concat(pseudoWaypoint.ident, "' sequenced."));
      }
      switch (pseudoWaypoint.sequencingType) {
        case PseudoWaypointSequencingAction.TOD_REACHED:
          // TODO EFIS message;
          break;
        case PseudoWaypointSequencingAction.APPROACH_PHASE_AUTO_ENGAGE:
          const apLateralMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Number');
          const agl = Simplane.getAltitudeAboveGround();
          if (agl < 9500 && (apLateralMode === LateralMode.NAV || apLateralMode === LateralMode.LOC_CPT || apLateralMode === LateralMode.LOC_TRACK)) {
            // Request APPROACH phase engagement for 5 seconds
            SimVar.SetSimVarValue('L:A32NX_FM_ENABLE_APPROACH_PHASE', 'Bool', true).then(() => [setTimeout(() => {
              SimVar.SetSimVarValue('L:A32NX_FM_ENABLE_APPROACH_PHASE', 'Bool', false);
            }, 5000)]);
          }
          break;
      }
    }

    /**
     * Computes a the distance between the fix before the PWP and the PWP
     *
     * @param leg               the leg along which this pseudo waypoint is situated
     * @param distanceAlongLeg  the distance from the termination of the leg to this pseudo waypoint
     *
     * @private
     */
    static computePseudoWaypointDistanceFromFix(leg, distanceAlongLeg) {
      var _leg$distance;
      return ((_leg$distance = leg === null || leg === void 0 ? void 0 : leg.distance) !== null && _leg$distance !== void 0 ? _leg$distance : 0) - distanceAlongLeg;
    }
    pointFromEndOfPath(path, wptCount, distanceFromEnd, debugString) {
      if (!distanceFromEnd || distanceFromEnd < 0) {
        return undefined;
      }
      let accumulator = 0;
      const destination = this.guidanceController.flightPlanManager.getDestination();
      for (let i = wptCount - 1; i > 0; i--) {
        const leg = path.legs.get(i);
        if (!leg || leg.isNull) {
          continue;
        }
        let distanceInDiscontinuity = 0;
        const nextLeg = path.legs.get(i + 1);
        const previousLeg = path.legs.get(i - 1);
        if (leg instanceof XFLeg && leg.fix.endsInDiscontinuity) {
          if (!nextLeg) {
            // The idea is that if there's a discontinuity but not next leg, we're probably at the end of the path.
            // So the distance in the discontinuity is just the distance to the airport.
            distanceInDiscontinuity = Avionics.Utils.computeGreatCircleDistance(leg.fix.infos.coordinates, destination.infos.coordinates);
          } else if (nextLeg instanceof XFLeg) {
            distanceInDiscontinuity = Avionics.Utils.computeGreatCircleDistance(leg.fix.infos.coordinates, nextLeg.fix.infos.coordinates);
          }
        } else if (leg instanceof VMLeg && previousLeg instanceof XFLeg && nextLeg instanceof XFLeg) {
          distanceInDiscontinuity = Avionics.Utils.computeGreatCircleDistance(previousLeg.fix.infos.coordinates, nextLeg.fix.infos.coordinates);
        }
        accumulator += distanceInDiscontinuity;
        const inboundTrans = path.transitions.get(i - 1);
        const outboundTrans = path.transitions.get(i);
        const [inboundTransLength, legPartLength, outboundTransLength] = Geometry.completeLegPathLengths(leg, inboundTrans, outboundTrans instanceof FixedRadiusTransition ? outboundTrans : null);
        const totalLegPathLength = inboundTransLength + legPartLength + outboundTransLength;
        accumulator += totalLegPathLength;
        if (accumulator > distanceFromEnd) {
          if (distanceInDiscontinuity > 0 && accumulator - totalLegPathLength > distanceFromEnd) {
            var _destination$infos;
            // Points lies on discontinuity (on the direct line between the two fixes)
            // In this case, we don't want to place the PWP unless we force placement. In this case, we place it on the termination
            if (nextLeg instanceof IFLeg) {
              // If the point lies on a discontinuity, we place it on the next leg.
              return [nextLeg.fix.infos.coordinates, distanceFromEnd - (accumulator - totalLegPathLength), i + 1];
            }
            if (!nextLeg && destination !== null && destination !== void 0 && (_destination$infos = destination.infos) !== null && _destination$infos !== void 0 && _destination$infos.coordinates) {
              // Hack until destination airport is properly handled (should exist as IF leg in geometry.)
              return [destination.infos.coordinates, distanceFromEnd, i + 1];
            }
            return undefined;
          }
          const distanceFromEndOfLeg = distanceFromEnd - (accumulator - totalLegPathLength);
          let lla;
          if (distanceFromEndOfLeg < outboundTransLength) {
            // Point is in outbound transition segment
            const distanceBeforeTerminator = outboundTrans.distance / 2 + distanceFromEndOfLeg;
            lla = outboundTrans.getPseudoWaypointLocation(distanceBeforeTerminator);
          } else if (distanceFromEndOfLeg >= outboundTransLength && distanceFromEndOfLeg < outboundTransLength + legPartLength) {
            // Point is in leg segment
            const distanceBeforeTerminator = distanceFromEndOfLeg - outboundTransLength;
            lla = leg.getPseudoWaypointLocation(distanceBeforeTerminator);
          } else {
            // Point is in inbound transition segment
            const distanceBeforeTerminator = distanceFromEndOfLeg - outboundTransLength - legPartLength;
            lla = inboundTrans.getPseudoWaypointLocation(distanceBeforeTerminator);
          }
          if (lla) {
            return [lla, distanceFromEndOfLeg, i];
          }
          return undefined;
        }
      }
      return undefined;
    }
    createPseudoWaypointFromVerticalCheckpoint(geometry, wptCount, totalDistance, checkpoint) {
      let [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = [undefined, undefined, undefined];
      // We want the decel point and T/D to be drawn along the track line even if not in NAV mode
      if (this.guidanceController.vnavDriver.isLatAutoControlActive() || isCheckpointForMcduPwp(checkpoint)) {
        const pwp = this.pointFromEndOfPath(geometry, wptCount, totalDistance - (checkpoint === null || checkpoint === void 0 ? void 0 : checkpoint.distanceFromStart), checkpoint.reason);
        if (!pwp) {
          return undefined;
        }
        [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = pwp;
      }
      switch (checkpoint.reason) {
        case VerticalCheckpointReason.LevelOffForClimbConstraint:
          return {
            ident: 'Level 1',
            efisSymbolFlag: NdSymbolTypeFlags.PwpClimbLevelOff | NdSymbolTypeFlags.MagentaColor,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.ContinueClimb:
          return {
            ident: 'Start of climb 1',
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpStartOfClimb | NdSymbolTypeFlags.CyanColor,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.CrossingClimbSpeedLimit:
          return {
            ident: PWP_IDENT_SPD_LIM,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: 0,
            // Since this is not shown on the ND, it does not need a symbol
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            mcduHeader: '\xa0(SPD)',
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: false
          };
        case VerticalCheckpointReason.CrossingDescentSpeedLimit:
          return {
            ident: PWP_IDENT_SPD_LIM,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: 0,
            // Since this is not shown on the ND, it does not need a symbol
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            mcduHeader: '\xa0(SPD)',
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: false
          };
        case VerticalCheckpointReason.CrossingFcuAltitudeClimb:
          return {
            ident: 'Level 2',
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpClimbLevelOff | NdSymbolTypeFlags.CyanColor,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.TopOfClimb:
          return {
            ident: PWP_IDENT_TOC,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: 0,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: false
          };
        case VerticalCheckpointReason.StepClimb:
          return {
            ident: PWP_IDENT_STEP_CLIMB,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpStartOfClimb,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: this.guidanceController.vnavDriver.isLatAutoControlActive()
          };
        case VerticalCheckpointReason.StepDescent:
          return {
            ident: PWP_IDENT_TOD,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpTopOfDescent,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: this.guidanceController.vnavDriver.isLatAutoControlActive(),
            mcduIdent: PWP_IDENT_STEP_DESCENT
          };
        case VerticalCheckpointReason.ContinueDescent:
          return {
            ident: PWP_IDENT_TOD,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpTopOfDescent,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.ContinueDescentArmed:
          return {
            ident: PWP_IDENT_TOD,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpTopOfDescent | NdSymbolTypeFlags.CyanColor,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.TopOfDescent:
          return {
            ident: PWP_IDENT_TOD,
            sequencingType: PseudoWaypointSequencingAction.TOD_REACHED,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpTopOfDescent,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: this.guidanceController.vnavDriver.isLatAutoControlActive() || this.guidanceController.vnavDriver.isFlightPhasePreflight()
          };
        case VerticalCheckpointReason.CrossingFcuAltitudeDescent:
          return {
            ident: 'Level 2',
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpDescentLevelOff | NdSymbolTypeFlags.CyanColor,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.LevelOffForDescentConstraint:
          return {
            ident: 'Level 1',
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpDescentLevelOff | NdSymbolTypeFlags.MagentaColor,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.InterceptDescentProfileSelected:
          return {
            ident: 'Intercept point 1',
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpInterceptProfile,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.InterceptDescentProfileManaged:
          return {
            ident: 'Intercept point 2',
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpInterceptProfile | NdSymbolTypeFlags.CyanColor,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: false,
            displayedOnNd: true
          };
        case VerticalCheckpointReason.Decel:
          return {
            ident: PWP_IDENT_DECEL,
            sequencingType: PseudoWaypointSequencingAction.APPROACH_PHASE_AUTO_ENGAGE,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpDecel | (Simplane.getAutoPilotAirspeedManaged() && this.guidanceController.vnavDriver.isLatAutoControlActive() ? NdSymbolTypeFlags.MagentaColor : 0),
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: true
          };
        case VerticalCheckpointReason.Flaps1:
          return {
            ident: PWP_IDENT_FLAP1,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpCdaFlap1,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: true
          };
        case VerticalCheckpointReason.Flaps2:
          return {
            ident: PWP_IDENT_FLAP2,
            alongLegIndex,
            distanceFromLegTermination,
            efisSymbolFlag: NdSymbolTypeFlags.PwpCdaFlap2,
            efisSymbolLla,
            distanceFromStart: checkpoint.distanceFromStart,
            displayedOnMcdu: true,
            flightPlanInfo: this.formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination),
            displayedOnNd: true
          };
        default:
          return undefined;
      }
    }
    createDebugPwp(geometry, wptCount, totalDistance) {
      const debugDistanceToEnd = SimVar.GetSimVarValue('L:A32NX_FM_VNAV_DEBUG_DISTANCE_TO_END', 'number');
      if (debugDistanceToEnd <= 0) {
        return null;
      }
      const position = this.pointFromEndOfPath(geometry, wptCount, debugDistanceToEnd);
      if (!position) {
        return null;
      }
      const [efisSymbolLla, distanceFromLegTermination, alongLegIndex] = position;
      return {
        ident: 'DEBUG_POINT',
        alongLegIndex,
        distanceFromLegTermination,
        efisSymbolFlag: NdSymbolTypeFlags.PwpSpeedChange | NdSymbolTypeFlags.CyanColor,
        efisSymbolLla,
        distanceFromStart: totalDistance - debugDistanceToEnd,
        displayedOnMcdu: false,
        displayedOnNd: true
      };
    }
    formatFlightPlanInfo(checkpoint, geometry, alongLegIndex, distanceFromLegTermination) {
      return _objectSpread2(_objectSpread2({}, checkpoint), {}, {
        speed: this.atmosphericConditions.casOrMach(checkpoint.speed, checkpoint.mach, checkpoint.altitude),
        distanceFromLastFix: Number.isFinite(alongLegIndex) ? PseudoWaypoints.computePseudoWaypointDistanceFromFix(geometry.legs.get(alongLegIndex), distanceFromLegTermination) : 0
      });
    }
  }

  class GenericDataListenerSync {
    constructor(recvEventCb, topic) {
      _defineProperty(this, "dataPackageQueue", void 0);
      _defineProperty(this, "topic", void 0);
      _defineProperty(this, "isRunning", void 0);
      _defineProperty(this, "listener", void 0);
      _defineProperty(this, "lastEventSynced", -1);
      _defineProperty(this, "recvEventCb", void 0);
      this.topic = topic;
      this.dataPackageQueue = [];
      this.isRunning = true;
      this.recvEventCb = recvEventCb;
      this.listener = RegisterGenericDataListener(() => {
        this.listener.onDataReceived(GenericDataListenerSync.EB_LISTENER_KEY, data => {
          this.processEventsReceived(data);
        });
      });
      const sendFn = () => {
        if (this.dataPackageQueue.length > 0) {
          const syncDataPackage = {
            packagedId: Math.floor(Math.random() * 1000000000),
            data: this.dataPackageQueue
          };
          this.listener.send(GenericDataListenerSync.EB_LISTENER_KEY, syncDataPackage);
          this.dataPackageQueue.length = 0;
        }
        if (this.isRunning) {
          requestAnimationFrame(sendFn);
        }
      };
      requestAnimationFrame(sendFn);
    }
    stop() {
      this.isRunning = false;
    }

    /**
     * Processes events received from onInteractionEvent and executes the configured callback.
     * @param target always empty
     * @param args SyncDataPackage
     */
    processEventsReceived(syncPackage) {
      const syncDataPackage = syncPackage;
      if (syncDataPackage.packagedId !== this.lastEventSynced) {
        this.lastEventSynced = syncDataPackage.packagedId;
        syncDataPackage.data.forEach(data => {
          if (data.topic === this.topic) {
            try {
              this.recvEventCb(data.topic, data.data !== undefined ? data.data : undefined);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          }
        });
      }
    }

    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     */
    sendEvent(topic, data) {
      const dataObj = data;
      const dataPackage = {
        topic,
        data: dataObj
      };
      this.dataPackageQueue.push(dataPackage);
    }
    receiveEvent() {
      // noop
    }
  }
  _defineProperty(GenericDataListenerSync, "EB_LISTENER_KEY", 'EB_EVENTS');

  const UPDATE_TIMER = 2500;
  class EfisVectors {
    constructor(guidanceController) {
      this.guidanceController = guidanceController;
      _defineProperty(this, "syncer", new GenericDataListenerSync());
      _defineProperty(this, "currentActiveVectors", []);
      _defineProperty(this, "currentDashedVectors", []);
      _defineProperty(this, "currentTemporaryVectors", []);
      _defineProperty(this, "updateTimer", 0);
    }
    forceUpdate() {
      this.updateTimer = UPDATE_TIMER + 1;
    }
    update(deltaTime) {
      var _this$guidanceControl, _this$guidanceControl2, _this$guidanceControl3, _this$guidanceControl4, _this$guidanceControl5, _this$guidanceControl6;
      this.updateTimer += deltaTime;
      if (this.updateTimer < UPDATE_TIMER) {
        return;
      }
      this.updateTimer = 0;
      const activeFlightPlanVectors = (_this$guidanceControl = (_this$guidanceControl2 = this.guidanceController.activeGeometry) === null || _this$guidanceControl2 === void 0 ? void 0 : _this$guidanceControl2.getAllPathVectors(this.guidanceController.activeLegIndex)) !== null && _this$guidanceControl !== void 0 ? _this$guidanceControl : [];
      const temporaryFlightPlanVectors = (_this$guidanceControl3 = (_this$guidanceControl4 = this.guidanceController.temporaryGeometry) === null || _this$guidanceControl4 === void 0 ? void 0 : _this$guidanceControl4.getAllPathVectors(this.guidanceController.temporaryLegIndex)) !== null && _this$guidanceControl3 !== void 0 ? _this$guidanceControl3 : [];
      const visibleActiveFlightPlanVectors = activeFlightPlanVectors.filter(vector => EfisVectors.isVectorReasonable(vector));
      const visibleTemporaryFlightPlanVectors = temporaryFlightPlanVectors.filter(vector => EfisVectors.isVectorReasonable(vector));
      if (visibleActiveFlightPlanVectors.length !== activeFlightPlanVectors.length) {
        this.guidanceController.efisStateForSide.L.legsCulled = true;
        this.guidanceController.efisStateForSide.R.legsCulled = true;
      } else {
        this.guidanceController.efisStateForSide.L.legsCulled = false;
        this.guidanceController.efisStateForSide.R.legsCulled = false;
      }

      // ACTIVE

      const engagedLateralMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Number');
      const armedLateralMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_ARMED', 'Enum');
      const navArmed = isArmed(armedLateralMode, ArmedLateralMode.NAV);
      const transmitActive = engagedLateralMode === LateralMode.NAV || engagedLateralMode === LateralMode.LOC_CPT || engagedLateralMode === LateralMode.LOC_TRACK || navArmed;
      const clearActive = !transmitActive && this.currentActiveVectors.length > 0;
      if (transmitActive) {
        this.currentActiveVectors = visibleActiveFlightPlanVectors;
        this.transmitGroup(this.currentActiveVectors, EfisVectorsGroup.ACTIVE);
      }
      if (clearActive) {
        this.currentActiveVectors = [];
        this.transmitGroup(this.currentActiveVectors, EfisVectorsGroup.ACTIVE);
      }

      // DASHED

      const transmitDashed = !transmitActive;
      const clearDashed = !transmitDashed && this.currentDashedVectors.length > 0;
      if (transmitDashed) {
        this.currentDashedVectors = visibleActiveFlightPlanVectors;
        this.transmitGroup(this.currentDashedVectors, EfisVectorsGroup.DASHED);
      }
      if (clearDashed) {
        this.currentDashedVectors = [];
        this.transmitGroup(this.currentDashedVectors, EfisVectorsGroup.DASHED);
      }

      // TEMPORARY

      const transmitTemporary = this.guidanceController.hasTemporaryFlightPlan && ((_this$guidanceControl5 = this.guidanceController.temporaryGeometry) === null || _this$guidanceControl5 === void 0 ? void 0 : (_this$guidanceControl6 = _this$guidanceControl5.legs) === null || _this$guidanceControl6 === void 0 ? void 0 : _this$guidanceControl6.size) > 0;
      const clearTemporary = !transmitTemporary && this.currentTemporaryVectors.length > 0;
      if (transmitTemporary) {
        this.currentTemporaryVectors = visibleTemporaryFlightPlanVectors;
        this.transmitGroup(this.currentTemporaryVectors, EfisVectorsGroup.TEMPORARY);
      }
      if (clearTemporary) {
        this.currentTemporaryVectors = [];
        this.transmitGroup(this.currentTemporaryVectors, EfisVectorsGroup.TEMPORARY);
      }
    }

    /**
     * Protect against potential perf issues from immense vectors
     */
    static isVectorReasonable(vector) {
      if (!pathVectorValid(vector)) {
        return false;
      }
      const length = pathVectorLength(vector);
      return length <= 5000;
    }
    transmitGroup(vectors, group) {
      this.transmit(vectors, group, 'L');
      this.transmit(vectors, group, 'R');
    }
    transmit(vectors, vectorsGroup, side) {
      this.syncer.sendEvent("A32NX_EFIS_VECTORS_".concat(side, "_").concat(EfisVectorsGroup[vectorsGroup]), vectors);
    }
  }

  let TaskCategory = /*#__PURE__*/function (TaskCategory) {
    TaskCategory[TaskCategory["EfisVectors"] = 0] = "EfisVectors";
    return TaskCategory;
  }({});
  class TaskQueue {
    constructor() {
      _defineProperty(this, "taskQueue", []);
      _defineProperty(this, "currentTask", null);
      _defineProperty(this, "currentTaskExecutor", null);
    }
    update(_deltaTime) {
      if (!this.currentTask && this.taskQueue.length > 0) {
        const nextTask = this.taskQueue.shift();
        if (nextTask) {
          this.currentTask = nextTask;
          this.currentTaskExecutor = nextTask.executor();
        }
      }
      if (this.currentTask) {
        const done = this.currentTaskExecutor.next().done;
        if (done) {
          this.currentTask = null;
          this.currentTaskExecutor = null;
        }
      }
    }
    runStepTask(executor) {
      this.taskQueue.push(executor);
    }
    cancelAllInCategory(category) {
      var _this$currentTask;
      if (((_this$currentTask = this.currentTask) === null || _this$currentTask === void 0 ? void 0 : _this$currentTask.category) === category) {
        this.currentTask = null;
        this.currentTaskExecutor = null;
      }
      for (const queuedTask of this.taskQueue) {
        if (queuedTask.category === category) {
          this.taskQueue = this.taskQueue.filter(task => task === queuedTask);
        }
      }
    }
  }

  class SimVarString {
    /**
     * Pack a string into numbers for use in a simvar
     * ASCII chars from dec 32-63 can be encoded, 6-bit per char, 8 chars per simvar
     * IMPORTANT: write the values as strings to the simvars or you will have precision errors
     * @param value
     * @param maxLength if specified enough simvars will be returned to fit this length,
     * and the value will be trimmed to this length
     * @returns an array of numbers ready to be written to simvars
     */
    static pack(value, maxLength) {
      let word = -1;
      const ret = [];
      for (let i = 0; i < Math.min(maxLength, value.length); i++) {
        const char = i % 8;
        if (char === 0) {
          word++;
          ret[word] = 0;
        }
        let code = value.charCodeAt(i) - 31;
        if (code < 1 || code > 63 || !Number.isFinite(code)) {
          code = 0;
        }
        ret[word] += 2 ** (char * 6) * code;
      }
      if (maxLength && ret.length < Math.ceil(maxLength / 8)) {
        ret.push(...new Array(Math.ceil(maxLength / 8) - ret.length).fill(0));
      }
      return ret;
    }

    /**
     * Unpacks numeric values packed by @see packString
     * @param values an array of numbers from the simvars
     * @returns the unpacked string
     */
    static unpack(values) {
      let ret = '';
      for (let i = 0; i < values.length * 8; i++) {
        const word = Math.floor(i / 8);
        const char = i % 8;
        const code = Math.floor(values[word] / 2 ** (char * 6)) & 0x3f;
        if (code > 0) {
          ret += String.fromCharCode(code + 31);
        }
      }
      return ret;
    }
  }

  class VerticalProfileComputationParametersObserver {
    constructor(fmgc) {
      this.fmgc = fmgc;
      _defineProperty(this, "parameters", void 0);
      this.update();
    }
    update() {
      var _this$fmgc$getDepartu;
      this.parameters = {
        presentPosition: this.getPresentPosition(),
        fcuAltitude: Simplane.getAutoPilotDisplayedAltitudeLockValue(),
        fcuVerticalMode: SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum'),
        fcuLateralMode: SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Enum'),
        fcuVerticalSpeed: SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_VS_SELECTED', 'Feet per minute'),
        fcuFlightPathAngle: SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_FPA_SELECTED', 'Degrees'),
        fcuSpeedManaged: SimVar.GetSimVarValue('L:A32NX_FCU_SPD_MANAGED_DOT', 'number'),
        fcuSpeed: SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_SPEED_SELECTED', 'number'),
        fcuArmedLateralMode: SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_ARMED', 'number'),
        fcuArmedVerticalMode: SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_ARMED', 'number'),
        fcuExpediteModeActive: SimVar.GetSimVarValue('L:A32NX_FMA_EXPEDITE_MODE', 'number'),
        qnhSettingMillibar: Simplane.getPressureValue('millibar'),
        managedClimbSpeed: this.fmgc.getManagedClimbSpeed(),
        managedClimbSpeedMach: this.fmgc.getManagedClimbSpeedMach(),
        managedCruiseSpeed: this.fmgc.getManagedCruiseSpeed(),
        managedCruiseSpeedMach: this.fmgc.getManagedCruiseSpeedMach(),
        managedDescentSpeed: this.fmgc.getManagedDescentSpeed(),
        managedDescentSpeedMach: this.fmgc.getManagedDescentSpeedMach(),
        zeroFuelWeight: this.fmgc.getZeroFuelWeight(),
        fuelOnBoard: UnitType.TONNE.convertTo(this.fmgc.getFOB(), UnitType.POUND),
        v2Speed: this.fmgc.getV2Speed(),
        tropoPause: this.fmgc.getTropoPause(),
        perfFactor: 0,
        // FIXME: Use actual value,
        departureElevation: (_this$fmgc$getDepartu = this.fmgc.getDepartureElevation()) !== null && _this$fmgc$getDepartu !== void 0 ? _this$fmgc$getDepartu : 0,
        /**
         * This differs from the altitude I use to start building the descent profile.
         * This one one is the altitude of the destination airport, the other one is the final procedure altitude.
         */
        destinationElevation: this.fmgc.getDestinationElevation(),
        accelerationAltitude: this.fmgc.getAccelerationAltitude(),
        thrustReductionAltitude: this.fmgc.getThrustReductionAltitude(),
        originTransitionAltitude: this.fmgc.getOriginTransitionAltitude(),
        cruiseAltitude: Number.isFinite(this.fmgc.getCruiseAltitude()) ? this.fmgc.getCruiseAltitude() : this.parameters.cruiseAltitude,
        climbSpeedLimit: this.fmgc.getClimbSpeedLimit(),
        descentSpeedLimit: this.fmgc.getDescentSpeedLimit(),
        flightPhase: this.fmgc.getFlightPhase(),
        preselectedClbSpeed: this.fmgc.getPreSelectedClbSpeed(),
        preselectedCruiseSpeed: this.fmgc.getPreSelectedCruiseSpeed(),
        preselectedDescentSpeed: this.fmgc.getPreSelectedDescentSpeed(),
        takeoffFlapsSetting: this.fmgc.getTakeoffFlapsSetting(),
        estimatedDestinationFuel: UnitType.TONNE.convertTo(this.fmgc.getDestEFOB(false), UnitType.POUND),
        approachQnh: this.fmgc.getApproachQnh(),
        approachTemperature: this.fmgc.getApproachTemperature(),
        approachSpeed: this.fmgc.getApproachSpeed(),
        flapRetractionSpeed: this.fmgc.getFlapRetractionSpeed(),
        slatRetractionSpeed: this.fmgc.getSlatRetractionSpeed(),
        cleanSpeed: this.fmgc.getCleanSpeed()
      };
    }
    getPresentPosition() {
      return new LatLongAlt(SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'), SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude'), SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
    }
    get() {
      return this.parameters;
    }
    canComputeProfile() {
      const areApproachSpeedsValid = this.parameters.cleanSpeed > 100 && this.parameters.slatRetractionSpeed > 100 && this.parameters.flapRetractionSpeed > 100 && this.parameters.approachSpeed > 100;
      const hasZeroFuelWeight = Number.isFinite(this.parameters.zeroFuelWeight);
      const hasTakeoffParameters = this.parameters.v2Speed > 0 && this.parameters.thrustReductionAltitude > 0 && this.parameters.accelerationAltitude > 0;
      return (this.parameters.flightPhase > FmgcFlightPhase.Takeoff || hasTakeoffParameters) && areApproachSpeedsValid && hasZeroFuelWeight;
    }
  }

  class WindVector {
    constructor(direction, speed) {
      this.direction = direction;
      this.speed = speed;
      Avionics.Utils.clampAngle(direction);
      if (speed < 0) {
        this.flipDirection();
        this.speed *= -1;
      }
    }
    flipDirection() {
      if (this.direction < 180) {
        this.direction += 180;
      }
      this.direction -= 180;
    }
    static default() {
      return new WindVector(0, 0);
    }
  }
  class WindComponent {
    /**
     *
     * @param value +ve for a tailwind, -ve for headwind
     */
    constructor(value) {
      this.value = value;
    }
    static fromVector(vector, planeHeading) {
      return new WindComponent(vector.speed * Math.cos(MathUtils$1.DEGREES_TO_RADIANS * Avionics.Utils.diffAngle(vector.direction, planeHeading)));
    }
    static zero() {
      return new WindComponent(0);
    }
  }

  class ClimbWindProfile {
    constructor(inputs, measurementDevice, aircraftDistanceFromStart) {
      this.inputs = inputs;
      this.measurementDevice = measurementDevice;
      this.aircraftDistanceFromStart = aircraftDistanceFromStart;
    }
    interpolateByAltitude(altitude) {
      if (this.inputs.climbWinds.length === 0) {
        return WindVector.default();
      }
      if (altitude <= this.inputs.climbWinds[0].altitude) {
        return this.inputs.climbWinds[0].vector;
      }
      for (let i = 0; i < this.inputs.climbWinds.length - 1; i++) {
        if (altitude > this.inputs.climbWinds[i].altitude && altitude <= this.inputs.climbWinds[i + 1].altitude) {
          const scaling = (altitude - this.inputs.climbWinds[i].altitude) / (this.inputs.climbWinds[i + 1].altitude - this.inputs.climbWinds[i].altitude);
          return this.interpolateVectors(this.inputs.climbWinds[i].vector, this.inputs.climbWinds[i + 1].vector, scaling);
        }
      }
      return this.inputs.climbWinds[this.inputs.climbWinds.length - 1].vector;
    }
    getHeadwindComponent(distanceFromStart, altitude, planeHeading) {
      const hasForecast = this.inputs.climbWinds.length !== 0;
      const measurement = this.measurementDevice.get();
      const hasMeasurement = measurement !== null;
      if (!hasForecast) {
        if (!hasMeasurement) {
          return this.inputs.tripWind;
        }
        return WindComponent.fromVector(measurement, planeHeading);
      }
      const forecast = this.interpolateByAltitude(altitude);
      const distanceToAirplane = distanceFromStart - this.aircraftDistanceFromStart;
      if (!hasMeasurement || distanceToAirplane < 0) {
        return WindComponent.fromVector(forecast, planeHeading);
      }
      const scaling = Math.min(1, distanceToAirplane / 200);
      return WindComponent.fromVector(this.interpolateVectors(measurement, forecast, scaling), planeHeading);
    }
    interpolateVectors(vector1, vector2, scaling) {
      return new WindVector((1 - scaling) * vector1.direction + scaling * vector2.direction, (1 - scaling) * vector1.speed + scaling * vector2.speed);
    }
  }

  // TODO: Make this actually use cruise winds.
  // I have kept it like this for now, so I can inject it into the profile computations already and change the actual code when I'm ready.
  class CruiseWindProfile {
    constructor(inputs, measurementDevice, aircraftDistanceFromStart) {
      this.inputs = inputs;
      this.measurementDevice = measurementDevice;
      this.aircraftDistanceFromStart = aircraftDistanceFromStart;
    }
    interpolateByAltitude(altitude) {
      if (this.inputs.climbWinds.length === 0) {
        return WindVector.default();
      }
      if (altitude <= this.inputs.climbWinds[0].altitude) {
        return this.inputs.climbWinds[0].vector;
      }
      for (let i = 0; i < this.inputs.climbWinds.length - 1; i++) {
        if (altitude > this.inputs.climbWinds[i].altitude && altitude <= this.inputs.climbWinds[i + 1].altitude) {
          const scaling = (altitude - this.inputs.climbWinds[i].altitude) / (this.inputs.climbWinds[i + 1].altitude - this.inputs.climbWinds[i].altitude);
          return this.interpolateVectors(this.inputs.climbWinds[i].vector, this.inputs.climbWinds[i + 1].vector, scaling);
        }
      }
      return this.inputs.climbWinds[this.inputs.climbWinds.length - 1].vector;
    }
    getHeadwindComponent(distanceFromStart, altitude, planeHeading) {
      const hasForecast = this.inputs.climbWinds.length !== 0;
      const measurement = this.measurementDevice.get();
      const hasMeasurement = measurement !== null;
      if (!hasForecast) {
        if (!hasMeasurement) {
          return this.inputs.tripWind;
        }
        return WindComponent.fromVector(measurement, planeHeading);
      }
      const forecast = this.interpolateByAltitude(altitude);
      const distanceToAirplane = distanceFromStart - this.aircraftDistanceFromStart;
      if (!hasMeasurement || distanceToAirplane < 0) {
        return WindComponent.fromVector(forecast, planeHeading);
      }
      const scaling = Math.min(1, distanceToAirplane / 200);
      return WindComponent.fromVector(this.interpolateVectors(measurement, forecast, scaling), planeHeading);
    }
    interpolateVectors(vector1, vector2, scaling) {
      return new WindVector((1 - scaling) * vector1.direction + scaling * vector2.direction, (1 - scaling) * vector1.speed + scaling * vector2.speed);
    }
  }

  class DescentWindProfile {
    constructor(inputs, measurementDevice, aircraftDistanceFromStart) {
      this.inputs = inputs;
      this.measurementDevice = measurementDevice;
      this.aircraftDistanceFromStart = aircraftDistanceFromStart;
    }
    interpolateByAltitude(altitude) {
      if (this.inputs.descentWinds.length === 0) {
        return WindVector.default();
      }
      if (altitude <= this.inputs.descentWinds[0].altitude) {
        return this.inputs.descentWinds[0].vector;
      }
      for (let i = 0; i < this.inputs.descentWinds.length - 1; i++) {
        if (altitude > this.inputs.descentWinds[i].altitude && altitude <= this.inputs.descentWinds[i + 1].altitude) {
          const scaling = (altitude - this.inputs.descentWinds[i].altitude) / (this.inputs.descentWinds[i + 1].altitude - this.inputs.descentWinds[i].altitude);
          return this.interpolateVectors(this.inputs.descentWinds[i].vector, this.inputs.descentWinds[i + 1].vector, scaling);
        }
      }
      return this.inputs.descentWinds[this.inputs.descentWinds.length - 1].vector;
    }
    getHeadwindComponent(distanceFromStart, altitude, planeHeading) {
      const hasForecast = this.inputs.descentWinds.length !== 0;
      const measurement = this.measurementDevice.get();
      const hasMeasurement = measurement !== null;
      if (!hasForecast) {
        if (!hasMeasurement) {
          return this.inputs.tripWind;
        }
        return WindComponent.fromVector(measurement, planeHeading);
      }
      const forecast = this.interpolateByAltitude(altitude);
      const distanceToAirplane = distanceFromStart - this.aircraftDistanceFromStart;
      if (!hasMeasurement || distanceToAirplane < 0) {
        return WindComponent.fromVector(forecast, planeHeading);
      }
      const scaling = Math.min(1, distanceToAirplane / 200);
      return WindComponent.fromVector(this.interpolateVectors(measurement, forecast, scaling), planeHeading);
    }
    interpolateVectors(vector1, vector2, scaling) {
      return new WindVector((1 - scaling) * vector1.direction + scaling * vector2.direction, (1 - scaling) * vector1.speed + scaling * vector2.speed);
    }
  }

  class WindForecastInputObserver {
    constructor(fmgc) {
      this.fmgc = fmgc;
      _defineProperty(this, "inputs", void 0);
      this.inputs = {
        tripWind: new WindComponent(0),
        climbWinds: [],
        cruiseWindsByWaypoint: new Map(),
        descentWinds: [],
        destinationWind: new WindVector(0, 0)
      };
      this.update();
    }
    update() {
      var _this$fmgc$getTripWin;
      this.inputs.tripWind = new WindComponent((_this$fmgc$getTripWin = this.fmgc.getTripWind()) !== null && _this$fmgc$getTripWin !== void 0 ? _this$fmgc$getTripWin : 0);
      this.parseFmcWinds(this.fmgc.getWinds());
      const {
        direction,
        speed
      } = this.fmgc.getApproachWind();
      this.inputs.destinationWind = new WindVector(direction, speed);
    }
    get() {
      return this.inputs;
    }
    get tripWind() {
      return this.inputs.tripWind;
    }
    get climbWinds() {
      return this.inputs.climbWinds;
    }
    get cruiseWindsByWaypoint() {
      return this.inputs.cruiseWindsByWaypoint;
    }
    get descentWinds() {
      return this.inputs.descentWinds;
    }
    get destinationWind() {
      return this.inputs.destinationWind;
    }
    parseFmcWinds(fmcWinds) {
      const parseFmcWindEntry = _ref => {
        let {
          direction,
          speed,
          altitude
        } = _ref;
        return {
          altitude,
          vector: new WindVector(direction, speed)
        };
      };
      this.inputs.climbWinds = fmcWinds.climb.map(parseFmcWindEntry);
      // TODO: Cruise winds
      this.inputs.descentWinds = fmcWinds.des.map(parseFmcWindEntry);
    }
  }

  class WindObserver {
    constructor(irsIndex) {
      this.irsIndex = irsIndex;
    }
    get() {
      const windDirection = Arinc429Word.fromSimVarValue("L:A32NX_ADIRS_IR_".concat(this.irsIndex, "_WIND_DIRECTION"));
      const windSpeed = Arinc429Word.fromSimVarValue("L:A32NX_ADIRS_IR_".concat(this.irsIndex, "_WIND_SPEED"));
      if (!windDirection.isNormalOperation() || !windSpeed.isNormalOperation()) {
        return null;
      }
      return new WindVector(windDirection.value, windSpeed.value);
    }
  }

  class WindProfileFactory {
    constructor(fmgc, fmgcSide) {
      _defineProperty(this, "windObserver", void 0);
      _defineProperty(this, "windInputObserver", void 0);
      _defineProperty(this, "aircraftDistanceFromStart", void 0);
      this.windObserver = new WindObserver(fmgcSide);
      this.windInputObserver = new WindForecastInputObserver(fmgc);
    }
    updateFmgcInputs() {
      this.windInputObserver.update();
    }
    updateAircraftDistanceFromStart(distanceFromStart) {
      this.aircraftDistanceFromStart = distanceFromStart;
    }
    getClimbWinds() {
      return new ClimbWindProfile(this.windInputObserver.get(), this.windObserver, this.aircraftDistanceFromStart);
    }
    getCruiseWinds() {
      return new CruiseWindProfile(this.windInputObserver.get(), this.windObserver, this.aircraftDistanceFromStart);
    }
    getDescentWinds() {
      return new DescentWindProfile(this.windInputObserver.get(), this.windObserver, this.aircraftDistanceFromStart);
    }
  }

  class AtmosphericConditions {
    constructor(observer) {
      this.observer = observer;
      _defineProperty(this, "ambientTemperatureFromSim", void 0);
      _defineProperty(this, "altitudeFromSim", void 0);
      _defineProperty(this, "casFromSim", void 0);
      _defineProperty(this, "tasFromSim", void 0);
      _defineProperty(this, "windSpeedFromSim", void 0);
      _defineProperty(this, "windDirectionFromSim", void 0);
      _defineProperty(this, "computedIsaDeviation", void 0);
      _defineProperty(this, "pressureAltFromSim", void 0);
      this.update();
    }

    // TODO: Surely some of these things should come from the ADRs
    update() {
      this.ambientTemperatureFromSim = SimVar.GetSimVarValue('AMBIENT TEMPERATURE', 'celsius');
      this.altitudeFromSim = SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet');
      this.tasFromSim = SimVar.GetSimVarValue('AIRSPEED TRUE', 'knots');
      this.casFromSim = SimVar.GetSimVarValue('AIRSPEED INDICATED', 'knots');
      // TODO filter?
      this.windSpeedFromSim = SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', 'Knots');
      this.windDirectionFromSim = SimVar.GetSimVarValue('AMBIENT WIND DIRECTION', 'Degrees');
      // This is what the AP uses
      this.pressureAltFromSim = SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet');
      this.computedIsaDeviation = this.ambientTemperatureFromSim - Common.getIsaTemp(this.altitudeFromSim);
    }
    get currentStaticAirTemperature() {
      return this.ambientTemperatureFromSim;
    }
    get currentAltitude() {
      return this.altitudeFromSim;
    }
    get currentAirspeed() {
      return this.casFromSim;
    }
    get currentTrueAirspeed() {
      return this.tasFromSim;
    }
    get currentWindSpeed() {
      return this.windSpeedFromSim;
    }
    get currentWindDirection() {
      return this.windDirectionFromSim;
    }
    get currentPressureAltitude() {
      return this.pressureAltFromSim;
    }
    getCurrentWindVelocityComponent(direction) {
      return Math.cos(Avionics.Utils.diffAngle(direction, this.currentWindDirection)) * this.currentWindSpeed;
    }
    get isaDeviation() {
      return this.computedIsaDeviation;
    }
    get tropoPause() {
      return this.observer.get().tropoPause;
    }
    predictStaticAirTemperatureAtAltitude(altitude) {
      return Common.getIsaTemp(altitude, altitude > this.tropoPause) + this.isaDeviation;
    }
    totalAirTemperatureFromMach(altitude, mach) {
      // From https://en.wikipedia.org/wiki/Total_air_temperature, using gamma = 1.4
      return (this.predictStaticAirTemperatureAtAltitude(altitude) + 273.15) * (1 + 0.2 * mach ** 2) - 273.15;
    }
    computeMachFromCas(altitude, speed) {
      const delta = Common.getDelta(altitude, altitude > this.tropoPause);
      return Common.CAStoMach(speed, delta);
    }
    computeCasFromMach(altitude, mach) {
      const delta = Common.getDelta(altitude, altitude > this.tropoPause);
      return Common.machToCas(mach, delta);
    }
    computeCasFromTas(altitude, speed) {
      const theta = Common.getTheta(altitude, this.isaDeviation, altitude > this.tropoPause);
      const delta = Common.getDelta(altitude, altitude > this.tropoPause);
      return Common.TAStoCAS(speed, theta, delta);
    }
    computeTasFromCas(altitude, speed) {
      const theta = Common.getTheta(altitude, this.isaDeviation, altitude > this.tropoPause);
      const delta = Common.getDelta(altitude, altitude > this.tropoPause);
      return Common.CAStoTAS(speed, theta, delta);
    }

    /**
     * Returns a Mach number if the CAS is taken above crossover altitude.
     * @param cas The corrected airspeed
     * @param mach The Mach number which will be used if it is lower than the Mach number corresponding ot `cas`.
     * @param altitude The altitude at which to perform the conversion
     * @returns
     */
    casOrMach(cas, mach, altitude) {
      const machAsIas = this.computeCasFromMach(altitude, mach);
      if (cas > machAsIas) {
        return mach;
      }
      return cas;
    }
  }

  class GuidanceConstants {}
  _defineProperty(GuidanceConstants, "k2", 0.0045);
  /**
   * TKAE threshold for exiting a forced turn state
   */
  _defineProperty(GuidanceConstants, "FORCED_TURN_TKAE_THRESHOLD", 150);

  /**
   * Represents the current turn state of the LNAV driver
   */
  let LnavTurnState = /*#__PURE__*/function (LnavTurnState) {
    LnavTurnState[LnavTurnState["Normal"] = 0] = "Normal";
    LnavTurnState[LnavTurnState["ForceLeftTurn"] = 1] = "ForceLeftTurn";
    LnavTurnState[LnavTurnState["ForceRightTurn"] = 2] = "ForceRightTurn";
    return LnavTurnState;
  }({});
  class LnavDriver {
    constructor(guidanceController) {
      _defineProperty(this, "guidanceController", void 0);
      _defineProperty(this, "lastAvail", void 0);
      _defineProperty(this, "lastLaw", void 0);
      _defineProperty(this, "lastXTE", void 0);
      _defineProperty(this, "lastTAE", void 0);
      _defineProperty(this, "lastPhi", void 0);
      _defineProperty(this, "turnState", LnavTurnState.Normal);
      _defineProperty(this, "ppos", new LatLongAlt());
      _defineProperty(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
      this.guidanceController = guidanceController;
      this.lastAvail = null;
      this.lastLaw = null;
      this.lastXTE = null;
      this.lastTAE = null;
      this.lastPhi = null;
    }
    init() {
      console.log('[FMGC/Guidance] LnavDriver initialized!');
    }
    update(_) {
      let available = false;
      this.ppos.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      this.ppos.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      const geometry = this.guidanceController.activeGeometry;
      const activeLegIdx = this.guidanceController.activeLegIndex;
      if (geometry && geometry.legs.size > 0) {
        const dtg = geometry.getDistanceToGo(this.guidanceController.activeLegIndex, this.ppos);
        const inboundTrans = geometry.transitions.get(activeLegIdx - 1);
        const activeLeg = geometry.legs.get(activeLegIdx);
        const outboundTrans = geometry.transitions.get(activeLegIdx) ? geometry.transitions.get(activeLegIdx) : null;
        if (!activeLeg) {
          return;
        }
        let completeDisplayLegPathDtg;
        if (inboundTrans instanceof FixedRadiusTransition && !inboundTrans.isNull) {
          if (inboundTrans.isAbeam(this.ppos)) {
            const inboundHalfDistance = inboundTrans.distance / 2;
            const inboundDtg = inboundTrans.getDistanceToGo(this.ppos);
            if (inboundDtg > inboundHalfDistance) {
              completeDisplayLegPathDtg = inboundDtg - inboundHalfDistance;
            }
          }
        }
        const completeLegPathDtg = Geometry.completeLegPathDistanceToGo(this.ppos, activeLeg, inboundTrans, outboundTrans);
        this.guidanceController.activeLegDtg = dtg;
        this.guidanceController.activeLegCompleteLegPathDtg = completeLegPathDtg;
        this.guidanceController.displayActiveLegCompleteLegPathDtg = completeDisplayLegPathDtg;

        // Update activeTransIndex in GuidanceController
        if (inboundTrans && inboundTrans.isAbeam(this.ppos)) {
          this.guidanceController.activeTransIndex = activeLegIdx - 1;
        } else if (outboundTrans && outboundTrans.isAbeam(this.ppos)) {
          this.guidanceController.activeTransIndex = activeLegIdx;
        } else {
          this.guidanceController.activeTransIndex = -1;
        }

        // Pseudo waypoint sequencing

        // FIXME when we have a path model, we don't have to do any of this business ?
        // FIXME see PseudoWaypoints.ts:153 for why we also allow the previous leg
        const pseudoWaypointsOnActiveLeg = this.guidanceController.currentPseudoWaypoints.filter(it => it.alongLegIndex === activeLegIdx || it.alongLegIndex === activeLegIdx - 1);
        for (const pseudoWaypoint of pseudoWaypointsOnActiveLeg) {
          // FIXME as with the hack above, we use the dtg to the intermediate point of the transition instead of
          // completeLegPathDtg, since we are pretending the previous leg is still active
          let dtgToUse;
          if (inboundTrans instanceof FixedRadiusTransition && pseudoWaypoint.alongLegIndex === activeLegIdx - 1) {
            const inboundHalfDistance = inboundTrans.distance / 2;
            const inboundDtg = inboundTrans.getDistanceToGo(this.ppos);
            if (inboundDtg > inboundHalfDistance) {
              dtgToUse = inboundDtg - inboundHalfDistance;
            } else {
              dtgToUse = completeLegPathDtg;
            }
          } else {
            dtgToUse = completeLegPathDtg;
          }
          if (pseudoWaypoint.distanceFromLegTermination >= dtgToUse) {
            this.guidanceController.sequencePseudoWaypoint(pseudoWaypoint);
          }
        }

        // Leg sequencing

        // TODO FIXME: Use FM position

        const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');

        // this is not the correct groundspeed to use, but it will suffice for now
        const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', 'Knots');
        const gs = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');
        const params = geometry.getGuidanceParameters(activeLegIdx, this.ppos, trueTrack, gs, tas);
        if (params) {
          var _params$phiLimit;
          if (this.lastLaw !== params.law) {
            this.lastLaw = params.law;
            SimVar.SetSimVarValue('L:A32NX_FG_CURRENT_LATERAL_LAW', 'number', params.law);
          }

          // Send bank limit to FG
          const bankLimit = (_params$phiLimit = params === null || params === void 0 ? void 0 : params.phiLimit) !== null && _params$phiLimit !== void 0 ? _params$phiLimit : maxBank(tas, false);
          SimVar.SetSimVarValue('L:A32NX_FG_PHI_LIMIT', 'Degrees', bankLimit);
          switch (params.law) {
            case ControlLaw.LATERAL_PATH:
              let {
                crossTrackError,
                trackAngleError,
                phiCommand
              } = params;

              // Update and take into account turn state; only guide using phi during a forced turn

              if (this.turnState !== LnavTurnState.Normal) {
                if (Math.abs(trackAngleError) < GuidanceConstants.FORCED_TURN_TKAE_THRESHOLD) {
                  // Stop forcing turn
                  this.turnState = LnavTurnState.Normal;
                }
                const forcedTurnPhi = this.turnState === LnavTurnState.ForceLeftTurn ? -maxBank(tas, true) : maxBank(tas, true);
                crossTrackError = 0;
                trackAngleError = 0;
                phiCommand = forcedTurnPhi;
              }

              // Set FG inputs

              if (!this.lastAvail) {
                SimVar.SetSimVarValue('L:A32NX_FG_AVAIL', 'Bool', true);
                this.lastAvail = true;
              }
              if (crossTrackError !== this.lastXTE) {
                SimVar.SetSimVarValue('L:A32NX_FG_CROSS_TRACK_ERROR', 'nautical miles', crossTrackError);
                this.lastXTE = crossTrackError;
              }
              if (trackAngleError !== this.lastTAE) {
                SimVar.SetSimVarValue('L:A32NX_FG_TRACK_ANGLE_ERROR', 'degree', trackAngleError);
                this.lastTAE = trackAngleError;
              }
              if (phiCommand !== this.lastPhi) {
                SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', phiCommand);
                this.lastPhi = phiCommand;
              }
              break;
            case ControlLaw.HEADING:
              const {
                heading,
                phiCommand: forcedPhiHeading
              } = params;
              if (!this.lastAvail) {
                SimVar.SetSimVarValue('L:A32NX_FG_AVAIL', 'Bool', true);
                this.lastAvail = true;
              }
              if (this.lastXTE !== 0) {
                SimVar.SetSimVarValue('L:A32NX_FG_CROSS_TRACK_ERROR', 'nautical miles', 0);
                this.lastXTE = 0;
              }

              // Track Angle Error
              const currentHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'Degrees');
              const deltaHeading = MathUtils$1.diffAngle(currentHeading, heading);

              // Update and take into account turn state; only guide using phi during a forced turn

              if (this.turnState !== LnavTurnState.Normal) {
                if (Math.abs(deltaHeading) < GuidanceConstants.FORCED_TURN_TKAE_THRESHOLD) {
                  // Stop forcing turn
                  this.turnState = LnavTurnState.Normal;
                }
                const forcedTurnPhi = this.turnState === LnavTurnState.ForceLeftTurn ? -maxBank(tas, true) : maxBank(tas, true);
                if (forcedTurnPhi !== this.lastPhi) {
                  SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', forcedTurnPhi);
                  this.lastPhi = forcedTurnPhi;
                }
                if (this.lastTAE !== 0) {
                  SimVar.SetSimVarValue('L:A32NX_FG_TRACK_ANGLE_ERROR', 'degree', 0);
                  this.lastTAE = 0;
                }
              } else {
                if (deltaHeading !== this.lastTAE) {
                  SimVar.SetSimVarValue('L:A32NX_FG_TRACK_ANGLE_ERROR', 'degree', deltaHeading);
                  this.lastTAE = deltaHeading;
                }
                if (forcedPhiHeading !== undefined) {
                  if (forcedPhiHeading !== this.lastPhi) {
                    SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', forcedPhiHeading);
                    this.lastPhi = forcedPhiHeading;
                  }
                } else if (this.lastPhi !== 0) {
                  SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', 0);
                  this.lastPhi = 0;
                }
              }
              break;
            case ControlLaw.TRACK:
              const {
                course,
                phiCommand: forcedPhiCourse
              } = params;
              if (!this.lastAvail) {
                SimVar.SetSimVarValue('L:A32NX_FG_AVAIL', 'Bool', true);
                this.lastAvail = true;
              }
              if (this.lastXTE !== 0) {
                SimVar.SetSimVarValue('L:A32NX_FG_CROSS_TRACK_ERROR', 'nautical miles', 0);
                this.lastXTE = 0;
              }
              const deltaCourse = MathUtils$1.diffAngle(trueTrack, course);
              if (this.turnState !== LnavTurnState.Normal) {
                if (Math.abs(deltaCourse) < GuidanceConstants.FORCED_TURN_TKAE_THRESHOLD) {
                  // Stop forcing turn
                  this.turnState = LnavTurnState.Normal;
                }
                const forcedTurnPhi = this.turnState === LnavTurnState.ForceLeftTurn ? -maxBank(tas, true) : maxBank(tas, true);
                if (forcedTurnPhi !== this.lastPhi) {
                  SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', forcedTurnPhi);
                  this.lastPhi = forcedTurnPhi;
                }
                if (this.lastTAE !== 0) {
                  SimVar.SetSimVarValue('L:A32NX_FG_TRACK_ANGLE_ERROR', 'degree', 0);
                  this.lastTAE = 0;
                }
              } else {
                if (deltaCourse !== this.lastTAE) {
                  SimVar.SetSimVarValue('L:A32NX_FG_TRACK_ANGLE_ERROR', 'degree', deltaCourse);
                  this.lastTAE = deltaCourse;
                }
                if (forcedPhiCourse !== undefined) {
                  if (forcedPhiCourse !== this.lastPhi) {
                    SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', forcedPhiCourse);
                    this.lastPhi = forcedPhiCourse;
                  }
                } else if (this.lastPhi !== 0) {
                  SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', 0);
                  this.lastPhi = 0;
                }
              }
              break;
          }
          available = true;
        }
        SimVar.SetSimVarValue('L:A32NX_GPS_WP_DISTANCE', 'nautical miles', dtg !== null && dtg !== void 0 ? dtg : 0);

        // Update EFIS active waypoint info

        this.updateEfisData(activeLeg, gs);

        // Sequencing

        const flightPhase = SimVar.GetSimVarValue('L:A32NX_FMGC_FLIGHT_PHASE', 'Enum');
        const canSequence = !activeLeg.disableAutomaticSequencing && flightPhase >= FmgcFlightPhase.Takeoff;
        let withinSequencingArea = true;
        if (params.law === ControlLaw.LATERAL_PATH) {
          withinSequencingArea = Math.abs(params.crossTrackError) < 7 && Math.abs(params.trackAngleError) < 90;
        }
        if (canSequence && withinSequencingArea && geometry.shouldSequenceLeg(activeLegIdx, this.ppos) || activeLeg.isNull) {
          const outboundTransition = geometry.transitions.get(activeLegIdx);
          const nextLeg = geometry.legs.get(activeLegIdx + 1);
          const followingLeg = geometry.legs.get(activeLegIdx + 2);
          if (nextLeg) {
            // FIXME we should stop relying on discos in the wpt objects, but for now it's fiiiiiine
            // Hard-coded check for TF leg after the disco for now - only case where we don't wanna
            // sequence this way is VM
            if (activeLeg instanceof XFLeg && activeLeg.fix.endsInDiscontinuity) {
              this.sequenceDiscontinuity(activeLeg);
            } else {
              this.sequenceLeg(activeLeg, outboundTransition);
            }
            geometry.onLegSequenced(activeLeg, nextLeg, followingLeg);
          } else {
            this.sequenceDiscontinuity(activeLeg);
            geometry.onLegSequenced(activeLeg, nextLeg, followingLeg);
          }
        }
      }

      /* Set FG parameters */

      if (!available && this.lastAvail !== false) {
        SimVar.SetSimVarValue('L:A32NX_FG_AVAIL', 'Bool', false);
        SimVar.SetSimVarValue('L:A32NX_FG_CROSS_TRACK_ERROR', 'nautical miles', 0);
        SimVar.SetSimVarValue('L:A32NX_FG_TRACK_ANGLE_ERROR', 'degree', 0);
        SimVar.SetSimVarValue('L:A32NX_FG_PHI_COMMAND', 'degree', 0);
        this.lastAvail = false;
        this.lastTAE = null;
        this.lastXTE = null;
        this.lastPhi = null;
        this.turnState = LnavTurnState.Normal;
      }
    }

    /**
     * Updates the EFIS TO WPT data
     *
     * @param activeLeg currently active display leg
     * @param gs        current ground speed in knots
     *
     * @private
     */
    updateEfisData(activeLeg, gs) {
      const termination = activeLeg instanceof XFLeg ? activeLeg.fix.infos.coordinates : activeLeg.getPathEndPoint();
      const efisTrueBearing = termination ? Avionics.Utils.computeGreatCircleHeading(this.ppos, termination) : -1;
      const efisBearing = termination ? A32NX_Util.trueToMagnetic(efisTrueBearing, Facilities.getMagVar(this.ppos.lat, this.ppos.long)) : -1;

      // Don't compute distance and ETA for XM legs
      const efisDistance = activeLeg instanceof VMLeg ? -1 : Avionics.Utils.computeGreatCircleDistance(this.ppos, termination);
      const efisEta = activeLeg instanceof VMLeg ? -1 : LnavDriver.legEta(this.ppos, gs, termination);

      // FIXME should be NCD if no FM position

      SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_BEARING', 'Degrees', efisBearing);
      SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_TRUE_BEARING', 'Degrees', efisTrueBearing);
      SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_DISTANCE', 'Number', efisDistance);
      SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_ETA', 'Seconds', efisEta);
      SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_BEARING', 'Degrees', efisBearing);
      SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_TRUE_BEARING', 'Degrees', efisTrueBearing);
      SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_DISTANCE', 'Number', efisDistance);
      SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_ETA', 'Seconds', efisEta);
    }
    static legEta(ppos, gs, termination) {
      // FIXME use a more accurate estimate, calculate in predictions

      const UTC_SECONDS = Math.floor(SimVar.GetGlobalVarValue('ZULU TIME', 'seconds'));
      const nauticalMilesToGo = Avionics.Utils.computeGreatCircleDistance(ppos, termination);
      const secondsToGo = nauticalMilesToGo / Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, gs) * 3600;
      const eta = (UTC_SECONDS + secondsToGo) % (3600 * 24);
      return eta;
    }
    sequenceLeg(_leg, outboundTransition) {
      let wpIndex = this.guidanceController.flightPlanManager.getActiveWaypointIndex(false, false, 0);
      const wp = this.guidanceController.flightPlanManager.getActiveWaypoint(false, false, 0);
      console.log("[FMGC/Guidance] LNAV - sequencing leg. [WP: ".concat(wp.ident, " Active WP Index: ").concat(wpIndex, "]"));
      wp.waypointReachedAt = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds');
      this.guidanceController.flightPlanManager.setActiveWaypointIndex(++wpIndex, () => {}, 0);
      outboundTransition === null || outboundTransition === void 0 ? void 0 : outboundTransition.freeze();

      // Set turn state based on turn direction
      if (outboundTransition && (outboundTransition instanceof PathCaptureTransition || outboundTransition instanceof CourseCaptureTransition)) {
        if (outboundTransition.turnDirection === TurnDirection.Left) {
          this.turnState = LnavTurnState.ForceLeftTurn;
        } else if (outboundTransition.turnDirection === TurnDirection.Right) {
          this.turnState = LnavTurnState.ForceRightTurn;
        } else {
          // Just to be safe
          this.turnState = LnavTurnState.Normal;
        }
      } else {
        this.turnState = LnavTurnState.Normal;
      }
    }
    sequenceDiscontinuity(_leg) {
      console.log('[FMGC/Guidance] LNAV - sequencing discontinuity');

      // Lateral mode is NAV
      const lateralModel = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Enum');
      const verticalMode = SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
      let reverted = false;
      if (lateralModel === LateralMode.NAV) {
        // Set HDG (current heading)
        SimVar.SetSimVarValue('H:A320_Neo_FCU_HDG_PULL', 'number', 0);
        SimVar.SetSimVarValue('L:A32NX_FM_HEADING_SYNC', 'boolean', true);
        reverted = true;
      }
      if (verticalMode === VerticalMode.DES) {
        // revert to V/S
        SimVar.SetSimVarValue('H:A320_Neo_FCU_VS_PULL', 'number', 0);
        reverted = true;
      } else if (verticalMode === VerticalMode.CLB) {
        // revert to OP CLB
        SimVar.SetSimVarValue('H:A320_Neo_FCU_ALT_PULL', 'number', 0);
        reverted = true;
      }
      if (reverted) {
        // Triple click
        Coherent.call('PLAY_INSTRUMENT_SOUND', '3click').catch(console.error);
      }
      this.sequenceLeg(_leg, null);
    }
    sequenceManual(_leg) {
      console.log('[FMGC/Guidance] LNAV - sequencing MANUAL');
    }
  }

  /**
   * This entire class essentially represents an interface to the flightplan.
   */
  class ConstraintReader {
    get distanceToPresentPosition() {
      return this.totalFlightPlanDistance - this.distanceToEnd;
    }
    constructor(guidanceController) {
      this.guidanceController = guidanceController;
      _defineProperty(this, "climbAlitudeConstraints", []);
      _defineProperty(this, "descentAltitudeConstraints", []);
      _defineProperty(this, "climbSpeedConstraints", []);
      _defineProperty(this, "descentSpeedConstraints", []);
      _defineProperty(this, "cruiseSteps", []);
      _defineProperty(this, "totalFlightPlanDistance", 0);
      _defineProperty(this, "distanceToEnd", 0);
      // If you change this property here, make sure you also reset it properly in `reset`
      _defineProperty(this, "finalDescentAngle", -3);
      // If you change this property here, make sure you also reset it properly in `reset`
      _defineProperty(this, "fafDistanceToEnd", 1000 / Math.tan(-this.finalDescentAngle * MathUtils$1.DEGREES_TO_RADIANS) / 6076.12);
      _defineProperty(this, "finalAltitude", 50);
      this.reset();
    }
    updateGeometry(geometry, ppos) {
      this.reset();
      this.updateDistancesToEnd(geometry);
      const fpm = this.guidanceController.flightPlanManager;
      let maxSpeed = Infinity;
      for (let i = 0; i < fpm.getWaypointsCount(FlightPlans.Active); i++) {
        const waypoint = fpm.getWaypoint(i, FlightPlans.Active);
        if (waypoint.additionalData.cruiseStep && !waypoint.additionalData.cruiseStep.isIgnored) {
          if (i >= fpm.getActiveWaypointIndex()) {
            const {
              waypointIndex,
              toAltitude,
              distanceBeforeTermination
            } = waypoint.additionalData.cruiseStep;
            this.cruiseSteps.push({
              distanceFromStart: this.totalFlightPlanDistance - waypoint.additionalData.distanceToEnd - distanceBeforeTermination,
              toAltitude,
              waypointIndex,
              isIgnored: false
            });
          } else {
            // We've already passed the waypoint
            waypoint.additionalData.cruiseStep = undefined;
            SimVar.SetSimVarValue('L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED', 'boolean', true);
          }
        }
        const altConstraint = getAltitudeConstraintFromWaypoint(waypoint);
        const speedConstraint = getSpeedConstraintFromWaypoint(waypoint);
        const pathAngleConstraint = getPathAngleConstraintFromWaypoint(waypoint);
        if (waypoint.additionalData.constraintType === WaypointConstraintType$1.CLB) {
          if (altConstraint && altConstraint.type !== AltitudeConstraintType.atOrAbove) {
            this.climbAlitudeConstraints.push({
              distanceFromStart: this.totalFlightPlanDistance - waypoint.additionalData.distanceToEnd,
              maxAltitude: altConstraint.altitude1
            });
          }
          if (speedConstraint && waypoint.speedConstraint > 100) {
            this.climbSpeedConstraints.push({
              distanceFromStart: this.totalFlightPlanDistance - waypoint.additionalData.distanceToEnd,
              maxSpeed: speedConstraint.speed
            });
          }
        } else if (waypoint.additionalData.constraintType === WaypointConstraintType$1.DES) {
          if (altConstraint) {
            this.descentAltitudeConstraints.push({
              distanceFromStart: this.totalFlightPlanDistance - waypoint.additionalData.distanceToEnd,
              constraint: altConstraint
            });
          }
          if (speedConstraint && waypoint.speedConstraint > 100) {
            maxSpeed = Math.min(maxSpeed, speedConstraint.speed);
            this.descentSpeedConstraints.push({
              distanceFromStart: this.totalFlightPlanDistance - waypoint.additionalData.distanceToEnd,
              maxSpeed
            });
          }
        }
        if (i === fpm.getDestinationIndex() && pathAngleConstraint) {
          this.finalDescentAngle = pathAngleConstraint;
        }
        if ((waypoint.additionalData.fixTypeFlags & FixTypeFlags$1.FAF) > 0) {
          this.fafDistanceToEnd = waypoint.additionalData.distanceToEnd;
        }
      }
      this.updateFinalAltitude();
      this.updateDistanceToEnd(ppos);
    }
    updateDistanceToEnd(ppos) {
      const geometry = this.guidanceController.activeGeometry;
      const activeLegIndex = this.guidanceController.activeLegIndex;
      const activeTransIndex = this.guidanceController.activeTransIndex;
      const fpm = this.guidanceController.flightPlanManager;
      const leg = geometry.legs.get(activeLegIndex);
      if (!leg || leg.isNull) {
        return;
      }
      const nextWaypoint = leg instanceof VMLeg ? fpm.getWaypoint(activeLegIndex + 1, FlightPlans.Active) : fpm.getWaypoint(activeLegIndex, FlightPlans.Active);
      const inboundTransition = geometry.transitions.get(activeLegIndex - 1);
      const outboundTransition = geometry.transitions.get(activeLegIndex);
      const [_, legDistance, outboundLength] = Geometry.completeLegPathLengths(leg, inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull || !(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isComputed) ? null : inboundTransition, outboundTransition);
      if (activeTransIndex === activeLegIndex) {
        var _nextWaypoint$additio, _nextWaypoint$additio2;
        // On an outbound transition
        // We subtract `outboundLength` because getDistanceToGo will include the entire distance while we only want the part that's on this leg.
        // For a FixedRadiusTransition, there's also a part on the next leg.
        this.distanceToEnd = outboundTransition.getDistanceToGo(ppos) - outboundLength + ((_nextWaypoint$additio = nextWaypoint === null || nextWaypoint === void 0 ? void 0 : (_nextWaypoint$additio2 = nextWaypoint.additionalData) === null || _nextWaypoint$additio2 === void 0 ? void 0 : _nextWaypoint$additio2.distanceToEnd) !== null && _nextWaypoint$additio !== void 0 ? _nextWaypoint$additio : 0);
      } else if (activeTransIndex === activeLegIndex - 1) {
        var _nextWaypoint$additio3, _nextWaypoint$additio4;
        // On an inbound transition
        const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
        let transitionDistanceToGo = inboundTransition.getDistanceToGo(ppos);
        if (inboundTransition instanceof PathCaptureTransition) {
          transitionDistanceToGo = inboundTransition.getActualDistanceToGo(ppos, trueTrack);
        } else if (inboundTransition instanceof FixedRadiusTransition && inboundTransition.isReverted) {
          transitionDistanceToGo = inboundTransition.revertTo.getActualDistanceToGo(ppos, trueTrack);
        }
        this.distanceToEnd = transitionDistanceToGo + legDistance + outboundLength + ((_nextWaypoint$additio3 = nextWaypoint === null || nextWaypoint === void 0 ? void 0 : (_nextWaypoint$additio4 = nextWaypoint.additionalData) === null || _nextWaypoint$additio4 === void 0 ? void 0 : _nextWaypoint$additio4.distanceToEnd) !== null && _nextWaypoint$additio3 !== void 0 ? _nextWaypoint$additio3 : 0);
      } else {
        var _nextWaypoint$infos, _nextWaypoint$additio5, _nextWaypoint$additio6;
        const distanceToGo = leg instanceof VMLeg || leg instanceof IFLeg ? Avionics.Utils.computeGreatCircleDistance(ppos, nextWaypoint === null || nextWaypoint === void 0 ? void 0 : (_nextWaypoint$infos = nextWaypoint.infos) === null || _nextWaypoint$infos === void 0 ? void 0 : _nextWaypoint$infos.coordinates) : leg.getDistanceToGo(ppos);
        this.distanceToEnd = distanceToGo + outboundLength + ((_nextWaypoint$additio5 = nextWaypoint === null || nextWaypoint === void 0 ? void 0 : (_nextWaypoint$additio6 = nextWaypoint.additionalData) === null || _nextWaypoint$additio6 === void 0 ? void 0 : _nextWaypoint$additio6.distanceToEnd) !== null && _nextWaypoint$additio5 !== void 0 ? _nextWaypoint$additio5 : 0);
      }
    }
    updateFinalAltitude() {
      const metersToFeet = 3.2808399;
      const fpm = this.guidanceController.flightPlanManager;
      const approach = fpm.getApproach();

      // Check if we have a procedure loaded from which we can extract the final altitude
      if (approach && approach.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN) {
        for (const leg of approach.finalLegs) {
          if (leg.fixTypeFlags & FixTypeFlags$1.MAP && Number.isFinite(leg.altitude1)) {
            this.finalAltitude = leg.altitude1 * metersToFeet;
            return;
          }
        }
      }

      // Check if we only have a runway loaded. In this case, take the threshold elevation.
      const runway = fpm.getDestinationRunway();
      if (runway && Number.isFinite(runway.thresholdElevation)) {
        this.finalAltitude = runway.thresholdElevation * metersToFeet + 50;
        return;
      }

      // Check if we only have a destination airport loaded. In this case, take the airport elevation.
      const destinationAirport = fpm.getDestination();
      // TODO: I think selecting an approach and then deleting it will cause destinationAirport.infos.coordinates.alt to be zero.
      if (destinationAirport && Number.isFinite(destinationAirport.infos.coordinates.alt)) {
        this.finalAltitude = destinationAirport.infos.coordinates.alt + 50;
        return;
      }

      // Last resort. Not sure how we'd get here.
      // If I do change this, I should probably change it in the reset() function.
      this.finalAltitude = 50;
    }
    reset() {
      this.climbAlitudeConstraints = [];
      this.descentAltitudeConstraints = [];
      this.climbSpeedConstraints = [];
      this.descentSpeedConstraints = [];
      this.cruiseSteps = [];
      this.totalFlightPlanDistance = 0;
      this.distanceToEnd = 0;
      this.finalDescentAngle = -3;
      this.fafDistanceToEnd = 1000 / Math.tan(-this.finalDescentAngle * MathUtils$1.DEGREES_TO_RADIANS) / 6076.12;
      this.finalAltitude = 50;
    }
    updateDistancesToEnd(geometry) {
      const {
        legs,
        transitions
      } = geometry;
      const fpm = this.guidanceController.flightPlanManager;
      this.totalFlightPlanDistance = 0;
      for (let i = fpm.getWaypointsCount(FlightPlans.Active) - 1; i >= fpm.getActiveWaypointIndex() - 1 && i >= 0; i--) {
        const leg = legs.get(i);
        const waypoint = fpm.getWaypoint(i, FlightPlans.Active);
        const nextWaypoint = fpm.getWaypoint(i + 1, FlightPlans.Active);
        if (waypoint.endsInDiscontinuity) {
          const startingPointOfDisco = waypoint.discontinuityCanBeCleared ? waypoint : fpm.getWaypoint(i - 1, FlightPlans.Active); // MANUAL

          this.totalFlightPlanDistance += Avionics.Utils.computeGreatCircleDistance(startingPointOfDisco.infos.coordinates, nextWaypoint.infos.coordinates);
        }
        waypoint.additionalData.distanceToEnd = this.totalFlightPlanDistance;
        if (!leg || leg.isNull) {
          continue;
        }
        const inboundTransition = transitions.get(i - 1);
        const outboundTransition = transitions.get(i);
        const [inboundLength, legDistance, outboundLength] = Geometry.completeLegPathLengths(leg, inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull || !(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isComputed) ? null : inboundTransition, outboundTransition);
        const correctedInboundLength = Number.isNaN(inboundLength) ? 0 : inboundLength;
        const totalLegLength = legDistance + correctedInboundLength + outboundLength;
        this.totalFlightPlanDistance += totalLegLength;
      }
    }
    ignoreCruiseStep(waypointIndex) {
      var _waypoint$additionalD;
      const waypoint = this.guidanceController.flightPlanManager.getWaypoint(waypointIndex, FlightPlans.Active);
      if (waypoint !== null && waypoint !== void 0 && (_waypoint$additionalD = waypoint.additionalData) !== null && _waypoint$additionalD !== void 0 && _waypoint$additionalD.cruiseStep) {
        waypoint.additionalData.cruiseStep.isIgnored = true;
      }
    }
  }

  /**
   * NotificationParams container for popups to package popup metadata
   */

  /**
   * PopUp utility class to create a pop-up UI element
   *
   * Usage:
   * import { PopUp } from '@shared/popup';
   * ...
   * const popup = new PopUp();
   * popup.showPopUp("CRITICAL SETTING CHANGED", "Your message here", "small", yesFunc, noFunc);
   * popup.showInformation("CRITICAL MESSAGE", "Your message here", "small", yesFunc);
   */
  class PopUpDialog {
    /**
     * Creates a Popup
     */
    constructor() {
      _defineProperty(this, "params", void 0);
      _defineProperty(this, "popupListener", void 0);
      const title = 'A32NX POPUP';
      const time = new Date().getTime();
      this.popupListener = undefined;
      this.params = {
        __Type: 'SNotificationParams',
        buttons: [new NotificationButton('TT:MENU.YES', "A32NX_POP_".concat(title, "_").concat(time, "_YES")), new NotificationButton('TT:MENU.NO', "A32NX_POP_".concat(title, "_").concat(time, "_NO"))],
        style: 'normal',
        displayGlobalPopup: true,
        contentData: 'Default Message',
        contentUrl: '',
        // i.e. "/templates/Controls/PopUp_EditPreset/PopUp_EditPreset.html";
        contentTemplate: '',
        // i.e. "popup-edit-preset";
        id: "".concat(title, "_").concat(time),
        title,
        time
      };
    }

    /**
     * Pass Popup display data to Coherent
     * @param params
     */
    /* eslint-disable no-underscore-dangle */
    _showPopUp() {
      let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Coherent.trigger('SHOW_POP_UP', params);
    }

    /**
     * Show popup with given or already initiated parameters
     * @param {string} title Title for popup - will show in menu bar
     * @param {string} message Popup message
     * @param {string} style Style/Type of popup. Valid types are small|normal|big|big-help
     * @param {function} callbackYes Callback function -> YES button is clicked.
     * @param {function} callbackNo Callback function -> NO button is clicked.
     */
    showPopUp(title, message, style, callbackYes, callbackNo) {
      if (title) {
        this.params.title = title;
      }
      if (message) {
        this.params.contentData = message;
      }
      if (style) {
        this.params.style = style;
      }
      if (callbackYes) {
        const yes = typeof callbackYes === 'function' ? callbackYes : () => callbackYes;
        Coherent.on("A32NX_POP_".concat(this.params.id, "_YES"), () => {
          Coherent.off("A32NX_POP_".concat(this.params.id, "_YES"), null, null);
          yes();
        });
      }
      if (callbackNo) {
        const no = typeof callbackNo === 'function' ? callbackNo : () => callbackNo;
        Coherent.on("A32NX_POP_".concat(this.params.id, "_NO"), () => {
          Coherent.off("A32NX_POP_".concat(this.params.id, "_NO"), null, null);
          no();
        });
      }
      if (!this.popupListener) {
        this.popupListener = RegisterViewListener('JS_LISTENER_POPUP', this._showPopUp.bind(null, this.params));
      } else {
        this._showPopUp(this.params);
      }
    }

    /**
     * Show information with given or already initiated parameters
     * @param {string} title Title for popup - will show in menu bar
     * @param {string} message Popup message
     * @param {string} style Style/Type of popup. Valid types are small|normal|big|big-help
     * @param {function} callback Callback function -> OK button is clicked.
     */
    showInformation(title, message, style, callback) {
      if (title) {
        this.params.title = title;
      }
      if (message) {
        this.params.contentData = message;
      }
      if (style) {
        this.params.style = style;
      }
      if (callback) {
        const yes = typeof callback === 'function' ? callback : () => callback;
        Coherent.on("A32NX_POP_".concat(this.params.id, "_YES"), () => {
          Coherent.off("A32NX_POP_".concat(this.params.id, "_YES"), null, null);
          yes();
        });
      }
      this.params.buttons = [new NotificationButton('TT:MENU.OK', "A32NX_POP_".concat(this.params.id, "_YES"))];
      if (!this.popupListener) {
        this.popupListener = RegisterViewListener('JS_LISTENER_POPUP', this._showPopUp.bind(null, this.params));
      } else {
        this._showPopUp(this.params);
      }
    }
  }

  const TIMEOUT = 10000;
  class TodGuidance {
    constructor(aircraftToDescentProfileRelation, observer, atmosphericConditions) {
      this.aircraftToDescentProfileRelation = aircraftToDescentProfileRelation;
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
      _defineProperty(this, "tdReached", void 0);
      _defineProperty(this, "tdPaused", void 0);
      _defineProperty(this, "apEngaged", void 0);
      _defineProperty(this, "cooldown", void 0);
      this.cooldown = 0;
      this.apEngaged = false;
      this.tdReached = false;
      this.tdPaused = false;
    }
    showPausePopup(title, message) {
      this.cooldown = TIMEOUT;
      SimVar.SetSimVarValue('K:PAUSE_SET', 'number', 1);
      let popup = new PopUpDialog();
      popup.showInformation(title, message, 'small', () => {
        SimVar.SetSimVarValue('K:PAUSE_SET', 'number', 0);
        this.cooldown = TIMEOUT;
        popup = null;
      });
    }
    update(deltaTime) {
      this.updateTdReached(deltaTime);
      this.updateTdPause(deltaTime);
    }
    updateTdPause(deltaTime) {
      if (this.cooldown <= 0 && NXDataStore.get('PAUSE_AT_TOD', 'DISABLED') === 'ENABLED') {
        // Only watching if T/D pause untriggered + between flight phase CLB and CRZ
        if (!this.tdPaused && this.observer.get().flightPhase >= FmgcFlightPhase.Climb && this.observer.get().flightPhase <= FmgcFlightPhase.Cruise && Simplane.getAutoPilotAirspeedManaged()) {
          var _this$aircraftToDesce;
          // Check T/D pause first, then AP mode reversion
          if (((_this$aircraftToDesce = this.aircraftToDescentProfileRelation.distanceToTopOfDescent()) !== null && _this$aircraftToDesce !== void 0 ? _this$aircraftToDesce : Number.POSITIVE_INFINITY) < parseFloat(NXDataStore.get('PAUSE_AT_TOD_DISTANCE', '10'))) {
            this.tdPaused = true;
            this.showPausePopup('TOP OF DESCENT', "Paused before the calculated top of descent. System Time was ".concat(new Date().toLocaleTimeString(), "."));
            // Only guard AP above transitional altitude
          } else if (this.atmosphericConditions.currentAltitude ? this.atmosphericConditions.currentAltitude > this.observer.get().originTransitionAltitude : false) {
            const apActive = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_ACTIVE', 'boolean') && SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'Enum') === LateralMode.NAV;
            if (this.apEngaged && !apActive) {
              this.showPausePopup('AP PROTECTION', "Autopilot or lateral guidance disengaged before the calculated top of descent. System Time was ".concat(new Date().toLocaleTimeString(), "."));
            }
            if (this.apEngaged !== apActive) {
              this.apEngaged = apActive;
            }
          }
        }

        // Reset flags on turnaround
        if (this.observer.get().flightPhase === FmgcFlightPhase.Done || this.observer.get().flightPhase === FmgcFlightPhase.Preflight) {
          this.tdPaused = false;
          this.apEngaged = false;
        }
      }
      if (this.cooldown > 0) {
        this.cooldown = Math.max(0, this.cooldown - deltaTime);
      }
    }
    updateTdReached(_deltaTime) {
      const tdReached = this.observer.get().flightPhase >= FmgcFlightPhase.Climb && this.observer.get().flightPhase <= FmgcFlightPhase.Cruise && Simplane.getAutoPilotAirspeedManaged() && this.aircraftToDescentProfileRelation.isPastTopOfDescent();
      if (tdReached !== this.tdReached) {
        this.tdReached = tdReached;
        SimVar.SetSimVarValue('L:A32NX_PFD_MSG_TD_REACHED', 'boolean', this.tdReached);
      }
    }
  }

  class SpeedMargin {
    constructor(observer) {
      this.observer = observer;
      _defineProperty(this, "vmo", 350);
      _defineProperty(this, "mmo", 0.82);
    }
    getTarget(indicatedAirspeed, targetSpeed) {
      const [lowerMargin, upperMargin] = this.getMargins(targetSpeed);
      return Math.max(Math.min(indicatedAirspeed, upperMargin), lowerMargin);
    }
    getMargins(currentTarget) {
      const {
        managedDescentSpeed,
        managedDescentSpeedMach,
        approachSpeed
      } = this.observer.get();
      const vmax = SimVar.GetSimVarValue('L:A32NX_SPEEDS_VMAX', 'number');
      const vMan = this.getVman(approachSpeed);
      const vls = SimVar.GetSimVarValue('L:A32NX_SPEEDS_VLS', 'number');
      const vmin = Math.max(vls, vMan);
      const mmoAsIas = SimVar.GetGameVarValue('FROM MACH TO KIAS', 'number', this.mmo);
      const isMachTarget = managedDescentSpeed - SimVar.GetGameVarValue('FROM MACH TO KIAS', 'number', managedDescentSpeedMach) > 1;
      const distanceToUpperMargin = !isMachTarget && managedDescentSpeed - currentTarget > 1 ? 5 : 20;
      return [Math.max(vmin, Math.min(currentTarget - 20, vmax, this.vmo - 3, mmoAsIas - 0.006)), Math.max(vmin, Math.min(vmax, this.vmo - 3, mmoAsIas - 0.006, currentTarget + distanceToUpperMargin))];
    }
    getVman(vApp) {
      switch (SimVar.GetSimVarValue('L:A32NX_FLAPS_HANDLE_INDEX', 'Number')) {
        case 0:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_GD', 'number');
        case 1:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_S', 'number');
        case 2:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_F', 'number');
        case 3:
        case 4:
          return vApp;
        default:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_VLS', 'number');
      }
    }
  }

  var DescentVerticalGuidanceState = /*#__PURE__*/function (DescentVerticalGuidanceState) {
    DescentVerticalGuidanceState[DescentVerticalGuidanceState["InvalidProfile"] = 0] = "InvalidProfile";
    DescentVerticalGuidanceState[DescentVerticalGuidanceState["ProvidingGuidance"] = 1] = "ProvidingGuidance";
    DescentVerticalGuidanceState[DescentVerticalGuidanceState["Observing"] = 2] = "Observing";
    return DescentVerticalGuidanceState;
  }(DescentVerticalGuidanceState || {});
  var DescentSpeedGuidanceState = /*#__PURE__*/function (DescentSpeedGuidanceState) {
    DescentSpeedGuidanceState[DescentSpeedGuidanceState["NotInDescentPhase"] = 0] = "NotInDescentPhase";
    DescentSpeedGuidanceState[DescentSpeedGuidanceState["TargetOnly"] = 1] = "TargetOnly";
    DescentSpeedGuidanceState[DescentSpeedGuidanceState["TargetAndMargins"] = 2] = "TargetAndMargins";
    return DescentSpeedGuidanceState;
  }(DescentSpeedGuidanceState || {});
  var PathCaptureState = /*#__PURE__*/function (PathCaptureState) {
    PathCaptureState[PathCaptureState["OffPath"] = 0] = "OffPath";
    PathCaptureState[PathCaptureState["OnPath"] = 1] = "OnPath";
    PathCaptureState[PathCaptureState["InPathCapture"] = 2] = "InPathCapture";
    return PathCaptureState;
  }(PathCaptureState || {});
  const VPATH_CAPTURE_PROFILE = {
    pathCaptureGain: 0.1,
    pathDisengagementGain: 0.2,
    fallbackPathCaptureDeviation: 100,
    maxOnPathDeviation: 100,
    minCaptureDeviation: 50,
    maxCaptureDeviation: 500
  };
  class DescentGuidance {
    constructor(guidanceController, aircraftToDescentProfileRelation, observer, atmosphericConditions) {
      this.guidanceController = guidanceController;
      this.aircraftToDescentProfileRelation = aircraftToDescentProfileRelation;
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
      _defineProperty(this, "verticalState", DescentVerticalGuidanceState.InvalidProfile);
      _defineProperty(this, "speedState", DescentSpeedGuidanceState.NotInDescentPhase);
      _defineProperty(this, "requestedVerticalMode", RequestedVerticalMode.None);
      _defineProperty(this, "targetAltitude", 0);
      _defineProperty(this, "targetAltitudeGuidance", 0);
      _defineProperty(this, "targetVerticalSpeed", 0);
      _defineProperty(this, "showLinearDeviationOnPfd", false);
      _defineProperty(this, "showDescentLatchOnPfd", false);
      _defineProperty(this, "speedMargin", void 0);
      _defineProperty(this, "todGuidance", void 0);
      _defineProperty(this, "speedTarget", void 0);
      // An "overspeed condition" just means we are above the speed margins, not that we are in the red band.
      // We use a boolean here for hysteresis
      _defineProperty(this, "isInOverspeedCondition", false);
      _defineProperty(this, "isInUnderspeedCondition", false);
      _defineProperty(this, "pathCaptureProfile", VPATH_CAPTURE_PROFILE);
      _defineProperty(this, "pathCaptureState", PathCaptureState.OffPath);
      this.speedMargin = new SpeedMargin(this.observer);
      this.todGuidance = new TodGuidance(this.aircraftToDescentProfileRelation, this.observer, this.atmosphericConditions);
      this.writeToSimVars();
    }
    updateProfile(profile) {
      this.aircraftToDescentProfileRelation.updateProfile(profile);
      if (!this.aircraftToDescentProfileRelation.isValid) {
        this.changeState(DescentVerticalGuidanceState.InvalidProfile);
      }
    }
    changeState(newState) {
      if (this.verticalState === newState) {
        return;
      }
      if (newState === DescentVerticalGuidanceState.InvalidProfile) {
        this.reset();
        this.writeToSimVars();
      } else if (newState === DescentVerticalGuidanceState.Observing) {
        this.pathCaptureState = PathCaptureState.OffPath;
      }
      this.verticalState = newState;
    }
    reset() {
      this.requestedVerticalMode = RequestedVerticalMode.None;
      this.targetAltitude = 0;
      this.targetVerticalSpeed = 0;
      this.showLinearDeviationOnPfd = false;
      this.showDescentLatchOnPfd = false;
      this.isInOverspeedCondition = false;
      this.pathCaptureState = PathCaptureState.OffPath;
    }
    update(deltaTime, distanceToEnd) {
      this.aircraftToDescentProfileRelation.update(distanceToEnd);
      if (!this.aircraftToDescentProfileRelation.isValid) {
        return;
      }
      if (this.observer.get().fcuVerticalMode === VerticalMode.DES !== (this.verticalState === DescentVerticalGuidanceState.ProvidingGuidance)) {
        this.changeState(this.verticalState === DescentVerticalGuidanceState.ProvidingGuidance ? DescentVerticalGuidanceState.Observing : DescentVerticalGuidanceState.ProvidingGuidance);
      }
      this.updateSpeedMarginState();
      this.updateSpeedTarget();
      this.updateSpeedGuidance();
      this.updateOverUnderspeedCondition();
      this.updateLinearDeviation();
      if (this.verticalState === DescentVerticalGuidanceState.ProvidingGuidance) {
        this.updateDesModeGuidance();
      }
      this.writeToSimVars();
      this.todGuidance.update(deltaTime);
    }
    updateLinearDeviation() {
      const {
        fcuVerticalMode,
        flightPhase
      } = this.observer.get();
      this.targetAltitude = this.aircraftToDescentProfileRelation.currentTargetAltitude();
      this.showLinearDeviationOnPfd = flightPhase < FmgcFlightPhase.GoAround && (flightPhase >= FmgcFlightPhase.Descent || this.aircraftToDescentProfileRelation.isPastTopOfDescent()) && fcuVerticalMode !== VerticalMode.GS_CPT && fcuVerticalMode !== VerticalMode.GS_TRACK && fcuVerticalMode !== VerticalMode.LAND && fcuVerticalMode !== VerticalMode.FLARE && fcuVerticalMode !== VerticalMode.ROLL_OUT;
    }
    updateDesModeGuidance() {
      const isOnGeometricPath = this.aircraftToDescentProfileRelation.isOnGeometricPath();
      const isAboveSpeedLimitAltitude = this.aircraftToDescentProfileRelation.isAboveSpeedLimitAltitude();
      const isCloseToAirfieldElevation = this.aircraftToDescentProfileRelation.isCloseToAirfieldElevation();
      const isBeforeTopOfDescent = !this.aircraftToDescentProfileRelation.isPastTopOfDescent();
      const linearDeviation = this.aircraftToDescentProfileRelation.computeLinearDeviation();
      const isSpeedAuto = Simplane.getAutoPilotAirspeedManaged();
      const isApproachPhaseActive = this.observer.get().flightPhase === FmgcFlightPhase.Approach;
      const isHoldActive = this.guidanceController.isManualHoldActive();
      const targetVerticalSpeed = this.aircraftToDescentProfileRelation.currentTargetVerticalSpeed();
      this.targetAltitudeGuidance = this.atmosphericConditions.currentPressureAltitude - linearDeviation;
      this.updatePathCaptureState(linearDeviation, targetVerticalSpeed);
      const shouldGoOffPath = this.pathCaptureState === PathCaptureState.OffPath;
      if (!isHoldActive && shouldGoOffPath && linearDeviation > 0 || this.isInOverspeedCondition) {
        // above path
        this.requestedVerticalMode = RequestedVerticalMode.SpeedThrust;
      } else if (shouldGoOffPath || isBeforeTopOfDescent || isHoldActive) {
        // below path
        if (isHoldActive) {
          this.requestedVerticalMode = RequestedVerticalMode.VsSpeed;
          this.targetVerticalSpeed = -1000;
        } else if (isOnGeometricPath) {
          this.requestedVerticalMode = RequestedVerticalMode.FpaSpeed;
          this.targetVerticalSpeed = this.aircraftToDescentProfileRelation.currentTargetPathAngle() / 2;
        } else {
          this.requestedVerticalMode = RequestedVerticalMode.VsSpeed;
          this.targetVerticalSpeed = isAboveSpeedLimitAltitude && !isCloseToAirfieldElevation ? -1000 : -500;
        }
      } else if (!isOnGeometricPath && isSpeedAuto && !this.isInUnderspeedCondition && !isApproachPhaseActive) {
        // on idle path

        this.requestedVerticalMode = RequestedVerticalMode.VpathThrust;
        this.targetVerticalSpeed = targetVerticalSpeed;
      } else {
        // on geometric path

        this.requestedVerticalMode = RequestedVerticalMode.VpathSpeed;
        this.targetVerticalSpeed = targetVerticalSpeed;
      }
    }
    updatePathCaptureState(linearDeviation, targetVerticalSpeed) {
      const allowPathCapture = this.isPathCaptureConditionMet(linearDeviation, targetVerticalSpeed, this.pathCaptureProfile.pathCaptureGain);
      switch (this.pathCaptureState) {
        case PathCaptureState.OffPath:
          if (allowPathCapture) {
            this.pathCaptureState = PathCaptureState.InPathCapture;
          }
          break;
        case PathCaptureState.OnPath:
          if (Math.abs(linearDeviation) > this.pathCaptureProfile.minCaptureDeviation && !allowPathCapture) {
            this.pathCaptureState = PathCaptureState.OffPath;
          }
          break;
        case PathCaptureState.InPathCapture:
          const shouldDisengageFromActiveCapture = !this.isPathCaptureConditionMet(linearDeviation, targetVerticalSpeed, this.pathCaptureProfile.pathCaptureGain);
          if (shouldDisengageFromActiveCapture) {
            this.pathCaptureState = PathCaptureState.OffPath;
          } else if (Math.abs(linearDeviation) < this.pathCaptureProfile.minCaptureDeviation) {
            this.pathCaptureState = PathCaptureState.OnPath;
          }
          break;
      }
    }
    isPathCaptureConditionMet(linearDeviation, targetVerticalSpeed, gain) {
      const verticalSpeed = this.getVerticalSpeed();
      if (!verticalSpeed) {
        // Fallback path capture condition
        return Math.abs(linearDeviation) < this.pathCaptureProfile.fallbackPathCaptureDeviation;
      }
      return Math.abs(linearDeviation) < Math.min(this.pathCaptureProfile.maxCaptureDeviation, Math.max(this.pathCaptureProfile.minCaptureDeviation, gain * Math.abs(verticalSpeed - targetVerticalSpeed)));
    }
    getVerticalSpeed() {
      const barometricVs = Arinc429Word.fromSimVarValue('L:A32NX_ADIRS_ADR_1_BAROMETRIC_VERTICAL_SPEED');
      const inertialVs = Arinc429Word.fromSimVarValue('L:A32NX_ADIRS_IR_1_VERTICAL_SPEED');
      if (inertialVs.isNormalOperation()) {
        return inertialVs.value;
      }
      if (barometricVs.isNormalOperation()) {
        return barometricVs.value;
      }
      return null;
    }
    updateSpeedTarget() {
      const {
        fcuSpeed,
        managedDescentSpeedMach,
        flightPhase
      } = this.observer.get();
      const inManagedSpeed = Simplane.getAutoPilotAirspeedManaged();

      // In the approach phase we want to fetch the correct speed target from the JS code.
      // This is because the guidance logic is a bit different in this case.
      const managedSpeedTarget = flightPhase === FmgcFlightPhase.Approach ? SimVar.GetSimVarValue('L:A32NX_SPEEDS_MANAGED_ATHR', 'knots') : Math.round(this.iasOrMach(SimVar.GetSimVarValue('L:A32NX_SPEEDS_MANAGED_PFD', 'knots'), managedDescentSpeedMach));
      const fcuSpeedIas = fcuSpeed < 1 ? SimVar.GetGameVarValue('FROM MACH TO KIAS', 'number', fcuSpeed) : fcuSpeed;
      this.speedTarget = inManagedSpeed ? managedSpeedTarget : fcuSpeedIas;
    }
    writeToSimVars() {
      SimVar.SetSimVarValue('L:A32NX_FG_REQUESTED_VERTICAL_MODE', 'Enum', this.requestedVerticalMode);
      SimVar.SetSimVarValue('L:A32NX_FG_TARGET_ALTITUDE', 'Feet', this.targetAltitudeGuidance);
      SimVar.SetSimVarValue('L:A32NX_FG_TARGET_VERTICAL_SPEED', 'number', this.targetVerticalSpeed);
      SimVar.SetSimVarValue('L:A32NX_PFD_TARGET_ALTITUDE', 'Feet', this.targetAltitude);
      SimVar.SetSimVarValue('L:A32NX_PFD_LINEAR_DEVIATION_ACTIVE', 'Bool', this.showLinearDeviationOnPfd);
      SimVar.SetSimVarValue('L:A32NX_PFD_VERTICAL_PROFILE_LATCHED', 'Bool', this.showDescentLatchOnPfd);
    }
    updateSpeedGuidance() {
      if (this.speedState === DescentSpeedGuidanceState.NotInDescentPhase) {
        return;
      }
      if (this.speedState === DescentSpeedGuidanceState.TargetOnly) {
        SimVar.SetSimVarValue('L:A32NX_SPEEDS_MANAGED_ATHR', 'knots', this.speedTarget);
        return;
      }
      const [lower, upper] = this.speedMargin.getMargins(this.speedTarget);
      const isOnGeometricPath = this.aircraftToDescentProfileRelation.isOnGeometricPath();
      let guidanceTarget = this.speedTarget;
      if (this.requestedVerticalMode === RequestedVerticalMode.SpeedThrust && !this.isInOverspeedCondition) {
        // If we're above the profile, target the upper speed margin to get back on the profile

        guidanceTarget = upper;
      } else if (this.requestedVerticalMode === RequestedVerticalMode.VpathThrust || this.requestedVerticalMode === RequestedVerticalMode.VpathSpeed && !isOnGeometricPath) {
        // In VPATH THRUST, the speed target does not matter, so set it to lower margin already in case we start underspeeding
        // If we get into VPATH SPEED on the idle path, we must have been underspeeding, so try keeping lower margin speed or go into idle

        guidanceTarget = lower;
      }
      SimVar.SetSimVarValue('L:A32NX_SPEEDS_MANAGED_ATHR', 'knots', guidanceTarget);
      SimVar.SetSimVarValue('L:A32NX_PFD_LOWER_SPEED_MARGIN', 'Knots', lower);
      SimVar.SetSimVarValue('L:A32NX_PFD_UPPER_SPEED_MARGIN', 'Knots', upper);
    }
    updateSpeedMarginState() {
      const {
        flightPhase
      } = this.observer.get();
      const isHoldActive = this.guidanceController.isManualHoldActive();
      if (flightPhase !== FmgcFlightPhase.Descent) {
        this.changeSpeedState(DescentSpeedGuidanceState.NotInDescentPhase);
        return;
      }
      const shouldShowMargins = !isHoldActive && this.verticalState === DescentVerticalGuidanceState.ProvidingGuidance && Simplane.getAutoPilotAirspeedManaged();
      this.changeSpeedState(shouldShowMargins ? DescentSpeedGuidanceState.TargetAndMargins : DescentSpeedGuidanceState.TargetOnly);
    }
    changeSpeedState(newState) {
      if (this.speedState === newState) {
        return;
      }

      // Hide margins if they were previously visible, but the state changed to literally anything else
      if (this.speedState === DescentSpeedGuidanceState.TargetAndMargins) {
        SimVar.SetSimVarValue('L:A32NX_PFD_SHOW_SPEED_MARGINS', 'boolean', false);
        SimVar.SetSimVarValue('L:A32NX_PFD_LOWER_SPEED_MARGIN', 'Knots', 0);
        SimVar.SetSimVarValue('L:A32NX_PFD_UPPER_SPEED_MARGIN', 'Knots', 0);
      } else if (newState === DescentSpeedGuidanceState.TargetAndMargins) {
        SimVar.SetSimVarValue('L:A32NX_PFD_SHOW_SPEED_MARGINS', 'boolean', true);
      }
      this.speedState = newState;
    }
    iasOrMach(ias, mach) {
      const machAsIas = SimVar.GetGameVarValue('FROM MACH TO KIAS', 'number', mach);
      if (ias > machAsIas) {
        return machAsIas;
      }
      return ias;
    }
    updateOverUnderspeedCondition() {
      const airspeed = this.atmosphericConditions.currentAirspeed;
      let upperLimit = this.speedTarget;
      let lowerLimit = this.speedTarget - 5;
      if (this.speedState === DescentSpeedGuidanceState.TargetAndMargins) {
        const [lower, upper] = this.speedMargin.getMargins(this.speedTarget);
        lowerLimit = lower;
        upperLimit = upper;
      }
      if (this.isInOverspeedCondition && airspeed < upperLimit) {
        this.isInOverspeedCondition = false;
      } else if (!this.isInOverspeedCondition && airspeed > upperLimit + 5) {
        this.isInOverspeedCondition = true;
        // Make sure we're not in over and underspeed at the same time
        this.isInUnderspeedCondition = false;
      }
      if (!this.isInUnderspeedCondition && airspeed < lowerLimit) {
        this.isInUnderspeedCondition = true;
        this.isInOverspeedCondition = false;
      } else if (this.isInUnderspeedCondition && airspeed > lowerLimit + 5) {
        this.isInUnderspeedCondition = false;
      }
    }
  }

  class AircraftToDescentProfileRelation {
    get distanceFromStart() {
      return this.totalFlightPlanDistance - this.distanceToEnd;
    }
    constructor(observer) {
      this.observer = observer;
      _defineProperty(this, "isValid", false);
      _defineProperty(this, "currentProfile", void 0);
      _defineProperty(this, "topOfDescent", void 0);
      _defineProperty(this, "geometricPathStart", void 0);
      _defineProperty(this, "distanceToEnd", 0);
      _defineProperty(this, "totalFlightPlanDistance", 0);
    }
    updateProfile(profile) {
      const topOfDescent = profile === null || profile === void 0 ? void 0 : profile.findVerticalCheckpoint(VerticalCheckpointReason.TopOfDescent);
      const geometricPathStart = profile === null || profile === void 0 ? void 0 : profile.findVerticalCheckpoint(VerticalCheckpointReason.GeometricPathStart);
      const isProfileValid = !!topOfDescent && !!geometricPathStart;
      if (!isProfileValid) {
        this.invalidate();
        return;
      }
      this.isValid = isProfileValid;
      this.topOfDescent = topOfDescent;
      this.geometricPathStart = geometricPathStart;
      this.currentProfile = profile;
      this.totalFlightPlanDistance = profile.totalFlightPlanDistance;
      this.distanceToEnd = profile.totalFlightPlanDistance - profile.distanceToPresentPosition;
    }
    invalidate() {
      this.isValid = false;
      this.currentProfile = undefined;
      this.topOfDescent = undefined;
    }
    update(distanceToEnd) {
      if (!this.isValid) {
        return;
      }
      this.distanceToEnd = distanceToEnd;
    }
    isPastTopOfDescent() {
      return this.distanceToTopOfDescent() < 0;
    }
    distanceToTopOfDescent() {
      if (this.topOfDescent) {
        return this.topOfDescent.distanceFromStart - this.distanceFromStart;
      }
      return null;
    }
    isOnGeometricPath() {
      return this.distanceFromStart > this.geometricPathStart.distanceFromStart;
    }
    computeLinearDeviation() {
      const altitude = this.observer.get().presentPosition.alt;
      const targetAltitude = this.currentTargetAltitude();
      return altitude - targetAltitude;
    }
    currentTargetAltitude() {
      return this.currentProfile.interpolateAltitudeAtDistance(this.distanceFromStart);
    }
    currentTargetPathAngle() {
      return this.currentProfile.interpolatePathAngleAtDistance(this.distanceFromStart);
    }
    currentTargetVerticalSpeed() {
      const groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'Knots');
      const knotsToFeetPerMinute = 101.269;
      return knotsToFeetPerMinute * groundSpeed * Math.tan(this.currentTargetPathAngle() * MathUtils$1.DEGREES_TO_RADIANS);
    }
    isAboveSpeedLimitAltitude() {
      const {
        presentPosition,
        descentSpeedLimit
      } = this.observer.get();
      return presentPosition.alt > (descentSpeedLimit === null || descentSpeedLimit === void 0 ? void 0 : descentSpeedLimit.underAltitude);
    }
    isCloseToAirfieldElevation() {
      const {
        destinationElevation,
        presentPosition
      } = this.observer.get();
      return presentPosition.alt < destinationElevation + 5000;
    }
    get currentDistanceToEnd() {
      return this.distanceToEnd;
    }
  }

  class NavHeadingProfile {
    constructor(flightPlanManager) {
      this.flightPlanManager = flightPlanManager;
      _defineProperty(this, "courses", []);
    }
    get(distanceFromStart) {
      if (this.courses.length === 0) {
        return null;
      }
      if (distanceFromStart <= this.courses[0].distanceFromStart) {
        return this.courses[0].course;
      }
      for (let i = 0; i < this.courses.length - 1; i++) {
        if (distanceFromStart > this.courses[i].distanceFromStart && distanceFromStart <= this.courses[i + 1].distanceFromStart) {
          return this.courses[i].course;
        }
      }
      return this.courses[this.courses.length - 1].course;
    }
    updateGeometry(geometry) {
      this.courses = [];
      const {
        legs,
        transitions
      } = geometry;
      let distanceFromStart = 0;
      for (let i = 0; i < this.flightPlanManager.getWaypointsCount(); i++) {
        const leg = legs.get(i);
        if (!leg || leg.isNull || leg instanceof IFLeg) {
          continue;
        }
        const inboundTransition = transitions.get(i - 1);
        const legDistance = Geometry.completeLegPathLengths(leg, inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull || !(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isComputed) ? null : inboundTransition, transitions.get(i)).reduce((sum, el) => sum + (!Number.isNaN(el) ? el : 0), 0);
        distanceFromStart += legDistance;
        if (!Number.isFinite(leg.outboundCourse)) {
          continue;
        }
        this.courses.push({
          distanceFromStart,
          course: leg.outboundCourse
        });
      }
    }
  }

  class CruisePathBuilder {
    constructor(computationParametersObserver, atmosphericConditions) {
      this.computationParametersObserver = computationParametersObserver;
      this.atmosphericConditions = atmosphericConditions;
    }
    computeCruisePath(profile, startOfCruise, targetDistanceFromStart, stepClimbStrategy, stepDescentStrategy, speedProfile, windProfile) {
      const sequence = new TemporaryCheckpointSequence(startOfCruise);
      for (const step of profile.cruiseSteps) {
        if (step.isIgnored) {
          continue;
        }

        // If the step is too close to T/D
        if (step.distanceFromStart < startOfCruise.distanceFromStart || step.distanceFromStart > targetDistanceFromStart) {
          this.ignoreCruiseStep(profile, step);
          continue;
        }

        // See if there are any speed constraints before the step
        for (const speedConstraint of profile.maxClimbSpeedConstraints) {
          if (speedConstraint.distanceFromStart > step.distanceFromStart) {
            continue;
          }
          this.addSegmentToSpeedConstraint(sequence, speedConstraint, speedProfile, windProfile);
        }
        const {
          distanceFromStart,
          altitude,
          remainingFuelOnBoard
        } = sequence.lastCheckpoint;
        const speed = speedProfile.getTarget(distanceFromStart, altitude, ManagedSpeedType.Cruise);
        const headwind = windProfile.getHeadwindComponent(distanceFromStart, altitude);
        const segmentToStep = this.computeCruiseSegment(altitude, step.distanceFromStart - distanceFromStart, remainingFuelOnBoard, speed, headwind);
        sequence.addCheckpointFromStep(segmentToStep, VerticalCheckpointReason.AtmosphericConditions);
        const addingStepSuccessful = this.tryAddStepFromLastCheckpoint(sequence, step, stepClimbStrategy, stepDescentStrategy, targetDistanceFromStart);
        if (!addingStepSuccessful) {
          this.ignoreCruiseStep(profile, step);
          continue;
        }
      }

      // Once again, we check if there are any speed constraints before the T/D
      for (const speedConstraint of profile.maxClimbSpeedConstraints) {
        // If speed constraint does not lie along the remaining cruise track
        if (speedConstraint.distanceFromStart > targetDistanceFromStart) {
          continue;
        }
        this.addSegmentToSpeedConstraint(sequence, speedConstraint, speedProfile, windProfile);
      }
      if (sequence.lastCheckpoint.distanceFromStart >= targetDistanceFromStart) {
        return sequence;
      }
      const speedTarget = speedProfile.getTarget(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude, ManagedSpeedType.Cruise);
      if (speedTarget - sequence.lastCheckpoint.speed > 1) {
        const accelerationStep = this.levelAccelerationStep(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.speed, speedTarget, windProfile.getHeadwindComponent(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.distanceFromStart));
        sequence.addCheckpointFromStep(accelerationStep, VerticalCheckpointReason.AtmosphericConditions);
      }
      const step = this.computeCruiseSegment(sequence.lastCheckpoint.altitude, targetDistanceFromStart - sequence.lastCheckpoint.distanceFromStart, startOfCruise.remainingFuelOnBoard, speedTarget, windProfile.getHeadwindComponent(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude));
      sequence.addCheckpointFromStep(step, VerticalCheckpointReason.AtmosphericConditions);
      return sequence;
    }
    addSegmentToSpeedConstraint(sequence, speedConstraint, speedProfile, windProfile) {
      const {
        distanceFromStart,
        altitude,
        remainingFuelOnBoard
      } = sequence.lastCheckpoint;
      if (speedConstraint.distanceFromStart < distanceFromStart) {
        return;
      }
      const speed = speedProfile.getTarget(distanceFromStart, altitude, ManagedSpeedType.Cruise);
      const segmentResult = this.computeCruiseSegment(altitude, speedConstraint.distanceFromStart - distanceFromStart, remainingFuelOnBoard, speed, windProfile.getHeadwindComponent(distanceFromStart, altitude));
      sequence.addCheckpointFromStep(segmentResult, VerticalCheckpointReason.SpeedConstraint);
    }

    /**
     * Compute a cruise step segment and add it unless it is too close to T/D.
     * @param sequence
     * @param step
     * @param stepClimbStrategy
     * @param stepDescentStrategy
     * @param maxDistance
     * @returns
     */
    tryAddStepFromLastCheckpoint(sequence, step, stepClimbStrategy, stepDescentStrategy, maxDistance) {
      const {
        managedCruiseSpeed,
        managedCruiseSpeedMach
      } = this.computationParametersObserver.get();
      const {
        altitude,
        distanceFromStart,
        remainingFuelOnBoard
      } = sequence.lastCheckpoint;
      const isClimbVsDescent = step.toAltitude > altitude;
      // Instead of just atmospheric conditions, the last checkpoint is now a step climb point
      if (sequence.lastCheckpoint.reason === VerticalCheckpointReason.AtmosphericConditions) {
        sequence.lastCheckpoint.reason = isClimbVsDescent ? VerticalCheckpointReason.StepClimb : VerticalCheckpointReason.StepDescent;
      }
      const stepResults = isClimbVsDescent ? stepClimbStrategy.predictToAltitude(altitude, step.toAltitude, managedCruiseSpeed, managedCruiseSpeedMach, remainingFuelOnBoard, WindComponent.zero()) : stepDescentStrategy.predictToAltitude(altitude, step.toAltitude, managedCruiseSpeed, managedCruiseSpeed, remainingFuelOnBoard, WindComponent.zero());

      // If the step end is closer than 50 NM to T/D, the step is ignored.
      if (distanceFromStart + stepResults.distanceTraveled - maxDistance > -50) {
        return false;
      }
      sequence.addCheckpointFromStep(stepResults, isClimbVsDescent ? VerticalCheckpointReason.TopOfStepClimb : VerticalCheckpointReason.BottomOfStepDescent);
      return true;
    }
    computeCruiseSegment(altitude, distance, remainingFuelOnBoard, speed, headwind) {
      const {
        zeroFuelWeight,
        managedCruiseSpeedMach,
        tropoPause
      } = this.computationParametersObserver.get();
      return Predictions.levelFlightStep(altitude, distance, speed, managedCruiseSpeedMach, zeroFuelWeight, remainingFuelOnBoard, headwind.value, this.atmosphericConditions.isaDeviation, tropoPause);
    }
    levelAccelerationStep(remainingFuelOnBoard, speed, finalSpeed, headwind) {
      const {
        zeroFuelWeight,
        cruiseAltitude,
        managedCruiseSpeedMach,
        tropoPause
      } = this.computationParametersObserver.get();
      return Predictions.speedChangeStep(0, cruiseAltitude, speed, finalSpeed, managedCruiseSpeedMach, managedCruiseSpeedMach, this.getClimbThrustN1Limit(this.atmosphericConditions, cruiseAltitude, speed), zeroFuelWeight, remainingFuelOnBoard, headwind.value, this.atmosphericConditions.isaDeviation, tropoPause);
    }
    getFinalCruiseAltitude(cruiseSteps) {
      const {
        cruiseAltitude
      } = this.computationParametersObserver.get();
      let altitude = cruiseAltitude;
      for (let i = 0; i < cruiseSteps.length; i++) {
        const step = cruiseSteps[i];
        if (!step.isIgnored) {
          altitude = step.toAltitude;
        }
      }
      return altitude;
    }
    getClimbThrustN1Limit(atmosphericConditions, altitude, speed) {
      // This Mach number is the Mach number for the predicted climb speed, not the Mach to use after crossover altitude.
      const climbSpeedMach = atmosphericConditions.computeMachFromCas(altitude, speed);
      const estimatedTat = atmosphericConditions.totalAirTemperatureFromMach(altitude, climbSpeedMach);
      return EngineModel.tableInterpolation(EngineModel.maxClimbThrustTableLeap, estimatedTat, altitude);
    }
    ignoreCruiseStep(profile, step) {
      step.isIgnored = true;
      profile.ignoreCruiseStep(step.waypointIndex);
    }
  }

  class ProfileInterceptCalculator {
    /**
     * Calculate where two checkpoint sequences intersect.
     * @param checkpoints1 The first sequence of checkpoints.
     * @param checkpoints2 The second sequence of checkpoints.
     * @param offset The distance from the start of the second sequence to the start of the first sequence.
     * @returns A tuple of the index of the first checkpoint in the first sequence and the distance from the start of the first sequence to the intersection point.
     */
    static calculateIntercept(checkpoints1, checkpoints2) {
      let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      for (let i = 0; i < checkpoints1.length - 1; i++) {
        const c1Start = checkpoints1[i];
        const c1End = checkpoints1[i + 1];
        for (let j = 0; j < checkpoints2.length - 1; j++) {
          const c2Start = checkpoints2[j];
          const c2End = checkpoints2[j + 1];
          const intersection = MathUtils$1.intersect(c1Start.distanceFromStart, c1Start.altitude, c1End.distanceFromStart, c1End.altitude, c2Start.distanceFromStart + offset, c2Start.altitude, c2End.distanceFromStart + offset, c2End.altitude);
          if (intersection) {
            return [i, intersection[0]];
          }
        }
      }
      return [-1, null];
    }
  }

  class CruiseToDescentCoordinator {
    constructor(observer, cruisePathBuilder, descentPathBuilder, approachPathBuilder) {
      this.observer = observer;
      this.cruisePathBuilder = cruisePathBuilder;
      this.descentPathBuilder = descentPathBuilder;
      this.approachPathBuilder = approachPathBuilder;
      _defineProperty(this, "lastEstimatedFuelAtDestination", 4000);
      _defineProperty(this, "lastEstimatedTimeAtDestination", 0);
    }
    resetEstimations() {
      const {
        estimatedDestinationFuel
      } = this.observer.get();

      // Use INIT FUEL PRED entry as initial estimate for destination EFOB. Clamp it to avoid unrealistic entries from erroneous pilot input.
      this.lastEstimatedFuelAtDestination = Number.isFinite(estimatedDestinationFuel) ? Math.min(Math.max(estimatedDestinationFuel, 0), VnavConfig.MAXIMUM_FUEL_ESTIMATE) : 4000;
      this.lastEstimatedTimeAtDestination = 0;
    }
    buildCruiseAndDescentPath(profile, speedProfile, cruiseWinds, descentWinds, stepClimbStrategy, stepDescentStrategy) {
      // - Start with initial guess for fuel on board at destination
      // - Compute descent profile to get distance to T/D and burnt fuel during descent
      // - Compute cruise profile to T/D -> Use fuel at T/D and previously computed fuel burn to get new fuel on board at destination
      // - Repeat
      const startingPointIndex = profile.findLastVerticalCheckpointIndex(VerticalCheckpointReason.TopOfClimb, VerticalCheckpointReason.PresentPosition);
      if (startingPointIndex < 0) {
        return;
      }
      let startingPoint = profile.checkpoints[startingPointIndex];
      let iterationCount = 0;
      let todFuelError = Infinity;
      let todTimeError = Infinity;
      if (Number.isNaN(this.lastEstimatedFuelAtDestination) || Number.isNaN(this.lastEstimatedTimeAtDestination)) {
        this.resetEstimations();
      }
      let descentPath = new TemporaryCheckpointSequence();
      let cruisePath = new TemporaryCheckpointSequence();
      while (iterationCount++ < 4 && (Math.abs(todFuelError) > 100 || Math.abs(todTimeError) > 1)) {
        descentPath = this.approachPathBuilder.computeApproachPath(profile, speedProfile, descentWinds, this.lastEstimatedFuelAtDestination, this.lastEstimatedTimeAtDestination);
        if (descentPath.lastCheckpoint.reason !== VerticalCheckpointReason.Decel) {
          console.error('[FMS/VNAV] Approach path did not end in DECEL. Discarding descent profile.');
          return;
        }

        // Geometric and idle
        this.descentPathBuilder.computeManagedDescentPath(descentPath, profile, speedProfile, descentWinds, this.cruisePathBuilder.getFinalCruiseAltitude(profile.cruiseSteps));
        if (descentPath.lastCheckpoint.reason !== VerticalCheckpointReason.TopOfDescent) {
          console.error('[FMS/VNAV] Approach path did not end in T/D. Discarding descent profile.');
          return;
        }
        if (descentPath.lastCheckpoint.distanceFromStart < startingPoint.distanceFromStart) {
          // Check if plane is past T/D.
          if (startingPoint.reason === VerticalCheckpointReason.PresentPosition) {
            // At this point, there will still be a PresentPosition checkpoint in the profile, but we use it and remove it in DescentGuidance
            profile.checkpoints.push(...descentPath.get(true).reverse());
            return;
          }
          if (startingPoint.reason === VerticalCheckpointReason.TopOfClimb) {
            // Flight plan too short
            const [index, climbDescentInterceptDistance] = ProfileInterceptCalculator.calculateIntercept(profile.checkpoints, descentPath.checkpoints);

            // If we somehow don't find an intercept between climb and descent path, just build the cruise path until end of the path
            if (index < 0) {
              cruisePath = this.cruisePathBuilder.computeCruisePath(profile, startingPoint, descentPath.at(0).distanceFromStart, stepClimbStrategy, stepDescentStrategy, speedProfile, cruiseWinds);
              console.error('[FMS/VNAV] Edge case: Flight plan too short. However, no intercept between climb and descent path.');
              profile.checkpoints.push(...cruisePath.get());
              return;
            }

            // If there is an intercept, place the T/D wherever we need it
            const combinedTopOfClimbTopOfDescent = profile.addInterpolatedCheckpoint(climbDescentInterceptDistance, {
              reason: VerticalCheckpointReason.TopOfClimb
            });
            const savedTopOfDescent = descentPath.lastCheckpoint;
            descentPath.checkpoints = descentPath.checkpoints.filter(checkpoint => checkpoint.distanceFromStart >= combinedTopOfClimbTopOfDescent.distanceFromStart);
            // TODO: We should interpolate this point along the descent path, so fuel and time are correct
            descentPath.push(_objectSpread2(_objectSpread2({}, savedTopOfDescent), {}, {
              distanceFromStart: combinedTopOfClimbTopOfDescent.distanceFromStart,
              altitude: combinedTopOfClimbTopOfDescent.altitude
            }));
            startingPoint = combinedTopOfClimbTopOfDescent;
          }
        }
        cruisePath = this.cruisePathBuilder.computeCruisePath(profile, startingPoint, descentPath.lastCheckpoint.distanceFromStart, stepClimbStrategy, stepDescentStrategy, speedProfile, cruiseWinds);
        if (!cruisePath) {
          console.error('[FMS/VNAV] Could not coordinate cruise and descent path. Discarding descent profile');
          return;
        }
        todFuelError = cruisePath.lastCheckpoint.remainingFuelOnBoard - descentPath.lastCheckpoint.remainingFuelOnBoard;
        todTimeError = cruisePath.lastCheckpoint.secondsFromPresent - descentPath.lastCheckpoint.secondsFromPresent;
        this.lastEstimatedFuelAtDestination += todFuelError;
        this.lastEstimatedTimeAtDestination += todTimeError;
      }
      profile.checkpoints = profile.checkpoints.filter(checkpoint => checkpoint.distanceFromStart <= startingPoint.distanceFromStart);
      profile.checkpoints.push(...cruisePath.get());
      profile.checkpoints.push(...descentPath.get(true).reverse());
    }
  }

  class SelectedGeometryProfile extends BaseGeometryProfile {
    constructor() {
      super(...arguments);
      _defineProperty(this, "maxAltitudeConstraints", []);
      _defineProperty(this, "descentAltitudeConstraints", []);
      _defineProperty(this, "maxClimbSpeedConstraints", []);
      _defineProperty(this, "descentSpeedConstraints", []);
      _defineProperty(this, "cruiseSteps", []);
      _defineProperty(this, "distanceToPresentPosition", 0);
      _defineProperty(this, "checkpointsToShowAlongFlightPlan", new Set([VerticalCheckpointReason.CrossingFcuAltitudeClimb, VerticalCheckpointReason.CrossingFcuAltitudeDescent, VerticalCheckpointReason.CrossingClimbSpeedLimit]));
    }
    getCheckpointsToShowOnTrackLine() {
      return this.checkpoints.filter(checkpoint => this.checkpointsToShowAlongFlightPlan.has(checkpoint.reason));
    }
    resetAltitudeConstraints() {
      this.maxAltitudeConstraints = [];
      this.descentAltitudeConstraints = [];
    }
    resetSpeedConstraints() {
      this.maxClimbSpeedConstraints = [];
      this.descentSpeedConstraints = [];
    }
  }

  class TakeoffPathBuilder {
    constructor(observer, atmosphericConditions) {
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
    }
    buildTakeoffPath(profile) {
      this.addTakeoffRollCheckpoint(profile);
      this.buildPathToThrustReductionAltitude(profile);
      this.buildPathToAccelerationAltitude(profile);
    }
    addTakeoffRollCheckpoint(profile) {
      const {
        departureElevation,
        v2Speed,
        fuelOnBoard,
        managedClimbSpeedMach
      } = this.observer.get();
      profile.checkpoints.push({
        reason: VerticalCheckpointReason.Liftoff,
        distanceFromStart: 0.6,
        secondsFromPresent: 20,
        altitude: departureElevation,
        remainingFuelOnBoard: fuelOnBoard,
        speed: v2Speed + 10,
        mach: managedClimbSpeedMach
      });
    }
    buildPathToThrustReductionAltitude(profile) {
      const {
        perfFactor,
        zeroFuelWeight,
        v2Speed,
        tropoPause,
        thrustReductionAltitude,
        takeoffFlapsSetting,
        managedClimbSpeedMach
      } = this.observer.get();
      const lastCheckpoint = profile.lastCheckpoint;
      const startingAltitude = lastCheckpoint.altitude;
      const predictedN1 = SimVar.GetSimVarValue('L:A32NX_AUTOTHRUST_THRUST_LIMIT_TOGA', 'Percent');
      const speed = v2Speed + 10;
      const {
        fuelBurned,
        distanceTraveled,
        timeElapsed
      } = Predictions.altitudeStep(startingAltitude, thrustReductionAltitude - startingAltitude, speed, this.atmosphericConditions.computeMachFromCas((thrustReductionAltitude + startingAltitude) / 2, speed), predictedN1, zeroFuelWeight, profile.lastCheckpoint.remainingFuelOnBoard, 0, this.atmosphericConditions.isaDeviation, tropoPause, false, takeoffFlapsSetting, false, perfFactor);
      profile.checkpoints.push({
        reason: VerticalCheckpointReason.ThrustReductionAltitude,
        distanceFromStart: profile.lastCheckpoint.distanceFromStart + distanceTraveled,
        secondsFromPresent: profile.lastCheckpoint.secondsFromPresent + timeElapsed,
        altitude: thrustReductionAltitude,
        remainingFuelOnBoard: profile.lastCheckpoint.remainingFuelOnBoard - fuelBurned,
        speed,
        mach: managedClimbSpeedMach
      });
    }
    buildPathToAccelerationAltitude(profile) {
      const lastCheckpoint = profile.lastCheckpoint;
      const {
        accelerationAltitude,
        v2Speed,
        zeroFuelWeight,
        perfFactor,
        tropoPause,
        managedClimbSpeedMach
      } = this.observer.get();
      const speed = v2Speed + 10;
      const startingAltitude = lastCheckpoint.altitude;
      const midwayAltitude = (startingAltitude + accelerationAltitude) / 2;
      const v2PlusTenMach = this.atmosphericConditions.computeMachFromCas(midwayAltitude, speed);
      const estimatedTat = this.atmosphericConditions.totalAirTemperatureFromMach(midwayAltitude, v2PlusTenMach);
      const predictedN1 = EngineModel.tableInterpolation(EngineModel.maxClimbThrustTableLeap, estimatedTat, midwayAltitude);
      const {
        fuelBurned,
        distanceTraveled,
        timeElapsed
      } = Predictions.altitudeStep(startingAltitude, accelerationAltitude - startingAltitude, speed, 1,
      // We never want to compute this in Mach, so we set the critical Mach to 1
      predictedN1, zeroFuelWeight, lastCheckpoint.remainingFuelOnBoard, 0, this.atmosphericConditions.isaDeviation, tropoPause, false, FlapConf.CLEAN, false, perfFactor);
      profile.checkpoints.push({
        reason: VerticalCheckpointReason.AccelerationAltitude,
        distanceFromStart: lastCheckpoint.distanceFromStart + distanceTraveled,
        secondsFromPresent: lastCheckpoint.secondsFromPresent + timeElapsed,
        altitude: accelerationAltitude,
        remainingFuelOnBoard: lastCheckpoint.remainingFuelOnBoard - fuelBurned,
        speed,
        mach: managedClimbSpeedMach
      });
    }
  }

  class BisectionMethod {
    /**
     * Use bisection method to approximate root of a function. This method works best for continuous functions.
     * @param f Function to find root of. Should take in a number and return a number.
     * @param a, b Bounds of domain to search for root. Should be such that f(a) and f(b) have opposite signs.
     * @param errorTolerance An array [e0, e1] describing the interval in which the error is allowed to be.
     * @param maxIterations Number of iterations to perform before giving up.
     * @param nonTerminationStrategy Strategy to use if the method does not converge.
     * @link https://en.wikipedia.org/wiki/Bisection_method
     * @returns The zero of the function.
     */
    static findZero(f, _ref) {
      let [a, b] = _ref;
      let errorTolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-0.05, 0.05];
      let nonTerminationStrategy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NonTerminationStrategy.LowerAbsoluteErrorResult;
      let maxIterations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10;
      if (a > b) {
        [b, a] = [a, b];
      }
      const isWithinTolerance = error => error >= errorTolerance[0] && error <= errorTolerance[1];
      const fa = f(a);
      const fb = f(b);
      if (fa * fb > 0) {
        // If solution does not lie between a and b, return closer value.
        return Math.abs(fa) < Math.abs(fb) ? a : b;
      }
      if (fa * fb < 0) {
        for (let i = 0; i < maxIterations; i++) {
          const c = (a + b) / 2;
          const fc = f(c);
          if (isWithinTolerance(fc)) {
            return c;
          }
          if (fa * fc > 0) {
            a = c;
          } else {
            b = c;
          }
        }
      }
      if (nonTerminationStrategy === NonTerminationStrategy.PositiveErrorResult) {
        return fa > 0 ? a : b;
      }
      if (nonTerminationStrategy === NonTerminationStrategy.NegativeErrorResult) {
        return fa < 0 ? a : b;
      }
      return Math.abs(fa) < Math.abs(fb) ? a : b;
    }
  }
  let NonTerminationStrategy = /*#__PURE__*/function (NonTerminationStrategy) {
    NonTerminationStrategy[NonTerminationStrategy["PositiveErrorResult"] = 0] = "PositiveErrorResult";
    NonTerminationStrategy[NonTerminationStrategy["NegativeErrorResult"] = 1] = "NegativeErrorResult";
    NonTerminationStrategy[NonTerminationStrategy["LowerAbsoluteErrorResult"] = 2] = "LowerAbsoluteErrorResult";
    return NonTerminationStrategy;
  }({});

  class FlapConfigurationProfile {
    static getBySpeed(speed, parameters) {
      if (speed >= parameters.cleanSpeed) {
        return FlapConf.CLEAN;
      }
      if (speed >= parameters.slatRetractionSpeed) {
        return FlapConf.CONF_1; // Between S and O
      }
      if (speed >= parameters.flapRetractionSpeed) {
        return FlapConf.CONF_2; // Between F and S
      }
      if (speed >= (parameters.flapRetractionSpeed + parameters.approachSpeed) / 2) {
        return FlapConf.CONF_3;
      }
      return FlapConf.CONF_FULL;
    }
    static findNextExtensionSpeed(speed, parameters) {
      if (speed < (parameters.flapRetractionSpeed + parameters.approachSpeed) / 2) {
        return (parameters.flapRetractionSpeed + parameters.approachSpeed) / 2;
      }
      if (speed < parameters.flapRetractionSpeed) {
        return parameters.flapRetractionSpeed;
      }
      if (speed < parameters.slatRetractionSpeed) {
        return parameters.slatRetractionSpeed;
      }
      if (speed < parameters.cleanSpeed) {
        return parameters.cleanSpeed;
      }
      return Infinity;
    }
    static getApproachPhaseTargetSpeed(flapConfig, parameters) {
      switch (flapConfig) {
        case FlapConf.CONF_FULL:
          return parameters.approachSpeed;
        case FlapConf.CONF_3:
        case FlapConf.CONF_2:
          return parameters.flapRetractionSpeed;
        case FlapConf.CONF_1:
          return parameters.slatRetractionSpeed;
        case FlapConf.CLEAN:
          return parameters.cleanSpeed;
        default:
          throw new Error("[FMS/VNAV] Unknown flap config: ".concat(flapConfig));
      }
    }
    static getFlapCheckpointReasonByFlapConf(flapConfig) {
      switch (flapConfig) {
        case FlapConf.CONF_FULL:
          return VerticalCheckpointReason.FlapsFull;
        case FlapConf.CONF_3:
          return VerticalCheckpointReason.Flaps3;
        case FlapConf.CONF_2:
          return VerticalCheckpointReason.Flaps2;
        case FlapConf.CONF_1:
          return VerticalCheckpointReason.Flaps1;
        case FlapConf.CLEAN:
          return VerticalCheckpointReason.Decel;
        default:
          throw new Error("[FMS/VNAV] Unknown flap config: ".concat(flapConfig));
      }
    }
  }
  class AircraftConfigurationProfile {
    static getBySpeed(speed, parameters) {
      return {
        flapConfig: FlapConfigurationProfile.getBySpeed(speed, parameters),
        speedbrakesExtended: false,
        gearExtended: speed < parameters.flapRetractionSpeed
      };
    }
  }
  class ApproachPathBuilder {
    constructor(observer, atmosphericConditions) {
      this.observer = observer;
      _defineProperty(this, "idleStrategy", void 0);
      _defineProperty(this, "fpaStrategy", void 0);
      this.idleStrategy = new IdleDescentStrategy(observer, atmosphericConditions);
      this.fpaStrategy = new FlightPathAngleStrategy(observer, atmosphericConditions, 0);
    }
    computeApproachPath(profile, speedProfile, windProfile, estimatedFuelOnBoardAtDestination, estimatedSecondsFromPresentAtDestination) {
      const {
        approachSpeed,
        managedDescentSpeedMach,
        cleanSpeed
      } = this.observer.get();
      const approachConstraints = profile.descentAltitudeConstraints.slice().reverse();

      // If we have a procedure loaded, we use the MAP altitude.
      // If not, fall back to runway or airfield
      const finalAltitude = profile.finalAltitude;
      const sequence = new TemporaryCheckpointSequence({
        reason: VerticalCheckpointReason.Landing,
        speed: approachSpeed,
        distanceFromStart: profile.getDistanceFromStart(0),
        altitude: finalAltitude,
        remainingFuelOnBoard: estimatedFuelOnBoardAtDestination,
        secondsFromPresent: estimatedSecondsFromPresentAtDestination,
        mach: managedDescentSpeedMach
      });
      const distanceToOneThousandAgl = 1000 / Math.tan(profile.finalDescentAngle * MathUtils$1.DEGREES_TO_RADIANS) / 6076.12;

      // Build final segment
      this.fpaStrategy.flightPathAngle = profile.finalDescentAngle;
      const finalApproachStep = this.fpaStrategy.predictToDistance(finalAltitude, distanceToOneThousandAgl, approachSpeed, managedDescentSpeedMach, estimatedFuelOnBoardAtDestination, windProfile.getHeadwindComponent(profile.getDistanceFromStart(0), finalAltitude), AircraftConfigurationProfile.getBySpeed(approachSpeed, this.observer.get()));
      sequence.addCheckpointFromStep(finalApproachStep, VerticalCheckpointReason.AtmosphericConditions);

      // Build path to FAF by flying the descent angle but decelerating
      const fafStep = this.buildDecelerationPath(sequence.lastCheckpoint, speedProfile, windProfile, profile.getDistanceFromStart(profile.fafDistanceToEnd));
      sequence.push(...fafStep.get());

      //
      this.fpaStrategy.flightPathAngle = 0;
      for (const altitudeConstraint of approachConstraints) {
        this.handleAltitudeConstraint(sequence, speedProfile, windProfile, altitudeConstraint);

        // If you're at or above your descent speed (taking speed limit into account, place the decel point)
        const speedTarget = speedProfile.getTarget(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude, ManagedSpeedType.Descent);
        if (sequence.lastCheckpoint.reason === VerticalCheckpointReason.Decel || sequence.lastCheckpoint.speed > cleanSpeed && sequence.lastCheckpoint.speed > speedTarget) {
          break;
        }
      }
      const speedTarget = speedProfile.getTarget(sequence.lastCheckpoint.distanceFromStart - 1e-4, sequence.lastCheckpoint.altitude, ManagedSpeedType.Descent);
      if (speedTarget - sequence.lastCheckpoint.speed > 0.1) {
        // We use -Infinty because we just want to decelerate to the descent speed without and constraint on distance
        const decelerationToDescentSpeed = this.buildDecelerationPath(sequence.lastCheckpoint, speedProfile, windProfile, -Infinity);
        sequence.push(...decelerationToDescentSpeed.get());
      }

      // There are cases where the decel point is not added when we handle the constraints above, in this case, we just add it here.
      if (sequence.lastCheckpoint.reason !== VerticalCheckpointReason.Decel) {
        sequence.copyLastCheckpoint({
          reason: VerticalCheckpointReason.Decel
        });
      }
      return sequence;
    }
    handleAltitudeConstraint(sequence, speedProfile, windProfile, constraint) {
      // We compose this segment of three segments:
      //  1. (A level deceleration segment) - `decelerationSequence`
      //  2. A descent segment - `descentSegment`
      //  3. A level deceleration segment - `secondDecelerationSequence`
      // ^ This is the order in which they appear along the track. Like the entire descent path, we build it backwards

      // Going in reverse:
      // We try to choose make the deceleration segment just as long that we can meet the altitude constraint with the descent segment.
      // Segment number 1. is only needed if we decelerate, descend, but are not at the altitude constraint yet.
      const {
        managedDescentSpeedMach,
        cleanSpeed
      } = this.observer.get();
      const {
        distanceFromStart,
        altitude
      } = sequence.lastCheckpoint;
      if (distanceFromStart < constraint.distanceFromStart || constraint.constraint.type === AltitudeConstraintType.atOrBelow || altitude - constraint.constraint.altitude1 > -50 // If we are already above the constraint
      ) {
        return;
      }
      const minimumAltitude = constraint.constraint.type === AltitudeConstraintType.range ? constraint.constraint.altitude2 : constraint.constraint.altitude1;

      // This should be positive
      const desiredDistanceToCover = distanceFromStart - constraint.distanceFromStart;
      let decelerationSequence = null;
      let descentSegment = null;
      let secondDecelerationSequence = null;

      // `decelerationSegmentDistance` should be positive
      const tryDecelDistance = decelerationSegmentDistance => {
        const currentDecelerationAttempt = new TemporaryCheckpointSequence(sequence.lastCheckpoint);
        decelerationSequence = this.buildDecelerationPath(sequence.lastCheckpoint, speedProfile, windProfile, distanceFromStart - decelerationSegmentDistance);
        currentDecelerationAttempt.push(...decelerationSequence.get());
        descentSegment = this.idleStrategy.predictToAltitude(altitude, minimumAltitude, decelerationSequence.lastCheckpoint.speed, managedDescentSpeedMach, decelerationSequence.lastCheckpoint.remainingFuelOnBoard, windProfile.getHeadwindComponent(distanceFromStart - decelerationSegmentDistance, minimumAltitude), AircraftConfigurationProfile.getBySpeed(decelerationSequence.lastCheckpoint.speed, this.observer.get()));
        currentDecelerationAttempt.addCheckpointFromStep(descentSegment, VerticalCheckpointReason.AltitudeConstraint);

        // This should be positive.
        // This is what we want to be as close to `desiredDistanceToCover` as possible. That would mean that we start "ascending" (descending backwards) just in time.
        const distanceTraveled = -descentSegment.distanceTraveled + (distanceFromStart - decelerationSequence.lastCheckpoint.distanceFromStart);

        // If we have not reached the altitude constraint yet, because we started "ascending" (descending backwards) too early, we continue to decelerate until we reach the constraint
        secondDecelerationSequence = this.buildDecelerationPath(currentDecelerationAttempt.lastCheckpoint, speedProfile, windProfile, constraint.distanceFromStart);
        return distanceTraveled - desiredDistanceToCover;
      };
      const solution = BisectionMethod.findZero(tryDecelDistance, [0, desiredDistanceToCover], [-0.1, 0.1], NonTerminationStrategy.NegativeErrorResult);
      tryDecelDistance(solution);
      sequence.push(...decelerationSequence.get());
      const speedTarget = speedProfile.getTarget(decelerationSequence.lastCheckpoint.distanceFromStart, decelerationSequence.lastCheckpoint.altitude, ManagedSpeedType.Descent);
      // Don't bother considering the climb step in the profile if we have already reached the target speed in the deceleration segment
      if (speedTarget - decelerationSequence.lastCheckpoint.speed > 1 || decelerationSequence.lastCheckpoint.speed < cleanSpeed) {
        sequence.addCheckpointFromStep(descentSegment, VerticalCheckpointReason.AltitudeConstraint);
        sequence.push(...secondDecelerationSequence.get());
      }
    }
    scaleStepBasedOnLastCheckpoint(lastCheckpoint, step, scaling) {
      step.distanceTraveled *= scaling;
      step.fuelBurned *= scaling;
      step.timeElapsed *= scaling;
      step.finalAltitude = (1 - scaling) * lastCheckpoint.altitude + scaling * step.finalAltitude;
      step.speed = (1 - scaling) * lastCheckpoint.speed + scaling * step.speed;
    }

    /**
     * This builds a level deceleration path, bringing out flaps as needed, and obeying speed constraints.
     * This relies on `this.fpaStrategy` to have the correct descent angle coded.
     * @param lastCheckpoint
     * @param speedProfile
     * @param windProfile
     * @param targetDistanceFromStart
     * @returns
     */
    buildDecelerationPath(lastCheckpoint, speedProfile, windProfile, targetDistanceFromStart) {
      const decelerationSequence = new TemporaryCheckpointSequence(lastCheckpoint);
      const parameters = this.observer.get();
      const {
        managedDescentSpeedMach
      } = parameters;
      for (let i = 0; i < 10 && decelerationSequence.lastCheckpoint.reason !== VerticalCheckpointReason.Decel && decelerationSequence.lastCheckpoint.distanceFromStart - targetDistanceFromStart > 1e-4;
      // We really only want to prevent floating point errors here
      i++) {
        const {
          distanceFromStart,
          altitude,
          speed,
          remainingFuelOnBoard
        } = decelerationSequence.lastCheckpoint;
        const speedConstraint = speedProfile.getMaxDescentSpeedConstraint(distanceFromStart - 1e-4);
        const flapTargetSpeed = FlapConfigurationProfile.findNextExtensionSpeed(speed, parameters);

        // This is the managed descent speed, or the speed limit speed.
        const limitingSpeed = speedProfile.getTargetWithoutConstraints(decelerationSequence.lastCheckpoint.altitude, ManagedSpeedType.Descent);

        // If the constraint is limiting, decelerate to the constraint, then fly constant speed until it is resolved
        // If the flapTarget is limiting, decelerate to the flap target
        // If the limitingSpeed is limiting, decelerate to it and return

        // Constraint is constraining
        if (speedConstraint !== null && speedConstraint.maxSpeed < flapTargetSpeed && speedConstraint.maxSpeed < limitingSpeed) {
          // This is meant to be negative
          const remainingDistance = Math.max(speedConstraint.distanceFromStart, targetDistanceFromStart) - distanceFromStart;

          // Decelerate to constraint
          const decelerationStep = this.fpaStrategy.predictToSpeed(altitude, Math.max(speedConstraint.maxSpeed, speed),
          // If constraint speed is less than the current speed, don't try to decelerate to it (because we'll end up going the wrong way)
          speed, managedDescentSpeedMach, remainingFuelOnBoard, windProfile.getHeadwindComponent(distanceFromStart, altitude), AircraftConfigurationProfile.getBySpeed(speed, parameters));
          if (decelerationStep.distanceTraveled > 0) {
            throw new Error('[FMS/VNAV] Deceleration step distance should not be positive');
          }
          if (decelerationStep.distanceTraveled < 1e-4) {
            // We tried to declerate, but it took us beyond targetDistanceFromStart, so we scale down the step
            const scaling = Math.min(1, remainingDistance / decelerationStep.distanceTraveled);
            this.scaleStepBasedOnLastCheckpoint(decelerationSequence.lastCheckpoint, decelerationStep, scaling);
            decelerationSequence.addCheckpointFromStep(decelerationStep, VerticalCheckpointReason.AtmosphericConditions);
          }
          const remainingDistanceToConstraint = distanceFromStart + decelerationStep.distanceTraveled - Math.max(speedConstraint.distanceFromStart, targetDistanceFromStart);
          if (remainingDistanceToConstraint > 0.05) {
            if (speedConstraint.maxSpeed > parameters.cleanSpeed) {
              decelerationSequence.lastCheckpoint.reason = VerticalCheckpointReason.Decel;
              return decelerationSequence;
            }

            // If we decelerated, but aren't at the constraint yet, fly level, at constant speed to the constraint
            const constantStep = this.fpaStrategy.predictToDistance(altitude, -remainingDistanceToConstraint, speedConstraint.maxSpeed, managedDescentSpeedMach, remainingFuelOnBoard - decelerationStep.fuelBurned, windProfile.getHeadwindComponent(distanceFromStart, altitude), AircraftConfigurationProfile.getBySpeed(speedConstraint.maxSpeed, parameters));
            if (constantStep.distanceTraveled > 0) {
              throw new Error('[FMS/VNAV] Descent step distance should not be positive');
            }
            decelerationSequence.addCheckpointFromStep(constantStep, VerticalCheckpointReason.SpeedConstraint);
          } else {
            decelerationSequence.copyLastCheckpoint({
              reason: VerticalCheckpointReason.SpeedConstraint
            });
          }
        } else {
          // flapTarget or managed speed is constraining
          const remainingDistance = targetDistanceFromStart - distanceFromStart; // This should be negative

          // We don't care about any speed constraint limitations here, because that's what the if block above is for.
          const targetSpeed = Math.min(flapTargetSpeed, limitingSpeed);
          const config = AircraftConfigurationProfile.getBySpeed(speed, parameters);

          // TODO: Handle case where we need speedbrakes
          const decelerationStep = this.fpaStrategy.predictToSpeed(altitude, targetSpeed, speed, managedDescentSpeedMach, remainingFuelOnBoard, windProfile.getHeadwindComponent(distanceFromStart, altitude), config);
          if (decelerationStep.distanceTraveled < remainingDistance) {
            const scaling = Math.min(1, remainingDistance / decelerationStep.distanceTraveled);
            this.scaleStepBasedOnLastCheckpoint(decelerationSequence.lastCheckpoint, decelerationStep, scaling);
            decelerationSequence.addCheckpointFromStep(decelerationStep, VerticalCheckpointReason.AtmosphericConditions);
            return decelerationSequence;
          }
          decelerationSequence.addDecelerationCheckpointFromStep(decelerationStep, FlapConfigurationProfile.getFlapCheckpointReasonByFlapConf(config.flapConfig), FlapConfigurationProfile.getApproachPhaseTargetSpeed(config.flapConfig, parameters));
        }
      }
      return decelerationSequence;
    }
  }

  /**
   * The deceleration schedule describes the speed profile computed for the managed descent path.
   * The tactical path builder should know about this schedule because - while we might not be following the managed vertical profile -
   * we might still be in managed speed mode.
   */

  class TacticalDescentPathBuilder {
    constructor(observer, atmosphericConditions) {
      this.observer = observer;
      _defineProperty(this, "levelFlightStrategy", void 0);
      this.levelFlightStrategy = new VerticalSpeedStrategy(this.observer, atmosphericConditions, 0);
    }

    /**
     * Builds a path from the last checkpoint to the finalDistance
     * @param profile
     * @param descentStrategy
     * @param speedProfile
     * @param windProfile
     * @param finalDistance
     * @param schedule Schedule describing the managed descent path
     */
    buildMcduPredictionPath(profile, descentStrategy, speedProfile, windProfile, schedule) {
      var _schedule$approachPoi, _schedule$approachPoi2;
      const start = profile.lastCheckpoint;
      let minAlt = Infinity;
      const altConstraintsToUse = profile.descentAltitudeConstraints.map(constraint => {
        minAlt = Math.min(minAlt, minimumAltitude(constraint.constraint));
        return {
          distanceFromStart: constraint.distanceFromStart,
          minimumAltitude: minAlt
        };
      });
      const decelPointDistance = (_schedule$approachPoi = (_schedule$approachPoi2 = schedule.approachPoints[0]) === null || _schedule$approachPoi2 === void 0 ? void 0 : _schedule$approachPoi2.distanceFromStart) !== null && _schedule$approachPoi !== void 0 ? _schedule$approachPoi : Infinity;
      const speedConstraintsToUse = profile.descentSpeedConstraints.filter(_ref => {
        let {
          distanceFromStart
        } = _ref;
        return distanceFromStart < decelPointDistance;
      });
      const phaseTable = new PhaseTable(this.observer.get(), windProfile);
      phaseTable.start = start;
      phaseTable.phases = [new DescendToAltitude(profile.finalAltitude).withReasonAfter(VerticalCheckpointReason.Landing)];
      let isPathValid = false;
      let numRecomputations = 0;
      let sequence = null;
      while (!isPathValid && numRecomputations++ < 100) {
        sequence = phaseTable.execute(descentStrategy, this.levelFlightStrategy);
        isPathValid = this.checkForViolations(phaseTable, altConstraintsToUse, speedConstraintsToUse, speedProfile, schedule);
      }
      if (sequence != null) {
        profile.checkpoints.push(...sequence.get());
      }
    }

    /**
     * Builds a path from the last checkpoint to the finalAltitude
     * @param profile
     * @param descentStrategy
     * @param speedProfile
     * @param windProfile
     * @param finalAltitude
     */
    buildTacticalDescentPathToAltitude(profile, descentStrategy, speedProfile, windProfile, finalAltitude, schedule) {
      var _schedule$approachPoi3, _schedule$approachPoi4;
      const start = profile.lastCheckpoint;
      let minAlt = Infinity;
      const altConstraintsToUse = profile.descentAltitudeConstraints.map(constraint => {
        minAlt = Math.min(minAlt, minimumAltitude(constraint.constraint));
        return {
          distanceFromStart: constraint.distanceFromStart,
          minimumAltitude: minAlt
        };
      });
      const decelPointDistance = (_schedule$approachPoi3 = (_schedule$approachPoi4 = schedule.approachPoints[0]) === null || _schedule$approachPoi4 === void 0 ? void 0 : _schedule$approachPoi4.distanceFromStart) !== null && _schedule$approachPoi3 !== void 0 ? _schedule$approachPoi3 : Infinity;
      const speedConstraintsToUse = profile.descentSpeedConstraints.filter(_ref2 => {
        let {
          distanceFromStart
        } = _ref2;
        return distanceFromStart < decelPointDistance;
      });
      const phaseTable = new PhaseTable(this.observer.get(), windProfile);
      phaseTable.start = start;
      phaseTable.phases = [new DescendToAltitude(finalAltitude).withReasonAfter(VerticalCheckpointReason.CrossingFcuAltitudeDescent)];
      let isPathValid = false;
      let numRecomputations = 0;
      let sequence = null;
      while (!isPathValid && numRecomputations++ < 100) {
        sequence = phaseTable.execute(descentStrategy, this.levelFlightStrategy);
        isPathValid = this.checkForViolations(phaseTable, altConstraintsToUse, speedConstraintsToUse, speedProfile, schedule);
      }

      // It's possible that the last phase (which is the one that the phase table is initialized with) is not executed because we've already got below
      // the final altitude through a different segment. In this case, we need to make sure we still get the level off arrow.
      // One scenario where this happens is if the final altitude is the speed limit alt (e.g 10000). In this case, we insert a deceleration segment, which might end just
      // slightly below the speed limit alt (= final alt), and the phase table will not execute the last phase because we're already below the final alt.
      if (sequence.lastCheckpoint.reason === VerticalCheckpointReason.AtmosphericConditions) {
        sequence.lastCheckpoint.reason = VerticalCheckpointReason.CrossingFcuAltitudeDescent;
      }
      if (sequence != null) {
        profile.checkpoints.push(...sequence.get());
      }
    }

    /**
     * Check the path for violations and handle them. Return true if the path is valid, false otherwise.
     * @param phaseTable
     * @param profile
     * @param altitudeConstraints
     * @param speedProfile
     * @param schedule The speed schedule describing the managed profile
     * @returns
     */
    checkForViolations(phaseTable, altitudeConstraints, speedConstraints, speedProfile, schedule) {
      const {
        descentSpeedLimit
      } = this.observer.get();
      let previousResult = phaseTable.start;
      for (let i = 0; i < phaseTable.phases.length; i++) {
        const phase = phaseTable.phases[i];
        if (!phase.lastResult) {
          continue;
        }
        for (const approachPoint of schedule.approachPoints) {
          if (this.doesPhaseViolateApproachPoint(phase, approachPoint)) {
            this.handleApproachPointViolation(phaseTable, i, approachPoint);
            return false;
          }
        }
        for (const speedChange of schedule.speedChanges) {
          if (this.doesPhaseViolateSpeedChange(phase, speedChange)) {
            if (speedChange.reason === VerticalCheckpointReason.StartDecelerationToConstraint) {
              this.handleConstraintSpeedChangeViolation(phaseTable, i, speedChange);
            } else if (speedChange.reason === VerticalCheckpointReason.StartDecelerationToLimit) {
              this.handleLimitSpeedChangeViolation(phaseTable, i, speedChange);
            }
            return false;
          }
        }
        for (const speedConstraint of speedConstraints) {
          if (this.doesPhaseViolateSpeedConstraint(previousResult, phase, speedConstraint)) {
            this.handleSpeedConstraintViolation(phaseTable, i, speedConstraint);
            return false;
          }
        }
        for (const altitudeConstraint of altitudeConstraints) {
          if (this.doesPhaseViolateAltitudeConstraint(previousResult, phase, altitudeConstraint)) {
            this.handleAltitudeConstraintViolation(phaseTable, i, altitudeConstraint);
            return false;
          }
        }
        if (speedProfile.shouldTakeDescentSpeedLimitIntoAccount()) {
          if (this.doesPhaseViolateSpeedLimit(previousResult, phase, descentSpeedLimit)) {
            this.handleSpeedLimitViolation(phaseTable, i, descentSpeedLimit);
            return false;
          }
        }
        previousResult = phase.lastResult;
      }
      return true;
    }
    handleConstraintSpeedChangeViolation(phaseTable, violatingPhaseIndex, speedChange) {
      const violatingPhase = phaseTable.phases[violatingPhaseIndex];
      if (violatingPhase instanceof DescendingDeceleration) {
        // If we are already decelerating, make sure we decelerate to the correct speed
        violatingPhase.toSpeed = Math.min(speedChange.targetSpeed, violatingPhase.toSpeed);
      } else {
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToDistance(speedChange.distanceFromStart),
        // Use deceleration reason as before
        new DescendingDeceleration(speedChange.targetSpeed).withReasonBefore(speedChange.reason));
      }
    }
    handleLimitSpeedChangeViolation(phaseTable, violatingPhaseIndex, speedChange) {
      const violatingPhase = phaseTable.phases[violatingPhaseIndex];
      if (violatingPhase instanceof DescendingDeceleration) {
        // If we are already decelerating, make sure we decelerate to the correct speed
        violatingPhase.toSpeed = Math.min(speedChange.targetSpeed, violatingPhase.toSpeed);
        const overshoot = violatingPhase.lastResult.altitude - speedChange.altitude;

        // Try to find a previous phase that we can shorten to allow more deceleration
        for (let i = violatingPhaseIndex - 1; i >= 0; i--) {
          const previousPhase = phaseTable.phases[i];
          if (previousPhase instanceof DescendToAltitude) {
            previousPhase.toAltitude -= overshoot;
          } else if (previousPhase instanceof DescendToDistance) {
            phaseTable.phases.splice(i, 1, new DescendToAltitude(previousPhase.lastResult.altitude - overshoot));
          }
          return;
        }
      } else {
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToAltitude(speedChange.altitude), new DescendingDeceleration(speedChange.targetSpeed).withReasonBefore(VerticalCheckpointReason.StartDecelerationToLimit));
      }
    }
    handleSpeedConstraintViolation(phaseTable, violatingPhaseIndex, speedConstraint) {
      const violatingPhase = phaseTable.phases[violatingPhaseIndex];

      // If the deceleration is not long enough, extend it
      if (violatingPhase instanceof DescendingDeceleration) {
        // If we are already decelerating, make sure we decelerate to the correct speed
        violatingPhase.toSpeed = Math.min(speedConstraint.maxSpeed, violatingPhase.toSpeed);
        const overshoot = violatingPhase.lastResult.distanceFromStart - speedConstraint.distanceFromStart;

        // Try to find a previous phase that we can shorten to allow more deceleration
        for (let i = violatingPhaseIndex - 1; i >= 0; i--) {
          const previousPhase = phaseTable.phases[i];
          if (!previousPhase.lastResult) {
            continue;
          }
          if (previousPhase instanceof DescendToAltitude) {
            // If we need to decelerate earlier, then replace the altitude segment with a distance segment
            phaseTable.phases.splice(i, 1, new DescendToDistance(previousPhase.lastResult.distanceFromStart - overshoot));
            return;
          }
          if (previousPhase instanceof DescendToDistance) {
            previousPhase.toDistance -= overshoot;
            return;
          }
        }
      } else {
        // If we don't even have a deceleration segment yet, fly to 3 miles before constraint and add the segment
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToDistance(speedConstraint.distanceFromStart - 3), new DescendingDeceleration(speedConstraint.maxSpeed).withReasonBefore(VerticalCheckpointReason.StartDecelerationToConstraint));
      }
    }
    handleAltitudeConstraintViolation(phaseTable, violatingPhaseIndex, altitudeConstraint) {
      const violatingPhase = phaseTable.phases[violatingPhaseIndex];
      if (violatingPhase instanceof DescendingDeceleration) {
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendingDeceleration(violatingPhase.toSpeed).withReasonBefore(violatingPhase.reasonBefore).withMinAltitude(altitudeConstraint.minimumAltitude).withReasonAfter(VerticalCheckpointReason.LevelOffForDescentConstraint), new DescendingDeceleration(violatingPhase.toSpeed).asLevelSegment().withMaxDistance(altitudeConstraint.distanceFromStart));

        // Transfer reason at start of this leg (`reasonBefore`) to leg that was inserted behind this one
        violatingPhase.reasonBefore = VerticalCheckpointReason.AtmosphericConditions;
      } else if (violatingPhase instanceof DescendToAltitude) {
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToAltitude(altitudeConstraint.minimumAltitude).withReasonAfter(VerticalCheckpointReason.LevelOffForDescentConstraint), new DescendToDistance(altitudeConstraint.distanceFromStart).asLevelSegment());
      } else if (violatingPhase instanceof DescendToDistance) {
        if (altitudeConstraint.distanceFromStart < violatingPhase.toDistance) {
          // If the altitude constraint comes before the distance we want to achieve, level off at the the constraint alitude, fly level to the constraint, then continue
          // descending to the original distance
          phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToAltitude(altitudeConstraint.minimumAltitude).withReasonAfter(VerticalCheckpointReason.LevelOffForDescentConstraint), new DescendToDistance(altitudeConstraint.distanceFromStart).asLevelSegment());
        } else {
          // If the altitude constraint comes after the distance we want to achieve, level off at the the constraint alitude, fly level to the original distance
          phaseTable.phases.splice(violatingPhaseIndex, 1, new DescendToAltitude(altitudeConstraint.minimumAltitude).withReasonAfter(VerticalCheckpointReason.LevelOffForDescentConstraint), new DescendToDistance(violatingPhase.toDistance).asLevelSegment());
        }
      }
    }
    handleSpeedLimitViolation(phaseTable, violatingPhaseIndex, speedLimit) {
      const violatingPhase = phaseTable.phases[violatingPhaseIndex];
      if (violatingPhase instanceof DescendingDeceleration) {
        violatingPhase.toSpeed = Math.min(speedLimit.speed, violatingPhase.toSpeed);
        const overshoot = violatingPhase.lastResult.altitude - speedLimit.underAltitude; // This is typically negative

        for (let i = violatingPhaseIndex - 1; i >= 0; i--) {
          const previousPhase = phaseTable.phases[i];

          // If the previous phase has not been calculated, it probably means that we are already at the distance/altitude that it was aiming for,
          // so we should not try to shorten it.
          if (!previousPhase.lastResult) {
            continue;
          }
          if (previousPhase instanceof DescendToAltitude) {
            previousPhase.toAltitude -= overshoot;
          } else if (previousPhase instanceof DescendToDistance) {
            phaseTable.phases.splice(violatingPhaseIndex, 1, new DescendToAltitude(previousPhase.lastResult.altitude - overshoot));
          }
          return;
        }
      } else {
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToAltitude(speedLimit.underAltitude + 100), new DescendingDeceleration(speedLimit.speed).withReasonBefore(VerticalCheckpointReason.StartDecelerationToLimit));
      }
    }
    handleApproachPointViolation(phaseTable, violatingPhaseIndex, approachPoint) {
      const violatingPhase = phaseTable.phases[violatingPhaseIndex];
      if (violatingPhase instanceof DescendingDeceleration) {
        // If we are already decelerating, make sure we decelerate to the correct speed
        violatingPhase.toSpeed = Math.min(approachPoint.targetSpeed, violatingPhase.toSpeed);
      } else {
        phaseTable.phases.splice(violatingPhaseIndex, 0, new DescendToDistance(approachPoint.distanceFromStart), new DescendingDeceleration(approachPoint.targetSpeed));
      }
    }
    doesPhaseViolateApproachPoint(phase, approachPoint) {
      // We're still before the point
      if (phase.lastResult.distanceFromStart <= approachPoint.distanceFromStart) {
        return false;
      }
      if (phase instanceof DescendingDeceleration) {
        return phase.toSpeed > approachPoint.targetSpeed;
      }
      return phase.lastResult.speed > approachPoint.targetSpeed;
    }
    doesPhaseViolateSpeedChange(phase, speedChange) {
      if (speedChange.reason === VerticalCheckpointReason.StartDecelerationToLimit) {
        if (phase.lastResult.altitude >= speedChange.altitude) {
          return false;
        }
      } else if (phase.lastResult.distanceFromStart <= speedChange.distanceFromStart) {
        return false;
      }
      if (phase instanceof DescendingDeceleration) {
        return phase.toSpeed > speedChange.targetSpeed;
      }
      return phase.lastResult.speed > speedChange.targetSpeed;
    }
    doesPhaseViolateSpeedConstraint(previousResult, phase, speedConstraint) {
      // We're still before the constraint
      if (phase.lastResult.distanceFromStart < speedConstraint.distanceFromStart) {
        return false;
      }

      // We had already passed the constraint
      if (previousResult.distanceFromStart > speedConstraint.distanceFromStart) {
        // We only "violate" the constraint if we don't decelerate at all (i.e not on deceleration segment) or to the incorrect speed
        return phase instanceof DescendingDeceleration ? phase.toSpeed > speedConstraint.maxSpeed : previousResult.speed > speedConstraint.maxSpeed;
      }

      // Now that we're sure, we pass the constraint on this exact segment, check what speed we were at
      const speedChangePerDistance = (previousResult.speed - phase.lastResult.speed) / (previousResult.distanceFromStart - phase.lastResult.distanceFromStart);
      const speedAtConstraint = phase.lastResult.speed + speedChangePerDistance * (speedConstraint.distanceFromStart - phase.lastResult.distanceFromStart);
      return speedAtConstraint - speedConstraint.maxSpeed > 1;
    }
    doesPhaseViolateAltitudeConstraint(previousResult, phase, altitudeConstraint) {
      if (phase.lastResult.altitude - altitudeConstraint.minimumAltitude >= -1 // We're still above the constraint
      || previousResult.altitude - altitudeConstraint.minimumAltitude < -100 // We were already more than 100 ft below the constraint before this subphase
      || previousResult.distanceFromStart >= altitudeConstraint.distanceFromStart // We're already behind the constraint
      || phase.shouldFlyAsLevelSegment // A level segment already tries its best at not violating the constraint
      ) {
        return false;
      }
      const gradient = (previousResult.altitude - phase.lastResult.altitude) / (previousResult.distanceFromStart - phase.lastResult.distanceFromStart);
      const altAtConstraint = previousResult.altitude + gradient * (altitudeConstraint.distanceFromStart - previousResult.distanceFromStart);
      return altAtConstraint < altitudeConstraint.minimumAltitude;
    }
    doesPhaseViolateSpeedLimit(previousResult, phase, speedLimit) {
      // We're still above the limit
      if (phase.lastResult.altitude > speedLimit.underAltitude) {
        return false;
      }

      // We had already passed the constraint
      if (previousResult.altitude < speedLimit.underAltitude) {
        // We only "violate" the constraint if we don't decelerate at all (i.e not on deceleration segment) or to the incorrect speed
        return phase instanceof DescendingDeceleration ? phase.toSpeed > speedLimit.speed : previousResult.speed > speedLimit.speed;
      }

      // Now that we're sure, we pass the limit on this exact segment, check what speed we were at
      const speedChangePerAltitude = (previousResult.speed - phase.lastResult.speed) / (previousResult.altitude - phase.lastResult.altitude);
      const speedAtSpeedLimitAlt = phase.lastResult.speed + speedChangePerAltitude * (speedLimit.underAltitude - phase.lastResult.altitude);
      return speedAtSpeedLimitAlt - speedLimit.speed > 1;
    }
  }
  function minimumAltitude(constraint) {
    switch (constraint.type) {
      case AltitudeConstraintType.at:
      case AltitudeConstraintType.atOrAbove:
        return constraint.altitude1;
      case AltitudeConstraintType.atOrBelow:
        return -Infinity;
      case AltitudeConstraintType.range:
        return constraint.altitude2;
      default:
        console.error("[FMS/VNAV] Unexpected constraint type: ".concat(constraint.type));
        return -Infinity;
    }
  }
  class PhaseTable {
    constructor(parameters, winds) {
      this.parameters = parameters;
      this.winds = winds;
      _defineProperty(this, "start", void 0);
      _defineProperty(this, "phases", []);
    }
    execute(descentStrategy, levelFlightStrategy) {
      const sequence = new TemporaryCheckpointSequence(this.start);
      for (const phase of this.phases) {
        if (phase.reasonBefore !== VerticalCheckpointReason.AtmosphericConditions) {
          if (sequence.lastCheckpoint.reason === VerticalCheckpointReason.AtmosphericConditions) {
            sequence.lastCheckpoint.reason = phase.reasonBefore;
          } else {
            sequence.copyLastCheckpoint({
              reason: phase.reasonBefore
            });
          }
        }
        if (phase.shouldExecute(sequence.lastCheckpoint)) {
          const headwind = this.winds.getHeadwindComponent(sequence.lastCheckpoint.distanceFromStart, sequence.lastCheckpoint.altitude);
          const configuration = AircraftConfigurationProfile.getBySpeed(sequence.lastCheckpoint.speed, this.parameters);
          const phaseResult = phase.execute(phase.shouldFlyAsLevelSegment ? levelFlightStrategy : descentStrategy)(sequence.lastCheckpoint, headwind, configuration);
          if (phase instanceof DescendingDeceleration) {
            sequence.lastCheckpoint.targetSpeed = phase.toSpeed;
          }
          sequence.addCheckpointFromStep(phaseResult, phase.reasonAfter);
          phase.lastResult = sequence.lastCheckpoint;
        } else {
          phase.lastResult = null;
        }
      }
      return sequence;
    }
  }
  class SubPhase {
    constructor() {
      _defineProperty(this, "lastResult", null);
      _defineProperty(this, "isLevelSegment", false);
      _defineProperty(this, "reasonAfter", VerticalCheckpointReason.AtmosphericConditions);
      _defineProperty(this, "reasonBefore", VerticalCheckpointReason.AtmosphericConditions);
    }
    get shouldFlyAsLevelSegment() {
      return this.isLevelSegment;
    }
    scaleStepBasedOnLastCheckpoint(lastCheckpoint, step, scaling) {
      step.distanceTraveled *= scaling;
      step.fuelBurned *= scaling;
      step.timeElapsed *= scaling;
      step.finalAltitude = (1 - scaling) * lastCheckpoint.altitude + scaling * step.finalAltitude;
      step.speed = (1 - scaling) * lastCheckpoint.speed + scaling * step.speed;
    }
    withReasonBefore(reason) {
      this.reasonBefore = reason;
      return this;
    }
    withReasonAfter(reason) {
      this.reasonAfter = reason;
      return this;
    }
  }
  class DescendingDeceleration extends SubPhase {
    constructor(toSpeed) {
      super();
      this.toSpeed = toSpeed;
      _defineProperty(this, "maxDistance", Infinity);
      _defineProperty(this, "minAltitude", -Infinity);
    }
    withMaxDistance(maxDistance) {
      this.maxDistance = maxDistance;
      return this;
    }
    withMinAltitude(minAltitude) {
      this.minAltitude = minAltitude;
      return this;
    }
    asLevelSegment() {
      this.isLevelSegment = true;
      return this;
    }
    shouldExecute(start) {
      return start.speed > this.toSpeed && start.distanceFromStart < this.maxDistance && (this.shouldFlyAsLevelSegment || start.altitude > this.minAltitude);
    }
    execute(strategy) {
      return (start, headwind, configuration) => {
        const step = strategy.predictToSpeed(start.altitude, this.toSpeed, start.speed, start.mach, start.remainingFuelOnBoard, headwind, configuration);
        if (step.finalAltitude < this.minAltitude || start.distanceFromStart + step.distanceTraveled > this.maxDistance) {
          const scaling = Math.max(0, Math.min((this.maxDistance - start.distanceFromStart) / step.distanceTraveled, (start.altitude - this.minAltitude) / (start.altitude - step.finalAltitude), 1));
          this.scaleStepBasedOnLastCheckpoint(start, step, scaling);
        }
        return step;
      };
    }
  }
  class DescendToAltitude extends SubPhase {
    constructor(toAltitude) {
      super();
      this.toAltitude = toAltitude;
    }
    shouldExecute(start) {
      return start.altitude > this.toAltitude;
    }
    execute(strategy) {
      return (start, headwind) => strategy.predictToAltitude(start.altitude, this.toAltitude, start.speed, start.mach, start.remainingFuelOnBoard, headwind);
    }
  }
  class DescendToDistance extends SubPhase {
    constructor(toDistance) {
      super();
      this.toDistance = toDistance;
      _defineProperty(this, "minAltitude", -Infinity);
    }
    asLevelSegment() {
      this.isLevelSegment = true;
      return this;
    }
    shouldExecute(start) {
      return start.distanceFromStart < this.toDistance;
    }
    execute(strategy) {
      return (start, headwind, configuration) => {
        const step = strategy.predictToDistance(start.altitude, this.toDistance - start.distanceFromStart, start.speed, start.mach, start.remainingFuelOnBoard, headwind, configuration);
        if (step.finalAltitude < this.minAltitude) {
          const scaling = (this.minAltitude - start.altitude) / (step.finalAltitude - start.altitude);
          this.scaleStepBasedOnLastCheckpoint(start, step, scaling);
        }
        return step;
      };
    }
  }

  class HeadwindProfile {
    constructor(windProfile, headingProfile) {
      this.windProfile = windProfile;
      this.headingProfile = headingProfile;
    }

    /**
     * Returns the predicted headwind component at a given distanceFromStart and altitude
     * @param distanceFromStart
     * @param altitude
     * @returns
     */
    getHeadwindComponent(distanceFromStart, altitude) {
      const heading = this.headingProfile.get(distanceFromStart);
      if (heading === null) {
        return WindComponent.zero();
      }
      return this.windProfile.getHeadwindComponent(distanceFromStart, altitude, heading);
    }
  }

  class ClimbPathBuilder {
    constructor(computationParametersObserver, atmosphericConditions) {
      this.computationParametersObserver = computationParametersObserver;
      this.atmosphericConditions = atmosphericConditions;
    }

    /**
     * Compute climb profile assuming climb thrust until top of climb.
     * @param profile
     * @returns
     */
    computeClimbPath(profile, climbStrategy, speedProfile, windProfile, targetAltitude) {
      const {
        fcuVerticalMode,
        fcuArmedVerticalMode
      } = this.computationParametersObserver.get();
      this.addClimbSteps(profile, climbStrategy, speedProfile, windProfile, targetAltitude, VerticalCheckpointReason.TopOfClimb);
      if (this.shouldAddFcuAltAsCheckpoint(fcuVerticalMode, fcuArmedVerticalMode)) {
        this.addFcuAltitudeAsCheckpoint(profile);
      }
      if (speedProfile.shouldTakeClimbSpeedLimitIntoAccount()) {
        this.addSpeedLimitAsCheckpoint(profile);
      }
    }
    addClimbSteps(profile, climbStrategy, speedProfile, windProfile, finalAltitude) {
      let finalAltitudeReason = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : VerticalCheckpointReason.AtmosphericConditions;
      const {
        managedClimbSpeedMach
      } = this.computationParametersObserver.get();
      for (const constraint of profile.maxAltitudeConstraints) {
        const {
          maxAltitude: constraintAltitude,
          distanceFromStart: constraintDistanceFromStart
        } = constraint;
        if (constraintAltitude >= finalAltitude) {
          break;
        }
        if (constraintAltitude > profile.lastCheckpoint.altitude) {
          // Continue climb
          if (profile.lastCheckpoint.reason === VerticalCheckpointReason.AltitudeConstraint) {
            profile.lastCheckpoint.reason = VerticalCheckpointReason.ContinueClimb;
          }

          // Mark where we are
          let indexToResetTo = profile.checkpoints.length;
          // Try going to the next altitude
          this.buildIteratedClimbSegment(profile, climbStrategy, speedProfile, windProfile, profile.lastCheckpoint.altitude, constraintAltitude);
          let currentSpeedConstraint = speedProfile.getMaxClimbSpeedConstraint(profile.lastCheckpoint.distanceFromStart);
          for (let i = 0; i++ < 10 && currentSpeedConstraint; currentSpeedConstraint = speedProfile.getMaxClimbSpeedConstraint(profile.lastCheckpoint.distanceFromStart)) {
            // This means we did not pass a constraint during the climb
            if (currentSpeedConstraint.distanceFromStart > profile.lastCheckpoint.distanceFromStart) {
              break;
            }

            // Reset
            profile.checkpoints.splice(indexToResetTo);

            // Use distance step instead
            this.buildIteratedDistanceStep(profile, climbStrategy, windProfile, currentSpeedConstraint.distanceFromStart - profile.lastCheckpoint.distanceFromStart, managedClimbSpeedMach, VerticalCheckpointReason.SpeedConstraint);

            // Repeat
            indexToResetTo = profile.checkpoints.length;
            this.buildIteratedClimbSegment(profile, climbStrategy, speedProfile, windProfile, profile.lastCheckpoint.altitude, constraintAltitude);
          }

          // We reach the target altitude before the constraint, so we insert a level segment.
          if (profile.lastCheckpoint.distanceFromStart < constraintDistanceFromStart) {
            profile.lastCheckpoint.reason = VerticalCheckpointReason.LevelOffForClimbConstraint;
            this.addLevelSegmentSteps(profile, speedProfile, constraintDistanceFromStart);
          }
        } else if (Math.abs(profile.lastCheckpoint.altitude - constraintAltitude) < 250) {
          // Continue in level flight to the next constraint
          this.addLevelSegmentSteps(profile, speedProfile, constraintDistanceFromStart);
        }
      }
      if (profile.lastCheckpoint.reason === VerticalCheckpointReason.AltitudeConstraint) {
        profile.lastCheckpoint.reason = VerticalCheckpointReason.ContinueClimb;
      }

      // We get here if there are still waypoints with speed constrainst after all the altitude constraints
      for (const speedConstraint of profile.maxClimbSpeedConstraints) {
        const {
          distanceFromStart,
          altitude,
          speed,
          remainingFuelOnBoard
        } = profile.lastCheckpoint;
        if (distanceFromStart > speedConstraint.distanceFromStart) {
          continue;
        }
        const speedTarget = speedProfile.getTarget(distanceFromStart, altitude, ManagedSpeedType.Climb);
        if (speedTarget - speed > 1) {
          const headwind = windProfile.getHeadwindComponent(distanceFromStart, altitude);
          const accelerationStep = climbStrategy.predictToSpeed(altitude, speedTarget, speed, managedClimbSpeedMach, remainingFuelOnBoard, headwind);

          // If we shoot through the final altitude trying to accelerate, pretend we didn't accelerate all the way
          if (accelerationStep.finalAltitude > finalAltitude) {
            const scaling = accelerationStep.finalAltitude - accelerationStep.initialAltitude !== 0 ? (finalAltitude - accelerationStep.initialAltitude) / (accelerationStep.finalAltitude - accelerationStep.initialAltitude) : 0;
            this.scaleStepBasedOnLastCheckpoint(profile.lastCheckpoint, accelerationStep, scaling);
          }
          this.addCheckpointFromStep(profile, accelerationStep, VerticalCheckpointReason.AtmosphericConditions);
        }
        if (speedConstraint.distanceFromStart > profile.lastCheckpoint.distanceFromStart) {
          this.buildIteratedDistanceStep(profile, climbStrategy, windProfile, speedConstraint.distanceFromStart - profile.lastCheckpoint.distanceFromStart, managedClimbSpeedMach, VerticalCheckpointReason.SpeedConstraint);

          // This occurs if we somehow overshot the target altitude
          if (profile.lastCheckpoint.altitude > finalAltitude) {
            // Remove all checkpoints that are above the final altitude
            profile.checkpoints = profile.checkpoints.filter(c => c.altitude <= finalAltitude);

            // Use an altitude step instead
            this.buildIteratedClimbSegment(profile, climbStrategy, speedProfile, windProfile, profile.lastCheckpoint.altitude, finalAltitude);
          }
        }
      }

      // We get here if we have passed all speed and altitude constraints, but are not at our final altitude yet.
      this.buildIteratedClimbSegment(profile, climbStrategy, speedProfile, windProfile, profile.lastCheckpoint.altitude, finalAltitude);
      profile.lastCheckpoint.reason = finalAltitudeReason;
    }
    buildIteratedClimbSegment(profile, climbStrategy, speedProfile, windProfile, startingAltitude, targetAltitude) {
      const {
        managedClimbSpeedMach
      } = this.computationParametersObserver.get();

      // This is just to prevent a potential infinite loop
      let i = 0;
      for (let altitude = startingAltitude; i++ < 100 && altitude < targetAltitude;) {
        const {
          speed,
          remainingFuelOnBoard,
          distanceFromStart
        } = profile.lastCheckpoint;
        const speedTarget = speedProfile.getTarget(distanceFromStart, altitude, ManagedSpeedType.Climb);
        const isAboveCrossoverAltitude = speedTarget > this.atmosphericConditions.computeCasFromMach(altitude, managedClimbSpeedMach);
        const headwind = windProfile.getHeadwindComponent(distanceFromStart, altitude);

        // If we're below the target speed, we need to accelerate, unless we're above the crossover altitude. In that case, IAS is always below the managed IAS speed.
        const step = isAboveCrossoverAltitude || speedTarget - speed < 1 ? climbStrategy.predictToAltitude(altitude, Math.min(altitude + 1500, targetAltitude), speedTarget, managedClimbSpeedMach, remainingFuelOnBoard, headwind) : climbStrategy.predictToSpeed(altitude, speedTarget, speed, managedClimbSpeedMach, remainingFuelOnBoard, headwind);
        if (step.finalAltitude - targetAltitude > 10) {
          const scaling = step.finalAltitude - step.initialAltitude !== 0 ? (targetAltitude - step.initialAltitude) / (step.finalAltitude - step.initialAltitude) : 0;
          this.scaleStepBasedOnLastCheckpoint(profile.lastCheckpoint, step, scaling);
        }
        this.addCheckpointFromStep(profile, step, VerticalCheckpointReason.AtmosphericConditions);
        altitude = step.finalAltitude;
      }
    }
    buildIteratedDistanceStep(profile, climbStrategy, windProfile, distance, mach, reason) {
      let distanceCrossed = 0;
      for (; distanceCrossed + 3 < distance; distanceCrossed += 3) {
        // The reason we don't check the actual distance travelled is because we don't want to have an infinite loop if the distance step travels no distance for some reason.
        // With this loop, it terminates at some point at least
        this.distanceStepFromLastCheckpoint(profile, climbStrategy, windProfile, 3, mach, VerticalCheckpointReason.AtmosphericConditions);
      }
      this.distanceStepFromLastCheckpoint(profile, climbStrategy, windProfile, distance - distanceCrossed, mach, reason);
    }
    distanceStepFromLastCheckpoint(profile, climbStrategy, windProfile, distance, mach, reason) {
      const {
        managedClimbSpeedMach
      } = this.computationParametersObserver.get();
      const {
        distanceFromStart,
        altitude,
        speed: initialSpeed,
        remainingFuelOnBoard
      } = profile.lastCheckpoint;
      const headwind = windProfile.getHeadwindComponent(distanceFromStart, altitude);
      const step = climbStrategy.predictToDistance(altitude, distance, initialSpeed, managedClimbSpeedMach, remainingFuelOnBoard, headwind);
      this.addCheckpointFromStep(profile, step, reason);
    }
    addLevelSegmentSteps(profile, speedProfile, toDistanceFromStart) {
      // The only reason we have to build this iteratively is because there could be speed constraints along the way
      const altitude = profile.lastCheckpoint.altitude;

      // Go over all constraints
      for (const speedConstraint of profile.maxClimbSpeedConstraints) {
        // Ignore constraint since we're already past it
        if (profile.lastCheckpoint.distanceFromStart >= speedConstraint.distanceFromStart || toDistanceFromStart <= speedConstraint.distanceFromStart) {
          continue;
        }
        const currentSpeed = profile.lastCheckpoint.speed;
        const speedTarget = speedProfile.getTarget(profile.lastCheckpoint.distanceFromStart, altitude, ManagedSpeedType.Climb);
        if (speedTarget > currentSpeed) {
          const step = this.computeLevelFlightAccelerationStep(altitude, currentSpeed, speedTarget, profile.lastCheckpoint.remainingFuelOnBoard);

          // We could not accelerate in time
          if (profile.lastCheckpoint.distanceFromStart + step.distanceTraveled > speedConstraint.distanceFromStart) {
            const scaling = step.distanceTraveled / (speedConstraint.distanceFromStart - profile.lastCheckpoint.distanceFromStart);
            this.scaleStepBasedOnLastCheckpoint(profile.lastCheckpoint, step, scaling);
            this.addCheckpointFromStep(profile, step, VerticalCheckpointReason.AtmosphericConditions);
            continue;
          } else {
            // End of acceleration
            this.addCheckpointFromStep(profile, step, VerticalCheckpointReason.AtmosphericConditions);
          }
        }

        // Compute step after accelerating to next constraint
        const levelStepToConstraint = this.computeLevelFlightSegmentPrediction(speedConstraint.distanceFromStart - profile.lastCheckpoint.distanceFromStart, altitude, profile.lastCheckpoint.speed, profile.lastCheckpoint.remainingFuelOnBoard);
        this.addCheckpointFromStep(profile, levelStepToConstraint, VerticalCheckpointReason.AltitudeConstraint);
      }

      // TODO: This exact piece of code appears a couple of lines above, extract to function!
      const currentSpeed = profile.lastCheckpoint.speed;
      const speedTarget = speedProfile.getTarget(profile.lastCheckpoint.distanceFromStart, altitude, ManagedSpeedType.Climb);
      if (speedTarget > currentSpeed) {
        const accelerationStep = this.computeLevelFlightAccelerationStep(altitude, currentSpeed, speedTarget, profile.lastCheckpoint.remainingFuelOnBoard);

        // We could not accelerate in time
        if (profile.lastCheckpoint.distanceFromStart + accelerationStep.distanceTraveled > toDistanceFromStart) {
          const scaling = accelerationStep.distanceTraveled / (toDistanceFromStart - profile.lastCheckpoint.distanceFromStart);
          this.scaleStepBasedOnLastCheckpoint(profile.lastCheckpoint, accelerationStep, scaling);
          this.addCheckpointFromStep(profile, accelerationStep, VerticalCheckpointReason.AtmosphericConditions);
          return;
        }

        // End of acceleration
        this.addCheckpointFromStep(profile, accelerationStep, VerticalCheckpointReason.AtmosphericConditions);
      }
      const levelStepToConstraint = this.computeLevelFlightSegmentPrediction(toDistanceFromStart - profile.lastCheckpoint.distanceFromStart, altitude, profile.lastCheckpoint.speed, profile.lastCheckpoint.remainingFuelOnBoard);
      this.addCheckpointFromStep(profile, levelStepToConstraint, VerticalCheckpointReason.AltitudeConstraint);
    }
    computeLevelFlightSegmentPrediction(stepSize, altitude, initialSpeed, fuelWeight) {
      const {
        zeroFuelWeight,
        managedClimbSpeedMach,
        tropoPause
      } = this.computationParametersObserver.get();
      return Predictions.levelFlightStep(altitude, stepSize, initialSpeed, managedClimbSpeedMach, zeroFuelWeight, fuelWeight, 0, this.atmosphericConditions.isaDeviation, tropoPause);
    }
    computeLevelFlightAccelerationStep(altitude, initialSpeed, speedTarget, fuelWeight) {
      const {
        zeroFuelWeight,
        managedClimbSpeedMach,
        tropoPause
      } = this.computationParametersObserver.get();
      return Predictions.speedChangeStep(0, altitude, initialSpeed, speedTarget, managedClimbSpeedMach, managedClimbSpeedMach, getClimbThrustN1Limit(this.atmosphericConditions, altitude, (initialSpeed + speedTarget) / 2, managedClimbSpeedMach),
      // TOD0
      zeroFuelWeight, fuelWeight, 0, this.atmosphericConditions.isaDeviation, tropoPause);
    }
    addSpeedLimitAsCheckpoint(profile) {
      const {
        climbSpeedLimit: {
          underAltitude
        },
        presentPosition: {
          alt
        },
        cruiseAltitude
      } = this.computationParametersObserver.get();
      if (underAltitude <= alt || underAltitude > cruiseAltitude) {
        return;
      }
      const distance = profile.interpolateDistanceAtAltitude(underAltitude);
      profile.addInterpolatedCheckpoint(distance, {
        reason: VerticalCheckpointReason.CrossingClimbSpeedLimit
      });
    }
    addFcuAltitudeAsCheckpoint(profile) {
      const {
        fcuAltitude,
        presentPosition,
        cruiseAltitude
      } = this.computationParametersObserver.get();
      if (fcuAltitude <= presentPosition.alt || fcuAltitude > cruiseAltitude) {
        return;
      }
      const distance = profile.interpolateDistanceAtAltitude(fcuAltitude);
      profile.addInterpolatedCheckpoint(distance, {
        reason: VerticalCheckpointReason.CrossingFcuAltitudeClimb
      });
    }
    shouldAddFcuAltAsCheckpoint(verticalMode, armedVerticalMode) {
      const verticalModesToShowLevelOffArrowFor = [VerticalMode.OP_CLB, VerticalMode.VS, VerticalMode.FPA, VerticalMode.CLB, VerticalMode.SRS, VerticalMode.SRS_GA];
      return isArmed(armedVerticalMode, ArmedVerticalMode.CLB) || verticalModesToShowLevelOffArrowFor.includes(verticalMode);
    }
    addCheckpointFromStep(profile, step, reason) {
      profile.addCheckpointFromLast(_ref => {
        let {
          distanceFromStart,
          secondsFromPresent,
          remainingFuelOnBoard
        } = _ref;
        return {
          reason,
          distanceFromStart: distanceFromStart + step.distanceTraveled,
          altitude: step.finalAltitude,
          secondsFromPresent: secondsFromPresent + step.timeElapsed,
          speed: step.speed,
          remainingFuelOnBoard: remainingFuelOnBoard - step.fuelBurned,
          mach: this.computationParametersObserver.get().managedClimbSpeedMach
        };
      });
    }
    scaleStepBasedOnLastCheckpoint(lastCheckpoint, step, scaling) {
      step.distanceTraveled *= scaling;
      step.fuelBurned *= scaling;
      step.timeElapsed *= scaling;
      step.finalAltitude = (1 - scaling) * lastCheckpoint.altitude + scaling * step.finalAltitude;
      step.speed = (1 - scaling) * lastCheckpoint.speed + scaling * step.speed;
    }
  }

  // TODO: Deduplicate this from here and ClimbStrategy.ts
  function getClimbThrustN1Limit(atmosphericConditions, altitude, speed, maxMach) {
    const climbSpeedMach = Math.min(maxMach, atmosphericConditions.computeMachFromCas(altitude, speed));
    const estimatedTat = atmosphericConditions.totalAirTemperatureFromMach(altitude, climbSpeedMach);
    return EngineModel.tableInterpolation(EngineModel.maxClimbThrustTableLeap, estimatedTat, altitude);
  }

  class VerticalProfileManager {
    constructor(guidanceController, observer, atmosphericConditions, constraintReader, headingProfile, windProfileFactory, aircraftToDescentProfileRelation) {
      this.guidanceController = guidanceController;
      this.observer = observer;
      this.atmosphericConditions = atmosphericConditions;
      this.constraintReader = constraintReader;
      this.headingProfile = headingProfile;
      this.windProfileFactory = windProfileFactory;
      this.aircraftToDescentProfileRelation = aircraftToDescentProfileRelation;
      _defineProperty(this, "takeoffPathBuilder", void 0);
      _defineProperty(this, "climbPathBuilder", void 0);
      _defineProperty(this, "cruisePathBuilder", void 0);
      _defineProperty(this, "tacticalDescentPathBuilder", void 0);
      _defineProperty(this, "managedDescentPathBuilder", void 0);
      _defineProperty(this, "approachPathBuilder", void 0);
      _defineProperty(this, "cruiseToDescentCoordinator", void 0);
      _defineProperty(this, "fcuModes", void 0);
      _defineProperty(this, "descentProfile", void 0);
      _defineProperty(this, "ndProfile", void 0);
      _defineProperty(this, "mcduProfile", void 0);
      _defineProperty(this, "expediteProfile", void 0);
      this.takeoffPathBuilder = new TakeoffPathBuilder(observer, this.atmosphericConditions);
      this.climbPathBuilder = new ClimbPathBuilder(observer, this.atmosphericConditions);
      this.cruisePathBuilder = new CruisePathBuilder(observer, this.atmosphericConditions);
      this.tacticalDescentPathBuilder = new TacticalDescentPathBuilder(this.observer, this.atmosphericConditions);
      this.managedDescentPathBuilder = new DescentPathBuilder(observer, this.atmosphericConditions);
      this.approachPathBuilder = new ApproachPathBuilder(observer, this.atmosphericConditions);
      this.cruiseToDescentCoordinator = new CruiseToDescentCoordinator(observer, this.cruisePathBuilder, this.managedDescentPathBuilder, this.approachPathBuilder);
      this.fcuModes = new FcuModeObserver(observer);
    }

    // PROFILE COMPUTATIONS

    computeTacticalMcduPath() {
      const {
        flightPhase,
        presentPosition,
        fuelOnBoard,
        approachSpeed,
        cruiseAltitude
      } = this.observer.get();
      const managedClimbStrategy = new ClimbThrustClimbStrategy(this.observer, this.atmosphericConditions);
      const stepDescentStrategy = new VerticalSpeedStrategy(this.observer, this.atmosphericConditions, -1000);
      const climbWinds = new HeadwindProfile(this.windProfileFactory.getClimbWinds(), this.headingProfile);
      const cruiseWinds = new HeadwindProfile(this.windProfileFactory.getCruiseWinds(), this.headingProfile);
      const descentWinds = new HeadwindProfile(this.windProfileFactory.getDescentWinds(), this.headingProfile);
      const mcduProfile = new NavGeometryProfile(this.guidanceController, this.constraintReader, this.atmosphericConditions);
      const speedProfile = new McduSpeedProfile(this.observer, this.constraintReader.distanceToPresentPosition, this.constraintReader.climbSpeedConstraints, this.constraintReader.descentSpeedConstraints);
      if (flightPhase < FmgcFlightPhase.Climb) {
        this.takeoffPathBuilder.buildTakeoffPath(mcduProfile);
      } else {
        mcduProfile.addPresentPositionCheckpoint(presentPosition, fuelOnBoard, this.getManagedMachTarget(), this.getVman(approachSpeed));
      }
      if (flightPhase < FmgcFlightPhase.Cruise) {
        this.climbPathBuilder.computeClimbPath(mcduProfile, managedClimbStrategy, speedProfile, climbWinds, cruiseAltitude);
      }
      if (this.aircraftToDescentProfileRelation.isValid && (flightPhase >= FmgcFlightPhase.Descent && flightPhase <= FmgcFlightPhase.Approach || this.aircraftToDescentProfileRelation.isPastTopOfDescent())) {
        const offset = this.computeTacticalToGuidanceProfileOffset();
        const schedule = this.getDecelerationScheduleFromDescentPath(offset);
        this.tacticalDescentPathBuilder.buildMcduPredictionPath(mcduProfile, this.getDesModeStrategy(), speedProfile, descentWinds, schedule);
        this.mergeMcduWithGuidanceProfile(mcduProfile, offset);
      } else {
        this.cruiseToDescentCoordinator.buildCruiseAndDescentPath(mcduProfile, speedProfile, cruiseWinds, descentWinds, managedClimbStrategy, stepDescentStrategy);
      }
      this.mcduProfile = mcduProfile;
      this.mcduProfile.finalizeProfile();
    }
    computeDescentPath() {
      const descentProfile = new NavGeometryProfile(this.guidanceController, this.constraintReader, this.atmosphericConditions);
      const speedProfile = new McduSpeedProfile(this.observer, this.constraintReader.distanceToPresentPosition, this.constraintReader.climbSpeedConstraints, this.constraintReader.descentSpeedConstraints);
      const descentWinds = new HeadwindProfile(this.windProfileFactory.getDescentWinds(), this.headingProfile);
      const {
        estimatedDestinationFuel
      } = this.observer.get();
      // Use INIT FUEL PRED entry as initial estimate for destination EFOB. Clamp it to avoid potentially crashing predictions entirely from erroneous pilot input.
      const fuelEstimation = Number.isFinite(estimatedDestinationFuel) ? Math.min(Math.max(estimatedDestinationFuel, 0), VnavConfig.MAXIMUM_FUEL_ESTIMATE) : 4000;
      const finalCruiseAltitude = this.cruisePathBuilder.getFinalCruiseAltitude(descentProfile.cruiseSteps);
      const sequence = this.approachPathBuilder.computeApproachPath(descentProfile, speedProfile, descentWinds, fuelEstimation, 0);
      this.managedDescentPathBuilder.computeManagedDescentPath(sequence, descentProfile, speedProfile, descentWinds, finalCruiseAltitude);
      descentProfile.checkpoints.push(...sequence.get(true).reverse());
      this.descentProfile = descentProfile;
      this.descentProfile.finalizeProfile();
    }
    computeVerticalProfileForExpediteClimb() {
      try {
        const {
          approachSpeed,
          fcuAltitude,
          presentPosition,
          fuelOnBoard,
          managedClimbSpeedMach
        } = this.observer.get();

        // TODO: I wonder where GD speed comes from IRL. Should probably be an FMGC computation rather than FAC since it's just for predictions
        const greenDotSpeed = Simplane.getGreenDotSpeed();
        if (!greenDotSpeed) {
          return;
        }
        const selectedSpeedProfile = new ExpediteSpeedProfile(greenDotSpeed);
        this.expediteProfile = new SelectedGeometryProfile();
        const climbStrategy = new ClimbThrustClimbStrategy(this.observer, this.atmosphericConditions);
        const climbWinds = new HeadwindProfile(this.windProfileFactory.getClimbWinds(), this.headingProfile);
        this.expediteProfile.addPresentPositionCheckpoint(presentPosition, fuelOnBoard, managedClimbSpeedMach, this.getVman(approachSpeed));
        this.climbPathBuilder.computeClimbPath(this.expediteProfile, climbStrategy, selectedSpeedProfile, climbWinds, fcuAltitude);
        this.expediteProfile.finalizeProfile();
      } catch (e) {
        console.error(e);
        this.expediteProfile = new SelectedGeometryProfile();
      }
    }

    /**
     * Build a path from the present position to the FCU altitude
     */
    computeTacticalNdProfile() {
      const {
        fcuAltitude,
        cleanSpeed,
        presentPosition,
        fuelOnBoard,
        approachSpeed
      } = this.observer.get();
      const ndProfile = this.fcuModes.isLatAutoControlActive() ? new NavGeometryProfile(this.guidanceController, this.constraintReader, this.atmosphericConditions) : new SelectedGeometryProfile();
      let speedProfile;
      if (this.fcuModes.isExpediteModeActive()) {
        speedProfile = new ExpediteSpeedProfile(cleanSpeed);
      } else if (this.fcuModes.isSpeedAutoControlActive()) {
        speedProfile = new McduSpeedProfile(this.observer, this.constraintReader.distanceToPresentPosition, this.constraintReader.climbSpeedConstraints, this.constraintReader.descentSpeedConstraints);
      } else {
        speedProfile = new NdSpeedProfile(this.observer, this.constraintReader.distanceToPresentPosition, this.constraintReader.climbSpeedConstraints, this.constraintReader.descentSpeedConstraints);
      }
      if (this.fcuModes.isInSelectedVerticalMode()) {
        ndProfile.resetAltitudeConstraints();
      }

      // TODO: Handle Takeoff and Go arounds

      ndProfile.addPresentPositionCheckpoint(presentPosition, fuelOnBoard, this.getManagedMachTarget(), this.getVman(approachSpeed));

      // Build path to FCU altitude
      if (this.fcuModes.isInTakeoffMode() || this.fcuModes.isInClimbingMode()) {
        const climbStrategy = this.getClimbStrategyForVerticalMode();
        const climbWinds = new HeadwindProfile(this.windProfileFactory.getClimbWinds(), this.headingProfile);
        this.climbPathBuilder.computeClimbPath(ndProfile, climbStrategy, speedProfile, climbWinds, fcuAltitude);
      } else if (this.fcuModes.isInDescentMode()) {
        const descentStrategy = this.getDescentStrategyForVerticalMode();
        const descentWinds = new HeadwindProfile(this.windProfileFactory.getDescentWinds(), this.headingProfile);
        const offset = this.computeTacticalToGuidanceProfileOffset();
        const schedule = this.getDecelerationScheduleFromDescentPath(offset);
        this.tacticalDescentPathBuilder.buildTacticalDescentPathToAltitude(ndProfile, descentStrategy, speedProfile, descentWinds, fcuAltitude, schedule);
        this.interceptNdWithGuidanceProfile(ndProfile);
        this.insertLevelSegmentPwp(ndProfile);
        this.insertNextDescentPwp(ndProfile);
      }
      ndProfile.finalizeProfile();
      this.ndProfile = ndProfile;
    }

    /**
     * Computes an intercept point between the profile that's predicted in the currently active modes and the precomputed descent profile.
     */
    interceptNdWithGuidanceProfile(ndProfile) {
      const {
        flightPhase,
        fcuVerticalMode,
        fcuArmedVerticalMode,
        presentPosition,
        fcuAltitude
      } = this.observer.get();
      if (!this.fcuModes.isLatAutoControlActive() || !this.descentProfile || !ndProfile || flightPhase !== FmgcFlightPhase.Descent && flightPhase !== FmgcFlightPhase.Approach) {
        return;
      }
      const offset = this.computeTacticalToGuidanceProfileOffset();
      const [index, interceptDistance] = ProfileInterceptCalculator.calculateIntercept(ndProfile.checkpoints, this.descentProfile.checkpoints, offset);
      const hasIntercept = index >= 0;
      const isDesActive = fcuVerticalMode === VerticalMode.DES;

      // If we have an intercept, add the intercept checkpoint
      if (hasIntercept) {
        const interceptReason = isDesActive ? VerticalCheckpointReason.InterceptDescentProfileManaged : VerticalCheckpointReason.InterceptDescentProfileSelected;
        const interceptCheckpoint = ndProfile.addInterpolatedCheckpoint(interceptDistance, {
          reason: interceptReason
        });
        const isAircraftTooCloseToIntercept = Math.abs(presentPosition.alt - interceptCheckpoint.altitude) < 100;
        if (isAircraftTooCloseToIntercept) {
          // If we're close to the intercept, we don't want to draw the intercept point, so use a reason that does not create a PWP
          interceptCheckpoint.reason = VerticalCheckpointReason.AtmosphericConditions;
        }
      }

      // In DES mode, we assume that we continue on the managed profile after the intercept, so we splice away the tactical profile and append the managed one after the intercept
      // In a selected mode, we continue until level off and only then continue with the managed profile.
      const isDesArmed = isArmed(fcuArmedVerticalMode, ArmedVerticalMode.DES);
      const shouldContinueWithManagedProfileAfterIntercept = hasIntercept && (isDesActive || isDesArmed);
      if (shouldContinueWithManagedProfileAfterIntercept) {
        ndProfile.checkpoints.splice(index + 2,
        // Add two so we don't splice the intercept checkpoint away after adding it
        Infinity, ...this.descentProfile.checkpoints.map(
        // Use AtmosphericConditions as reason to make sure we don't get the DECEL point from the guidance profile to show up on the ND
        checkpoint => _objectSpread2(_objectSpread2({}, checkpoint), {}, {
          reason: checkpoint.reason !== VerticalCheckpointReason.Decel ? checkpoint.reason : VerticalCheckpointReason.AtmosphericConditions,
          distanceFromStart: checkpoint.distanceFromStart + offset
        })).filter(_ref => {
          let {
            distanceFromStart
          } = _ref;
          return distanceFromStart > interceptDistance;
        }));

        // If we appended the managed profile directly after the intercept, we will have spliced away the level off arrow, so we have to add it again
        // At this point, we have to add the level off arrow again, because we spliced the previous one away as it lies after the intercept
        const levelOffDistance = ndProfile.interpolateDistanceAtAltitudeBackwards(fcuAltitude, true);
        ndProfile.addInterpolatedCheckpoint(levelOffDistance, {
          reason: VerticalCheckpointReason.CrossingFcuAltitudeDescent
        });
      } else {
        ndProfile.checkpoints.push(...this.descentProfile.checkpoints.map(
        // Use AtmosphericConditions as reason to make sure we don't get the DECEL point from the guidance profile to show up on the ND
        checkpoint => _objectSpread2(_objectSpread2({}, checkpoint), {}, {
          reason: checkpoint.reason !== VerticalCheckpointReason.Decel ? checkpoint.reason : VerticalCheckpointReason.AtmosphericConditions,
          distanceFromStart: checkpoint.distanceFromStart + offset
        })).filter(_ref2 => {
          let {
            distanceFromStart
          } = _ref2;
          return distanceFromStart > ndProfile.lastCheckpoint.distanceFromStart;
        }));
      }
    }

    /**
     * Find level segments in ND profile and add magenta arrows to them.
     */
    insertLevelSegmentPwp(ndProfile) {
      const {
        flightPhase,
        fcuArmedVerticalMode,
        presentPosition
      } = this.observer.get();
      if (!this.fcuModes.isLatAutoControlActive() || !this.descentProfile || !ndProfile || flightPhase !== FmgcFlightPhase.Descent && flightPhase !== FmgcFlightPhase.Approach) {
        return;
      }
      const currentAlt = presentPosition.alt;
      const isDescentArmed = isArmed(fcuArmedVerticalMode, ArmedVerticalMode.DES) || isArmed(fcuArmedVerticalMode, ArmedVerticalMode.FINAL);
      const isInLevelFlight = this.fcuModes.isInLevelFlightMode();
      let constraintAlt = -Infinity;
      // Find next descent segment
      for (let i = 1; i < ndProfile.checkpoints.length; i++) {
        const checkpoint = ndProfile.checkpoints[i];
        if (checkpoint.reason === VerticalCheckpointReason.LevelOffForDescentConstraint) {
          // This removes the magenta arrow if we're closer than 100 ft. (I have a reference for that)
          if (currentAlt - checkpoint.altitude < 100) {
            checkpoint.reason = VerticalCheckpointReason.AtmosphericConditions;
          } else {
            constraintAlt = Math.round(checkpoint.altitude);
          }
        }
        const previousCheckpoint = ndProfile.checkpoints[i - 1];
        // Either in level flight and DES armed or in descent and checkpoint under cstr alt found
        if (isInLevelFlight && isDescentArmed && currentAlt - checkpoint.altitude > 100 || constraintAlt - checkpoint.altitude > 100) {
          ndProfile.addInterpolatedCheckpoint(previousCheckpoint.distanceFromStart, {
            reason: VerticalCheckpointReason.ContinueDescentArmed
          });
          break;
        }
      }
    }

    /**
     * Insert a T/D checkpoint into the ND profile where we want to start the descent from FCU altitude
     */
    insertNextDescentPwp(ndProfile) {
      const {
        flightPhase,
        fcuAltitude
      } = this.observer.get();
      if (!this.fcuModes.isLatAutoControlActive() || !ndProfile || flightPhase !== FmgcFlightPhase.Descent && flightPhase !== FmgcFlightPhase.Approach) {
        return;
      }
      let levelOffDistance = 0;

      // Find next descent segment
      for (let i = 1; i < ndProfile.checkpoints.length; i++) {
        const checkpoint = ndProfile.checkpoints[i];
        const previousCheckpoint = ndProfile.checkpoints[i - 1];
        if (checkpoint.reason === VerticalCheckpointReason.CrossingFcuAltitudeDescent) {
          levelOffDistance = checkpoint.distanceFromStart;
        }
        if (checkpoint.reason === VerticalCheckpointReason.ContinueDescentArmed) {
          return;
        }

        // `checkpoint.altitude - fcuAltitude >= -100` works like this: If you have a constraint at 4450 feet causing a level segment,
        // but you set the FCU altitude to 4500 ft, then the continue descent arrow should be drawn where you continue the descent from 4450 ft
        // I have evidence of this somewhere.
        if (checkpoint.altitude - fcuAltitude >= -100) {
          continue;
        }
        ndProfile.addInterpolatedCheckpoint(Math.max(levelOffDistance, previousCheckpoint.distanceFromStart), {
          reason: VerticalCheckpointReason.ContinueDescent
        });
        return;
      }
    }
    mergeMcduWithGuidanceProfile(mcduProfile, offset) {
      const {
        flightPhase
      } = this.observer.get();
      if (!this.descentProfile || !mcduProfile || flightPhase !== FmgcFlightPhase.Descent && flightPhase !== FmgcFlightPhase.Approach) {
        return;
      }
      const [index, interceptDistance] = ProfileInterceptCalculator.calculateIntercept(mcduProfile.checkpoints, this.descentProfile.checkpoints, offset);
      if (index >= 0) {
        // If we have an intercept, adjust the fuel predictions/time predictions based on the current aircraft state
        const {
          secondsFromPresent: tacticalTimeAtIntercept,
          remainingFuelOnBoard: tacticalFuelAtIntercept
        } = mcduProfile.interpolateEverythingFromStart(interceptDistance, false);
        const {
          secondsFromPresent: guidanceTimeAtIntercept,
          remainingFuelOnBoard: guidanceFuelAtIntercept
        } = this.descentProfile.interpolateEverythingFromStart(interceptDistance - offset, false);

        // How much more fuel is predicted in the tactical profile vs the guidance profile
        const fuelOffset = tacticalFuelAtIntercept - guidanceFuelAtIntercept;
        const timeOffset = tacticalTimeAtIntercept - guidanceTimeAtIntercept;
        mcduProfile.checkpoints.splice(index + 1, Infinity, ...this.descentProfile.checkpoints.map(checkpoint => _objectSpread2(_objectSpread2({}, checkpoint), {}, {
          distanceFromStart: checkpoint.distanceFromStart + offset,
          remainingFuelOnBoard: checkpoint.remainingFuelOnBoard + fuelOffset,
          secondsFromPresent: checkpoint.secondsFromPresent + timeOffset
        })).filter(_ref3 => {
          let {
            distanceFromStart
          } = _ref3;
          return distanceFromStart > interceptDistance;
        }));
      }
      const decelPointInMcdu = mcduProfile.findVerticalCheckpoint(VerticalCheckpointReason.Decel);
      if (!decelPointInMcdu) {
        const decelPointInGuidanceProfile = this.descentProfile.findVerticalCheckpoint(VerticalCheckpointReason.Decel);
        mcduProfile.addInterpolatedCheckpoint(decelPointInGuidanceProfile.distanceFromStart + offset, {
          reason: VerticalCheckpointReason.Decel
        });
      }
      const spdLimCrossingInMcdu = mcduProfile.findVerticalCheckpoint(VerticalCheckpointReason.CrossingDescentSpeedLimit);
      if (!spdLimCrossingInMcdu) {
        const spdLimCrossingInGuidanceProfile = this.descentProfile.findVerticalCheckpoint(VerticalCheckpointReason.CrossingDescentSpeedLimit);
        if (spdLimCrossingInGuidanceProfile) {
          const spdLimCrossingDistance = mcduProfile.interpolateDistanceAtAltitudeBackwards(spdLimCrossingInGuidanceProfile.altitude);
          mcduProfile.addInterpolatedCheckpoint(spdLimCrossingDistance, {
            reason: VerticalCheckpointReason.CrossingDescentSpeedLimit
          });
        }
      }
    }

    // INTERNAL HELPERS

    getClimbStrategyForVerticalMode() {
      const {
        fcuVerticalMode,
        fcuVerticalSpeed,
        fcuFlightPathAngle
      } = this.observer.get();
      if (fcuVerticalMode === VerticalMode.VS) {
        return new VerticalSpeedStrategy(this.observer, this.atmosphericConditions, Math.max(0, fcuVerticalSpeed));
      }
      if (fcuVerticalMode === VerticalMode.FPA) {
        return new FlightPathAngleStrategy(this.observer, this.atmosphericConditions, Math.max(0, fcuFlightPathAngle));
      }
      return new ClimbThrustClimbStrategy(this.observer, this.atmosphericConditions);
    }
    getDescentStrategyForVerticalMode() {
      const {
        fcuVerticalMode,
        fcuVerticalSpeed,
        fcuFlightPathAngle
      } = this.observer.get();
      if (fcuVerticalMode === VerticalMode.VS) {
        return new VerticalSpeedStrategy(this.observer, this.atmosphericConditions, Math.min(0, fcuVerticalSpeed));
      }
      if (fcuVerticalMode === VerticalMode.FPA) {
        return new FlightPathAngleStrategy(this.observer, this.atmosphericConditions, Math.min(0, fcuFlightPathAngle));
      }
      if (fcuVerticalMode === VerticalMode.OP_DES) {
        return new IdleDescentStrategy(this.observer, this.atmosphericConditions);
      }

      // DES
      if (!this.aircraftToDescentProfileRelation.isValid) {
        return new IdleDescentStrategy(this.observer, this.atmosphericConditions);
      }
      return this.getDesModeStrategy();
    }

    /**
     * Important: Make sure the descent profile is valid before calling this method.
     * Figures out what descent strategy to use in DES mode based on whether we're above or below the descent profile.
     * @returns The descent strategy to use
     */
    getDesModeStrategy() {
      const linearDeviation = this.aircraftToDescentProfileRelation.computeLinearDeviation();
      if (linearDeviation > 0 && this.aircraftToDescentProfileRelation.isPastTopOfDescent()) {
        return DesModeStrategy.aboveProfile(this.observer, this.atmosphericConditions);
      }
      if (this.aircraftToDescentProfileRelation.isOnGeometricPath()) {
        const fpaTarget = this.aircraftToDescentProfileRelation.currentTargetPathAngle() / 2;
        return DesModeStrategy.belowProfileFpa(this.observer, this.atmosphericConditions, fpaTarget);
      }
      const vsTarget = this.aircraftToDescentProfileRelation.isAboveSpeedLimitAltitude() && !this.aircraftToDescentProfileRelation.isCloseToAirfieldElevation() ? -1000 : -500;
      return DesModeStrategy.belowProfileVs(this.observer, this.atmosphericConditions, vsTarget);
    }
    getVman(vApp) {
      // TODO: I wonder where these speeds come from IRL. It's probably the FAC.
      switch (SimVar.GetSimVarValue('L:A32NX_FLAPS_HANDLE_INDEX', 'Number')) {
        case 0:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_GD', 'number');
        case 1:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_S', 'number');
        case 2:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_F', 'number');
        case 3:
        case 4:
          return vApp;
        default:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_VLS', 'number');
      }
    }
    getDecelerationScheduleFromDescentPath(offset) {
      const schedule = {
        speedChanges: [],
        approachPoints: []
      };
      if (!this.descentProfile) {
        return schedule;
      }
      this.descentProfile.checkpoints.forEach(checkpoint => {
        if (isSpeedChangePoint(checkpoint)) {
          schedule.speedChanges.push(_objectSpread2(_objectSpread2({}, checkpoint), {}, {
            distanceFromStart: checkpoint.distanceFromStart + offset
          }));
        } else if (isApproachCheckpoint(checkpoint)) {
          schedule.approachPoints.push(_objectSpread2(_objectSpread2({}, checkpoint), {}, {
            distanceFromStart: checkpoint.distanceFromStart + offset
          }));
        }
      });
      return schedule;
    }

    /**
     * Computes the difference in distance between the aircraft's current position and the start of the descent profile.
     * According to the the tactical profile (i.e short term prediction profile used for things like level off arrows), the aircraft's distance from start
     * is the distance from the start of the currently active leg.
     * According to the descent profile, it is the distance that was the current distance from start when the aircraft started its descent.
     * This is naturally the case because the descent profile and the "starting point" is not updated during descent.
     * @returns Offset between the aircraft's distance from start and the descent profile's distance from start
     */
    computeTacticalToGuidanceProfileOffset() {
      var _this$aircraftToDesce;
      if (!this.descentProfile || !((_this$aircraftToDesce = this.aircraftToDescentProfileRelation) !== null && _this$aircraftToDesce !== void 0 && _this$aircraftToDesce.isValid)) {
        return 0;
      }
      return this.constraintReader.distanceToPresentPosition - this.aircraftToDescentProfileRelation.distanceFromStart;
    }
    getManagedMachTarget() {
      const {
        flightPhase,
        managedClimbSpeedMach,
        managedCruiseSpeedMach,
        managedDescentSpeedMach
      } = this.observer.get();
      switch (flightPhase) {
        case FmgcFlightPhase.Cruise:
          return managedCruiseSpeedMach;
        case FmgcFlightPhase.Descent:
        case FmgcFlightPhase.Approach:
        case FmgcFlightPhase.Done:
          return managedDescentSpeedMach;
        default:
          return managedClimbSpeedMach;
      }
    }
  }
  class FcuModeObserver {
    constructor(observer) {
      this.observer = observer;
      _defineProperty(this, "LAT_AUTO_CONTROL_MODES", [LateralMode.NAV, LateralMode.LOC_CPT, LateralMode.LOC_TRACK, LateralMode.RWY]);
      _defineProperty(this, "VERT_CLIMB_MODES", [VerticalMode.CLB, VerticalMode.OP_CLB, VerticalMode.SRS, VerticalMode.SRS_GA]);
      _defineProperty(this, "VERT_DESCENT_MODES", [VerticalMode.DES, VerticalMode.OP_DES]);
      _defineProperty(this, "VERT_LEVEL_MODES", [VerticalMode.ALT, VerticalMode.ALT_CPT, VerticalMode.ALT_CST, VerticalMode.ALT_CST_CPT]);
      _defineProperty(this, "VERT_SELECTED_MODES", [VerticalMode.OP_CLB, VerticalMode.OP_DES, VerticalMode.VS, VerticalMode.FPA]);
    }
    isLatAutoControlActive() {
      return this.LAT_AUTO_CONTROL_MODES.includes(this.observer.get().fcuLateralMode);
    }
    isSpeedAutoControlActive() {
      return this.observer.get().fcuSpeedManaged;
    }
    isInTakeoffMode() {
      const {
        fcuVerticalMode
      } = this.observer.get();
      return fcuVerticalMode === VerticalMode.SRS;
    }
    isInClimbingMode() {
      const {
        fcuVerticalMode,
        fcuVerticalSpeed,
        fcuFlightPathAngle
      } = this.observer.get();
      return this.VERT_CLIMB_MODES.includes(fcuVerticalMode) || fcuVerticalMode === VerticalMode.FPA && fcuFlightPathAngle > 0 || fcuVerticalMode === VerticalMode.VS && fcuVerticalSpeed > 0;
    }
    isInDescentMode() {
      const {
        fcuVerticalMode,
        fcuVerticalSpeed,
        fcuFlightPathAngle
      } = this.observer.get();
      return this.VERT_DESCENT_MODES.includes(fcuVerticalMode) || fcuVerticalMode === VerticalMode.FPA && fcuFlightPathAngle < 0 || fcuVerticalMode === VerticalMode.VS && fcuVerticalSpeed < 0;
    }
    isInLevelFlightMode() {
      const {
        fcuVerticalMode,
        fcuVerticalSpeed,
        fcuFlightPathAngle
      } = this.observer.get();
      return this.VERT_LEVEL_MODES.includes(fcuVerticalMode) || fcuVerticalMode === VerticalMode.FPA && Math.abs(fcuFlightPathAngle) < 10 || fcuVerticalMode === VerticalMode.VS && Math.abs(fcuVerticalSpeed) < 10;
    }
    isExpediteModeActive() {
      return this.observer.get().fcuExpediteModeActive;
    }
    isInGoAroundMode() {
      const {
        fcuVerticalMode
      } = this.observer.get();
      return fcuVerticalMode === VerticalMode.SRS_GA;
    }
    isInSelectedVerticalMode() {
      const {
        fcuVerticalMode
      } = this.observer.get();
      return this.VERT_SELECTED_MODES.includes(fcuVerticalMode);
    }
  }

  class VnavDriver {
    constructor(guidanceController, computationParametersObserver, atmosphericConditions, windProfileFactory, flightPlanManager) {
      this.guidanceController = guidanceController;
      this.computationParametersObserver = computationParametersObserver;
      this.atmosphericConditions = atmosphericConditions;
      this.windProfileFactory = windProfileFactory;
      this.flightPlanManager = flightPlanManager;
      _defineProperty(this, "version", 0);
      _defineProperty(this, "currentMcduSpeedProfile", void 0);
      _defineProperty(this, "constraintReader", void 0);
      _defineProperty(this, "aircraftToDescentProfileRelation", void 0);
      _defineProperty(this, "descentGuidance", void 0);
      _defineProperty(this, "headingProfile", void 0);
      _defineProperty(this, "profileManager", void 0);
      // We cache this here, so we don't have to recompute it every guidance step
      _defineProperty(this, "decelPoint", null);
      // Saved variables to check for changes
      _defineProperty(this, "previousManagedDescentSpeedTarget", void 0);
      _defineProperty(this, "lastParameters", null);
      // Here, we keep a copy of the whatever legs we used to update the descent profile last. We compare it with the legs we get from any new geometries to figure out
      // if the descent profile should be recomputed.
      _defineProperty(this, "oldLegs", new Map());
      /**
       * To check
       */
      _defineProperty(this, "requestDescentProfileRecomputation", false);
      this.headingProfile = new NavHeadingProfile(flightPlanManager);
      this.currentMcduSpeedProfile = new McduSpeedProfile(this.computationParametersObserver, 0, [], []);
      this.constraintReader = new ConstraintReader(guidanceController);
      this.aircraftToDescentProfileRelation = new AircraftToDescentProfileRelation(this.computationParametersObserver);
      this.descentGuidance = new DescentGuidance(this.guidanceController, this.aircraftToDescentProfileRelation, computationParametersObserver, this.atmosphericConditions);
      this.profileManager = new VerticalProfileManager(this.guidanceController, this.computationParametersObserver, this.atmosphericConditions, this.constraintReader, this.headingProfile, this.windProfileFactory, this.aircraftToDescentProfileRelation);
    }
    init() {
      console.log('[FMGC/Guidance] VnavDriver initialized!');
    }
    acceptMultipleLegGeometry(geometry) {
      this.recompute(geometry);
    }
    update(deltaTime) {
      try {
        const {
          presentPosition,
          flightPhase
        } = this.computationParametersObserver.get();
        if (flightPhase >= FmgcFlightPhase.Takeoff) {
          this.constraintReader.updateDistanceToEnd(presentPosition);
          this.updateHoldSpeed();
          this.updateDescentSpeedGuidance();
          this.descentGuidance.update(deltaTime, this.constraintReader.distanceToEnd);
        }
      } catch (e) {
        console.error('[FMS] Failed to calculate vertical profile. See exception below.');
        console.error(e);
      }
    }
    recompute(geometry) {
      var _this$currentMcduSpee, _geometry$legs;
      if (geometry.legs.size <= 0 || !this.computationParametersObserver.canComputeProfile()) {
        return;
      }
      const newParameters = this.computationParametersObserver.get();
      this.constraintReader.updateGeometry(geometry, newParameters.presentPosition);
      this.windProfileFactory.updateAircraftDistanceFromStart(this.constraintReader.distanceToPresentPosition);
      this.headingProfile.updateGeometry(geometry);
      (_this$currentMcduSpee = this.currentMcduSpeedProfile) === null || _this$currentMcduSpee === void 0 ? void 0 : _this$currentMcduSpee.update(this.constraintReader.distanceToPresentPosition);
      this.profileManager.computeTacticalMcduPath();
      const newLegs = new Map((_geometry$legs = geometry === null || geometry === void 0 ? void 0 : geometry.legs) !== null && _geometry$legs !== void 0 ? _geometry$legs : []);
      if (this.shouldUpdateDescentProfile(newParameters, newLegs) || this.requestDescentProfileRecomputation) {
        this.oldLegs = new Map(newLegs);
        this.lastParameters = newParameters;
        this.requestDescentProfileRecomputation = false;
        this.previousManagedDescentSpeedTarget = newParameters.managedDescentSpeed;
        this.profileManager.computeDescentPath();

        // TODO: This doesn't really do much, the profile is automatically updated by reference.
        this.descentGuidance.updateProfile(this.profileManager.descentProfile);
        this.decelPoint = this.profileManager.descentProfile.findVerticalCheckpoint(VerticalCheckpointReason.Decel);
      }
      this.updateLegSpeedPredictions();
      this.profileManager.computeTacticalNdProfile();
      this.profileManager.computeVerticalProfileForExpediteClimb();
      this.guidanceController.pseudoWaypoints.acceptVerticalProfile();
      this.version++;
    }
    isLatAutoControlActive() {
      const {
        fcuLateralMode
      } = this.computationParametersObserver.get();
      return fcuLateralMode === LateralMode.NAV || fcuLateralMode === LateralMode.LOC_CPT || fcuLateralMode === LateralMode.LOC_TRACK || fcuLateralMode === LateralMode.RWY;
    }
    isSelectedVerticalModeActive() {
      const {
        fcuVerticalMode,
        fcuExpediteModeActive
      } = this.computationParametersObserver.get();
      return fcuExpediteModeActive || fcuVerticalMode === VerticalMode.VS || fcuVerticalMode === VerticalMode.FPA || fcuVerticalMode === VerticalMode.OP_CLB || fcuVerticalMode === VerticalMode.OP_DES;
    }
    get mcduProfile() {
      return this.profileManager.mcduProfile;
    }
    get ndProfile() {
      return this.profileManager.ndProfile;
    }
    get expediteProfile() {
      return this.profileManager.expediteProfile;
    }
    updateDescentSpeedGuidance() {
      var _this$ndProfile, _this$decelPoint$spee, _this$decelPoint;
      if (!((_this$ndProfile = this.ndProfile) !== null && _this$ndProfile !== void 0 && _this$ndProfile.isReadyToDisplay)) {
        return;
      }
      const {
        flightPhase,
        managedDescentSpeed,
        managedDescentSpeedMach,
        presentPosition,
        approachSpeed,
        fcuExpediteModeActive
      } = this.computationParametersObserver.get();
      const isHoldActive = this.guidanceController.isManualHoldActive() || this.guidanceController.isManualHoldNext();
      const currentDistanceFromStart = this.isLatAutoControlActive() ? this.constraintReader.distanceToPresentPosition : 0;
      const currentAltitude = presentPosition.alt;

      // Speed guidance for holds is handled elsewhere for now, so we don't want to interfere here
      if (flightPhase !== FmgcFlightPhase.Descent || fcuExpediteModeActive || isHoldActive) {
        return;
      }

      // We get this value because we only want to a speed constraint if this is not covered by the decel point already
      const decelPointSpeed = (_this$decelPoint$spee = (_this$decelPoint = this.decelPoint) === null || _this$decelPoint === void 0 ? void 0 : _this$decelPoint.speed) !== null && _this$decelPoint$spee !== void 0 ? _this$decelPoint$spee : 0;
      let newSpeedTarget = Math.min(managedDescentSpeed, this.previousManagedDescentSpeedTarget);
      if (this.isLatAutoControlActive()) {
        // We get the managed target here because this function is only supposed to update the managed speed
        const targetFromProfile = this.currentMcduSpeedProfile.getManagedTarget(currentDistanceFromStart, currentAltitude, ManagedSpeedType.Descent);
        newSpeedTarget = Math.min(newSpeedTarget, targetFromProfile);
      }
      for (let i = 0; i < this.profileManager.ndProfile.checkpoints.length - 2; i++) {
        const checkpoint = this.profileManager.ndProfile.checkpoints[i];
        if (checkpoint.distanceFromStart - currentDistanceFromStart > 1) {
          break;
        }
        const isPastCstrDeceleration = checkpoint.reason === VerticalCheckpointReason.StartDecelerationToConstraint && currentDistanceFromStart - checkpoint.distanceFromStart > -1e-4;
        const isPastLimitDeceleration = checkpoint.reason === VerticalCheckpointReason.StartDecelerationToLimit && currentAltitude - checkpoint.altitude < 1e-4;
        if (isSpeedChangePoint(checkpoint) && checkpoint.targetSpeed >= decelPointSpeed && (isPastCstrDeceleration || isPastLimitDeceleration)) {
          newSpeedTarget = Math.min(newSpeedTarget, checkpoint.targetSpeed);
          break;
        }
      }
      this.previousManagedDescentSpeedTarget = newSpeedTarget;
      const vLs = SimVar.GetSimVarValue('L:A32NX_SPEEDS_VLS', 'number');
      const vMan = this.getVman(approachSpeed);
      const econMachAsCas = this.atmosphericConditions.computeCasFromMach(presentPosition.alt, managedDescentSpeedMach);
      SimVar.SetSimVarValue('L:A32NX_SPEEDS_MANAGED_PFD', 'knots', Math.max(vLs, vMan, Math.min(newSpeedTarget, econMachAsCas)));
    }

    // TODO: This appears too many times in different places. Centralize
    getVman(vApp) {
      // TODO: I wonder where these speeds come from IRL. It's probably the FAC.
      switch (SimVar.GetSimVarValue('L:A32NX_FLAPS_HANDLE_INDEX', 'Number')) {
        case 0:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_GD', 'number');
        case 1:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_S', 'number');
        case 2:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_F', 'number');
        case 3:
        case 4:
          return vApp;
        default:
          return SimVar.GetSimVarValue('L:A32NX_SPEEDS_VLS', 'number');
      }
    }
    updateHoldSpeed() {
      if (!this.guidanceController.isManualHoldActive() && !this.guidanceController.isManualHoldNext()) {
        return;
      }
      let holdSpeedCas = SimVar.GetSimVarValue('L:A32NX_FM_HOLD_SPEED', 'number');
      const holdDecelReached = SimVar.GetSimVarValue('L:A32NX_FM_HOLD_DECEL', 'bool');
      const speedControlManual = Simplane.getAutoPilotAirspeedSelected();
      const isMach = Simplane.getAutoPilotMachModeActive();
      if (speedControlManual && holdDecelReached) {
        if (isMach) {
          const holdValue = Simplane.getAutoPilotMachHoldValue();
          holdSpeedCas = this.atmosphericConditions.computeCasFromMach(this.atmosphericConditions.currentAltitude, holdValue);
        } else {
          holdSpeedCas = Simplane.getAutoPilotAirspeedHoldValue();
        }
      }
      const holdSpeedTas = this.atmosphericConditions.computeTasFromCas(this.atmosphericConditions.currentAltitude, holdSpeedCas);
      this.guidanceController.setHoldSpeed(holdSpeedTas);
    }
    getLinearDeviation() {
      if (!this.aircraftToDescentProfileRelation.isValid) {
        return null;
      }
      return this.aircraftToDescentProfileRelation.computeLinearDeviation();
    }
    shouldUpdateDescentProfile(newParameters, newLegs) {
      var _this$lastParameters$, _newParameters$descen, _this$lastParameters$2, _newParameters$descen2;
      // While in the descent phase, we don't want to update the profile anymore
      if (this.lastParameters === null) {
        return true;
      }
      return newParameters.flightPhase < FmgcFlightPhase.Descent || newParameters.flightPhase > FmgcFlightPhase.Approach || !this.flightPlanManager.isCurrentFlightPlanTemporary() && this.didLegsChange(this.oldLegs, newLegs) || numberOrNanChanged(this.lastParameters.cruiseAltitude, newParameters.cruiseAltitude) || numberOrNanChanged(this.lastParameters.managedDescentSpeed, newParameters.managedDescentSpeed) || numberOrNanChanged(this.lastParameters.managedDescentSpeedMach, newParameters.managedDescentSpeedMach) || numberOrNanChanged(this.lastParameters.approachQnh, newParameters.approachQnh) || numberOrNanChanged(this.lastParameters.approachTemperature, newParameters.approachTemperature) || numberOrNanChanged((_this$lastParameters$ = this.lastParameters.descentSpeedLimit) === null || _this$lastParameters$ === void 0 ? void 0 : _this$lastParameters$.speed, (_newParameters$descen = newParameters.descentSpeedLimit) === null || _newParameters$descen === void 0 ? void 0 : _newParameters$descen.speed) || numberOrNanChanged((_this$lastParameters$2 = this.lastParameters.descentSpeedLimit) === null || _this$lastParameters$2 === void 0 ? void 0 : _this$lastParameters$2.underAltitude, (_newParameters$descen2 = newParameters.descentSpeedLimit) === null || _newParameters$descen2 === void 0 ? void 0 : _newParameters$descen2.underAltitude);
    }
    didLegsChange(oldLegs, newLegs) {
      for (const [index, legA] of newLegs) {
        const legB = oldLegs.get(index);
        if (index < this.guidanceController.activeLegIndex) {
          continue;
        }
        if (!(legA !== null && legA !== void 0 && legA.repr) !== !(legB !== null && legB !== void 0 && legB.repr)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Compute predictions for EFOB, ETE, etc. at destination
     */
    getDestinationPrediction() {
      var _this$profileManager$, _this$profileManager$2;
      return (_this$profileManager$ = this.profileManager.mcduProfile) === null || _this$profileManager$ === void 0 ? void 0 : (_this$profileManager$2 = _this$profileManager$.waypointPredictions) === null || _this$profileManager$2 === void 0 ? void 0 : _this$profileManager$2.get(this.flightPlanManager.getDestinationIndex());
    }

    /**
     * Compute predictions to be shown on the PERF CRZ page
     */
    getPerfCrzToPrediction() {
      var _this$profileManager$3;
      if (!((_this$profileManager$3 = this.profileManager.mcduProfile) !== null && _this$profileManager$3 !== void 0 && _this$profileManager$3.isReadyToDisplay)) {
        return null;
      }
      const todOrStep = this.profileManager.mcduProfile.findVerticalCheckpoint(VerticalCheckpointReason.StepClimb, VerticalCheckpointReason.StepDescent, VerticalCheckpointReason.TopOfDescent);
      if (!todOrStep) {
        return null;
      }
      return {
        reason: todOrStep.reason,
        distanceFromPresentPosition: todOrStep.distanceFromStart - this.constraintReader.distanceToPresentPosition,
        secondsFromPresent: todOrStep.secondsFromPresent
      };
    }
    get distanceToEnd() {
      return this.constraintReader.distanceToEnd;
    }
    findNextSpeedChange() {
      var _this$decelPoint2;
      const {
        presentPosition,
        flightPhase,
        fcuAltitude,
        fcuSpeedManaged,
        fcuExpediteModeActive
      } = this.computationParametersObserver.get();
      if (!this.ndProfile || !fcuSpeedManaged || fcuExpediteModeActive || flightPhase === FmgcFlightPhase.Approach) {
        return null;
      }
      let speedTargetType = ManagedSpeedType.Climb;
      if (flightPhase === FmgcFlightPhase.Cruise) {
        speedTargetType = ManagedSpeedType.Cruise;
      } else if (flightPhase === FmgcFlightPhase.Descent) {
        speedTargetType = ManagedSpeedType.Descent;
      }
      const distanceToPresentPosition = this.ndProfile.distanceToPresentPosition;
      const decelPointSpeed = (_this$decelPoint2 = this.decelPoint) === null || _this$decelPoint2 === void 0 ? void 0 : _this$decelPoint2.speed;

      // We don't want to show the speed change dot at acceleration altiude, so we have to make sure the speed target is econ speed, not SRS speed.
      const speedTarget = flightPhase < FmgcFlightPhase.Climb ? this.currentMcduSpeedProfile.getTarget(distanceToPresentPosition, presentPosition.alt, ManagedSpeedType.Climb) : SimVar.GetSimVarValue('L:A32NX_SPEEDS_MANAGED_PFD', 'knots');
      for (let i = 1; i < this.profileManager.ndProfile.checkpoints.length - 1; i++) {
        const checkpoint = this.profileManager.ndProfile.checkpoints[i];
        if (checkpoint.distanceFromStart < distanceToPresentPosition) {
          continue;
        } else if (checkpoint.reason === VerticalCheckpointReason.TopOfClimb || checkpoint.reason === VerticalCheckpointReason.TopOfDescent) {
          // At T/C, T/D, we expect to see a speed change the the respective ECON speed, but this is not indicated to the pilots
          return null;
        }
        if (speedTargetType === ManagedSpeedType.Climb || speedTargetType === ManagedSpeedType.Cruise) {
          if (Math.min(checkpoint.speed, this.atmosphericConditions.computeCasFromMach(checkpoint.altitude, checkpoint.mach)) - Math.max(this.profileManager.ndProfile.checkpoints[i - 1].speed, speedTarget) > 1) {
            // Candiate for a climb speed change
            return this.profileManager.ndProfile.checkpoints[i - 1].distanceFromStart;
          }
        } else if (isSpeedChangePoint(checkpoint) && checkpoint.targetSpeed - speedTarget < -1 && checkpoint.targetSpeed >= decelPointSpeed) {
          // Check if decel point, or `StartDeceleration` point with target speed lower than current target, but larger than the speed the decel point is placed at.

          // Only show deceleration to speed limit if we are going to descend below it.
          if (checkpoint.reason === VerticalCheckpointReason.StartDecelerationToConstraint || fcuAltitude < checkpoint.altitude) {
            return checkpoint.distanceFromStart;
          }
        }
      }
      return null;
    }
    invalidateFlightPlanProfile() {
      var _this$profileManager$4;
      this.requestDescentProfileRecomputation = true;

      // Invalidate MCDU profile, so the FPLAN page shows blank predictions
      (_this$profileManager$4 = this.profileManager.mcduProfile) === null || _this$profileManager$4 === void 0 ? void 0 : _this$profileManager$4.invalidate();
    }

    // Only used to check whether T/D PWP should be displayed despite not being in lat auto control
    isFlightPhasePreflight() {
      return this.computationParametersObserver.get().flightPhase === FmgcFlightPhase.Preflight;
    }
    updateLegSpeedPredictions() {
      var _this$profileManager$5;
      // No VNAV predictions
      if (!((_this$profileManager$5 = this.profileManager.mcduProfile) !== null && _this$profileManager$5 !== void 0 && _this$profileManager$5.isReadyToDisplay)) {
        return;
      }
      const geometry = this.guidanceController.activeGeometry;
      const activeLegIndex = this.guidanceController.activeLegIndex;
      let distanceFromAircraft = this.guidanceController.activeLegCompleteLegPathDtg;
      const tacticalDistanceFromStart = this.constraintReader.distanceToPresentPosition;
      for (let i = activeLegIndex; geometry.legs.get(i) || geometry.legs.get(i + 1); i++) {
        const leg = geometry.legs.get(i);
        if (!leg) {
          continue;
        }
        if (i > activeLegIndex) {
          if (leg instanceof IFLeg) {
            var _leg$fix, _leg$fix$infos;
            const previousTermination = geometry.legs.get(i - 1).getPathEndPoint();
            if (previousTermination && leg !== null && leg !== void 0 && (_leg$fix = leg.fix) !== null && _leg$fix !== void 0 && (_leg$fix$infos = _leg$fix.infos) !== null && _leg$fix$infos !== void 0 && _leg$fix$infos.coordinates) {
              distanceFromAircraft += Avionics.Utils.computeGreatCircleDistance(previousTermination, leg.fix.infos.coordinates);
            }
          } else {
            const inboundTransition = geometry.transitions.get(i - 1);
            const outboundTransition = geometry.transitions.get(i);
            const [inboundLength, legDistance, outboundLength] = Geometry.completeLegPathLengths(leg, inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull || !(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isComputed) ? null : inboundTransition, outboundTransition !== null && outboundTransition !== void 0 && outboundTransition.isNull || !(outboundTransition !== null && outboundTransition !== void 0 && outboundTransition.isComputed) ? null : outboundTransition);
            const correctedInboundLength = Number.isNaN(inboundLength) ? 0 : inboundLength;
            const totalLegLength = legDistance + correctedInboundLength + outboundLength;
            distanceFromAircraft += totalLegLength;
          }
        }
        const prediction = this.profileManager.mcduProfile.interpolateEverythingFromStart(tacticalDistanceFromStart + distanceFromAircraft);
        const tasPrediction = this.atmosphericConditions.computeTasFromCas(prediction.altitude, prediction.speed);

        // TODO: Use wind speed prediction for that leg instead of current wind speed
        const gsPrediction = tasPrediction + this.atmosphericConditions.currentWindSpeed;
        leg.predictedTas = tasPrediction;
        leg.predictedGs = gsPrediction;
      }
    }
  }

  /// To check whether the value changed from old to new, but not if both values are NaN. (NaN !== NaN in JS)
  function numberOrNanChanged(oldValue, newValue) {
    return (!Number.isNaN(oldValue) || !Number.isNaN(newValue)) && oldValue !== newValue;
  }

  // How often the (milliseconds)
  const GEOMETRY_RECOMPUTATION_TIMER = 5000;
  class GuidanceController {
    get hasTemporaryFlightPlan() {
      // eslint-disable-next-line no-underscore-dangle
      return this.flightPlanManager._currentFlightPlanIndex === FlightPlans.Temporary;
    }
    updateEfisState(side, state) {
      const ndMode = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_MODE"), 'Enum');
      const ndRange = rangeSettings[SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_RANGE"), 'Enum')];
      if ((state === null || state === void 0 ? void 0 : state.mode) !== ndMode || (state === null || state === void 0 ? void 0 : state.range) !== ndRange) {
        this.taskQueue.cancelAllInCategory(TaskCategory.EfisVectors);
        this.efisVectors.forceUpdate();
      }
      state.mode = ndMode;
      state.range = ndRange;
      this.updateEfisApproachMessage();
    }
    updateMrpState() {
      // PLAN mode center

      const focusedWpIndex = SimVar.GetSimVarValue('L:A32NX_SELECTED_WAYPOINT', 'number');
      const focusedWp = this.flightPlanManager.getWaypoint(focusedWpIndex);
      if (this.lastFocusedWpIndex !== focusedWpIndex) {
        this.lastFocusedWpIndex = focusedWpIndex;
        this.efisVectors.forceUpdate();
      }
      if (focusedWp) {
        this.focusedWaypointCoordinates.lat = focusedWp.infos.coordinates.lat;
        this.focusedWaypointCoordinates.long = focusedWp.infos.coordinates.long;
        SimVar.SetSimVarValue('L:A32NX_SELECTED_WAYPOINT_LAT', 'Degrees', this.focusedWaypointCoordinates.lat);
        SimVar.SetSimVarValue('L:A32NX_SELECTED_WAYPOINT_LONG', 'Degrees', this.focusedWaypointCoordinates.long);
      }
    }
    updateMapPartlyDisplayed() {
      if (this.efisStateForSide.L.dataLimitReached || this.efisStateForSide.L.legsCulled) {
        SimVar.SetSimVarValue('L:A32NX_EFIS_L_MAP_PARTLY_DISPLAYED', 'boolean', true);
      } else {
        SimVar.SetSimVarValue('L:A32NX_EFIS_L_MAP_PARTLY_DISPLAYED', 'boolean', false);
      }
      if (this.efisStateForSide.R.dataLimitReached || this.efisStateForSide.R.legsCulled) {
        SimVar.SetSimVarValue('L:A32NX_EFIS_R_MAP_PARTLY_DISPLAYED', 'boolean', true);
      } else {
        SimVar.SetSimVarValue('L:A32NX_EFIS_R_MAP_PARTLY_DISPLAYED', 'boolean', false);
      }
    }
    updateEfisIdent() {
      var _this$activeGeometry$, _this$activeGeometry$2;
      // Update EFIS ident

      const efisIdent = (_this$activeGeometry$ = (_this$activeGeometry$2 = this.activeGeometry.legs.get(this.activeLegIndex)) === null || _this$activeGeometry$2 === void 0 ? void 0 : _this$activeGeometry$2.ident) !== null && _this$activeGeometry$ !== void 0 ? _this$activeGeometry$ : 'PPOS';
      const efisVars = SimVarString.pack(efisIdent, 9);
      // setting the simvar as a number greater than about 16 million causes precision error > 1... but this works..
      SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_IDENT_0', 'string', efisVars[0].toString());
      SimVar.SetSimVarValue('L:A32NX_EFIS_L_TO_WPT_IDENT_1', 'string', efisVars[1].toString());
      SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_IDENT_0', 'string', efisVars[0].toString());
      SimVar.SetSimVarValue('L:A32NX_EFIS_R_TO_WPT_IDENT_1', 'string', efisVars[1].toString());
    }
    updateEfisApproachMessage() {
      let apprMsg = '';
      const appr = this.flightPlanManager.getApproach(FlightPlans.Active);
      if (appr && appr.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN) {
        const phase = getFlightPhaseManager().phase;
        if (phase > FmgcFlightPhase.Cruise || phase === FmgcFlightPhase.Cruise && this.flightPlanManager.getDistanceToDestination(FlightPlans.Active) < 250) {
          apprMsg = appr.longName;
        }
      }
      if (apprMsg !== this.approachMessage) {
        this.approachMessage = apprMsg;
        const apprMsgVars = SimVarString.pack(apprMsg, 9);
        // setting the simvar as a number greater than about 16 million causes precision error > 1... but this works..
        SimVar.SetSimVarValue('L:A32NX_EFIS_L_APPR_MSG_0', 'string', apprMsgVars[0].toString());
        SimVar.SetSimVarValue('L:A32NX_EFIS_L_APPR_MSG_1', 'string', apprMsgVars[1].toString());
        SimVar.SetSimVarValue('L:A32NX_EFIS_R_APPR_MSG_0', 'string', apprMsgVars[0].toString());
        SimVar.SetSimVarValue('L:A32NX_EFIS_R_APPR_MSG_1', 'string', apprMsgVars[1].toString());
      }
    }
    constructor(flightPlanManager, guidanceManager, fmgc) {
      _defineProperty(this, "flightPlanManager", void 0);
      _defineProperty(this, "guidanceManager", void 0);
      _defineProperty(this, "lnavDriver", void 0);
      _defineProperty(this, "vnavDriver", void 0);
      _defineProperty(this, "pseudoWaypoints", void 0);
      _defineProperty(this, "efisVectors", void 0);
      _defineProperty(this, "activeGeometry", void 0);
      _defineProperty(this, "temporaryGeometry", void 0);
      _defineProperty(this, "activeLegIndex", void 0);
      _defineProperty(this, "temporaryLegIndex", -1);
      _defineProperty(this, "activeTransIndex", void 0);
      _defineProperty(this, "activeLegDtg", void 0);
      _defineProperty(this, "activeLegCompleteLegPathDtg", void 0);
      _defineProperty(this, "displayActiveLegCompleteLegPathDtg", void 0);
      _defineProperty(this, "focusedWaypointCoordinates", {
        lat: 0,
        long: 0
      });
      _defineProperty(this, "currentPseudoWaypoints", []);
      _defineProperty(this, "automaticSequencing", true);
      _defineProperty(this, "leftEfisState", void 0);
      _defineProperty(this, "rightEfisState", void 0);
      _defineProperty(this, "efisStateForSide", void 0);
      _defineProperty(this, "approachMessage", '');
      _defineProperty(this, "taskQueue", new TaskQueue());
      _defineProperty(this, "verticalProfileComputationParametersObserver", void 0);
      _defineProperty(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
      _defineProperty(this, "windProfileFactory", void 0);
      _defineProperty(this, "atmosphericConditions", void 0);
      _defineProperty(this, "lastFocusedWpIndex", -1);
      _defineProperty(this, "lastFlightPlanVersion", SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number'));
      _defineProperty(this, "geometryRecomputationTimer", GEOMETRY_RECOMPUTATION_TIMER + 1);
      this.flightPlanManager = flightPlanManager;
      this.guidanceManager = guidanceManager;
      this.verticalProfileComputationParametersObserver = new VerticalProfileComputationParametersObserver(fmgc);
      this.windProfileFactory = new WindProfileFactory(fmgc, 1);
      this.atmosphericConditions = new AtmosphericConditions(this.verticalProfileComputationParametersObserver);
      this.lnavDriver = new LnavDriver(this);
      this.vnavDriver = new VnavDriver(this, this.verticalProfileComputationParametersObserver, this.atmosphericConditions, this.windProfileFactory, flightPlanManager);
      this.pseudoWaypoints = new PseudoWaypoints(this, this.atmosphericConditions);
      this.efisVectors = new EfisVectors(this);
    }
    init() {
      console.log('[FMGC/Guidance] GuidanceController initialized!');
      this.lnavDriver.ppos.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      this.lnavDriver.ppos.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      this.activeLegIndex = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Active);
      this.updateGeometries();
      this.leftEfisState = {
        mode: EfisNdMode.ARC,
        range: 10,
        dataLimitReached: false,
        legsCulled: false
      };
      this.rightEfisState = {
        mode: EfisNdMode.ARC,
        range: 10,
        dataLimitReached: false,
        legsCulled: false
      };
      this.efisStateForSide = {
        L: this.leftEfisState,
        R: this.rightEfisState
      };
      this.updateEfisState('L', this.leftEfisState);
      this.updateEfisState('R', this.rightEfisState);
      this.efisStateForSide.L = this.leftEfisState;
      this.efisStateForSide.R = this.leftEfisState;
      this.lnavDriver.init();
      this.vnavDriver.init();
      this.pseudoWaypoints.init();
      Coherent.on('A32NX_IMM_EXIT', (fpIndex, immExit) => {
        const leg = this.activeGeometry.legs.get(fpIndex);
        const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', 'Knots');
        if (leg instanceof HMLeg) {
          leg.setImmediateExit(immExit, this.lnavDriver.ppos, tas);
          this.flightPlanManager.updateFlightPlanVersion();
          this.automaticSequencing = true;
        }
      }, undefined);
    }
    update(deltaTime) {
      this.geometryRecomputationTimer += deltaTime;
      this.activeLegIndex = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Active);
      this.temporaryLegIndex = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Temporary);
      this.updateEfisState('L', this.leftEfisState);
      this.updateEfisState('R', this.rightEfisState);
      try {
        this.verticalProfileComputationParametersObserver.update();
        this.windProfileFactory.updateFmgcInputs();
        this.atmosphericConditions.update();
      } catch (e) {
        console.error('[FMS] Error during update of VNAV input parameters. See exception below.');
        console.error(e);
      }

      // Generate new geometry when flight plan changes
      // TODO also need to do it when FMS perf params change, e.g. speed limit/alt, climb/crz/des speeds
      const newFlightPlanVersion = this.flightPlanManager.currentFlightPlanVersion;
      if (newFlightPlanVersion !== this.lastFlightPlanVersion) {
        this.lastFlightPlanVersion = newFlightPlanVersion;
        try {
          this.updateGeometries();
          this.geometryRecomputationTimer = GEOMETRY_RECOMPUTATION_TIMER + 1;
        } catch (e) {
          console.error('[FMS] Error during update of geometry. See exception below.');
          console.error(e);
        }
      }
      if (this.geometryRecomputationTimer > GEOMETRY_RECOMPUTATION_TIMER) {
        this.geometryRecomputationTimer = 0;
        try {
          this.recomputeGeometries();
          if (this.activeGeometry) {
            try {
              this.vnavDriver.acceptMultipleLegGeometry(this.activeGeometry);
              this.pseudoWaypoints.acceptMultipleLegGeometry(this.activeGeometry);
            } catch (e) {
              console.error('[FMS] Error during active geometry recomputation. See exception below.');
              console.error(e);
            }
          }
        } catch (e) {
          console.error('[FMS] Error during geometry recomputation. See exception below.');
          console.error(e);
        }
      }
      try {
        this.updateMrpState();
      } catch (e) {
        console.error('[FMS] Error during map state computation. See exception below.');
        console.error(e);
      }
      try {
        this.updateMapPartlyDisplayed();
      } catch (e) {
        console.error('[FMS] Error during map partly displayed computation. See exception below.');
        console.error(e);
      }
      try {
        this.lnavDriver.update(deltaTime);
      } catch (e) {
        console.error('[FMS] Error during LNAV driver update. See exception below.');
        console.error(e);
      }
      try {
        this.vnavDriver.update(deltaTime);
      } catch (e) {
        console.error('[FMS] Error during VNAV driver update. See exception below.');
        console.error(e);
      }
      try {
        this.pseudoWaypoints.update(deltaTime);
      } catch (e) {
        console.error('[FMS] Error during pseudo waypoints update. See exception below.');
        console.error(e);
      }
      try {
        this.efisVectors.update(deltaTime);
      } catch (e) {
        console.error('[FMS] Error during EFIS vectors update. See exception below.');
        console.error(e);
      }
      try {
        this.taskQueue.update(deltaTime);
      } catch (e) {
        console.error('[FMS] Error during task queue update. See exception below.');
        console.error(e);
      }
    }

    /**
     * Called when the lateral flight plan is changed
     */
    updateGeometries() {
      this.updateActiveGeometry();
      if (this.flightPlanManager.getFlightPlan(FlightPlans.Temporary)) {
        this.updateTemporaryGeometry();
      } else {
        this.temporaryGeometry = undefined;
      }
      this.recomputeGeometries();
      this.updateEfisIdent();
      this.geometryRecomputationTimer = 0;
      this.vnavDriver.acceptMultipleLegGeometry(this.activeGeometry);
      this.pseudoWaypoints.acceptMultipleLegGeometry(this.activeGeometry);
    }
    updateActiveGeometry() {
      const wptCount = this.flightPlanManager.getWaypointsCount(FlightPlans.Active);
      const activeIdx = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Active);
      if (this.activeGeometry) {
        this.guidanceManager.updateGeometry(this.activeGeometry, FlightPlans.Active, activeIdx, wptCount);
      } else {
        this.activeGeometry = this.guidanceManager.getMultipleLegGeometry();
      }
    }
    updateTemporaryGeometry() {
      const wptCount = this.flightPlanManager.getWaypointsCount(FlightPlans.Temporary);
      const activeIdx = this.flightPlanManager.getActiveWaypointIndex(false, false, FlightPlans.Temporary);
      if (this.temporaryGeometry) {
        this.guidanceManager.updateGeometry(this.temporaryGeometry, FlightPlans.Temporary, activeIdx, wptCount);
      } else {
        this.temporaryGeometry = this.guidanceManager.getMultipleLegGeometry(true);
      }
    }
    recomputeGeometries() {
      const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', 'Knots');
      const gs = SimVar.GetSimVarValue('GPS GROUND SPEED', 'Knots');
      const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
      if (this.activeGeometry) {
        this.activeGeometry.recomputeWithParameters(tas, gs, this.lnavDriver.ppos, trueTrack, this.activeLegIndex, this.activeTransIndex);
      }
      if (this.temporaryGeometry) {
        this.temporaryGeometry.recomputeWithParameters(tas, gs, this.lnavDriver.ppos, trueTrack, this.temporaryLegIndex, this.temporaryLegIndex - 1);
      }
    }

    /**
     * Notifies the FMS that a pseudo waypoint must be sequenced.
     *
     * This is to be sued by {@link LnavDriver} only.
     *
     * @param pseudoWaypoint the {@link PseudoWaypoint} to sequence.
     */
    sequencePseudoWaypoint(pseudoWaypoint) {
      this.pseudoWaypoints.sequencePseudoWaypoint(pseudoWaypoint);
    }
    isManualHoldActive() {
      if (this.activeGeometry) {
        const activeLeg = this.activeGeometry.legs.get(this.activeLegIndex);
        return activeLeg instanceof HMLeg;
      }
      return false;
    }
    isManualHoldNext() {
      if (this.activeGeometry) {
        const nextLeg = this.activeGeometry.legs.get(this.activeLegIndex + 1);
        return nextLeg instanceof HMLeg;
      }
      return false;
    }
    setHoldSpeed(tas) {
      let holdLeg;
      if (this.isManualHoldActive()) {
        holdLeg = this.activeGeometry.legs.get(this.activeLegIndex);
      } else if (this.isManualHoldNext()) {
        holdLeg = this.activeGeometry.legs.get(this.activeLegIndex + 1);
      }
      if (holdLeg) {
        holdLeg.setPredictedTas(tas);
      }
    }
  }

  // WARNING: this is a temporary implementation until the new nav database is complete
  // Do not write any code which depends on it
  class NearbyFacilities {
    constructor() {
      _defineProperty(this, "nearbyAirports", new Map());
      _defineProperty(this, "nearbyNdbNavaids", new Map());
      _defineProperty(this, "nearbyVhfNavaids", new Map());
      _defineProperty(this, "nearbyWaypoints", new Map());
      _defineProperty(this, "version", 0);
      _defineProperty(this, "listener", void 0);
      _defineProperty(this, "initDone", false);
      _defineProperty(this, "airportSessionId", void 0);
      _defineProperty(this, "ndbSessionId", void 0);
      _defineProperty(this, "vorSessionId", void 0);
      _defineProperty(this, "waypointSessionId", void 0);
      _defineProperty(this, "ppos", {
        lat: 0,
        long: 0
      });
      _defineProperty(this, "pposValid", false);
      _defineProperty(this, "throttler", new A32NX_Util.UpdateThrottler(10000));
      _defineProperty(this, "radius", 381 * 1852);
      // metres
      _defineProperty(this, "limit", 160);
      this.listener = RegisterViewListener('JS_LISTENER_FACILITY', async () => {
        this.listener.on('SendAirport', this.addAirport.bind(this));
        this.listener.on('SendIntersection', this.addWaypoint.bind(this));
        this.listener.on('SendNdb', this.addNdbNavaid.bind(this));
        this.listener.on('SendVor', this.addVhfNavaid.bind(this));
        this.listener.on('NearestSearchCompleted', this.onSearchCompleted.bind(this));
        this.airportSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Airport);
        this.ndbSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Ndb);
        this.vorSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Vor);
        this.waypointSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Intersection);
        this.initDone = true;
      });
    }
    static getInstance() {
      if (!NearbyFacilities.instance) {
        NearbyFacilities.instance = new NearbyFacilities();
      }
      return NearbyFacilities.instance;
    }
    getAirports() {
      return this.pposValid ? this.nearbyAirports.values() : [][Symbol.iterator]();
    }
    getNdbNavaids() {
      return this.pposValid ? this.nearbyNdbNavaids.values() : [][Symbol.iterator]();
    }
    getVhfNavaids() {
      return this.pposValid ? this.nearbyVhfNavaids.values() : [][Symbol.iterator]();
    }
    getWaypoints() {
      return this.pposValid ? this.nearbyWaypoints.values() : [][Symbol.iterator]();
    }
    init() {
      // Do nothing for now
    }
    async update(deltaTime) {
      if (!this.initDone || this.throttler.canUpdate(deltaTime) === -1) {
        return;
      }
      if (this.pposValid) {
        Coherent.call('SEARCH_NEAREST', this.airportSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
        Coherent.call('SEARCH_NEAREST', this.vorSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
        Coherent.call('SEARCH_NEAREST', this.ndbSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
        Coherent.call('SEARCH_NEAREST', this.waypointSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
      }
    }
    setPpos(ppos) {
      if (ppos === null) {
        this.pposValid = false;
      } else if (!this.pposValid || Avionics.Utils.computeDistance(ppos, this.ppos) > 5) {
        this.ppos.lat = ppos.lat;
        this.ppos.long = ppos.long;
        this.pposValid = true;
      }
    }
    onSearchCompleted(result) {
      let nearestList;
      let loadCall;
      switch (result.sessionId) {
        case this.airportSessionId:
          nearestList = this.nearbyAirports;
          loadCall = 'LOAD_AIRPORTS';
          break;
        case this.ndbSessionId:
          nearestList = this.nearbyNdbNavaids;
          loadCall = 'LOAD_NDBS';
          break;
        case this.vorSessionId:
          nearestList = this.nearbyVhfNavaids;
          loadCall = 'LOAD_VORS';
          break;
        case this.waypointSessionId:
          nearestList = this.nearbyWaypoints;
          loadCall = 'LOAD_INTERSECTIONS';
          break;
        default:
          return;
      }
      for (const icao of result.removed) {
        delete nearestList[icao];
        this.version++;
      }
      const loadIcaos = [];
      for (const icao of result.added) {
        if (nearestList.has(icao)) {
          continue;
        }
        loadIcaos.push(icao);
      }
      if (loadIcaos.length > 0) {
        Coherent.call(loadCall, loadIcaos);
      }
    }
    addAirport(airport) {
      this.nearbyAirports.set(airport.icao, airport);
      this.version++;
    }
    addWaypoint(waypoint) {
      this.nearbyWaypoints.set(waypoint.icao, waypoint);
      this.version++;
    }
    addNdbNavaid(ndb) {
      this.nearbyNdbNavaids.set(ndb.icao, ndb);
      this.version++;
    }
    addVhfNavaid(vor) {
      this.nearbyVhfNavaids.set(vor.icao, vor);
      this.version++;
    }
  }
  _defineProperty(NearbyFacilities, "instance", void 0);

  class EfisSymbols {
    constructor(flightPlanManager, guidanceController, navaidTuner) {
      this.navaidTuner = navaidTuner;
      _defineProperty(this, "blockUpdate", false);
      _defineProperty(this, "flightPlanManager", void 0);
      _defineProperty(this, "guidanceController", void 0);
      _defineProperty(this, "guidanceManager", void 0);
      _defineProperty(this, "nearby", void 0);
      _defineProperty(this, "syncer", new GenericDataListenerSync());
      _defineProperty(this, "lastMode", {
        L: -1,
        R: -1
      });
      _defineProperty(this, "lastRange", {
        L: 0,
        R: 0
      });
      _defineProperty(this, "lastEfisOption", {
        L: 0,
        R: 0
      });
      _defineProperty(this, "lastPlanCentre", undefined);
      _defineProperty(this, "lastPpos", {
        lat: 0,
        long: 0
      });
      _defineProperty(this, "lastTrueHeading", -1);
      _defineProperty(this, "lastNearbyFacilitiesVersion", void 0);
      _defineProperty(this, "lastFpVersion", void 0);
      _defineProperty(this, "lastNavaidVersion", -1);
      _defineProperty(this, "lastVnavDriverVersion", -1);
      this.flightPlanManager = flightPlanManager;
      this.guidanceController = guidanceController;
      this.guidanceManager = guidanceController.guidanceManager;
      this.nearby = NearbyFacilities.getInstance();
    }
    init() {
      this.nearby.init();
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async update(deltaTime) {
      var _this$flightPlanManag, _this$lastPlanCentre, _this$lastPlanCentre2;
      if (this.blockUpdate) {
        return;
      }

      // TODO use FMGC position
      const ppos = {
        lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
        long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
      };
      const trueHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
      const pposChanged = Avionics.Utils.computeDistance(this.lastPpos, ppos) > 2;
      if (pposChanged) {
        this.lastPpos = ppos;
      }
      const trueHeadingChanged = Avionics.Utils.diffAngle(trueHeading, this.lastTrueHeading) > 2;
      if (trueHeadingChanged) {
        this.lastTrueHeading = trueHeading;
      }
      const nearbyFacilitiesChanged = this.nearby.version !== this.lastNearbyFacilitiesVersion;
      this.lastNearbyFacilitiesVersion = this.nearby.version;
      const fpChanged = this.lastFpVersion !== this.flightPlanManager.currentFlightPlanVersion;
      this.lastFpVersion = this.flightPlanManager.currentFlightPlanVersion;
      // FIXME map reference point should be per side
      const planCentreIndex = SimVar.GetSimVarValue('L:A32NX_SELECTED_WAYPOINT', 'number');
      const planCentre = (_this$flightPlanManag = this.flightPlanManager.getWaypoint(planCentreIndex)) === null || _this$flightPlanManag === void 0 ? void 0 : _this$flightPlanManag.infos.coordinates;
      const planCentreChanged = (planCentre === null || planCentre === void 0 ? void 0 : planCentre.lat) !== ((_this$lastPlanCentre = this.lastPlanCentre) === null || _this$lastPlanCentre === void 0 ? void 0 : _this$lastPlanCentre.lat) || (planCentre === null || planCentre === void 0 ? void 0 : planCentre.long) !== ((_this$lastPlanCentre2 = this.lastPlanCentre) === null || _this$lastPlanCentre2 === void 0 ? void 0 : _this$lastPlanCentre2.long);
      this.lastPlanCentre = planCentre;
      const navaidsChanged = this.lastNavaidVersion !== this.navaidTuner.navaidVersion;
      this.lastNavaidVersion = this.navaidTuner.navaidVersion;
      const vnavPredictionsChanged = this.lastVnavDriverVersion !== this.guidanceController.vnavDriver.version;
      this.lastVnavDriverVersion = this.guidanceController.vnavDriver.version;
      const activeFp = this.flightPlanManager.getCurrentFlightPlan();
      // TODO temp f-pln

      const hasSuitableRunway = airport => {
        for (const runway of airport.runways) {
          switch (runway.surface) {
            case RunwaySurface.Asphalt:
            case RunwaySurface.Bituminous:
            case RunwaySurface.Concrete:
            case RunwaySurface.Tarmac:
              if (runway.length >= 1500 && runway.width >= 30) {
                return true;
              }
              break;
          }
        }
        return false;
      };
      for (const side of EfisSymbols.sides) {
        var _this$guidanceControl;
        const range = rangeSettings[SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_RANGE"), 'number')];
        const mode = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_MODE"), 'number');
        const efisOption = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_OPTION"), 'Enum');
        const rangeChange = this.lastRange[side] !== range;
        this.lastRange[side] = range;
        const modeChange = this.lastMode[side] !== mode;
        this.lastMode[side] = mode;
        const efisOptionChange = this.lastEfisOption[side] !== efisOption;
        this.lastEfisOption[side] = efisOption;
        const nearbyOverlayChanged = efisOption !== EfisOption.Constraints && efisOption !== EfisOption.None && nearbyFacilitiesChanged;
        if (!pposChanged && !trueHeadingChanged && !rangeChange && !modeChange && !efisOptionChange && !nearbyOverlayChanged && !fpChanged && !planCentreChanged && !navaidsChanged && !vnavPredictionsChanged) {
          continue;
        }
        if (mode === EfisNdMode.PLAN && !planCentre) {
          this.syncer.sendEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), []);
          return;
        }
        const [editAhead, editBehind, editBeside] = this.calculateEditArea(range, mode);

        // eslint-disable-next-line no-loop-func
        const withinEditArea = ll => {
          const dist = Avionics.Utils.computeGreatCircleDistance(mode === EfisNdMode.PLAN ? planCentre : ppos, ll);
          let bearing = Avionics.Utils.computeGreatCircleHeading(mode === EfisNdMode.PLAN ? planCentre : ppos, ll);
          if (mode !== EfisNdMode.PLAN) {
            bearing = Avionics.Utils.clampAngle(bearing - trueHeading);
          }
          bearing = bearing * Math.PI / 180;
          const dx = dist * Math.sin(bearing);
          const dy = dist * Math.cos(bearing);
          return Math.abs(dx) < editBeside && dy > -editBehind && dy < editAhead;
        };
        const symbols = [];

        // symbols most recently inserted always end up at the end of the array
        // we reverse the array at the end to make sure symbols are drawn in the correct order
        // eslint-disable-next-line no-loop-func
        const upsertSymbol = symbol => {
          const symbolIdx = symbols.findIndex(s => s.databaseId === symbol.databaseId);
          if (symbolIdx !== -1) {
            var _symbol$constraints, _symbol$direction, _symbol$length, _symbol$location;
            const oldSymbol = symbols.splice(symbolIdx, 1)[0];
            symbol.constraints = (_symbol$constraints = symbol.constraints) !== null && _symbol$constraints !== void 0 ? _symbol$constraints : oldSymbol.constraints;
            symbol.direction = (_symbol$direction = symbol.direction) !== null && _symbol$direction !== void 0 ? _symbol$direction : oldSymbol.direction;
            symbol.length = (_symbol$length = symbol.length) !== null && _symbol$length !== void 0 ? _symbol$length : oldSymbol.length;
            symbol.location = (_symbol$location = symbol.location) !== null && _symbol$location !== void 0 ? _symbol$location : oldSymbol.location;
            symbol.type |= oldSymbol.type;
            if (oldSymbol.radials) {
              if (symbol.radials) {
                symbol.radials.push(...oldSymbol.radials);
              } else {
                symbol.radials = oldSymbol.radials;
              }
            }
            if (oldSymbol.radii) {
              if (symbol.radii) {
                symbol.radii.push(...oldSymbol.radii);
              } else {
                symbol.radii = oldSymbol.radii;
              }
            }
          }
          symbols.push(symbol);
        };

        // TODO ADIRs aligned (except in plan mode...?)
        if (efisOption === EfisOption.VorDmes) {
          for (const vor of this.nearby.getVhfNavaids()) {
            if (vor.type !== VorType$1.VORDME && vor.type !== VorType$1.VOR && vor.type !== VorType$1.DME && vor.type !== VorType$1.VORTAC && vor.type !== VorType$1.TACAN) {
              continue;
            }
            const ll = {
              lat: vor.lat,
              long: vor.lon
            };
            if (withinEditArea(ll)) {
              upsertSymbol({
                databaseId: vor.icao,
                ident: vor.icao.substring(7, 12),
                location: ll,
                type: this.vorDmeTypeFlag(vor.type) | NdSymbolTypeFlags.EfisOption
              });
            }
          }
        } else if (efisOption === EfisOption.Ndbs) {
          for (const ndb of this.nearby.getNdbNavaids()) {
            const ll = {
              lat: ndb.lat,
              long: ndb.lon
            };
            if (withinEditArea(ll)) {
              upsertSymbol({
                databaseId: ndb.icao,
                ident: ndb.icao.substring(7, 12),
                location: ll,
                type: NdSymbolTypeFlags.Ndb | NdSymbolTypeFlags.EfisOption
              });
            }
          }
        } else if (efisOption === EfisOption.Airports) {
          for (const ap of this.nearby.getAirports()) {
            const ll = {
              lat: ap.lat,
              long: ap.lon
            };
            if (withinEditArea(ll) && hasSuitableRunway(ap)) {
              upsertSymbol({
                databaseId: ap.icao,
                ident: ap.icao.substring(7, 12),
                location: ll,
                type: NdSymbolTypeFlags.Airport | NdSymbolTypeFlags.EfisOption
              });
            }
          }
        } else if (efisOption === EfisOption.Waypoints) {
          for (const wp of this.nearby.getWaypoints()) {
            const ll = {
              lat: wp.lat,
              long: wp.lon
            };
            if (withinEditArea(ll)) {
              upsertSymbol({
                databaseId: wp.icao,
                ident: wp.icao.substring(7, 12),
                location: ll,
                type: NdSymbolTypeFlags.Waypoint | NdSymbolTypeFlags.EfisOption
              });
            }
          }
        }
        for (let i = 0; i < 4; i++) {
          const fixInfo = this.flightPlanManager.getFixInfo(i);
          const refFix = fixInfo === null || fixInfo === void 0 ? void 0 : fixInfo.getRefFix();
          if (refFix !== undefined) {
            upsertSymbol({
              databaseId: refFix.icao,
              ident: refFix.ident,
              location: refFix.infos.coordinates,
              type: NdSymbolTypeFlags.FixInfo,
              radials: fixInfo.getRadialTrueBearings(),
              radii: [fixInfo.getRadiusValue()]
            });
          }
        }
        const formatConstraintAlt = function (alt, descent) {
          var _activeFp$originTrans, _activeFp$destination;
          let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
          const transAlt = (_activeFp$originTrans = activeFp === null || activeFp === void 0 ? void 0 : activeFp.originTransitionAltitudePilot) !== null && _activeFp$originTrans !== void 0 ? _activeFp$originTrans : activeFp === null || activeFp === void 0 ? void 0 : activeFp.originTransitionAltitudeDb;
          const transFl = (_activeFp$destination = activeFp === null || activeFp === void 0 ? void 0 : activeFp.destinationTransitionLevelPilot) !== null && _activeFp$destination !== void 0 ? _activeFp$destination : activeFp === null || activeFp === void 0 ? void 0 : activeFp.destinationTransitionLevelDb;
          if (descent) {
            const fl = Math.round(alt / 100);
            if (transFl && fl >= transFl) {
              return "".concat(prefix, "FL").concat(fl);
            }
          } else if (transAlt && alt >= transAlt) {
            return "".concat(prefix, "FL").concat(Math.round(alt / 100));
          }
          return "".concat(prefix).concat(Math.round(alt));
        };
        const formatConstraintSpeed = function (speed) {
          let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          return "".concat(prefix).concat(Math.floor(speed), "KT");
        };
        for (const [index, leg] of this.guidanceController.activeGeometry.legs.entries()) {
          if (!leg.isNull && leg.terminationWaypoint && leg.displayedOnMap) {
            if (!(leg.terminationWaypoint instanceof WayPoint)) {
              const isActive = index === this.guidanceController.activeLegIndex;
              let type = NdSymbolTypeFlags.FlightPlan;
              if (isActive) {
                type |= NdSymbolTypeFlags.ActiveLegTermination;
              }
              const ident = leg.ident;
              const cutIdent = leg.ident.substring(0, 4).padEnd(5, ' ');
              const id = (Math.random() * 10000000).toString().substring(0, 5);
              upsertSymbol({
                databaseId: "X".concat(id).concat(cutIdent),
                ident,
                type,
                location: leg.terminationWaypoint
              });
            }
          }
        }
        const isInLatAutoControl = this.guidanceController.vnavDriver.isLatAutoControlActive();
        const waypointPredictions = (_this$guidanceControl = this.guidanceController.vnavDriver.mcduProfile) === null || _this$guidanceControl === void 0 ? void 0 : _this$guidanceControl.waypointPredictions;
        const isSelectedVerticalModeActive = this.guidanceController.vnavDriver.isSelectedVerticalModeActive();
        const flightPhase = getFlightPhaseManager().phase;

        // TODO don't send the waypoint before active once FP sequencing is properly implemented
        // (currently sequences with guidance which is too early)
        // eslint-disable-next-line no-lone-blocks
        {
          for (let i = activeFp.length - 1; i >= activeFp.activeWaypointIndex - 1 && i >= 0; i--) {
            const wp = activeFp.getWaypoint(i);
            if (!wp) {
              continue;
            }
            const isFromWp = i < activeFp.activeWaypointIndex;

            // FIXME these should integrate with the normal algorithms to pick up contraints, not be drawn in enroute ranges, etc.
            const legType = wp.additionalData.legType;
            if (EfisSymbols.LEG_MANAGED_TYPES.includes(legType)) {
              continue;
            }
            if (wp.type === 'A') {
              // we pick these up later
              continue;
            }
            // if range >= 160, don't include terminal waypoints, except at enroute boundary
            if (range >= 160) {
              const segment = activeFp.findSegmentByWaypointIndex(i);
              if (segment.type === SegmentType.Departure) {
                // keep the last waypoint from the SID as it is the enroute boundary
                if (!activeFp.isLastWaypointInSegment(i)) {
                  continue;
                }
              } else if (segment.type !== SegmentType.Enroute) {
                continue;
              }
            }
            if (!withinEditArea(wp.infos.coordinates)) {
              continue;
            }
            let type = NdSymbolTypeFlags.FlightPlan;
            const constraints = [];
            let direction;
            const isCourseReversal = wp.additionalData.legType === LegType$1.HA || wp.additionalData.legType === LegType$1.HF || wp.additionalData.legType === LegType$1.HM || wp.additionalData.legType === LegType$1.PI;
            if (i === activeFp.activeWaypointIndex) {
              type |= NdSymbolTypeFlags.ActiveLegTermination;
            } else if (isCourseReversal && i > activeFp.activeWaypointIndex + 1 && range <= 80 && !LnavConfig.DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS) {
              if (wp.turnDirection === TurnDirection.Left) {
                type |= NdSymbolTypeFlags.CourseReversalLeft;
              } else {
                type |= NdSymbolTypeFlags.CourseReversalRight;
              }
              direction = wp.additionalData.course;
            }
            if (isInLatAutoControl && !isFromWp && wp.legAltitudeDescription > 0 && wp.legAltitudeDescription < 6) {
              if (!isSelectedVerticalModeActive && shouldShowConstraintCircleInPhase(flightPhase, wp)) {
                type |= NdSymbolTypeFlags.Constraint;
                const predictionAtWaypoint = waypointPredictions.get(i);
                if (predictionAtWaypoint !== null && predictionAtWaypoint !== void 0 && predictionAtWaypoint.isAltitudeConstraintMet) {
                  type |= NdSymbolTypeFlags.MagentaColor;
                } else if (predictionAtWaypoint) {
                  type |= NdSymbolTypeFlags.AmberColor;
                }
              } else if (i === activeFp.activeWaypointIndex) {
                type |= NdSymbolTypeFlags.Constraint;
              }
            }
            if (efisOption === EfisOption.Constraints && !isFromWp) {
              const descent = wp.constraintType === WaypointConstraintType$1.DES;
              switch (wp.legAltitudeDescription) {
                case 1:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent));
                  break;
                case 2:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '+'));
                  break;
                case 3:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '-'));
                  break;
                case 4:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '-'));
                  constraints.push(formatConstraintAlt(wp.legAltitude2, descent, '+'));
                  break;
              }
              if (wp.speedConstraint > 0) {
                constraints.push(formatConstraintSpeed(wp.speedConstraint));
              }
            }
            upsertSymbol({
              databaseId: wp.icao,
              ident: wp.ident,
              location: wp.infos.coordinates,
              type,
              constraints: constraints.length > 0 ? constraints : undefined,
              direction
            });
          }
        }

        // we can only send 2 constraint predictions, so filter out any past the 2 close to the AC
        let constraintPredictions = 0;
        const constraintFlags = NdSymbolTypeFlags.Constraint | NdSymbolTypeFlags.MagentaColor | NdSymbolTypeFlags.AmberColor;
        for (let i = symbols.length - 1; i >= 0; i--) {
          if ((symbols[i].type & constraintFlags) === 0) {
            continue;
          }
          if (constraintPredictions >= 2) {
            symbols[i].type &= ~constraintFlags;
          } else {
            constraintPredictions++;
          }
        }
        const airports = [[activeFp.originAirfield, activeFp.getOriginRunway()], [activeFp.destinationAirfield, activeFp.getDestinationRunway()]];
        for (const [airport, runway] of airports) {
          if (!airport) {
            continue;
          }
          if (runway) {
            if (withinEditArea(runway.beginningCoordinates)) {
              upsertSymbol({
                databaseId: airport.icao,
                ident: "".concat(airport.ident).concat(Avionics.Utils.formatRunway(runway.designation)),
                location: runway.beginningCoordinates,
                direction: runway.direction,
                length: runway.length / 1852,
                type: NdSymbolTypeFlags.Runway
              });
            }
          } else if (withinEditArea(airport.infos.coordinates)) {
            upsertSymbol({
              databaseId: airport.icao,
              ident: airport.ident,
              location: airport.infos.coordinates,
              type: NdSymbolTypeFlags.Airport
            });
          }
        }

        // Pseudo waypoints

        for (const pwp of this.guidanceController.currentPseudoWaypoints.filter(it => it && it.displayedOnNd)) {
          upsertSymbol({
            databaseId: "W      ".concat(pwp.ident),
            ident: pwp.ident,
            location: pwp.efisSymbolLla,
            type: pwp.efisSymbolFlag,
            distanceFromAirplane: pwp.distanceFromStart
          });
        }
        for (const ndb of this.navaidTuner.tunedNdbs) {
          upsertSymbol({
            databaseId: ndb.icao,
            ident: WayPoint.formatIdentFromIcao(ndb.icao),
            location: {
              lat: ndb.lat,
              long: ndb.lon
            },
            type: NdSymbolTypeFlags.Ndb | NdSymbolTypeFlags.Tuned
          });
        }
        for (const vor of this.navaidTuner.tunedVors) {
          upsertSymbol({
            databaseId: vor.icao,
            ident: WayPoint.formatIdentFromIcao(vor.icao),
            location: {
              lat: vor.lat,
              long: vor.lon
            },
            type: this.vorDmeTypeFlag(vor.type) | NdSymbolTypeFlags.Tuned
          });
        }
        const wordsPerSymbol = 6;
        const maxSymbols = 640 / wordsPerSymbol;
        if (symbols.length > maxSymbols) {
          symbols.splice(0, symbols.length - maxSymbols);
          this.guidanceController.efisStateForSide[side].dataLimitReached = true;
        } else {
          this.guidanceController.efisStateForSide[side].dataLimitReached = false;
        }
        this.syncer.sendEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), symbols);

        // make sure we don't run too often
        this.blockUpdate = true;
        setTimeout(() => {
          this.blockUpdate = false;
        }, 200);
      }
    }
    vorDmeTypeFlag(type) {
      switch (type) {
        case VorType$1.VORDME:
        case VorType$1.VORTAC:
          return NdSymbolTypeFlags.VorDme;
        case VorType$1.VOR:
          return NdSymbolTypeFlags.Vor;
        case VorType$1.DME:
        case VorType$1.TACAN:
          return NdSymbolTypeFlags.Dme;
        default:
          return 0;
      }
    }
    calculateEditArea(range, mode) {
      switch (mode) {
        case EfisNdMode.ARC:
          if (range <= 10) {
            return [10.5, 3.5, 8.3];
          }
          if (range <= 20) {
            return [20.5, 7, 16.6];
          }
          if (range <= 40) {
            return [40.5, 14, 33.2];
          }
          if (range <= 80) {
            return [80.5, 28, 66.4];
          }
          if (range <= 160) {
            return [160.5, 56, 132.8];
          }
          return [320.5, 112, 265.6];
        case EfisNdMode.ROSE_NAV:
          if (range <= 10) {
            return [7.6, 7.1, 7.1];
          }
          if (range <= 20) {
            return [14.7, 14.2, 14.2];
          }
          if (range <= 40) {
            return [28.9, 28.4, 28.4];
          }
          if (range <= 80) {
            return [57.3, 56.8, 56.8];
          }
          if (range <= 160) {
            return [114.1, 113.6, 113.6];
          }
          return [227.7, 227.2, 227.2];
        case EfisNdMode.PLAN:
          if (range <= 10) {
            return [7, 7, 7];
          }
          if (range <= 20) {
            return [14, 14, 14];
          }
          if (range <= 40) {
            return [28, 28, 28];
          }
          if (range <= 80) {
            return [56, 56, 56];
          }
          if (range <= 160) {
            return [112, 112, 112];
          }
          return [224, 224, 224];
        default:
          return [0, 0, 0];
      }
    }
  }
  /** these types of legs are current not integrated into the normal symbol drawing routines */
  _defineProperty(EfisSymbols, "LEG_MANAGED_TYPES", [LegType$1.CA, LegType$1.CR, LegType$1.CI, LegType$1.FM, LegType$1.PI, LegType$1.VA, LegType$1.VI, LegType$1.VM]);
  _defineProperty(EfisSymbols, "sides", ['L', 'R']);
  const shouldShowConstraintCircleInPhase = (phase, waypoint) => (phase === FmgcFlightPhase.Takeoff || phase === FmgcFlightPhase.Climb) && waypoint.additionalData.constraintType === WaypointConstraintType$1.CLB || (phase === FmgcFlightPhase.Cruise || phase === FmgcFlightPhase.Descent || phase === FmgcFlightPhase.Approach) && waypoint.additionalData.constraintType === WaypointConstraintType$1.DES;

  // Note the logic for this is different on A330/350/380

  class FcuSync {
    constructor() {
      _defineProperty(this, "trueRef", false);
    }
    // eslint-disable-next-line no-empty-function
    init() {}
    update(_deltaTime) {
      const irMaint = Arinc429Word.fromSimVarValue('L:A32NX_ADIRS_IR_1_MAINT_WORD');
      const trueRefPb = SimVar.GetSimVarValue('L:A32NX_PUSH_TRUE_REF', 'bool');
      const trueRef = (irMaint.getBitValueOr(15, false) || trueRefPb) && !irMaint.getBitValueOr(2, false);
      if (trueRef !== this.trueRef) {
        this.trueRef = trueRef;
        SimVar.SetSimVarValue('L:A32NX_FMGC_TRUE_REF', 'boolean', trueRef);
        const activeMode = SimVar.GetSimVarValue('L:A32NX_FMA_LATERAL_MODE', 'number');
        if (activeMode === LateralMode.HDG || activeMode === LateralMode.TRACK) {
          SimVar.SetSimVarValue('L:A32NX_FM_HEADING_SYNC', 'boolean', true);
        }
      }
    }
  }

  class ReadySignal {
    constructor() {
      _defineProperty(this, "baseInstrument", null);
      _defineProperty(this, "updateThrottler", new A32NX_Util.UpdateThrottler(1000));
    }
    init(baseInstrument, _flightPlanManager) {
      this.baseInstrument = baseInstrument;
    }
    update(deltaTime) {
      if (this.updateThrottler.canUpdate(deltaTime) !== -1 && this.baseInstrument.getGameState() === GameState.ingame && SimVar.GetSimVarValue('L:A32NX_IS_READY', 'number') !== 1) {
        // set ready signal that JS code is initialized and flight is actually started
        // -> user pressed 'READY TO FLY' button
        SimVar.SetSimVarValue('L:A32NX_IS_READY', 'number', 1);
      }
    }
  }

  class EfisLabels {
    constructor() {
      _defineProperty(this, "lastTransitionAltitude", void 0);
      _defineProperty(this, "lastTransitionLevel", void 0);
      _defineProperty(this, "flightPlanManager", void 0);
    }
    init(_baseInstrument, flightPlanManager) {
      this.flightPlanManager = flightPlanManager;
    }
    update(_deltaTime) {
      const transitionAltitude = this.flightPlanManager.originTransitionAltitude;
      const transitionLevel = this.flightPlanManager.destinationTransitionLevel;

      // FIXME ARINC429 when the PR adding a TS impl. lands...
      if (transitionAltitude !== this.lastTransitionAltitude) {
        SimVar.SetSimVarValue('L:AIRLINER_TRANS_ALT', 'Number', transitionAltitude !== null && transitionAltitude !== void 0 ? transitionAltitude : 0);
        this.lastTransitionAltitude = transitionAltitude;
      }
      if (transitionLevel !== this.lastTransitionLevel) {
        SimVar.SetSimVarValue('L:AIRLINER_APPR_TRANS_ALT', 'Number', (transitionLevel !== null && transitionLevel !== void 0 ? transitionLevel : 0) * 100);
        this.lastTransitionLevel = transitionLevel;
      }
    }
  }

  /** See a320-coherent-triggers.md */
  const FMMessageTriggers = {
    SEND_TO_MCDU: 'A32NX_FMGC_SEND_MESSAGE_TO_MCDU',
    RECALL_FROM_MCDU_WITH_ID: 'A32NX_FMGC_RECALL_MESSAGE_FROM_MCDU_WITH_ID',
    POP_FROM_STACK: 'A32NX_FMGC_POP_MESSAGE'
  };

  /* eslint-disable no-multi-spaces */
  let NdFmMessageFlag = /*#__PURE__*/function (NdFmMessageFlag) {
    NdFmMessageFlag[NdFmMessageFlag["None"] = 0] = "None";
    NdFmMessageFlag[NdFmMessageFlag["SelectTrueRef"] = 1] = "SelectTrueRef";
    NdFmMessageFlag[NdFmMessageFlag["CheckNorthRef"] = 2] = "CheckNorthRef";
    NdFmMessageFlag[NdFmMessageFlag["NavAccuracyDowngrade"] = 4] = "NavAccuracyDowngrade";
    NdFmMessageFlag[NdFmMessageFlag["NavAccuracyUpgradeNoGps"] = 8] = "NavAccuracyUpgradeNoGps";
    NdFmMessageFlag[NdFmMessageFlag["SpecifiedVorDmeUnavailble"] = 16] = "SpecifiedVorDmeUnavailble";
    NdFmMessageFlag[NdFmMessageFlag["NavAccuracyUpgradeGps"] = 32] = "NavAccuracyUpgradeGps";
    NdFmMessageFlag[NdFmMessageFlag["GpsPrimary"] = 64] = "GpsPrimary";
    NdFmMessageFlag[NdFmMessageFlag["MapPartlyDisplayed"] = 128] = "MapPartlyDisplayed";
    NdFmMessageFlag[NdFmMessageFlag["SetOffsideRangeMode"] = 256] = "SetOffsideRangeMode";
    NdFmMessageFlag[NdFmMessageFlag["OffsideFmControl"] = 512] = "OffsideFmControl";
    NdFmMessageFlag[NdFmMessageFlag["OffsideFmWxrControl"] = 1024] = "OffsideFmWxrControl";
    NdFmMessageFlag[NdFmMessageFlag["OffsideWxrControl"] = 2048] = "OffsideWxrControl";
    NdFmMessageFlag[NdFmMessageFlag["GpsPrimaryLost"] = 4096] = "GpsPrimaryLost";
    NdFmMessageFlag[NdFmMessageFlag["RtaMissed"] = 8192] = "RtaMissed";
    NdFmMessageFlag[NdFmMessageFlag["BackupNav"] = 16384] = "BackupNav";
    return NdFmMessageFlag;
  }({});
  /* eslint-enable no-multi-spaces */

  const FMMessageTypes = {
    SelectTrueRef: {
      id: 1,
      ndFlag: NdFmMessageFlag.SelectTrueRef,
      text: 'SELECT TRUE REF',
      color: 'Amber',
      ndPriority: 1,
      clearable: true
    },
    CheckNorthRef: {
      id: 2,
      ndFlag: NdFmMessageFlag.CheckNorthRef,
      text: 'CHECK NORTH REF',
      color: 'Amber',
      ndPriority: 1,
      clearable: true
    },
    NavAccuracyDowngrade: {
      id: 3,
      ndFlag: NdFmMessageFlag.NavAccuracyDowngrade,
      text: 'NAV ACCUR DOWNGRAD',
      color: 'Amber',
      ndPriority: 1,
      clearable: true
    },
    NavAccuracyUpgradeNoGps: {
      id: 4,
      ndFlag: NdFmMessageFlag.NavAccuracyUpgradeNoGps,
      text: 'NAV ACCUR UPGRAD',
      color: 'Amber',
      ndPriority: 1,
      clearable: true
    },
    SpecifiedVorDmeUnavailble: {
      id: 5,
      ndFlag: NdFmMessageFlag.SpecifiedVorDmeUnavailble,
      text: 'SPECIF VOR/D UNAVAIL',
      color: 'Amber',
      ndPriority: 1,
      clearable: true
    },
    NavAccuracyUpgradeGps: {
      id: 6,
      ndFlag: NdFmMessageFlag.NavAccuracyUpgradeGps,
      text: 'NAV ACCUR UPGRAD',
      color: 'White',
      ndPriority: 1,
      clearable: true
    },
    GpsPrimary: {
      id: 7,
      ndFlag: NdFmMessageFlag.GpsPrimary,
      text: 'GPS PRIMARY',
      color: 'White',
      ndPriority: 1,
      clearable: true
    },
    MapPartlyDisplayed: {
      id: 8,
      ndFlag: NdFmMessageFlag.MapPartlyDisplayed,
      efisText: 'MAP PARTLY DISPLAYED',
      color: 'Amber',
      ndPriority: 2
    },
    SetOffsideRangeMode: {
      id: 9,
      ndFlag: NdFmMessageFlag.SetOffsideRangeMode,
      text: 'SET OFFSIDE RNG/MODE',
      color: 'Amber',
      ndPriority: 3
    },
    OffsideFmControl: {
      id: 10,
      ndFlag: NdFmMessageFlag.OffsideFmControl,
      text: 'OFFSIDE FM CONTROL',
      color: 'Amber',
      ndPriority: 4
    },
    OffsideFmWxrControl: {
      id: 11,
      ndFlag: NdFmMessageFlag.OffsideFmWxrControl,
      text: 'OFFSIDE FM/WXR CONTROL',
      color: 'Amber',
      ndPriority: 5
    },
    OffsideWxrControl: {
      id: 12,
      ndFlag: NdFmMessageFlag.OffsideWxrControl,
      text: 'OFFSIDE WXR CONTROL',
      color: 'Amber',
      ndPriority: 6
    },
    GpsPrimaryLost: {
      id: 13,
      ndFlag: NdFmMessageFlag.GpsPrimaryLost,
      text: 'GPS PRIMARY LOST',
      color: 'Amber',
      ndPriority: 7
    },
    RtaMissed: {
      id: 14,
      ndFlag: NdFmMessageFlag.RtaMissed,
      text: 'RTA MISSED',
      color: 'Amber',
      ndPriority: 8
    },
    BackupNav: {
      id: 15,
      ndFlag: NdFmMessageFlag.BackupNav,
      text: 'BACK UP NAV',
      color: 'Amber',
      ndPriority: 9
    },
    TurnAreaExceedance: {
      id: 16,
      text: 'TURN AREA EXCEEDANCE',
      color: 'Amber'
    },
    TuneNavaid: {
      id: 17,
      text: 'TUNE BBB FFF.FF',
      color: 'Amber'
    },
    SpecifiedNdbUnavailble: {
      id: 18,
      text: 'SPECIF NDB UNAVAIL',
      color: 'Amber'
    },
    RwyLsMismatch: {
      id: 19,
      text: 'RWY/LS MISMATCH',
      color: 'Amber'
    },
    TdReached: {
      id: 17,
      text: 'T/D REACHED',
      color: 'White',
      clearable: true
    },
    StepAhead: {
      id: 18,
      text: 'STEP AHEAD',
      color: 'White',
      clearable: true
    },
    StepDeleted: {
      id: 19,
      text: 'STEP DELETED',
      color: 'White',
      clearable: true
    }
  };

  class RwyLsMismatch {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.RwyLsMismatch);
      _defineProperty(this, "efisSide", void 0);
      _defineProperty(this, "trigRising", new Trigger(true));
      _defineProperty(this, "trigFalling", new Trigger(true));
      _defineProperty(this, "navaidTuner", void 0);
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getRwyLsMismatchMessage();
      this.trigRising.input = message;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !message;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return FMMessageUpdate.SEND;
      }
      if (this.trigFalling.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }
  class RwyLsMismatchLeft extends RwyLsMismatch {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'L');
    }
  }
  class RwyLsMismatchRight extends RwyLsMismatch {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'R');
    }
  }

  class SpecifiedNdbUnavailable {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.SpecifiedNdbUnavailble);
      _defineProperty(this, "efisSide", void 0);
      _defineProperty(this, "trigRising", new Trigger(true));
      _defineProperty(this, "trigFalling", new Trigger(true));
      _defineProperty(this, "navaidTuner", void 0);
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getSpecifiedNdbMessage();
      this.trigRising.input = message;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !message;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return FMMessageUpdate.SEND;
      }
      if (this.trigFalling.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }
  class SpecifiedNdbUnavailableLeft extends SpecifiedNdbUnavailable {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'L');
    }
  }
  class SpecifiedNdbUnavailableRight extends SpecifiedNdbUnavailable {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'R');
    }
  }

  class SpecifiedVorUnavailable {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.SpecifiedVorDmeUnavailble);
      _defineProperty(this, "efisSide", void 0);
      _defineProperty(this, "trigRising", new Trigger(true));
      _defineProperty(this, "trigFalling", new Trigger(true));
      _defineProperty(this, "navaidTuner", void 0);
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getSpecifiedVorMessage();
      this.trigRising.input = message;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !message;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return FMMessageUpdate.SEND;
      }
      if (this.trigFalling.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }
  class SpecifiedVorUnavailableLeft extends SpecifiedVorUnavailable {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'L');
    }
  }
  class SpecifiedVorUnavailableRight extends SpecifiedVorUnavailable {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'R');
    }
  }

  class TuneNavaid {
    constructor() {
      _defineProperty(this, "message", _objectSpread2({}, FMMessageTypes.TuneNavaid));
      _defineProperty(this, "efisSide", void 0);
      _defineProperty(this, "trigRising", new Trigger(true));
      _defineProperty(this, "trigFalling", new Trigger(true));
      _defineProperty(this, "navaidTuner", void 0);
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getTuneNavaidMessage();
      this.trigRising.input = message !== null;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = message === null;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        const [freqeuncy, ident] = message;
        const baseMessage = FMMessageTypes.TuneNavaid.text;
        this.message.text = baseMessage.replace('BBB', ident).replace('FFF.FF', freqeuncy.toFixed(2));
        return FMMessageUpdate.SEND;
      }
      if (this.trigFalling.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }
  class TuneNavaidLeft extends TuneNavaid {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'L');
    }
  }
  class TuneNavaidRight extends TuneNavaid {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'R');
    }
  }

  class TurnAreaExceedance {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.TurnAreaExceedance);
      _defineProperty(this, "efisSide", void 0);
      _defineProperty(this, "trigRising", new Trigger(true));
      _defineProperty(this, "trigFalling", new Trigger(true));
      _defineProperty(this, "guidanceController", void 0);
      _defineProperty(this, "navigation", void 0);
    }
    init(baseInstrument) {
      this.guidanceController = baseInstrument.guidanceController;
      this.navigation = baseInstrument.navigation;
    }
    process(deltaTime) {
      var _this$guidanceControl;
      const gs = this.navigation.groundSpeed;
      const dtg = (_this$guidanceControl = this.guidanceController.activeLegDtg) !== null && _this$guidanceControl !== void 0 ? _this$guidanceControl : Infinity;
      const ttg = gs > 10 ? 3600 * dtg / gs : Infinity;
      const nextLeg = this.guidanceController.activeGeometry.legs.get(this.guidanceController.activeLegIndex + 1);

      // if within 1.5 min of PI and it's path goes outside the coded distance limit
      const turnAreaExceeded = ttg <= 90 && nextLeg instanceof PILeg && nextLeg.turnAreaExceeded;
      this.trigRising.input = turnAreaExceeded;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !turnAreaExceeded;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return FMMessageUpdate.SEND;
      }
      if (this.trigFalling.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }
  class TurnAreaExceedanceLeft extends TurnAreaExceedance {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'L');
    }
  }
  class TurnAreaExceedanceRight extends TurnAreaExceedance {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'R');
    }
  }

  class TdReached {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.TdReached);
      _defineProperty(this, "lastState", false);
    }
    process(_) {
      const newState = SimVar.GetSimVarValue('L:A32NX_PFD_MSG_TD_REACHED', 'Bool') === 1;
      if (newState !== this.lastState) {
        this.lastState = newState;
        return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }

  class StepAhead {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.StepAhead);
      _defineProperty(this, "guidanceController", void 0);
      _defineProperty(this, "lastState", false);
    }
    init(baseInstrument) {
      this.guidanceController = baseInstrument.guidanceController;
    }
    process(_) {
      var _this$guidanceControl;
      const fpm = this.guidanceController.flightPlanManager;
      const distanceToEnd = this.guidanceController.vnavDriver.distanceToEnd;
      if (!((_this$guidanceControl = this.guidanceController.vnavDriver.mcduProfile) !== null && _this$guidanceControl !== void 0 && _this$guidanceControl.isReadyToDisplay) || distanceToEnd <= 0) {
        return FMMessageUpdate.NO_ACTION;
      }
      let newState = false;
      for (let i = fpm.getActiveWaypointIndex(); i < fpm.getWaypointsCount(FlightPlans.Active); i++) {
        const waypoint = fpm.getWaypoint(i, FlightPlans.Active);
        if (!waypoint || !waypoint.additionalData.cruiseStep || waypoint.additionalData.cruiseStep.isIgnored) {
          continue;
        }
        if (distanceToEnd - waypoint.additionalData.distanceToEnd < 20) {
          newState = true;
        }
      }
      if (newState !== this.lastState) {
        this.lastState = newState;
        return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }

  class StepDeleted {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.StepDeleted);
    }
    process(_) {
      const newState = SimVar.GetSimVarValue('L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED', 'Bool') === 1;
      if (newState) {
        SimVar.SetSimVarValue('L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED', 'boolean', false);
        return FMMessageUpdate.SEND;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }

  class GpsPrimary {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.GpsPrimary);
      _defineProperty(this, "lastState", false);
    }
    process(_) {
      const newState = SimVar.GetSimVarValue('L:A32NX_ADIRS_USES_GPS_AS_PRIMARY', 'Bool') === 1;
      if (newState !== this.lastState) {
        this.lastState = newState;
        return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }

  /**
   * Since this happens when the simvar goes to zero, we need to use some CONF nodes to make sure we do not count the initial
   * first-frame value, as the ADIRS module might not have run yet.
   */
  class GpsPrimaryLost {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.GpsPrimaryLost);
      _defineProperty(this, "confLost", new ConfirmationNode(1000));
      _defineProperty(this, "trigLost", new Trigger(true));
      _defineProperty(this, "confRegained", new ConfirmationNode(1000));
      _defineProperty(this, "trigRegained", new Trigger(true));
    }
    process(deltaTime) {
      const lostNow = SimVar.GetSimVarValue('L:A32NX_ADIRS_USES_GPS_AS_PRIMARY', 'Bool') === 0;
      this.confLost.input = lostNow;
      this.confLost.update(deltaTime);
      this.trigLost.input = this.confLost.output;
      this.trigLost.update(deltaTime);
      this.confRegained.input = !lostNow;
      this.confRegained.update(deltaTime);
      this.trigRegained.input = this.confRegained.output;
      this.trigRegained.update(deltaTime);
      if (this.trigLost.output) {
        return FMMessageUpdate.SEND;
      }
      if (this.trigRegained.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }

  class MapPartlyDisplayed {
    constructor() {
      _defineProperty(this, "message", FMMessageTypes.MapPartlyDisplayed);
      _defineProperty(this, "efisSide", void 0);
      _defineProperty(this, "trigRising", new Trigger(true));
      _defineProperty(this, "trigFalling", new Trigger(true));
    }
    process(deltaTime) {
      const partlyDisplayed = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(this.efisSide, "_MAP_PARTLY_DISPLAYED"), 'boolean');
      this.trigRising.input = partlyDisplayed === 1;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = partlyDisplayed === 0;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return FMMessageUpdate.SEND;
      }
      if (this.trigFalling.output) {
        return FMMessageUpdate.RECALL;
      }
      return FMMessageUpdate.NO_ACTION;
    }
  }
  class MapPartlyDisplayedLeft extends MapPartlyDisplayed {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'L');
    }
  }
  class MapPartlyDisplayedRight extends MapPartlyDisplayed {
    constructor() {
      super(...arguments);
      _defineProperty(this, "efisSide", 'R');
    }
  }

  /**
   * This class manages Type II messages sent from the FMGC.
   *
   * Since many of those are also sent to the EFIS, this class sets a bitfield signalling the active messages to the DMCs
   *
   * At the moment, other Type II messages which are not displayed on the EFIS are declared in the old JavaScript CDU/"FMC".
   *
   * **Note:** The plan is eventually to move them here as well - but since they can be triggered manually on pilot output as well, and it
   * is not currently convenient to use this class from the JS CDU, we will not do that at the moment
   *
   * -Benjamin
   */
  class FmsMessages {
    constructor() {
      _defineProperty(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));
      _defineProperty(this, "baseInstrument", void 0);
      _defineProperty(this, "ndMessageFlags", {
        L: 0,
        R: 0
      });
      _defineProperty(this, "messageSelectors", [new GpsPrimary(), new GpsPrimaryLost(), new MapPartlyDisplayedLeft(), new MapPartlyDisplayedRight(), new TurnAreaExceedanceLeft(), new TurnAreaExceedanceRight(), new TuneNavaidLeft(), new TuneNavaidRight(), new SpecifiedVorUnavailableLeft(), new SpecifiedVorUnavailableRight(), new SpecifiedNdbUnavailableLeft(), new SpecifiedNdbUnavailableRight(), new RwyLsMismatchLeft(), new RwyLsMismatchRight(), new TdReached(), new StepAhead(), new StepDeleted()]);
    }
    init(baseInstrument, _flightPlanManager) {
      this.baseInstrument = baseInstrument;
      for (const selector of this.messageSelectors) {
        if (selector.init) {
          selector.init(this.baseInstrument);
        }
      }
    }
    update(deltaTime) {
      let didMutateNd = false;
      for (const selector of this.messageSelectors) {
        const newState = selector.process(deltaTime);
        const message = selector.message;
        switch (newState) {
          case FMMessageUpdate.SEND:
            if (message.text) {
              this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
            }
            if (message.ndFlag > 0) {
              if (selector.efisSide) {
                this.ndMessageFlags[selector.efisSide] |= message.ndFlag;
              } else {
                for (const side in this.ndMessageFlags) {
                  if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
                    this.ndMessageFlags[side] |= message.ndFlag;
                  }
                }
              }
              didMutateNd = true;
            }
            break;
          case FMMessageUpdate.RECALL:
            if (message.text) {
              this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id
            }

            if (message.ndFlag > 0) {
              if (selector.efisSide) {
                this.ndMessageFlags[selector.efisSide] &= ~message.ndFlag;
              } else {
                for (const side in this.ndMessageFlags) {
                  if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
                    this.ndMessageFlags[side] &= ~message.ndFlag;
                  }
                }
              }
              didMutateNd = true;
            }
            break;
          case FMMessageUpdate.NO_ACTION:
            break;
          default:
            throw new Error('Invalid FM message update state');
        }
      }
      if (didMutateNd) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
          }
        }
      }
    }
    send(messageClass) {
      const message = this.messageSelectors.find(it => it instanceof messageClass).message;
      this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
      if (message.ndFlag) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            this.ndMessageFlags[side] |= message.ndFlag;
            SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
          }
        }
      }
    }
    recall(messageClass) {
      const message = this.messageSelectors.find(it => it instanceof messageClass).message;
      this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id

      if (message.ndFlag) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            this.ndMessageFlags[side] &= ~message.ndFlag;
            SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
          }
        }
      }
    }
    recallId(id) {
      const message = this.messageSelectors.find(it => it.message.id === id).message;
      this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id

      if (message.ndFlag) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            this.ndMessageFlags[side] &= ~message.ndFlag;
            SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
          }
        }
      }
    }
  }

  /**
   * Type II message update state.
   *
   * Used when a message selector implements the {@link FMMessageSelector.process `process`} method.
   */
  let FMMessageUpdate = /*#__PURE__*/function (FMMessageUpdate) {
    FMMessageUpdate[FMMessageUpdate["NO_ACTION"] = 0] = "NO_ACTION";
    FMMessageUpdate[FMMessageUpdate["SEND"] = 1] = "SEND";
    FMMessageUpdate[FMMessageUpdate["RECALL"] = 2] = "RECALL";
    return FMMessageUpdate;
  }({});

  /**
   * Defines a selector for a Type II message.
   */

  const fmsMessages = new FmsMessages();
  const components = [fmsMessages, new EfisLabels(), new ReadySignal(), new FcuSync()];
  function initComponents(baseInstrument, flightPlanManager) {
    components.forEach(component => component.init(baseInstrument, flightPlanManager));
  }
  function updateComponents(deltaTime) {
    components.forEach(component => component.update(deltaTime));
  }
  function recallMessageById(id) {
    fmsMessages.recallId(id);
  }

  class LandingSystemSelectionManager {
    constructor(navigationProvider, fpm, facLoader) {
      this.navigationProvider = navigationProvider;
      this.fpm = fpm;
      this.facLoader = facLoader;
      _defineProperty(this, "ppos", {
        lat: 0,
        long: 0
      });
      _defineProperty(this, "pposValid", false);
      _defineProperty(this, "flightPlanVersion", -1);
      _defineProperty(this, "_selectedIls", null);
      _defineProperty(this, "_selectedLocCourse", null);
      _defineProperty(this, "_selectedApproachBackcourse", false);
      _defineProperty(this, "_selectedGsSlope", null);
      _defineProperty(this, "flightPhaseManager", void 0);
      _defineProperty(this, "autotuneUpdateThrottler", new A32NX_Util.UpdateThrottler(30000));
      _defineProperty(this, "inProcess", false);
      this.flightPhaseManager = getFlightPhaseManager();
    }
    async update(deltaTime) {
      const forceUpdate = this.fpm.currentFlightPlanVersion !== this.flightPlanVersion;
      this.flightPlanVersion = this.fpm.currentFlightPlanVersion;
      if (this.autotuneUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
        if (this.inProcess) {
          return;
        }
        this.inProcess = true;
        try {
          this.updatePpos();
          const phase = this.flightPhaseManager.phase;
          if (phase <= FmgcFlightPhase.Takeoff) {
            await this.selectDepartureIls();
          } else if (phase >= FmgcFlightPhase.Descent) {
            await this.selectApproachIls();
          } else if (this.pposValid) {
            const destination = this.fpm.getDestination(FlightPlans.Active);
            if (destination && distanceTo(this.ppos, destination.infos.coordinates) <= LandingSystemSelectionManager.DESTINATION_TUNING_DISTANCE) {
              await this.selectApproachIls();
            }
          }
        } catch (e) {
          console.error('Failed to select ILS', e);
          this.resetSelectedIls();
        } finally {
          this.inProcess = false;
        }
      }
    }
    updatePpos() {
      const ppos = this.navigationProvider.getPpos();
      if (ppos === null) {
        this.pposValid = false;
      } else {
        this.ppos.lat = ppos.lat;
        this.ppos.long = ppos.long;
        this.pposValid = true;
      }
    }
    async selectDepartureIls() {
      const airport = this.fpm.getPersistentOrigin(FlightPlans.Active);
      const runway = this.fpm.getOriginRunway(FlightPlans.Active);
      if (await this.setIlsFromRunway(runway)) {
        return true;
      }
      if (await this.setIlsForRunwayFromApproaches(airport, runway)) {
        return true;
      }

      // if we got here there wasn't a suitable ILS
      this.resetSelectedIls();
      return false;
    }
    async selectApproachIls() {
      const airport = this.fpm.getDestination(FlightPlans.Active);
      const approach = this.fpm.getApproach(FlightPlans.Active);
      if (this.isTunableApproach(approach === null || approach === void 0 ? void 0 : approach.approachType) && this.setIlsFromApproach(airport, approach, true)) {
        return true;
      }

      // if we got here there wasn't a suitable ILS
      this.resetSelectedIls();
      return false;
    }

    /**
     * Attempt to set the ILS from the runway data
     * @param runway The runway
     * @param icao If specified, the facility will only be selected if it matches this icao
     * @param checkBothEnds Check the secondary runway too in case it's a backcourse approach
     * @returns true on success
     */
    async setIlsFromRunway(runway, icao) {
      let checkBothEnds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (!runway) {
        return false;
      }
      const frequencies = [runway.primaryILSFrequency];
      if (checkBothEnds) {
        frequencies.push(runway.secondaryILSFrequency);
      }
      for (const frequency of frequencies) {
        if (frequency.freqMHz > 0 && (!icao || frequency.icao === icao)) {
          var _this$_selectedIls;
          if (frequency.icao === ((_this$_selectedIls = this._selectedIls) === null || _this$_selectedIls === void 0 ? void 0 : _this$_selectedIls.icao)) {
            return true;
          }

          // eslint-disable-next-line no-await-in-loop
          const loc = await this.facLoader.getFacilityRaw(frequency.icao, 1500, true);
          if (!loc) {
            return false;
          }
          this._selectedIls = loc;
          this._selectedLocCourse = frequency.localizerCourse;
          this._selectedGsSlope = frequency.hasGlideslope ? -frequency.glideslopeAngle : null;
          return true;
        }
      }
      return false;
    }
    async setIlsForRunwayFromApproaches(airport, runway) {
      // If the airport has correct navdata, the ILS will be listed as the reference navaid (originIcao in MSFS land) on at least the last leg of the
      // ILS approach procedure(s). Tuning this way gives us the ident, and the course
      if (airport && airport.infos && airport.infos.icao.charAt(0) === 'A' && runway) {
        const approaches = airport.infos.approaches;
        for (const approach of approaches) {
          // L(eft), C(entre), R(ight), T(true North) are the possible runway designators (ARINC424)
          // If there are multiple procedures for the same type of approach, an alphanumeric suffix is added to their names (last subpattern)
          // We are a little more lenient than ARINC424 in an effort to match non-perfect navdata, so we allow dashes, spaces, or nothing before the suffix
          if (approach.approachType === ApproachType.APPROACH_TYPE_ILS && approach.runwayNumber === runway.number && approach.runwayDesignator === runway.designator && approach.finalLegs.length > 0) {
            return this.setIlsFromApproach(airport, approach);
          }
        }
      }
      return false;
    }

    /**
     * Attempt to set the ILS from approach data
     * @param airport Airport the approach is to
     * @param approach The approach
     * @param checkRunwayFrequencies if true, runway frequency data will be checked for course/gs information.
     * This method is better if possible because it can get proper glideslope info.
     * unfortunately many scenery developers break the runway <-> ILS links and the data is not available
     * @returns true on success
     */
    async setIlsFromApproach(airport, approach) {
      var _finalLeg$originIcao$, _this$_selectedIls2;
      let checkRunwayFrequencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
      if (((_finalLeg$originIcao$ = finalLeg === null || finalLeg === void 0 ? void 0 : finalLeg.originIcao.trim()) !== null && _finalLeg$originIcao$ !== void 0 ? _finalLeg$originIcao$ : '').length === 0) {
        return false;
      }
      if (finalLeg.originIcao === ((_this$_selectedIls2 = this._selectedIls) === null || _this$_selectedIls2 === void 0 ? void 0 : _this$_selectedIls2.icao)) {
        return true;
      }
      if (checkRunwayFrequencies) {
        const runway = airport.infos.oneWayRunways.find(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
        if (runway && (await this.setIlsFromRunway(runway, finalLeg.originIcao, true))) {
          return true;
        }
      }
      const loc = await this.facLoader.getFacilityRaw(finalLeg.originIcao, 1500, true);
      if (!loc) {
        return false;
      }
      this._selectedIls = loc;
      const courseSlope = await this.getIlsCourseSlopeFromApproach(airport, approach, loc);
      if (courseSlope !== null) {
        this._selectedApproachBackcourse = courseSlope.backcourse;
        this._selectedLocCourse = courseSlope.course;
        this._selectedGsSlope = courseSlope.slope;
      } else {
        this._selectedApproachBackcourse = false;
        this._selectedLocCourse = null;
        this._selectedGsSlope = null;
      }
      return true;
    }

    /**
     * Try to get the course and slope for an ILS from an approach
     * @param airport Airport the approach is from
     * @param approach The approach
     * @param ils The ILS/LOC
     * @returns course/slope data, null fields if not available. Caution: it is not safe to keep a reference to this object.
     */
    async getIlsCourseSlopeFromApproach(airport, approach, ils) {
      const runway = airport.infos.oneWayRunways.find(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
      if (runway) {
        const frequencies = [runway.primaryILSFrequency, runway.secondaryILSFrequency];
        for (const frequency of frequencies) {
          if (frequency.freqMHz > 0 && frequency.icao === ils.icao) {
            LandingSystemSelectionManager.courseSlopeCache.backcourse = approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE;
            LandingSystemSelectionManager.courseSlopeCache.course = frequency.localizerCourse;
            LandingSystemSelectionManager.courseSlopeCache.slope = frequency.hasGlideslope ? -frequency.glideslopeAngle : null;
            return LandingSystemSelectionManager.courseSlopeCache;
          }
        }
      }
      const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
      if (!finalLeg) {
        return null;
      }
      let finalLegCourse = finalLeg.trueDegrees ? A32NX_Util.trueToMagnetic(finalLeg.course, -ils.magneticVariation) : finalLeg.course;
      if (finalLeg.type === LegType$1.TF) {
        const previousLeg = approach.finalLegs[approach.finalLegs.length - 2];
        if (!previousLeg || !previousLeg.fixIcao.trim() || !finalLeg.fixIcao.trim()) {
          return null;
        }
        const finalWp = await this.facLoader.getFacility(finalLeg.fixIcao);
        const previousWp = await this.facLoader.getFacility(previousLeg.fixIcao);
        if (!finalWp || !previousWp) {
          return null;
        }
        finalLegCourse = A32NX_Util.trueToMagnetic(bearingTo(previousWp.infos.coordinates, finalWp.infos.coordinates), -ils.magneticVariation);
      }
      const ilsApproachExists = airport.infos.approaches.find(a => a.approachType === ApproachType.APPROACH_TYPE_ILS && a.runwayNumber === approach.runwayNumber && a.runwayDesignator === approach.runwayDesignator) !== undefined;
      LandingSystemSelectionManager.courseSlopeCache.backcourse = approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE;
      LandingSystemSelectionManager.courseSlopeCache.course = LandingSystemSelectionManager.courseSlopeCache.backcourse ? finalLegCourse + 180 : finalLegCourse;
      LandingSystemSelectionManager.courseSlopeCache.slope = finalLeg.verticalAngle && ilsApproachExists ? finalLeg.verticalAngle - 360 : null;
      return LandingSystemSelectionManager.courseSlopeCache;
    }
    resetSelectedIls() {
      this._selectedIls = null;
      this._selectedLocCourse = null;
      this._selectedApproachBackcourse = false;
      this._selectedGsSlope = null;
    }
    isTunableApproach(approachType) {
      // FIXME case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE: when FG can support it
      switch (approachType) {
        case ApproachType.APPROACH_TYPE_ILS:
        case ApproachType.APPROACH_TYPE_LOCALIZER:
        case ApproachType.APPROACH_TYPE_LDA:
        case ApproachType.APPROACH_TYPE_SDF:
          return true;
        default:
          return false;
      }
    }
    async tryGetCourseSlopeForIlsFromAirport(ils, airport) {
      for (const approach of airport.infos.approaches) {
        if (approach.approachType !== ApproachType.APPROACH_TYPE_ILS) {
          continue;
        }
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        if (!finalLeg) {
          continue;
        }
        if (finalLeg.originIcao === ils.icao) {
          // eslint-disable-next-line no-await-in-loop
          const data = await this.getIlsCourseSlopeFromApproach(airport, approach, ils);
          if (data !== null) {
            return [data.course, data.slope];
          }
        }
      }
      return null;
    }

    /** Try to get the course and slope for a manually tuned ILS */
    async tryGetCourseSlopeForIls(ils) {
      // first try the destination and origin fields, as we already have them loaded
      const flightPlan = this.fpm.activeFlightPlan;
      if (flightPlan.destinationAirfield) {
        const ret = await this.tryGetCourseSlopeForIlsFromAirport(ils, flightPlan.destinationAirfield);
        if (ret !== null) {
          return ret;
        }
      }
      if (flightPlan.originAirfield) {
        const ret = await this.tryGetCourseSlopeForIlsFromAirport(ils, flightPlan.originAirfield);
        if (ret !== null) {
          return ret;
        }
      }

      // last ditch see if it's encoded in the ils icao
      const airportIdent = ils.icao.slice(3, 7).trim();
      if (airportIdent.length === 4) {
        const airport = await this.facLoader.getFacility("A      ".concat(airportIdent));
        if (airport) {
          const ret = await this.tryGetCourseSlopeForIlsFromAirport(ils, airport);
          if (ret !== null) {
            return ret;
          }
        }
      }
      return [null, null];
    }
    get selectedIls() {
      return this._selectedIls;
    }
    get selectedLocCourse() {
      return this._selectedLocCourse !== null ? Math.round(this._selectedLocCourse % 360) : null;
    }
    get selectedApprBackcourse() {
      return this._selectedApproachBackcourse;
    }
    get selectedGsSlope() {
      return this._selectedGsSlope;
    }

    /** Reset all state e.g. when the nav database is switched */
    resetState() {
      this.resetSelectedIls();
    }
  }
  _defineProperty(LandingSystemSelectionManager, "DESTINATION_TUNING_DISTANCE", 300);
  _defineProperty(LandingSystemSelectionManager, "courseSlopeCache", {
    course: null,
    backcourse: false,
    slope: null
  });

  function arrayFlat(arr) {
    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return depth > 0 ? arr.reduce((acc, cur) => {
      if (Array.isArray(cur)) {
        acc.push(...arrayFlat(cur, depth - 1));
      } else {
        acc.push(cur);
      }
      return acc;
    }, []) : arr.slice();
  }

  let VorSelectionReason = /*#__PURE__*/function (VorSelectionReason) {
    VorSelectionReason[VorSelectionReason["None"] = 0] = "None";
    VorSelectionReason[VorSelectionReason["Display"] = 1] = "Display";
    VorSelectionReason[VorSelectionReason["Route"] = 2] = "Route";
    VorSelectionReason[VorSelectionReason["Navigation"] = 3] = "Navigation";
    VorSelectionReason[VorSelectionReason["Procedure"] = 4] = "Procedure";
    return VorSelectionReason;
  }({});
  class NavaidSelectionManager {
    constructor(navigationProvider, fpm) {
      this.navigationProvider = navigationProvider;
      this.fpm = fpm;
      _defineProperty(this, "nearbyFacilities", NearbyFacilities.getInstance());
      _defineProperty(this, "candidateUpdateThrottler", new A32NX_Util.UpdateThrottler(180));
      _defineProperty(this, "dmePairUpdateThrottler", new A32NX_Util.UpdateThrottler(10));
      _defineProperty(this, "autotuneUpdateThrottler", new A32NX_Util.UpdateThrottler(1));
      _defineProperty(this, "ppos", {
        lat: 0,
        long: 0
      });
      _defineProperty(this, "epe", Infinity);
      _defineProperty(this, "pposValid", false);
      _defineProperty(this, "altitude", 0);
      _defineProperty(this, "horizonDistance", 40);
      _defineProperty(this, "coneOfConfusionDistance", 0);
      /** Current candidate navaids eligbible for selection, sorted by distance from the aircraft (nearer navaids first) */
      _defineProperty(this, "candidateList", []);
      /** Current candidates for the lowest priority display VOR */
      _defineProperty(this, "vorCandidateList", []);
      /** Blacklist of navaids that were tuned but not received, maps icao to blacklist time */
      _defineProperty(this, "blackList", new Map());
      _defineProperty(this, "selectedDisplayVor", null);
      _defineProperty(this, "selectedDisplayVorReason", VorSelectionReason.None);
      _defineProperty(this, "selectedDmePair", null);
      _defineProperty(this, "selectedNdb", null);
      _defineProperty(this, "deselectedFacilities", new Set());
      _defineProperty(this, "specifiedVorDeselected", false);
      _defineProperty(this, "specifiedNdbDeselected", false);
      _defineProperty(this, "filteredHeight", null);
    }
    update(deltaTime) {
      let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.updatePpos();
      this.updateAltitude();
      if (this.pposValid) {
        if (this.candidateUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
          this.updateCandidateList();
        }
        try {
          if (this.dmePairUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
            this.selectDmePair();
          }
        } catch (e) {
          console.error('Error in DME pair selection', e);
        }
        try {
          if (this.autotuneUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
            this.selectDisplayVor();
            this.selectDisplayNdb();
          }
        } catch (e) {
          console.error('Error in display VOR selection', e);
        }
      }
      // if ppos not valid we don't change anything
    }

    updatePpos() {
      const ppos = this.navigationProvider.getPpos();
      if (ppos === null) {
        this.pposValid = false;
        this.selectedDisplayVor = null;
        this.selectedDmePair = null;
      } else {
        this.ppos.lat = ppos.lat;
        this.ppos.long = ppos.long;
        this.pposValid = true;
      }
      this.epe = this.navigationProvider.getEpe();
    }
    updateAltitude() {
      var _this$navigationProvi;
      // the MSFS navaids no not give any elevation data for our LoS/cone of confusion checks...
      // so we do a bit of a hack and assume all navaids are at ground level
      const baroAltitude = (_this$navigationProvi = this.navigationProvider.getBaroCorrectedAltitude()) !== null && _this$navigationProvi !== void 0 ? _this$navigationProvi : this.navigationProvider.getPressureAltitude();
      if (baroAltitude !== null) {
        // FIXME use baroAltitude when we have elevation data for navaids
        const height = SimVar.GetSimVarValue('PLANE ALT ABOVE GROUND', 'feet');
        if (this.filteredHeight === null) {
          this.filteredHeight = height;
        } else {
          this.filteredHeight = 0.01 * height + 0.99 * this.filteredHeight;
        }
        this.altitude = this.filteredHeight;
        const planeAltNm = this.altitude / 6076.12;
        this.horizonDistance = Math.sqrt(planeAltNm * (2 * EARTH_RADIUS + planeAltNm));
        this.coneOfConfusionDistance = planeAltNm * Math.tan(Math.PI / 6);
      }
    }
    updateCandidateList() {
      this.candidateList.length = 0;
      this.vorCandidateList.length = 0;
      const frequencies = new Set();
      const duplicateFrequencies = new Set();
      for (const facility of this.nearbyFacilities.getVhfNavaids()) {
        if (!this.isSuitableType(facility)) {
          continue;
        }
        const distance = distanceTo(this.ppos, {
          lat: facility.lat,
          long: facility.lon
        });
        if (this.isInLineOfSight(distance)) {
          if (frequencies.has(facility.freqBCD16)) {
            duplicateFrequencies.add(facility.freqBCD16);
          }
          frequencies.add(facility.freqBCD16);
        }
        const candidate = _objectSpread2({
          distance
        }, facility);
        if (this.isEligibleCandidate(facility, distance)) {
          this.candidateList.push(candidate);
        }
        if (this.isEligibleDisplayVor(facility, distance)) {
          this.vorCandidateList.push(candidate);
        }
      }
      for (let i = this.candidateList.length - 1; i >= 0; i--) {
        const facility = this.candidateList[i];
        if (duplicateFrequencies.has(facility.freqBCD16)) {
          this.candidateList.splice(i, 1);
        }
      }
      this.candidateList.sort((a, b) => a.distance - b.distance);
      this.vorCandidateList.sort((a, b) => a.distance - b.distance);
      this.vorCandidateList.length = Math.min(this.vorCandidateList.length, 7);
    }
    isEligibleCandidate(facility, distance) {
      return !this.isBlackListed(facility) && !this.isDeselected(facility) && this.isInLineOfSight(distance) && this.isWithinFom(facility, distance) && !this.isWithinConeOfConfusion(facility, distance) && this.isWithinGroundRange(distance);
    }
    isEligibleDisplayVor(facility, distance) {
      return this.isVor(facility) && this.isWithinFom(facility, distance) && !this.isDeselected(facility);
    }

    /** Checks if a navaid is a VOR type for display VOR tuning */
    isVor(facility) {
      return this.typeIsVor(facility.type);
    }
    typeIsVor(type) {
      return type === VorType$1.VOR || type === VorType$1.VORDME || type === VorType$1.VORTAC;
      // FIXME TACAN when the VOR tuner can handle TACANs..
    }

    /** Checks if a navaid is a co-located VOR/DME type for navigation */
    isVorDme(facility) {
      return facility.type === VorType$1.VORDME || facility.type === VorType$1.VORTAC;
    }

    /** Checks if a navaid has been blacklisted due to no reception */
    isBlackListed(facility) {
      return this.blackList.has(facility.icao);
    }

    /** Checks if a navaid is delsected by the pilot in the MCDU */
    isDeselected(facility) {
      return this.deselectedFacilities.has(facility.icao);
    }

    /** Checks if the navaid is able to be received over the horizon */
    isInLineOfSight(distance) {
      // FIXME should also consider navaid elevation but we don't have that from MSFS
      return distance <= Math.max(10, 7 / 6 * this.horizonDistance);
    }

    /** Checks if the navaid is within it's figure of merit limits */
    isWithinFom(facility, distance) {
      if (distance === undefined) {
        distance = distanceTo(this.ppos, {
          lat: facility.lat,
          long: facility.lon
        });
      }
      switch (facility.vorClass) {
        // MSFS thinks everything is 130ish
        case VorClass$1.HighAlttitude: //  return distance <= 250; // FoM 3
        case VorClass$1.Unknown:
          return distance <= 130;
        // unclassified, FoM 2
        case VorClass$1.LowAltitude:
          return distance <= 70 && this.altitude < 18000;
        // FoM 1
        case VorClass$1.Terminal:
          return distance <= 40 && this.altitude < 12000;
        // FoM 0
        default:
          return false;
      }
    }

    /** Checks if the navaid is too close to the aircraft overhead it */
    isWithinConeOfConfusion(facility, distance) {
      // FIXME should consider navaid elevation but MSFS doesn't give it to us
      return distance < this.coneOfConfusionDistance;
    }

    /** Checks if the navaid is too close to the aircraft laterally */
    isWithinGroundRange(distance) {
      return distance >= Math.min(9, Math.max(1, this.epe));
    }

    /** Filters out unsuitable types of MSFS navaid */
    isSuitableType(facility) {
      // FIXME we should be able to use ILS/DME but MSFS doesn't allow us to determine if an ILS has a DME
      return facility.vorClass !== VorClass$1.VOT && facility.type !== VorType$1.TACAN && facility.type !== VorType$1.ILS;
    }
    selectDmePair() {
      let findNewPair = this.selectedDmePair === null;
      let geometryCheck = false;
      if (this.selectedDmePair !== null) {
        // check the angle for the current pair
        const angle = this.calcDmePairAngle(this.selectedDmePair[0], this.selectedDmePair[1]);
        geometryCheck = angle < 70 || angle > 110;

        // check the current pair are still valid candidates
        findNewPair = findNewPair || !this.candidateList.some(v => v.icao === this.selectedDmePair[0].icao) || !this.candidateList.some(v => v.icao === this.selectedDmePair[1].icao);

        // FIXME either of the navaid idents don't match expected
        // FIXME either navaid not received or unstable for 10 seconds
        // we don't have enough NAV radios to actually tune DME pairs and check this
      }

      if (findNewPair || geometryCheck) {
        const pairs = arrayFlat(this.candidateList.map((a, i) => this.candidateList.slice(i + 1).map(b => [a, b])));

        /** angle diff from 90 for current best selection */
        let bestAngleDiff = Infinity;
        let bestPair = null;
        for (const [a, b] of pairs) {
          const angle = this.calcDmePairAngle(a, b);
          const validPair = angle > 30 && angle < 150;
          if (validPair) {
            if (this.altitude < 12000) {
              this.selectedDmePair = [a, b];
              return;
            }
            const angleDiff = Math.abs(diffAngle(90, angle));
            if (angleDiff < bestAngleDiff) {
              bestPair = [a, b];
              bestAngleDiff = angleDiff;
            }
          }
        }
        if (geometryCheck) {
          // only select a new pair if they're at least 10 close to the ideal 90
          const currentPairAngleDiff = Math.abs(diffAngle(90, this.calcDmePairAngle(this.selectedDmePair[0], this.selectedDmePair[1])));
          if (currentPairAngleDiff - bestAngleDiff >= 10) {
            this.selectedDmePair = bestPair;
          }
        } else {
          this.selectedDmePair = bestPair;
        }
      }
    }
    calcDmePairAngle(a, b) {
      // FIXME bearingTo really needs an overload that takes lat and lon as args
      const bearingA = bearingTo(this.ppos, {
        lat: a.lat,
        long: a.lon
      });
      const bearingB = bearingTo(this.ppos, {
        lat: b.lat,
        long: b.lon
      });
      return Math.abs(diffAngle(bearingA, bearingB));
    }
    getSpecifiedNavaid() {
      if (NavaidSelectionManager.SPECIFIED_VOR_APPROACH_TYPES.includes(this.fpm.getApproachType(FlightPlans.Active))) {
        var _finalLeg$additionalD;
        const waypoints = this.fpm.getApproachWaypoints(FlightPlans.Active);
        // due to cfms 1.5 messing up the last leg of the final approach, we take the second last
        const finalLeg = waypoints[waypoints.length - 2];
        // eslint-disable-next-line no-underscore-dangle
        const facility = (finalLeg === null || finalLeg === void 0 ? void 0 : (_finalLeg$additionalD = finalLeg.additionalData.recommendedFacility) === null || _finalLeg$additionalD === void 0 ? void 0 : _finalLeg$additionalD.__Type) === 'JS_FacilityVOR' ? finalLeg.additionalData.recommendedFacility : null;
        if (facility !== null && this.isVor(facility)) {
          return facility;
        }
      }
      return null;
    }
    selectDisplayVor() {
      // manually tuned handled in NavaidTuner

      this.specifiedVorDeselected = false;

      // procedure specified for the approach
      if (this.fpm.isActiveApproach(FlightPlans.Active)) {
        const specified = this.getSpecifiedNavaid();
        if (specified !== null) {
          if (this.isDeselected(specified)) {
            this.specifiedVorDeselected = true;
            // fall through and pick another criteria
          } else {
            this.setDisplayVor(specified, VorSelectionReason.Procedure);
            return;
          }
        }
      }
      if (this.selectedDmePair === null) {
        // reference navaid (vor/dme or vortac within 5 NM of dest runway, no dme pair available, and ppos < 51 NM from navaid)
        const refNavaid = this.getReferenceNavaid();
        if (refNavaid !== null) {
          this.setDisplayVor(refNavaid, VorSelectionReason.Navigation);
          return;
        }

        // closest co-located vor/dme when no DME pair available
        const colocated = this.getNearestColocatedNavaid();
        if (colocated !== null) {
          this.setDisplayVor(colocated, VorSelectionReason.Navigation);
          return;
        }
      }

      // route navaid (to waypoint or 5 next downpath within FoM limit)
      const activeLegIndex = this.fpm.getActiveWaypointIndex(false, false, FlightPlans.Active);
      if (activeLegIndex >= 0) {
        for (let i = activeLegIndex; i < activeLegIndex + 5; i++) {
          var _leg$additionalData$f;
          const leg = this.fpm.getWaypoint(i, FlightPlans.Active, true);
          if (!leg) {
            break;
          }

          // eslint-disable-next-line no-underscore-dangle
          const facility = ((_leg$additionalData$f = leg.additionalData.facility) === null || _leg$additionalData$f === void 0 ? void 0 : _leg$additionalData$f.__Type) === 'JS_FacilityVOR' ? leg.additionalData.facility : null;
          if (facility !== null && this.isVor(facility) && this.isWithinFom(facility)) {
            this.setDisplayVor(facility, VorSelectionReason.Route);
            return;
          }
        }
      }

      // closest vor/dme within FoM, with a little bit of stickiness to avoid swapping back and forth
      if (this.vorCandidateList.length > 0 && this.displayVor !== null) {
        const currentVor = this.vorCandidateList.find(v => v.icao === this.displayVor.icao);
        const replaceCurrentVor = !currentVor || this.selectedDisplayVorReason !== VorSelectionReason.Display || currentVor.distance - this.vorCandidateList[0].distance > NavaidSelectionManager.DISPLAY_VOR_STICKINESS_THRESHOLD;
        if (replaceCurrentVor) {
          this.setDisplayVor(this.vorCandidateList[0], VorSelectionReason.Display);
        }
      } else if (this.vorCandidateList.length > 0) {
        this.setDisplayVor(this.vorCandidateList[0], VorSelectionReason.Display);
      } else {
        this.setDisplayVor(null, VorSelectionReason.None);
      }
    }
    getNearestColocatedNavaid() {
      for (const candidate of this.candidateList) {
        if (this.isVorDme(candidate)) {
          return candidate;
        }
      }
      return null;
    }

    /**
     * Finds a VOR/DME or VOR/TAC within 5 NM of the destination runway and within 51 NM or the aircraft
     */
    getReferenceNavaid() {
      const destRunway = this.fpm.getDestinationRunway(FlightPlans.Active);
      if (!destRunway) {
        return null;
      }
      const candidates = this.candidateList.filter(v => this.isVorDme(v) && v.distance < 51);
      candidates.sort((a, b) => distanceTo(destRunway.thresholdCoordinates, {
        lat: a.lat,
        long: a.lon
      }) - distanceTo(destRunway.thresholdCoordinates, {
        lat: b.lat,
        long: b.lon
      }));
      if (candidates.length > 0 && distanceTo(destRunway.thresholdCoordinates, {
        lat: candidates[0].lat,
        long: candidates[0].lon
      }) < 5) {
        return candidates[0];
      }
      return null;
    }
    getSpecifiedNdb() {
      if (NavaidSelectionManager.SPECIFIED_NDB_APPROACH_TYPES.includes(this.fpm.getApproachType(FlightPlans.Active))) {
        var _finalLeg$additionalD2;
        const waypoints = this.fpm.getApproachWaypoints(FlightPlans.Active);
        // due to cfms 1.5 messing up the last leg of the final approach, we take the second last
        const finalLeg = waypoints[waypoints.length - 2];
        // eslint-disable-next-line no-underscore-dangle
        const facility = (finalLeg === null || finalLeg === void 0 ? void 0 : (_finalLeg$additionalD2 = finalLeg.additionalData.recommendedFacility) === null || _finalLeg$additionalD2 === void 0 ? void 0 : _finalLeg$additionalD2.__Type) === 'JS_FacilityNDB' ? finalLeg.additionalData.recommendedFacility : null;
        if (facility !== null) {
          return facility;
        }
      }
      return null;
    }
    selectDisplayNdb() {
      this.specifiedNdbDeselected = false;
      if (this.fpm.isActiveApproach(FlightPlans.Active)) {
        const specified = this.getSpecifiedNdb();
        if (specified !== null) {
          if (this.isDeselected(specified)) {
            this.specifiedNdbDeselected = true;
          } else {
            this.setDisplayNdb(specified);
            return;
          }
        }
      }
      this.setDisplayNdb(null);
    }
    setDisplayNdb(ndb) {
      this.selectedNdb = ndb;
    }
    setDisplayVor(vor, reason) {
      this.selectedDisplayVor = vor;
      this.selectedDisplayVorReason = reason;
    }
    get displayVor() {
      return this.selectedDisplayVor;
    }
    get displayVorReason() {
      return this.selectedDisplayVorReason;
    }
    get displayNdb() {
      return this.selectedNdb;
    }
    get displayNdbReason() {
      return this.selectedNdb !== null ? VorSelectionReason.Display : VorSelectionReason.None;
    }
    get dmePair() {
      return this.selectedDmePair;
    }
    deselectNavaid(icao) {
      this.deselectedFacilities.add(icao);
      this.update(0, true);
    }
    reselectNavaid(icao) {
      this.deselectedFacilities.delete(icao);
      this.update(0, true);
    }
    get deselectedNavaids() {
      return Array.from(this.deselectedFacilities);
    }
    get isSpecifiedVorDeselected() {
      return this.specifiedVorDeselected;
    }
    get isSpecifiedNdbDeselected() {
      return this.specifiedNdbDeselected;
    }

    /** Reset all state e.g. when the nav database is switched */
    resetState() {
      this.candidateList.length = 0;
      this.vorCandidateList.length = 0;
      this.blackList.clear();
      this.selectedDisplayVor = null;
      this.selectedDisplayVorReason = VorSelectionReason.None;
      this.selectedDmePair = null;
      this.selectedNdb = null;
      this.deselectedFacilities.clear();
      this.specifiedVorDeselected = false;
      this.specifiedNdbDeselected = false;
    }
  }
  // the closest VOR needs to be this much closer than the currently tuned one to make us swap
  _defineProperty(NavaidSelectionManager, "DISPLAY_VOR_STICKINESS_THRESHOLD", 2);
  _defineProperty(NavaidSelectionManager, "SPECIFIED_VOR_APPROACH_TYPES", [ApproachType.APPROACH_TYPE_RNAV, ApproachType.APPROACH_TYPE_VOR, ApproachType.APPROACH_TYPE_VORDME]);
  _defineProperty(NavaidSelectionManager, "SPECIFIED_NDB_APPROACH_TYPES", [ApproachType.APPROACH_TYPE_NDB, ApproachType.APPROACH_TYPE_NDBDME]);

  // Copyright (c) 2023 FlyByWire Simulations
  // SPDX-License-Identifier: GPL-3.0

  class NavRadioUtils {
    static vhfFrequenciesAreEqual(a, b) {
      return Math.abs((a !== null && a !== void 0 ? a : 0) - (b !== null && b !== void 0 ? b : 0)) < 0.01;
    }
  }

  class NavaidTuner {
    constructor(navigationProvider, navaidSelectionManager, landingSystemSelectionManager) {
      this.navigationProvider = navigationProvider;
      this.navaidSelectionManager = navaidSelectionManager;
      this.landingSystemSelectionManager = landingSystemSelectionManager;
      _defineProperty(this, "vorTuningStatus", [{
        // VOR 1
        frequency: null,
        ident: null,
        manual: false,
        course: null,
        dmeOnly: false
      }, {
        // VOR 2
        frequency: null,
        ident: null,
        manual: false,
        course: null,
        dmeOnly: false
      }]);
      _defineProperty(this, "mmrTuningStatus", [{
        // MMR 1
        databaseCourse: null,
        databaseBackcourse: false,
        frequency: null,
        course: null,
        courseManual: false,
        ident: null,
        manual: false,
        backcourse: false,
        slope: null
      }, {
        // MMR 2
        databaseCourse: null,
        databaseBackcourse: false,
        frequency: null,
        course: null,
        courseManual: false,
        ident: null,
        manual: false,
        backcourse: false,
        slope: null
      }]);
      _defineProperty(this, "adfTuningStatus", [{
        // ADF 1
        frequency: null,
        ident: null,
        manual: false,
        bfo: false
      }, {
        // ADF 2
        frequency: null,
        ident: null,
        manual: false,
        bfo: false
      }]);
      _defineProperty(this, "lastVorFrequencies", [null, null]);
      _defineProperty(this, "lastVorCourses", [null, null]);
      _defineProperty(this, "lastMmrFrequencies", [null, null]);
      _defineProperty(this, "lastMmrCourses", [null, null]);
      _defineProperty(this, "lastAdfFrequencies", [null, null]);
      /** Increments each time the tuned navaids change */
      _defineProperty(this, "navaidVersion", 0);
      _defineProperty(this, "rmpTuningActive", false);
      _defineProperty(this, "arincNavDiscrete", Arinc429Word.empty());
      _defineProperty(this, "lastArincNavDiscreteValueWritten", null);
      _defineProperty(this, "tuneNavaidMessage", null);
      _defineProperty(this, "rwyLsMismatchMessage", false);
      _defineProperty(this, "tuningLockoutTimer", -1);
      _defineProperty(this, "tuningActive", false);
      _defineProperty(this, "flightPhaseManager", void 0);
      /** Whether the tuning event blocked message has been shown before. It is only shown once. */
      _defineProperty(this, "blockEventMessageShown", false);
      // eslint-disable-next-line camelcase
      _defineProperty(this, "tipsManager", void 0);
      this.flightPhaseManager = getFlightPhaseManager();
    }
    init() {
      this.resetAllReceivers();

      // FIXME move this to the RMP when it's rewritten in msfs-avionics-framework
      // FIXME use the framework manager when the framework is updated
      this.tipsManager = A32NX_TipsManager.instance;
      Coherent.on('keyIntercepted', this.handleKeyEvent.bind(this));
      NavaidTuner.TUNING_EVENT_INTERCEPTS.forEach(key => Coherent.call('INTERCEPT_KEY_EVENT', key, 1));
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    update(deltaTime) {
      // FIXME RMPs should provide a discrete output for this
      const rmpTuningActive = SimVar.GetSimVarValue('L:A32NX_RMP_L_NAV_BUTTON_SELECTED', 'bool') || SimVar.GetSimVarValue('L:A32NX_RMP_R_NAV_BUTTON_SELECTED', 'bool');
      const rmpTuningDeActivated = !rmpTuningActive && this.rmpTuningActive;
      this.rmpTuningActive = rmpTuningActive;
      if (rmpTuningDeActivated) {
        // What should happen here is the receivers don't receive any frequency labels on the bus for a short while
        // and they go into standby mode. Since we use the sim radios this doesn't happen so we explicitly reset them to 0
        // This one really belongs in the RMP
        this.resetAllReceivers();

        // we do nothing for a short time
        this.tuningLockoutTimer = NavaidTuner.DELAY_AFTER_RMP_TUNING;
      }
      const tuningActive = !this.rmpTuningActive && this.tuningLockoutTimer <= 0;
      const tuningDeActivated = !tuningActive && this.tuningActive;
      this.tuningActive = tuningActive;
      if (tuningDeActivated) {
        // as above, but this one belongs here, because we are stopping our transmission
        this.resetAllReceivers();
      }
      if (this.tuningActive) {
        this.updateNavaidSelection();
        this.rwyLsMismatchMessage = this.hasRunwayLsMismatch(1) || this.hasRunwayLsMismatch(2);
      } else if (this.tuningLockoutTimer > 0) {
        this.tuningLockoutTimer -= deltaTime;
      }
      this.updateArincBus();
    }
    handleKeyEvent(key, value1, value0, value2) {
      if (NavaidTuner.TUNING_EVENT_INTERCEPTS.includes(key)) {
        if (this.rmpTuningActive) {
          // pass the tuning event through to the sim
          Coherent.call('TRIGGER_KEY_EVENT', key, true, value0 !== null && value0 !== void 0 ? value0 : 0, value1 !== null && value1 !== void 0 ? value1 : 0, value2 !== null && value2 !== void 0 ? value2 : 0);
        } else if (!this.blockEventMessageShown) {
          var _this$tipsManager;
          (_this$tipsManager = this.tipsManager) === null || _this$tipsManager === void 0 ? void 0 : _this$tipsManager.showNavRadioTuningTip();
          this.blockEventMessageShown = true;
        }
      }
    }
    resetAllReceivers() {
      this.tuneVorFrequency(1, null);
      this.tuneVorCourse(1, null);
      this.tuneVorFrequency(2, null);
      this.tuneVorCourse(2, null);
      this.tuneMmrIlsFrequency(1, null);
      this.tuneMmrCourse(1, null);
      this.tuneMmrIlsFrequency(2, null);
      this.tuneMmrCourse(2, null);
      this.tuneAdf(1, null);
      this.tuneAdf(2, null);
    }
    updateArincBus() {
      for (const [i, vor] of this.vorTuningStatus.entries()) {
        this.arincNavDiscrete.setBitValue(11 + i, this.tuningActive && vor.manual);
      }
      for (const [i, adf] of this.adfTuningStatus.entries()) {
        this.arincNavDiscrete.setBitValue(13 + i, this.tuningActive && adf.manual);
      }
      for (const [i, mmr] of this.mmrTuningStatus.entries()) {
        this.arincNavDiscrete.setBitValue(15 + i, this.tuningActive && mmr.manual);
      }
      const ssm = this.tuningActive ? Arinc429SignStatusMatrix.NormalOperation : Arinc429SignStatusMatrix.NoComputedData;
      if (ssm !== this.arincNavDiscrete.ssm || this.lastArincNavDiscreteValueWritten !== this.arincNavDiscrete.value) {
        this.arincNavDiscrete.ssm = ssm;
        this.writeNavDiscreteToBus();
      }
    }
    writeNavDiscreteToBus() {
      Arinc429Word.toSimVarValue('L:A32NX_FM1_NAV_DISCRETE', this.arincNavDiscrete.value, this.arincNavDiscrete.ssm);
      // Arinc429Word.toSimVarValue('L:A32NX_FM2_NAV_DISCRETE', this.arincNavDiscrete.value, this.arincNavDiscrete.ssm);
      this.lastArincNavDiscreteValueWritten = this.arincNavDiscrete.value;
    }
    updateNavaidSelection() {
      let tuneNavaidMessage = null;
      for (const [i, vor] of this.vorTuningStatus.entries()) {
        var _this$navaidSelection, _vor$facility;
        const autoFacility = (_this$navaidSelection = this.navaidSelectionManager.displayVor) !== null && _this$navaidSelection !== void 0 ? _this$navaidSelection : undefined;
        if (vor.manual) {
          const autoReason = this.navaidSelectionManager.displayVorReason;
          if ((autoReason === VorSelectionReason.Navigation || autoReason === VorSelectionReason.Procedure) && !NavRadioUtils.vhfFrequenciesAreEqual(autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.freqMHz, vor.frequency)) {
            tuneNavaidMessage = [autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.freqMHz, WayPoint.formatIdentFromIcao(autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.icao)];
          }
        } else if (((_vor$facility = vor.facility) === null || _vor$facility === void 0 ? void 0 : _vor$facility.icao) !== (autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.icao)) {
          var _autoFacility$freqMHz;
          vor.course = null;
          vor.facility = autoFacility;
          vor.frequency = (_autoFacility$freqMHz = autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.freqMHz) !== null && _autoFacility$freqMHz !== void 0 ? _autoFacility$freqMHz : null;
          vor.ident = autoFacility !== null && autoFacility !== void 0 && autoFacility.icao ? WayPoint.formatIdentFromIcao(autoFacility.icao) : null;
          vor.dmeOnly = this.isDmeOnly(autoFacility);
        }
        // TODO if a proc VOR is tuned, make sure it is received

        this.tuneVorFrequency(i + 1, vor.frequency);
        this.tuneVorCourse(i + 1, vor.course);
      }
      for (const [i, mmr] of this.mmrTuningStatus.entries()) {
        var _this$landingSystemSe, _mmr$facility;
        const autoFacility = (_this$landingSystemSe = this.landingSystemSelectionManager.selectedIls) !== null && _this$landingSystemSe !== void 0 ? _this$landingSystemSe : undefined;
        const autoCourse = this.landingSystemSelectionManager.selectedLocCourse;
        if (!mmr.manual && ((_mmr$facility = mmr.facility) === null || _mmr$facility === void 0 ? void 0 : _mmr$facility.icao) !== (autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.icao) && autoCourse !== null) {
          var _autoFacility$freqMHz2;
          mmr.databaseCourse = autoCourse;
          mmr.databaseBackcourse = this.landingSystemSelectionManager.selectedApprBackcourse;
          mmr.course = mmr.databaseCourse;
          mmr.courseManual = false;
          mmr.frequency = (_autoFacility$freqMHz2 = autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.freqMHz) !== null && _autoFacility$freqMHz2 !== void 0 ? _autoFacility$freqMHz2 : null;
          mmr.facility = autoFacility;
          mmr.ident = autoFacility !== null && autoFacility !== void 0 && autoFacility.icao ? WayPoint.formatIdentFromIcao(autoFacility.icao) : null;
          mmr.backcourse = this.landingSystemSelectionManager.selectedApprBackcourse;
          mmr.slope = this.landingSystemSelectionManager.selectedGsSlope;
        }
        this.tuneMmrIlsFrequency(i + 1, mmr.frequency);
        this.tuneMmrCourse(i + 1, mmr.course);
      }
      for (const [i, adf] of this.adfTuningStatus.entries()) {
        var _this$navaidSelection2, _adf$facility;
        const autoFacility = (_this$navaidSelection2 = this.navaidSelectionManager.displayNdb) !== null && _this$navaidSelection2 !== void 0 ? _this$navaidSelection2 : undefined;
        if (!adf.manual && ((_adf$facility = adf.facility) === null || _adf$facility === void 0 ? void 0 : _adf$facility.icao) !== (autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.icao)) {
          var _autoFacility$freqMHz3;
          adf.facility = autoFacility;
          adf.frequency = (_autoFacility$freqMHz3 = autoFacility === null || autoFacility === void 0 ? void 0 : autoFacility.freqMHz) !== null && _autoFacility$freqMHz3 !== void 0 ? _autoFacility$freqMHz3 : null;
          adf.ident = autoFacility !== null && autoFacility !== void 0 && autoFacility.icao ? WayPoint.formatIdentFromIcao(autoFacility.icao) : null;
        }
        this.tuneAdf(i + 1, adf.frequency);
      }
      if (this.tuneNavaidMessage !== tuneNavaidMessage) {
        this.tuneNavaidMessage = tuneNavaidMessage;
      }
    }

    /**
     * Tune the VOR receiver and associated DME receiver to a frequency
     * @param index VOR index, 1 or 2
     * @param frequency VOR frequency in MHz
     * @returns promise resolved when the tuning is complete
     */
    async tuneVorFrequency(index, frequency) {
      // FIXME tune through RMP (or direct for off-side)
      if (!NavRadioUtils.vhfFrequenciesAreEqual(this.lastVorFrequencies[index - 1], frequency)) {
        this.lastVorFrequencies[index - 1] = frequency;
        this.navaidVersion++;
        return Coherent.call('TRIGGER_KEY_EVENT', "NAV".concat(index, "_RADIO_SET_HZ"), true, (frequency !== null && frequency !== void 0 ? frequency : 0) * 1000000, 0, 0);
      }
      return false;
    }

    /**
     * Tune the VOR to a course
     * @param index VOR index, 1 or 2
     * @param frequency VOR course in degrees
     * @returns promise resolved when the tuning is complete
     */
    async tuneVorCourse(index, course) {
      // FIXME tune through RMP (or direct for off-side)
      if (Math.round(this.lastVorCourses[index - 1]) !== Math.round(course)) {
        this.lastVorCourses[index - 1] = course;
        return Coherent.call('TRIGGER_KEY_EVENT', "VOR".concat(index, "_SET"), true, course !== null && course !== void 0 ? course : 0, 0, 0);
      }
      return false;
    }

    /**
     * Tune the MMR and associated DME receiver to an ILS frequency
     * @param index MMR index, 1 or 2
     * @param frequency ILS frequency in MHz
     * @returns promise resolved when the tuning is complete
     */
    async tuneMmrIlsFrequency(index, frequency) {
      if (this.isMmrTuningLocked()) {
        return false;
      }

      // FIXME tune through RMP (or direct for off-side)
      if (!NavRadioUtils.vhfFrequenciesAreEqual(this.lastMmrFrequencies[index - 1], frequency)) {
        this.lastMmrFrequencies[index - 1] = frequency;
        this.navaidVersion++;
        return Coherent.call('TRIGGER_KEY_EVENT', "NAV".concat(index + 2, "_RADIO_SET_HZ"), true, (frequency !== null && frequency !== void 0 ? frequency : 0) * 1000000, 0, 0);
      }
      return false;
    }

    /**
     * Tune the MMR to an ILS course
     * @param index MMR index, 1 or 2
     * @param frequency ILS course in degrees
     * @returns promise resolved when the tuning is complete
     */
    async tuneMmrCourse(index, course) {
      if (this.isMmrTuningLocked()) {
        return false;
      }

      // FIXME tune through RMP (or direct for off-side)
      if (Math.round(this.lastMmrCourses[index - 1]) !== Math.round(course)) {
        this.lastMmrCourses[index - 1] = course;
        return Coherent.call('TRIGGER_KEY_EVENT', "VOR".concat(index + 2, "_SET"), true, course !== null && course !== void 0 ? course : 0, 0, 0);
      }
      return false;
    }

    /**
     * Tune the ADF to a frequency
     * @param index ADF index, 1 or 2
     * @param frequency ADF frequency in kHz
     * @returns promise resolved when the tuning is complete
     */
    async tuneAdf(index, frequency) {
      // FIXME tune through RMP (or direct for off-side)
      if (!NavRadioUtils.vhfFrequenciesAreEqual(this.lastAdfFrequencies[index - 1], frequency)) {
        this.lastAdfFrequencies[index - 1] = frequency;
        this.navaidVersion++;
        return Coherent.call('TRIGGER_KEY_EVENT', "ADF".concat(index > 1 ? index : '', "_COMPLETE_SET"), true, Avionics.Utils.make_adf_bcd32((frequency !== null && frequency !== void 0 ? frequency : 0) * 1000), 0, 0);
      }
      return false;
    }
    hasRunwayLsMismatch(index) {
      var _this$landingSystemSe2, _this$landingSystemSe3;
      const mmr = this.getMmrRadioTuningStatus(index);
      const databaseFrequency = (_this$landingSystemSe2 = (_this$landingSystemSe3 = this.landingSystemSelectionManager.selectedIls) === null || _this$landingSystemSe3 === void 0 ? void 0 : _this$landingSystemSe3.freqMHz) !== null && _this$landingSystemSe2 !== void 0 ? _this$landingSystemSe2 : null;
      const databaseCourse = this.landingSystemSelectionManager.selectedLocCourse;
      if (mmr.frequency !== null && databaseFrequency !== null && !NavRadioUtils.vhfFrequenciesAreEqual(databaseFrequency, mmr.frequency)) {
        return true;
      }
      if (mmr.course !== null && databaseCourse !== null && Math.abs(mmr.course - databaseCourse) > 3) {
        return true;
      }
      return false;
    }
    isDmeOnly(facility) {
      switch (facility === null || facility === void 0 ? void 0 : facility.type) {
        case VorType$1.DME:
        case VorType$1.TACAN:
          return true;
        default:
          return false;
      }
    }

    /** check if MMR tuning is locked during final approach */
    isMmrTuningLocked() {
      var _this$navigationProvi;
      return this.flightPhaseManager.phase === FmgcFlightPhase.Approach && ((_this$navigationProvi = this.navigationProvider.getRadioHeight()) !== null && _this$navigationProvi !== void 0 ? _this$navigationProvi : Infinity) < 700;
    }
    get tunedVors() {
      return this.vorTuningStatus.map(vorStatus => vorStatus.facility).filter(fac => fac !== undefined);
    }
    get tunedNdbs() {
      return this.adfTuningStatus.map(adfStatus => adfStatus.facility).filter(fac => fac !== undefined);
    }
    deselectNavaid(icao) {
      this.navaidSelectionManager.deselectNavaid(icao);
    }
    reselectNavaid(icao) {
      this.navaidSelectionManager.reselectNavaid(icao);
    }
    get deselectedNavaids() {
      return this.navaidSelectionManager.deselectedNavaids;
    }
    setManualVor(index, vor) {
      const vorStatus = this.vorTuningStatus[index - 1];
      if (vor === null) {
        vorStatus.manual = false;
        vorStatus.facility = undefined;
        vorStatus.course = null;
        vorStatus.ident = null;
        vorStatus.frequency = null;
      } else if (typeof vor === 'number') {
        vorStatus.manual = true;
        vorStatus.facility = undefined;
        vorStatus.course = null;
        vorStatus.ident = null;
        vorStatus.frequency = vor;
      } else {
        vorStatus.manual = true;
        vorStatus.facility = vor;
        vorStatus.course = null;
        vorStatus.ident = WayPoint.formatIdentFromIcao(vor.icao);
        vorStatus.frequency = vor.freqMHz;
      }
      vorStatus.dmeOnly = this.isDmeOnly(vorStatus.facility);
    }

    /**
     * Set a VOR course
     * @param index Index of the receiver
     * @param course null to clear
     */
    setVorCourse(index, course) {
      const vorStatus = this.vorTuningStatus[index - 1];
      vorStatus.course = course;
    }
    async setManualIls(ils) {
      let dbCourse = null;
      let dbSlope = null;
      if (ils !== null && typeof ils !== 'number') {
        [dbCourse, dbSlope] = await this.landingSystemSelectionManager.tryGetCourseSlopeForIls(ils);
      }
      for (const mmrStatus of this.mmrTuningStatus) {
        if (ils === null) {
          mmrStatus.databaseCourse = null;
          mmrStatus.databaseBackcourse = false;
          mmrStatus.manual = false;
          mmrStatus.facility = undefined;
          mmrStatus.course = null;
          mmrStatus.courseManual = false;
          mmrStatus.ident = null;
          mmrStatus.frequency = null;
          mmrStatus.backcourse = false;
          mmrStatus.slope = null;
        } else if (typeof ils === 'number') {
          mmrStatus.databaseCourse = null;
          mmrStatus.databaseBackcourse = false;
          mmrStatus.manual = true;
          mmrStatus.facility = undefined;
          mmrStatus.course = null;
          mmrStatus.courseManual = false;
          mmrStatus.ident = null;
          mmrStatus.frequency = ils;
          mmrStatus.backcourse = false;
          mmrStatus.slope = null;
        } else {
          mmrStatus.databaseCourse = dbCourse;
          mmrStatus.databaseBackcourse = false;
          mmrStatus.manual = true;
          mmrStatus.facility = ils;
          mmrStatus.course = dbCourse;
          mmrStatus.courseManual = false;
          mmrStatus.ident = WayPoint.formatIdentFromIcao(ils.icao);
          mmrStatus.frequency = ils.freqMHz;
          mmrStatus.backcourse = false;
          mmrStatus.slope = dbSlope;
        }
      }
    }

    /**
     * Set an ILS course
     * @param course null to clear
     * @param backcourse true if the course is a backcourse
     */
    setIlsCourse(course) {
      let backcourse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      for (const mmrStatus of this.mmrTuningStatus) {
        mmrStatus.course = course === null ? mmrStatus.databaseCourse : course % 360;
        mmrStatus.backcourse = course === null ? mmrStatus.databaseBackcourse : backcourse;
        mmrStatus.courseManual = course !== null;
      }
    }
    setManualAdf(index, ndb) {
      const adfStatus = this.adfTuningStatus[index - 1];
      if (ndb === null) {
        adfStatus.manual = false;
        adfStatus.facility = undefined;
        adfStatus.ident = null;
        adfStatus.frequency = null;
        adfStatus.bfo = false;
      } else if (typeof ndb === 'number') {
        adfStatus.manual = true;
        adfStatus.facility = undefined;
        adfStatus.ident = null;
        adfStatus.frequency = ndb;
        adfStatus.bfo = false;
      } else {
        adfStatus.manual = true;
        adfStatus.facility = ndb;
        adfStatus.ident = WayPoint.formatIdentFromIcao(ndb.icao);
        adfStatus.frequency = ndb.freqMHz;
        adfStatus.bfo = false;
      }
    }
    getVorRadioTuningStatus(index) {
      return this.vorTuningStatus[index - 1];
    }
    getMmrRadioTuningStatus(index) {
      return this.mmrTuningStatus[index - 1];
    }
    getAdfRadioTuningStatus(index) {
      return this.adfTuningStatus[index - 1];
    }
    getTuneNavaidMessage() {
      return this.tuneNavaidMessage;
    }
    getRwyLsMismatchMessage() {
      return this.rwyLsMismatchMessage;
    }
    getSpecifiedVorMessage() {
      // FIXME also check if it is tuned but not received
      return this.navaidSelectionManager.isSpecifiedVorDeselected;
    }
    getSpecifiedNdbMessage() {
      // FIXME also check if it is tuned but not received
      return this.navaidSelectionManager.isSpecifiedNdbDeselected;
    }
    isFmTuningActive() {
      return this.tuningActive;
    }

    /** Reset all state e.g. when the nav database is switched */
    resetState() {
      for (let i = 1; i <= 2; i++) {
        const n = i;
        this.setManualAdf(n, null);
        this.setManualVor(n, null);
        this.setVorCourse(n, null);
      }
      this.setManualIls(null);
      this.setIlsCourse(null);
      this.tuningLockoutTimer = NavaidTuner.DELAY_AFTER_RMP_TUNING;
    }
  }
  _defineProperty(NavaidTuner, "DELAY_AFTER_RMP_TUNING", 1000);
  // ms
  _defineProperty(NavaidTuner, "TUNING_EVENT_INTERCEPTS", ['ADF_1_DEC', 'ADF2_1_DEC', 'ADF_10_DEC', 'ADF2_10_DEC', 'ADF_100_DEC', 'ADF2_100_DEC', 'ADF_1_INC', 'ADF2_1_INC', 'ADF_10_INC', 'ADF2_10_INC', 'ADF_100_INC', 'ADF2_100_INC', 'ADF_ACTIVE_SET', 'ADF2_ACTIVE_SET', 'ADF_COMPLETE_SET', 'ADF2_COMPLETE_SET', 'ADF_EXTENDED_SET', 'ADF2_EXTENDED_SET', 'ADF_FRACT_DEC_CARRY', 'ADF2_FRACT_DEC_CARRY', 'ADF_FRACT_INC_CARRY', 'ADF2_FRACT_INC_CARRY', 'ADF_HIGHRANGE_SET', 'ADF2_HIGHRANGE_SET', 'ADF_LOWRANGE_SET', 'ADF2_LOWRANGE_SET', 'ADF1_RADIO_SWAP', 'ADF2_RADIO_SWAP', 'ADF1_RADIO_TENTHS_DEC', 'ADF2_RADIO_TENTHS_DEC', 'ADF1_RADIO_TENTHS_INC', 'ADF2_RADIO_TENTHS_INC', 'ADF_SET', 'ADF2_SET', 'ADF1_WHOLE_DEC', 'ADF2_WHOLE_DEC', 'ADF1_WHOLE_INC', 'ADF2_WHOLE_INC', 'NAV1_RADIO_FRACT_DEC', 'NAV2_RADIO_FRACT_DEC', 'NAV3_RADIO_FRACT_DEC', 'NAV4_RADIO_FRACT_DEC', 'NAV1_RADIO_FRACT_DEC_CARRY', 'NAV2_RADIO_FRACT_DEC_CARRY', 'NAV3_RADIO_FRACT_DEC_CARRY', 'NAV4_RADIO_FRACT_DEC_CARRY', 'NAV1_RADIO_FRACT_INC', 'NAV2_RADIO_FRACT_INC', 'NAV3_RADIO_FRACT_INC', 'NAV4_RADIO_FRACT_INC', 'NAV1_RADIO_FRACT_INC_CARRY', 'NAV2_RADIO_FRACT_INC_CARRY', 'NAV3_RADIO_FRACT_INC_CARRY', 'NAV4_RADIO_FRACT_INC_CARRY', 'NAV1_RADIO_SET', 'NAV2_RADIO_SET', 'NAV3_RADIO_SET', 'NAV4_RADIO_SET', 'NAV1_RADIO_SET_HZ', 'NAV2_RADIO_SET_HZ', 'NAV3_RADIO_SET_HZ', 'NAV4_RADIO_SET_HZ', 'NAV1_RADIO_SWAP', 'NAV2_RADIO_SWAP', 'NAV3_RADIO_SWAP', 'NAV4_RADIO_SWAP', 'NAV1_RADIO_WHOLE_DEC', 'NAV2_RADIO_WHOLE_DEC', 'NAV3_RADIO_WHOLE_DEC', 'NAV4_RADIO_WHOLE_DEC', 'NAV1_RADIO_WHOLE_INC', 'NAV2_RADIO_WHOLE_INC', 'NAV3_RADIO_WHOLE_INC', 'NAV4_RADIO_WHOLE_INC', 'TACAN1_ACTIVE_CHANNEL_SET', 'TACAN2_ACTIVE_CHANNEL_SET', 'TACAN1_ACTIVE_MODE_SET', 'TACAN2_ACTIVE_MODE_SET', 'TACAN1_SWAP', 'TACAN2_SWAP', 'TACAN1_SET', 'TACAN2_SET', 'TACAN1_OBI_DEC', 'TACAN2_OBI_DEC', 'TACAN1_OBI_INC', 'TACAN2_OBI_INC', 'TACAN1_OBI_FAST_DEC', 'TACAN2_OBI_FAST_DEC', 'TACAN1_OBI_FAST_INC', 'TACAN2_OBI_FAST_INC', 'VOR1_OBI_DEC', 'VOR2_OBI_DEC', 'VOR3_OBI_DEC', 'VOR4_OBI_DEC', 'VOR1_OBI_FAST_DEC', 'VOR2_OBI_FAST_DEC', 'VOR3_OBI_FAST_DEC', 'VOR4_OBI_FAST_DEC', 'VOR1_OBI_FAST_INC', 'VOR2_OBI_FAST_INC', 'VOR3_OBI_FAST_INC', 'VOR4_OBI_FAST_INC', 'VOR1_OBI_INC', 'VOR2_OBI_INC', 'VOR3_OBI_INC', 'VOR4_OBI_INC', 'VOR1_SET', 'VOR2_SET', 'VOR3_SET', 'VOR4_SET']);

  const rnpDefaults = {
    [FlightArea.Takeoff]: 1,
    [FlightArea.Terminal]: 1,
    [FlightArea.Enroute]: 2,
    [FlightArea.Oceanic]: 2,
    [FlightArea.VorApproach]: 0.5,
    [FlightArea.GpsApproach]: 0.3,
    [FlightArea.PrecisionApproach]: 0.5,
    [FlightArea.NonPrecisionApproach]: 0.5
  };

  // FIXME RNP-related scratchpad messages

  class RequiredPerformance {
    constructor(flightPlanManager) {
      this.flightPlanManager = flightPlanManager;
      _defineProperty(this, "activeRnp", void 0);
      _defineProperty(this, "requestLDev", false);
      _defineProperty(this, "manualRnp", false);
    }
    update(_deltaTime) {
      this.updateAutoRnp();
      this.updateLDev();
    }
    setPilotRnp(rnp) {
      this.manualRnp = true;
      this.setActiveRnp(rnp);
    }
    clearPilotRnp() {
      this.manualRnp = false;
      this.updateAutoRnp();
    }
    updateAutoRnp() {
      if (this.manualRnp) {
        return;
      }
      const plan = this.flightPlanManager.activeFlightPlan;
      if (plan && plan.activeWaypoint) {
        const legRnp = plan.activeWaypoint.additionalData.rnp;
        if (legRnp !== undefined) {
          if (legRnp !== this.activeRnp) {
            this.setActiveRnp(legRnp);
          }
          return;
        }
      }
      const area = this.flightPlanManager.activeArea;
      const rnp = rnpDefaults[area];
      if (rnp !== this.activeRnp) {
        this.setActiveRnp(rnp);
      }
    }
    setActiveRnp(rnp) {
      this.activeRnp = rnp;
      SimVar.SetSimVarValue('L:A32NX_FMGC_L_RNP', 'number', rnp !== null && rnp !== void 0 ? rnp : 0);
      SimVar.SetSimVarValue('L:A32NX_FMGC_R_RNP', 'number', rnp !== null && rnp !== void 0 ? rnp : 0);
    }
    updateLDev() {
      const area = this.flightPlanManager.activeArea;
      const ldev = area !== FlightArea.Enroute && area !== FlightArea.Oceanic && this.activeRnp < 0.305;
      if (ldev !== this.requestLDev) {
        this.requestLDev = ldev;
        SimVar.SetSimVarValue('L:A32NX_FMGC_L_LDEV_REQUEST', 'bool', this.requestLDev);
        SimVar.SetSimVarValue('L:A32NX_FMGC_R_LDEV_REQUEST', 'bool', this.requestLDev);
      }
    }
  }

  let SelectedNavaidType = /*#__PURE__*/function (SelectedNavaidType) {
    SelectedNavaidType[SelectedNavaidType["None"] = 0] = "None";
    SelectedNavaidType[SelectedNavaidType["Dme"] = 1] = "Dme";
    SelectedNavaidType[SelectedNavaidType["Vor"] = 2] = "Vor";
    SelectedNavaidType[SelectedNavaidType["VorDme"] = 3] = "VorDme";
    SelectedNavaidType[SelectedNavaidType["VorTac"] = 4] = "VorTac";
    SelectedNavaidType[SelectedNavaidType["Tacan"] = 5] = "Tacan";
    SelectedNavaidType[SelectedNavaidType["Ils"] = 6] = "Ils";
    SelectedNavaidType[SelectedNavaidType["Gls"] = 7] = "Gls";
    SelectedNavaidType[SelectedNavaidType["Mls"] = 8] = "Mls";
    return SelectedNavaidType;
  }({});
  let SelectedNavaidMode = /*#__PURE__*/function (SelectedNavaidMode) {
    SelectedNavaidMode[SelectedNavaidMode["Auto"] = 0] = "Auto";
    SelectedNavaidMode[SelectedNavaidMode["Manual"] = 1] = "Manual";
    SelectedNavaidMode[SelectedNavaidMode["Rmp"] = 2] = "Rmp";
    return SelectedNavaidMode;
  }({});
  class Navigation {
    constructor(flightPlanManager, facLoader) {
      this.flightPlanManager = flightPlanManager;
      this.facLoader = facLoader;
      _defineProperty(this, "requiredPerformance", void 0);
      _defineProperty(this, "currentPerformance", void 0);
      _defineProperty(this, "accuracyHigh", false);
      _defineProperty(this, "ppos", {
        lat: 0,
        long: 0
      });
      _defineProperty(this, "groundSpeed", 0);
      _defineProperty(this, "radioHeight", null);
      _defineProperty(this, "baroAltitude", null);
      _defineProperty(this, "pressureAltitude", null);
      _defineProperty(this, "navaidSelectionManager", void 0);
      _defineProperty(this, "landingSystemSelectionManager", void 0);
      _defineProperty(this, "navaidTuner", void 0);
      _defineProperty(this, "selectedNavaids", Array.from({
        length: 4
      }, () => ({
        type: SelectedNavaidType.None,
        mode: SelectedNavaidMode.Auto,
        ident: '',
        frequency: 0,
        facility: null
      })));
      this.requiredPerformance = new RequiredPerformance(this.flightPlanManager);
      this.navaidSelectionManager = new NavaidSelectionManager(this, this.flightPlanManager);
      this.landingSystemSelectionManager = new LandingSystemSelectionManager(this, this.flightPlanManager, this.facLoader);
      this.navaidTuner = new NavaidTuner(this, this.navaidSelectionManager, this.landingSystemSelectionManager);
    }
    init() {
      this.navaidTuner.init();
    }
    update(deltaTime) {
      this.requiredPerformance.update(deltaTime);
      this.updateCurrentPerformance();
      this.updatePosition();
      this.updateRadioHeight();
      this.updateBaroAltitude();
      this.updatePressureAltitude();
      NearbyFacilities.getInstance().update(deltaTime);
      this.navaidSelectionManager.update(deltaTime);
      this.landingSystemSelectionManager.update(deltaTime);
      this.navaidTuner.update(deltaTime);
    }

    /** Reset all state e.g. when the nav database is switched */
    resetState() {
      this.navaidSelectionManager.resetState();
      this.landingSystemSelectionManager.resetState();
      this.navaidTuner.resetState();

      // FIXME reset FMS position
    }

    getAdiruValue(simVars) {
      for (const adiru of Navigation.adiruOrder) {
        const simVar = simVars[adiru - 1];
        Navigation.arincWordCache.setFromSimVar(simVar);
        if (Navigation.arincWordCache.isNormalOperation()) {
          return Navigation.arincWordCache.value;
        }
      }
      return null;
    }
    updateCurrentPerformance() {
      const gs = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');

      // FIXME fake it until we make it :D
      const estimate = 0.03 + Math.random() * 0.02 + gs * 0.00015;
      // basic IIR filter
      this.currentPerformance = this.currentPerformance === undefined ? estimate : this.currentPerformance * 0.9 + estimate * 0.1;
      const accuracyHigh = this.currentPerformance <= this.requiredPerformance.activeRnp;
      if (accuracyHigh !== this.accuracyHigh) {
        this.accuracyHigh = accuracyHigh;
        SimVar.SetSimVarValue('L:A32NX_FMGC_L_NAV_ACCURACY_HIGH', 'bool', this.accuracyHigh);
        SimVar.SetSimVarValue('L:A32NX_FMGC_R_NAV_ACCURACY_HIGH', 'bool', this.accuracyHigh);
      }
    }
    updateRadioHeight() {
      for (const simVar of Navigation.radioAltimeterVars) {
        Navigation.arincWordCache.setFromSimVar(simVar);
        if (Navigation.arincWordCache.isNormalOperation()) {
          this.radioHeight = Navigation.arincWordCache.value;
          return;
        }
      }
      this.radioHeight = null;
    }
    updateBaroAltitude() {
      this.baroAltitude = this.getAdiruValue(Navigation.baroAltitudeVars);
    }
    updatePressureAltitude() {
      this.pressureAltitude = this.getAdiruValue(Navigation.pressureAltitudeVars);
    }
    updatePosition() {
      this.ppos.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
      this.ppos.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
      this.groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');

      // pass to submodules
      NearbyFacilities.getInstance().setPpos(this.ppos);
    }
    getBaroCorrectedAltitude() {
      return this.baroAltitude;
    }
    getEpe() {
      var _this$currentPerforma;
      return (_this$currentPerforma = this.currentPerformance) !== null && _this$currentPerforma !== void 0 ? _this$currentPerforma : Infinity;
    }
    getPpos() {
      // TODO return null when fms pos invalid
      return this.ppos;
    }
    getPressureAltitude() {
      return this.pressureAltitude;
    }
    getRadioHeight() {
      return this.radioHeight;
    }
    getNavaidTuner() {
      return this.navaidTuner;
    }
    resetSelectedNavaid(i) {
      const selected = this.selectedNavaids[i];
      selected.type = SelectedNavaidType.None;
      selected.mode = SelectedNavaidMode.Auto;
      selected.ident = '';
      selected.frequency = 0;
      selected.facility = null;
    }
    getSelectedNavaids() {
      let cdu = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      if (this.navaidTuner.isFmTuningActive()) {
        const vorStatus = this.navaidTuner.getVorRadioTuningStatus(cdu);
        if (vorStatus.frequency !== null) {
          var _vorStatus$facility;
          const selected = this.selectedNavaids[0];
          selected.type = this.getSelectedNavaidType(vorStatus.facility);
          selected.mode = vorStatus.manual ? SelectedNavaidMode.Manual : SelectedNavaidMode.Auto;
          selected.ident = vorStatus.ident;
          selected.frequency = vorStatus.frequency;
          selected.facility = (_vorStatus$facility = vorStatus.facility) !== null && _vorStatus$facility !== void 0 ? _vorStatus$facility : null;
        } else {
          this.resetSelectedNavaid(0);
        }
        const dmePair = this.navaidSelectionManager.dmePair;
        if (dmePair !== null) {
          for (const [i, dme] of dmePair.entries()) {
            const selected = this.selectedNavaids[i + 1];
            selected.type = this.getSelectedNavaidType(dme);
            selected.mode = SelectedNavaidMode.Auto;
            selected.ident = WayPoint.formatIdentFromIcao(dme.icao);
            selected.frequency = dme.freqMHz;
            selected.facility = dme;
          }
        } else if (this.navaidSelectionManager.displayVorReason === VorSelectionReason.Navigation) {
          const navaid = this.navaidSelectionManager.displayVor;
          const selected = this.selectedNavaids[1];
          selected.type = this.getSelectedNavaidType(navaid);
          selected.mode = SelectedNavaidMode.Auto;
          selected.ident = WayPoint.formatIdentFromIcao(navaid.icao);
          selected.frequency = navaid.freqMHz;
          selected.facility = navaid;
          this.resetSelectedNavaid(2);
        } else {
          this.resetSelectedNavaid(1);
          this.resetSelectedNavaid(2);
        }
        const mmrStatus = this.navaidTuner.getMmrRadioTuningStatus(1);
        if (mmrStatus.frequency !== null) {
          var _mmrStatus$facility;
          const selected = this.selectedNavaids[3];
          selected.type = this.getSelectedNavaidType(mmrStatus.facility);
          selected.mode = mmrStatus.manual ? SelectedNavaidMode.Manual : SelectedNavaidMode.Auto;
          selected.ident = mmrStatus.ident;
          selected.frequency = mmrStatus.frequency;
          selected.facility = (_mmrStatus$facility = mmrStatus.facility) !== null && _mmrStatus$facility !== void 0 ? _mmrStatus$facility : null;
        } else {
          this.resetSelectedNavaid(3);
        }
      } else {
        // RMP
        for (let i = 0; i < 4; i++) {
          this.resetSelectedNavaid(i);
          // No DME pair with RMP active
          if (i === 1 || i === 2) {
            continue;
          }
          const selected = this.selectedNavaids[i];
          selected.type = i === 3 ? SelectedNavaidType.Ils : SelectedNavaidType.None;
          selected.mode = SelectedNavaidMode.Rmp;
          selected.frequency = SimVar.GetSimVarValue("NAV ACTIVE FREQUENCY:".concat(i === 0 ? cdu : cdu + 2), 'mhz');
        }
      }
      return this.selectedNavaids;
    }
    getSelectedNavaidType(facility) {
      if (!facility) {
        return SelectedNavaidType.None;
      }
      switch (facility.type) {
        case VorType$1.DME:
          return SelectedNavaidType.Dme;
        case VorType$1.VOR:
          return SelectedNavaidType.Vor;
        case VorType$1.VORDME:
          return SelectedNavaidType.VorDme;
        case VorType$1.VORTAC:
          return SelectedNavaidType.VorTac;
        case VorType$1.TACAN:
          return SelectedNavaidType.Tacan;
        case VorType$1.ILS:
          return SelectedNavaidType.Ils;
        default:
          return SelectedNavaidType.None;
      }
    }
  }
  _defineProperty(Navigation, "adiruOrder", [1, 3, 2]);
  _defineProperty(Navigation, "arincWordCache", Arinc429Register.empty());
  _defineProperty(Navigation, "radioAltimeterVars", Array.from({
    length: 2
  }, (_, i) => "L:A32NX_RA_".concat(i + 1, "_RADIO_ALTITUDE")));
  _defineProperty(Navigation, "baroAltitudeVars", Array.from({
    length: 3
  }, (_, i) => "L:A32NX_ADIRS_ADR_".concat(i + 1, "_BARO_CORRECTED_ALTITUDE_1")));
  _defineProperty(Navigation, "pressureAltitudeVars", Array.from({
    length: 3
  }, (_, i) => "L:A32NX_ADIRS_ADR_".concat(i + 1, "_ALTITUDE")));

  function initFmgcLoop(baseInstrument, flightPlanManager) {
    initComponents(baseInstrument, flightPlanManager);
  }
  function updateFmgcLoop(deltaTime) {
    updateComponents(deltaTime);
  }

  exports.ApproachUtils = ApproachUtils;
  exports.DescentPathBuilder = DescentPathBuilder;
  exports.EfisSymbols = EfisSymbols;
  exports.FlightPlanAsoboSync = FlightPlanAsoboSync;
  exports.FlightPlanManager = FlightPlanManager;
  exports.GuidanceController = GuidanceController;
  exports.GuidanceManager = GuidanceManager;
  exports.ManagedFlightPlan = ManagedFlightPlan;
  exports.Navigation = Navigation;
  exports.RawDataMapper = RawDataMapper;
  exports.SelectedNavaidMode = SelectedNavaidMode;
  exports.SelectedNavaidType = SelectedNavaidType;
  exports.WaypointBuilder = WaypointBuilder;
  exports.getFlightPhaseManager = getFlightPhaseManager;
  exports.initFmgcLoop = initFmgcLoop;
  exports.recallMessageById = recallMessageById;
  exports.updateFmgcLoop = updateFmgcLoop;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
