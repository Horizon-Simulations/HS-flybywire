<script type="text/html" id="ND_TEMPLATE">
    <div id="MSFS_REACT_MOUNT">
        <h1>If you're seeing this, React didn't load.</h1>
    </div>

    <script id="ND_BUNDLED_LOGIC">
        // Although this is a script tag, because it is a child of a custom element,
        // it will not execute. Inside `template.js`, we read the contents of this script
        // element, then create a new script element and append it to the document body.
        // We embed it into this file, even though it is useless, because this file can
        // be hot-reloaded, but `template.js` cannot.
        /* eslint-disable */
        (function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */

	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
	  if (val === null || val === undefined) {
	    throw new TypeError('Object.assign cannot be called with null or undefined');
	  }

	  return Object(val);
	}

	function shouldUseNative() {
	  try {
	    if (!Object.assign) {
	      return false;
	    } // Detect buggy property enumeration order in older V8 versions.
	    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


	    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

	    test1[5] = 'de';

	    if (Object.getOwnPropertyNames(test1)[0] === '5') {
	      return false;
	    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


	    var test2 = {};

	    for (var i = 0; i < 10; i++) {
	      test2['_' + String.fromCharCode(i)] = i;
	    }

	    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
	      return test2[n];
	    });

	    if (order2.join('') !== '0123456789') {
	      return false;
	    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


	    var test3 = {};
	    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
	      test3[letter] = letter;
	    });

	    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
	      return false;
	    }

	    return true;
	  } catch (err) {
	    // We don't expect any of the above to throw, but better to be safe.
	    return false;
	  }
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	  var from;
	  var to = toObject(target);
	  var symbols;

	  for (var s = 1; s < arguments.length; s++) {
	    from = Object(arguments[s]);

	    for (var key in from) {
	      if (hasOwnProperty$1.call(from, key)) {
	        to[key] = from[key];
	      }
	    }

	    if (getOwnPropertySymbols) {
	      symbols = getOwnPropertySymbols(from);

	      for (var i = 0; i < symbols.length; i++) {
	        if (propIsEnumerable.call(from, symbols[i])) {
	          to[symbols[i]] = from[symbols[i]];
	        }
	      }
	    }
	  }

	  return to;
	};

	var react_production_min = createCommonjsModule(function (module, exports) {

	  var n = 60103,
	      p = 60106;
	  exports.Fragment = 60107;
	  exports.StrictMode = 60108;
	  exports.Profiler = 60114;
	  var q = 60109,
	      r = 60110,
	      t = 60112;
	  exports.Suspense = 60113;
	  var u = 60115,
	      v = 60116;

	  if ("function" === typeof Symbol && Symbol.for) {
	    var w = Symbol.for;
	    n = w("react.element");
	    p = w("react.portal");
	    exports.Fragment = w("react.fragment");
	    exports.StrictMode = w("react.strict_mode");
	    exports.Profiler = w("react.profiler");
	    q = w("react.provider");
	    r = w("react.context");
	    t = w("react.forward_ref");
	    exports.Suspense = w("react.suspense");
	    u = w("react.memo");
	    v = w("react.lazy");
	  }

	  var x = "function" === typeof Symbol && Symbol.iterator;

	  function y(a) {
	    if (null === a || "object" !== typeof a) return null;
	    a = x && a[x] || a["@@iterator"];
	    return "function" === typeof a ? a : null;
	  }

	  function z(a) {
	    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

	    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	  }

	  var A = {
	    isMounted: function () {
	      return !1;
	    },
	    enqueueForceUpdate: function () {},
	    enqueueReplaceState: function () {},
	    enqueueSetState: function () {}
	  },
	      B = {};

	  function C(a, b, c) {
	    this.props = a;
	    this.context = b;
	    this.refs = B;
	    this.updater = c || A;
	  }

	  C.prototype.isReactComponent = {};

	  C.prototype.setState = function (a, b) {
	    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(z(85));
	    this.updater.enqueueSetState(this, a, b, "setState");
	  };

	  C.prototype.forceUpdate = function (a) {
	    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
	  };

	  function D() {}

	  D.prototype = C.prototype;

	  function E(a, b, c) {
	    this.props = a;
	    this.context = b;
	    this.refs = B;
	    this.updater = c || A;
	  }

	  var F = E.prototype = new D();
	  F.constructor = E;
	  objectAssign(F, C.prototype);
	  F.isPureReactComponent = !0;
	  var G = {
	    current: null
	  },
	      H = Object.prototype.hasOwnProperty,
	      I = {
	    key: !0,
	    ref: !0,
	    __self: !0,
	    __source: !0
	  };

	  function J(a, b, c) {
	    var e,
	        d = {},
	        k = null,
	        h = null;
	    if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
	    var g = arguments.length - 2;
	    if (1 === g) d.children = c;else if (1 < g) {
	      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];

	      d.children = f;
	    }
	    if (a && a.defaultProps) for (e in g = a.defaultProps, g) void 0 === d[e] && (d[e] = g[e]);
	    return {
	      $$typeof: n,
	      type: a,
	      key: k,
	      ref: h,
	      props: d,
	      _owner: G.current
	    };
	  }

	  function K(a, b) {
	    return {
	      $$typeof: n,
	      type: a.type,
	      key: b,
	      ref: a.ref,
	      props: a.props,
	      _owner: a._owner
	    };
	  }

	  function L(a) {
	    return "object" === typeof a && null !== a && a.$$typeof === n;
	  }

	  function escape(a) {
	    var b = {
	      "=": "=0",
	      ":": "=2"
	    };
	    return "$" + a.replace(/[=:]/g, function (a) {
	      return b[a];
	    });
	  }

	  var M = /\/+/g;

	  function N(a, b) {
	    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
	  }

	  function O(a, b, c, e, d) {
	    var k = typeof a;
	    if ("undefined" === k || "boolean" === k) a = null;
	    var h = !1;
	    if (null === a) h = !0;else switch (k) {
	      case "string":
	      case "number":
	        h = !0;
	        break;

	      case "object":
	        switch (a.$$typeof) {
	          case n:
	          case p:
	            h = !0;
	        }

	    }
	    if (h) return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function (a) {
	      return a;
	    })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
	    h = 0;
	    e = "" === e ? "." : e + ":";
	    if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
	      k = a[g];
	      var f = e + N(k, g);
	      h += O(k, b, c, f, d);
	    } else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
	    return h;
	  }

	  function P(a, b, c) {
	    if (null == a) return a;
	    var e = [],
	        d = 0;
	    O(a, e, "", "", function (a) {
	      return b.call(c, a, d++);
	    });
	    return e;
	  }

	  function Q(a) {
	    if (-1 === a._status) {
	      var b = a._result;
	      b = b();
	      a._status = 0;
	      a._result = b;
	      b.then(function (b) {
	        0 === a._status && (b = b.default, a._status = 1, a._result = b);
	      }, function (b) {
	        0 === a._status && (a._status = 2, a._result = b);
	      });
	    }

	    if (1 === a._status) return a._result;
	    throw a._result;
	  }

	  var R = {
	    current: null
	  };

	  function S() {
	    var a = R.current;
	    if (null === a) throw Error(z(321));
	    return a;
	  }

	  var T = {
	    ReactCurrentDispatcher: R,
	    ReactCurrentBatchConfig: {
	      transition: 0
	    },
	    ReactCurrentOwner: G,
	    IsSomeRendererActing: {
	      current: !1
	    },
	    assign: objectAssign
	  };
	  exports.Children = {
	    map: P,
	    forEach: function (a, b, c) {
	      P(a, function () {
	        b.apply(this, arguments);
	      }, c);
	    },
	    count: function (a) {
	      var b = 0;
	      P(a, function () {
	        b++;
	      });
	      return b;
	    },
	    toArray: function (a) {
	      return P(a, function (a) {
	        return a;
	      }) || [];
	    },
	    only: function (a) {
	      if (!L(a)) throw Error(z(143));
	      return a;
	    }
	  };
	  exports.Component = C;
	  exports.PureComponent = E;
	  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;

	  exports.cloneElement = function (a, b, c) {
	    if (null === a || void 0 === a) throw Error(z(267, a));
	    var e = objectAssign({}, a.props),
	        d = a.key,
	        k = a.ref,
	        h = a._owner;

	    if (null != b) {
	      void 0 !== b.ref && (k = b.ref, h = G.current);
	      void 0 !== b.key && (d = "" + b.key);
	      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

	      for (f in b) H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
	    }

	    var f = arguments.length - 2;
	    if (1 === f) e.children = c;else if (1 < f) {
	      g = Array(f);

	      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];

	      e.children = g;
	    }
	    return {
	      $$typeof: n,
	      type: a.type,
	      key: d,
	      ref: k,
	      props: e,
	      _owner: h
	    };
	  };

	  exports.createContext = function (a, b) {
	    void 0 === b && (b = null);
	    a = {
	      $$typeof: r,
	      _calculateChangedBits: b,
	      _currentValue: a,
	      _currentValue2: a,
	      _threadCount: 0,
	      Provider: null,
	      Consumer: null
	    };
	    a.Provider = {
	      $$typeof: q,
	      _context: a
	    };
	    return a.Consumer = a;
	  };

	  exports.createElement = J;

	  exports.createFactory = function (a) {
	    var b = J.bind(null, a);
	    b.type = a;
	    return b;
	  };

	  exports.createRef = function () {
	    return {
	      current: null
	    };
	  };

	  exports.forwardRef = function (a) {
	    return {
	      $$typeof: t,
	      render: a
	    };
	  };

	  exports.isValidElement = L;

	  exports.lazy = function (a) {
	    return {
	      $$typeof: v,
	      _payload: {
	        _status: -1,
	        _result: a
	      },
	      _init: Q
	    };
	  };

	  exports.memo = function (a, b) {
	    return {
	      $$typeof: u,
	      type: a,
	      compare: void 0 === b ? null : b
	    };
	  };

	  exports.useCallback = function (a, b) {
	    return S().useCallback(a, b);
	  };

	  exports.useContext = function (a, b) {
	    return S().useContext(a, b);
	  };

	  exports.useDebugValue = function () {};

	  exports.useEffect = function (a, b) {
	    return S().useEffect(a, b);
	  };

	  exports.useImperativeHandle = function (a, b, c) {
	    return S().useImperativeHandle(a, b, c);
	  };

	  exports.useLayoutEffect = function (a, b) {
	    return S().useLayoutEffect(a, b);
	  };

	  exports.useMemo = function (a, b) {
	    return S().useMemo(a, b);
	  };

	  exports.useReducer = function (a, b, c) {
	    return S().useReducer(a, b, c);
	  };

	  exports.useRef = function (a) {
	    return S().useRef(a);
	  };

	  exports.useState = function (a) {
	    return S().useState(a);
	  };

	  exports.version = "17.0.2";
	});

	createCommonjsModule(function (module, exports) {
	});

	var react = createCommonjsModule(function (module) {

	  {
	    module.exports = react_production_min;
	  }
	});

	var defineProperty = createCommonjsModule(function (module) {
	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }

	    return obj;
	  }

	  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});
	var _defineProperty = /*@__PURE__*/getDefaultExportFromCjs(defineProperty);

	/**
	 * Allows interacting with the persistent storage
	 */
	class NXDataStore {
	  static get listener() {
	    if (this.mListener === undefined) {
	      this.mListener = RegisterViewListener('JS_LISTENER_SIMVARS', null, true);
	    }

	    return this.mListener;
	  }
	  /**
	   * Reads a value from persistent storage
	   * @param key The property key
	   * @param defaultVal The default value if the property is not set
	   */


	  static get(key, defaultVal) {
	    const val = GetStoredData("A32NX_".concat(key)); // GetStoredData returns null on error, or empty string for keys that don't exist (why isn't that an error??)
	    // We could use SearchStoredData, but that spams the console with every key (somebody left their debug print in)

	    if (val === null || val.length === 0) {
	      return defaultVal;
	    }

	    return val;
	  }
	  /**
	   * Sets a value in persistent storage
	   *
	   * @param key The property key
	   * @param val The value to assign to the property
	   */


	  static set(key, val) {
	    SetStoredData("A32NX_".concat(key), val);
	    this.listener.triggerToAllSubscribers('A32NX_NXDATASTORE_UPDATE', key, val);
	  }

	  static subscribe(key, callback) {
	    return Coherent.on('A32NX_NXDATASTORE_UPDATE', (updatedKey, value) => {
	      if (key === '*' || key === updatedKey) {
	        callback(updatedKey, value);
	      }
	    }).clear;
	  }

	  static getAndSubscribe(key, callback, defaultVal) {
	    callback(key, NXDataStore.get(key, defaultVal));
	    return NXDataStore.subscribe(key, callback);
	  }

	}

	_defineProperty(NXDataStore, "mListener", void 0);

	const stringify = configure(); // @ts-expect-error

	stringify.configure = configure; // @ts-expect-error

	stringify.stringify = stringify; // @ts-expect-error

	stringify.default = stringify; // @ts-expect-error used for named export

	var stringify_1 = stringify; // @ts-expect-error used for named export

	var configure_1 = configure;
	var safeStableStringify = stringify; // eslint-disable-next-line

	const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/; // eslint-disable-next-line

	const strEscapeSequencesReplacer = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g; // Escaped special characters. Use empty strings to fill up unused entries.

	const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '\\"', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];

	function escapeFn(str) {
	  if (str.length === 2) {
	    const charCode = str.charCodeAt(1);
	    return "".concat(str[0], "\\u").concat(charCode.toString(16));
	  }

	  const charCode = str.charCodeAt(0);
	  return meta.length > charCode ? meta[charCode] : "\\u".concat(charCode.toString(16));
	} // Escape C0 control characters, double quotes, the backslash and every code
	// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.


	function strEscape(str) {
	  // Some magic numbers that worked out fine while benchmarking with v8 8.0
	  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
	    return str;
	  }

	  if (str.length > 100) {
	    return str.replace(strEscapeSequencesReplacer, escapeFn);
	  }

	  let result = '';
	  let last = 0;

	  for (let i = 0; i < str.length; i++) {
	    const point = str.charCodeAt(i);

	    if (point === 34 || point === 92 || point < 32) {
	      result += "".concat(str.slice(last, i)).concat(meta[point]);
	      last = i + 1;
	    } else if (point >= 0xd800 && point <= 0xdfff) {
	      if (point <= 0xdbff && i + 1 < str.length) {
	        const point = str.charCodeAt(i + 1);

	        if (point >= 0xdc00 && point <= 0xdfff) {
	          i++;
	          continue;
	        }
	      }

	      result += "".concat(str.slice(last, i), "\\u".concat(point.toString(16)));
	      last = i + 1;
	    }
	  }

	  result += str.slice(last);
	  return result;
	}

	function insertSort(array) {
	  // Insertion sort is very efficient for small input sizes but it has a bad
	  // worst case complexity. Thus, use native array sort for bigger values.
	  if (array.length > 2e2) {
	    return array.sort();
	  }

	  for (let i = 1; i < array.length; i++) {
	    const currentValue = array[i];
	    let position = i;

	    while (position !== 0 && array[position - 1] > currentValue) {
	      array[position] = array[position - 1];
	      position--;
	    }

	    array[position] = currentValue;
	  }

	  return array;
	}

	const typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;

	function isTypedArrayWithEntries(value) {
	  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
	}

	function stringifyTypedArray(array, separator, maximumBreadth) {
	  if (array.length < maximumBreadth) {
	    maximumBreadth = array.length;
	  }

	  const whitespace = separator === ',' ? '' : ' ';
	  let res = "\"0\":".concat(whitespace).concat(array[0]);

	  for (let i = 1; i < maximumBreadth; i++) {
	    res += "".concat(separator, "\"").concat(i, "\":").concat(whitespace).concat(array[i]);
	  }

	  return res;
	}

	function getCircularValueOption(options) {
	  if (options && Object.prototype.hasOwnProperty.call(options, 'circularValue')) {
	    var circularValue = options.circularValue;

	    if (typeof circularValue === 'string') {
	      return "\"".concat(circularValue, "\"");
	    }

	    if (circularValue == null) {
	      return circularValue;
	    }

	    if (circularValue === Error || circularValue === TypeError) {
	      return {
	        toString() {
	          throw new TypeError('Converting circular structure to JSON');
	        }

	      };
	    }

	    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
	  }

	  return '"[Circular]"';
	}

	function getBooleanOption(options, key) {
	  if (options && Object.prototype.hasOwnProperty.call(options, key)) {
	    var value = options[key];

	    if (typeof value !== 'boolean') {
	      throw new TypeError("The \"".concat(key, "\" argument must be of type boolean"));
	    }
	  }

	  return value === undefined ? true : value;
	}

	function getPositiveIntegerOption(options, key) {
	  if (options && Object.prototype.hasOwnProperty.call(options, key)) {
	    var value = options[key];

	    if (typeof value !== 'number') {
	      throw new TypeError("The \"".concat(key, "\" argument must be of type number"));
	    }

	    if (!Number.isInteger(value)) {
	      throw new TypeError("The \"".concat(key, "\" argument must be an integer"));
	    }

	    if (value < 1) {
	      throw new RangeError("The \"".concat(key, "\" argument must be >= 1"));
	    }
	  }

	  return value === undefined ? Infinity : value;
	}

	function getItemCount(number) {
	  if (number === 1) {
	    return '1 item';
	  }

	  return "".concat(number, " items");
	}

	function getUniqueReplacerSet(replacerArray) {
	  const replacerSet = new Set();

	  for (const value of replacerArray) {
	    if (typeof value === 'string') {
	      replacerSet.add(value);
	    } else if (typeof value === 'number') {
	      replacerSet.add(String(value));
	    }
	  }

	  return replacerSet;
	}

	function configure(options) {
	  const circularValue = getCircularValueOption(options);
	  const bigint = getBooleanOption(options, 'bigint');
	  const deterministic = getBooleanOption(options, 'deterministic');
	  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');
	  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');

	  function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
	    let value = parent[key];

	    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
	      value = value.toJSON(key);
	    }

	    value = replacer.call(parent, key, value);

	    switch (typeof value) {
	      case 'string':
	        return "\"".concat(strEscape(value), "\"");

	      case 'object':
	        {
	          if (value === null) {
	            return 'null';
	          }

	          if (stack.indexOf(value) !== -1) {
	            return circularValue;
	          }

	          let res = '';
	          let join = ',';
	          const originalIndentation = indentation;

	          if (Array.isArray(value)) {
	            if (value.length === 0) {
	              return '[]';
	            }

	            if (maximumDepth < stack.length + 1) {
	              return '"[Array]"';
	            }

	            stack.push(value);

	            if (spacer !== '') {
	              indentation += spacer;
	              res += "\n".concat(indentation);
	              join = ",\n".concat(indentation);
	            }

	            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
	            let i = 0;

	            for (; i < maximumValuesToStringify - 1; i++) {
	              const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
	              res += tmp !== undefined ? tmp : 'null';
	              res += join;
	            }

	            const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
	            res += tmp !== undefined ? tmp : 'null';

	            if (value.length - 1 > maximumBreadth) {
	              const removedKeys = value.length - maximumBreadth - 1;
	              res += "".concat(join, "\"... ").concat(getItemCount(removedKeys), " not stringified\"");
	            }

	            if (spacer !== '') {
	              res += "\n".concat(originalIndentation);
	            }

	            stack.pop();
	            return "[".concat(res, "]");
	          }

	          let keys = Object.keys(value);
	          const keyLength = keys.length;

	          if (keyLength === 0) {
	            return '{}';
	          }

	          if (maximumDepth < stack.length + 1) {
	            return '"[Object]"';
	          }

	          let whitespace = '';
	          let separator = '';

	          if (spacer !== '') {
	            indentation += spacer;
	            join = ",\n".concat(indentation);
	            whitespace = ' ';
	          }

	          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);

	          if (isTypedArrayWithEntries(value)) {
	            res += stringifyTypedArray(value, join, maximumBreadth);
	            keys = keys.slice(value.length);
	            maximumPropertiesToStringify -= value.length;
	            separator = join;
	          }

	          if (deterministic) {
	            keys = insertSort(keys);
	          }

	          stack.push(value);

	          for (let i = 0; i < maximumPropertiesToStringify; i++) {
	            const key = keys[i];
	            const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);

	            if (tmp !== undefined) {
	              res += "".concat(separator, "\"").concat(strEscape(key), "\":").concat(whitespace).concat(tmp);
	              separator = join;
	            }
	          }

	          if (keyLength > maximumBreadth) {
	            const removedKeys = keyLength - maximumBreadth;
	            res += "".concat(separator, "\"...\":").concat(whitespace, "\"").concat(getItemCount(removedKeys), " not stringified\"");
	            separator = join;
	          }

	          if (spacer !== '' && separator.length > 1) {
	            res = "\n".concat(indentation).concat(res, "\n").concat(originalIndentation);
	          }

	          stack.pop();
	          return "{".concat(res, "}");
	        }

	      case 'number':
	        return isFinite(value) ? String(value) : 'null';

	      case 'boolean':
	        return value === true ? 'true' : 'false';

	      case 'bigint':
	        return bigint ? String(value) : undefined;
	    }
	  }

	  function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
	    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
	      value = value.toJSON(key);
	    }

	    switch (typeof value) {
	      case 'string':
	        return "\"".concat(strEscape(value), "\"");

	      case 'object':
	        {
	          if (value === null) {
	            return 'null';
	          }

	          if (stack.indexOf(value) !== -1) {
	            return circularValue;
	          }

	          const originalIndentation = indentation;
	          let res = '';
	          let join = ',';

	          if (Array.isArray(value)) {
	            if (value.length === 0) {
	              return '[]';
	            }

	            if (maximumDepth < stack.length + 1) {
	              return '"[Array]"';
	            }

	            stack.push(value);

	            if (spacer !== '') {
	              indentation += spacer;
	              res += "\n".concat(indentation);
	              join = ",\n".concat(indentation);
	            }

	            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
	            let i = 0;

	            for (; i < maximumValuesToStringify - 1; i++) {
	              const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
	              res += tmp !== undefined ? tmp : 'null';
	              res += join;
	            }

	            const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
	            res += tmp !== undefined ? tmp : 'null';

	            if (value.length - 1 > maximumBreadth) {
	              const removedKeys = value.length - maximumBreadth - 1;
	              res += "".concat(join, "\"... ").concat(getItemCount(removedKeys), " not stringified\"");
	            }

	            if (spacer !== '') {
	              res += "\n".concat(originalIndentation);
	            }

	            stack.pop();
	            return "[".concat(res, "]");
	          }

	          if (replacer.size === 0) {
	            return '{}';
	          }

	          stack.push(value);
	          let whitespace = '';

	          if (spacer !== '') {
	            indentation += spacer;
	            join = ",\n".concat(indentation);
	            whitespace = ' ';
	          }

	          let separator = '';

	          for (const key of replacer) {
	            const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);

	            if (tmp !== undefined) {
	              res += "".concat(separator, "\"").concat(strEscape(key), "\":").concat(whitespace).concat(tmp);
	              separator = join;
	            }
	          }

	          if (spacer !== '' && separator.length > 1) {
	            res = "\n".concat(indentation).concat(res, "\n").concat(originalIndentation);
	          }

	          stack.pop();
	          return "{".concat(res, "}");
	        }

	      case 'number':
	        return isFinite(value) ? String(value) : 'null';

	      case 'boolean':
	        return value === true ? 'true' : 'false';

	      case 'bigint':
	        return bigint ? String(value) : undefined;
	    }
	  }

	  function stringifyIndent(key, value, stack, spacer, indentation) {
	    switch (typeof value) {
	      case 'string':
	        return "\"".concat(strEscape(value), "\"");

	      case 'object':
	        {
	          if (value === null) {
	            return 'null';
	          }

	          if (typeof value.toJSON === 'function') {
	            value = value.toJSON(key); // Prevent calling `toJSON` again.

	            if (typeof value !== 'object') {
	              return stringifyIndent(key, value, stack, spacer, indentation);
	            }

	            if (value === null) {
	              return 'null';
	            }
	          }

	          if (stack.indexOf(value) !== -1) {
	            return circularValue;
	          }

	          const originalIndentation = indentation;

	          if (Array.isArray(value)) {
	            if (value.length === 0) {
	              return '[]';
	            }

	            if (maximumDepth < stack.length + 1) {
	              return '"[Array]"';
	            }

	            stack.push(value);
	            indentation += spacer;
	            let res = "\n".concat(indentation);
	            const join = ",\n".concat(indentation);
	            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
	            let i = 0;

	            for (; i < maximumValuesToStringify - 1; i++) {
	              const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
	              res += tmp !== undefined ? tmp : 'null';
	              res += join;
	            }

	            const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
	            res += tmp !== undefined ? tmp : 'null';

	            if (value.length - 1 > maximumBreadth) {
	              const removedKeys = value.length - maximumBreadth - 1;
	              res += "".concat(join, "\"... ").concat(getItemCount(removedKeys), " not stringified\"");
	            }

	            res += "\n".concat(originalIndentation);
	            stack.pop();
	            return "[".concat(res, "]");
	          }

	          let keys = Object.keys(value);
	          const keyLength = keys.length;

	          if (keyLength === 0) {
	            return '{}';
	          }

	          if (maximumDepth < stack.length + 1) {
	            return '"[Object]"';
	          }

	          indentation += spacer;
	          const join = ",\n".concat(indentation);
	          let res = '';
	          let separator = '';
	          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);

	          if (isTypedArrayWithEntries(value)) {
	            res += stringifyTypedArray(value, join, maximumBreadth);
	            keys = keys.slice(value.length);
	            maximumPropertiesToStringify -= value.length;
	            separator = join;
	          }

	          if (deterministic) {
	            keys = insertSort(keys);
	          }

	          stack.push(value);

	          for (let i = 0; i < maximumPropertiesToStringify; i++) {
	            const key = keys[i];
	            const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);

	            if (tmp !== undefined) {
	              res += "".concat(separator, "\"").concat(strEscape(key), "\": ").concat(tmp);
	              separator = join;
	            }
	          }

	          if (keyLength > maximumBreadth) {
	            const removedKeys = keyLength - maximumBreadth;
	            res += "".concat(separator, "\"...\": \"").concat(getItemCount(removedKeys), " not stringified\"");
	            separator = join;
	          }

	          if (separator !== '') {
	            res = "\n".concat(indentation).concat(res, "\n").concat(originalIndentation);
	          }

	          stack.pop();
	          return "{".concat(res, "}");
	        }

	      case 'number':
	        return isFinite(value) ? String(value) : 'null';

	      case 'boolean':
	        return value === true ? 'true' : 'false';

	      case 'bigint':
	        return bigint ? String(value) : undefined;
	    }
	  }

	  function stringifySimple(key, value, stack) {
	    switch (typeof value) {
	      case 'string':
	        return "\"".concat(strEscape(value), "\"");

	      case 'object':
	        {
	          if (value === null) {
	            return 'null';
	          }

	          if (typeof value.toJSON === 'function') {
	            value = value.toJSON(key); // Prevent calling `toJSON` again

	            if (typeof value !== 'object') {
	              return stringifySimple(key, value, stack);
	            }

	            if (value === null) {
	              return 'null';
	            }
	          }

	          if (stack.indexOf(value) !== -1) {
	            return circularValue;
	          }

	          let res = '';

	          if (Array.isArray(value)) {
	            if (value.length === 0) {
	              return '[]';
	            }

	            if (maximumDepth < stack.length + 1) {
	              return '"[Array]"';
	            }

	            stack.push(value);
	            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
	            let i = 0;

	            for (; i < maximumValuesToStringify - 1; i++) {
	              const tmp = stringifySimple(i, value[i], stack);
	              res += tmp !== undefined ? tmp : 'null';
	              res += ',';
	            }

	            const tmp = stringifySimple(i, value[i], stack);
	            res += tmp !== undefined ? tmp : 'null';

	            if (value.length - 1 > maximumBreadth) {
	              const removedKeys = value.length - maximumBreadth - 1;
	              res += ",\"... ".concat(getItemCount(removedKeys), " not stringified\"");
	            }

	            stack.pop();
	            return "[".concat(res, "]");
	          }

	          let keys = Object.keys(value);
	          const keyLength = keys.length;

	          if (keyLength === 0) {
	            return '{}';
	          }

	          if (maximumDepth < stack.length + 1) {
	            return '"[Object]"';
	          }

	          let separator = '';
	          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);

	          if (isTypedArrayWithEntries(value)) {
	            res += stringifyTypedArray(value, ',', maximumBreadth);
	            keys = keys.slice(value.length);
	            maximumPropertiesToStringify -= value.length;
	            separator = ',';
	          }

	          if (deterministic) {
	            keys = insertSort(keys);
	          }

	          stack.push(value);

	          for (let i = 0; i < maximumPropertiesToStringify; i++) {
	            const key = keys[i];
	            const tmp = stringifySimple(key, value[key], stack);

	            if (tmp !== undefined) {
	              res += "".concat(separator, "\"").concat(strEscape(key), "\":").concat(tmp);
	              separator = ',';
	            }
	          }

	          if (keyLength > maximumBreadth) {
	            const removedKeys = keyLength - maximumBreadth;
	            res += "".concat(separator, "\"...\":\"").concat(getItemCount(removedKeys), " not stringified\"");
	          }

	          stack.pop();
	          return "{".concat(res, "}");
	        }

	      case 'number':
	        return isFinite(value) ? String(value) : 'null';

	      case 'boolean':
	        return value === true ? 'true' : 'false';

	      case 'bigint':
	        return bigint ? String(value) : undefined;
	    }
	  }

	  function stringify(value, replacer, space) {
	    if (arguments.length > 1) {
	      let spacer = '';

	      if (typeof space === 'number') {
	        spacer = ' '.repeat(Math.min(space, 10));
	      } else if (typeof space === 'string') {
	        spacer = space.slice(0, 10);
	      }

	      if (replacer != null) {
	        if (typeof replacer === 'function') {
	          return stringifyFnReplacer('', {
	            '': value
	          }, [], replacer, spacer, '');
	        }

	        if (Array.isArray(replacer)) {
	          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');
	        }
	      }

	      if (spacer.length !== 0) {
	        return stringifyIndent('', value, [], spacer, '');
	      }
	    }

	    return stringifySimple('', value, []);
	  }

	  return stringify;
	}
	safeStableStringify.stringify = stringify_1;
	safeStableStringify.configure = configure_1;

	class FlowEventSync {
	  constructor(recvEventCb, topic) {
	    _defineProperty(this, "evtNum", void 0);

	    _defineProperty(this, "dataPackageQueue", void 0);

	    _defineProperty(this, "topic", void 0);

	    _defineProperty(this, "isRunning", void 0);

	    _defineProperty(this, "recvEventCb", void 0);

	    this.evtNum = 0;
	    this.topic = topic;
	    this.dataPackageQueue = [];
	    this.isRunning = true;
	    this.recvEventCb = recvEventCb;

	    if (topic) {
	      Coherent.on('OnInteractionEvent', this.processEventsReceived.bind(this));
	    }

	    const sendFn = () => {
	      if (this.dataPackageQueue.length > 0) {
	        const syncDataPackage = {
	          data: this.dataPackageQueue
	        };
	        LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', FlowEventSync.EB_LISTENER_KEY, safeStableStringify(syncDataPackage));
	        this.dataPackageQueue.length = 0;
	      }

	      if (this.isRunning) {
	        requestAnimationFrame(sendFn);
	      }
	    };

	    requestAnimationFrame(sendFn);
	  }

	  stop() {
	    this.isRunning = false;
	  }
	  /**
	   * Processes events received from onInteractionEvent and executes the configured callback.
	   * @param target always empty
	   * @param args [0] the eventlistener key [1] SyncDataPackage
	   */


	  processEventsReceived(_target, args) {
	    // identify if its a flowsyncevent
	    if (args.length === 0 || args[0] !== FlowEventSync.EB_LISTENER_KEY) {
	      return;
	    }

	    const syncDataPackage = JSON.parse(args[1]);
	    syncDataPackage.data.forEach(data => {
	      if (data.topic === this.topic) {
	        try {
	          this.recvEventCb(data.topic, data.data !== undefined ? JSON.parse(data.data) : undefined);
	        } catch (e) {
	          console.error(e);

	          if (e instanceof Error) {
	            console.error(e.stack);
	          }
	        }
	      }
	    });
	  }
	  /**
	   * Sends an event via flow events.
	   * @param topic The topic to send data on.
	   * @param data The data to send.
	   */


	  sendEvent(topic, data) {
	    const dataObj = safeStableStringify(data);
	    const dataPackage = {
	      evtNum: this.evtNum++,
	      topic,
	      data: dataObj
	    };
	    this.dataPackageQueue.push(dataPackage);
	  }

	  receiveEvent() {// noop
	  }

	}

	_defineProperty(FlowEventSync, "EB_LISTENER_KEY", 'EB_EVENTS');

	// We currently assume that these two elements will be found.
	// Might be worth implementing checking in the future.
	let reactMount = document.getElementById('MSFS_REACT_MOUNT');
	/**
	 * Returns the render target which React mounts onto
	 */

	const getRenderTarget = () => reactMount;
	/**
	 * Returns the root element which receives `update` events
	 */

	const getRootElement = () => {
	  var _reactMount;

	  if ((_reactMount = reactMount) !== null && _reactMount !== void 0 && _reactMount.parentElement) {
	    return reactMount.parentElement;
	  }

	  throw new Error('Could not find rootElement');
	};

	const useUpdate = handler => {
	  // Logic based on https://usehooks.com/useEventListener/
	  const savedHandler = react.useRef(handler);
	  react.useEffect(() => {
	    savedHandler.current = handler;
	  }, [handler]);
	  react.useEffect(() => {
	    const wrappedHandler = event => {
	      savedHandler.current(event.detail);
	    };

	    getRootElement().addEventListener('update', wrappedHandler);
	    return () => {
	      getRootElement().removeEventListener('update', wrappedHandler);
	    };
	  }, []);
	};
	const useInteractionEvent = (event, handler) => {
	  // Logic based on https://usehooks.com/useEventListener/
	  const savedHandler = react.useRef(handler);
	  react.useEffect(() => {
	    savedHandler.current = handler;
	  }, [handler]);
	  react.useEffect(() => {
	    const wrappedHandler = e => {
	      if (event === '*') {
	        savedHandler.current(e.detail);
	      } else {
	        savedHandler.current();
	      }
	    };

	    getRootElement().addEventListener(event, wrappedHandler);
	    return () => {
	      getRootElement().removeEventListener(event, wrappedHandler);
	    };
	  }, [event]);
	};
	const useCoherentEvent = (event, handler) => {
	  const savedHandler = react.useRef(handler);
	  react.useEffect(() => {
	    savedHandler.current = handler;
	  }, [handler]);
	  react.useEffect(() => {
	    console.log('hooking coherent event', event);
	    const coherentHandler = Coherent.on(event, savedHandler.current);
	    console.log(coherentHandler);
	    return () => {
	      coherentHandler.clear();
	    };
	  }, [event]);
	};
	const useFlowSyncEvent = (event, handler) => {
	  const savedHandler = react.useRef(handler);
	  react.useEffect(() => {
	    savedHandler.current = handler;
	  }, [handler]);
	  react.useEffect(() => {
	    const flowEventHandler = new FlowEventSync(savedHandler.current, event);
	    return () => {
	      flowEventHandler.stop();
	    };
	  }, [event]);
	};

	/**
	 * The useSimVar hook provides an easy way to read and write SimVars from React.
	 *
	 * It's signature is similar to useState and it regularly refreshes the SimVar
	 * to ensure your React component stays in sync with the SimVar being modified
	 * from outside your component (like from other components, XML or SimConnect).
	 *
	 * You may optionally specify the refresh interval. If the same SimVar
	 * is used in multiple places, this hook will automatically deduplicate those
	 * for maximum performance, rather than fetching the SimVar multiple times.
	 * Setting the SimVar will instantly cause it to be updated in all other places
	 * within the same React tree.
	 *
	 * @param name The name of the SimVar.
	 * @param unit The unit of the SimVar.
	 * @param refreshInterval The time in milliseconds that needs to elapse before
	 * the next render will cause a SimVar refresh from the simulator.
	 *
	 * @example
	 * // the return value is the value itself and a setter, similar to useState
	 * const [v1, setV1] = useSimVar('L:AIRLINER_V1_SPEED', 'Knots');
	 *
	 * @example
	 * // only refresh the SimVar every 500ms
	 * const [lightsTest] = useSimVar('L:A32NX_OVHD_INTLT_ANN', 'Bool', 500);
	 *
	 * @returns {[*, (function(*): void)]}
	 *
	 * @see {@link useSplitSimVar} if your SimVar is set through a K event
	 * @see {@link useInteractionSimVar} if you emit an H event whenever your SimVar changes
	 * @see {@link useGlobalVar} if you have a Global Var instead
	 */
	const useSimVar = function (name, unit) {
	  let refreshInterval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  const lastUpdate = react.useRef(Date.now() - refreshInterval - 1);
	  const [stateValue, setStateValue] = react.useState(() => SimVar.GetSimVarValue(name, unit));
	  const updateCallback = react.useCallback(() => {
	    const delta = Date.now() - lastUpdate.current;

	    if (delta >= refreshInterval) {
	      lastUpdate.current = Date.now();
	      const newValue = SimVar.GetSimVarValue(name, unit);
	      setStateValue(newValue);
	    }
	  }, [name, unit, refreshInterval]);
	  useUpdate(updateCallback);
	  const setter = react.useCallback(valueOrSetter => {
	    const executedValue = typeof valueOrSetter === 'function' ? valueOrSetter(stateValue) : valueOrSetter;
	    SimVar.SetSimVarValue(name, unit, executedValue);
	    setStateValue(executedValue);
	    return stateValue;
	  }, [name, unit, stateValue]);
	  return [stateValue, setter];
	};

	var reactJsxRuntime_production_min = createCommonjsModule(function (module, exports) {

	  var g = 60103;
	  exports.Fragment = 60107;

	  if ("function" === typeof Symbol && Symbol.for) {
	    var h = Symbol.for;
	    g = h("react.element");
	    exports.Fragment = h("react.fragment");
	  }

	  var m = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
	      n = Object.prototype.hasOwnProperty,
	      p = {
	    key: !0,
	    ref: !0,
	    __self: !0,
	    __source: !0
	  };

	  function q(c, a, k) {
	    var b,
	        d = {},
	        e = null,
	        l = null;
	    void 0 !== k && (e = "" + k);
	    void 0 !== a.key && (e = "" + a.key);
	    void 0 !== a.ref && (l = a.ref);

	    for (b in a) n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);

	    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
	    return {
	      $$typeof: g,
	      type: c,
	      key: e,
	      ref: l,
	      props: d,
	      _owner: m.current
	    };
	  }

	  exports.jsx = q;
	  exports.jsxs = q;
	});

	createCommonjsModule(function (module, exports) {
	});

	var jsxRuntime = createCommonjsModule(function (module) {

	  {
	    module.exports = reactJsxRuntime_production_min;
	  }
	});

	var DisplayUnitState;

	(function (DisplayUnitState) {
	  DisplayUnitState[DisplayUnitState["On"] = 0] = "On";
	  DisplayUnitState[DisplayUnitState["Off"] = 1] = "Off";
	  DisplayUnitState[DisplayUnitState["Selftest"] = 2] = "Selftest";
	  DisplayUnitState[DisplayUnitState["Standby"] = 3] = "Standby";
	})(DisplayUnitState || (DisplayUnitState = {}));

	function BacklightBleed(props) {
	  if (props.homeCockpit) {
	    return null;
	  }

	  return /*#__PURE__*/jsxRuntime.jsx("div", {
	    className: "BacklightBleed"
	  });
	}

	const DisplayUnit = props => {
	  const [coldDark] = useSimVar('L:A32NX_COLD_AND_DARK_SPAWN', 'Bool', 200);
	  const [state, setState] = react.useState(coldDark ? DisplayUnitState.Off : DisplayUnitState.Standby);
	  const timer = react.useRef(null);
	  const [potentiometer] = useSimVar("LIGHT POTENTIOMETER:".concat(props.potentiometerIndex), 'percent over 100', 200);
	  const [electricityState] = useSimVar(props.electricitySimvar, 'bool', 200);
	  const [homeCockpit] = useSimVar('L:A32NX_HOME_COCKPIT_ENABLED', 'bool', 200);
	  useUpdate(deltaTime => {
	    if (timer.current !== null) {
	      if (timer.current > 0) {
	        timer.current -= deltaTime / 1000;
	      } else if (state === DisplayUnitState.Standby) {
	        setState(DisplayUnitState.Off);
	        timer.current = null;
	      } else if (state === DisplayUnitState.Selftest) {
	        setState(DisplayUnitState.On);
	        timer.current = null;
	      }
	    } // override MSFS menu animations setting for this instrument


	    if (!document.documentElement.classList.contains('animationsEnabled')) {
	      document.documentElement.classList.add('animationsEnabled');
	    }
	  });
	  react.useEffect(() => {
	    if (state !== DisplayUnitState.Off && props.failed) {
	      setState(DisplayUnitState.Off);
	    } else if (state === DisplayUnitState.On && (potentiometer === 0 || electricityState === 0)) {
	      setState(DisplayUnitState.Standby);
	      timer.current = 10;
	    } else if (state === DisplayUnitState.Standby && potentiometer !== 0 && electricityState !== 0) {
	      setState(DisplayUnitState.On);
	      timer.current = null;
	    } else if (state === DisplayUnitState.Off && potentiometer !== 0 && electricityState !== 0 && !props.failed) {
	      setState(DisplayUnitState.Selftest);
	      timer.current = parseInt(NXDataStore.get('CONFIG_SELF_TEST_TIME', '15'));
	    } else if (state === DisplayUnitState.Selftest && (potentiometer === 0 || electricityState === 0)) {
	      setState(DisplayUnitState.Off);
	      timer.current = null;
	    }
	  }, [timer.current, state, potentiometer, electricityState]);

	  if (state === DisplayUnitState.Selftest) {
	    return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx(BacklightBleed, {
	        homeCockpit: homeCockpit
	      }), /*#__PURE__*/jsxRuntime.jsxs("svg", {
	        className: "SelfTest",
	        viewBox: "0 0 600 600",
	        children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
	          className: "SelfTestBackground",
	          x: "0",
	          y: "0",
	          width: "100%",
	          height: "100%"
	        }), /*#__PURE__*/jsxRuntime.jsx("text", {
	          className: "SelfTestText",
	          x: "50%",
	          y: "50%",
	          children: "SELF TEST IN PROGRESS"
	        }), /*#__PURE__*/jsxRuntime.jsx("text", {
	          className: "SelfTestText",
	          x: "50%",
	          y: "56%",
	          children: "(MAX 40 SECONDS)"
	        })]
	      })]
	    });
	  }

	  if (state === DisplayUnitState.Off) {
	    return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx(BacklightBleed, {
	      homeCockpit: homeCockpit
	    }), /*#__PURE__*/jsxRuntime.jsx("div", {
	      style: {
	        display: state === DisplayUnitState.On ? 'block' : 'none'
	      },
	      children: props.children
	    })]
	  });
	};

	// Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	// SPDX-License-Identifier: MIT
	let AirportClass;

	(function (AirportClass) {
	  AirportClass[AirportClass["Unknown"] = 0] = "Unknown";
	  AirportClass[AirportClass["Normal"] = 1] = "Normal";
	  AirportClass[AirportClass["SoftUnknown"] = 2] = "SoftUnknown";
	  AirportClass[AirportClass["Seaplane"] = 3] = "Seaplane";
	  AirportClass[AirportClass["Heliport"] = 4] = "Heliport";
	  AirportClass[AirportClass["Private"] = 5] = "Private";
	})(AirportClass || (AirportClass = {}));

	let AirportPrivateType;

	(function (AirportPrivateType) {
	  AirportPrivateType[AirportPrivateType["Unknown"] = 0] = "Unknown";
	  AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
	  AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
	  AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
	})(AirportPrivateType || (AirportPrivateType = {}));

	let AirspaceType;

	(function (AirspaceType) {
	  AirspaceType[AirspaceType["None"] = 0] = "None";
	  AirspaceType[AirspaceType["Center"] = 1] = "Center";
	  AirspaceType[AirspaceType["ClassA"] = 2] = "ClassA";
	  AirspaceType[AirspaceType["ClassB"] = 3] = "ClassB";
	  AirspaceType[AirspaceType["ClassC"] = 4] = "ClassC";
	  AirspaceType[AirspaceType["ClassD"] = 5] = "ClassD";
	  AirspaceType[AirspaceType["ClassE"] = 6] = "ClassE";
	  AirspaceType[AirspaceType["ClassF"] = 7] = "ClassF";
	  AirspaceType[AirspaceType["ClassG"] = 8] = "ClassG";
	  AirspaceType[AirspaceType["Tower"] = 9] = "Tower";
	  AirspaceType[AirspaceType["Clearance"] = 10] = "Clearance";
	  AirspaceType[AirspaceType["Ground"] = 11] = "Ground";
	  AirspaceType[AirspaceType["Departure"] = 12] = "Departure";
	  AirspaceType[AirspaceType["Approach"] = 13] = "Approach";
	  AirspaceType[AirspaceType["MOA"] = 14] = "MOA";
	  AirspaceType[AirspaceType["Restricted"] = 15] = "Restricted";
	  AirspaceType[AirspaceType["Prohibited"] = 16] = "Prohibited";
	  AirspaceType[AirspaceType["Warning"] = 17] = "Warning";
	  AirspaceType[AirspaceType["Alert"] = 18] = "Alert";
	  AirspaceType[AirspaceType["Danger"] = 19] = "Danger";
	  AirspaceType[AirspaceType["NationalPark"] = 20] = "NationalPark";
	  AirspaceType[AirspaceType["ModeC"] = 21] = "ModeC";
	  AirspaceType[AirspaceType["Radar"] = 22] = "Radar";
	  AirspaceType[AirspaceType["Training"] = 23] = "Training";
	})(AirspaceType || (AirspaceType = {}));

	let AltitudeDescriptor;

	(function (AltitudeDescriptor) {
	  AltitudeDescriptor[AltitudeDescriptor["Empty"] = 0] = "Empty";
	  AltitudeDescriptor[AltitudeDescriptor["At"] = 1] = "At";
	  AltitudeDescriptor[AltitudeDescriptor["AtOrAbove"] = 2] = "AtOrAbove";
	  AltitudeDescriptor[AltitudeDescriptor["AtOrBelow"] = 3] = "AtOrBelow";
	  AltitudeDescriptor[AltitudeDescriptor["Between"] = 4] = "Between";
	  AltitudeDescriptor[AltitudeDescriptor["C"] = 5] = "C";
	  AltitudeDescriptor[AltitudeDescriptor["G"] = 6] = "G";
	  AltitudeDescriptor[AltitudeDescriptor["H"] = 7] = "H";
	  AltitudeDescriptor[AltitudeDescriptor["I"] = 8] = "I";
	  AltitudeDescriptor[AltitudeDescriptor["J"] = 9] = "J";
	  AltitudeDescriptor[AltitudeDescriptor["V"] = 10] = "V";
	})(AltitudeDescriptor || (AltitudeDescriptor = {}));

	let FixTypeFlags;

	(function (FixTypeFlags) {
	  FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
	  FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
	  FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
	  FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
	  FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
	})(FixTypeFlags || (FixTypeFlags = {}));

	let FrequencyType; // ARINC424 names

	(function (FrequencyType) {
	  FrequencyType[FrequencyType["None"] = 0] = "None";
	  FrequencyType[FrequencyType["ATIS"] = 1] = "ATIS";
	  FrequencyType[FrequencyType["Multicom"] = 2] = "Multicom";
	  FrequencyType[FrequencyType["Unicom"] = 3] = "Unicom";
	  FrequencyType[FrequencyType["CTAF"] = 4] = "CTAF";
	  FrequencyType[FrequencyType["Ground"] = 5] = "Ground";
	  FrequencyType[FrequencyType["Tower"] = 6] = "Tower";
	  FrequencyType[FrequencyType["Clearance"] = 7] = "Clearance";
	  FrequencyType[FrequencyType["Approach"] = 8] = "Approach";
	  FrequencyType[FrequencyType["Departure"] = 9] = "Departure";
	  FrequencyType[FrequencyType["Center"] = 10] = "Center";
	  FrequencyType[FrequencyType["FSS"] = 11] = "FSS";
	  FrequencyType[FrequencyType["AWOS"] = 12] = "AWOS";
	  FrequencyType[FrequencyType["ASOS"] = 13] = "ASOS";
	  FrequencyType[FrequencyType["ClearancePreTaxi"] = 14] = "ClearancePreTaxi";
	  FrequencyType[FrequencyType["RemoteDeliveryClearance"] = 15] = "RemoteDeliveryClearance";
	})(FrequencyType || (FrequencyType = {}));

	let LegType;

	(function (LegType) {
	  LegType[LegType["Unknown"] = 0] = "Unknown";
	  LegType[LegType["AF"] = 1] = "AF";
	  LegType[LegType["CA"] = 2] = "CA";
	  LegType[LegType["CD"] = 3] = "CD";
	  LegType[LegType["CF"] = 4] = "CF";
	  LegType[LegType["CI"] = 5] = "CI";
	  LegType[LegType["CR"] = 6] = "CR";
	  LegType[LegType["DF"] = 7] = "DF";
	  LegType[LegType["FA"] = 8] = "FA";
	  LegType[LegType["FC"] = 9] = "FC";
	  LegType[LegType["FD"] = 10] = "FD";
	  LegType[LegType["FM"] = 11] = "FM";
	  LegType[LegType["HA"] = 12] = "HA";
	  LegType[LegType["HF"] = 13] = "HF";
	  LegType[LegType["HM"] = 14] = "HM";
	  LegType[LegType["IF"] = 15] = "IF";
	  LegType[LegType["PI"] = 16] = "PI";
	  LegType[LegType["RF"] = 17] = "RF";
	  LegType[LegType["TF"] = 18] = "TF";
	  LegType[LegType["VA"] = 19] = "VA";
	  LegType[LegType["VD"] = 20] = "VD";
	  LegType[LegType["VI"] = 21] = "VI";
	  LegType[LegType["VM"] = 22] = "VM";
	  LegType[LegType["VR"] = 23] = "VR";
	})(LegType || (LegType = {}));

	let NdbType;

	(function (NdbType) {
	  NdbType[NdbType["CompassLocator"] = 0] = "CompassLocator";
	  NdbType[NdbType["MH"] = 1] = "MH";
	  NdbType[NdbType["H"] = 2] = "H";
	  NdbType[NdbType["HH"] = 3] = "HH";
	})(NdbType || (NdbType = {}));

	let NearestSearchType;

	(function (NearestSearchType) {
	  NearestSearchType[NearestSearchType["None"] = 0] = "None";
	  NearestSearchType[NearestSearchType["Airport"] = 1] = "Airport";
	  NearestSearchType[NearestSearchType["Intersection"] = 2] = "Intersection";
	  NearestSearchType[NearestSearchType["Vor"] = 3] = "Vor";
	  NearestSearchType[NearestSearchType["Ndb"] = 4] = "Ndb";
	  NearestSearchType[NearestSearchType["Boundary"] = 5] = "Boundary";
	})(NearestSearchType || (NearestSearchType = {}));

	let RnavTypeFlags;

	(function (RnavTypeFlags) {
	  RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
	  RnavTypeFlags[RnavTypeFlags["Lnav"] = 1] = "Lnav";
	  RnavTypeFlags[RnavTypeFlags["LnavVnav"] = 2] = "LnavVnav";
	  RnavTypeFlags[RnavTypeFlags["Lp"] = 4] = "Lp";
	  RnavTypeFlags[RnavTypeFlags["Lpv"] = 8] = "Lpv";
	})(RnavTypeFlags || (RnavTypeFlags = {}));

	let RouteType;

	(function (RouteType) {
	  RouteType[RouteType["None"] = 0] = "None";
	  RouteType[RouteType["LowLevel"] = 1] = "LowLevel";
	  RouteType[RouteType["HighLevel"] = 2] = "HighLevel";
	  RouteType[RouteType["All"] = 3] = "All";
	})(RouteType || (RouteType = {}));

	let RunwayDesignatorChar;

	(function (RunwayDesignatorChar) {
	  RunwayDesignatorChar[RunwayDesignatorChar["L"] = 1] = "L";
	  RunwayDesignatorChar[RunwayDesignatorChar["R"] = 2] = "R";
	  RunwayDesignatorChar[RunwayDesignatorChar["C"] = 3] = "C";
	  RunwayDesignatorChar[RunwayDesignatorChar["W"] = 4] = "W";
	  RunwayDesignatorChar[RunwayDesignatorChar["A"] = 5] = "A";
	  RunwayDesignatorChar[RunwayDesignatorChar["B"] = 6] = "B";
	})(RunwayDesignatorChar || (RunwayDesignatorChar = {}));

	let RunwayLighting;

	(function (RunwayLighting) {
	  RunwayLighting[RunwayLighting["Unknown"] = 0] = "Unknown";
	  RunwayLighting[RunwayLighting["None"] = 1] = "None";
	  RunwayLighting[RunwayLighting["PartTime"] = 2] = "PartTime";
	  RunwayLighting[RunwayLighting["FullTime"] = 3] = "FullTime";
	  RunwayLighting[RunwayLighting["Frequency"] = 4] = "Frequency";
	})(RunwayLighting || (RunwayLighting = {}));

	let RunwaySurface;

	(function (RunwaySurface) {
	  RunwaySurface[RunwaySurface["Concrete"] = 0] = "Concrete";
	  RunwaySurface[RunwaySurface["Grass"] = 1] = "Grass";
	  RunwaySurface[RunwaySurface["WaterFsx"] = 2] = "WaterFsx";
	  RunwaySurface[RunwaySurface["GrassBumpy"] = 3] = "GrassBumpy";
	  RunwaySurface[RunwaySurface["Asphalt"] = 4] = "Asphalt";
	  RunwaySurface[RunwaySurface["ShortGrass"] = 5] = "ShortGrass";
	  RunwaySurface[RunwaySurface["LongGrass"] = 6] = "LongGrass";
	  RunwaySurface[RunwaySurface["HardTurf"] = 7] = "HardTurf";
	  RunwaySurface[RunwaySurface["Snow"] = 8] = "Snow";
	  RunwaySurface[RunwaySurface["Ice"] = 9] = "Ice";
	  RunwaySurface[RunwaySurface["Urban"] = 10] = "Urban";
	  RunwaySurface[RunwaySurface["Forest"] = 11] = "Forest";
	  RunwaySurface[RunwaySurface["Dirt"] = 12] = "Dirt";
	  RunwaySurface[RunwaySurface["Coral"] = 13] = "Coral";
	  RunwaySurface[RunwaySurface["Gravel"] = 14] = "Gravel";
	  RunwaySurface[RunwaySurface["OilTreated"] = 15] = "OilTreated";
	  RunwaySurface[RunwaySurface["SteelMats"] = 16] = "SteelMats";
	  RunwaySurface[RunwaySurface["Bituminous"] = 17] = "Bituminous";
	  RunwaySurface[RunwaySurface["Brick"] = 18] = "Brick";
	  RunwaySurface[RunwaySurface["Macadam"] = 19] = "Macadam";
	  RunwaySurface[RunwaySurface["Planks"] = 20] = "Planks";
	  RunwaySurface[RunwaySurface["Sand"] = 21] = "Sand";
	  RunwaySurface[RunwaySurface["Shale"] = 22] = "Shale";
	  RunwaySurface[RunwaySurface["Tarmac"] = 23] = "Tarmac";
	  RunwaySurface[RunwaySurface["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
	  RunwaySurface[RunwaySurface["Ocean"] = 26] = "Ocean";
	  RunwaySurface[RunwaySurface["Water"] = 27] = "Water";
	  RunwaySurface[RunwaySurface["Pond"] = 28] = "Pond";
	  RunwaySurface[RunwaySurface["Lake"] = 29] = "Lake";
	  RunwaySurface[RunwaySurface["River"] = 30] = "River";
	  RunwaySurface[RunwaySurface["WasterWater"] = 31] = "WasterWater";
	  RunwaySurface[RunwaySurface["Paint"] = 32] = "Paint";
	})(RunwaySurface || (RunwaySurface = {}));

	let TurnDirection;

	(function (TurnDirection) {
	  TurnDirection[TurnDirection["Unknown"] = 0] = "Unknown";
	  TurnDirection[TurnDirection["Left"] = 1] = "Left";
	  TurnDirection[TurnDirection["Right"] = 2] = "Right";
	  TurnDirection[TurnDirection["Either"] = 3] = "Either";
	})(TurnDirection || (TurnDirection = {}));

	let VorClass;

	(function (VorClass) {
	  VorClass[VorClass["Unknown"] = 0] = "Unknown";
	  VorClass[VorClass["Terminal"] = 1] = "Terminal";
	  VorClass[VorClass["LowAltitude"] = 2] = "LowAltitude";
	  VorClass[VorClass["HighAlttitude"] = 3] = "HighAlttitude";
	  VorClass[VorClass["ILS"] = 4] = "ILS";
	  VorClass[VorClass["VOT"] = 5] = "VOT";
	})(VorClass || (VorClass = {}));

	let VorType;

	(function (VorType) {
	  VorType[VorType["Unknown"] = 0] = "Unknown";
	  VorType[VorType["VOR"] = 1] = "VOR";
	  VorType[VorType["VORDME"] = 2] = "VORDME";
	  VorType[VorType["DME"] = 3] = "DME";
	  VorType[VorType["TACAN"] = 4] = "TACAN";
	  VorType[VorType["VORTAC"] = 5] = "VORTAC";
	  VorType[VorType["ILS"] = 6] = "ILS";
	  VorType[VorType["VOT"] = 7] = "VOT";
	})(VorType || (VorType = {}));

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/**
	 * A segment of a flight plan.
	 */
	class FlightPlanSegment {
	  /**
	  * Creates a new FlightPlanSegment.
	  * @param type The type of the flight plan segment.
	  * @param offset The offset within the original flight plan that
	  * the segment starts at.
	  * @param waypoints The waypoints in the flight plan segment.
	  */
	  constructor(type, offset, waypoints) {
	    this.type = type;
	    this.offset = offset;
	    this.waypoints = waypoints;
	    this.type = type;
	    this.offset = offset;
	    this.waypoints = waypoints;
	  }
	  /** An empty flight plan segment. */


	}
	/** Types of flight plan segments. */

	_defineProperty(FlightPlanSegment, "Empty", new FlightPlanSegment(-1, -1, []));

	let SegmentType;

	(function (SegmentType) {
	  SegmentType[SegmentType["Origin"] = 0] = "Origin";
	  SegmentType[SegmentType["Departure"] = 1] = "Departure";
	  SegmentType[SegmentType["Enroute"] = 2] = "Enroute";
	  SegmentType[SegmentType["Arrival"] = 3] = "Arrival";
	  SegmentType[SegmentType["Approach"] = 4] = "Approach";
	  SegmentType[SegmentType["Missed"] = 5] = "Missed";
	  SegmentType[SegmentType["Destination"] = 6] = "Destination";
	})(SegmentType || (SegmentType = {}));

	//  Copyright (c) 2021 FlyByWire Simulations
	//  SPDX-License-Identifier: GPL-3.0
	let HoldType;

	(function (HoldType) {
	  HoldType[HoldType["Computed"] = 0] = "Computed";
	  HoldType[HoldType["Database"] = 1] = "Database";
	  HoldType[HoldType["Pilot"] = 2] = "Pilot";
	})(HoldType || (HoldType = {}));

	var _extends_1 = createCommonjsModule(function (module) {
	  function _extends() {
	    module.exports = _extends = Object.assign || function (target) {
	      for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];

	        for (var key in source) {
	          if (Object.prototype.hasOwnProperty.call(source, key)) {
	            target[key] = source[key];
	          }
	        }
	      }

	      return target;
	    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
	    return _extends.apply(this, arguments);
	  }

	  module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	var _extends = /*@__PURE__*/getDefaultExportFromCjs(_extends_1);

	var DEFAULT_CONFIG = {
	  // minimum relative difference between two compared values,
	  // used by all comparison functions
	  epsilon: 1e-12,
	  // type of default matrix output. Choose 'matrix' (default) or 'array'
	  matrix: 'Matrix',
	  // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
	  number: 'number',
	  // number of significant digits in BigNumbers
	  precision: 64,
	  // predictable output type of functions. When true, output type depends only
	  // on the input types. When false (default), output type can vary depending
	  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
	  // predictable is false, and returns `NaN` when true.
	  predictable: false,
	  // random seed for seeded pseudo random number generation
	  // null = randomly seed
	  randomSeed: null
	};

	// type checks for all known types
	//
	// note that:
	//
	// - check by duck-typing on a property like `isUnit`, instead of checking instanceof.
	//   instanceof cannot be used because that would not allow to pass data from
	//   one instance of math.js to another since each has it's own instance of Unit.
	// - check the `isUnit` property via the constructor, so there will be no
	//   matches for "fake" instances like plain objects with a property `isUnit`.
	//   That is important for security reasons.
	// - It must not be possible to override the type checks used internally,
	//   for security reasons, so these functions are not exposed in the expression
	//   parser.
	function isNumber(x) {
	  return typeof x === 'number';
	}
	function isBigNumber(x) {
	  if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {
	    return false;
	  }

	  if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {
	    return true;
	  }

	  if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {
	    return true;
	  }

	  return false;
	}
	function isComplex(x) {
	  return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;
	}
	function isFraction(x) {
	  return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;
	}
	function isUnit(x) {
	  return x && x.constructor.prototype.isUnit === true || false;
	}
	function isString$1(x) {
	  return typeof x === 'string';
	}
	var isArray = Array.isArray;
	function isMatrix(x) {
	  return x && x.constructor.prototype.isMatrix === true || false;
	}
	/**
	 * Test whether a value is a collection: an Array or Matrix
	 * @param {*} x
	 * @returns {boolean} isCollection
	 */

	function isCollection(x) {
	  return Array.isArray(x) || isMatrix(x);
	}
	function isDenseMatrix(x) {
	  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
	}
	function isSparseMatrix(x) {
	  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
	}
	function isRange(x) {
	  return x && x.constructor.prototype.isRange === true || false;
	}
	function isIndex(x) {
	  return x && x.constructor.prototype.isIndex === true || false;
	}
	function isBoolean(x) {
	  return typeof x === 'boolean';
	}
	function isResultSet(x) {
	  return x && x.constructor.prototype.isResultSet === true || false;
	}
	function isHelp(x) {
	  return x && x.constructor.prototype.isHelp === true || false;
	}
	function isFunction(x) {
	  return typeof x === 'function';
	}
	function isDate(x) {
	  return x instanceof Date;
	}
	function isRegExp$1(x) {
	  return x instanceof RegExp;
	}
	function isObject(x) {
	  return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));
	}
	function isNull(x) {
	  return x === null;
	}
	function isUndefined(x) {
	  return x === undefined;
	}
	function isAccessorNode(x) {
	  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isArrayNode(x) {
	  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isAssignmentNode(x) {
	  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isBlockNode(x) {
	  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isConditionalNode(x) {
	  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isConstantNode(x) {
	  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isFunctionAssignmentNode(x) {
	  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isFunctionNode(x) {
	  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isIndexNode(x) {
	  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isNode(x) {
	  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isObjectNode(x) {
	  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isOperatorNode(x) {
	  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isParenthesisNode(x) {
	  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isRangeNode(x) {
	  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isSymbolNode(x) {
	  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
	}
	function isChain(x) {
	  return x && x.constructor.prototype.isChain === true || false;
	}
	function typeOf(x) {
	  var t = typeof x;

	  if (t === 'object') {
	    // JavaScript types
	    if (x === null) return 'null';
	    if (Array.isArray(x)) return 'Array';
	    if (x instanceof Date) return 'Date';
	    if (x instanceof RegExp) return 'RegExp'; // math.js types

	    if (isBigNumber(x)) return 'BigNumber';
	    if (isComplex(x)) return 'Complex';
	    if (isFraction(x)) return 'Fraction';
	    if (isMatrix(x)) return 'Matrix';
	    if (isUnit(x)) return 'Unit';
	    if (isIndex(x)) return 'Index';
	    if (isRange(x)) return 'Range';
	    if (isResultSet(x)) return 'ResultSet';
	    if (isNode(x)) return x.type;
	    if (isChain(x)) return 'Chain';
	    if (isHelp(x)) return 'Help';
	    return 'Object';
	  }

	  if (t === 'function') return 'Function';
	  return t; // can be 'string', 'number', 'boolean', ...
	}

	/**
	 * Clone an object
	 *
	 *     clone(x)
	 *
	 * Can clone any primitive type, array, and object.
	 * If x has a function clone, this function will be invoked to clone the object.
	 *
	 * @param {*} x
	 * @return {*} clone
	 */

	function clone(x) {
	  var type = typeof x; // immutable primitive types

	  if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {
	    return x;
	  } // use clone function of the object when available


	  if (typeof x.clone === 'function') {
	    return x.clone();
	  } // array


	  if (Array.isArray(x)) {
	    return x.map(function (value) {
	      return clone(value);
	    });
	  }

	  if (x instanceof Date) return new Date(x.valueOf());
	  if (isBigNumber(x)) return x; // bignumbers are immutable

	  if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp
	  // object

	  return mapObject(x, clone);
	}
	/**
	 * Apply map to all properties of an object
	 * @param {Object} object
	 * @param {function} callback
	 * @return {Object} Returns a copy of the object with mapped properties
	 */

	function mapObject(object, callback) {
	  var clone = {};

	  for (var key in object) {
	    if (hasOwnProperty(object, key)) {
	      clone[key] = callback(object[key]);
	    }
	  }

	  return clone;
	}
	/**
	 * Extend object a with the properties of object b
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 */

	function extend(a, b) {
	  for (var prop in b) {
	    if (hasOwnProperty(b, prop)) {
	      a[prop] = b[prop];
	    }
	  }

	  return a;
	}
	/**
	 * Deep test equality of all fields in two pairs of arrays or objects.
	 * Compares values and functions strictly (ie. 2 is not the same as '2').
	 * @param {Array | Object} a
	 * @param {Array | Object} b
	 * @returns {boolean}
	 */

	function deepStrictEqual(a, b) {
	  var prop, i, len;

	  if (Array.isArray(a)) {
	    if (!Array.isArray(b)) {
	      return false;
	    }

	    if (a.length !== b.length) {
	      return false;
	    }

	    for (i = 0, len = a.length; i < len; i++) {
	      if (!deepStrictEqual(a[i], b[i])) {
	        return false;
	      }
	    }

	    return true;
	  } else if (typeof a === 'function') {
	    return a === b;
	  } else if (a instanceof Object) {
	    if (Array.isArray(b) || !(b instanceof Object)) {
	      return false;
	    }

	    for (prop in a) {
	      // noinspection JSUnfilteredForInLoop
	      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
	        return false;
	      }
	    }

	    for (prop in b) {
	      // noinspection JSUnfilteredForInLoop
	      if (!(prop in a)) {
	        return false;
	      }
	    }

	    return true;
	  } else {
	    return a === b;
	  }
	}
	/**
	 * A safe hasOwnProperty
	 * @param {Object} object
	 * @param {string} property
	 */

	function hasOwnProperty(object, property) {
	  return object && Object.hasOwnProperty.call(object, property);
	}
	/**
	 * Shallow version of pick, creating an object composed of the picked object properties
	 * but not for nested properties
	 * @param {Object} object
	 * @param {string[]} properties
	 * @return {Object}
	 */

	function pickShallow(object, properties) {
	  var copy = {};

	  for (var i = 0; i < properties.length; i++) {
	    var key = properties[i];
	    var value = object[key];

	    if (value !== undefined) {
	      copy[key] = value;
	    }
	  }

	  return copy;
	}

	var MATRIX_OPTIONS = ['Matrix', 'Array']; // valid values for option matrix

	var NUMBER_OPTIONS = ['number', 'BigNumber', 'Fraction']; // valid values for option number

	var config = function config(options) {
	  if (options) {
	    throw new Error('The global config is readonly. \n' + 'Please create a mathjs instance if you want to change the default configuration. \n' + 'Example:\n' + '\n' + '  import { create, all } from \'mathjs\';\n' + '  const mathjs = create(all);\n' + '  mathjs.config({ number: \'BigNumber\' });\n');
	  }

	  return Object.freeze(DEFAULT_CONFIG);
	};

	_extends(config, DEFAULT_CONFIG, {
	  MATRIX_OPTIONS,
	  NUMBER_OPTIONS
	});

	var typedFunction = createCommonjsModule(function (module, exports) {

	  (function (root, factory) {
	    {
	      // OldNode. Does not work with strict CommonJS, but
	      // only CommonJS-like environments that support module.exports,
	      // like OldNode.
	      module.exports = factory();
	    }
	  })(commonjsGlobal, function () {
	    function ok() {
	      return true;
	    }

	    function notOk() {
	      return false;
	    }

	    function undef() {
	      return undefined;
	    }
	    /**
	     * @typedef {{
	     *   params: Param[],
	     *   fn: function
	     * }} Signature
	     *
	     * @typedef {{
	     *   types: Type[],
	     *   restParam: boolean
	     * }} Param
	     *
	     * @typedef {{
	     *   name: string,
	     *   typeIndex: number,
	     *   test: function,
	     *   conversion?: ConversionDef,
	     *   conversionIndex: number,
	     * }} Type
	     *
	     * @typedef {{
	     *   from: string,
	     *   to: string,
	     *   convert: function (*) : *
	     * }} ConversionDef
	     *
	     * @typedef {{
	     *   name: string,
	     *   test: function(*) : boolean
	     * }} TypeDef
	     */
	    // create a new instance of typed-function


	    function create() {
	      // data type tests
	      var _types = [{
	        name: 'number',
	        test: function (x) {
	          return typeof x === 'number';
	        }
	      }, {
	        name: 'string',
	        test: function (x) {
	          return typeof x === 'string';
	        }
	      }, {
	        name: 'boolean',
	        test: function (x) {
	          return typeof x === 'boolean';
	        }
	      }, {
	        name: 'Function',
	        test: function (x) {
	          return typeof x === 'function';
	        }
	      }, {
	        name: 'Array',
	        test: Array.isArray
	      }, {
	        name: 'Date',
	        test: function (x) {
	          return x instanceof Date;
	        }
	      }, {
	        name: 'RegExp',
	        test: function (x) {
	          return x instanceof RegExp;
	        }
	      }, {
	        name: 'Object',
	        test: function (x) {
	          return typeof x === 'object' && x !== null && x.constructor === Object;
	        }
	      }, {
	        name: 'null',
	        test: function (x) {
	          return x === null;
	        }
	      }, {
	        name: 'undefined',
	        test: function (x) {
	          return x === undefined;
	        }
	      }];
	      var anyType = {
	        name: 'any',
	        test: ok
	      }; // types which need to be ignored

	      var _ignore = []; // type conversions

	      var _conversions = []; // This is a temporary object, will be replaced with a typed function at the end

	      var typed = {
	        types: _types,
	        conversions: _conversions,
	        ignore: _ignore
	      };
	      /**
	       * Find the test function for a type
	       * @param {String} typeName
	       * @return {TypeDef} Returns the type definition when found,
	       *                    Throws a TypeError otherwise
	       */

	      function findTypeByName(typeName) {
	        var entry = findInArray(typed.types, function (entry) {
	          return entry.name === typeName;
	        });

	        if (entry) {
	          return entry;
	        }

	        if (typeName === 'any') {
	          // special baked-in case 'any'
	          return anyType;
	        }

	        var hint = findInArray(typed.types, function (entry) {
	          return entry.name.toLowerCase() === typeName.toLowerCase();
	        });
	        throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ''));
	      }
	      /**
	       * Find the index of a type definition. Handles special case 'any'
	       * @param {TypeDef} type
	       * @return {number}
	       */


	      function findTypeIndex(type) {
	        if (type === anyType) {
	          return 999;
	        }

	        return typed.types.indexOf(type);
	      }
	      /**
	       * Find a type that matches a value.
	       * @param {*} value
	       * @return {string} Returns the name of the first type for which
	       *                  the type test matches the value.
	       */


	      function findTypeName(value) {
	        var entry = findInArray(typed.types, function (entry) {
	          return entry.test(value);
	        });

	        if (entry) {
	          return entry.name;
	        }

	        throw new TypeError('Value has unknown type. Value: ' + value);
	      }
	      /**
	       * Find a specific signature from a (composed) typed function, for example:
	       *
	       *   typed.find(fn, ['number', 'string'])
	       *   typed.find(fn, 'number, string')
	       *
	       * Function find only only works for exact matches.
	       *
	       * @param {Function} fn                   A typed-function
	       * @param {string | string[]} signature   Signature to be found, can be
	       *                                        an array or a comma separated string.
	       * @return {Function}                     Returns the matching signature, or
	       *                                        throws an error when no signature
	       *                                        is found.
	       */


	      function find(fn, signature) {
	        if (!fn.signatures) {
	          throw new TypeError('Function is no typed-function');
	        } // normalize input


	        var arr;

	        if (typeof signature === 'string') {
	          arr = signature.split(',');

	          for (var i = 0; i < arr.length; i++) {
	            arr[i] = arr[i].trim();
	          }
	        } else if (Array.isArray(signature)) {
	          arr = signature;
	        } else {
	          throw new TypeError('String array or a comma separated string expected');
	        }

	        var str = arr.join(','); // find an exact match

	        var match = fn.signatures[str];

	        if (match) {
	          return match;
	        } // TODO: extend find to match non-exact signatures


	        throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');
	      }
	      /**
	       * Convert a given value to another data type.
	       * @param {*} value
	       * @param {string} type
	       */


	      function convert(value, type) {
	        var from = findTypeName(value); // check conversion is needed

	        if (type === from) {
	          return value;
	        }

	        for (var i = 0; i < typed.conversions.length; i++) {
	          var conversion = typed.conversions[i];

	          if (conversion.from === from && conversion.to === type) {
	            return conversion.convert(value);
	          }
	        }

	        throw new Error('Cannot convert from ' + from + ' to ' + type);
	      }
	      /**
	       * Stringify parameters in a normalized way
	       * @param {Param[]} params
	       * @return {string}
	       */


	      function stringifyParams(params) {
	        return params.map(function (param) {
	          var typeNames = param.types.map(getTypeName);
	          return (param.restParam ? '...' : '') + typeNames.join('|');
	        }).join(',');
	      }
	      /**
	       * Parse a parameter, like "...number | boolean"
	       * @param {string} param
	       * @param {ConversionDef[]} conversions
	       * @return {Param} param
	       */


	      function parseParam(param, conversions) {
	        var restParam = param.indexOf('...') === 0;
	        var types = !restParam ? param : param.length > 3 ? param.slice(3) : 'any';
	        var typeNames = types.split('|').map(trim).filter(notEmpty).filter(notIgnore);
	        var matchingConversions = filterConversions(conversions, typeNames);
	        var exactTypes = typeNames.map(function (typeName) {
	          var type = findTypeByName(typeName);
	          return {
	            name: typeName,
	            typeIndex: findTypeIndex(type),
	            test: type.test,
	            conversion: null,
	            conversionIndex: -1
	          };
	        });
	        var convertibleTypes = matchingConversions.map(function (conversion) {
	          var type = findTypeByName(conversion.from);
	          return {
	            name: conversion.from,
	            typeIndex: findTypeIndex(type),
	            test: type.test,
	            conversion: conversion,
	            conversionIndex: conversions.indexOf(conversion)
	          };
	        });
	        return {
	          types: exactTypes.concat(convertibleTypes),
	          restParam: restParam
	        };
	      }
	      /**
	       * Parse a signature with comma separated parameters,
	       * like "number | boolean, ...string"
	       * @param {string} signature
	       * @param {function} fn
	       * @param {ConversionDef[]} conversions
	       * @return {Signature | null} signature
	       */


	      function parseSignature(signature, fn, conversions) {
	        var params = [];

	        if (signature.trim() !== '') {
	          params = signature.split(',').map(trim).map(function (param, index, array) {
	            var parsedParam = parseParam(param, conversions);

	            if (parsedParam.restParam && index !== array.length - 1) {
	              throw new SyntaxError('Unexpected rest parameter "' + param + '": ' + 'only allowed for the last parameter');
	            }

	            return parsedParam;
	          });
	        }

	        if (params.some(isInvalidParam)) {
	          // invalid signature: at least one parameter has no types
	          // (they may have been filtered)
	          return null;
	        }

	        return {
	          params: params,
	          fn: fn
	        };
	      }
	      /**
	       * Test whether a set of params contains a restParam
	       * @param {Param[]} params
	       * @return {boolean} Returns true when the last parameter is a restParam
	       */


	      function hasRestParam(params) {
	        var param = last(params);
	        return param ? param.restParam : false;
	      }
	      /**
	       * Test whether a parameter contains conversions
	       * @param {Param} param
	       * @return {boolean} Returns true when at least one of the parameters
	       *                   contains a conversion.
	       */


	      function hasConversions(param) {
	        return param.types.some(function (type) {
	          return type.conversion != null;
	        });
	      }
	      /**
	       * Create a type test for a single parameter, which can have one or multiple
	       * types.
	       * @param {Param} param
	       * @return {function(x: *) : boolean} Returns a test function
	       */


	      function compileTest(param) {
	        if (!param || param.types.length === 0) {
	          // nothing to do
	          return ok;
	        } else if (param.types.length === 1) {
	          return findTypeByName(param.types[0].name).test;
	        } else if (param.types.length === 2) {
	          var test0 = findTypeByName(param.types[0].name).test;
	          var test1 = findTypeByName(param.types[1].name).test;
	          return function or(x) {
	            return test0(x) || test1(x);
	          };
	        } else {
	          // param.types.length > 2
	          var tests = param.types.map(function (type) {
	            return findTypeByName(type.name).test;
	          });
	          return function or(x) {
	            for (var i = 0; i < tests.length; i++) {
	              if (tests[i](x)) {
	                return true;
	              }
	            }

	            return false;
	          };
	        }
	      }
	      /**
	       * Create a test for all parameters of a signature
	       * @param {Param[]} params
	       * @return {function(args: Array<*>) : boolean}
	       */


	      function compileTests(params) {
	        var tests, test0, test1;

	        if (hasRestParam(params)) {
	          // variable arguments like '...number'
	          tests = initial(params).map(compileTest);
	          var varIndex = tests.length;
	          var lastTest = compileTest(last(params));

	          var testRestParam = function (args) {
	            for (var i = varIndex; i < args.length; i++) {
	              if (!lastTest(args[i])) {
	                return false;
	              }
	            }

	            return true;
	          };

	          return function testArgs(args) {
	            for (var i = 0; i < tests.length; i++) {
	              if (!tests[i](args[i])) {
	                return false;
	              }
	            }

	            return testRestParam(args) && args.length >= varIndex + 1;
	          };
	        } else {
	          // no variable arguments
	          if (params.length === 0) {
	            return function testArgs(args) {
	              return args.length === 0;
	            };
	          } else if (params.length === 1) {
	            test0 = compileTest(params[0]);
	            return function testArgs(args) {
	              return test0(args[0]) && args.length === 1;
	            };
	          } else if (params.length === 2) {
	            test0 = compileTest(params[0]);
	            test1 = compileTest(params[1]);
	            return function testArgs(args) {
	              return test0(args[0]) && test1(args[1]) && args.length === 2;
	            };
	          } else {
	            // arguments.length > 2
	            tests = params.map(compileTest);
	            return function testArgs(args) {
	              for (var i = 0; i < tests.length; i++) {
	                if (!tests[i](args[i])) {
	                  return false;
	                }
	              }

	              return args.length === tests.length;
	            };
	          }
	        }
	      }
	      /**
	       * Find the parameter at a specific index of a signature.
	       * Handles rest parameters.
	       * @param {Signature} signature
	       * @param {number} index
	       * @return {Param | null} Returns the matching parameter when found,
	       *                        null otherwise.
	       */


	      function getParamAtIndex(signature, index) {
	        return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
	      }
	      /**
	       * Get all type names of a parameter
	       * @param {Signature} signature
	       * @param {number} index
	       * @param {boolean} excludeConversions
	       * @return {string[]} Returns an array with type names
	       */


	      function getExpectedTypeNames(signature, index, excludeConversions) {
	        var param = getParamAtIndex(signature, index);
	        var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
	        return types.map(getTypeName);
	      }
	      /**
	       * Returns the name of a type
	       * @param {Type} type
	       * @return {string} Returns the type name
	       */


	      function getTypeName(type) {
	        return type.name;
	      }
	      /**
	       * Test whether a type is an exact type or conversion
	       * @param {Type} type
	       * @return {boolean} Returns true when
	       */


	      function isExactType(type) {
	        return type.conversion === null || type.conversion === undefined;
	      }
	      /**
	       * Helper function for creating error messages: create an array with
	       * all available types on a specific argument index.
	       * @param {Signature[]} signatures
	       * @param {number} index
	       * @return {string[]} Returns an array with available types
	       */


	      function mergeExpectedParams(signatures, index) {
	        var typeNames = uniq(flatMap(signatures, function (signature) {
	          return getExpectedTypeNames(signature, index, false);
	        }));
	        return typeNames.indexOf('any') !== -1 ? ['any'] : typeNames;
	      }
	      /**
	       * Create
	       * @param {string} name             The name of the function
	       * @param {array.<*>} args          The actual arguments passed to the function
	       * @param {Signature[]} signatures  A list with available signatures
	       * @return {TypeError} Returns a type error with additional data
	       *                     attached to it in the property `data`
	       */


	      function createError(name, args, signatures) {
	        var err, expected;

	        var _name = name || 'unnamed'; // test for wrong type at some index


	        var matchingSignatures = signatures;
	        var index;

	        for (index = 0; index < args.length; index++) {
	          var nextMatchingDefs = matchingSignatures.filter(function (signature) {
	            var test = compileTest(getParamAtIndex(signature, index));
	            return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
	          });

	          if (nextMatchingDefs.length === 0) {
	            // no matching signatures anymore, throw error "wrong type"
	            expected = mergeExpectedParams(matchingSignatures, index);

	            if (expected.length > 0) {
	              var actualType = findTypeName(args[index]);
	              err = new TypeError('Unexpected type of argument in function ' + _name + ' (expected: ' + expected.join(' or ') + ', actual: ' + actualType + ', index: ' + index + ')');
	              err.data = {
	                category: 'wrongType',
	                fn: _name,
	                index: index,
	                actual: actualType,
	                expected: expected
	              };
	              return err;
	            }
	          } else {
	            matchingSignatures = nextMatchingDefs;
	          }
	        } // test for too few arguments


	        var lengths = matchingSignatures.map(function (signature) {
	          return hasRestParam(signature.params) ? Infinity : signature.params.length;
	        });

	        if (args.length < Math.min.apply(null, lengths)) {
	          expected = mergeExpectedParams(matchingSignatures, index);
	          err = new TypeError('Too few arguments in function ' + _name + ' (expected: ' + expected.join(' or ') + ', index: ' + args.length + ')');
	          err.data = {
	            category: 'tooFewArgs',
	            fn: _name,
	            index: args.length,
	            expected: expected
	          };
	          return err;
	        } // test for too many arguments


	        var maxLength = Math.max.apply(null, lengths);

	        if (args.length > maxLength) {
	          err = new TypeError('Too many arguments in function ' + _name + ' (expected: ' + maxLength + ', actual: ' + args.length + ')');
	          err.data = {
	            category: 'tooManyArgs',
	            fn: _name,
	            index: args.length,
	            expectedLength: maxLength
	          };
	          return err;
	        }

	        err = new TypeError('Arguments of type "' + args.join(', ') + '" do not match any of the defined signatures of function ' + _name + '.');
	        err.data = {
	          category: 'mismatch',
	          actual: args.map(findTypeName)
	        };
	        return err;
	      }
	      /**
	       * Find the lowest index of all exact types of a parameter (no conversions)
	       * @param {Param} param
	       * @return {number} Returns the index of the lowest type in typed.types
	       */


	      function getLowestTypeIndex(param) {
	        var min = 999;

	        for (var i = 0; i < param.types.length; i++) {
	          if (isExactType(param.types[i])) {
	            min = Math.min(min, param.types[i].typeIndex);
	          }
	        }

	        return min;
	      }
	      /**
	       * Find the lowest index of the conversion of all types of the parameter
	       * having a conversion
	       * @param {Param} param
	       * @return {number} Returns the lowest index of the conversions of this type
	       */


	      function getLowestConversionIndex(param) {
	        var min = 999;

	        for (var i = 0; i < param.types.length; i++) {
	          if (!isExactType(param.types[i])) {
	            min = Math.min(min, param.types[i].conversionIndex);
	          }
	        }

	        return min;
	      }
	      /**
	       * Compare two params
	       * @param {Param} param1
	       * @param {Param} param2
	       * @return {number} returns a negative number when param1 must get a lower
	       *                  index than param2, a positive number when the opposite,
	       *                  or zero when both are equal
	       */


	      function compareParams(param1, param2) {
	        var c; // compare having a rest parameter or not

	        c = param1.restParam - param2.restParam;

	        if (c !== 0) {
	          return c;
	        } // compare having conversions or not


	        c = hasConversions(param1) - hasConversions(param2);

	        if (c !== 0) {
	          return c;
	        } // compare the index of the types


	        c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);

	        if (c !== 0) {
	          return c;
	        } // compare the index of any conversion


	        return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
	      }
	      /**
	       * Compare two signatures
	       * @param {Signature} signature1
	       * @param {Signature} signature2
	       * @return {number} returns a negative number when param1 must get a lower
	       *                  index than param2, a positive number when the opposite,
	       *                  or zero when both are equal
	       */


	      function compareSignatures(signature1, signature2) {
	        var len = Math.min(signature1.params.length, signature2.params.length);
	        var i;
	        var c; // compare whether the params have conversions at all or not

	        c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);

	        if (c !== 0) {
	          return c;
	        } // next compare whether the params have conversions one by one


	        for (i = 0; i < len; i++) {
	          c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);

	          if (c !== 0) {
	            return c;
	          }
	        } // compare the types of the params one by one


	        for (i = 0; i < len; i++) {
	          c = compareParams(signature1.params[i], signature2.params[i]);

	          if (c !== 0) {
	            return c;
	          }
	        } // compare the number of params


	        return signature1.params.length - signature2.params.length;
	      }
	      /**
	       * Get params containing all types that can be converted to the defined types.
	       *
	       * @param {ConversionDef[]} conversions
	       * @param {string[]} typeNames
	       * @return {ConversionDef[]} Returns the conversions that are available
	       *                        for every type (if any)
	       */


	      function filterConversions(conversions, typeNames) {
	        var matches = {};
	        conversions.forEach(function (conversion) {
	          if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
	            matches[conversion.from] = conversion;
	          }
	        });
	        return Object.keys(matches).map(function (from) {
	          return matches[from];
	        });
	      }
	      /**
	       * Preprocess arguments before calling the original function:
	       * - if needed convert the parameters
	       * - in case of rest parameters, move the rest parameters into an Array
	       * @param {Param[]} params
	       * @param {function} fn
	       * @return {function} Returns a wrapped function
	       */


	      function compileArgsPreprocessing(params, fn) {
	        var fnConvert = fn; // TODO: can we make this wrapper function smarter/simpler?

	        if (params.some(hasConversions)) {
	          var restParam = hasRestParam(params);
	          var compiledConversions = params.map(compileArgConversion);

	          fnConvert = function convertArgs() {
	            var args = [];
	            var last = restParam ? arguments.length - 1 : arguments.length;

	            for (var i = 0; i < last; i++) {
	              args[i] = compiledConversions[i](arguments[i]);
	            }

	            if (restParam) {
	              args[last] = arguments[last].map(compiledConversions[last]);
	            }

	            return fn.apply(this, args);
	          };
	        }

	        var fnPreprocess = fnConvert;

	        if (hasRestParam(params)) {
	          var offset = params.length - 1;

	          fnPreprocess = function preprocessRestParams() {
	            return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
	          };
	        }

	        return fnPreprocess;
	      }
	      /**
	       * Compile conversion for a parameter to the right type
	       * @param {Param} param
	       * @return {function} Returns the wrapped function that will convert arguments
	       *
	       */


	      function compileArgConversion(param) {
	        var test0, test1, conversion0, conversion1;
	        var tests = [];
	        var conversions = [];
	        param.types.forEach(function (type) {
	          if (type.conversion) {
	            tests.push(findTypeByName(type.conversion.from).test);
	            conversions.push(type.conversion.convert);
	          }
	        }); // create optimized conversion functions depending on the number of conversions

	        switch (conversions.length) {
	          case 0:
	            return function convertArg(arg) {
	              return arg;
	            };

	          case 1:
	            test0 = tests[0];
	            conversion0 = conversions[0];
	            return function convertArg(arg) {
	              if (test0(arg)) {
	                return conversion0(arg);
	              }

	              return arg;
	            };

	          case 2:
	            test0 = tests[0];
	            test1 = tests[1];
	            conversion0 = conversions[0];
	            conversion1 = conversions[1];
	            return function convertArg(arg) {
	              if (test0(arg)) {
	                return conversion0(arg);
	              }

	              if (test1(arg)) {
	                return conversion1(arg);
	              }

	              return arg;
	            };

	          default:
	            return function convertArg(arg) {
	              for (var i = 0; i < conversions.length; i++) {
	                if (tests[i](arg)) {
	                  return conversions[i](arg);
	                }
	              }

	              return arg;
	            };
	        }
	      }
	      /**
	       * Convert an array with signatures into a map with signatures,
	       * where signatures with union types are split into separate signatures
	       *
	       * Throws an error when there are conflicting types
	       *
	       * @param {Signature[]} signatures
	       * @return {Object.<string, function>}  Returns a map with signatures
	       *                                      as key and the original function
	       *                                      of this signature as value.
	       */


	      function createSignaturesMap(signatures) {
	        var signaturesMap = {};
	        signatures.forEach(function (signature) {
	          if (!signature.params.some(hasConversions)) {
	            splitParams(signature.params, true).forEach(function (params) {
	              signaturesMap[stringifyParams(params)] = signature.fn;
	            });
	          }
	        });
	        return signaturesMap;
	      }
	      /**
	       * Split params with union types in to separate params.
	       *
	       * For example:
	       *
	       *     splitParams([['Array', 'Object'], ['string', 'RegExp'])
	       *     // returns:
	       *     // [
	       *     //   ['Array', 'string'],
	       *     //   ['Array', 'RegExp'],
	       *     //   ['Object', 'string'],
	       *     //   ['Object', 'RegExp']
	       *     // ]
	       *
	       * @param {Param[]} params
	       * @param {boolean} ignoreConversionTypes
	       * @return {Param[]}
	       */


	      function splitParams(params, ignoreConversionTypes) {
	        function _splitParams(params, index, types) {
	          if (index < params.length) {
	            var param = params[index];
	            var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
	            var typeGroups;

	            if (param.restParam) {
	              // split the types of a rest parameter in two:
	              // one with only exact types, and one with exact types and conversions
	              var exactTypes = filteredTypes.filter(isExactType);
	              typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
	            } else {
	              // split all the types of a regular parameter into one type per group
	              typeGroups = filteredTypes.map(function (type) {
	                return [type];
	              });
	            } // recurse over the groups with types


	            return flatMap(typeGroups, function (typeGroup) {
	              return _splitParams(params, index + 1, types.concat([typeGroup]));
	            });
	          } else {
	            // we've reached the end of the parameters. Now build a new Param
	            var splittedParams = types.map(function (type, typeIndex) {
	              return {
	                types: type,
	                restParam: typeIndex === params.length - 1 && hasRestParam(params)
	              };
	            });
	            return [splittedParams];
	          }
	        }

	        return _splitParams(params, 0, []);
	      }
	      /**
	       * Test whether two signatures have a conflicting signature
	       * @param {Signature} signature1
	       * @param {Signature} signature2
	       * @return {boolean} Returns true when the signatures conflict, false otherwise.
	       */


	      function hasConflictingParams(signature1, signature2) {
	        var ii = Math.max(signature1.params.length, signature2.params.length);

	        for (var i = 0; i < ii; i++) {
	          var typesNames1 = getExpectedTypeNames(signature1, i, true);
	          var typesNames2 = getExpectedTypeNames(signature2, i, true);

	          if (!hasOverlap(typesNames1, typesNames2)) {
	            return false;
	          }
	        }

	        var len1 = signature1.params.length;
	        var len2 = signature2.params.length;
	        var restParam1 = hasRestParam(signature1.params);
	        var restParam2 = hasRestParam(signature2.params);
	        return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
	      }
	      /**
	       * Create a typed function
	       * @param {String} name               The name for the typed function
	       * @param {Object.<string, function>} signaturesMap
	       *                                    An object with one or
	       *                                    multiple signatures as key, and the
	       *                                    function corresponding to the
	       *                                    signature as value.
	       * @return {function}  Returns the created typed function.
	       */


	      function createTypedFunction(name, signaturesMap) {
	        if (Object.keys(signaturesMap).length === 0) {
	          throw new SyntaxError('No signatures provided');
	        } // parse the signatures, and check for conflicts


	        var parsedSignatures = [];
	        Object.keys(signaturesMap).map(function (signature) {
	          return parseSignature(signature, signaturesMap[signature], typed.conversions);
	        }).filter(notNull).forEach(function (parsedSignature) {
	          // check whether this parameter conflicts with already parsed signatures
	          var conflictingSignature = findInArray(parsedSignatures, function (s) {
	            return hasConflictingParams(s, parsedSignature);
	          });

	          if (conflictingSignature) {
	            throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
	          }

	          parsedSignatures.push(parsedSignature);
	        }); // split and filter the types of the signatures, and then order them

	        var signatures = flatMap(parsedSignatures, function (parsedSignature) {
	          var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
	          return params.map(function (params) {
	            return {
	              params: params,
	              fn: parsedSignature.fn
	            };
	          });
	        }).filter(notNull);
	        signatures.sort(compareSignatures); // we create a highly optimized checks for the first couple of signatures with max 2 arguments

	        var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
	        var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
	        var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
	        var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
	        var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
	        var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
	        var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5; // compile the tests

	        var tests = signatures.map(function (signature) {
	          return compileTests(signature.params);
	        });
	        var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
	        var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
	        var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
	        var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
	        var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
	        var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
	        var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
	        var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
	        var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
	        var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
	        var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
	        var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk; // compile the functions

	        var fns = signatures.map(function (signature) {
	          return compileArgsPreprocessing(signature.params, signature.fn);
	        });
	        var fn0 = ok0 ? fns[0] : undef;
	        var fn1 = ok1 ? fns[1] : undef;
	        var fn2 = ok2 ? fns[2] : undef;
	        var fn3 = ok3 ? fns[3] : undef;
	        var fn4 = ok4 ? fns[4] : undef;
	        var fn5 = ok5 ? fns[5] : undef;
	        var len0 = ok0 ? signatures[0].params.length : -1;
	        var len1 = ok1 ? signatures[1].params.length : -1;
	        var len2 = ok2 ? signatures[2].params.length : -1;
	        var len3 = ok3 ? signatures[3].params.length : -1;
	        var len4 = ok4 ? signatures[4].params.length : -1;
	        var len5 = ok5 ? signatures[5].params.length : -1; // simple and generic, but also slow

	        var iStart = allOk ? 6 : 0;
	        var iEnd = signatures.length;

	        var generic = function generic() {

	          for (var i = iStart; i < iEnd; i++) {
	            if (tests[i](arguments)) {
	              return fns[i].apply(this, arguments);
	            }
	          }

	          return typed.onMismatch(name, arguments, signatures);
	        }; // create the typed function
	        // fast, specialized version. Falls back to the slower, generic one if needed


	        var fn = function fn(arg0, arg1) {

	          if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
	            return fn0.apply(fn, arguments);
	          }

	          if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
	            return fn1.apply(fn, arguments);
	          }

	          if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
	            return fn2.apply(fn, arguments);
	          }

	          if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
	            return fn3.apply(fn, arguments);
	          }

	          if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
	            return fn4.apply(fn, arguments);
	          }

	          if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
	            return fn5.apply(fn, arguments);
	          }

	          return generic.apply(fn, arguments);
	        }; // attach name the typed function


	        try {
	          Object.defineProperty(fn, 'name', {
	            value: name
	          });
	        } catch (err) {// old browsers do not support Object.defineProperty and some don't support setting the name property
	          // the function name is not essential for the functioning, it's mostly useful for debugging,
	          // so it's fine to have unnamed functions.
	        } // attach signatures to the function


	        fn.signatures = createSignaturesMap(signatures);
	        return fn;
	      }
	      /**
	       * Action to take on mismatch
	       * @param {string} name      Name of function that was attempted to be called
	       * @param {Array} args       Actual arguments to the call
	       * @param {Array} signatures Known signatures of the named typed-function
	       */


	      function _onMismatch(name, args, signatures) {
	        throw createError(name, args, signatures);
	      }
	      /**
	       * Test whether a type should be NOT be ignored
	       * @param {string} typeName
	       * @return {boolean}
	       */


	      function notIgnore(typeName) {
	        return typed.ignore.indexOf(typeName) === -1;
	      }
	      /**
	       * trim a string
	       * @param {string} str
	       * @return {string}
	       */


	      function trim(str) {
	        return str.trim();
	      }
	      /**
	       * Test whether a string is not empty
	       * @param {string} str
	       * @return {boolean}
	       */


	      function notEmpty(str) {
	        return !!str;
	      }
	      /**
	       * test whether a value is not strict equal to null
	       * @param {*} value
	       * @return {boolean}
	       */


	      function notNull(value) {
	        return value !== null;
	      }
	      /**
	       * Test whether a parameter has no types defined
	       * @param {Param} param
	       * @return {boolean}
	       */


	      function isInvalidParam(param) {
	        return param.types.length === 0;
	      }
	      /**
	       * Return all but the last items of an array
	       * @param {Array} arr
	       * @return {Array}
	       */


	      function initial(arr) {
	        return arr.slice(0, arr.length - 1);
	      }
	      /**
	       * return the last item of an array
	       * @param {Array} arr
	       * @return {*}
	       */


	      function last(arr) {
	        return arr[arr.length - 1];
	      }
	      /**
	       * Slice an array or function Arguments
	       * @param {Array | Arguments | IArguments} arr
	       * @param {number} start
	       * @param {number} [end]
	       * @return {Array}
	       */


	      function slice(arr, start, end) {
	        return Array.prototype.slice.call(arr, start, end);
	      }
	      /**
	       * Test whether an array contains some item
	       * @param {Array} array
	       * @param {*} item
	       * @return {boolean} Returns true if array contains item, false if not.
	       */


	      function contains(array, item) {
	        return array.indexOf(item) !== -1;
	      }
	      /**
	       * Test whether two arrays have overlapping items
	       * @param {Array} array1
	       * @param {Array} array2
	       * @return {boolean} Returns true when at least one item exists in both arrays
	       */


	      function hasOverlap(array1, array2) {
	        for (var i = 0; i < array1.length; i++) {
	          if (contains(array2, array1[i])) {
	            return true;
	          }
	        }

	        return false;
	      }
	      /**
	       * Return the first item from an array for which test(arr[i]) returns true
	       * @param {Array} arr
	       * @param {function} test
	       * @return {* | undefined} Returns the first matching item
	       *                         or undefined when there is no match
	       */


	      function findInArray(arr, test) {
	        for (var i = 0; i < arr.length; i++) {
	          if (test(arr[i])) {
	            return arr[i];
	          }
	        }

	        return undefined;
	      }
	      /**
	       * Filter unique items of an array with strings
	       * @param {string[]} arr
	       * @return {string[]}
	       */


	      function uniq(arr) {
	        var entries = {};

	        for (var i = 0; i < arr.length; i++) {
	          entries[arr[i]] = true;
	        }

	        return Object.keys(entries);
	      }
	      /**
	       * Flat map the result invoking a callback for every item in an array.
	       * https://gist.github.com/samgiles/762ee337dff48623e729
	       * @param {Array} arr
	       * @param {function} callback
	       * @return {Array}
	       */


	      function flatMap(arr, callback) {
	        return Array.prototype.concat.apply([], arr.map(callback));
	      }
	      /**
	       * Retrieve the function name from a set of typed functions,
	       * and check whether the name of all functions match (if given)
	       * @param {function[]} fns
	       */


	      function getName(fns) {
	        var name = '';

	        for (var i = 0; i < fns.length; i++) {
	          var fn = fns[i]; // check whether the names are the same when defined

	          if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {
	            if (name === '') {
	              name = fn.name;
	            } else if (name !== fn.name) {
	              var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');
	              err.data = {
	                actual: fn.name,
	                expected: name
	              };
	              throw err;
	            }
	          }
	        }

	        return name;
	      } // extract and merge all signatures of a list with typed functions


	      function extractSignatures(fns) {
	        var err;
	        var signaturesMap = {};

	        function validateUnique(_signature, _fn) {
	          if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
	            err = new Error('Signature "' + _signature + '" is defined twice');
	            err.data = {
	              signature: _signature
	            };
	            throw err; // else: both signatures point to the same function, that's fine
	          }
	        }

	        for (var i = 0; i < fns.length; i++) {
	          var fn = fns[i]; // test whether this is a typed-function

	          if (typeof fn.signatures === 'object') {
	            // merge the signatures
	            for (var signature in fn.signatures) {
	              if (fn.signatures.hasOwnProperty(signature)) {
	                validateUnique(signature, fn.signatures[signature]);
	                signaturesMap[signature] = fn.signatures[signature];
	              }
	            }
	          } else if (typeof fn.signature === 'string') {
	            validateUnique(fn.signature, fn);
	            signaturesMap[fn.signature] = fn;
	          } else {
	            err = new TypeError('Function is no typed-function (index: ' + i + ')');
	            err.data = {
	              index: i
	            };
	            throw err;
	          }
	        }

	        return signaturesMap;
	      }

	      typed = createTypedFunction('typed', {
	        'string, Object': createTypedFunction,
	        'Object': function (signaturesMap) {
	          // find existing name
	          var fns = [];

	          for (var signature in signaturesMap) {
	            if (signaturesMap.hasOwnProperty(signature)) {
	              fns.push(signaturesMap[signature]);
	            }
	          }

	          var name = getName(fns);
	          return createTypedFunction(name, signaturesMap);
	        },
	        '...Function': function (fns) {
	          return createTypedFunction(getName(fns), extractSignatures(fns));
	        },
	        'string, ...Function': function (name, fns) {
	          return createTypedFunction(name, extractSignatures(fns));
	        }
	      });
	      typed.create = create;
	      typed.types = _types;
	      typed.conversions = _conversions;
	      typed.ignore = _ignore;
	      typed.onMismatch = _onMismatch;
	      typed.throwMismatchError = _onMismatch;
	      typed.createError = createError;
	      typed.convert = convert;
	      typed.find = find;
	      /**
	       * add a type
	       * @param {{name: string, test: function}} type
	       * @param {boolean} [beforeObjectTest=true]
	       *                          If true, the new test will be inserted before
	       *                          the test with name 'Object' (if any), since
	       *                          tests for Object match Array and classes too.
	       */

	      typed.addType = function (type, beforeObjectTest) {
	        if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {
	          throw new TypeError('Object with properties {name: string, test: function} expected');
	        }

	        if (beforeObjectTest !== false) {
	          for (var i = 0; i < typed.types.length; i++) {
	            if (typed.types[i].name === 'Object') {
	              typed.types.splice(i, 0, type);
	              return;
	            }
	          }
	        }

	        typed.types.push(type);
	      }; // add a conversion


	      typed.addConversion = function (conversion) {
	        if (!conversion || typeof conversion.from !== 'string' || typeof conversion.to !== 'string' || typeof conversion.convert !== 'function') {
	          throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');
	        }

	        typed.conversions.push(conversion);
	      };

	      return typed;
	    }

	    return create();
	  });
	});

	/**
	 * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue
	 */

	/**
	 * Check if a number is integer
	 * @param {number | boolean} value
	 * @return {boolean} isInteger
	 */

	function isInteger(value) {
	  if (typeof value === 'boolean') {
	    return true;
	  }

	  return isFinite(value) ? value === Math.round(value) : false;
	}
	/**
	 * Calculate the sign of a number
	 * @param {number} x
	 * @returns {number}
	 */

	var sign$1 = Math.sign || function (x) {
	  if (x > 0) {
	    return 1;
	  } else if (x < 0) {
	    return -1;
	  } else {
	    return 0;
	  }
	};
	/**
	 * Formats a number in a given base
	 * @param {number} n
	 * @param {number} base
	 * @param {number} size
	 * @returns {string}
	 */

	function formatNumberToBase(n, base, size) {
	  var prefixes = {
	    2: '0b',
	    8: '0o',
	    16: '0x'
	  };
	  var prefix = prefixes[base];
	  var suffix = '';

	  if (size) {
	    if (size < 1) {
	      throw new Error('size must be in greater than 0');
	    }

	    if (!isInteger(size)) {
	      throw new Error('size must be an integer');
	    }

	    if (n > 2 ** (size - 1) - 1 || n < -(2 ** (size - 1))) {
	      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
	    }

	    if (!isInteger(n)) {
	      throw new Error('Value must be an integer');
	    }

	    if (n < 0) {
	      n = n + 2 ** size;
	    }

	    suffix = "i".concat(size);
	  }

	  var sign = '';

	  if (n < 0) {
	    n = -n;
	    sign = '-';
	  }

	  return "".concat(sign).concat(prefix).concat(n.toString(base)).concat(suffix);
	}
	/**
	 * Convert a number to a formatted string representation.
	 *
	 * Syntax:
	 *
	 *    format(value)
	 *    format(value, options)
	 *    format(value, precision)
	 *    format(value, fn)
	 *
	 * Where:
	 *
	 *    {number} value   The value to be formatted
	 *    {Object} options An object with formatting options. Available options:
	 *                     {string} notation
	 *                         Number notation. Choose from:
	 *                         'fixed'          Always use regular number notation.
	 *                                          For example '123.40' and '14000000'
	 *                         'exponential'    Always use exponential notation.
	 *                                          For example '1.234e+2' and '1.4e+7'
	 *                         'engineering'    Always use engineering notation.
	 *                                          For example '123.4e+0' and '14.0e+6'
	 *                         'auto' (default) Regular number notation for numbers
	 *                                          having an absolute value between
	 *                                          `lowerExp` and `upperExp` bounds, and
	 *                                          uses exponential notation elsewhere.
	 *                                          Lower bound is included, upper bound
	 *                                          is excluded.
	 *                                          For example '123.4' and '1.4e7'.
	 *                         'bin', 'oct, or
	 *                         'hex'            Format the number using binary, octal,
	 *                                          or hexadecimal notation.
	 *                                          For example '0b1101' and '0x10fe'.
	 *                     {number} wordSize    The word size in bits to use for formatting
	 *                                          in binary, octal, or hexadecimal notation.
	 *                                          To be used only with 'bin', 'oct', or 'hex'
	 *                                          values for 'notation' option. When this option
	 *                                          is defined the value is formatted as a signed
	 *                                          twos complement integer of the given word size
	 *                                          and the size suffix is appended to the output.
	 *                                          For example
	 *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
	 *                                          Default value is undefined.
	 *                     {number} precision   A number between 0 and 16 to round
	 *                                          the digits of the number.
	 *                                          In case of notations 'exponential',
	 *                                          'engineering', and 'auto',
	 *                                          `precision` defines the total
	 *                                          number of significant digits returned.
	 *                                          In case of notation 'fixed',
	 *                                          `precision` defines the number of
	 *                                          significant digits after the decimal
	 *                                          point.
	 *                                          `precision` is undefined by default,
	 *                                          not rounding any digits.
	 *                     {number} lowerExp    Exponent determining the lower boundary
	 *                                          for formatting a value with an exponent
	 *                                          when `notation='auto`.
	 *                                          Default value is `-3`.
	 *                     {number} upperExp    Exponent determining the upper boundary
	 *                                          for formatting a value with an exponent
	 *                                          when `notation='auto`.
	 *                                          Default value is `5`.
	 *    {Function} fn    A custom formatting function. Can be used to override the
	 *                     built-in notations. Function `fn` is called with `value` as
	 *                     parameter and must return a string. Is useful for example to
	 *                     format all values inside a matrix in a particular way.
	 *
	 * Examples:
	 *
	 *    format(6.4)                                        // '6.4'
	 *    format(1240000)                                    // '1.24e6'
	 *    format(1/3)                                        // '0.3333333333333333'
	 *    format(1/3, 3)                                     // '0.333'
	 *    format(21385, 2)                                   // '21000'
	 *    format(12.071, {notation: 'fixed'})                // '12'
	 *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'
	 *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'
	 *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'
	 *
	 * @param {number} value
	 * @param {Object | Function | number} [options]
	 * @return {string} str The formatted value
	 */


	function format$2(value, options) {
	  if (typeof options === 'function') {
	    // handle format(value, fn)
	    return options(value);
	  } // handle special cases


	  if (value === Infinity) {
	    return 'Infinity';
	  } else if (value === -Infinity) {
	    return '-Infinity';
	  } else if (isNaN(value)) {
	    return 'NaN';
	  } // default values for options


	  var notation = 'auto';
	  var precision;
	  var wordSize;

	  if (options) {
	    // determine notation from options
	    if (options.notation) {
	      notation = options.notation;
	    } // determine precision from options


	    if (isNumber(options)) {
	      precision = options;
	    } else if (isNumber(options.precision)) {
	      precision = options.precision;
	    }

	    if (options.wordSize) {
	      wordSize = options.wordSize;

	      if (typeof wordSize !== 'number') {
	        throw new Error('Option "wordSize" must be a number');
	      }
	    }
	  } // handle the various notations


	  switch (notation) {
	    case 'fixed':
	      return toFixed$1(value, precision);

	    case 'exponential':
	      return toExponential$1(value, precision);

	    case 'engineering':
	      return toEngineering$1(value, precision);

	    case 'bin':
	      return formatNumberToBase(value, 2, wordSize);

	    case 'oct':
	      return formatNumberToBase(value, 8, wordSize);

	    case 'hex':
	      return formatNumberToBase(value, 16, wordSize);

	    case 'auto':
	      // remove trailing zeros after the decimal point
	      return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function () {
	        var digits = arguments[2];
	        var e = arguments[4];
	        return digits !== '.' ? digits + e : e;
	      });

	    default:
	      throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
	  }
	}
	/**
	 * Split a number into sign, coefficients, and exponent
	 * @param {number | string} value
	 * @return {SplitValue}
	 *              Returns an object containing sign, coefficients, and exponent
	 */

	function splitNumber(value) {
	  // parse the input value
	  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);

	  if (!match) {
	    throw new SyntaxError('Invalid number ' + value);
	  }

	  var sign = match[1];
	  var digits = match[2];
	  var exponent = parseFloat(match[4] || '0');
	  var dot = digits.indexOf('.');
	  exponent += dot !== -1 ? dot - 1 : digits.length - 1;
	  var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)
	  .replace(/^0*/, function (zeros) {
	    // remove leading zeros, add their count to the exponent
	    exponent -= zeros.length;
	    return '';
	  }).replace(/0*$/, '') // remove trailing zeros
	  .split('').map(function (d) {
	    return parseInt(d);
	  });

	  if (coefficients.length === 0) {
	    coefficients.push(0);
	    exponent++;
	  }

	  return {
	    sign: sign,
	    coefficients: coefficients,
	    exponent: exponent
	  };
	}
	/**
	 * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
	 * @param {number | string} value
	 * @param {number} [precision]        Optional number of significant figures to return.
	 */

	function toEngineering$1(value, precision) {
	  if (isNaN(value) || !isFinite(value)) {
	    return String(value);
	  }

	  var split = splitNumber(value);
	  var rounded = roundDigits(split, precision);
	  var e = rounded.exponent;
	  var c = rounded.coefficients; // find nearest lower multiple of 3 for exponent

	  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;

	  if (isNumber(precision)) {
	    // add zeroes to give correct sig figs
	    while (precision > c.length || e - newExp + 1 > c.length) {
	      c.push(0);
	    }
	  } else {
	    // concatenate coefficients with necessary zeros
	    // add zeros if necessary (for example: 1e+8 -> 100e+6)
	    var missingZeros = Math.abs(e - newExp) - (c.length - 1);

	    for (var i = 0; i < missingZeros; i++) {
	      c.push(0);
	    }
	  } // find difference in exponents


	  var expDiff = Math.abs(e - newExp);
	  var decimalIdx = 1; // push decimal index over by expDiff times

	  while (expDiff > 0) {
	    decimalIdx++;
	    expDiff--;
	  } // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.
	  // otherwise concat with the rest of the coefficients


	  var decimals = c.slice(decimalIdx).join('');
	  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';
	  var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
	  return rounded.sign + str;
	}
	/**
	 * Format a number with fixed notation.
	 * @param {number | string} value
	 * @param {number} [precision=undefined]  Optional number of decimals after the
	 *                                        decimal point. null by default.
	 */

	function toFixed$1(value, precision) {
	  if (isNaN(value) || !isFinite(value)) {
	    return String(value);
	  }

	  var splitValue = splitNumber(value);
	  var rounded = typeof precision === 'number' ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
	  var c = rounded.coefficients;
	  var p = rounded.exponent + 1; // exponent may have changed
	  // append zeros if needed

	  var pp = p + (precision || 0);

	  if (c.length < pp) {
	    c = c.concat(zeros$1(pp - c.length));
	  } // prepend zeros if needed


	  if (p < 0) {
	    c = zeros$1(-p + 1).concat(c);
	    p = 1;
	  } // insert a dot if needed


	  if (p < c.length) {
	    c.splice(p, 0, p === 0 ? '0.' : '.');
	  }

	  return rounded.sign + c.join('');
	}
	/**
	 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
	 * @param {number | string} value
	 * @param {number} [precision]  Number of digits in formatted output.
	 *                              If not provided, the maximum available digits
	 *                              is used.
	 */

	function toExponential$1(value, precision) {
	  if (isNaN(value) || !isFinite(value)) {
	    return String(value);
	  } // round if needed, else create a clone


	  var split = splitNumber(value);
	  var rounded = precision ? roundDigits(split, precision) : split;
	  var c = rounded.coefficients;
	  var e = rounded.exponent; // append zeros if needed

	  if (c.length < precision) {
	    c = c.concat(zeros$1(precision - c.length));
	  } // format as `C.CCCe+EEE` or `C.CCCe-EEE`


	  var first = c.shift();
	  return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;
	}
	/**
	 * Format a number with a certain precision
	 * @param {number | string} value
	 * @param {number} [precision=undefined] Optional number of digits.
	 * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]
	 *                                       By default:
	 *                                         lowerExp = -3 (incl)
	 *                                         upper = +5 (excl)
	 * @return {string}
	 */

	function toPrecision(value, precision, options) {
	  if (isNaN(value) || !isFinite(value)) {
	    return String(value);
	  } // determine lower and upper bound for exponential notation.


	  var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
	  var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;
	  var split = splitNumber(value);
	  var rounded = precision ? roundDigits(split, precision) : split;

	  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
	    // exponential notation
	    return toExponential$1(value, precision);
	  } else {
	    var c = rounded.coefficients;
	    var e = rounded.exponent; // append trailing zeros

	    if (c.length < precision) {
	      c = c.concat(zeros$1(precision - c.length));
	    } // append trailing zeros
	    // TODO: simplify the next statement


	    c = c.concat(zeros$1(e - c.length + 1 + (c.length < precision ? precision - c.length : 0))); // prepend zeros

	    c = zeros$1(-e).concat(c);
	    var dot = e > 0 ? e : 0;

	    if (dot < c.length - 1) {
	      c.splice(dot + 1, 0, '.');
	    }

	    return rounded.sign + c.join('');
	  }
	}
	/**
	 * Round the number of digits of a number *
	 * @param {SplitValue} split       A value split with .splitNumber(value)
	 * @param {number} precision  A positive integer
	 * @return {SplitValue}
	 *              Returns an object containing sign, coefficients, and exponent
	 *              with rounded digits
	 */

	function roundDigits(split, precision) {
	  // create a clone
	  var rounded = {
	    sign: split.sign,
	    coefficients: split.coefficients,
	    exponent: split.exponent
	  };
	  var c = rounded.coefficients; // prepend zeros if needed

	  while (precision <= 0) {
	    c.unshift(0);
	    rounded.exponent++;
	    precision++;
	  }

	  if (c.length > precision) {
	    var removed = c.splice(precision, c.length - precision);

	    if (removed[0] >= 5) {
	      var i = precision - 1;
	      c[i]++;

	      while (c[i] === 10) {
	        c.pop();

	        if (i === 0) {
	          c.unshift(0);
	          rounded.exponent++;
	          i++;
	        }

	        i--;
	        c[i]++;
	      }
	    }
	  }

	  return rounded;
	}
	/**
	 * Create an array filled with zeros.
	 * @param {number} length
	 * @return {Array}
	 */

	function zeros$1(length) {
	  var arr = [];

	  for (var i = 0; i < length; i++) {
	    arr.push(0);
	  }

	  return arr;
	}
	/**
	 * Count the number of significant digits of a number.
	 *
	 * For example:
	 *   2.34 returns 3
	 *   0.0034 returns 2
	 *   120.5e+30 returns 4
	 *
	 * @param {number} value
	 * @return {number} digits   Number of significant digits
	 */


	function digits(value) {
	  return value.toExponential().replace(/e.*$/, '') // remove exponential notation
	  .replace(/^0\.?0*|\./, '') // remove decimal point and leading zeros
	  .length;
	}
	/**
	 * Minimum number added to one that makes the result different than one
	 */

	var DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;
	/**
	 * Compares two floating point numbers.
	 * @param {number} x          First value to compare
	 * @param {number} y          Second value to compare
	 * @param {number} [epsilon]  The maximum relative difference between x and y
	 *                            If epsilon is undefined or null, the function will
	 *                            test whether x and y are exactly equal.
	 * @return {boolean} whether the two numbers are nearly equal
	*/

	function nearlyEqual$1(x, y, epsilon) {
	  // if epsilon is null or undefined, test whether x and y are exactly equal
	  if (epsilon === null || epsilon === undefined) {
	    return x === y;
	  }

	  if (x === y) {
	    return true;
	  } // NaN


	  if (isNaN(x) || isNaN(y)) {
	    return false;
	  } // at this point x and y should be finite


	  if (isFinite(x) && isFinite(y)) {
	    // check numbers are very close, needed when comparing numbers near zero
	    var diff = Math.abs(x - y);

	    if (diff < DBL_EPSILON) {
	      return true;
	    } else {
	      // use relative error
	      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
	    }
	  } // Infinite and Number or negative Infinite and positive Infinite cases


	  return false;
	}

	/**
	 * Formats a BigNumber in a given base
	 * @param {BigNumber} n
	 * @param {number} base
	 * @param {number} size
	 * @returns {string}
	 */

	function formatBigNumberToBase(n, base, size) {
	  var BigNumberCtor = n.constructor;
	  var big2 = new BigNumberCtor(2);
	  var suffix = '';

	  if (size) {
	    if (size < 1) {
	      throw new Error('size must be in greater than 0');
	    }

	    if (!isInteger(size)) {
	      throw new Error('size must be an integer');
	    }

	    if (n.greaterThan(big2.pow(size - 1).sub(1)) || n.lessThan(big2.pow(size - 1).mul(-1))) {
	      throw new Error("Value must be in range [-2^".concat(size - 1, ", 2^").concat(size - 1, "-1]"));
	    }

	    if (!n.isInteger()) {
	      throw new Error('Value must be an integer');
	    }

	    if (n.lessThan(0)) {
	      n = n.add(big2.pow(size));
	    }

	    suffix = "i".concat(size);
	  }

	  switch (base) {
	    case 2:
	      return "".concat(n.toBinary()).concat(suffix);

	    case 8:
	      return "".concat(n.toOctal()).concat(suffix);

	    case 16:
	      return "".concat(n.toHexadecimal()).concat(suffix);

	    default:
	      throw new Error("Base ".concat(base, " not supported "));
	  }
	}
	/**
	 * Convert a BigNumber to a formatted string representation.
	 *
	 * Syntax:
	 *
	 *    format(value)
	 *    format(value, options)
	 *    format(value, precision)
	 *    format(value, fn)
	 *
	 * Where:
	 *
	 *    {number} value   The value to be formatted
	 *    {Object} options An object with formatting options. Available options:
	 *                     {string} notation
	 *                         Number notation. Choose from:
	 *                         'fixed'          Always use regular number notation.
	 *                                          For example '123.40' and '14000000'
	 *                         'exponential'    Always use exponential notation.
	 *                                          For example '1.234e+2' and '1.4e+7'
	 *                         'auto' (default) Regular number notation for numbers
	 *                                          having an absolute value between
	 *                                          `lower` and `upper` bounds, and uses
	 *                                          exponential notation elsewhere.
	 *                                          Lower bound is included, upper bound
	 *                                          is excluded.
	 *                                          For example '123.4' and '1.4e7'.
	 *                         'bin', 'oct, or
	 *                         'hex'            Format the number using binary, octal,
	 *                                          or hexadecimal notation.
	 *                                          For example '0b1101' and '0x10fe'.
	 *                     {number} wordSize    The word size in bits to use for formatting
	 *                                          in binary, octal, or hexadecimal notation.
	 *                                          To be used only with 'bin', 'oct', or 'hex'
	 *                                          values for 'notation' option. When this option
	 *                                          is defined the value is formatted as a signed
	 *                                          twos complement integer of the given word size
	 *                                          and the size suffix is appended to the output.
	 *                                          For example
	 *                                          format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
	 *                                          Default value is undefined.
	 *                     {number} precision   A number between 0 and 16 to round
	 *                                          the digits of the number.
	 *                                          In case of notations 'exponential',
	 *                                          'engineering', and 'auto',
	 *                                          `precision` defines the total
	 *                                          number of significant digits returned.
	 *                                          In case of notation 'fixed',
	 *                                          `precision` defines the number of
	 *                                          significant digits after the decimal
	 *                                          point.
	 *                                          `precision` is undefined by default.
	 *                     {number} lowerExp    Exponent determining the lower boundary
	 *                                          for formatting a value with an exponent
	 *                                          when `notation='auto`.
	 *                                          Default value is `-3`.
	 *                     {number} upperExp    Exponent determining the upper boundary
	 *                                          for formatting a value with an exponent
	 *                                          when `notation='auto`.
	 *                                          Default value is `5`.
	 *    {Function} fn    A custom formatting function. Can be used to override the
	 *                     built-in notations. Function `fn` is called with `value` as
	 *                     parameter and must return a string. Is useful for example to
	 *                     format all values inside a matrix in a particular way.
	 *
	 * Examples:
	 *
	 *    format(6.4)                                        // '6.4'
	 *    format(1240000)                                    // '1.24e6'
	 *    format(1/3)                                        // '0.3333333333333333'
	 *    format(1/3, 3)                                     // '0.333'
	 *    format(21385, 2)                                   // '21000'
	 *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'
	 *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'
	 *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'
	 *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'
	 *
	 * @param {BigNumber} value
	 * @param {Object | Function | number} [options]
	 * @return {string} str The formatted value
	 */


	function format$1(value, options) {
	  if (typeof options === 'function') {
	    // handle format(value, fn)
	    return options(value);
	  } // handle special cases


	  if (!value.isFinite()) {
	    return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';
	  } // default values for options


	  var notation = 'auto';
	  var precision;
	  var wordSize;

	  if (options !== undefined) {
	    // determine notation from options
	    if (options.notation) {
	      notation = options.notation;
	    } // determine precision from options


	    if (typeof options === 'number') {
	      precision = options;
	    } else if (options.precision) {
	      precision = options.precision;
	    }

	    if (options.wordSize) {
	      wordSize = options.wordSize;

	      if (typeof wordSize !== 'number') {
	        throw new Error('Option "wordSize" must be a number');
	      }
	    }
	  } // handle the various notations


	  switch (notation) {
	    case 'fixed':
	      return toFixed(value, precision);

	    case 'exponential':
	      return toExponential(value, precision);

	    case 'engineering':
	      return toEngineering(value, precision);

	    case 'bin':
	      return formatBigNumberToBase(value, 2, wordSize);

	    case 'oct':
	      return formatBigNumberToBase(value, 8, wordSize);

	    case 'hex':
	      return formatBigNumberToBase(value, 16, wordSize);

	    case 'auto':
	      {
	        // determine lower and upper bound for exponential notation.
	        // TODO: implement support for upper and lower to be BigNumbers themselves
	        var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;
	        var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5; // handle special case zero

	        if (value.isZero()) return '0'; // determine whether or not to output exponential notation

	        var str;
	        var rounded = value.toSignificantDigits(precision);
	        var exp = rounded.e;

	        if (exp >= lowerExp && exp < upperExp) {
	          // normal number notation
	          str = rounded.toFixed();
	        } else {
	          // exponential notation
	          str = toExponential(value, precision);
	        } // remove trailing zeros after the decimal point


	        return str.replace(/((\.\d*?)(0+))($|e)/, function () {
	          var digits = arguments[2];
	          var e = arguments[4];
	          return digits !== '.' ? digits + e : e;
	        });
	      }

	    default:
	      throw new Error('Unknown notation "' + notation + '". ' + 'Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
	  }
	}
	/**
	 * Format a BigNumber in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'
	 * @param {BigNumber | string} value
	 * @param {number} [precision]        Optional number of significant figures to return.
	 */

	function toEngineering(value, precision) {
	  // find nearest lower multiple of 3 for exponent
	  var e = value.e;
	  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3; // find difference in exponents, and calculate the value without exponent

	  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
	  var valueStr = valueWithoutExp.toPrecision(precision);

	  if (valueStr.indexOf('e') !== -1) {
	    valueStr = valueWithoutExp.toString();
	  }

	  return valueStr + 'e' + (e >= 0 ? '+' : '') + newExp.toString();
	}
	/**
	 * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'
	 * @param {BigNumber} value
	 * @param {number} [precision]  Number of digits in formatted output.
	 *                              If not provided, the maximum available digits
	 *                              is used.
	 * @returns {string} str
	 */

	function toExponential(value, precision) {
	  if (precision !== undefined) {
	    return value.toExponential(precision - 1); // Note the offset of one
	  } else {
	    return value.toExponential();
	  }
	}
	/**
	 * Format a number with fixed notation.
	 * @param {BigNumber} value
	 * @param {number} [precision=undefined] Optional number of decimals after the
	 *                                       decimal point. Undefined by default.
	 */

	function toFixed(value, precision) {
	  return value.toFixed(precision);
	}

	/**
	 * Format a value of any type into a string.
	 *
	 * Usage:
	 *     math.format(value)
	 *     math.format(value, precision)
	 *     math.format(value, options)
	 *
	 * When value is a function:
	 *
	 * - When the function has a property `syntax`, it returns this
	 *   syntax description.
	 * - In other cases, a string `'function'` is returned.
	 *
	 * When `value` is an Object:
	 *
	 * - When the object contains a property `format` being a function, this
	 *   function is invoked as `value.format(options)` and the result is returned.
	 * - When the object has its own `toString` method, this method is invoked
	 *   and the result is returned.
	 * - In other cases the function will loop over all object properties and
	 *   return JSON object notation like '{"a": 2, "b": 3}'.
	 *
	 * Example usage:
	 *     math.format(2/7)                // '0.2857142857142857'
	 *     math.format(math.pi, 3)         // '3.14'
	 *     math.format(new Complex(2, 3))  // '2 + 3i'
	 *     math.format('hello')            // '"hello"'
	 *
	 * @param {*} value             Value to be stringified
	 * @param {Object | number | Function} [options]
	 *     Formatting options. See src/utils/number.js:format for a
	 *     description of the available options controlling number output.
	 *     This generic "format" also supports the option property `truncate: NN`
	 *     giving the maximum number NN of characters to return (if there would
	 *     have been more, they are deleted and replaced by an ellipsis).
	 * @return {string} str
	 */

	function format(value, options) {
	  var result = _format(value, options);

	  if (options && typeof options === 'object' && 'truncate' in options && result.length > options.truncate) {
	    return result.substring(0, options.truncate - 3) + '...';
	  }

	  return result;
	}

	function _format(value, options) {
	  if (typeof value === 'number') {
	    return format$2(value, options);
	  }

	  if (isBigNumber(value)) {
	    return format$1(value, options);
	  } // note: we use unsafe duck-typing here to check for Fractions, this is
	  // ok here since we're only invoking toString or concatenating its values


	  if (looksLikeFraction(value)) {
	    if (!options || options.fraction !== 'decimal') {
	      // output as ratio, like '1/3'
	      return value.s * value.n + '/' + value.d;
	    } else {
	      // output as decimal, like '0.(3)'
	      return value.toString();
	    }
	  }

	  if (Array.isArray(value)) {
	    return formatArray(value, options);
	  }

	  if (isString$1(value)) {
	    return '"' + value + '"';
	  }

	  if (typeof value === 'function') {
	    return value.syntax ? String(value.syntax) : 'function';
	  }

	  if (value && typeof value === 'object') {
	    if (typeof value.format === 'function') {
	      return value.format(options);
	    } else if (value && value.toString(options) !== {}.toString()) {
	      // this object has a non-native toString method, use that one
	      return value.toString(options);
	    } else {
	      var entries = Object.keys(value).map(key => {
	        return '"' + key + '": ' + format(value[key], options);
	      });
	      return '{' + entries.join(', ') + '}';
	    }
	  }

	  return String(value);
	}
	/**
	 * Recursively format an n-dimensional matrix
	 * Example output: "[[1, 2], [3, 4]]"
	 * @param {Array} array
	 * @param {Object | number | Function} [options]  Formatting options. See
	 *                                                lib/utils/number:format for a
	 *                                                description of the available
	 *                                                options.
	 * @returns {string} str
	 */

	function formatArray(array, options) {
	  if (Array.isArray(array)) {
	    var str = '[';
	    var len = array.length;

	    for (var i = 0; i < len; i++) {
	      if (i !== 0) {
	        str += ', ';
	      }

	      str += formatArray(array[i], options);
	    }

	    str += ']';
	    return str;
	  } else {
	    return format(array, options);
	  }
	}
	/**
	 * Check whether a value looks like a Fraction (unsafe duck-type check)
	 * @param {*} value
	 * @return {boolean}
	 */


	function looksLikeFraction(value) {
	  return value && typeof value === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;
	}

	/**
	 * Create a range error with the message:
	 *     'Dimension mismatch (<actual size> != <expected size>)'
	 * @param {number | number[]} actual        The actual size
	 * @param {number | number[]} expected      The expected size
	 * @param {string} [relation='!=']          Optional relation between actual
	 *                                          and expected size: '!=', '<', etc.
	 * @extends RangeError
	 */
	function DimensionError(actual, expected, relation) {
	  if (!(this instanceof DimensionError)) {
	    throw new SyntaxError('Constructor must be called with the new operator');
	  }

	  this.actual = actual;
	  this.expected = expected;
	  this.relation = relation;
	  this.message = 'Dimension mismatch (' + (Array.isArray(actual) ? '[' + actual.join(', ') + ']' : actual) + ' ' + (this.relation || '!=') + ' ' + (Array.isArray(expected) ? '[' + expected.join(', ') + ']' : expected) + ')';
	  this.stack = new Error().stack;
	}
	DimensionError.prototype = new RangeError();
	DimensionError.prototype.constructor = RangeError;
	DimensionError.prototype.name = 'DimensionError';
	DimensionError.prototype.isDimensionError = true;

	/**
	 * Create a range error with the message:
	 *     'Index out of range (index < min)'
	 *     'Index out of range (index < max)'
	 *
	 * @param {number} index     The actual index
	 * @param {number} [min=0]   Minimum index (included)
	 * @param {number} [max]     Maximum index (excluded)
	 * @extends RangeError
	 */
	function IndexError(index, min, max) {
	  if (!(this instanceof IndexError)) {
	    throw new SyntaxError('Constructor must be called with the new operator');
	  }

	  this.index = index;

	  if (arguments.length < 3) {
	    this.min = 0;
	    this.max = min;
	  } else {
	    this.min = min;
	    this.max = max;
	  }

	  if (this.min !== undefined && this.index < this.min) {
	    this.message = 'Index out of range (' + this.index + ' < ' + this.min + ')';
	  } else if (this.max !== undefined && this.index >= this.max) {
	    this.message = 'Index out of range (' + this.index + ' > ' + (this.max - 1) + ')';
	  } else {
	    this.message = 'Index out of range (' + this.index + ')';
	  }

	  this.stack = new Error().stack;
	}
	IndexError.prototype = new RangeError();
	IndexError.prototype.constructor = RangeError;
	IndexError.prototype.name = 'IndexError';
	IndexError.prototype.isIndexError = true;

	/**
	 * Calculate the size of a multi dimensional array.
	 * This function checks the size of the first entry, it does not validate
	 * whether all dimensions match. (use function `validate` for that)
	 * @param {Array} x
	 * @Return {Number[]} size
	 */

	function arraySize(x) {
	  var s = [];

	  while (Array.isArray(x)) {
	    s.push(x.length);
	    x = x[0];
	  }

	  return s;
	}
	/**
	 * Recursively validate whether each element in a multi dimensional array
	 * has a size corresponding to the provided size array.
	 * @param {Array} array    Array to be validated
	 * @param {number[]} size  Array with the size of each dimension
	 * @param {number} dim   Current dimension
	 * @throws DimensionError
	 * @private
	 */

	function _validate(array, size, dim) {
	  var i;
	  var len = array.length;

	  if (len !== size[dim]) {
	    throw new DimensionError(len, size[dim]);
	  }

	  if (dim < size.length - 1) {
	    // recursively validate each child array
	    var dimNext = dim + 1;

	    for (i = 0; i < len; i++) {
	      var child = array[i];

	      if (!Array.isArray(child)) {
	        throw new DimensionError(size.length - 1, size.length, '<');
	      }

	      _validate(array[i], size, dimNext);
	    }
	  } else {
	    // last dimension. none of the childs may be an array
	    for (i = 0; i < len; i++) {
	      if (Array.isArray(array[i])) {
	        throw new DimensionError(size.length + 1, size.length, '>');
	      }
	    }
	  }
	}
	/**
	 * Validate whether each element in a multi dimensional array has
	 * a size corresponding to the provided size array.
	 * @param {Array} array    Array to be validated
	 * @param {number[]} size  Array with the size of each dimension
	 * @throws DimensionError
	 */


	function validate(array, size) {
	  var isScalar = size.length === 0;

	  if (isScalar) {
	    // scalar
	    if (Array.isArray(array)) {
	      throw new DimensionError(array.length, 0);
	    }
	  } else {
	    // array
	    _validate(array, size, 0);
	  }
	}
	/**
	 * Test whether index is an integer number with index >= 0 and index < length
	 * when length is provided
	 * @param {number} index    Zero-based index
	 * @param {number} [length] Length of the array
	 */

	function validateIndex(index, length) {
	  if (!isNumber(index) || !isInteger(index)) {
	    throw new TypeError('Index must be an integer (value: ' + index + ')');
	  }

	  if (index < 0 || typeof length === 'number' && index >= length) {
	    throw new IndexError(index, length);
	  }
	}
	/**
	 * Resize a multi dimensional array. The resized array is returned.
	 * @param {Array} array         Array to be resized
	 * @param {Array.<number>} size Array with the size of each dimension
	 * @param {*} [defaultValue=0]  Value to be filled in in new entries,
	 *                              zero by default. Specify for example `null`,
	 *                              to clearly see entries that are not explicitly
	 *                              set.
	 * @return {Array} array         The resized array
	 */

	function resize(array, size, defaultValue) {
	  // TODO: add support for scalars, having size=[] ?
	  // check the type of the arguments
	  if (!Array.isArray(array) || !Array.isArray(size)) {
	    throw new TypeError('Array expected');
	  }

	  if (size.length === 0) {
	    throw new Error('Resizing to scalar is not supported');
	  } // check whether size contains positive integers


	  size.forEach(function (value) {
	    if (!isNumber(value) || !isInteger(value) || value < 0) {
	      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');
	    }
	  }); // recursively resize the array

	  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;

	  _resize(array, size, 0, _defaultValue);

	  return array;
	}
	/**
	 * Recursively resize a multi dimensional array
	 * @param {Array} array         Array to be resized
	 * @param {number[]} size       Array with the size of each dimension
	 * @param {number} dim          Current dimension
	 * @param {*} [defaultValue]    Value to be filled in in new entries,
	 *                              undefined by default.
	 * @private
	 */

	function _resize(array, size, dim, defaultValue) {
	  var i;
	  var elem;
	  var oldLen = array.length;
	  var newLen = size[dim];
	  var minLen = Math.min(oldLen, newLen); // apply new length

	  array.length = newLen;

	  if (dim < size.length - 1) {
	    // non-last dimension
	    var dimNext = dim + 1; // resize existing child arrays

	    for (i = 0; i < minLen; i++) {
	      // resize child array
	      elem = array[i];

	      if (!Array.isArray(elem)) {
	        elem = [elem]; // add a dimension

	        array[i] = elem;
	      }

	      _resize(elem, size, dimNext, defaultValue);
	    } // create new child arrays


	    for (i = minLen; i < newLen; i++) {
	      // get child array
	      elem = [];
	      array[i] = elem; // resize new child array

	      _resize(elem, size, dimNext, defaultValue);
	    }
	  } else {
	    // last dimension
	    // remove dimensions of existing values
	    for (i = 0; i < minLen; i++) {
	      while (Array.isArray(array[i])) {
	        array[i] = array[i][0];
	      }
	    } // fill new elements with the default value


	    for (i = minLen; i < newLen; i++) {
	      array[i] = defaultValue;
	    }
	  }
	}
	/**
	 * Re-shape a multi dimensional array to fit the specified dimensions
	 * @param {Array} array           Array to be reshaped
	 * @param {Array.<number>} sizes  List of sizes for each dimension
	 * @returns {Array}               Array whose data has been formatted to fit the
	 *                                specified dimensions
	 *
	 * @throws {DimensionError}       If the product of the new dimension sizes does
	 *                                not equal that of the old ones
	 */


	function reshape(array, sizes) {
	  var flatArray = flatten$1(array);
	  var currentLength = flatArray.length;

	  if (!Array.isArray(array) || !Array.isArray(sizes)) {
	    throw new TypeError('Array expected');
	  }

	  if (sizes.length === 0) {
	    throw new DimensionError(0, currentLength, '!=');
	  }

	  sizes = processSizesWildcard(sizes, currentLength);
	  var newLength = product(sizes);

	  if (currentLength !== newLength) {
	    throw new DimensionError(newLength, currentLength, '!=');
	  }

	  try {
	    return _reshape(flatArray, sizes);
	  } catch (e) {
	    if (e instanceof DimensionError) {
	      throw new DimensionError(newLength, currentLength, '!=');
	    }

	    throw e;
	  }
	}
	/**
	 * Replaces the wildcard -1 in the sizes array.
	 * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.
	 * @param {number} currentLength  Number of elements in the array.
	 * @throws {Error}                If more than one wildcard or unable to replace it.
	 * @returns {Array.<number>}      The sizes array with wildcard replaced.
	 */

	function processSizesWildcard(sizes, currentLength) {
	  var newLength = product(sizes);
	  var processedSizes = sizes.slice();
	  var WILDCARD = -1;
	  var wildCardIndex = sizes.indexOf(WILDCARD);
	  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;

	  if (isMoreThanOneWildcard) {
	    throw new Error('More than one wildcard in sizes');
	  }

	  var hasWildcard = wildCardIndex >= 0;
	  var canReplaceWildcard = currentLength % newLength === 0;

	  if (hasWildcard) {
	    if (canReplaceWildcard) {
	      processedSizes[wildCardIndex] = -currentLength / newLength;
	    } else {
	      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);
	    }
	  }

	  return processedSizes;
	}
	/**
	 * Computes the product of all array elements.
	 * @param {Array<number>} array Array of factors
	 * @returns {number}            Product of all elements
	 */

	function product(array) {
	  return array.reduce((prev, curr) => prev * curr, 1);
	}
	/**
	 * Iteratively re-shape a multi dimensional array to fit the specified dimensions
	 * @param {Array} array           Array to be reshaped
	 * @param {Array.<number>} sizes  List of sizes for each dimension
	 * @returns {Array}               Array whose data has been formatted to fit the
	 *                                specified dimensions
	 */


	function _reshape(array, sizes) {
	  // testing if there are enough elements for the requested shape
	  var tmpArray = array;
	  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one

	  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
	    var size = sizes[sizeIndex];
	    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size

	    var length = tmpArray.length / size;

	    for (var i = 0; i < length; i++) {
	      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));
	    } // set it as the new tmpArray for the next loop turn or for return


	    tmpArray = tmpArray2;
	  }

	  return tmpArray;
	}
	/**
	 * Squeeze a multi dimensional array
	 * @param {Array} array
	 * @param {Array} [size]
	 * @returns {Array} returns the array itself
	 */


	function squeeze(array, size) {
	  var s = size || arraySize(array); // squeeze outer dimensions

	  while (Array.isArray(array) && array.length === 1) {
	    array = array[0];
	    s.shift();
	  } // find the first dimension to be squeezed


	  var dims = s.length;

	  while (s[dims - 1] === 1) {
	    dims--;
	  } // squeeze inner dimensions


	  if (dims < s.length) {
	    array = _squeeze(array, dims, 0);
	    s.length = dims;
	  }

	  return array;
	}
	/**
	 * Recursively squeeze a multi dimensional array
	 * @param {Array} array
	 * @param {number} dims Required number of dimensions
	 * @param {number} dim  Current dimension
	 * @returns {Array | *} Returns the squeezed array
	 * @private
	 */

	function _squeeze(array, dims, dim) {
	  var i, ii;

	  if (dim < dims) {
	    var next = dim + 1;

	    for (i = 0, ii = array.length; i < ii; i++) {
	      array[i] = _squeeze(array[i], dims, next);
	    }
	  } else {
	    while (Array.isArray(array)) {
	      array = array[0];
	    }
	  }

	  return array;
	}
	/**
	 * Unsqueeze a multi dimensional array: add dimensions when missing
	 *
	 * Paramter `size` will be mutated to match the new, unqueezed matrix size.
	 *
	 * @param {Array} array
	 * @param {number} dims       Desired number of dimensions of the array
	 * @param {number} [outer]    Number of outer dimensions to be added
	 * @param {Array} [size] Current size of array.
	 * @returns {Array} returns the array itself
	 * @private
	 */


	function unsqueeze(array, dims, outer, size) {
	  var s = size || arraySize(array); // unsqueeze outer dimensions

	  if (outer) {
	    for (var i = 0; i < outer; i++) {
	      array = [array];
	      s.unshift(1);
	    }
	  } // unsqueeze inner dimensions


	  array = _unsqueeze(array, dims, 0);

	  while (s.length < dims) {
	    s.push(1);
	  }

	  return array;
	}
	/**
	 * Recursively unsqueeze a multi dimensional array
	 * @param {Array} array
	 * @param {number} dims Required number of dimensions
	 * @param {number} dim  Current dimension
	 * @returns {Array | *} Returns the squeezed array
	 * @private
	 */

	function _unsqueeze(array, dims, dim) {
	  var i, ii;

	  if (Array.isArray(array)) {
	    var next = dim + 1;

	    for (i = 0, ii = array.length; i < ii; i++) {
	      array[i] = _unsqueeze(array[i], dims, next);
	    }
	  } else {
	    for (var d = dim; d < dims; d++) {
	      array = [array];
	    }
	  }

	  return array;
	}
	/**
	 * Flatten a multi dimensional array, put all elements in a one dimensional
	 * array
	 * @param {Array} array   A multi dimensional array
	 * @return {Array}        The flattened array (1 dimensional)
	 */


	function flatten$1(array) {
	  if (!Array.isArray(array)) {
	    // if not an array, return as is
	    return array;
	  }

	  var flat = [];
	  array.forEach(function callback(value) {
	    if (Array.isArray(value)) {
	      value.forEach(callback); // traverse through sub-arrays recursively
	    } else {
	      flat.push(value);
	    }
	  });
	  return flat;
	}
	/**
	 * Check the datatype of a given object
	 * This is a low level implementation that should only be used by
	 * parent Matrix classes such as SparseMatrix or DenseMatrix
	 * This method does not validate Array Matrix shape
	 * @param {Array} array
	 * @param {function} typeOf   Callback function to use to determine the type of a value
	 * @return {string}
	 */

	function getArrayDataType(array, typeOf) {
	  var type; // to hold type info

	  var length = 0; // to hold length value to ensure it has consistent sizes

	  for (var i = 0; i < array.length; i++) {
	    var item = array[i];
	    var isArray = Array.isArray(item); // Saving the target matrix row size

	    if (i === 0 && isArray) {
	      length = item.length;
	    } // If the current item is an array but the length does not equal the targetVectorSize


	    if (isArray && item.length !== length) {
	      return undefined;
	    }

	    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array
	    : typeOf(item);

	    if (type === undefined) {
	      type = itemType; // first item
	    } else if (type !== itemType) {
	      return 'mixed';
	    } else ;
	  }

	  return type;
	}

	/**
	 * Create a factory function, which can be used to inject dependencies.
	 *
	 * The created functions are memoized, a consecutive call of the factory
	 * with the exact same inputs will return the same function instance.
	 * The memoized cache is exposed on `factory.cache` and can be cleared
	 * if needed.
	 *
	 * Example:
	 *
	 *     const name = 'log'
	 *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']
	 *
	 *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {
	 *       // ... create the function log here and return it
	 *     }
	 *
	 * @param {string} name           Name of the function to be created
	 * @param {string[]} dependencies The names of all required dependencies
	 * @param {function} create       Callback function called with an object with all dependencies
	 * @param {Object} [meta]         Optional object with meta information that will be attached
	 *                                to the created factory function as property `meta`.
	 * @returns {function}
	 */

	function factory(name, dependencies, create, meta) {
	  function assertAndCreate(scope) {
	    // we only pass the requested dependencies to the factory function
	    // to prevent functions to rely on dependencies that are not explicitly
	    // requested.
	    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));
	    assertDependencies(name, dependencies, scope);
	    return create(deps);
	  }

	  assertAndCreate.isFactory = true;
	  assertAndCreate.fn = name;
	  assertAndCreate.dependencies = dependencies.slice().sort();

	  if (meta) {
	    assertAndCreate.meta = meta;
	  }

	  return assertAndCreate;
	}
	/**
	 * Assert that all dependencies of a list with dependencies are available in the provided scope.
	 *
	 * Will throw an exception when there are dependencies missing.
	 *
	 * @param {string} name   Name for the function to be created. Used to generate a useful error message
	 * @param {string[]} dependencies
	 * @param {Object} scope
	 */

	function assertDependencies(name, dependencies, scope) {
	  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals
	  .every(dependency => scope[dependency] !== undefined);

	  if (!allDefined) {
	    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined); // TODO: create a custom error class for this, a MathjsError or something like that

	    throw new Error("Cannot create function \"".concat(name, "\", ") + "some dependencies are missing: ".concat(missingDependencies.map(d => "\"".concat(d, "\"")).join(', '), "."));
	  }
	}
	function isOptionalDependency(dependency) {
	  return dependency && dependency[0] === '?';
	}
	function stripOptionalNotation(dependency) {
	  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;
	}

	/**
	 * Get a property of a plain object
	 * Throws an error in case the object is not a plain object or the
	 * property is not defined on the object itself
	 * @param {Object} object
	 * @param {string} prop
	 * @return {*} Returns the property value when safe
	 */

	function getSafeProperty(object, prop) {
	  // only allow getting safe properties of a plain object
	  if (isPlainObject$1(object) && isSafeProperty(object, prop)) {
	    return object[prop];
	  }

	  if (typeof object[prop] === 'function' && isSafeMethod(object, prop)) {
	    throw new Error('Cannot access method "' + prop + '" as a property');
	  }

	  throw new Error('No access to property "' + prop + '"');
	}
	/**
	 * Set a property on a plain object.
	 * Throws an error in case the object is not a plain object or the
	 * property would override an inherited property like .constructor or .toString
	 * @param {Object} object
	 * @param {string} prop
	 * @param {*} value
	 * @return {*} Returns the value
	 */
	// TODO: merge this function into access.js?


	function setSafeProperty(object, prop, value) {
	  // only allow setting safe properties of a plain object
	  if (isPlainObject$1(object) && isSafeProperty(object, prop)) {
	    object[prop] = value;
	    return value;
	  }

	  throw new Error('No access to property "' + prop + '"');
	}

	function hasSafeProperty(object, prop) {
	  return prop in object;
	}
	/**
	 * Test whether a property is safe to use for an object.
	 * For example .toString and .constructor are not safe
	 * @param {string} prop
	 * @return {boolean} Returns true when safe
	 */


	function isSafeProperty(object, prop) {
	  if (!object || typeof object !== 'object') {
	    return false;
	  } // SAFE: whitelisted
	  // e.g length


	  if (hasOwnProperty(safeNativeProperties, prop)) {
	    return true;
	  } // UNSAFE: inherited from Object prototype
	  // e.g constructor


	  if (prop in Object.prototype) {
	    // 'in' is used instead of hasOwnProperty for nodejs v0.10
	    // which is inconsistent on root prototypes. It is safe
	    // here because Object.prototype is a root object
	    return false;
	  } // UNSAFE: inherited from Function prototype
	  // e.g call, apply


	  if (prop in Function.prototype) {
	    // 'in' is used instead of hasOwnProperty for nodejs v0.10
	    // which is inconsistent on root prototypes. It is safe
	    // here because Function.prototype is a root object
	    return false;
	  }

	  return true;
	}
	/**
	 * Check whether a method is safe.
	 * Throws an error when that's not the case (for example for `constructor`).
	 * @param {Object} object
	 * @param {string} method
	 * @return {boolean} Returns true when safe, false otherwise
	 */


	function isSafeMethod(object, method) {
	  if (object === null || object === undefined || typeof object[method] !== 'function') {
	    return false;
	  } // UNSAFE: ghosted
	  // e.g overridden toString
	  // Note that IE10 doesn't support __proto__ and we can't do this check there.


	  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
	    return false;
	  } // SAFE: whitelisted
	  // e.g toString


	  if (hasOwnProperty(safeNativeMethods, method)) {
	    return true;
	  } // UNSAFE: inherited from Object prototype
	  // e.g constructor


	  if (method in Object.prototype) {
	    // 'in' is used instead of hasOwnProperty for nodejs v0.10
	    // which is inconsistent on root prototypes. It is safe
	    // here because Object.prototype is a root object
	    return false;
	  } // UNSAFE: inherited from Function prototype
	  // e.g call, apply


	  if (method in Function.prototype) {
	    // 'in' is used instead of hasOwnProperty for nodejs v0.10
	    // which is inconsistent on root prototypes. It is safe
	    // here because Function.prototype is a root object
	    return false;
	  }

	  return true;
	}

	function isPlainObject$1(object) {
	  return typeof object === 'object' && object && object.constructor === Object;
	}

	var safeNativeProperties = {
	  length: true,
	  name: true
	};
	var safeNativeMethods = {
	  toString: true,
	  valueOf: true,
	  toLocaleString: true
	};

	/**
	 * A map facade on a bare object.
	 *
	 * The small number of methods needed to implement a scope,
	 * forwarding on to the SafeProperty functions. Over time, the codebase
	 * will stop using this method, as all objects will be Maps, rather than
	 * more security prone objects.
	 */

	class ObjectWrappingMap {
	  constructor(object) {
	    this.wrappedObject = object;
	  }

	  keys() {
	    return Object.keys(this.wrappedObject);
	  }

	  get(key) {
	    return getSafeProperty(this.wrappedObject, key);
	  }

	  set(key, value) {
	    setSafeProperty(this.wrappedObject, key, value);
	    return this;
	  }

	  has(key) {
	    return hasSafeProperty(this.wrappedObject, key);
	  }

	}
	/**
	 * Returns `true` if the passed object appears to be a Map (i.e. duck typing).
	 *
	 * Methods looked for are `get`, `set`, `keys` and `has`.
	 *
	 * @param {Map | object} object
	 * @returns
	 */

	function isMap(object) {
	  // We can use the fast instanceof, or a slower duck typing check.
	  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.
	  if (!object) {
	    return false;
	  }

	  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';
	}

	/**
	 * Create a typed-function which checks the types of the arguments and
	 * can match them against multiple provided signatures. The typed-function
	 * automatically converts inputs in order to find a matching signature.
	 * Typed functions throw informative errors in case of wrong input arguments.
	 *
	 * See the library [typed-function](https://github.com/josdejong/typed-function)
	 * for detailed documentation.
	 *
	 * Syntax:
	 *
	 *     math.typed(name, signatures) : function
	 *     math.typed(signatures) : function
	 *
	 * Examples:
	 *
	 *     // create a typed function with multiple types per argument (type union)
	 *     const fn2 = typed({
	 *       'number | boolean': function (b) {
	 *         return 'b is a number or boolean'
	 *       },
	 *       'string, number | boolean': function (a, b) {
	 *         return 'a is a string, b is a number or boolean'
	 *       }
	 *     })
	 *
	 *     // create a typed function with an any type argument
	 *     const log = typed({
	 *       'string, any': function (event, data) {
	 *         console.log('event: ' + event + ', data: ' + JSON.stringify(data))
	 *       }
	 *     })
	 *
	 * @param {string} [name]                          Optional name for the typed-function
	 * @param {Object<string, function>} signatures   Object with one or multiple function signatures
	 * @returns {function} The created typed-function.
	 */

	var _createTyped2 = function _createTyped() {
	  // initially, return the original instance of typed-function
	  // consecutively, return a new instance from typed.create.
	  _createTyped2 = typedFunction.create;
	  return typedFunction;
	};

	var dependencies$14 = ['?BigNumber', '?Complex', '?DenseMatrix', '?Fraction'];
	/**
	 * Factory function for creating a new typed instance
	 * @param {Object} dependencies   Object with data types like Complex and BigNumber
	 * @returns {Function}
	 */

	var createTyped = /* #__PURE__ */factory('typed', dependencies$14, function createTyped(_ref) {
	  var {
	    BigNumber,
	    Complex,
	    DenseMatrix,
	    Fraction
	  } = _ref; // TODO: typed-function must be able to silently ignore signatures with unknown data types
	  // get a new instance of typed-function

	  var typed = _createTyped2(); // define all types. The order of the types determines in which order function
	  // arguments are type-checked (so for performance it's important to put the
	  // most used types first).


	  typed.types = [{
	    name: 'number',
	    test: isNumber
	  }, {
	    name: 'Complex',
	    test: isComplex
	  }, {
	    name: 'BigNumber',
	    test: isBigNumber
	  }, {
	    name: 'Fraction',
	    test: isFraction
	  }, {
	    name: 'Unit',
	    test: isUnit
	  }, {
	    name: 'string',
	    test: isString$1
	  }, {
	    name: 'Chain',
	    test: isChain
	  }, {
	    name: 'Array',
	    test: isArray
	  }, {
	    name: 'Matrix',
	    test: isMatrix
	  }, {
	    name: 'DenseMatrix',
	    test: isDenseMatrix
	  }, {
	    name: 'SparseMatrix',
	    test: isSparseMatrix
	  }, {
	    name: 'Range',
	    test: isRange
	  }, {
	    name: 'Index',
	    test: isIndex
	  }, {
	    name: 'boolean',
	    test: isBoolean
	  }, {
	    name: 'ResultSet',
	    test: isResultSet
	  }, {
	    name: 'Help',
	    test: isHelp
	  }, {
	    name: 'function',
	    test: isFunction
	  }, {
	    name: 'Date',
	    test: isDate
	  }, {
	    name: 'RegExp',
	    test: isRegExp$1
	  }, {
	    name: 'null',
	    test: isNull
	  }, {
	    name: 'undefined',
	    test: isUndefined
	  }, {
	    name: 'AccessorNode',
	    test: isAccessorNode
	  }, {
	    name: 'ArrayNode',
	    test: isArrayNode
	  }, {
	    name: 'AssignmentNode',
	    test: isAssignmentNode
	  }, {
	    name: 'BlockNode',
	    test: isBlockNode
	  }, {
	    name: 'ConditionalNode',
	    test: isConditionalNode
	  }, {
	    name: 'ConstantNode',
	    test: isConstantNode
	  }, {
	    name: 'FunctionNode',
	    test: isFunctionNode
	  }, {
	    name: 'FunctionAssignmentNode',
	    test: isFunctionAssignmentNode
	  }, {
	    name: 'IndexNode',
	    test: isIndexNode
	  }, {
	    name: 'Node',
	    test: isNode
	  }, {
	    name: 'ObjectNode',
	    test: isObjectNode
	  }, {
	    name: 'OperatorNode',
	    test: isOperatorNode
	  }, {
	    name: 'ParenthesisNode',
	    test: isParenthesisNode
	  }, {
	    name: 'RangeNode',
	    test: isRangeNode
	  }, {
	    name: 'SymbolNode',
	    test: isSymbolNode
	  }, {
	    name: 'Map',
	    test: isMap
	  }, {
	    name: 'Object',
	    test: isObject
	  } // order 'Object' last, it matches on other classes too
	  ];
	  typed.conversions = [{
	    from: 'number',
	    to: 'BigNumber',
	    convert: function convert(x) {
	      if (!BigNumber) {
	        throwNoBignumber(x);
	      } // note: conversion from number to BigNumber can fail if x has >15 digits


	      if (digits(x) > 15) {
	        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');
	      }

	      return new BigNumber(x);
	    }
	  }, {
	    from: 'number',
	    to: 'Complex',
	    convert: function convert(x) {
	      if (!Complex) {
	        throwNoComplex(x);
	      }

	      return new Complex(x, 0);
	    }
	  }, {
	    from: 'number',
	    to: 'string',
	    convert: function convert(x) {
	      return x + '';
	    }
	  }, {
	    from: 'BigNumber',
	    to: 'Complex',
	    convert: function convert(x) {
	      if (!Complex) {
	        throwNoComplex(x);
	      }

	      return new Complex(x.toNumber(), 0);
	    }
	  }, {
	    from: 'Fraction',
	    to: 'BigNumber',
	    convert: function convert(x) {
	      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');
	    }
	  }, {
	    from: 'Fraction',
	    to: 'Complex',
	    convert: function convert(x) {
	      if (!Complex) {
	        throwNoComplex(x);
	      }

	      return new Complex(x.valueOf(), 0);
	    }
	  }, {
	    from: 'number',
	    to: 'Fraction',
	    convert: function convert(x) {
	      if (!Fraction) {
	        throwNoFraction(x);
	      }

	      var f = new Fraction(x);

	      if (f.valueOf() !== x) {
	        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');
	      }

	      return f;
	    }
	  }, {
	    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
	    //  from: 'Fraction',
	    //  to: 'number',
	    //  convert: function (x) {
	    //    return x.valueOf()
	    //  }
	    // }, {
	    from: 'string',
	    to: 'number',
	    convert: function convert(x) {
	      var n = Number(x);

	      if (isNaN(n)) {
	        throw new Error('Cannot convert "' + x + '" to a number');
	      }

	      return n;
	    }
	  }, {
	    from: 'string',
	    to: 'BigNumber',
	    convert: function convert(x) {
	      if (!BigNumber) {
	        throwNoBignumber(x);
	      }

	      try {
	        return new BigNumber(x);
	      } catch (err) {
	        throw new Error('Cannot convert "' + x + '" to BigNumber');
	      }
	    }
	  }, {
	    from: 'string',
	    to: 'Fraction',
	    convert: function convert(x) {
	      if (!Fraction) {
	        throwNoFraction(x);
	      }

	      try {
	        return new Fraction(x);
	      } catch (err) {
	        throw new Error('Cannot convert "' + x + '" to Fraction');
	      }
	    }
	  }, {
	    from: 'string',
	    to: 'Complex',
	    convert: function convert(x) {
	      if (!Complex) {
	        throwNoComplex(x);
	      }

	      try {
	        return new Complex(x);
	      } catch (err) {
	        throw new Error('Cannot convert "' + x + '" to Complex');
	      }
	    }
	  }, {
	    from: 'boolean',
	    to: 'number',
	    convert: function convert(x) {
	      return +x;
	    }
	  }, {
	    from: 'boolean',
	    to: 'BigNumber',
	    convert: function convert(x) {
	      if (!BigNumber) {
	        throwNoBignumber(x);
	      }

	      return new BigNumber(+x);
	    }
	  }, {
	    from: 'boolean',
	    to: 'Fraction',
	    convert: function convert(x) {
	      if (!Fraction) {
	        throwNoFraction(x);
	      }

	      return new Fraction(+x);
	    }
	  }, {
	    from: 'boolean',
	    to: 'string',
	    convert: function convert(x) {
	      return String(x);
	    }
	  }, {
	    from: 'Array',
	    to: 'Matrix',
	    convert: function convert(array) {
	      if (!DenseMatrix) {
	        throwNoMatrix();
	      }

	      return new DenseMatrix(array);
	    }
	  }, {
	    from: 'Matrix',
	    to: 'Array',
	    convert: function convert(matrix) {
	      return matrix.valueOf();
	    }
	  }];
	  return typed;
	});

	function throwNoBignumber(x) {
	  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
	}

	function throwNoComplex(x) {
	  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
	}

	function throwNoMatrix() {
	  throw new Error('Cannot convert array into a Matrix: no class \'DenseMatrix\' provided');
	}

	function throwNoFraction(x) {
	  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
	}

	var decimal = createCommonjsModule(function (module) {

	  (function (globalScope) {
	    /*
	     *  decimal.js v10.3.1
	     *  An arbitrary-precision Decimal type for JavaScript.
	     *  https://github.com/MikeMcl/decimal.js
	     *  Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>
	     *  MIT Licence
	     */
	    // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //
	    // The maximum exponent magnitude.
	    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.

	    var EXP_LIMIT = 9e15,
	        // 0 to 9e15
	    // The limit on the value of `precision`, and on the value of the first argument to
	    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
	    MAX_DIGITS = 1e9,
	        // 0 to 1e9
	    // Base conversion alphabet.
	    NUMERALS = '0123456789abcdef',
	        // The natural logarithm of 10 (1025 digits).
	    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',
	        // Pi (1025 digits).
	    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',
	        // The initial configuration properties of the Decimal constructor.
	    DEFAULTS = {
	      // These values must be integers within the stated ranges (inclusive).
	      // Most of these values can be changed at run-time using the `Decimal.config` method.
	      // The maximum number of significant digits of the result of a calculation or base conversion.
	      // E.g. `Decimal.config({ precision: 20 });`
	      precision: 20,
	      // 1 to MAX_DIGITS
	      // The rounding mode used when rounding to `precision`.
	      //
	      // ROUND_UP         0 Away from zero.
	      // ROUND_DOWN       1 Towards zero.
	      // ROUND_CEIL       2 Towards +Infinity.
	      // ROUND_FLOOR      3 Towards -Infinity.
	      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
	      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
	      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
	      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
	      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
	      //
	      // E.g.
	      // `Decimal.rounding = 4;`
	      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
	      rounding: 4,
	      // 0 to 8
	      // The modulo mode used when calculating the modulus: a mod n.
	      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
	      // The remainder (r) is calculated as: r = a - n * q.
	      //
	      // UP         0 The remainder is positive if the dividend is negative, else is negative.
	      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
	      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
	      // HALF_EVEN  6 The IEEE 754 remainder function.
	      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
	      //
	      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
	      // division (9) are commonly used for the modulus operation. The other rounding modes can also
	      // be used, but they may not give useful results.
	      modulo: 1,
	      // 0 to 9
	      // The exponent value at and beneath which `toString` returns exponential notation.
	      // JavaScript numbers: -7
	      toExpNeg: -7,
	      // 0 to -EXP_LIMIT
	      // The exponent value at and above which `toString` returns exponential notation.
	      // JavaScript numbers: 21
	      toExpPos: 21,
	      // 0 to EXP_LIMIT
	      // The minimum exponent value, beneath which underflow to zero occurs.
	      // JavaScript numbers: -324  (5e-324)
	      minE: -EXP_LIMIT,
	      // -1 to -EXP_LIMIT
	      // The maximum exponent value, above which overflow to Infinity occurs.
	      // JavaScript numbers: 308  (1.7976931348623157e+308)
	      maxE: EXP_LIMIT,
	      // 1 to EXP_LIMIT
	      // Whether to use cryptographically-secure random number generation, if available.
	      crypto: false // true/false

	    },
	        // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //
	    Decimal,
	        inexact,
	        noConflict,
	        quadrant,
	        external = true,
	        decimalError = '[DecimalError] ',
	        invalidArgument = decimalError + 'Invalid argument: ',
	        precisionLimitExceeded = decimalError + 'Precision limit exceeded',
	        cryptoUnavailable = decimalError + 'crypto unavailable',
	        tag = '[object Decimal]',
	        mathfloor = Math.floor,
	        mathpow = Math.pow,
	        isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
	        isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
	        isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
	        isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	        BASE = 1e7,
	        LOG_BASE = 7,
	        MAX_SAFE_INTEGER = 9007199254740991,
	        LN10_PRECISION = LN10.length - 1,
	        PI_PRECISION = PI.length - 1,
	        // Decimal.prototype object
	    P = {
	      toStringTag: tag
	    }; // Decimal prototype methods

	    /*
	     *  absoluteValue             abs
	     *  ceil
	     *  clampedTo                 clamp
	     *  comparedTo                cmp
	     *  cosine                    cos
	     *  cubeRoot                  cbrt
	     *  decimalPlaces             dp
	     *  dividedBy                 div
	     *  dividedToIntegerBy        divToInt
	     *  equals                    eq
	     *  floor
	     *  greaterThan               gt
	     *  greaterThanOrEqualTo      gte
	     *  hyperbolicCosine          cosh
	     *  hyperbolicSine            sinh
	     *  hyperbolicTangent         tanh
	     *  inverseCosine             acos
	     *  inverseHyperbolicCosine   acosh
	     *  inverseHyperbolicSine     asinh
	     *  inverseHyperbolicTangent  atanh
	     *  inverseSine               asin
	     *  inverseTangent            atan
	     *  isFinite
	     *  isInteger                 isInt
	     *  isNaN
	     *  isNegative                isNeg
	     *  isPositive                isPos
	     *  isZero
	     *  lessThan                  lt
	     *  lessThanOrEqualTo         lte
	     *  logarithm                 log
	     *  [maximum]                 [max]
	     *  [minimum]                 [min]
	     *  minus                     sub
	     *  modulo                    mod
	     *  naturalExponential        exp
	     *  naturalLogarithm          ln
	     *  negated                   neg
	     *  plus                      add
	     *  precision                 sd
	     *  round
	     *  sine                      sin
	     *  squareRoot                sqrt
	     *  tangent                   tan
	     *  times                     mul
	     *  toBinary
	     *  toDecimalPlaces           toDP
	     *  toExponential
	     *  toFixed
	     *  toFraction
	     *  toHexadecimal             toHex
	     *  toNearest
	     *  toNumber
	     *  toOctal
	     *  toPower                   pow
	     *  toPrecision
	     *  toSignificantDigits       toSD
	     *  toString
	     *  truncated                 trunc
	     *  valueOf                   toJSON
	     */

	    /*
	     * Return a new Decimal whose value is the absolute value of this Decimal.
	     *
	     */

	    P.absoluteValue = P.abs = function () {
	      var x = new this.constructor(this);
	      if (x.s < 0) x.s = 1;
	      return finalise(x);
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
	     * direction of positive Infinity.
	     *
	     */


	    P.ceil = function () {
	      return finalise(new this.constructor(this), this.e + 1, 2);
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal clamped to the range
	     * delineated by `min` and `max`.
	     *
	     * min {number|string|Decimal}
	     * max {number|string|Decimal}
	     *
	     */


	    P.clampedTo = P.clamp = function (min, max) {
	      var k,
	          x = this,
	          Ctor = x.constructor;
	      min = new Ctor(min);
	      max = new Ctor(max);
	      if (!min.s || !max.s) return new Ctor(NaN);
	      if (min.gt(max)) throw Error(invalidArgument + max);
	      k = x.cmp(min);
	      return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
	    };
	    /*
	     * Return
	     *   1    if the value of this Decimal is greater than the value of `y`,
	     *  -1    if the value of this Decimal is less than the value of `y`,
	     *   0    if they have the same value,
	     *   NaN  if the value of either Decimal is NaN.
	     *
	     */


	    P.comparedTo = P.cmp = function (y) {
	      var i,
	          j,
	          xdL,
	          ydL,
	          x = this,
	          xd = x.d,
	          yd = (y = new x.constructor(y)).d,
	          xs = x.s,
	          ys = y.s; // Either NaN or Infinity?

	      if (!xd || !yd) {
	        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
	      } // Either zero?


	      if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0; // Signs differ?

	      if (xs !== ys) return xs; // Compare exponents.

	      if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
	      xdL = xd.length;
	      ydL = yd.length; // Compare digit by digit.

	      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
	        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
	      } // Compare lengths.


	      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
	    };
	    /*
	     * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-1, 1]
	     *
	     * cos(0)         = 1
	     * cos(-0)        = 1
	     * cos(Infinity)  = NaN
	     * cos(-Infinity) = NaN
	     * cos(NaN)       = NaN
	     *
	     */


	    P.cosine = P.cos = function () {
	      var pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.d) return new Ctor(NaN); // cos(0) = cos(-0) = 1

	      if (!x.d[0]) return new Ctor(1);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
	      Ctor.rounding = 1;
	      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
	    };
	    /*
	     *
	     * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
	     * `precision` significant digits using rounding mode `rounding`.
	     *
	     *  cbrt(0)  =  0
	     *  cbrt(-0) = -0
	     *  cbrt(1)  =  1
	     *  cbrt(-1) = -1
	     *  cbrt(N)  =  N
	     *  cbrt(-I) = -I
	     *  cbrt(I)  =  I
	     *
	     * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
	     *
	     */


	    P.cubeRoot = P.cbrt = function () {
	      var e,
	          m,
	          n,
	          r,
	          rep,
	          s,
	          sd,
	          t,
	          t3,
	          t3plusx,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite() || x.isZero()) return new Ctor(x);
	      external = false; // Initial estimate.

	      s = x.s * mathpow(x.s * x, 1 / 3); // Math.cbrt underflow/overflow?
	      // Pass x to Math.pow as integer, then adjust the exponent of the result.

	      if (!s || Math.abs(s) == 1 / 0) {
	        n = digitsToString(x.d);
	        e = x.e; // Adjust n exponent so it is a multiple of 3 away from x exponent.

	        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? '0' : '00';
	        s = mathpow(n, 1 / 3); // Rarely, e may be one less than the result exponent value.

	        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

	        if (s == 1 / 0) {
	          n = '5e' + e;
	        } else {
	          n = s.toExponential();
	          n = n.slice(0, n.indexOf('e') + 1) + e;
	        }

	        r = new Ctor(n);
	        r.s = x.s;
	      } else {
	        r = new Ctor(s.toString());
	      }

	      sd = (e = Ctor.precision) + 3; // Halley's method.
	      // TODO? Compare Newton's method.

	      for (;;) {
	        t = r;
	        t3 = t.times(t).times(t);
	        t3plusx = t3.plus(x);
	        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1); // TODO? Replace with for-loop and checkRoundingDigits.

	        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
	          n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
	          // , i.e. approaching a rounding boundary, continue the iteration.

	          if (n == '9999' || !rep && n == '4999') {
	            // On the first iteration only, check to see if rounding up gives the exact result as the
	            // nines may infinitely repeat.
	            if (!rep) {
	              finalise(t, e + 1, 0);

	              if (t.times(t).times(t).eq(x)) {
	                r = t;
	                break;
	              }
	            }

	            sd += 4;
	            rep = 1;
	          } else {
	            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
	            // If not, then there are further digits and m will be truthy.
	            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
	              // Truncate to the first rounding digit.
	              finalise(r, e + 1, 1);
	              m = !r.times(r).times(r).eq(x);
	            }

	            break;
	          }
	        }
	      }

	      external = true;
	      return finalise(r, e, Ctor.rounding, m);
	    };
	    /*
	     * Return the number of decimal places of the value of this Decimal.
	     *
	     */


	    P.decimalPlaces = P.dp = function () {
	      var w,
	          d = this.d,
	          n = NaN;

	      if (d) {
	        w = d.length - 1;
	        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE; // Subtract the number of trailing zeros of the last word.

	        w = d[w];
	        if (w) for (; w % 10 == 0; w /= 10) n--;
	        if (n < 0) n = 0;
	      }

	      return n;
	    };
	    /*
	     *  n / 0 = I
	     *  n / N = N
	     *  n / I = 0
	     *  0 / n = 0
	     *  0 / 0 = N
	     *  0 / N = N
	     *  0 / I = 0
	     *  N / n = N
	     *  N / 0 = N
	     *  N / N = N
	     *  N / I = N
	     *  I / n = I
	     *  I / 0 = I
	     *  I / N = N
	     *  I / I = N
	     *
	     * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
	     * `precision` significant digits using rounding mode `rounding`.
	     *
	     */


	    P.dividedBy = P.div = function (y) {
	      return divide(this, new this.constructor(y));
	    };
	    /*
	     * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
	     * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
	     *
	     */


	    P.dividedToIntegerBy = P.divToInt = function (y) {
	      var x = this,
	          Ctor = x.constructor;
	      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
	    };
	    /*
	     * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
	     *
	     */


	    P.equals = P.eq = function (y) {
	      return this.cmp(y) === 0;
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
	     * direction of negative Infinity.
	     *
	     */


	    P.floor = function () {
	      return finalise(new this.constructor(this), this.e + 1, 3);
	    };
	    /*
	     * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
	     * false.
	     *
	     */


	    P.greaterThan = P.gt = function (y) {
	      return this.cmp(y) > 0;
	    };
	    /*
	     * Return true if the value of this Decimal is greater than or equal to the value of `y`,
	     * otherwise return false.
	     *
	     */


	    P.greaterThanOrEqualTo = P.gte = function (y) {
	      var k = this.cmp(y);
	      return k == 1 || k === 0;
	    };
	    /*
	     * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
	     * Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [1, Infinity]
	     *
	     * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
	     *
	     * cosh(0)         = 1
	     * cosh(-0)        = 1
	     * cosh(Infinity)  = Infinity
	     * cosh(-Infinity) = Infinity
	     * cosh(NaN)       = NaN
	     *
	     *  x        time taken (ms)   result
	     * 1000      9                 9.8503555700852349694e+433
	     * 10000     25                4.4034091128314607936e+4342
	     * 100000    171               1.4033316802130615897e+43429
	     * 1000000   3817              1.5166076984010437725e+434294
	     * 10000000  abandoned after 2 minute wait
	     *
	     * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
	     *
	     */


	    P.hyperbolicCosine = P.cosh = function () {
	      var k,
	          n,
	          pr,
	          rm,
	          len,
	          x = this,
	          Ctor = x.constructor,
	          one = new Ctor(1);
	      if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
	      if (x.isZero()) return one;
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
	      Ctor.rounding = 1;
	      len = x.d.length; // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
	      // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))
	      // Estimate the optimum number of times to use the argument reduction.
	      // TODO? Estimation reused from cosine() and may not be optimal here.

	      if (len < 32) {
	        k = Math.ceil(len / 3);
	        n = (1 / tinyPow(4, k)).toString();
	      } else {
	        k = 16;
	        n = '2.3283064365386962890625e-10';
	      }

	      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true); // Reverse argument reduction

	      var cosh2_x,
	          i = k,
	          d8 = new Ctor(8);

	      for (; i--;) {
	        cosh2_x = x.times(x);
	        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
	      }

	      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
	    };
	    /*
	     * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
	     * Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-Infinity, Infinity]
	     *
	     * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
	     *
	     * sinh(0)         = 0
	     * sinh(-0)        = -0
	     * sinh(Infinity)  = Infinity
	     * sinh(-Infinity) = -Infinity
	     * sinh(NaN)       = NaN
	     *
	     * x        time taken (ms)
	     * 10       2 ms
	     * 100      5 ms
	     * 1000     14 ms
	     * 10000    82 ms
	     * 100000   886 ms            1.4033316802130615897e+43429
	     * 200000   2613 ms
	     * 300000   5407 ms
	     * 400000   8824 ms
	     * 500000   13026 ms          8.7080643612718084129e+217146
	     * 1000000  48543 ms
	     *
	     * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
	     *
	     */


	    P.hyperbolicSine = P.sinh = function () {
	      var k,
	          pr,
	          rm,
	          len,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite() || x.isZero()) return new Ctor(x);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
	      Ctor.rounding = 1;
	      len = x.d.length;

	      if (len < 3) {
	        x = taylorSeries(Ctor, 2, x, x, true);
	      } else {
	        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
	        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
	        // 3 multiplications and 1 addition
	        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
	        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
	        // 4 multiplications and 2 additions
	        // Estimate the optimum number of times to use the argument reduction.
	        k = 1.4 * Math.sqrt(len);
	        k = k > 16 ? 16 : k | 0;
	        x = x.times(1 / tinyPow(5, k));
	        x = taylorSeries(Ctor, 2, x, x, true); // Reverse argument reduction

	        var sinh2_x,
	            d5 = new Ctor(5),
	            d16 = new Ctor(16),
	            d20 = new Ctor(20);

	        for (; k--;) {
	          sinh2_x = x.times(x);
	          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
	        }
	      }

	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return finalise(x, pr, rm, true);
	    };
	    /*
	     * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
	     * Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-1, 1]
	     *
	     * tanh(x) = sinh(x) / cosh(x)
	     *
	     * tanh(0)         = 0
	     * tanh(-0)        = -0
	     * tanh(Infinity)  = 1
	     * tanh(-Infinity) = -1
	     * tanh(NaN)       = NaN
	     *
	     */


	    P.hyperbolicTangent = P.tanh = function () {
	      var pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite()) return new Ctor(x.s);
	      if (x.isZero()) return new Ctor(x);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + 7;
	      Ctor.rounding = 1;
	      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
	    };
	    /*
	     * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
	     * this Decimal.
	     *
	     * Domain: [-1, 1]
	     * Range: [0, pi]
	     *
	     * acos(x) = pi/2 - asin(x)
	     *
	     * acos(0)       = pi/2
	     * acos(-0)      = pi/2
	     * acos(1)       = 0
	     * acos(-1)      = pi
	     * acos(1/2)     = pi/3
	     * acos(-1/2)    = 2*pi/3
	     * acos(|x| > 1) = NaN
	     * acos(NaN)     = NaN
	     *
	     */


	    P.inverseCosine = P.acos = function () {
	      var halfPi,
	          x = this,
	          Ctor = x.constructor,
	          k = x.abs().cmp(1),
	          pr = Ctor.precision,
	          rm = Ctor.rounding;

	      if (k !== -1) {
	        return k === 0 // |x| is 1
	        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) // |x| > 1 or x is NaN
	        : new Ctor(NaN);
	      }

	      if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5); // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

	      Ctor.precision = pr + 6;
	      Ctor.rounding = 1;
	      x = x.asin();
	      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return halfPi.minus(x);
	    };
	    /*
	     * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
	     * value of this Decimal.
	     *
	     * Domain: [1, Infinity]
	     * Range: [0, Infinity]
	     *
	     * acosh(x) = ln(x + sqrt(x^2 - 1))
	     *
	     * acosh(x < 1)     = NaN
	     * acosh(NaN)       = NaN
	     * acosh(Infinity)  = Infinity
	     * acosh(-Infinity) = NaN
	     * acosh(0)         = NaN
	     * acosh(-0)        = NaN
	     * acosh(1)         = 0
	     * acosh(-1)        = NaN
	     *
	     */


	    P.inverseHyperbolicCosine = P.acosh = function () {
	      var pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
	      if (!x.isFinite()) return new Ctor(x);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
	      Ctor.rounding = 1;
	      external = false;
	      x = x.times(x).minus(1).sqrt().plus(x);
	      external = true;
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return x.ln();
	    };
	    /*
	     * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
	     * of this Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-Infinity, Infinity]
	     *
	     * asinh(x) = ln(x + sqrt(x^2 + 1))
	     *
	     * asinh(NaN)       = NaN
	     * asinh(Infinity)  = Infinity
	     * asinh(-Infinity) = -Infinity
	     * asinh(0)         = 0
	     * asinh(-0)        = -0
	     *
	     */


	    P.inverseHyperbolicSine = P.asinh = function () {
	      var pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite() || x.isZero()) return new Ctor(x);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
	      Ctor.rounding = 1;
	      external = false;
	      x = x.times(x).plus(1).sqrt().plus(x);
	      external = true;
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return x.ln();
	    };
	    /*
	     * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
	     * value of this Decimal.
	     *
	     * Domain: [-1, 1]
	     * Range: [-Infinity, Infinity]
	     *
	     * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
	     *
	     * atanh(|x| > 1)   = NaN
	     * atanh(NaN)       = NaN
	     * atanh(Infinity)  = NaN
	     * atanh(-Infinity) = NaN
	     * atanh(0)         = 0
	     * atanh(-0)        = -0
	     * atanh(1)         = Infinity
	     * atanh(-1)        = -Infinity
	     *
	     */


	    P.inverseHyperbolicTangent = P.atanh = function () {
	      var pr,
	          rm,
	          wpr,
	          xsd,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite()) return new Ctor(NaN);
	      if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      xsd = x.sd();
	      if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
	      Ctor.precision = wpr = xsd - x.e;
	      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
	      Ctor.precision = pr + 4;
	      Ctor.rounding = 1;
	      x = x.ln();
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return x.times(0.5);
	    };
	    /*
	     * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
	     * Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-pi/2, pi/2]
	     *
	     * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
	     *
	     * asin(0)       = 0
	     * asin(-0)      = -0
	     * asin(1/2)     = pi/6
	     * asin(-1/2)    = -pi/6
	     * asin(1)       = pi/2
	     * asin(-1)      = -pi/2
	     * asin(|x| > 1) = NaN
	     * asin(NaN)     = NaN
	     *
	     * TODO? Compare performance of Taylor series.
	     *
	     */


	    P.inverseSine = P.asin = function () {
	      var halfPi,
	          k,
	          pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (x.isZero()) return new Ctor(x);
	      k = x.abs().cmp(1);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;

	      if (k !== -1) {
	        // |x| is 1
	        if (k === 0) {
	          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
	          halfPi.s = x.s;
	          return halfPi;
	        } // |x| > 1 or x is NaN


	        return new Ctor(NaN);
	      } // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6


	      Ctor.precision = pr + 6;
	      Ctor.rounding = 1;
	      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return x.times(2);
	    };
	    /*
	     * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
	     * of this Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-pi/2, pi/2]
	     *
	     * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
	     *
	     * atan(0)         = 0
	     * atan(-0)        = -0
	     * atan(1)         = pi/4
	     * atan(-1)        = -pi/4
	     * atan(Infinity)  = pi/2
	     * atan(-Infinity) = -pi/2
	     * atan(NaN)       = NaN
	     *
	     */


	    P.inverseTangent = P.atan = function () {
	      var i,
	          j,
	          k,
	          n,
	          px,
	          t,
	          r,
	          wpr,
	          x2,
	          x = this,
	          Ctor = x.constructor,
	          pr = Ctor.precision,
	          rm = Ctor.rounding;

	      if (!x.isFinite()) {
	        if (!x.s) return new Ctor(NaN);

	        if (pr + 4 <= PI_PRECISION) {
	          r = getPi(Ctor, pr + 4, rm).times(0.5);
	          r.s = x.s;
	          return r;
	        }
	      } else if (x.isZero()) {
	        return new Ctor(x);
	      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
	        r = getPi(Ctor, pr + 4, rm).times(0.25);
	        r.s = x.s;
	        return r;
	      }

	      Ctor.precision = wpr = pr + 10;
	      Ctor.rounding = 1; // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);
	      // Argument reduction
	      // Ensure |x| < 0.42
	      // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

	      k = Math.min(28, wpr / LOG_BASE + 2 | 0);

	      for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

	      external = false;
	      j = Math.ceil(wpr / LOG_BASE);
	      n = 1;
	      x2 = x.times(x);
	      r = new Ctor(x);
	      px = x; // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...

	      for (; i !== -1;) {
	        px = px.times(x2);
	        t = r.minus(px.div(n += 2));
	        px = px.times(x2);
	        r = t.plus(px.div(n += 2));
	        if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
	      }

	      if (k) r = r.times(2 << k - 1);
	      external = true;
	      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
	    };
	    /*
	     * Return true if the value of this Decimal is a finite number, otherwise return false.
	     *
	     */


	    P.isFinite = function () {
	      return !!this.d;
	    };
	    /*
	     * Return true if the value of this Decimal is an integer, otherwise return false.
	     *
	     */


	    P.isInteger = P.isInt = function () {
	      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
	    };
	    /*
	     * Return true if the value of this Decimal is NaN, otherwise return false.
	     *
	     */


	    P.isNaN = function () {
	      return !this.s;
	    };
	    /*
	     * Return true if the value of this Decimal is negative, otherwise return false.
	     *
	     */


	    P.isNegative = P.isNeg = function () {
	      return this.s < 0;
	    };
	    /*
	     * Return true if the value of this Decimal is positive, otherwise return false.
	     *
	     */


	    P.isPositive = P.isPos = function () {
	      return this.s > 0;
	    };
	    /*
	     * Return true if the value of this Decimal is 0 or -0, otherwise return false.
	     *
	     */


	    P.isZero = function () {
	      return !!this.d && this.d[0] === 0;
	    };
	    /*
	     * Return true if the value of this Decimal is less than `y`, otherwise return false.
	     *
	     */


	    P.lessThan = P.lt = function (y) {
	      return this.cmp(y) < 0;
	    };
	    /*
	     * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
	     *
	     */


	    P.lessThanOrEqualTo = P.lte = function (y) {
	      return this.cmp(y) < 1;
	    };
	    /*
	     * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * If no base is specified, return log[10](arg).
	     *
	     * log[base](arg) = ln(arg) / ln(base)
	     *
	     * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
	     * otherwise:
	     *
	     * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
	     * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
	     * between the result and the correctly rounded result will be one ulp (unit in the last place).
	     *
	     * log[-b](a)       = NaN
	     * log[0](a)        = NaN
	     * log[1](a)        = NaN
	     * log[NaN](a)      = NaN
	     * log[Infinity](a) = NaN
	     * log[b](0)        = -Infinity
	     * log[b](-0)       = -Infinity
	     * log[b](-a)       = NaN
	     * log[b](1)        = 0
	     * log[b](Infinity) = Infinity
	     * log[b](NaN)      = NaN
	     *
	     * [base] {number|string|Decimal} The base of the logarithm.
	     *
	     */


	    P.logarithm = P.log = function (base) {
	      var isBase10,
	          d,
	          denominator,
	          k,
	          inf,
	          num,
	          sd,
	          r,
	          arg = this,
	          Ctor = arg.constructor,
	          pr = Ctor.precision,
	          rm = Ctor.rounding,
	          guard = 5; // Default base is 10.

	      if (base == null) {
	        base = new Ctor(10);
	        isBase10 = true;
	      } else {
	        base = new Ctor(base);
	        d = base.d; // Return NaN if base is negative, or non-finite, or is 0 or 1.

	        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
	        isBase10 = base.eq(10);
	      }

	      d = arg.d; // Is arg negative, non-finite, 0 or 1?

	      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
	        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
	      } // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
	      // integer power of 10.


	      if (isBase10) {
	        if (d.length > 1) {
	          inf = true;
	        } else {
	          for (k = d[0]; k % 10 === 0;) k /= 10;

	          inf = k !== 1;
	        }
	      }

	      external = false;
	      sd = pr + guard;
	      num = naturalLogarithm(arg, sd);
	      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd); // The result will have 5 rounding digits.

	      r = divide(num, denominator, sd, 1); // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
	      // calculate 10 further digits.
	      //
	      // If the result is known to have an infinite decimal expansion, repeat this until it is clear
	      // that the result is above or below the boundary. Otherwise, if after calculating the 10
	      // further digits, the last 14 are nines, round up and assume the result is exact.
	      // Also assume the result is exact if the last 14 are zero.
	      //
	      // Example of a result that will be incorrectly rounded:
	      // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
	      // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
	      // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
	      // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
	      // place is still 2.6.

	      if (checkRoundingDigits(r.d, k = pr, rm)) {
	        do {
	          sd += 10;
	          num = naturalLogarithm(arg, sd);
	          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
	          r = divide(num, denominator, sd, 1);

	          if (!inf) {
	            // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
	            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
	              r = finalise(r, pr + 1, 0);
	            }

	            break;
	          }
	        } while (checkRoundingDigits(r.d, k += 10, rm));
	      }

	      external = true;
	      return finalise(r, pr, rm);
	    };
	    /*
	     * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
	     *
	     * arguments {number|string|Decimal}
	     *
	    P.max = function () {
	      Array.prototype.push.call(arguments, this);
	      return maxOrMin(this.constructor, arguments, 'lt');
	    };
	     */

	    /*
	     * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
	     *
	     * arguments {number|string|Decimal}
	     *
	    P.min = function () {
	      Array.prototype.push.call(arguments, this);
	      return maxOrMin(this.constructor, arguments, 'gt');
	    };
	     */

	    /*
	     *  n - 0 = n
	     *  n - N = N
	     *  n - I = -I
	     *  0 - n = -n
	     *  0 - 0 = 0
	     *  0 - N = N
	     *  0 - I = -I
	     *  N - n = N
	     *  N - 0 = N
	     *  N - N = N
	     *  N - I = N
	     *  I - n = I
	     *  I - 0 = I
	     *  I - N = N
	     *  I - I = N
	     *
	     * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     */


	    P.minus = P.sub = function (y) {
	      var d,
	          e,
	          i,
	          j,
	          k,
	          len,
	          pr,
	          rm,
	          xd,
	          xe,
	          xLTy,
	          yd,
	          x = this,
	          Ctor = x.constructor;
	      y = new Ctor(y); // If either is not finite...

	      if (!x.d || !y.d) {
	        // Return NaN if either is NaN.
	        if (!x.s || !y.s) y = new Ctor(NaN); // Return y negated if x is finite and y is Infinity.
	        else if (x.d) y.s = -y.s; // Return x if y is finite and x is Infinity.
	        // Return x if both are Infinity with different signs.
	        // Return NaN if both are Infinity with the same sign.
	        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
	        return y;
	      } // If signs differ...


	      if (x.s != y.s) {
	        y.s = -y.s;
	        return x.plus(y);
	      }

	      xd = x.d;
	      yd = y.d;
	      pr = Ctor.precision;
	      rm = Ctor.rounding; // If either is zero...

	      if (!xd[0] || !yd[0]) {
	        // Return y negated if x is zero and y is non-zero.
	        if (yd[0]) y.s = -y.s; // Return x if y is zero and x is non-zero.
	        else if (xd[0]) y = new Ctor(x); // Return zero if both are zero.
	        // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
	        else return new Ctor(rm === 3 ? -0 : 0);
	        return external ? finalise(y, pr, rm) : y;
	      } // x and y are finite, non-zero numbers with the same sign.
	      // Calculate base 1e7 exponents.


	      e = mathfloor(y.e / LOG_BASE);
	      xe = mathfloor(x.e / LOG_BASE);
	      xd = xd.slice();
	      k = xe - e; // If base 1e7 exponents differ...

	      if (k) {
	        xLTy = k < 0;

	        if (xLTy) {
	          d = xd;
	          k = -k;
	          len = yd.length;
	        } else {
	          d = yd;
	          e = xe;
	          len = xd.length;
	        } // Numbers with massively different exponents would result in a very high number of
	        // zeros needing to be prepended, but this can be avoided while still ensuring correct
	        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.


	        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

	        if (k > i) {
	          k = i;
	          d.length = 1;
	        } // Prepend zeros to equalise exponents.


	        d.reverse();

	        for (i = k; i--;) d.push(0);

	        d.reverse(); // Base 1e7 exponents equal.
	      } else {
	        // Check digits to determine which is the bigger number.
	        i = xd.length;
	        len = yd.length;
	        xLTy = i < len;
	        if (xLTy) len = i;

	        for (i = 0; i < len; i++) {
	          if (xd[i] != yd[i]) {
	            xLTy = xd[i] < yd[i];
	            break;
	          }
	        }

	        k = 0;
	      }

	      if (xLTy) {
	        d = xd;
	        xd = yd;
	        yd = d;
	        y.s = -y.s;
	      }

	      len = xd.length; // Append zeros to `xd` if shorter.
	      // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.

	      for (i = yd.length - len; i > 0; --i) xd[len++] = 0; // Subtract yd from xd.


	      for (i = yd.length; i > k;) {
	        if (xd[--i] < yd[i]) {
	          for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;

	          --xd[j];
	          xd[i] += BASE;
	        }

	        xd[i] -= yd[i];
	      } // Remove trailing zeros.


	      for (; xd[--len] === 0;) xd.pop(); // Remove leading zeros and adjust exponent accordingly.


	      for (; xd[0] === 0; xd.shift()) --e; // Zero?


	      if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
	      y.d = xd;
	      y.e = getBase10Exponent(xd, e);
	      return external ? finalise(y, pr, rm) : y;
	    };
	    /*
	     *   n % 0 =  N
	     *   n % N =  N
	     *   n % I =  n
	     *   0 % n =  0
	     *  -0 % n = -0
	     *   0 % 0 =  N
	     *   0 % N =  N
	     *   0 % I =  0
	     *   N % n =  N
	     *   N % 0 =  N
	     *   N % N =  N
	     *   N % I =  N
	     *   I % n =  N
	     *   I % 0 =  N
	     *   I % N =  N
	     *   I % I =  N
	     *
	     * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
	     * `precision` significant digits using rounding mode `rounding`.
	     *
	     * The result depends on the modulo mode.
	     *
	     */


	    P.modulo = P.mod = function (y) {
	      var q,
	          x = this,
	          Ctor = x.constructor;
	      y = new Ctor(y); // Return NaN if x is Infinity or NaN, or y is NaN or 0.

	      if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN); // Return x if y is Infinity or x is 0.

	      if (!y.d || x.d && !x.d[0]) {
	        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
	      } // Prevent rounding of intermediate calculations.


	      external = false;

	      if (Ctor.modulo == 9) {
	        // Euclidian division: q = sign(y) * floor(x / abs(y))
	        // result = x - q * y    where  0 <= result < abs(y)
	        q = divide(x, y.abs(), 0, 3, 1);
	        q.s *= y.s;
	      } else {
	        q = divide(x, y, 0, Ctor.modulo, 1);
	      }

	      q = q.times(y);
	      external = true;
	      return x.minus(q);
	    };
	    /*
	     * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
	     * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     */


	    P.naturalExponential = P.exp = function () {
	      return naturalExponential(this);
	    };
	    /*
	     * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
	     * rounded to `precision` significant digits using rounding mode `rounding`.
	     *
	     */


	    P.naturalLogarithm = P.ln = function () {
	      return naturalLogarithm(this);
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
	     * -1.
	     *
	     */


	    P.negated = P.neg = function () {
	      var x = new this.constructor(this);
	      x.s = -x.s;
	      return finalise(x);
	    };
	    /*
	     *  n + 0 = n
	     *  n + N = N
	     *  n + I = I
	     *  0 + n = n
	     *  0 + 0 = 0
	     *  0 + N = N
	     *  0 + I = I
	     *  N + n = N
	     *  N + 0 = N
	     *  N + N = N
	     *  N + I = N
	     *  I + n = I
	     *  I + 0 = I
	     *  I + N = N
	     *  I + I = I
	     *
	     * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     */


	    P.plus = P.add = function (y) {
	      var carry,
	          d,
	          e,
	          i,
	          k,
	          len,
	          pr,
	          rm,
	          xd,
	          yd,
	          x = this,
	          Ctor = x.constructor;
	      y = new Ctor(y); // If either is not finite...

	      if (!x.d || !y.d) {
	        // Return NaN if either is NaN.
	        if (!x.s || !y.s) y = new Ctor(NaN); // Return x if y is finite and x is Infinity.
	        // Return x if both are Infinity with the same sign.
	        // Return NaN if both are Infinity with different signs.
	        // Return y if x is finite and y is Infinity.
	        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
	        return y;
	      } // If signs differ...


	      if (x.s != y.s) {
	        y.s = -y.s;
	        return x.minus(y);
	      }

	      xd = x.d;
	      yd = y.d;
	      pr = Ctor.precision;
	      rm = Ctor.rounding; // If either is zero...

	      if (!xd[0] || !yd[0]) {
	        // Return x if y is zero.
	        // Return y if y is non-zero.
	        if (!yd[0]) y = new Ctor(x);
	        return external ? finalise(y, pr, rm) : y;
	      } // x and y are finite, non-zero numbers with the same sign.
	      // Calculate base 1e7 exponents.


	      k = mathfloor(x.e / LOG_BASE);
	      e = mathfloor(y.e / LOG_BASE);
	      xd = xd.slice();
	      i = k - e; // If base 1e7 exponents differ...

	      if (i) {
	        if (i < 0) {
	          d = xd;
	          i = -i;
	          len = yd.length;
	        } else {
	          d = yd;
	          e = k;
	          len = xd.length;
	        } // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.


	        k = Math.ceil(pr / LOG_BASE);
	        len = k > len ? k + 1 : len + 1;

	        if (i > len) {
	          i = len;
	          d.length = 1;
	        } // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.


	        d.reverse();

	        for (; i--;) d.push(0);

	        d.reverse();
	      }

	      len = xd.length;
	      i = yd.length; // If yd is longer than xd, swap xd and yd so xd points to the longer array.

	      if (len - i < 0) {
	        i = len;
	        d = yd;
	        yd = xd;
	        xd = d;
	      } // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.


	      for (carry = 0; i;) {
	        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
	        xd[i] %= BASE;
	      }

	      if (carry) {
	        xd.unshift(carry);
	        ++e;
	      } // Remove trailing zeros.
	      // No need to check for zero, as +x + +y != 0 && -x + -y != 0


	      for (len = xd.length; xd[--len] == 0;) xd.pop();

	      y.d = xd;
	      y.e = getBase10Exponent(xd, e);
	      return external ? finalise(y, pr, rm) : y;
	    };
	    /*
	     * Return the number of significant digits of the value of this Decimal.
	     *
	     * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
	     *
	     */


	    P.precision = P.sd = function (z) {
	      var k,
	          x = this;
	      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

	      if (x.d) {
	        k = getPrecision(x.d);
	        if (z && x.e + 1 > k) k = x.e + 1;
	      } else {
	        k = NaN;
	      }

	      return k;
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
	     * rounding mode `rounding`.
	     *
	     */


	    P.round = function () {
	      var x = this,
	          Ctor = x.constructor;
	      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
	    };
	    /*
	     * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-1, 1]
	     *
	     * sin(x) = x - x^3/3! + x^5/5! - ...
	     *
	     * sin(0)         = 0
	     * sin(-0)        = -0
	     * sin(Infinity)  = NaN
	     * sin(-Infinity) = NaN
	     * sin(NaN)       = NaN
	     *
	     */


	    P.sine = P.sin = function () {
	      var pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite()) return new Ctor(NaN);
	      if (x.isZero()) return new Ctor(x);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
	      Ctor.rounding = 1;
	      x = sine(Ctor, toLessThanHalfPi(Ctor, x));
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
	    };
	    /*
	     * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     *  sqrt(-n) =  N
	     *  sqrt(N)  =  N
	     *  sqrt(-I) =  N
	     *  sqrt(I)  =  I
	     *  sqrt(0)  =  0
	     *  sqrt(-0) = -0
	     *
	     */


	    P.squareRoot = P.sqrt = function () {
	      var m,
	          n,
	          sd,
	          r,
	          rep,
	          t,
	          x = this,
	          d = x.d,
	          e = x.e,
	          s = x.s,
	          Ctor = x.constructor; // Negative/NaN/Infinity/zero?

	      if (s !== 1 || !d || !d[0]) {
	        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
	      }

	      external = false; // Initial estimate.

	      s = Math.sqrt(+x); // Math.sqrt underflow/overflow?
	      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.

	      if (s == 0 || s == 1 / 0) {
	        n = digitsToString(d);
	        if ((n.length + e) % 2 == 0) n += '0';
	        s = Math.sqrt(n);
	        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

	        if (s == 1 / 0) {
	          n = '5e' + e;
	        } else {
	          n = s.toExponential();
	          n = n.slice(0, n.indexOf('e') + 1) + e;
	        }

	        r = new Ctor(n);
	      } else {
	        r = new Ctor(s.toString());
	      }

	      sd = (e = Ctor.precision) + 3; // Newton-Raphson iteration.

	      for (;;) {
	        t = r;
	        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5); // TODO? Replace with for-loop and checkRoundingDigits.

	        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
	          n = n.slice(sd - 3, sd + 1); // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
	          // 4999, i.e. approaching a rounding boundary, continue the iteration.

	          if (n == '9999' || !rep && n == '4999') {
	            // On the first iteration only, check to see if rounding up gives the exact result as the
	            // nines may infinitely repeat.
	            if (!rep) {
	              finalise(t, e + 1, 0);

	              if (t.times(t).eq(x)) {
	                r = t;
	                break;
	              }
	            }

	            sd += 4;
	            rep = 1;
	          } else {
	            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
	            // If not, then there are further digits and m will be truthy.
	            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
	              // Truncate to the first rounding digit.
	              finalise(r, e + 1, 1);
	              m = !r.times(r).eq(x);
	            }

	            break;
	          }
	        }
	      }

	      external = true;
	      return finalise(r, e, Ctor.rounding, m);
	    };
	    /*
	     * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-Infinity, Infinity]
	     *
	     * tan(0)         = 0
	     * tan(-0)        = -0
	     * tan(Infinity)  = NaN
	     * tan(-Infinity) = NaN
	     * tan(NaN)       = NaN
	     *
	     */


	    P.tangent = P.tan = function () {
	      var pr,
	          rm,
	          x = this,
	          Ctor = x.constructor;
	      if (!x.isFinite()) return new Ctor(NaN);
	      if (x.isZero()) return new Ctor(x);
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      Ctor.precision = pr + 10;
	      Ctor.rounding = 1;
	      x = x.sin();
	      x.s = 1;
	      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
	      Ctor.precision = pr;
	      Ctor.rounding = rm;
	      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
	    };
	    /*
	     *  n * 0 = 0
	     *  n * N = N
	     *  n * I = I
	     *  0 * n = 0
	     *  0 * 0 = 0
	     *  0 * N = N
	     *  0 * I = N
	     *  N * n = N
	     *  N * 0 = N
	     *  N * N = N
	     *  N * I = N
	     *  I * n = I
	     *  I * 0 = N
	     *  I * N = N
	     *  I * I = I
	     *
	     * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     */


	    P.times = P.mul = function (y) {
	      var carry,
	          e,
	          i,
	          k,
	          r,
	          rL,
	          t,
	          xdL,
	          ydL,
	          x = this,
	          Ctor = x.constructor,
	          xd = x.d,
	          yd = (y = new Ctor(y)).d;
	      y.s *= x.s; // If either is NaN, Infinity or 0...

	      if (!xd || !xd[0] || !yd || !yd[0]) {
	        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd // Return NaN if either is NaN.
	        // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
	        ? NaN // Return Infinity if either is Infinity.
	        // Return 0 if either is 0.
	        : !xd || !yd ? y.s / 0 : y.s * 0);
	      }

	      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
	      xdL = xd.length;
	      ydL = yd.length; // Ensure xd points to the longer array.

	      if (xdL < ydL) {
	        r = xd;
	        xd = yd;
	        yd = r;
	        rL = xdL;
	        xdL = ydL;
	        ydL = rL;
	      } // Initialise the result array with zeros.


	      r = [];
	      rL = xdL + ydL;

	      for (i = rL; i--;) r.push(0); // Multiply!


	      for (i = ydL; --i >= 0;) {
	        carry = 0;

	        for (k = xdL + i; k > i;) {
	          t = r[k] + yd[i] * xd[k - i - 1] + carry;
	          r[k--] = t % BASE | 0;
	          carry = t / BASE | 0;
	        }

	        r[k] = (r[k] + carry) % BASE | 0;
	      } // Remove trailing zeros.


	      for (; !r[--rL];) r.pop();

	      if (carry) ++e;else r.shift();
	      y.d = r;
	      y.e = getBase10Exponent(r, e);
	      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
	    };
	    /*
	     * Return a string representing the value of this Decimal in base 2, round to `sd` significant
	     * digits using rounding mode `rm`.
	     *
	     * If the optional `sd` argument is present then return binary exponential notation.
	     *
	     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     */


	    P.toBinary = function (sd, rm) {
	      return toStringBinary(this, 2, sd, rm);
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
	     * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
	     *
	     * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     */


	    P.toDecimalPlaces = P.toDP = function (dp, rm) {
	      var x = this,
	          Ctor = x.constructor;
	      x = new Ctor(x);
	      if (dp === void 0) return x;
	      checkInt32(dp, 0, MAX_DIGITS);
	      if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
	      return finalise(x, dp + x.e + 1, rm);
	    };
	    /*
	     * Return a string representing the value of this Decimal in exponential notation rounded to
	     * `dp` fixed decimal places using rounding mode `rounding`.
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     */


	    P.toExponential = function (dp, rm) {
	      var str,
	          x = this,
	          Ctor = x.constructor;

	      if (dp === void 0) {
	        str = finiteToString(x, true);
	      } else {
	        checkInt32(dp, 0, MAX_DIGITS);
	        if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
	        x = finalise(new Ctor(x), dp + 1, rm);
	        str = finiteToString(x, true, dp + 1);
	      }

	      return x.isNeg() && !x.isZero() ? '-' + str : str;
	    };
	    /*
	     * Return a string representing the value of this Decimal in normal (fixed-point) notation to
	     * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
	     * omitted.
	     *
	     * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
	     *
	     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
	     * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
	     * (-0).toFixed(3) is '0.000'.
	     * (-0.5).toFixed(0) is '-0'.
	     *
	     */


	    P.toFixed = function (dp, rm) {
	      var str,
	          y,
	          x = this,
	          Ctor = x.constructor;

	      if (dp === void 0) {
	        str = finiteToString(x);
	      } else {
	        checkInt32(dp, 0, MAX_DIGITS);
	        if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
	        y = finalise(new Ctor(x), dp + x.e + 1, rm);
	        str = finiteToString(y, false, dp + y.e + 1);
	      } // To determine whether to add the minus sign look at the value before it was rounded,
	      // i.e. look at `x` rather than `y`.


	      return x.isNeg() && !x.isZero() ? '-' + str : str;
	    };
	    /*
	     * Return an array representing the value of this Decimal as a simple fraction with an integer
	     * numerator and an integer denominator.
	     *
	     * The denominator will be a positive non-zero value less than or equal to the specified maximum
	     * denominator. If a maximum denominator is not specified, the denominator will be the lowest
	     * value necessary to represent the number exactly.
	     *
	     * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
	     *
	     */


	    P.toFraction = function (maxD) {
	      var d,
	          d0,
	          d1,
	          d2,
	          e,
	          k,
	          n,
	          n0,
	          n1,
	          pr,
	          q,
	          r,
	          x = this,
	          xd = x.d,
	          Ctor = x.constructor;
	      if (!xd) return new Ctor(x);
	      n1 = d0 = new Ctor(1);
	      d1 = n0 = new Ctor(0);
	      d = new Ctor(d1);
	      e = d.e = getPrecision(xd) - x.e - 1;
	      k = e % LOG_BASE;
	      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

	      if (maxD == null) {
	        // d is 10**e, the minimum max-denominator needed.
	        maxD = e > 0 ? d : n1;
	      } else {
	        n = new Ctor(maxD);
	        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
	        maxD = n.gt(d) ? e > 0 ? d : n1 : n;
	      }

	      external = false;
	      n = new Ctor(digitsToString(xd));
	      pr = Ctor.precision;
	      Ctor.precision = e = xd.length * LOG_BASE * 2;

	      for (;;) {
	        q = divide(n, d, 0, 1, 1);
	        d2 = d0.plus(q.times(d1));
	        if (d2.cmp(maxD) == 1) break;
	        d0 = d1;
	        d1 = d2;
	        d2 = n1;
	        n1 = n0.plus(q.times(d2));
	        n0 = d2;
	        d2 = d;
	        d = n.minus(q.times(d2));
	        n = d2;
	      }

	      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
	      n0 = n0.plus(d2.times(n1));
	      d0 = d0.plus(d2.times(d1));
	      n0.s = n1.s = x.s; // Determine which fraction is closer to x, n0/d0 or n1/d1?

	      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
	      Ctor.precision = pr;
	      external = true;
	      return r;
	    };
	    /*
	     * Return a string representing the value of this Decimal in base 16, round to `sd` significant
	     * digits using rounding mode `rm`.
	     *
	     * If the optional `sd` argument is present then return binary exponential notation.
	     *
	     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     */


	    P.toHexadecimal = P.toHex = function (sd, rm) {
	      return toStringBinary(this, 16, sd, rm);
	    };
	    /*
	     * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
	     * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
	     *
	     * The return value will always have the same sign as this Decimal, unless either this Decimal
	     * or `y` is NaN, in which case the return value will be also be NaN.
	     *
	     * The return value is not affected by the value of `precision`.
	     *
	     * y {number|string|Decimal} The magnitude to round to a multiple of.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * 'toNearest() rounding mode not an integer: {rm}'
	     * 'toNearest() rounding mode out of range: {rm}'
	     *
	     */


	    P.toNearest = function (y, rm) {
	      var x = this,
	          Ctor = x.constructor;
	      x = new Ctor(x);

	      if (y == null) {
	        // If x is not finite, return x.
	        if (!x.d) return x;
	        y = new Ctor(1);
	        rm = Ctor.rounding;
	      } else {
	        y = new Ctor(y);

	        if (rm === void 0) {
	          rm = Ctor.rounding;
	        } else {
	          checkInt32(rm, 0, 8);
	        } // If x is not finite, return x if y is not NaN, else NaN.


	        if (!x.d) return y.s ? x : y; // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.

	        if (!y.d) {
	          if (y.s) y.s = x.s;
	          return y;
	        }
	      } // If y is not zero, calculate the nearest multiple of y to x.


	      if (y.d[0]) {
	        external = false;
	        x = divide(x, y, 0, rm, 1).times(y);
	        external = true;
	        finalise(x); // If y is zero, return zero with the sign of x.
	      } else {
	        y.s = x.s;
	        x = y;
	      }

	      return x;
	    };
	    /*
	     * Return the value of this Decimal converted to a number primitive.
	     * Zero keeps its sign.
	     *
	     */


	    P.toNumber = function () {
	      return +this;
	    };
	    /*
	     * Return a string representing the value of this Decimal in base 8, round to `sd` significant
	     * digits using rounding mode `rm`.
	     *
	     * If the optional `sd` argument is present then return binary exponential notation.
	     *
	     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     */


	    P.toOctal = function (sd, rm) {
	      return toStringBinary(this, 8, sd, rm);
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
	     * to `precision` significant digits using rounding mode `rounding`.
	     *
	     * ECMAScript compliant.
	     *
	     *   pow(x, NaN)                           = NaN
	     *   pow(x, 0)                            = 1
	       *   pow(NaN, non-zero)                    = NaN
	     *   pow(abs(x) > 1, +Infinity)            = +Infinity
	     *   pow(abs(x) > 1, -Infinity)            = +0
	     *   pow(abs(x) == 1, Infinity)           = NaN
	     *   pow(abs(x) < 1, +Infinity)            = +0
	     *   pow(abs(x) < 1, -Infinity)            = +Infinity
	     *   pow(+Infinity, y > 0)                 = +Infinity
	     *   pow(+Infinity, y < 0)                 = +0
	     *   pow(-Infinity, odd integer > 0)       = -Infinity
	     *   pow(-Infinity, even integer > 0)      = +Infinity
	     *   pow(-Infinity, odd integer < 0)       = -0
	     *   pow(-Infinity, even integer < 0)      = +0
	     *   pow(+0, y > 0)                        = +0
	     *   pow(+0, y < 0)                        = +Infinity
	     *   pow(-0, odd integer > 0)              = -0
	     *   pow(-0, even integer > 0)             = +0
	     *   pow(-0, odd integer < 0)              = -Infinity
	     *   pow(-0, even integer < 0)             = +Infinity
	     *   pow(finite x < 0, finite non-integer) = NaN
	     *
	     * For non-integer or very large exponents pow(x, y) is calculated using
	     *
	     *   x^y = exp(y*ln(x))
	     *
	     * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
	     * probability of an incorrectly rounded result
	     * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
	     * i.e. 1 in 250,000,000,000,000
	     *
	     * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
	     *
	     * y {number|string|Decimal} The power to which to raise this Decimal.
	     *
	     */


	    P.toPower = P.pow = function (y) {
	      var e,
	          k,
	          pr,
	          r,
	          rm,
	          s,
	          x = this,
	          Ctor = x.constructor,
	          yn = +(y = new Ctor(y)); // Either Infinity, NaN or 0?

	      if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
	      x = new Ctor(x);
	      if (x.eq(1)) return x;
	      pr = Ctor.precision;
	      rm = Ctor.rounding;
	      if (y.eq(1)) return finalise(x, pr, rm); // y exponent

	      e = mathfloor(y.e / LOG_BASE); // If y is a small integer use the 'exponentiation by squaring' algorithm.

	      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
	        r = intPow(Ctor, x, k, pr);
	        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
	      }

	      s = x.s; // if x is negative

	      if (s < 0) {
	        // if y is not an integer
	        if (e < y.d.length - 1) return new Ctor(NaN); // Result is positive if x is negative and the last digit of integer y is even.

	        if ((y.d[e] & 1) == 0) s = 1; // if x.eq(-1)

	        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
	          x.s = s;
	          return x;
	        }
	      } // Estimate result exponent.
	      // x^y = 10^e,  where e = y * log10(x)
	      // log10(x) = log10(x_significand) + x_exponent
	      // log10(x_significand) = ln(x_significand) / ln(10)


	      k = mathpow(+x, yn);
	      e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + '').e; // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.
	      // Overflow/underflow?

	      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
	      external = false;
	      Ctor.rounding = x.s = 1; // Estimate the extra guard digits needed to ensure five correct rounding digits from
	      // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
	      // new Decimal(2.32456).pow('2087987436534566.46411')
	      // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815

	      k = Math.min(12, (e + '').length); // r = x^y = exp(y*ln(x))

	      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr); // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)

	      if (r.d) {
	        // Truncate to the required precision plus five rounding digits.
	        r = finalise(r, pr + 5, 1); // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
	        // the result.

	        if (checkRoundingDigits(r.d, pr, rm)) {
	          e = pr + 10; // Truncate to the increased precision plus five rounding digits.

	          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1); // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).

	          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
	            r = finalise(r, pr + 1, 0);
	          }
	        }
	      }

	      r.s = s;
	      external = true;
	      Ctor.rounding = rm;
	      return finalise(r, pr, rm);
	    };
	    /*
	     * Return a string representing the value of this Decimal rounded to `sd` significant digits
	     * using rounding mode `rounding`.
	     *
	     * Return exponential notation if `sd` is less than the number of digits necessary to represent
	     * the integer part of the value in normal notation.
	     *
	     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     */


	    P.toPrecision = function (sd, rm) {
	      var str,
	          x = this,
	          Ctor = x.constructor;

	      if (sd === void 0) {
	        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
	      } else {
	        checkInt32(sd, 1, MAX_DIGITS);
	        if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
	        x = finalise(new Ctor(x), sd, rm);
	        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
	      }

	      return x.isNeg() && !x.isZero() ? '-' + str : str;
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
	     * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
	     * omitted.
	     *
	     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
	     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	     *
	     * 'toSD() digits out of range: {sd}'
	     * 'toSD() digits not an integer: {sd}'
	     * 'toSD() rounding mode not an integer: {rm}'
	     * 'toSD() rounding mode out of range: {rm}'
	     *
	     */


	    P.toSignificantDigits = P.toSD = function (sd, rm) {
	      var x = this,
	          Ctor = x.constructor;

	      if (sd === void 0) {
	        sd = Ctor.precision;
	        rm = Ctor.rounding;
	      } else {
	        checkInt32(sd, 1, MAX_DIGITS);
	        if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
	      }

	      return finalise(new Ctor(x), sd, rm);
	    };
	    /*
	     * Return a string representing the value of this Decimal.
	     *
	     * Return exponential notation if this Decimal has a positive exponent equal to or greater than
	     * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
	     *
	     */


	    P.toString = function () {
	      var x = this,
	          Ctor = x.constructor,
	          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
	      return x.isNeg() && !x.isZero() ? '-' + str : str;
	    };
	    /*
	     * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
	     *
	     */


	    P.truncated = P.trunc = function () {
	      return finalise(new this.constructor(this), this.e + 1, 1);
	    };
	    /*
	     * Return a string representing the value of this Decimal.
	     * Unlike `toString`, negative zero will include the minus sign.
	     *
	     */


	    P.valueOf = P.toJSON = function () {
	      var x = this,
	          Ctor = x.constructor,
	          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
	      return x.isNeg() ? '-' + str : str;
	    }; // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.

	    /*
	     *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
	     *                           finiteToString, naturalExponential, naturalLogarithm
	     *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
	     *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
	     *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
	     *  convertBase              toStringBinary, parseOther
	     *  cos                      P.cos
	     *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
	     *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
	     *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
	     *                           taylorSeries, atan2, parseOther
	     *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
	     *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
	     *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
	     *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
	     *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
	     *                           P.truncated, divide, getLn10, getPi, naturalExponential,
	     *                           naturalLogarithm, ceil, floor, round, trunc
	     *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
	     *                           toStringBinary
	     *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
	     *  getLn10                  P.logarithm, naturalLogarithm
	     *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
	     *  getPrecision             P.precision, P.toFraction
	     *  getZeroString            digitsToString, finiteToString
	     *  intPow                   P.toPower, parseOther
	     *  isOdd                    toLessThanHalfPi
	     *  maxOrMin                 max, min
	     *  naturalExponential       P.naturalExponential, P.toPower
	     *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
	     *                           P.toPower, naturalExponential
	     *  nonFiniteToString        finiteToString, toStringBinary
	     *  parseDecimal             Decimal
	     *  parseOther               Decimal
	     *  sin                      P.sin
	     *  taylorSeries             P.cosh, P.sinh, cos, sin
	     *  toLessThanHalfPi         P.cos, P.sin
	     *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
	     *  truncate                 intPow
	     *
	     *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
	     *                           naturalLogarithm, config, parseOther, random, Decimal
	     */


	    function digitsToString(d) {
	      var i,
	          k,
	          ws,
	          indexOfLastWord = d.length - 1,
	          str = '',
	          w = d[0];

	      if (indexOfLastWord > 0) {
	        str += w;

	        for (i = 1; i < indexOfLastWord; i++) {
	          ws = d[i] + '';
	          k = LOG_BASE - ws.length;
	          if (k) str += getZeroString(k);
	          str += ws;
	        }

	        w = d[i];
	        ws = w + '';
	        k = LOG_BASE - ws.length;
	        if (k) str += getZeroString(k);
	      } else if (w === 0) {
	        return '0';
	      } // Remove trailing zeros of last w.


	      for (; w % 10 === 0;) w /= 10;

	      return str + w;
	    }

	    function checkInt32(i, min, max) {
	      if (i !== ~~i || i < min || i > max) {
	        throw Error(invalidArgument + i);
	      }
	    }
	    /*
	     * Check 5 rounding digits if `repeating` is null, 4 otherwise.
	     * `repeating == null` if caller is `log` or `pow`,
	     * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
	     */


	    function checkRoundingDigits(d, i, rm, repeating) {
	      var di, k, r, rd; // Get the length of the first word of the array d.

	      for (k = d[0]; k >= 10; k /= 10) --i; // Is the rounding digit in the first word of d?


	      if (--i < 0) {
	        i += LOG_BASE;
	        di = 0;
	      } else {
	        di = Math.ceil((i + 1) / LOG_BASE);
	        i %= LOG_BASE;
	      } // i is the index (0 - 6) of the rounding digit.
	      // E.g. if within the word 3487563 the first rounding digit is 5,
	      // then i = 4, k = 1000, rd = 3487563 % 1000 = 563


	      k = mathpow(10, LOG_BASE - i);
	      rd = d[di] % k | 0;

	      if (repeating == null) {
	        if (i < 3) {
	          if (i == 0) rd = rd / 100 | 0;else if (i == 1) rd = rd / 10 | 0;
	          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
	        } else {
	          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
	        }
	      } else {
	        if (i < 4) {
	          if (i == 0) rd = rd / 1000 | 0;else if (i == 1) rd = rd / 100 | 0;else if (i == 2) rd = rd / 10 | 0;
	          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
	        } else {
	          r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
	        }
	      }

	      return r;
	    } // Convert string of `baseIn` to an array of numbers of `baseOut`.
	    // Eg. convertBase('255', 10, 16) returns [15, 15].
	    // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].


	    function convertBase(str, baseIn, baseOut) {
	      var j,
	          arr = [0],
	          arrL,
	          i = 0,
	          strL = str.length;

	      for (; i < strL;) {
	        for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;

	        arr[0] += NUMERALS.indexOf(str.charAt(i++));

	        for (j = 0; j < arr.length; j++) {
	          if (arr[j] > baseOut - 1) {
	            if (arr[j + 1] === void 0) arr[j + 1] = 0;
	            arr[j + 1] += arr[j] / baseOut | 0;
	            arr[j] %= baseOut;
	          }
	        }
	      }

	      return arr.reverse();
	    }
	    /*
	     * cos(x) = 1 - x^2/2! + x^4/4! - ...
	     * |x| < pi/2
	     *
	     */


	    function cosine(Ctor, x) {
	      var k, len, y;
	      if (x.isZero()) return x; // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
	      // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1
	      // Estimate the optimum number of times to use the argument reduction.

	      len = x.d.length;

	      if (len < 32) {
	        k = Math.ceil(len / 3);
	        y = (1 / tinyPow(4, k)).toString();
	      } else {
	        k = 16;
	        y = '2.3283064365386962890625e-10';
	      }

	      Ctor.precision += k;
	      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1)); // Reverse argument reduction

	      for (var i = k; i--;) {
	        var cos2x = x.times(x);
	        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
	      }

	      Ctor.precision -= k;
	      return x;
	    }
	    /*
	     * Perform division in the specified base.
	     */


	    var divide = function () {
	      // Assumes non-zero x and k, and hence non-zero result.
	      function multiplyInteger(x, k, base) {
	        var temp,
	            carry = 0,
	            i = x.length;

	        for (x = x.slice(); i--;) {
	          temp = x[i] * k + carry;
	          x[i] = temp % base | 0;
	          carry = temp / base | 0;
	        }

	        if (carry) x.unshift(carry);
	        return x;
	      }

	      function compare(a, b, aL, bL) {
	        var i, r;

	        if (aL != bL) {
	          r = aL > bL ? 1 : -1;
	        } else {
	          for (i = r = 0; i < aL; i++) {
	            if (a[i] != b[i]) {
	              r = a[i] > b[i] ? 1 : -1;
	              break;
	            }
	          }
	        }

	        return r;
	      }

	      function subtract(a, b, aL, base) {
	        var i = 0; // Subtract b from a.

	        for (; aL--;) {
	          a[aL] -= i;
	          i = a[aL] < b[aL] ? 1 : 0;
	          a[aL] = i * base + a[aL] - b[aL];
	        } // Remove leading zeros.


	        for (; !a[0] && a.length > 1;) a.shift();
	      }

	      return function (x, y, pr, rm, dp, base) {
	        var cmp,
	            e,
	            i,
	            k,
	            logBase,
	            more,
	            prod,
	            prodL,
	            q,
	            qd,
	            rem,
	            remL,
	            rem0,
	            sd,
	            t,
	            xi,
	            xL,
	            yd0,
	            yL,
	            yz,
	            Ctor = x.constructor,
	            sign = x.s == y.s ? 1 : -1,
	            xd = x.d,
	            yd = y.d; // Either NaN, Infinity or 0?

	        if (!xd || !xd[0] || !yd || !yd[0]) {
	          return new Ctor( // Return NaN if either NaN, or both Infinity or 0.
	          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
	          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
	        }

	        if (base) {
	          logBase = 1;
	          e = x.e - y.e;
	        } else {
	          base = BASE;
	          logBase = LOG_BASE;
	          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
	        }

	        yL = yd.length;
	        xL = xd.length;
	        q = new Ctor(sign);
	        qd = q.d = []; // Result exponent may be one less than e.
	        // The digit array of a Decimal from toStringBinary may have trailing zeros.

	        for (i = 0; yd[i] == (xd[i] || 0); i++);

	        if (yd[i] > (xd[i] || 0)) e--;

	        if (pr == null) {
	          sd = pr = Ctor.precision;
	          rm = Ctor.rounding;
	        } else if (dp) {
	          sd = pr + (x.e - y.e) + 1;
	        } else {
	          sd = pr;
	        }

	        if (sd < 0) {
	          qd.push(1);
	          more = true;
	        } else {
	          // Convert precision in number of base 10 digits to base 1e7 digits.
	          sd = sd / logBase + 2 | 0;
	          i = 0; // divisor < 1e7

	          if (yL == 1) {
	            k = 0;
	            yd = yd[0];
	            sd++; // k is the carry.

	            for (; (i < xL || k) && sd--; i++) {
	              t = k * base + (xd[i] || 0);
	              qd[i] = t / yd | 0;
	              k = t % yd | 0;
	            }

	            more = k || i < xL; // divisor >= 1e7
	          } else {
	            // Normalise xd and yd so highest order digit of yd is >= base/2
	            k = base / (yd[0] + 1) | 0;

	            if (k > 1) {
	              yd = multiplyInteger(yd, k, base);
	              xd = multiplyInteger(xd, k, base);
	              yL = yd.length;
	              xL = xd.length;
	            }

	            xi = yL;
	            rem = xd.slice(0, yL);
	            remL = rem.length; // Add zeros to make remainder as long as divisor.

	            for (; remL < yL;) rem[remL++] = 0;

	            yz = yd.slice();
	            yz.unshift(0);
	            yd0 = yd[0];
	            if (yd[1] >= base / 2) ++yd0;

	            do {
	              k = 0; // Compare divisor and remainder.

	              cmp = compare(yd, rem, yL, remL); // If divisor < remainder.

	              if (cmp < 0) {
	                // Calculate trial digit, k.
	                rem0 = rem[0];
	                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0); // k will be how many times the divisor goes into the current remainder.

	                k = rem0 / yd0 | 0; //  Algorithm:
	                //  1. product = divisor * trial digit (k)
	                //  2. if product > remainder: product -= divisor, k--
	                //  3. remainder -= product
	                //  4. if product was < remainder at 2:
	                //    5. compare new remainder and divisor
	                //    6. If remainder > divisor: remainder -= divisor, k++

	                if (k > 1) {
	                  if (k >= base) k = base - 1; // product = divisor * trial digit.

	                  prod = multiplyInteger(yd, k, base);
	                  prodL = prod.length;
	                  remL = rem.length; // Compare product and remainder.

	                  cmp = compare(prod, rem, prodL, remL); // product > remainder.

	                  if (cmp == 1) {
	                    k--; // Subtract divisor from product.

	                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
	                  }
	                } else {
	                  // cmp is -1.
	                  // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
	                  // to avoid it. If k is 1 there is a need to compare yd and rem again below.
	                  if (k == 0) cmp = k = 1;
	                  prod = yd.slice();
	                }

	                prodL = prod.length;
	                if (prodL < remL) prod.unshift(0); // Subtract product from remainder.

	                subtract(rem, prod, remL, base); // If product was < previous remainder.

	                if (cmp == -1) {
	                  remL = rem.length; // Compare divisor and new remainder.

	                  cmp = compare(yd, rem, yL, remL); // If divisor < new remainder, subtract divisor from remainder.

	                  if (cmp < 1) {
	                    k++; // Subtract divisor from remainder.

	                    subtract(rem, yL < remL ? yz : yd, remL, base);
	                  }
	                }

	                remL = rem.length;
	              } else if (cmp === 0) {
	                k++;
	                rem = [0];
	              } // if cmp === 1, k will be 0
	              // Add the next digit, k, to the result array.


	              qd[i++] = k; // Update the remainder.

	              if (cmp && rem[0]) {
	                rem[remL++] = xd[xi] || 0;
	              } else {
	                rem = [xd[xi]];
	                remL = 1;
	              }
	            } while ((xi++ < xL || rem[0] !== void 0) && sd--);

	            more = rem[0] !== void 0;
	          } // Leading zero?


	          if (!qd[0]) qd.shift();
	        } // logBase is 1 when divide is being used for base conversion.


	        if (logBase == 1) {
	          q.e = e;
	          inexact = more;
	        } else {
	          // To calculate q.e, first get the number of digits of qd[0].
	          for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;

	          q.e = i + e * logBase - 1;
	          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
	        }

	        return q;
	      };
	    }();
	    /*
	     * Round `x` to `sd` significant digits using rounding mode `rm`.
	     * Check for over/under-flow.
	     */


	    function finalise(x, sd, rm, isTruncated) {
	      var digits,
	          i,
	          j,
	          k,
	          rd,
	          roundUp,
	          w,
	          xd,
	          xdi,
	          Ctor = x.constructor; // Don't round if sd is null or undefined.

	      out: if (sd != null) {
	        xd = x.d; // Infinity/NaN.

	        if (!xd) return x; // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
	        // w: the word of xd containing rd, a base 1e7 number.
	        // xdi: the index of w within xd.
	        // digits: the number of digits of w.
	        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
	        // they had leading zeros)
	        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).
	        // Get the length of the first word of the digits array xd.

	        for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;

	        i = sd - digits; // Is the rounding digit in the first word of xd?

	        if (i < 0) {
	          i += LOG_BASE;
	          j = sd;
	          w = xd[xdi = 0]; // Get the rounding digit at index j of w.

	          rd = w / mathpow(10, digits - j - 1) % 10 | 0;
	        } else {
	          xdi = Math.ceil((i + 1) / LOG_BASE);
	          k = xd.length;

	          if (xdi >= k) {
	            if (isTruncated) {
	              // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
	              for (; k++ <= xdi;) xd.push(0);

	              w = rd = 0;
	              digits = 1;
	              i %= LOG_BASE;
	              j = i - LOG_BASE + 1;
	            } else {
	              break out;
	            }
	          } else {
	            w = k = xd[xdi]; // Get the number of digits of w.

	            for (digits = 1; k >= 10; k /= 10) digits++; // Get the index of rd within w.


	            i %= LOG_BASE; // Get the index of rd within w, adjusted for leading zeros.
	            // The number of leading zeros of w is given by LOG_BASE - digits.

	            j = i - LOG_BASE + digits; // Get the rounding digit at index j of w.

	            rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
	          }
	        } // Are there any non-zero digits after the rounding digit?


	        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1)); // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
	        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
	        // will give 714.

	        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
	        (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));

	        if (sd < 1 || !xd[0]) {
	          xd.length = 0;

	          if (roundUp) {
	            // Convert sd to decimal places.
	            sd -= x.e + 1; // 1, 0.1, 0.01, 0.001, 0.0001 etc.

	            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
	            x.e = -sd || 0;
	          } else {
	            // Zero.
	            xd[0] = x.e = 0;
	          }

	          return x;
	        } // Remove excess digits.


	        if (i == 0) {
	          xd.length = xdi;
	          k = 1;
	          xdi--;
	        } else {
	          xd.length = xdi + 1;
	          k = mathpow(10, LOG_BASE - i); // E.g. 56700 becomes 56000 if 7 is the rounding digit.
	          // j > 0 means i > number of leading zeros of w.

	          xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
	        }

	        if (roundUp) {
	          for (;;) {
	            // Is the digit to be rounded up in the first word of xd?
	            if (xdi == 0) {
	              // i will be the length of xd[0] before k is added.
	              for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;

	              j = xd[0] += k;

	              for (k = 1; j >= 10; j /= 10) k++; // if i != k the length has increased.


	              if (i != k) {
	                x.e++;
	                if (xd[0] == BASE) xd[0] = 1;
	              }

	              break;
	            } else {
	              xd[xdi] += k;
	              if (xd[xdi] != BASE) break;
	              xd[xdi--] = 0;
	              k = 1;
	            }
	          }
	        } // Remove trailing zeros.


	        for (i = xd.length; xd[--i] === 0;) xd.pop();
	      }

	      if (external) {
	        // Overflow?
	        if (x.e > Ctor.maxE) {
	          // Infinity.
	          x.d = null;
	          x.e = NaN; // Underflow?
	        } else if (x.e < Ctor.minE) {
	          // Zero.
	          x.e = 0;
	          x.d = [0]; // Ctor.underflow = true;
	        } // else Ctor.underflow = false;

	      }

	      return x;
	    }

	    function finiteToString(x, isExp, sd) {
	      if (!x.isFinite()) return nonFiniteToString(x);
	      var k,
	          e = x.e,
	          str = digitsToString(x.d),
	          len = str.length;

	      if (isExp) {
	        if (sd && (k = sd - len) > 0) {
	          str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
	        } else if (len > 1) {
	          str = str.charAt(0) + '.' + str.slice(1);
	        }

	        str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
	      } else if (e < 0) {
	        str = '0.' + getZeroString(-e - 1) + str;
	        if (sd && (k = sd - len) > 0) str += getZeroString(k);
	      } else if (e >= len) {
	        str += getZeroString(e + 1 - len);
	        if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
	      } else {
	        if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);

	        if (sd && (k = sd - len) > 0) {
	          if (e + 1 === len) str += '.';
	          str += getZeroString(k);
	        }
	      }

	      return str;
	    } // Calculate the base 10 exponent from the base 1e7 exponent.


	    function getBase10Exponent(digits, e) {
	      var w = digits[0]; // Add the number of digits of the first word of the digits array.

	      for (e *= LOG_BASE; w >= 10; w /= 10) e++;

	      return e;
	    }

	    function getLn10(Ctor, sd, pr) {
	      if (sd > LN10_PRECISION) {
	        // Reset global state in case the exception is caught.
	        external = true;
	        if (pr) Ctor.precision = pr;
	        throw Error(precisionLimitExceeded);
	      }

	      return finalise(new Ctor(LN10), sd, 1, true);
	    }

	    function getPi(Ctor, sd, rm) {
	      if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
	      return finalise(new Ctor(PI), sd, rm, true);
	    }

	    function getPrecision(digits) {
	      var w = digits.length - 1,
	          len = w * LOG_BASE + 1;
	      w = digits[w]; // If non-zero...

	      if (w) {
	        // Subtract the number of trailing zeros of the last word.
	        for (; w % 10 == 0; w /= 10) len--; // Add the number of digits of the first word.


	        for (w = digits[0]; w >= 10; w /= 10) len++;
	      }

	      return len;
	    }

	    function getZeroString(k) {
	      var zs = '';

	      for (; k--;) zs += '0';

	      return zs;
	    }
	    /*
	     * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
	     * integer of type number.
	     *
	     * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
	     *
	     */


	    function intPow(Ctor, x, n, pr) {
	      var isTruncated,
	          r = new Ctor(1),
	          // Max n of 9007199254740991 takes 53 loop iterations.
	      // Maximum digits array length; leaves [28, 34] guard digits.
	      k = Math.ceil(pr / LOG_BASE + 4);
	      external = false;

	      for (;;) {
	        if (n % 2) {
	          r = r.times(x);
	          if (truncate(r.d, k)) isTruncated = true;
	        }

	        n = mathfloor(n / 2);

	        if (n === 0) {
	          // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
	          n = r.d.length - 1;
	          if (isTruncated && r.d[n] === 0) ++r.d[n];
	          break;
	        }

	        x = x.times(x);
	        truncate(x.d, k);
	      }

	      external = true;
	      return r;
	    }

	    function isOdd(n) {
	      return n.d[n.d.length - 1] & 1;
	    }
	    /*
	     * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
	     */


	    function maxOrMin(Ctor, args, ltgt) {
	      var y,
	          x = new Ctor(args[0]),
	          i = 0;

	      for (; ++i < args.length;) {
	        y = new Ctor(args[i]);

	        if (!y.s) {
	          x = y;
	          break;
	        } else if (x[ltgt](y)) {
	          x = y;
	        }
	      }

	      return x;
	    }
	    /*
	     * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
	     * digits.
	     *
	     * Taylor/Maclaurin series.
	     *
	     * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
	     *
	     * Argument reduction:
	     *   Repeat x = x / 32, k += 5, until |x| < 0.1
	     *   exp(x) = exp(x / 2^k)^(2^k)
	     *
	     * Previously, the argument was initially reduced by
	     * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
	     * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
	     * found to be slower than just dividing repeatedly by 32 as above.
	     *
	     * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
	     * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
	     * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
	     *
	     *  exp(Infinity)  = Infinity
	     *  exp(-Infinity) = 0
	     *  exp(NaN)       = NaN
	     *  exp(0)        = 1
	     *
	     *  exp(x) is non-terminating for any finite, non-zero x.
	     *
	     *  The result will always be correctly rounded.
	     *
	     */


	    function naturalExponential(x, sd) {
	      var denominator,
	          guard,
	          j,
	          pow,
	          sum,
	          t,
	          wpr,
	          rep = 0,
	          i = 0,
	          k = 0,
	          Ctor = x.constructor,
	          rm = Ctor.rounding,
	          pr = Ctor.precision; // 0/NaN/Infinity?

	      if (!x.d || !x.d[0] || x.e > 17) {
	        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
	      }

	      if (sd == null) {
	        external = false;
	        wpr = pr;
	      } else {
	        wpr = sd;
	      }

	      t = new Ctor(0.03125); // while abs(x) >= 0.1

	      while (x.e > -2) {
	        // x = x / 2^5
	        x = x.times(t);
	        k += 5;
	      } // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
	      // necessary to ensure the first 4 rounding digits are correct.


	      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
	      wpr += guard;
	      denominator = pow = sum = new Ctor(1);
	      Ctor.precision = wpr;

	      for (;;) {
	        pow = finalise(pow.times(x), wpr, 1);
	        denominator = denominator.times(++i);
	        t = sum.plus(divide(pow, denominator, wpr, 1));

	        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
	          j = k;

	          while (j--) sum = finalise(sum.times(sum), wpr, 1); // Check to see if the first 4 rounding digits are [49]999.
	          // If so, repeat the summation with a higher precision, otherwise
	          // e.g. with precision: 18, rounding: 1
	          // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
	          // `wpr - guard` is the index of first rounding digit.


	          if (sd == null) {
	            if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
	              Ctor.precision = wpr += 10;
	              denominator = pow = t = new Ctor(1);
	              i = 0;
	              rep++;
	            } else {
	              return finalise(sum, Ctor.precision = pr, rm, external = true);
	            }
	          } else {
	            Ctor.precision = pr;
	            return sum;
	          }
	        }

	        sum = t;
	      }
	    }
	    /*
	     * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
	     * digits.
	     *
	     *  ln(-n)        = NaN
	     *  ln(0)         = -Infinity
	     *  ln(-0)        = -Infinity
	     *  ln(1)         = 0
	     *  ln(Infinity)  = Infinity
	     *  ln(-Infinity) = NaN
	     *  ln(NaN)       = NaN
	     *
	     *  ln(n) (n != 1) is non-terminating.
	     *
	     */


	    function naturalLogarithm(y, sd) {
	      var c,
	          c0,
	          denominator,
	          e,
	          numerator,
	          rep,
	          sum,
	          t,
	          wpr,
	          x1,
	          x2,
	          n = 1,
	          guard = 10,
	          x = y,
	          xd = x.d,
	          Ctor = x.constructor,
	          rm = Ctor.rounding,
	          pr = Ctor.precision; // Is x negative or Infinity, NaN, 0 or 1?

	      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
	        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
	      }

	      if (sd == null) {
	        external = false;
	        wpr = pr;
	      } else {
	        wpr = sd;
	      }

	      Ctor.precision = wpr += guard;
	      c = digitsToString(xd);
	      c0 = c.charAt(0);

	      if (Math.abs(e = x.e) < 1.5e15) {
	        // Argument reduction.
	        // The series converges faster the closer the argument is to 1, so using
	        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
	        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
	        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
	        // later be divided by this number, then separate out the power of 10 using
	        // ln(a*10^b) = ln(a) + b*ln(10).
	        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
	        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
	        // max n is 6 (gives 0.7 - 1.3)
	        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
	          x = x.times(y);
	          c = digitsToString(x.d);
	          c0 = c.charAt(0);
	          n++;
	        }

	        e = x.e;

	        if (c0 > 1) {
	          x = new Ctor('0.' + c);
	          e++;
	        } else {
	          x = new Ctor(c0 + '.' + c.slice(1));
	        }
	      } else {
	        // The argument reduction method above may result in overflow if the argument y is a massive
	        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
	        // function using ln(x*10^e) = ln(x) + e*ln(10).
	        t = getLn10(Ctor, wpr + 2, pr).times(e + '');
	        x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
	        Ctor.precision = pr;
	        return sd == null ? finalise(x, pr, rm, external = true) : x;
	      } // x1 is x reduced to a value near 1.


	      x1 = x; // Taylor series.
	      // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
	      // where x = (y - 1)/(y + 1)    (|x| < 1)

	      sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
	      x2 = finalise(x.times(x), wpr, 1);
	      denominator = 3;

	      for (;;) {
	        numerator = finalise(numerator.times(x2), wpr, 1);
	        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

	        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
	          sum = sum.times(2); // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
	          // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.

	          if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
	          sum = divide(sum, new Ctor(n), wpr, 1); // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
	          // been repeated previously) and the first 4 rounding digits 9999?
	          // If so, restart the summation with a higher precision, otherwise
	          // e.g. with precision: 12, rounding: 1
	          // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
	          // `wpr - guard` is the index of first rounding digit.

	          if (sd == null) {
	            if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
	              Ctor.precision = wpr += guard;
	              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
	              x2 = finalise(x.times(x), wpr, 1);
	              denominator = rep = 1;
	            } else {
	              return finalise(sum, Ctor.precision = pr, rm, external = true);
	            }
	          } else {
	            Ctor.precision = pr;
	            return sum;
	          }
	        }

	        sum = t;
	        denominator += 2;
	      }
	    } // Infinity, NaN.


	    function nonFiniteToString(x) {
	      // Unsigned.
	      return String(x.s * x.s / 0);
	    }
	    /*
	     * Parse the value of a new Decimal `x` from string `str`.
	     */


	    function parseDecimal(x, str) {
	      var e, i, len; // Decimal point?

	      if ((e = str.indexOf('.')) > -1) str = str.replace('.', ''); // Exponential form?

	      if ((i = str.search(/e/i)) > 0) {
	        // Determine exponent.
	        if (e < 0) e = i;
	        e += +str.slice(i + 1);
	        str = str.substring(0, i);
	      } else if (e < 0) {
	        // Integer.
	        e = str.length;
	      } // Determine leading zeros.


	      for (i = 0; str.charCodeAt(i) === 48; i++); // Determine trailing zeros.


	      for (len = str.length; str.charCodeAt(len - 1) === 48; --len);

	      str = str.slice(i, len);

	      if (str) {
	        len -= i;
	        x.e = e = e - i - 1;
	        x.d = []; // Transform base
	        // e is the base 10 exponent.
	        // i is where to slice str to get the first word of the digits array.

	        i = (e + 1) % LOG_BASE;
	        if (e < 0) i += LOG_BASE;

	        if (i < len) {
	          if (i) x.d.push(+str.slice(0, i));

	          for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));

	          str = str.slice(i);
	          i = LOG_BASE - str.length;
	        } else {
	          i -= len;
	        }

	        for (; i--;) str += '0';

	        x.d.push(+str);

	        if (external) {
	          // Overflow?
	          if (x.e > x.constructor.maxE) {
	            // Infinity.
	            x.d = null;
	            x.e = NaN; // Underflow?
	          } else if (x.e < x.constructor.minE) {
	            // Zero.
	            x.e = 0;
	            x.d = [0]; // x.constructor.underflow = true;
	          } // else x.constructor.underflow = false;

	        }
	      } else {
	        // Zero.
	        x.e = 0;
	        x.d = [0];
	      }

	      return x;
	    }
	    /*
	     * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
	     */


	    function parseOther(x, str) {
	      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

	      if (str.indexOf('_') > -1) {
	        str = str.replace(/(\d)_(?=\d)/g, '$1');
	        if (isDecimal.test(str)) return parseDecimal(x, str);
	      } else if (str === 'Infinity' || str === 'NaN') {
	        if (!+str) x.s = NaN;
	        x.e = NaN;
	        x.d = null;
	        return x;
	      }

	      if (isHex.test(str)) {
	        base = 16;
	        str = str.toLowerCase();
	      } else if (isBinary.test(str)) {
	        base = 2;
	      } else if (isOctal.test(str)) {
	        base = 8;
	      } else {
	        throw Error(invalidArgument + str);
	      } // Is there a binary exponent part?


	      i = str.search(/p/i);

	      if (i > 0) {
	        p = +str.slice(i + 1);
	        str = str.substring(2, i);
	      } else {
	        str = str.slice(2);
	      } // Convert `str` as an integer then divide the result by `base` raised to a power such that the
	      // fraction part will be restored.


	      i = str.indexOf('.');
	      isFloat = i >= 0;
	      Ctor = x.constructor;

	      if (isFloat) {
	        str = str.replace('.', '');
	        len = str.length;
	        i = len - i; // log[10](16) = 1.2041... , log[10](88) = 1.9444....

	        divisor = intPow(Ctor, new Ctor(base), i, i * 2);
	      }

	      xd = convertBase(str, base, BASE);
	      xe = xd.length - 1; // Remove trailing zeros.

	      for (i = xe; xd[i] === 0; --i) xd.pop();

	      if (i < 0) return new Ctor(x.s * 0);
	      x.e = getBase10Exponent(xd, xe);
	      x.d = xd;
	      external = false; // At what precision to perform the division to ensure exact conversion?
	      // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
	      // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
	      // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
	      // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
	      // Therefore using 4 * the number of digits of str will always be enough.

	      if (isFloat) x = divide(x, divisor, len * 4); // Multiply by the binary exponent part if present.

	      if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
	      external = true;
	      return x;
	    }
	    /*
	     * sin(x) = x - x^3/3! + x^5/5! - ...
	     * |x| < pi/2
	     *
	     */


	    function sine(Ctor, x) {
	      var k,
	          len = x.d.length;

	      if (len < 3) {
	        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
	      } // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
	      // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
	      // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))
	      // Estimate the optimum number of times to use the argument reduction.


	      k = 1.4 * Math.sqrt(len);
	      k = k > 16 ? 16 : k | 0;
	      x = x.times(1 / tinyPow(5, k));
	      x = taylorSeries(Ctor, 2, x, x); // Reverse argument reduction

	      var sin2_x,
	          d5 = new Ctor(5),
	          d16 = new Ctor(16),
	          d20 = new Ctor(20);

	      for (; k--;) {
	        sin2_x = x.times(x);
	        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
	      }

	      return x;
	    } // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.


	    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
	      var j,
	          t,
	          u,
	          x2,
	          pr = Ctor.precision,
	          k = Math.ceil(pr / LOG_BASE);
	      external = false;
	      x2 = x.times(x);
	      u = new Ctor(y);

	      for (;;) {
	        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
	        u = isHyperbolic ? y.plus(t) : y.minus(t);
	        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
	        t = u.plus(y);

	        if (t.d[k] !== void 0) {
	          for (j = k; t.d[j] === u.d[j] && j--;);

	          if (j == -1) break;
	        }

	        j = u;
	        u = y;
	        y = t;
	        t = j;
	      }

	      external = true;
	      t.d.length = k + 1;
	      return t;
	    } // Exponent e must be positive and non-zero.


	    function tinyPow(b, e) {
	      var n = b;

	      while (--e) n *= b;

	      return n;
	    } // Return the absolute value of `x` reduced to less than or equal to half pi.


	    function toLessThanHalfPi(Ctor, x) {
	      var t,
	          isNeg = x.s < 0,
	          pi = getPi(Ctor, Ctor.precision, 1),
	          halfPi = pi.times(0.5);
	      x = x.abs();

	      if (x.lte(halfPi)) {
	        quadrant = isNeg ? 4 : 1;
	        return x;
	      }

	      t = x.divToInt(pi);

	      if (t.isZero()) {
	        quadrant = isNeg ? 3 : 2;
	      } else {
	        x = x.minus(t.times(pi)); // 0 <= x < pi

	        if (x.lte(halfPi)) {
	          quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
	          return x;
	        }

	        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
	      }

	      return x.minus(pi).abs();
	    }
	    /*
	     * Return the value of Decimal `x` as a string in base `baseOut`.
	     *
	     * If the optional `sd` argument is present include a binary exponent suffix.
	     */


	    function toStringBinary(x, baseOut, sd, rm) {
	      var base,
	          e,
	          i,
	          k,
	          len,
	          roundUp,
	          str,
	          xd,
	          y,
	          Ctor = x.constructor,
	          isExp = sd !== void 0;

	      if (isExp) {
	        checkInt32(sd, 1, MAX_DIGITS);
	        if (rm === void 0) rm = Ctor.rounding;else checkInt32(rm, 0, 8);
	      } else {
	        sd = Ctor.precision;
	        rm = Ctor.rounding;
	      }

	      if (!x.isFinite()) {
	        str = nonFiniteToString(x);
	      } else {
	        str = finiteToString(x);
	        i = str.indexOf('.'); // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
	        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
	        // minBinaryExponent = floor(decimalExponent * log[2](10))
	        // log[2](10) = 3.321928094887362347870319429489390175864

	        if (isExp) {
	          base = 2;

	          if (baseOut == 16) {
	            sd = sd * 4 - 3;
	          } else if (baseOut == 8) {
	            sd = sd * 3 - 2;
	          }
	        } else {
	          base = baseOut;
	        } // Convert the number as an integer then divide the result by its base raised to a power such
	        // that the fraction part will be restored.
	        // Non-integer.


	        if (i >= 0) {
	          str = str.replace('.', '');
	          y = new Ctor(1);
	          y.e = str.length - i;
	          y.d = convertBase(finiteToString(y), 10, base);
	          y.e = y.d.length;
	        }

	        xd = convertBase(str, 10, base);
	        e = len = xd.length; // Remove trailing zeros.

	        for (; xd[--len] == 0;) xd.pop();

	        if (!xd[0]) {
	          str = isExp ? '0p+0' : '0';
	        } else {
	          if (i < 0) {
	            e--;
	          } else {
	            x = new Ctor(x);
	            x.d = xd;
	            x.e = e;
	            x = divide(x, y, sd, rm, 0, base);
	            xd = x.d;
	            e = x.e;
	            roundUp = inexact;
	          } // The rounding digit, i.e. the digit after the digit that may be rounded up.


	          i = xd[sd];
	          k = base / 2;
	          roundUp = roundUp || xd[sd + 1] !== void 0;
	          roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
	          xd.length = sd;

	          if (roundUp) {
	            // Rounding up may mean the previous digit has to be rounded up and so on.
	            for (; ++xd[--sd] > base - 1;) {
	              xd[sd] = 0;

	              if (!sd) {
	                ++e;
	                xd.unshift(1);
	              }
	            }
	          } // Determine trailing zeros.


	          for (len = xd.length; !xd[len - 1]; --len); // E.g. [4, 11, 15] becomes 4bf.


	          for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]); // Add binary exponent suffix?


	          if (isExp) {
	            if (len > 1) {
	              if (baseOut == 16 || baseOut == 8) {
	                i = baseOut == 16 ? 4 : 3;

	                for (--len; len % i; len++) str += '0';

	                xd = convertBase(str, base, baseOut);

	                for (len = xd.length; !xd[len - 1]; --len); // xd[0] will always be be 1


	                for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
	              } else {
	                str = str.charAt(0) + '.' + str.slice(1);
	              }
	            }

	            str = str + (e < 0 ? 'p' : 'p+') + e;
	          } else if (e < 0) {
	            for (; ++e;) str = '0' + str;

	            str = '0.' + str;
	          } else {
	            if (++e > len) for (e -= len; e--;) str += '0';else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
	          }
	        }

	        str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
	      }

	      return x.s < 0 ? '-' + str : str;
	    } // Does not strip trailing zeros.


	    function truncate(arr, len) {
	      if (arr.length > len) {
	        arr.length = len;
	        return true;
	      }
	    } // Decimal methods

	    /*
	     *  abs
	     *  acos
	     *  acosh
	     *  add
	     *  asin
	     *  asinh
	     *  atan
	     *  atanh
	     *  atan2
	     *  cbrt
	     *  ceil
	     *  clamp
	     *  clone
	     *  config
	     *  cos
	     *  cosh
	     *  div
	     *  exp
	     *  floor
	     *  hypot
	     *  ln
	     *  log
	     *  log2
	     *  log10
	     *  max
	     *  min
	     *  mod
	     *  mul
	     *  pow
	     *  random
	     *  round
	     *  set
	     *  sign
	     *  sin
	     *  sinh
	     *  sqrt
	     *  sub
	     *  sum
	     *  tan
	     *  tanh
	     *  trunc
	     */

	    /*
	     * Return a new Decimal whose value is the absolute value of `x`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function abs(x) {
	      return new this(x).abs();
	    }
	    /*
	     * Return a new Decimal whose value is the arccosine in radians of `x`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function acos(x) {
	      return new this(x).acos();
	    }
	    /*
	     * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
	     * `precision` significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function acosh(x) {
	      return new this(x).acosh();
	    }
	    /*
	     * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     * y {number|string|Decimal}
	     *
	     */


	    function add(x, y) {
	      return new this(x).plus(y);
	    }
	    /*
	     * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function asin(x) {
	      return new this(x).asin();
	    }
	    /*
	     * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
	     * `precision` significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function asinh(x) {
	      return new this(x).asinh();
	    }
	    /*
	     * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function atan(x) {
	      return new this(x).atan();
	    }
	    /*
	     * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
	     * `precision` significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function atanh(x) {
	      return new this(x).atanh();
	    }
	    /*
	     * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
	     * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
	     *
	     * Domain: [-Infinity, Infinity]
	     * Range: [-pi, pi]
	     *
	     * y {number|string|Decimal} The y-coordinate.
	     * x {number|string|Decimal} The x-coordinate.
	     *
	     * atan2(0, -0)               = pi
	     * atan2(0, +0)               = 0
	     * atan2(0, -x)               = pi for x > 0
	     * atan2(0, x)                = 0 for x > 0
	     * atan2(-y, 0)               = -pi/2 for y > 0
	     * atan2(y, 0)                = pi/2 for y > 0
	     * atan2(y, -Infinity)        = pi for finite y > 0
	     * atan2(y, +Infinity)        = 0 for finite y > 0
	     * atan2(Infinity, x)         = pi/2 for finite x
	     * atan2(Infinity, -Infinity) = 3*pi/4
	     * atan2(Infinity, +Infinity) = pi/4
	     * atan2(NaN, x) = NaN
	     * atan2(y, NaN) = NaN
	     *
	     */


	    function atan2(y, x) {
	      y = new this(y);
	      x = new this(x);
	      var r,
	          pr = this.precision,
	          rm = this.rounding,
	          wpr = pr + 4; // Either NaN

	      if (!y.s || !x.s) {
	        r = new this(NaN); // Both Infinity
	      } else if (!y.d && !x.d) {
	        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
	        r.s = y.s; // x is Infinity or y is 0
	      } else if (!x.d || y.isZero()) {
	        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
	        r.s = y.s; // y is Infinity or x is 0
	      } else if (!y.d || x.isZero()) {
	        r = getPi(this, wpr, 1).times(0.5);
	        r.s = y.s; // Both non-zero and finite
	      } else if (x.s < 0) {
	        this.precision = wpr;
	        this.rounding = 1;
	        r = this.atan(divide(y, x, wpr, 1));
	        x = getPi(this, wpr, 1);
	        this.precision = pr;
	        this.rounding = rm;
	        r = y.s < 0 ? r.minus(x) : r.plus(x);
	      } else {
	        r = this.atan(divide(y, x, wpr, 1));
	      }

	      return r;
	    }
	    /*
	     * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function cbrt(x) {
	      return new this(x).cbrt();
	    }
	    /*
	     * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function ceil(x) {
	      return finalise(x = new this(x), x.e + 1, 2);
	    }
	    /*
	     * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
	     *
	     * x {number|string|Decimal}
	     * min {number|string|Decimal}
	     * max {number|string|Decimal}
	     *
	     */


	    function clamp(x, min, max) {
	      return new this(x).clamp(min, max);
	    }
	    /*
	     * Configure global settings for a Decimal constructor.
	     *
	     * `obj` is an object with one or more of the following properties,
	     *
	     *   precision  {number}
	     *   rounding   {number}
	     *   toExpNeg   {number}
	     *   toExpPos   {number}
	     *   maxE       {number}
	     *   minE       {number}
	     *   modulo     {number}
	     *   crypto     {boolean|number}
	     *   defaults   {true}
	     *
	     * E.g. Decimal.config({ precision: 20, rounding: 4 })
	     *
	     */


	    function config(obj) {
	      if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
	      var i,
	          p,
	          v,
	          useDefaults = obj.defaults === true,
	          ps = ['precision', 1, MAX_DIGITS, 'rounding', 0, 8, 'toExpNeg', -EXP_LIMIT, 0, 'toExpPos', 0, EXP_LIMIT, 'maxE', 0, EXP_LIMIT, 'minE', -EXP_LIMIT, 0, 'modulo', 0, 9];

	      for (i = 0; i < ps.length; i += 3) {
	        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];

	        if ((v = obj[p]) !== void 0) {
	          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;else throw Error(invalidArgument + p + ': ' + v);
	        }
	      }

	      if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];

	      if ((v = obj[p]) !== void 0) {
	        if (v === true || v === false || v === 0 || v === 1) {
	          if (v) {
	            if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
	              this[p] = true;
	            } else {
	              throw Error(cryptoUnavailable);
	            }
	          } else {
	            this[p] = false;
	          }
	        } else {
	          throw Error(invalidArgument + p + ': ' + v);
	        }
	      }

	      return this;
	    }
	    /*
	     * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function cos(x) {
	      return new this(x).cos();
	    }
	    /*
	     * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function cosh(x) {
	      return new this(x).cosh();
	    }
	    /*
	     * Create and return a Decimal constructor with the same configuration properties as this Decimal
	     * constructor.
	     *
	     */


	    function clone(obj) {
	      var i, p, ps;
	      /*
	       * The Decimal constructor and exported function.
	       * Return a new Decimal instance.
	       *
	       * v {number|string|Decimal} A numeric value.
	       *
	       */

	      function Decimal(v) {
	        var e,
	            i,
	            t,
	            x = this; // Decimal called without new.

	        if (!(x instanceof Decimal)) return new Decimal(v); // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
	        // which points to Object.

	        x.constructor = Decimal; // Duplicate.

	        if (isDecimalInstance(v)) {
	          x.s = v.s;

	          if (external) {
	            if (!v.d || v.e > Decimal.maxE) {
	              // Infinity.
	              x.e = NaN;
	              x.d = null;
	            } else if (v.e < Decimal.minE) {
	              // Zero.
	              x.e = 0;
	              x.d = [0];
	            } else {
	              x.e = v.e;
	              x.d = v.d.slice();
	            }
	          } else {
	            x.e = v.e;
	            x.d = v.d ? v.d.slice() : v.d;
	          }

	          return;
	        }

	        t = typeof v;

	        if (t === 'number') {
	          if (v === 0) {
	            x.s = 1 / v < 0 ? -1 : 1;
	            x.e = 0;
	            x.d = [0];
	            return;
	          }

	          if (v < 0) {
	            v = -v;
	            x.s = -1;
	          } else {
	            x.s = 1;
	          } // Fast path for small integers.


	          if (v === ~~v && v < 1e7) {
	            for (e = 0, i = v; i >= 10; i /= 10) e++;

	            if (external) {
	              if (e > Decimal.maxE) {
	                x.e = NaN;
	                x.d = null;
	              } else if (e < Decimal.minE) {
	                x.e = 0;
	                x.d = [0];
	              } else {
	                x.e = e;
	                x.d = [v];
	              }
	            } else {
	              x.e = e;
	              x.d = [v];
	            }

	            return; // Infinity, NaN.
	          } else if (v * 0 !== 0) {
	            if (!v) x.s = NaN;
	            x.e = NaN;
	            x.d = null;
	            return;
	          }

	          return parseDecimal(x, v.toString());
	        } else if (t !== 'string') {
	          throw Error(invalidArgument + v);
	        } // Minus sign?


	        if ((i = v.charCodeAt(0)) === 45) {
	          v = v.slice(1);
	          x.s = -1;
	        } else {
	          // Plus sign?
	          if (i === 43) v = v.slice(1);
	          x.s = 1;
	        }

	        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
	      }

	      Decimal.prototype = P;
	      Decimal.ROUND_UP = 0;
	      Decimal.ROUND_DOWN = 1;
	      Decimal.ROUND_CEIL = 2;
	      Decimal.ROUND_FLOOR = 3;
	      Decimal.ROUND_HALF_UP = 4;
	      Decimal.ROUND_HALF_DOWN = 5;
	      Decimal.ROUND_HALF_EVEN = 6;
	      Decimal.ROUND_HALF_CEIL = 7;
	      Decimal.ROUND_HALF_FLOOR = 8;
	      Decimal.EUCLID = 9;
	      Decimal.config = Decimal.set = config;
	      Decimal.clone = clone;
	      Decimal.isDecimal = isDecimalInstance;
	      Decimal.abs = abs;
	      Decimal.acos = acos;
	      Decimal.acosh = acosh; // ES6

	      Decimal.add = add;
	      Decimal.asin = asin;
	      Decimal.asinh = asinh; // ES6

	      Decimal.atan = atan;
	      Decimal.atanh = atanh; // ES6

	      Decimal.atan2 = atan2;
	      Decimal.cbrt = cbrt; // ES6

	      Decimal.ceil = ceil;
	      Decimal.clamp = clamp;
	      Decimal.cos = cos;
	      Decimal.cosh = cosh; // ES6

	      Decimal.div = div;
	      Decimal.exp = exp;
	      Decimal.floor = floor;
	      Decimal.hypot = hypot; // ES6

	      Decimal.ln = ln;
	      Decimal.log = log;
	      Decimal.log10 = log10; // ES6

	      Decimal.log2 = log2; // ES6

	      Decimal.max = max;
	      Decimal.min = min;
	      Decimal.mod = mod;
	      Decimal.mul = mul;
	      Decimal.pow = pow;
	      Decimal.random = random;
	      Decimal.round = round;
	      Decimal.sign = sign; // ES6

	      Decimal.sin = sin;
	      Decimal.sinh = sinh; // ES6

	      Decimal.sqrt = sqrt;
	      Decimal.sub = sub;
	      Decimal.sum = sum;
	      Decimal.tan = tan;
	      Decimal.tanh = tanh; // ES6

	      Decimal.trunc = trunc; // ES6

	      if (obj === void 0) obj = {};

	      if (obj) {
	        if (obj.defaults !== true) {
	          ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];

	          for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
	        }
	      }

	      Decimal.config(obj);
	      return Decimal;
	    }
	    /*
	     * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     * y {number|string|Decimal}
	     *
	     */


	    function div(x, y) {
	      return new this(x).div(y);
	    }
	    /*
	     * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} The power to which to raise the base of the natural log.
	     *
	     */


	    function exp(x) {
	      return new this(x).exp();
	    }
	    /*
	     * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function floor(x) {
	      return finalise(x = new this(x), x.e + 1, 3);
	    }
	    /*
	     * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
	     * rounded to `precision` significant digits using rounding mode `rounding`.
	     *
	     * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
	     *
	     * arguments {number|string|Decimal}
	     *
	     */


	    function hypot() {
	      var i,
	          n,
	          t = new this(0);
	      external = false;

	      for (i = 0; i < arguments.length;) {
	        n = new this(arguments[i++]);

	        if (!n.d) {
	          if (n.s) {
	            external = true;
	            return new this(1 / 0);
	          }

	          t = n;
	        } else if (t.d) {
	          t = t.plus(n.times(n));
	        }
	      }

	      external = true;
	      return t.sqrt();
	    }
	    /*
	     * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
	     * otherwise return false.
	     *
	     */


	    function isDecimalInstance(obj) {
	      return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
	    }
	    /*
	     * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function ln(x) {
	      return new this(x).ln();
	    }
	    /*
	     * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
	     * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
	     *
	     * log[y](x)
	     *
	     * x {number|string|Decimal} The argument of the logarithm.
	     * y {number|string|Decimal} The base of the logarithm.
	     *
	     */


	    function log(x, y) {
	      return new this(x).log(y);
	    }
	    /*
	     * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function log2(x) {
	      return new this(x).log(2);
	    }
	    /*
	     * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function log10(x) {
	      return new this(x).log(10);
	    }
	    /*
	     * Return a new Decimal whose value is the maximum of the arguments.
	     *
	     * arguments {number|string|Decimal}
	     *
	     */


	    function max() {
	      return maxOrMin(this, arguments, 'lt');
	    }
	    /*
	     * Return a new Decimal whose value is the minimum of the arguments.
	     *
	     * arguments {number|string|Decimal}
	     *
	     */


	    function min() {
	      return maxOrMin(this, arguments, 'gt');
	    }
	    /*
	     * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
	     * using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     * y {number|string|Decimal}
	     *
	     */


	    function mod(x, y) {
	      return new this(x).mod(y);
	    }
	    /*
	     * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     * y {number|string|Decimal}
	     *
	     */


	    function mul(x, y) {
	      return new this(x).mul(y);
	    }
	    /*
	     * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} The base.
	     * y {number|string|Decimal} The exponent.
	     *
	     */


	    function pow(x, y) {
	      return new this(x).pow(y);
	    }
	    /*
	     * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
	     * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
	     * are produced).
	     *
	     * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
	     *
	     */


	    function random(sd) {
	      var d,
	          e,
	          k,
	          n,
	          i = 0,
	          r = new this(1),
	          rd = [];
	      if (sd === void 0) sd = this.precision;else checkInt32(sd, 1, MAX_DIGITS);
	      k = Math.ceil(sd / LOG_BASE);

	      if (!this.crypto) {
	        for (; i < k;) rd[i++] = Math.random() * 1e7 | 0; // Browsers supporting crypto.getRandomValues.

	      } else if (crypto.getRandomValues) {
	        d = crypto.getRandomValues(new Uint32Array(k));

	        for (; i < k;) {
	          n = d[i]; // 0 <= n < 4294967296
	          // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).

	          if (n >= 4.29e9) {
	            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
	          } else {
	            // 0 <= n <= 4289999999
	            // 0 <= (n % 1e7) <= 9999999
	            rd[i++] = n % 1e7;
	          }
	        } // Node.js supporting crypto.randomBytes.

	      } else if (crypto.randomBytes) {
	        // buffer
	        d = crypto.randomBytes(k *= 4);

	        for (; i < k;) {
	          // 0 <= n < 2147483648
	          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24); // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).

	          if (n >= 2.14e9) {
	            crypto.randomBytes(4).copy(d, i);
	          } else {
	            // 0 <= n <= 2139999999
	            // 0 <= (n % 1e7) <= 9999999
	            rd.push(n % 1e7);
	            i += 4;
	          }
	        }

	        i = k / 4;
	      } else {
	        throw Error(cryptoUnavailable);
	      }

	      k = rd[--i];
	      sd %= LOG_BASE; // Convert trailing digits to zeros according to sd.

	      if (k && sd) {
	        n = mathpow(10, LOG_BASE - sd);
	        rd[i] = (k / n | 0) * n;
	      } // Remove trailing words which are zero.


	      for (; rd[i] === 0; i--) rd.pop(); // Zero?


	      if (i < 0) {
	        e = 0;
	        rd = [0];
	      } else {
	        e = -1; // Remove leading words which are zero and adjust exponent accordingly.

	        for (; rd[0] === 0; e -= LOG_BASE) rd.shift(); // Count the digits of the first word of rd to determine leading zeros.


	        for (k = 1, n = rd[0]; n >= 10; n /= 10) k++; // Adjust the exponent for leading zeros of the first word of rd.


	        if (k < LOG_BASE) e -= LOG_BASE - k;
	      }

	      r.e = e;
	      r.d = rd;
	      return r;
	    }
	    /*
	     * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
	     *
	     * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function round(x) {
	      return finalise(x = new this(x), x.e + 1, this.rounding);
	    }
	    /*
	     * Return
	     *   1    if x > 0,
	     *  -1    if x < 0,
	     *   0    if x is 0,
	     *  -0    if x is -0,
	     *   NaN  otherwise
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function sign(x) {
	      x = new this(x);
	      return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
	    }
	    /*
	     * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
	     * using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function sin(x) {
	      return new this(x).sin();
	    }
	    /*
	     * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function sinh(x) {
	      return new this(x).sinh();
	    }
	    /*
	     * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function sqrt(x) {
	      return new this(x).sqrt();
	    }
	    /*
	     * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
	     * using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal}
	     * y {number|string|Decimal}
	     *
	     */


	    function sub(x, y) {
	      return new this(x).sub(y);
	    }
	    /*
	     * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * Only the result is rounded, not the intermediate calculations.
	     *
	     * arguments {number|string|Decimal}
	     *
	     */


	    function sum() {
	      var i = 0,
	          args = arguments,
	          x = new this(args[i]);
	      external = false;

	      for (; x.s && ++i < args.length;) x = x.plus(args[i]);

	      external = true;
	      return finalise(x, this.precision, this.rounding);
	    }
	    /*
	     * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
	     * digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function tan(x) {
	      return new this(x).tan();
	    }
	    /*
	     * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
	     * significant digits using rounding mode `rounding`.
	     *
	     * x {number|string|Decimal} A value in radians.
	     *
	     */


	    function tanh(x) {
	      return new this(x).tanh();
	    }
	    /*
	     * Return a new Decimal whose value is `x` truncated to an integer.
	     *
	     * x {number|string|Decimal}
	     *
	     */


	    function trunc(x) {
	      return finalise(x = new this(x), x.e + 1, 1);
	    } // Create and configure initial Decimal constructor.


	    Decimal = clone(DEFAULTS);
	    Decimal.prototype.constructor = Decimal;
	    Decimal['default'] = Decimal.Decimal = Decimal; // Create the internal constants from their string values.

	    LN10 = new Decimal(LN10);
	    PI = new Decimal(PI); // Export.
	    // AMD.

	    if (module.exports) {
	      if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {
	        P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;
	        P[Symbol.toStringTag] = 'Decimal';
	      }

	      module.exports = Decimal; // Browser.
	    } else {
	      if (!globalScope) {
	        globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;
	      }

	      noConflict = globalScope.Decimal;

	      Decimal.noConflict = function () {
	        globalScope.Decimal = noConflict;
	        return Decimal;
	      };

	      globalScope.Decimal = Decimal;
	    }
	  })(commonjsGlobal);
	});

	var name$13 = 'BigNumber';
	var dependencies$13 = ['?on', 'config'];
	var createBigNumberClass = /* #__PURE__ */factory(name$13, dependencies$13, _ref => {
	  var {
	    on,
	    config
	  } = _ref;
	  var BigNumber = decimal.clone({
	    precision: config.precision,
	    modulo: decimal.EUCLID
	  });
	  BigNumber.prototype = Object.create(BigNumber.prototype);
	  /**
	   * Attach type information
	   */

	  BigNumber.prototype.type = 'BigNumber';
	  BigNumber.prototype.isBigNumber = true;
	  /**
	   * Get a JSON representation of a BigNumber containing
	   * type information
	   * @returns {Object} Returns a JSON object structured as:
	   *                   `{"mathjs": "BigNumber", "value": "0.2"}`
	   */

	  BigNumber.prototype.toJSON = function () {
	    return {
	      mathjs: 'BigNumber',
	      value: this.toString()
	    };
	  };
	  /**
	   * Instantiate a BigNumber from a JSON object
	   * @param {Object} json  a JSON object structured as:
	   *                       `{"mathjs": "BigNumber", "value": "0.2"}`
	   * @return {BigNumber}
	   */


	  BigNumber.fromJSON = function (json) {
	    return new BigNumber(json.value);
	  };

	  if (on) {
	    // listen for changed in the configuration, automatically apply changed precision
	    on('config', function (curr, prev) {
	      if (curr.precision !== prev.precision) {
	        BigNumber.config({
	          precision: curr.precision
	        });
	      }
	    });
	  }

	  return BigNumber;
	}, {
	  isClass: true
	});

	var complex$1 = createCommonjsModule(function (module, exports) {
	  /**
	   * @license Complex.js v2.1.1 12/05/2020
	   *
	   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
	   * Dual licensed under the MIT or GPL Version 2 licenses.
	   **/

	  /**
	   *
	   * This class allows the manipulation of complex numbers.
	   * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
	   *
	   * Object form
	   * { re: <real>, im: <imaginary> }
	   * { arg: <angle>, abs: <radius> }
	   * { phi: <angle>, r: <radius> }
	   *
	   * Array / Vector form
	   * [ real, imaginary ]
	   *
	   * Double form
	   * 99.3 - Single double value
	   *
	   * String form
	   * '23.1337' - Simple real number
	   * '15+3i' - a simple complex number
	   * '3-i' - a simple complex number
	   *
	   * Example:
	   *
	   * var c = new Complex('99.3+8i');
	   * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
	   *
	   */
	  (function (root) {

	    var cosh = Math.cosh || function (x) {
	      return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
	    };

	    var sinh = Math.sinh || function (x) {
	      return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
	    };
	    /**
	     * Calculates cos(x) - 1 using Taylor series if x is small (-  x  ).
	     *
	     * @param {number} x
	     * @returns {number} cos(x) - 1
	     */


	    var cosm1 = function (x) {
	      var b = Math.PI / 4;

	      if (-b > x || x > b) {
	        return Math.cos(x) - 1.0;
	      }
	      /* Calculate horner form of polynomial of taylor series in Q
	      var fac = 1, alt = 1, pol = {};
	      for (var i = 0; i <= 16; i++) {
	        fac*= i || 1;
	        if (i % 2 == 0) {
	          pol[i] = new Fraction(1, alt * fac);
	          alt = -alt;
	        }
	      }
	      console.log(new Polynomial(pol).toHorner()); // (((((((1/20922789888000x^2-1/87178291200)x^2+1/479001600)x^2-1/3628800)x^2+1/40320)x^2-1/720)x^2+1/24)x^2-1/2)x^2+1
	      */


	      var xx = x * x;
	      return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888000 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
	    };

	    var hypot = function (x, y) {
	      var a = Math.abs(x);
	      var b = Math.abs(y);

	      if (a < 3000 && b < 3000) {
	        return Math.sqrt(a * a + b * b);
	      }

	      if (a < b) {
	        a = b;
	        b = x / y;
	      } else {
	        b = y / x;
	      }

	      return a * Math.sqrt(1 + b * b);
	    };

	    var parser_exit = function () {
	      throw SyntaxError('Invalid Param');
	    };
	    /**
	     * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
	     *
	     * @param {number} a
	     * @param {number} b
	     * @returns {number}
	     */


	    function logHypot(a, b) {
	      var _a = Math.abs(a);

	      var _b = Math.abs(b);

	      if (a === 0) {
	        return Math.log(_b);
	      }

	      if (b === 0) {
	        return Math.log(_a);
	      }

	      if (_a < 3000 && _b < 3000) {
	        return Math.log(a * a + b * b) * 0.5;
	      }
	      /* I got 4 ideas to compute this property without overflow:
	       *
	       * Testing 1000000 times with random samples for a,b  [1, 1000000000] against a big decimal library to get an error estimate
	       *
	       * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)
	        Math.log(a * a + b * b) / 2
	        *
	       *
	       * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)
	        var fn = function(a, b) {
	       a = Math.abs(a);
	       b = Math.abs(b);
	       var t = Math.min(a, b);
	       a = Math.max(a, b);
	       t = t / a;
	        return Math.log(a) + Math.log(1 + t * t) / 2;
	       };
	        * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)
	        Math.log(a / Math.cos(Math.atan2(b, a)))
	        * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)
	        Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))
	        */


	      a = a / 2;
	      b = b / 2;
	      return 0.5 * Math.log(a * a + b * b) + Math.LN2;
	    }

	    var parse = function (a, b) {
	      var z = {
	        're': 0,
	        'im': 0
	      };

	      if (a === undefined || a === null) {
	        z['re'] = z['im'] = 0;
	      } else if (b !== undefined) {
	        z['re'] = a;
	        z['im'] = b;
	      } else switch (typeof a) {
	        case 'object':
	          if ('im' in a && 're' in a) {
	            z['re'] = a['re'];
	            z['im'] = a['im'];
	          } else if ('abs' in a && 'arg' in a) {
	            if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
	              return Complex['INFINITY'];
	            }

	            z['re'] = a['abs'] * Math.cos(a['arg']);
	            z['im'] = a['abs'] * Math.sin(a['arg']);
	          } else if ('r' in a && 'phi' in a) {
	            if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
	              return Complex['INFINITY'];
	            }

	            z['re'] = a['r'] * Math.cos(a['phi']);
	            z['im'] = a['r'] * Math.sin(a['phi']);
	          } else if (a.length === 2) {
	            // Quick array check
	            z['re'] = a[0];
	            z['im'] = a[1];
	          } else {
	            parser_exit();
	          }

	          break;

	        case 'string':
	          z['im'] =
	          /* void */
	          z['re'] = 0;
	          var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
	          var plus = 1;
	          var minus = 0;

	          if (tokens === null) {
	            parser_exit();
	          }

	          for (var i = 0; i < tokens.length; i++) {
	            var c = tokens[i];

	            if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
	              plus++;
	            } else if (c === '-') {
	              minus++;
	            } else if (c === 'i' || c === 'I') {
	              if (plus + minus === 0) {
	                parser_exit();
	              }

	              if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
	                z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
	                i++;
	              } else {
	                z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
	              }

	              plus = minus = 0;
	            } else {
	              if (plus + minus === 0 || isNaN(c)) {
	                parser_exit();
	              }

	              if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
	                z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
	                i++;
	              } else {
	                z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
	              }

	              plus = minus = 0;
	            }
	          } // Still something on the stack


	          if (plus + minus > 0) {
	            parser_exit();
	          }

	          break;

	        case 'number':
	          z['im'] = 0;
	          z['re'] = a;
	          break;

	        default:
	          parser_exit();
	      }

	      if (isNaN(z['re']) || isNaN(z['im'])) ;

	      return z;
	    };
	    /**
	     * @constructor
	     * @returns {Complex}
	     */


	    function Complex(a, b) {
	      if (!(this instanceof Complex)) {
	        return new Complex(a, b);
	      }

	      var z = parse(a, b);
	      this['re'] = z['re'];
	      this['im'] = z['im'];
	    }

	    Complex.prototype = {
	      're': 0,
	      'im': 0,

	      /**
	       * Calculates the sign of a complex number, which is a normalized complex
	       *
	       * @returns {Complex}
	       */
	      'sign': function () {
	        var abs = this['abs']();
	        return new Complex(this['re'] / abs, this['im'] / abs);
	      },

	      /**
	       * Adds two complex numbers
	       *
	       * @returns {Complex}
	       */
	      'add': function (a, b) {
	        var z = new Complex(a, b); // Infinity + Infinity = NaN

	        if (this['isInfinite']() && z['isInfinite']()) {
	          return Complex['NAN'];
	        } // Infinity + z = Infinity { where z != Infinity }


	        if (this['isInfinite']() || z['isInfinite']()) {
	          return Complex['INFINITY'];
	        }

	        return new Complex(this['re'] + z['re'], this['im'] + z['im']);
	      },

	      /**
	       * Subtracts two complex numbers
	       *
	       * @returns {Complex}
	       */
	      'sub': function (a, b) {
	        var z = new Complex(a, b); // Infinity - Infinity = NaN

	        if (this['isInfinite']() && z['isInfinite']()) {
	          return Complex['NAN'];
	        } // Infinity - z = Infinity { where z != Infinity }


	        if (this['isInfinite']() || z['isInfinite']()) {
	          return Complex['INFINITY'];
	        }

	        return new Complex(this['re'] - z['re'], this['im'] - z['im']);
	      },

	      /**
	       * Multiplies two complex numbers
	       *
	       * @returns {Complex}
	       */
	      'mul': function (a, b) {
	        var z = new Complex(a, b); // Infinity * 0 = NaN

	        if (this['isInfinite']() && z['isZero']() || this['isZero']() && z['isInfinite']()) {
	          return Complex['NAN'];
	        } // Infinity * z = Infinity { where z != 0 }


	        if (this['isInfinite']() || z['isInfinite']()) {
	          return Complex['INFINITY'];
	        } // Short circuit for real values


	        if (z['im'] === 0 && this['im'] === 0) {
	          return new Complex(this['re'] * z['re'], 0);
	        }

	        return new Complex(this['re'] * z['re'] - this['im'] * z['im'], this['re'] * z['im'] + this['im'] * z['re']);
	      },

	      /**
	       * Divides two complex numbers
	       *
	       * @returns {Complex}
	       */
	      'div': function (a, b) {
	        var z = new Complex(a, b); // 0 / 0 = NaN and Infinity / Infinity = NaN

	        if (this['isZero']() && z['isZero']() || this['isInfinite']() && z['isInfinite']()) {
	          return Complex['NAN'];
	        } // Infinity / 0 = Infinity


	        if (this['isInfinite']() || z['isZero']()) {
	          return Complex['INFINITY'];
	        } // 0 / Infinity = 0


	        if (this['isZero']() || z['isInfinite']()) {
	          return Complex['ZERO'];
	        }

	        a = this['re'];
	        b = this['im'];
	        var c = z['re'];
	        var d = z['im'];
	        var t, x;

	        if (0 === d) {
	          // Divisor is real
	          return new Complex(a / c, b / c);
	        }

	        if (Math.abs(c) < Math.abs(d)) {
	          x = c / d;
	          t = c * x + d;
	          return new Complex((a * x + b) / t, (b * x - a) / t);
	        } else {
	          x = d / c;
	          t = d * x + c;
	          return new Complex((a + b * x) / t, (b - a * x) / t);
	        }
	      },

	      /**
	       * Calculate the power of two complex numbers
	       *
	       * @returns {Complex}
	       */
	      'pow': function (a, b) {
	        var z = new Complex(a, b);
	        a = this['re'];
	        b = this['im'];

	        if (z['isZero']()) {
	          return Complex['ONE'];
	        } // If the exponent is real


	        if (z['im'] === 0) {
	          if (b === 0 && a > 0) {
	            return new Complex(Math.pow(a, z['re']), 0);
	          } else if (a === 0) {
	            // If base is fully imaginary
	            switch ((z['re'] % 4 + 4) % 4) {
	              case 0:
	                return new Complex(Math.pow(b, z['re']), 0);

	              case 1:
	                return new Complex(0, Math.pow(b, z['re']));

	              case 2:
	                return new Complex(-Math.pow(b, z['re']), 0);

	              case 3:
	                return new Complex(0, -Math.pow(b, z['re']));
	            }
	          }
	        }
	        /* I couldn't find a good formula, so here is a derivation and optimization
	         *
	         * z_1^z_2 = (a + bi)^(c + di)
	         *         = exp((c + di) * log(a + bi)
	         *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
	         * =>...
	         * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
	         * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
	         *
	         * =>...
	         * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
	         * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
	         *
	         * =>
	         * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
	         * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
	         *
	         */


	        if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
	          return Complex['ZERO'];
	        }

	        var arg = Math.atan2(b, a);
	        var loh = logHypot(a, b);
	        a = Math.exp(z['re'] * loh - z['im'] * arg);
	        b = z['im'] * loh + z['re'] * arg;
	        return new Complex(a * Math.cos(b), a * Math.sin(b));
	      },

	      /**
	       * Calculate the complex square root
	       *
	       * @returns {Complex}
	       */
	      'sqrt': function () {
	        var a = this['re'];
	        var b = this['im'];
	        var r = this['abs']();
	        var re, im;

	        if (a >= 0) {
	          if (b === 0) {
	            return new Complex(Math.sqrt(a), 0);
	          }

	          re = 0.5 * Math.sqrt(2.0 * (r + a));
	        } else {
	          re = Math.abs(b) / Math.sqrt(2 * (r - a));
	        }

	        if (a <= 0) {
	          im = 0.5 * Math.sqrt(2.0 * (r - a));
	        } else {
	          im = Math.abs(b) / Math.sqrt(2 * (r + a));
	        }

	        return new Complex(re, b < 0 ? -im : im);
	      },

	      /**
	       * Calculate the complex exponent
	       *
	       * @returns {Complex}
	       */
	      'exp': function () {
	        var tmp = Math.exp(this['re']);

	        if (this['im'] === 0) ;

	        return new Complex(tmp * Math.cos(this['im']), tmp * Math.sin(this['im']));
	      },

	      /**
	       * Calculate the complex exponent and subtracts one.
	       *
	       * This may be more accurate than `Complex(x).exp().sub(1)` if
	       * `x` is small.
	       *
	       * @returns {Complex}
	       */
	      'expm1': function () {
	        /**
	         * exp(a + i*b) - 1
	         = exp(a) * (cos(b) + j*sin(b)) - 1
	         = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
	         */
	        var a = this['re'];
	        var b = this['im'];
	        return new Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));
	      },

	      /**
	       * Calculate the natural log
	       *
	       * @returns {Complex}
	       */
	      'log': function () {
	        var a = this['re'];
	        var b = this['im'];

	        return new Complex(logHypot(a, b), Math.atan2(b, a));
	      },

	      /**
	       * Calculate the magnitude of the complex number
	       *
	       * @returns {number}
	       */
	      'abs': function () {
	        return hypot(this['re'], this['im']);
	      },

	      /**
	       * Calculate the angle of the complex number
	       *
	       * @returns {number}
	       */
	      'arg': function () {
	        return Math.atan2(this['im'], this['re']);
	      },

	      /**
	       * Calculate the sine of the complex number
	       *
	       * @returns {Complex}
	       */
	      'sin': function () {
	        // sin(z) = ( e^iz - e^-iz ) / 2i 
	        //        = sin(a)cosh(b) + i cos(a)sinh(b)
	        var a = this['re'];
	        var b = this['im'];
	        return new Complex(Math.sin(a) * cosh(b), Math.cos(a) * sinh(b));
	      },

	      /**
	       * Calculate the cosine
	       *
	       * @returns {Complex}
	       */
	      'cos': function () {
	        // cos(z) = ( e^iz + e^-iz ) / 2 
	        //        = cos(a)cosh(b) - i sin(a)sinh(b)
	        var a = this['re'];
	        var b = this['im'];
	        return new Complex(Math.cos(a) * cosh(b), -Math.sin(a) * sinh(b));
	      },

	      /**
	       * Calculate the tangent
	       *
	       * @returns {Complex}
	       */
	      'tan': function () {
	        // tan(z) = sin(z) / cos(z) 
	        //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )
	        //        = ( e^2iz - 1 ) / i( e^2iz + 1 )
	        //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )
	        var a = 2 * this['re'];
	        var b = 2 * this['im'];
	        var d = Math.cos(a) + cosh(b);
	        return new Complex(Math.sin(a) / d, sinh(b) / d);
	      },

	      /**
	       * Calculate the cotangent
	       *
	       * @returns {Complex}
	       */
	      'cot': function () {
	        // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))
	        var a = 2 * this['re'];
	        var b = 2 * this['im'];
	        var d = Math.cos(a) - cosh(b);
	        return new Complex(-Math.sin(a) / d, sinh(b) / d);
	      },

	      /**
	       * Calculate the secant
	       *
	       * @returns {Complex}
	       */
	      'sec': function () {
	        // sec(c) = 2 / (e^(ci) + e^(-ci))
	        var a = this['re'];
	        var b = this['im'];
	        var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);
	        return new Complex(Math.cos(a) * cosh(b) / d, Math.sin(a) * sinh(b) / d);
	      },

	      /**
	       * Calculate the cosecans
	       *
	       * @returns {Complex}
	       */
	      'csc': function () {
	        // csc(c) = 2i / (e^(ci) - e^(-ci))
	        var a = this['re'];
	        var b = this['im'];
	        var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);
	        return new Complex(Math.sin(a) * cosh(b) / d, -Math.cos(a) * sinh(b) / d);
	      },

	      /**
	       * Calculate the complex arcus sinus
	       *
	       * @returns {Complex}
	       */
	      'asin': function () {
	        // asin(c) = -i * log(ci + sqrt(1 - c^2))
	        var a = this['re'];
	        var b = this['im'];
	        var t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();
	        var t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();
	        return new Complex(t2['im'], -t2['re']);
	      },

	      /**
	       * Calculate the complex arcus cosinus
	       *
	       * @returns {Complex}
	       */
	      'acos': function () {
	        // acos(c) = i * log(c - i * sqrt(1 - c^2))
	        var a = this['re'];
	        var b = this['im'];
	        var t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();
	        var t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();
	        return new Complex(Math.PI / 2 - t2['im'], t2['re']);
	      },

	      /**
	       * Calculate the complex arcus tangent
	       *
	       * @returns {Complex}
	       */
	      'atan': function () {
	        // atan(c) = i / 2 log((i + x) / (i - x))
	        var a = this['re'];
	        var b = this['im'];

	        if (a === 0) {
	          if (b === 1) {
	            return new Complex(0, Infinity);
	          }

	          if (b === -1) {
	            return new Complex(0, -Infinity);
	          }
	        }

	        var d = a * a + (1.0 - b) * (1.0 - b);
	        var t1 = new Complex((1 - b * b - a * a) / d, -2 * a / d).log();
	        return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
	      },

	      /**
	       * Calculate the complex arcus cotangent
	       *
	       * @returns {Complex}
	       */
	      'acot': function () {
	        // acot(c) = i / 2 log((c - i) / (c + i))
	        var a = this['re'];
	        var b = this['im'];

	        if (b === 0) {
	          return new Complex(Math.atan2(1, a), 0);
	        }

	        var d = a * a + b * b;
	        return d !== 0 ? new Complex(a / d, -b / d).atan() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();
	      },

	      /**
	       * Calculate the complex arcus secant
	       *
	       * @returns {Complex}
	       */
	      'asec': function () {
	        // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))
	        var a = this['re'];
	        var b = this['im'];

	        if (a === 0 && b === 0) {
	          return new Complex(0, Infinity);
	        }

	        var d = a * a + b * b;
	        return d !== 0 ? new Complex(a / d, -b / d).acos() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();
	      },

	      /**
	       * Calculate the complex arcus cosecans
	       *
	       * @returns {Complex}
	       */
	      'acsc': function () {
	        // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))
	        var a = this['re'];
	        var b = this['im'];

	        if (a === 0 && b === 0) {
	          return new Complex(Math.PI / 2, Infinity);
	        }

	        var d = a * a + b * b;
	        return d !== 0 ? new Complex(a / d, -b / d).asin() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();
	      },

	      /**
	       * Calculate the complex sinh
	       *
	       * @returns {Complex}
	       */
	      'sinh': function () {
	        // sinh(c) = (e^c - e^-c) / 2
	        var a = this['re'];
	        var b = this['im'];
	        return new Complex(sinh(a) * Math.cos(b), cosh(a) * Math.sin(b));
	      },

	      /**
	       * Calculate the complex cosh
	       *
	       * @returns {Complex}
	       */
	      'cosh': function () {
	        // cosh(c) = (e^c + e^-c) / 2
	        var a = this['re'];
	        var b = this['im'];
	        return new Complex(cosh(a) * Math.cos(b), sinh(a) * Math.sin(b));
	      },

	      /**
	       * Calculate the complex tanh
	       *
	       * @returns {Complex}
	       */
	      'tanh': function () {
	        // tanh(c) = (e^c - e^-c) / (e^c + e^-c)
	        var a = 2 * this['re'];
	        var b = 2 * this['im'];
	        var d = cosh(a) + Math.cos(b);
	        return new Complex(sinh(a) / d, Math.sin(b) / d);
	      },

	      /**
	       * Calculate the complex coth
	       *
	       * @returns {Complex}
	       */
	      'coth': function () {
	        // coth(c) = (e^c + e^-c) / (e^c - e^-c)
	        var a = 2 * this['re'];
	        var b = 2 * this['im'];
	        var d = cosh(a) - Math.cos(b);
	        return new Complex(sinh(a) / d, -Math.sin(b) / d);
	      },

	      /**
	       * Calculate the complex coth
	       *
	       * @returns {Complex}
	       */
	      'csch': function () {
	        // csch(c) = 2 / (e^c - e^-c)
	        var a = this['re'];
	        var b = this['im'];
	        var d = Math.cos(2 * b) - cosh(2 * a);
	        return new Complex(-2 * sinh(a) * Math.cos(b) / d, 2 * cosh(a) * Math.sin(b) / d);
	      },

	      /**
	       * Calculate the complex sech
	       *
	       * @returns {Complex}
	       */
	      'sech': function () {
	        // sech(c) = 2 / (e^c + e^-c)
	        var a = this['re'];
	        var b = this['im'];
	        var d = Math.cos(2 * b) + cosh(2 * a);
	        return new Complex(2 * cosh(a) * Math.cos(b) / d, -2 * sinh(a) * Math.sin(b) / d);
	      },

	      /**
	       * Calculate the complex asinh
	       *
	       * @returns {Complex}
	       */
	      'asinh': function () {
	        // asinh(c) = log(c + sqrt(c^2 + 1))
	        var tmp = this['im'];
	        this['im'] = -this['re'];
	        this['re'] = tmp;
	        var res = this['asin']();
	        this['re'] = -this['im'];
	        this['im'] = tmp;
	        tmp = res['re'];
	        res['re'] = -res['im'];
	        res['im'] = tmp;
	        return res;
	      },

	      /**
	       * Calculate the complex acosh
	       *
	       * @returns {Complex}
	       */
	      'acosh': function () {
	        // acosh(c) = log(c + sqrt(c^2 - 1))
	        var res = this['acos']();

	        if (res['im'] <= 0) {
	          var tmp = res['re'];
	          res['re'] = -res['im'];
	          res['im'] = tmp;
	        } else {
	          var tmp = res['im'];
	          res['im'] = -res['re'];
	          res['re'] = tmp;
	        }

	        return res;
	      },

	      /**
	       * Calculate the complex atanh
	       *
	       * @returns {Complex}
	       */
	      'atanh': function () {
	        // atanh(c) = log((1+c) / (1-c)) / 2
	        var a = this['re'];
	        var b = this['im'];
	        var noIM = a > 1 && b === 0;
	        var oneMinus = 1 - a;
	        var onePlus = 1 + a;
	        var d = oneMinus * oneMinus + b * b;
	        var x = d !== 0 ? new Complex((onePlus * oneMinus - b * b) / d, (b * oneMinus + onePlus * b) / d) : new Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);
	        var temp = x['re'];
	        x['re'] = logHypot(x['re'], x['im']) / 2;
	        x['im'] = Math.atan2(x['im'], temp) / 2;

	        if (noIM) {
	          x['im'] = -x['im'];
	        }

	        return x;
	      },

	      /**
	       * Calculate the complex acoth
	       *
	       * @returns {Complex}
	       */
	      'acoth': function () {
	        // acoth(c) = log((c+1) / (c-1)) / 2
	        var a = this['re'];
	        var b = this['im'];

	        if (a === 0 && b === 0) {
	          return new Complex(0, Math.PI / 2);
	        }

	        var d = a * a + b * b;
	        return d !== 0 ? new Complex(a / d, -b / d).atanh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atanh();
	      },

	      /**
	       * Calculate the complex acsch
	       *
	       * @returns {Complex}
	       */
	      'acsch': function () {
	        // acsch(c) = log((1+sqrt(1+c^2))/c)
	        var a = this['re'];
	        var b = this['im'];

	        if (b === 0) {
	          return new Complex(a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity, 0);
	        }

	        var d = a * a + b * b;
	        return d !== 0 ? new Complex(a / d, -b / d).asinh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asinh();
	      },

	      /**
	       * Calculate the complex asech
	       *
	       * @returns {Complex}
	       */
	      'asech': function () {
	        // asech(c) = log((1+sqrt(1-c^2))/c)
	        var a = this['re'];
	        var b = this['im'];

	        if (this['isZero']()) {
	          return Complex['INFINITY'];
	        }

	        var d = a * a + b * b;
	        return d !== 0 ? new Complex(a / d, -b / d).acosh() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acosh();
	      },

	      /**
	       * Calculate the complex inverse 1/z
	       *
	       * @returns {Complex}
	       */
	      'inverse': function () {
	        // 1 / 0 = Infinity and 1 / Infinity = 0
	        if (this['isZero']()) {
	          return Complex['INFINITY'];
	        }

	        if (this['isInfinite']()) {
	          return Complex['ZERO'];
	        }

	        var a = this['re'];
	        var b = this['im'];
	        var d = a * a + b * b;
	        return new Complex(a / d, -b / d);
	      },

	      /**
	       * Returns the complex conjugate
	       *
	       * @returns {Complex}
	       */
	      'conjugate': function () {
	        return new Complex(this['re'], -this['im']);
	      },

	      /**
	       * Gets the negated complex number
	       *
	       * @returns {Complex}
	       */
	      'neg': function () {
	        return new Complex(-this['re'], -this['im']);
	      },

	      /**
	       * Ceils the actual complex number
	       *
	       * @returns {Complex}
	       */
	      'ceil': function (places) {
	        places = Math.pow(10, places || 0);
	        return new Complex(Math.ceil(this['re'] * places) / places, Math.ceil(this['im'] * places) / places);
	      },

	      /**
	       * Floors the actual complex number
	       *
	       * @returns {Complex}
	       */
	      'floor': function (places) {
	        places = Math.pow(10, places || 0);
	        return new Complex(Math.floor(this['re'] * places) / places, Math.floor(this['im'] * places) / places);
	      },

	      /**
	       * Ceils the actual complex number
	       *
	       * @returns {Complex}
	       */
	      'round': function (places) {
	        places = Math.pow(10, places || 0);
	        return new Complex(Math.round(this['re'] * places) / places, Math.round(this['im'] * places) / places);
	      },

	      /**
	       * Compares two complex numbers
	       *
	       * **Note:** new Complex(Infinity).equals(Infinity) === false
	       *
	       * @returns {boolean}
	       */
	      'equals': function (a, b) {
	        var z = new Complex(a, b);
	        return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] && Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
	      },

	      /**
	       * Clones the actual object
	       *
	       * @returns {Complex}
	       */
	      'clone': function () {
	        return new Complex(this['re'], this['im']);
	      },

	      /**
	       * Gets a string of the actual complex number
	       *
	       * @returns {string}
	       */
	      'toString': function () {
	        var a = this['re'];
	        var b = this['im'];
	        var ret = "";

	        if (this['isNaN']()) {
	          return 'NaN';
	        }

	        if (this['isInfinite']()) {
	          return 'Infinity';
	        }

	        if (Math.abs(a) < Complex['EPSILON']) {
	          a = 0;
	        }

	        if (Math.abs(b) < Complex['EPSILON']) {
	          b = 0;
	        } // If is real number


	        if (b === 0) {
	          return ret + a;
	        }

	        if (a !== 0) {
	          ret += a;
	          ret += " ";

	          if (b < 0) {
	            b = -b;
	            ret += "-";
	          } else {
	            ret += "+";
	          }

	          ret += " ";
	        } else if (b < 0) {
	          b = -b;
	          ret += "-";
	        }

	        if (1 !== b) {
	          // b is the absolute imaginary part
	          ret += b;
	        }

	        return ret + "i";
	      },

	      /**
	       * Returns the actual number as a vector
	       *
	       * @returns {Array}
	       */
	      'toVector': function () {
	        return [this['re'], this['im']];
	      },

	      /**
	       * Returns the actual real value of the current object
	       *
	       * @returns {number|null}
	       */
	      'valueOf': function () {
	        if (this['im'] === 0) {
	          return this['re'];
	        }

	        return null;
	      },

	      /**
	       * Determines whether a complex number is not on the Riemann sphere.
	       *
	       * @returns {boolean}
	       */
	      'isNaN': function () {
	        return isNaN(this['re']) || isNaN(this['im']);
	      },

	      /**
	       * Determines whether or not a complex number is at the zero pole of the
	       * Riemann sphere.
	       *
	       * @returns {boolean}
	       */
	      'isZero': function () {
	        return this['im'] === 0 && this['re'] === 0;
	      },

	      /**
	       * Determines whether a complex number is not at the infinity pole of the
	       * Riemann sphere.
	       *
	       * @returns {boolean}
	       */
	      'isFinite': function () {
	        return isFinite(this['re']) && isFinite(this['im']);
	      },

	      /**
	       * Determines whether or not a complex number is at the infinity pole of the
	       * Riemann sphere.
	       *
	       * @returns {boolean}
	       */
	      'isInfinite': function () {
	        return !(this['isNaN']() || this['isFinite']());
	      }
	    };
	    Complex['ZERO'] = new Complex(0, 0);
	    Complex['ONE'] = new Complex(1, 0);
	    Complex['I'] = new Complex(0, 1);
	    Complex['PI'] = new Complex(Math.PI, 0);
	    Complex['E'] = new Complex(Math.E, 0);
	    Complex['INFINITY'] = new Complex(Infinity, Infinity);
	    Complex['NAN'] = new Complex(NaN, NaN);
	    Complex['EPSILON'] = 1e-15;

	    {
	      Object.defineProperty(Complex, "__esModule", {
	        'value': true
	      });
	      Complex['default'] = Complex;
	      Complex['Complex'] = Complex;
	      module['exports'] = Complex;
	    }
	  })();
	});
	var Complex$1 = /*@__PURE__*/getDefaultExportFromCjs(complex$1);

	var name$12 = 'Complex';
	var dependencies$12 = [];
	var createComplexClass = /* #__PURE__ */factory(name$12, dependencies$12, () => {
	  /**
	   * Attach type information
	   */
	  Complex$1.prototype.type = 'Complex';
	  Complex$1.prototype.isComplex = true;
	  /**
	   * Get a JSON representation of the complex number
	   * @returns {Object} Returns a JSON object structured as:
	   *                   `{"mathjs": "Complex", "re": 2, "im": 3}`
	   */

	  Complex$1.prototype.toJSON = function () {
	    return {
	      mathjs: 'Complex',
	      re: this.re,
	      im: this.im
	    };
	  };
	  /*
	   * Return the value of the complex number in polar notation
	   * The angle phi will be set in the interval of [-pi, pi].
	   * @return {{r: number, phi: number}} Returns and object with properties r and phi.
	   */


	  Complex$1.prototype.toPolar = function () {
	    return {
	      r: this.abs(),
	      phi: this.arg()
	    };
	  };
	  /**
	   * Get a string representation of the complex number,
	   * with optional formatting options.
	   * @param {Object | number | Function} [options]  Formatting options. See
	   *                                                lib/utils/number:format for a
	   *                                                description of the available
	   *                                                options.
	   * @return {string} str
	   */


	  Complex$1.prototype.format = function (options) {
	    var str = '';
	    var im = this.im;
	    var re = this.re;
	    var strRe = format$2(this.re, options);
	    var strIm = format$2(this.im, options); // round either re or im when smaller than the configured precision

	    var precision = isNumber(options) ? options : options ? options.precision : null;

	    if (precision !== null) {
	      var epsilon = Math.pow(10, -precision);

	      if (Math.abs(re / im) < epsilon) {
	        re = 0;
	      }

	      if (Math.abs(im / re) < epsilon) {
	        im = 0;
	      }
	    }

	    if (im === 0) {
	      // real value
	      str = strRe;
	    } else if (re === 0) {
	      // purely complex value
	      if (im === 1) {
	        str = 'i';
	      } else if (im === -1) {
	        str = '-i';
	      } else {
	        str = strIm + 'i';
	      }
	    } else {
	      // complex value
	      if (im < 0) {
	        if (im === -1) {
	          str = strRe + ' - i';
	        } else {
	          str = strRe + ' - ' + strIm.substring(1) + 'i';
	        }
	      } else {
	        if (im === 1) {
	          str = strRe + ' + i';
	        } else {
	          str = strRe + ' + ' + strIm + 'i';
	        }
	      }
	    }

	    return str;
	  };
	  /**
	   * Create a complex number from polar coordinates
	   *
	   * Usage:
	   *
	   *     Complex.fromPolar(r: number, phi: number) : Complex
	   *     Complex.fromPolar({r: number, phi: number}) : Complex
	   *
	   * @param {*} args...
	   * @return {Complex}
	   */


	  Complex$1.fromPolar = function (args) {
	    switch (arguments.length) {
	      case 1:
	        {
	          var arg = arguments[0];

	          if (typeof arg === 'object') {
	            return Complex$1(arg);
	          } else {
	            throw new TypeError('Input has to be an object with r and phi keys.');
	          }
	        }

	      case 2:
	        {
	          var r = arguments[0];
	          var phi = arguments[1];

	          if (isNumber(r)) {
	            if (isUnit(phi) && phi.hasBase('ANGLE')) {
	              // convert unit to a number in radians
	              phi = phi.toNumber('rad');
	            }

	            if (isNumber(phi)) {
	              return new Complex$1({
	                r: r,
	                phi: phi
	              });
	            }

	            throw new TypeError('Phi is not a number nor an angle unit.');
	          } else {
	            throw new TypeError('Radius r is not a number.');
	          }
	        }

	      default:
	        throw new SyntaxError('Wrong number of arguments in function fromPolar');
	    }
	  };

	  Complex$1.prototype.valueOf = Complex$1.prototype.toString;
	  /**
	   * Create a Complex number from a JSON object
	   * @param {Object} json  A JSON Object structured as
	   *                       {"mathjs": "Complex", "re": 2, "im": 3}
	   *                       All properties are optional, default values
	   *                       for `re` and `im` are 0.
	   * @return {Complex} Returns a new Complex number
	   */

	  Complex$1.fromJSON = function (json) {
	    return new Complex$1(json);
	  };
	  /**
	   * Compare two complex numbers, `a` and `b`:
	   *
	   * - Returns 1 when the real part of `a` is larger than the real part of `b`
	   * - Returns -1 when the real part of `a` is smaller than the real part of `b`
	   * - Returns 1 when the real parts are equal
	   *   and the imaginary part of `a` is larger than the imaginary part of `b`
	   * - Returns -1 when the real parts are equal
	   *   and the imaginary part of `a` is smaller than the imaginary part of `b`
	   * - Returns 0 when both real and imaginary parts are equal.
	   *
	   * @params {Complex} a
	   * @params {Complex} b
	   * @returns {number} Returns the comparison result: -1, 0, or 1
	   */


	  Complex$1.compare = function (a, b) {
	    if (a.re > b.re) {
	      return 1;
	    }

	    if (a.re < b.re) {
	      return -1;
	    }

	    if (a.im > b.im) {
	      return 1;
	    }

	    if (a.im < b.im) {
	      return -1;
	    }

	    return 0;
	  };

	  return Complex$1;
	}, {
	  isClass: true
	});

	var fraction$1 = createCommonjsModule(function (module, exports) {
	  /**
	   * @license Fraction.js v4.2.0 05/03/2022
	   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
	   *
	   * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
	   * Dual licensed under the MIT or GPL Version 2 licenses.
	   **/

	  /**
	   *
	   * This class offers the possibility to calculate fractions.
	   * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
	   *
	   * Array/Object form
	   * [ 0 => <nominator>, 1 => <denominator> ]
	   * [ n => <nominator>, d => <denominator> ]
	   *
	   * Integer form
	   * - Single integer value
	   *
	   * Double form
	   * - Single double value
	   *
	   * String form
	   * 123.456 - a simple double
	   * 123/456 - a string fraction
	   * 123.'456' - a double with repeating decimal places
	   * 123.(456) - synonym
	   * 123.45'6' - a double with repeating last place
	   * 123.45(6) - synonym
	   *
	   * Example:
	   *
	   * var f = new Fraction("9.4'31'");
	   * f.mul([-4, 3]).div(4.9);
	   *
	   */
	  (function (root) {
	    // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
	    // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits

	    var MAX_CYCLE_LEN = 2000; // Parsed data to avoid calling "new" all the time

	    var P = {
	      "s": 1,
	      "n": 0,
	      "d": 1
	    };

	    function assign(n, s) {
	      if (isNaN(n = parseInt(n, 10))) {
	        throw Fraction['InvalidParameter'];
	      }

	      return n * s;
	    } // Creates a new Fraction internally without the need of the bulky constructor


	    function newFraction(n, d) {
	      if (d === 0) {
	        throw Fraction['DivisionByZero'];
	      }

	      var f = Object.create(Fraction.prototype);
	      f["s"] = n < 0 ? -1 : 1;
	      n = n < 0 ? -n : n;
	      var a = gcd(n, d);
	      f["n"] = n / a;
	      f["d"] = d / a;
	      return f;
	    }

	    function factorize(num) {
	      var factors = {};
	      var n = num;
	      var i = 2;
	      var s = 4;

	      while (s <= n) {
	        while (n % i === 0) {
	          n /= i;
	          factors[i] = (factors[i] || 0) + 1;
	        }

	        s += 1 + 2 * i++;
	      }

	      if (n !== num) {
	        if (n > 1) factors[n] = (factors[n] || 0) + 1;
	      } else {
	        factors[num] = (factors[num] || 0) + 1;
	      }

	      return factors;
	    }

	    var parse = function (p1, p2) {
	      var n = 0,
	          d = 1,
	          s = 1;
	      var v = 0,
	          w = 0,
	          x = 0,
	          y = 1,
	          z = 1;
	      var A = 0,
	          B = 1;
	      var C = 1,
	          D = 1;
	      var N = 10000000;
	      var M;

	      if (p1 === undefined || p1 === null) ; else if (p2 !== undefined) {
	        n = p1;
	        d = p2;
	        s = n * d;

	        if (n % 1 !== 0 || d % 1 !== 0) {
	          throw Fraction['NonIntegerParameter'];
	        }
	      } else switch (typeof p1) {
	        case "object":
	          {
	            if ("d" in p1 && "n" in p1) {
	              n = p1["n"];
	              d = p1["d"];
	              if ("s" in p1) n *= p1["s"];
	            } else if (0 in p1) {
	              n = p1[0];
	              if (1 in p1) d = p1[1];
	            } else {
	              throw Fraction['InvalidParameter'];
	            }

	            s = n * d;
	            break;
	          }

	        case "number":
	          {
	            if (p1 < 0) {
	              s = p1;
	              p1 = -p1;
	            }

	            if (p1 % 1 === 0) {
	              n = p1;
	            } else if (p1 > 0) {
	              // check for != 0, scale would become NaN (log(0)), which converges really slow
	              if (p1 >= 1) {
	                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
	                p1 /= z;
	              } // Using Farey Sequences
	              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/


	              while (B <= N && D <= N) {
	                M = (A + C) / (B + D);

	                if (p1 === M) {
	                  if (B + D <= N) {
	                    n = A + C;
	                    d = B + D;
	                  } else if (D > B) {
	                    n = C;
	                    d = D;
	                  } else {
	                    n = A;
	                    d = B;
	                  }

	                  break;
	                } else {
	                  if (p1 > M) {
	                    A += C;
	                    B += D;
	                  } else {
	                    C += A;
	                    D += B;
	                  }

	                  if (B > N) {
	                    n = C;
	                    d = D;
	                  } else {
	                    n = A;
	                    d = B;
	                  }
	                }
	              }

	              n *= z;
	            } else if (isNaN(p1) || isNaN(p2)) {
	              d = n = NaN;
	            }

	            break;
	          }

	        case "string":
	          {
	            B = p1.match(/\d+|./g);
	            if (B === null) throw Fraction['InvalidParameter'];

	            if (B[A] === '-') {
	              // Check for minus sign at the beginning
	              s = -1;
	              A++;
	            } else if (B[A] === '+') {
	              // Check for plus sign at the beginning
	              A++;
	            }

	            if (B.length === A + 1) {
	              // Check if it's just a simple number "1234"
	              w = assign(B[A++], s);
	            } else if (B[A + 1] === '.' || B[A] === '.') {
	              // Check if it's a decimal number
	              if (B[A] !== '.') {
	                // Handle 0.5 and .5
	                v = assign(B[A++], s);
	              }

	              A++; // Check for decimal places

	              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
	                w = assign(B[A], s);
	                y = Math.pow(10, B[A].length);
	                A++;
	              } // Check for repeating places


	              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
	                x = assign(B[A + 1], s);
	                z = Math.pow(10, B[A + 1].length) - 1;
	                A += 3;
	              }
	            } else if (B[A + 1] === '/' || B[A + 1] === ':') {
	              // Check for a simple fraction "123/456" or "123:456"
	              w = assign(B[A], s);
	              y = assign(B[A + 2], 1);
	              A += 3;
	            } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
	              // Check for a complex fraction "123 1/2"
	              v = assign(B[A], s);
	              w = assign(B[A + 2], s);
	              y = assign(B[A + 4], 1);
	              A += 5;
	            }

	            if (B.length <= A) {
	              // Check for more tokens on the stack
	              d = y * z;
	              s =
	              /* void */
	              n = x + d * v + z * w;
	              break;
	            }
	            /* Fall through on error */

	          }

	        default:
	          throw Fraction['InvalidParameter'];
	      }

	      if (d === 0) {
	        throw Fraction['DivisionByZero'];
	      }

	      P["s"] = s < 0 ? -1 : 1;
	      P["n"] = Math.abs(n);
	      P["d"] = Math.abs(d);
	    };

	    function modpow(b, e, m) {
	      var r = 1;

	      for (; e > 0; b = b * b % m, e >>= 1) {
	        if (e & 1) {
	          r = r * b % m;
	        }
	      }

	      return r;
	    }

	    function cycleLen(n, d) {
	      for (; d % 2 === 0; d /= 2) {}

	      for (; d % 5 === 0; d /= 5) {}

	      if (d === 1) // Catch non-cyclic numbers
	        return 0; // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
	      // 10^(d-1) % d == 1
	      // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
	      // as we want to translate the numbers to strings.

	      var rem = 10 % d;
	      var t = 1;

	      for (; rem !== 1; t++) {
	        rem = rem * 10 % d;
	        if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
	      }

	      return t;
	    }

	    function cycleStart(n, d, len) {
	      var rem1 = 1;
	      var rem2 = modpow(10, len, d);

	      for (var t = 0; t < 300; t++) {
	        // s < ~log10(Number.MAX_VALUE)
	        // Solve 10^s == 10^(s+t) (mod d)
	        if (rem1 === rem2) return t;
	        rem1 = rem1 * 10 % d;
	        rem2 = rem2 * 10 % d;
	      }

	      return 0;
	    }

	    function gcd(a, b) {
	      if (!a) return b;
	      if (!b) return a;

	      while (1) {
	        a %= b;
	        if (!a) return b;
	        b %= a;
	        if (!b) return a;
	      }
	    }
	    /**
	     * Module constructor
	     *
	     * @constructor
	     * @param {number|Fraction=} a
	     * @param {number=} b
	     */

	    function Fraction(a, b) {
	      parse(a, b);

	      if (this instanceof Fraction) {
	        a = gcd(P["d"], P["n"]); // Abuse variable a

	        this["s"] = P["s"];
	        this["n"] = P["n"] / a;
	        this["d"] = P["d"] / a;
	      } else {
	        return newFraction(P['s'] * P['n'], P['d']);
	      }
	    }

	    Fraction['DivisionByZero'] = new Error("Division by Zero");
	    Fraction['InvalidParameter'] = new Error("Invalid argument");
	    Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");
	    Fraction.prototype = {
	      "s": 1,
	      "n": 0,
	      "d": 1,

	      /**
	       * Calculates the absolute value
	       *
	       * Ex: new Fraction(-4).abs() => 4
	       **/
	      "abs": function () {
	        return newFraction(this["n"], this["d"]);
	      },

	      /**
	       * Inverts the sign of the current fraction
	       *
	       * Ex: new Fraction(-4).neg() => 4
	       **/
	      "neg": function () {
	        return newFraction(-this["s"] * this["n"], this["d"]);
	      },

	      /**
	       * Adds two rational numbers
	       *
	       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
	       **/
	      "add": function (a, b) {
	        parse(a, b);
	        return newFraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
	      },

	      /**
	       * Subtracts two rational numbers
	       *
	       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
	       **/
	      "sub": function (a, b) {
	        parse(a, b);
	        return newFraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
	      },

	      /**
	       * Multiplies two rational numbers
	       *
	       * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
	       **/
	      "mul": function (a, b) {
	        parse(a, b);
	        return newFraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
	      },

	      /**
	       * Divides two rational numbers
	       *
	       * Ex: new Fraction("-17.(345)").inverse().div(3)
	       **/
	      "div": function (a, b) {
	        parse(a, b);
	        return newFraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
	      },

	      /**
	       * Clones the actual object
	       *
	       * Ex: new Fraction("-17.(345)").clone()
	       **/
	      "clone": function () {
	        return newFraction(this['s'] * this['n'], this['d']);
	      },

	      /**
	       * Calculates the modulo of two rational numbers - a more precise fmod
	       *
	       * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
	       **/
	      "mod": function (a, b) {
	        if (isNaN(this['n']) || isNaN(this['d'])) {
	          return new Fraction(NaN);
	        }

	        if (a === undefined) {
	          return newFraction(this["s"] * this["n"] % this["d"], 1);
	        }

	        parse(a, b);

	        if (0 === P["n"] && 0 === this["d"]) {
	          throw Fraction['DivisionByZero'];
	        }
	        /*
	         * First silly attempt, kinda slow
	         *
	         return that["sub"]({
	         "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
	         "d": num["d"],
	         "s": this["s"]
	         });*/

	        /*
	         * New attempt: a1 / b1 = a2 / b2 * q + r
	         * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
	         * => (b2 * a1 % a2 * b1) / (b1 * b2)
	         */


	        return newFraction(this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]), P["d"] * this["d"]);
	      },

	      /**
	       * Calculates the fractional gcd of two rational numbers
	       *
	       * Ex: new Fraction(5,8).gcd(3,7) => 1/56
	       */
	      "gcd": function (a, b) {
	        parse(a, b); // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

	        return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
	      },

	      /**
	       * Calculates the fractional lcm of two rational numbers
	       *
	       * Ex: new Fraction(5,8).lcm(3,7) => 15
	       */
	      "lcm": function (a, b) {
	        parse(a, b); // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

	        if (P["n"] === 0 && this["n"] === 0) {
	          return newFraction(0, 1);
	        }

	        return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
	      },

	      /**
	       * Calculates the ceil of a rational number
	       *
	       * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
	       **/
	      "ceil": function (places) {
	        places = Math.pow(10, places || 0);

	        if (isNaN(this["n"]) || isNaN(this["d"])) {
	          return new Fraction(NaN);
	        }

	        return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
	      },

	      /**
	       * Calculates the floor of a rational number
	       *
	       * Ex: new Fraction('4.(3)').floor() => (4 / 1)
	       **/
	      "floor": function (places) {
	        places = Math.pow(10, places || 0);

	        if (isNaN(this["n"]) || isNaN(this["d"])) {
	          return new Fraction(NaN);
	        }

	        return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
	      },

	      /**
	       * Rounds a rational numbers
	       *
	       * Ex: new Fraction('4.(3)').round() => (4 / 1)
	       **/
	      "round": function (places) {
	        places = Math.pow(10, places || 0);

	        if (isNaN(this["n"]) || isNaN(this["d"])) {
	          return new Fraction(NaN);
	        }

	        return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
	      },

	      /**
	       * Gets the inverse of the fraction, means numerator and denominator are exchanged
	       *
	       * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
	       **/
	      "inverse": function () {
	        return newFraction(this["s"] * this["d"], this["n"]);
	      },

	      /**
	       * Calculates the fraction to some rational exponent, if possible
	       *
	       * Ex: new Fraction(-1,2).pow(-3) => -8
	       */
	      "pow": function (a, b) {
	        parse(a, b); // Trivial case when exp is an integer

	        if (P['d'] === 1) {
	          if (P['s'] < 0) {
	            return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
	          } else {
	            return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
	          }
	        } // Negative roots become complex
	        //     (-a/b)^(c/d) = x
	        // <=> (-1)^(c/d) * (a/b)^(c/d) = x
	        // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180
	        // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
	        // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.


	        if (this['s'] < 0) return null; // Now prime factor n and d

	        var N = factorize(this['n']);
	        var D = factorize(this['d']); // Exponentiate and take root for n and d individually

	        var n = 1;
	        var d = 1;

	        for (var k in N) {
	          if (k === '1') continue;

	          if (k === '0') {
	            n = 0;
	            break;
	          }

	          N[k] *= P['n'];

	          if (N[k] % P['d'] === 0) {
	            N[k] /= P['d'];
	          } else return null;

	          n *= Math.pow(k, N[k]);
	        }

	        for (var k in D) {
	          if (k === '1') continue;
	          D[k] *= P['n'];

	          if (D[k] % P['d'] === 0) {
	            D[k] /= P['d'];
	          } else return null;

	          d *= Math.pow(k, D[k]);
	        }

	        if (P['s'] < 0) {
	          return newFraction(d, n);
	        }

	        return newFraction(n, d);
	      },

	      /**
	       * Check if two rational numbers are the same
	       *
	       * Ex: new Fraction(19.6).equals([98, 5]);
	       **/
	      "equals": function (a, b) {
	        parse(a, b);
	        return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
	      },

	      /**
	       * Check if two rational numbers are the same
	       *
	       * Ex: new Fraction(19.6).equals([98, 5]);
	       **/
	      "compare": function (a, b) {
	        parse(a, b);
	        var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
	        return (0 < t) - (t < 0);
	      },
	      "simplify": function (eps) {
	        if (isNaN(this['n']) || isNaN(this['d'])) {
	          return this;
	        }

	        eps = eps || 0.001;
	        var thisABS = this['abs']();
	        var cont = thisABS['toContinued']();

	        for (var i = 1; i < cont.length; i++) {
	          var s = newFraction(cont[i - 1], 1);

	          for (var k = i - 2; k >= 0; k--) {
	            s = s['inverse']()['add'](cont[k]);
	          }

	          if (s['sub'](thisABS)['abs']().valueOf() < eps) {
	            return s['mul'](this['s']);
	          }
	        }

	        return this;
	      },

	      /**
	       * Check if two rational numbers are divisible
	       *
	       * Ex: new Fraction(19.6).divisible(1.5);
	       */
	      "divisible": function (a, b) {
	        parse(a, b);
	        return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
	      },

	      /**
	       * Returns a decimal representation of the fraction
	       *
	       * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
	       **/
	      'valueOf': function () {
	        return this["s"] * this["n"] / this["d"];
	      },

	      /**
	       * Returns a string-fraction representation of a Fraction object
	       *
	       * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
	       **/
	      'toFraction': function (excludeWhole) {
	        var whole,
	            str = "";
	        var n = this["n"];
	        var d = this["d"];

	        if (this["s"] < 0) {
	          str += '-';
	        }

	        if (d === 1) {
	          str += n;
	        } else {
	          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
	            str += whole;
	            str += " ";
	            n %= d;
	          }

	          str += n;
	          str += '/';
	          str += d;
	        }

	        return str;
	      },

	      /**
	       * Returns a latex representation of a Fraction object
	       *
	       * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
	       **/
	      'toLatex': function (excludeWhole) {
	        var whole,
	            str = "";
	        var n = this["n"];
	        var d = this["d"];

	        if (this["s"] < 0) {
	          str += '-';
	        }

	        if (d === 1) {
	          str += n;
	        } else {
	          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
	            str += whole;
	            n %= d;
	          }

	          str += "\\frac{";
	          str += n;
	          str += '}{';
	          str += d;
	          str += '}';
	        }

	        return str;
	      },

	      /**
	       * Returns an array of continued fraction elements
	       *
	       * Ex: new Fraction("7/8").toContinued() => [0,1,7]
	       */
	      'toContinued': function () {
	        var t;
	        var a = this['n'];
	        var b = this['d'];
	        var res = [];

	        if (isNaN(a) || isNaN(b)) {
	          return res;
	        }

	        do {
	          res.push(Math.floor(a / b));
	          t = a % b;
	          a = b;
	          b = t;
	        } while (a !== 1);

	        return res;
	      },

	      /**
	       * Creates a string representation of a fraction with all digits
	       *
	       * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
	       **/
	      'toString': function (dec) {
	        var N = this["n"];
	        var D = this["d"];

	        if (isNaN(N) || isNaN(D)) {
	          return "NaN";
	        }

	        dec = dec || 15; // 15 = decimal places when no repetation

	        var cycLen = cycleLen(N, D); // Cycle length

	        var cycOff = cycleStart(N, D, cycLen); // Cycle start

	        var str = this['s'] < 0 ? "-" : "";
	        str += N / D | 0;
	        N %= D;
	        N *= 10;
	        if (N) str += ".";

	        if (cycLen) {
	          for (var i = cycOff; i--;) {
	            str += N / D | 0;
	            N %= D;
	            N *= 10;
	          }

	          str += "(";

	          for (var i = cycLen; i--;) {
	            str += N / D | 0;
	            N %= D;
	            N *= 10;
	          }

	          str += ")";
	        } else {
	          for (var i = dec; N && i--;) {
	            str += N / D | 0;
	            N %= D;
	            N *= 10;
	          }
	        }

	        return str;
	      }
	    };

	    {
	      Object.defineProperty(Fraction, "__esModule", {
	        'value': true
	      });
	      Fraction['default'] = Fraction;
	      Fraction['Fraction'] = Fraction;
	      module['exports'] = Fraction;
	    }
	  })();
	});
	var Fraction$1 = /*@__PURE__*/getDefaultExportFromCjs(fraction$1);

	var name$11 = 'Fraction';
	var dependencies$11 = [];
	var createFractionClass = /* #__PURE__ */factory(name$11, dependencies$11, () => {
	  /**
	   * Attach type information
	   */
	  Fraction$1.prototype.type = 'Fraction';
	  Fraction$1.prototype.isFraction = true;
	  /**
	   * Get a JSON representation of a Fraction containing type information
	   * @returns {Object} Returns a JSON object structured as:
	   *                   `{"mathjs": "Fraction", "n": 3, "d": 8}`
	   */

	  Fraction$1.prototype.toJSON = function () {
	    return {
	      mathjs: 'Fraction',
	      n: this.s * this.n,
	      d: this.d
	    };
	  };
	  /**
	   * Instantiate a Fraction from a JSON object
	   * @param {Object} json  a JSON object structured as:
	   *                       `{"mathjs": "Fraction", "n": 3, "d": 8}`
	   * @return {BigNumber}
	   */


	  Fraction$1.fromJSON = function (json) {
	    return new Fraction$1(json);
	  };

	  return Fraction$1;
	}, {
	  isClass: true
	});

	var name$10 = 'Matrix';
	var dependencies$10 = [];
	var createMatrixClass = /* #__PURE__ */factory(name$10, dependencies$10, () => {
	  /**
	   * @constructor Matrix
	   *
	   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional
	   * array. A matrix can be constructed as:
	   *
	   *     let matrix = math.matrix(data)
	   *
	   * Matrix contains the functions to resize, get and set values, get the size,
	   * clone the matrix and to convert the matrix to a vector, array, or scalar.
	   * Furthermore, one can iterate over the matrix using map and forEach.
	   * The internal Array of the Matrix can be accessed using the function valueOf.
	   *
	   * Example usage:
	   *
	   *     let matrix = math.matrix([[1, 2], [3, 4]])
	   *     matix.size()              // [2, 2]
	   *     matrix.resize([3, 2], 5)
	   *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]
	   *     matrix.subset([1,2])       // 3 (indexes are zero-based)
	   *
	   */
	  function Matrix() {
	    if (!(this instanceof Matrix)) {
	      throw new SyntaxError('Constructor must be called with the new operator');
	    }
	  }
	  /**
	   * Attach type information
	   */


	  Matrix.prototype.type = 'Matrix';
	  Matrix.prototype.isMatrix = true;
	  /**
	   * Get the storage format used by the matrix.
	   *
	   * Usage:
	   *     const format = matrix.storage()   // retrieve storage format
	   *
	   * @return {string}           The storage format.
	   */

	  Matrix.prototype.storage = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke storage on a Matrix interface');
	  };
	  /**
	   * Get the datatype of the data stored in the matrix.
	   *
	   * Usage:
	   *     const format = matrix.datatype()    // retrieve matrix datatype
	   *
	   * @return {string}           The datatype.
	   */


	  Matrix.prototype.datatype = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke datatype on a Matrix interface');
	  };
	  /**
	   * Create a new Matrix With the type of the current matrix instance
	   * @param {Array | Object} data
	   * @param {string} [datatype]
	   */


	  Matrix.prototype.create = function (data, datatype) {
	    throw new Error('Cannot invoke create on a Matrix interface');
	  };
	  /**
	   * Get a subset of the matrix, or replace a subset of the matrix.
	   *
	   * Usage:
	   *     const subset = matrix.subset(index)               // retrieve subset
	   *     const value = matrix.subset(index, replacement)   // replace subset
	   *
	   * @param {Index} index
	   * @param {Array | Matrix | *} [replacement]
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be filled with zeros.
	   */


	  Matrix.prototype.subset = function (index, replacement, defaultValue) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke subset on a Matrix interface');
	  };
	  /**
	   * Get a single element from the matrix.
	   * @param {number[]} index   Zero-based index
	   * @return {*} value
	   */


	  Matrix.prototype.get = function (index) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke get on a Matrix interface');
	  };
	  /**
	   * Replace a single element in the matrix.
	   * @param {number[]} index   Zero-based index
	   * @param {*} value
	   * @param {*} [defaultValue]        Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be left undefined.
	   * @return {Matrix} self
	   */


	  Matrix.prototype.set = function (index, value, defaultValue) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke set on a Matrix interface');
	  };
	  /**
	   * Resize the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (resize in place).
	   *
	   * @param {number[]} size           The new size the matrix should have.
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
	   *                                  If not provided, the matrix elements will
	   *                                  be filled with zeros.
	   * @param {boolean} [copy]          Return a resized copy of the matrix
	   *
	   * @return {Matrix}                 The resized matrix
	   */


	  Matrix.prototype.resize = function (size, defaultValue) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke resize on a Matrix interface');
	  };
	  /**
	   * Reshape the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (reshape in place).
	   *
	   * @param {number[]} size           The new size the matrix should have.
	   * @param {boolean} [copy]          Return a reshaped copy of the matrix
	   *
	   * @return {Matrix}                 The reshaped matrix
	   */


	  Matrix.prototype.reshape = function (size, defaultValue) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke reshape on a Matrix interface');
	  };
	  /**
	   * Create a clone of the matrix
	   * @return {Matrix} clone
	   */


	  Matrix.prototype.clone = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke clone on a Matrix interface');
	  };
	  /**
	   * Retrieve the size of the matrix.
	   * @returns {number[]} size
	   */


	  Matrix.prototype.size = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke size on a Matrix interface');
	  };
	  /**
	   * Create a new matrix with the results of the callback function executed on
	   * each entry of the matrix.
	   * @param {Function} callback   The callback function is invoked with three
	   *                              parameters: the value of the element, the index
	   *                              of the element, and the Matrix being traversed.
	   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
	   *
	   * @return {Matrix} matrix
	   */


	  Matrix.prototype.map = function (callback, skipZeros) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke map on a Matrix interface');
	  };
	  /**
	   * Execute a callback function on each entry of the matrix.
	   * @param {Function} callback   The callback function is invoked with three
	   *                              parameters: the value of the element, the index
	   *                              of the element, and the Matrix being traversed.
	   */


	  Matrix.prototype.forEach = function (callback) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke forEach on a Matrix interface');
	  };
	  /**
	   * Iterate over the matrix elements
	   * @return {Iterable<{ value, index: number[] }>}
	   */


	  Matrix.prototype[Symbol.iterator] = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot iterate a Matrix interface');
	  };
	  /**
	   * Create an Array with a copy of the data of the Matrix
	   * @returns {Array} array
	   */


	  Matrix.prototype.toArray = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke toArray on a Matrix interface');
	  };
	  /**
	   * Get the primitive value of the Matrix: a multidimensional array
	   * @returns {Array} array
	   */


	  Matrix.prototype.valueOf = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke valueOf on a Matrix interface');
	  };
	  /**
	   * Get a string representation of the matrix, with optional formatting options.
	   * @param {Object | number | Function} [options]  Formatting options. See
	   *                                                lib/utils/number:format for a
	   *                                                description of the available
	   *                                                options.
	   * @returns {string} str
	   */


	  Matrix.prototype.format = function (options) {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke format on a Matrix interface');
	  };
	  /**
	   * Get a string representation of the matrix
	   * @returns {string} str
	   */


	  Matrix.prototype.toString = function () {
	    // must be implemented by each of the Matrix implementations
	    throw new Error('Cannot invoke toString on a Matrix interface');
	  };

	  return Matrix;
	}, {
	  isClass: true
	});

	var name$$ = 'DenseMatrix';
	var dependencies$$ = ['Matrix'];
	var createDenseMatrixClass = /* #__PURE__ */factory(name$$, dependencies$$, _ref => {
	  var {
	    Matrix
	  } = _ref;
	  /**
	   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
	   * @class DenseMatrix
	   * @enum {{ value, index: number[] }}
	   */

	  function DenseMatrix(data, datatype) {
	    if (!(this instanceof DenseMatrix)) {
	      throw new SyntaxError('Constructor must be called with the new operator');
	    }

	    if (datatype && !isString$1(datatype)) {
	      throw new Error('Invalid datatype: ' + datatype);
	    }

	    if (isMatrix(data)) {
	      // check data is a DenseMatrix
	      if (data.type === 'DenseMatrix') {
	        // clone data & size
	        this._data = clone(data._data);
	        this._size = clone(data._size);
	        this._datatype = datatype || data._datatype;
	      } else {
	        // build data from existing matrix
	        this._data = data.toArray();
	        this._size = data.size();
	        this._datatype = datatype || data._datatype;
	      }
	    } else if (data && isArray(data.data) && isArray(data.size)) {
	      // initialize fields from JSON representation
	      this._data = data.data;
	      this._size = data.size; // verify the dimensions of the array

	      validate(this._data, this._size);
	      this._datatype = datatype || data.datatype;
	    } else if (isArray(data)) {
	      // replace nested Matrices with Arrays
	      this._data = preprocess(data); // get the dimensions of the array

	      this._size = arraySize(this._data); // verify the dimensions of the array, TODO: compute size while processing array

	      validate(this._data, this._size); // data type unknown

	      this._datatype = datatype;
	    } else if (data) {
	      // unsupported type
	      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
	    } else {
	      // nothing provided
	      this._data = [];
	      this._size = [0];
	      this._datatype = datatype;
	    }
	  }

	  DenseMatrix.prototype = new Matrix();
	  /**
	   * Create a new DenseMatrix
	   */

	  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {
	    return new DenseMatrix(data, datatype);
	  };
	  /**
	   * Attach type information
	   */


	  DenseMatrix.prototype.type = 'DenseMatrix';
	  DenseMatrix.prototype.isDenseMatrix = true;
	  /**
	   * Get the matrix type
	   *
	   * Usage:
	   *    const matrixType = matrix.getDataType()  // retrieves the matrix type
	   *
	   * @memberOf DenseMatrix
	   * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
	   */

	  DenseMatrix.prototype.getDataType = function () {
	    return getArrayDataType(this._data, typeOf);
	  };
	  /**
	   * Get the storage format used by the matrix.
	   *
	   * Usage:
	   *     const format = matrix.storage()  // retrieve storage format
	   *
	   * @memberof DenseMatrix
	   * @return {string}           The storage format.
	   */


	  DenseMatrix.prototype.storage = function () {
	    return 'dense';
	  };
	  /**
	   * Get the datatype of the data stored in the matrix.
	   *
	   * Usage:
	   *     const format = matrix.datatype()   // retrieve matrix datatype
	   *
	   * @memberof DenseMatrix
	   * @return {string}           The datatype.
	   */


	  DenseMatrix.prototype.datatype = function () {
	    return this._datatype;
	  };
	  /**
	   * Create a new DenseMatrix
	   * @memberof DenseMatrix
	   * @param {Array} data
	   * @param {string} [datatype]
	   */


	  DenseMatrix.prototype.create = function (data, datatype) {
	    return new DenseMatrix(data, datatype);
	  };
	  /**
	   * Get a subset of the matrix, or replace a subset of the matrix.
	   *
	   * Usage:
	   *     const subset = matrix.subset(index)               // retrieve subset
	   *     const value = matrix.subset(index, replacement)   // replace subset
	   *
	   * @memberof DenseMatrix
	   * @param {Index} index
	   * @param {Array | Matrix | *} [replacement]
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be filled with zeros.
	   */


	  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {
	    switch (arguments.length) {
	      case 1:
	        return _get(this, index);
	      // intentional fall through

	      case 2:
	      case 3:
	        return _set(this, index, replacement, defaultValue);

	      default:
	        throw new SyntaxError('Wrong number of arguments');
	    }
	  };
	  /**
	   * Get a single element from the matrix.
	   * @memberof DenseMatrix
	   * @param {number[]} index   Zero-based index
	   * @return {*} value
	   */


	  DenseMatrix.prototype.get = function (index) {
	    if (!isArray(index)) {
	      throw new TypeError('Array expected');
	    }

	    if (index.length !== this._size.length) {
	      throw new DimensionError(index.length, this._size.length);
	    } // check index


	    for (var x = 0; x < index.length; x++) {
	      validateIndex(index[x], this._size[x]);
	    }

	    var data = this._data;

	    for (var i = 0, ii = index.length; i < ii; i++) {
	      var indexI = index[i];
	      validateIndex(indexI, data.length);
	      data = data[indexI];
	    }

	    return data;
	  };
	  /**
	   * Replace a single element in the matrix.
	   * @memberof DenseMatrix
	   * @param {number[]} index   Zero-based index
	   * @param {*} value
	   * @param {*} [defaultValue]        Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be left undefined.
	   * @return {DenseMatrix} self
	   */


	  DenseMatrix.prototype.set = function (index, value, defaultValue) {
	    if (!isArray(index)) {
	      throw new TypeError('Array expected');
	    }

	    if (index.length < this._size.length) {
	      throw new DimensionError(index.length, this._size.length, '<');
	    }

	    var i, ii, indexI; // enlarge matrix when needed

	    var size = index.map(function (i) {
	      return i + 1;
	    });

	    _fit(this, size, defaultValue); // traverse over the dimensions


	    var data = this._data;

	    for (i = 0, ii = index.length - 1; i < ii; i++) {
	      indexI = index[i];
	      validateIndex(indexI, data.length);
	      data = data[indexI];
	    } // set new value


	    indexI = index[index.length - 1];
	    validateIndex(indexI, data.length);
	    data[indexI] = value;
	    return this;
	  };
	  /**
	   * Get a submatrix of this matrix
	   * @memberof DenseMatrix
	   * @param {DenseMatrix} matrix
	   * @param {Index} index   Zero-based index
	   * @private
	   */


	  function _get(matrix, index) {
	    if (!isIndex(index)) {
	      throw new TypeError('Invalid index');
	    }

	    var isScalar = index.isScalar();

	    if (isScalar) {
	      // return a scalar
	      return matrix.get(index.min());
	    } else {
	      // validate dimensions
	      var size = index.size();

	      if (size.length !== matrix._size.length) {
	        throw new DimensionError(size.length, matrix._size.length);
	      } // validate if any of the ranges in the index is out of range


	      var min = index.min();
	      var max = index.max();

	      for (var i = 0, ii = matrix._size.length; i < ii; i++) {
	        validateIndex(min[i], matrix._size[i]);
	        validateIndex(max[i], matrix._size[i]);
	      } // retrieve submatrix
	      // TODO: more efficient when creating an empty matrix and setting _data and _size manually


	      return new DenseMatrix(_getSubmatrix(matrix._data, index, size.length, 0), matrix._datatype);
	    }
	  }
	  /**
	   * Recursively get a submatrix of a multi dimensional matrix.
	   * Index is not checked for correct number or length of dimensions.
	   * @memberof DenseMatrix
	   * @param {Array} data
	   * @param {Index} index
	   * @param {number} dims   Total number of dimensions
	   * @param {number} dim    Current dimension
	   * @return {Array} submatrix
	   * @private
	   */


	  function _getSubmatrix(data, index, dims, dim) {
	    var last = dim === dims - 1;
	    var range = index.dimension(dim);

	    if (last) {
	      return range.map(function (i) {
	        validateIndex(i, data.length);
	        return data[i];
	      }).valueOf();
	    } else {
	      return range.map(function (i) {
	        validateIndex(i, data.length);
	        var child = data[i];
	        return _getSubmatrix(child, index, dims, dim + 1);
	      }).valueOf();
	    }
	  }
	  /**
	   * Replace a submatrix in this matrix
	   * Indexes are zero-based.
	   * @memberof DenseMatrix
	   * @param {DenseMatrix} matrix
	   * @param {Index} index
	   * @param {DenseMatrix | Array | *} submatrix
	   * @param {*} defaultValue          Default value, filled in on new entries when
	   *                                  the matrix is resized.
	   * @return {DenseMatrix} matrix
	   * @private
	   */


	  function _set(matrix, index, submatrix, defaultValue) {
	    if (!index || index.isIndex !== true) {
	      throw new TypeError('Invalid index');
	    } // get index size and check whether the index contains a single value


	    var iSize = index.size();
	    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

	    var sSize;

	    if (isMatrix(submatrix)) {
	      sSize = submatrix.size();
	      submatrix = submatrix.valueOf();
	    } else {
	      sSize = arraySize(submatrix);
	    }

	    if (isScalar) {
	      // set a scalar
	      // check whether submatrix is a scalar
	      if (sSize.length !== 0) {
	        throw new TypeError('Scalar expected');
	      }

	      matrix.set(index.min(), submatrix, defaultValue);
	    } else {
	      // set a submatrix
	      // validate dimensions
	      if (iSize.length < matrix._size.length) {
	        throw new DimensionError(iSize.length, matrix._size.length, '<');
	      }

	      if (sSize.length < iSize.length) {
	        // calculate number of missing outer dimensions
	        var i = 0;
	        var outer = 0;

	        while (iSize[i] === 1 && sSize[i] === 1) {
	          i++;
	        }

	        while (iSize[i] === 1) {
	          outer++;
	          i++;
	        } // unsqueeze both outer and inner dimensions


	        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
	      } // check whether the size of the submatrix matches the index size


	      if (!deepStrictEqual(iSize, sSize)) {
	        throw new DimensionError(iSize, sSize, '>');
	      } // enlarge matrix when needed


	      var size = index.max().map(function (i) {
	        return i + 1;
	      });

	      _fit(matrix, size, defaultValue); // insert the sub matrix


	      var dims = iSize.length;
	      var dim = 0;

	      _setSubmatrix(matrix._data, index, submatrix, dims, dim);
	    }

	    return matrix;
	  }
	  /**
	   * Replace a submatrix of a multi dimensional matrix.
	   * @memberof DenseMatrix
	   * @param {Array} data
	   * @param {Index} index
	   * @param {Array} submatrix
	   * @param {number} dims   Total number of dimensions
	   * @param {number} dim
	   * @private
	   */


	  function _setSubmatrix(data, index, submatrix, dims, dim) {
	    var last = dim === dims - 1;
	    var range = index.dimension(dim);

	    if (last) {
	      range.forEach(function (dataIndex, subIndex) {
	        validateIndex(dataIndex);
	        data[dataIndex] = submatrix[subIndex[0]];
	      });
	    } else {
	      range.forEach(function (dataIndex, subIndex) {
	        validateIndex(dataIndex);

	        _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
	      });
	    }
	  }
	  /**
	   * Resize the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (resize in place).
	   *
	   * @memberof DenseMatrix
	   * @param {number[] || Matrix} size The new size the matrix should have.
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
	   *                                  If not provided, the matrix elements will
	   *                                  be filled with zeros.
	   * @param {boolean} [copy]          Return a resized copy of the matrix
	   *
	   * @return {Matrix}                 The resized matrix
	   */


	  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {
	    // validate arguments
	    if (!isCollection(size)) {
	      throw new TypeError('Array or Matrix expected');
	    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector


	    var sizeArray = size.valueOf().map(value => {
	      return Array.isArray(value) && value.length === 1 ? value[0] : value;
	    }); // matrix to resize

	    var m = copy ? this.clone() : this; // resize matrix

	    return _resize(m, sizeArray, defaultValue);
	  };

	  function _resize(matrix, size, defaultValue) {
	    // check size
	    if (size.length === 0) {
	      // first value in matrix
	      var v = matrix._data; // go deep

	      while (isArray(v)) {
	        v = v[0];
	      }

	      return v;
	    } // resize matrix


	    matrix._size = size.slice(0); // copy the array

	    matrix._data = resize(matrix._data, matrix._size, defaultValue); // return matrix

	    return matrix;
	  }
	  /**
	   * Reshape the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (reshape in place).
	   *
	   * NOTE: This might be better suited to copy by default, instead of modifying
	   *       in place. For now, it operates in place to remain consistent with
	   *       resize().
	   *
	   * @memberof DenseMatrix
	   * @param {number[]} size           The new size the matrix should have.
	   * @param {boolean} [copy]          Return a reshaped copy of the matrix
	   *
	   * @return {Matrix}                 The reshaped matrix
	   */


	  DenseMatrix.prototype.reshape = function (size, copy) {
	    var m = copy ? this.clone() : this;
	    m._data = reshape(m._data, size);

	    var currentLength = m._size.reduce((length, size) => length * size);

	    m._size = processSizesWildcard(size, currentLength);
	    return m;
	  };
	  /**
	   * Enlarge the matrix when it is smaller than given size.
	   * If the matrix is larger or equal sized, nothing is done.
	   * @memberof DenseMatrix
	   * @param {DenseMatrix} matrix           The matrix to be resized
	   * @param {number[]} size
	   * @param {*} defaultValue          Default value, filled in on new entries.
	   * @private
	   */


	  function _fit(matrix, size, defaultValue) {
	    var // copy the array
	    newSize = matrix._size.slice(0);

	    var changed = false; // add dimensions when needed

	    while (newSize.length < size.length) {
	      newSize.push(0);
	      changed = true;
	    } // enlarge size when needed


	    for (var i = 0, ii = size.length; i < ii; i++) {
	      if (size[i] > newSize[i]) {
	        newSize[i] = size[i];
	        changed = true;
	      }
	    }

	    if (changed) {
	      // resize only when size is changed
	      _resize(matrix, newSize, defaultValue);
	    }
	  }
	  /**
	   * Create a clone of the matrix
	   * @memberof DenseMatrix
	   * @return {DenseMatrix} clone
	   */


	  DenseMatrix.prototype.clone = function () {
	    var m = new DenseMatrix({
	      data: clone(this._data),
	      size: clone(this._size),
	      datatype: this._datatype
	    });
	    return m;
	  };
	  /**
	   * Retrieve the size of the matrix.
	   * @memberof DenseMatrix
	   * @returns {number[]} size
	   */


	  DenseMatrix.prototype.size = function () {
	    return this._size.slice(0); // return a clone of _size
	  };
	  /**
	   * Create a new matrix with the results of the callback function executed on
	   * each entry of the matrix.
	   * @memberof DenseMatrix
	   * @param {Function} callback   The callback function is invoked with three
	   *                              parameters: the value of the element, the index
	   *                              of the element, and the Matrix being traversed.
	   *
	   * @return {DenseMatrix} matrix
	   */


	  DenseMatrix.prototype.map = function (callback) {
	    // matrix instance
	    var me = this;

	    var recurse = function recurse(value, index) {
	      if (isArray(value)) {
	        return value.map(function (child, i) {
	          return recurse(child, index.concat(i));
	        });
	      } else {
	        return callback(value, index, me);
	      }
	    }; // determine the new datatype when the original matrix has datatype defined
	    // TODO: should be done in matrix constructor instead


	    var data = recurse(this._data, []);
	    var datatype = this._datatype !== undefined ? getArrayDataType(data, typeOf) : undefined;
	    return new DenseMatrix(data, datatype);
	  };
	  /**
	   * Execute a callback function on each entry of the matrix.
	   * @memberof DenseMatrix
	   * @param {Function} callback   The callback function is invoked with three
	   *                              parameters: the value of the element, the index
	   *                              of the element, and the Matrix being traversed.
	   */


	  DenseMatrix.prototype.forEach = function (callback) {
	    // matrix instance
	    var me = this;

	    var recurse = function recurse(value, index) {
	      if (isArray(value)) {
	        value.forEach(function (child, i) {
	          recurse(child, index.concat(i));
	        });
	      } else {
	        callback(value, index, me);
	      }
	    };

	    recurse(this._data, []);
	  };
	  /**
	   * Iterate over the matrix elements
	   * @return {Iterable<{ value, index: number[] }>}
	   */


	  DenseMatrix.prototype[Symbol.iterator] = function* () {
	    var recurse = function* recurse(value, index) {
	      if (isArray(value)) {
	        for (var i = 0; i < value.length; i++) {
	          yield* recurse(value[i], index.concat(i));
	        }
	      } else {
	        yield {
	          value,
	          index
	        };
	      }
	    };

	    yield* recurse(this._data, []);
	  };
	  /**
	   * Returns an array containing the rows of a 2D matrix
	   * @returns {Array<Matrix>}
	   */


	  DenseMatrix.prototype.rows = function () {
	    var result = [];
	    var s = this.size();

	    if (s.length !== 2) {
	      throw new TypeError('Rows can only be returned for a 2D matrix.');
	    }

	    var data = this._data;

	    for (var row of data) {
	      result.push(new DenseMatrix([row], this._datatype));
	    }

	    return result;
	  };
	  /**
	   * Returns an array containing the columns of a 2D matrix
	   * @returns {Array<Matrix>}
	   */


	  DenseMatrix.prototype.columns = function () {
	    var _this = this;

	    var result = [];
	    var s = this.size();

	    if (s.length !== 2) {
	      throw new TypeError('Rows can only be returned for a 2D matrix.');
	    }

	    var data = this._data;

	    var _loop = function _loop(i) {
	      var col = data.map(row => [row[i]]);
	      result.push(new DenseMatrix(col, _this._datatype));
	    };

	    for (var i = 0; i < s[1]; i++) {
	      _loop(i);
	    }

	    return result;
	  };
	  /**
	   * Create an Array with a copy of the data of the DenseMatrix
	   * @memberof DenseMatrix
	   * @returns {Array} array
	   */


	  DenseMatrix.prototype.toArray = function () {
	    return clone(this._data);
	  };
	  /**
	   * Get the primitive value of the DenseMatrix: a multidimensional array
	   * @memberof DenseMatrix
	   * @returns {Array} array
	   */


	  DenseMatrix.prototype.valueOf = function () {
	    return this._data;
	  };
	  /**
	   * Get a string representation of the matrix, with optional formatting options.
	   * @memberof DenseMatrix
	   * @param {Object | number | Function} [options]  Formatting options. See
	   *                                                lib/utils/number:format for a
	   *                                                description of the available
	   *                                                options.
	   * @returns {string} str
	   */


	  DenseMatrix.prototype.format = function (options) {
	    return format(this._data, options);
	  };
	  /**
	   * Get a string representation of the matrix
	   * @memberof DenseMatrix
	   * @returns {string} str
	   */


	  DenseMatrix.prototype.toString = function () {
	    return format(this._data);
	  };
	  /**
	   * Get a JSON representation of the matrix
	   * @memberof DenseMatrix
	   * @returns {Object}
	   */


	  DenseMatrix.prototype.toJSON = function () {
	    return {
	      mathjs: 'DenseMatrix',
	      data: this._data,
	      size: this._size,
	      datatype: this._datatype
	    };
	  };
	  /**
	   * Get the kth Matrix diagonal.
	   *
	   * @memberof DenseMatrix
	   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
	   *
	   * @returns {Matrix}                     The matrix with the diagonal values.
	   */


	  DenseMatrix.prototype.diagonal = function (k) {
	    // validate k if any
	    if (k) {
	      // convert BigNumber to a number
	      if (isBigNumber(k)) {
	        k = k.toNumber();
	      } // is must be an integer


	      if (!isNumber(k) || !isInteger(k)) {
	        throw new TypeError('The parameter k must be an integer number');
	      }
	    } else {
	      // default value
	      k = 0;
	    }

	    var kSuper = k > 0 ? k : 0;
	    var kSub = k < 0 ? -k : 0; // rows & columns

	    var rows = this._size[0];
	    var columns = this._size[1]; // number diagonal values

	    var n = Math.min(rows - kSub, columns - kSuper); // x is a matrix get diagonal from matrix

	    var data = []; // loop rows

	    for (var i = 0; i < n; i++) {
	      data[i] = this._data[i + kSub][i + kSuper];
	    } // create DenseMatrix


	    return new DenseMatrix({
	      data: data,
	      size: [n],
	      datatype: this._datatype
	    });
	  };
	  /**
	   * Create a diagonal matrix.
	   *
	   * @memberof DenseMatrix
	   * @param {Array} size                     The matrix size.
	   * @param {number | Matrix | Array } value The values for the diagonal.
	   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.
	   * @param {number} [defaultValue]          The default value for non-diagonal
	   * @param {string} [datatype]              The datatype for the diagonal
	   *
	   * @returns {DenseMatrix}
	   */


	  DenseMatrix.diagonal = function (size, value, k, defaultValue) {
	    if (!isArray(size)) {
	      throw new TypeError('Array expected, size parameter');
	    }

	    if (size.length !== 2) {
	      throw new Error('Only two dimensions matrix are supported');
	    } // map size & validate


	    size = size.map(function (s) {
	      // check it is a big number
	      if (isBigNumber(s)) {
	        // convert it
	        s = s.toNumber();
	      } // validate arguments


	      if (!isNumber(s) || !isInteger(s) || s < 1) {
	        throw new Error('Size values must be positive integers');
	      }

	      return s;
	    }); // validate k if any

	    if (k) {
	      // convert BigNumber to a number
	      if (isBigNumber(k)) {
	        k = k.toNumber();
	      } // is must be an integer


	      if (!isNumber(k) || !isInteger(k)) {
	        throw new TypeError('The parameter k must be an integer number');
	      }
	    } else {
	      // default value
	      k = 0;
	    }

	    var kSuper = k > 0 ? k : 0;
	    var kSub = k < 0 ? -k : 0; // rows and columns

	    var rows = size[0];
	    var columns = size[1]; // number of non-zero items

	    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

	    var _value; // check value


	    if (isArray(value)) {
	      // validate array
	      if (value.length !== n) {
	        // number of values in array must be n
	        throw new Error('Invalid value array length');
	      } // define function


	      _value = function _value(i) {
	        // return value @ i
	        return value[i];
	      };
	    } else if (isMatrix(value)) {
	      // matrix size
	      var ms = value.size(); // validate matrix

	      if (ms.length !== 1 || ms[0] !== n) {
	        // number of values in array must be n
	        throw new Error('Invalid matrix length');
	      } // define function


	      _value = function _value(i) {
	        // return value @ i
	        return value.get([i]);
	      };
	    } else {
	      // define function
	      _value = function _value() {
	        // return value
	        return value;
	      };
	    } // discover default value if needed


	    if (!defaultValue) {
	      // check first value in array
	      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero
	      : 0;
	    } // empty array


	    var data = []; // check we need to resize array

	    if (size.length > 0) {
	      // resize array
	      data = resize(data, size, defaultValue); // fill diagonal

	      for (var d = 0; d < n; d++) {
	        data[d + kSub][d + kSuper] = _value(d);
	      }
	    } // create DenseMatrix


	    return new DenseMatrix({
	      data: data,
	      size: [rows, columns]
	    });
	  };
	  /**
	   * Generate a matrix from a JSON object
	   * @memberof DenseMatrix
	   * @param {Object} json  An object structured like
	   *                       `{"mathjs": "DenseMatrix", data: [], size: []}`,
	   *                       where mathjs is optional
	   * @returns {DenseMatrix}
	   */


	  DenseMatrix.fromJSON = function (json) {
	    return new DenseMatrix(json);
	  };
	  /**
	   * Swap rows i and j in Matrix.
	   *
	   * @memberof DenseMatrix
	   * @param {number} i       Matrix row index 1
	   * @param {number} j       Matrix row index 2
	   *
	   * @return {Matrix}        The matrix reference
	   */


	  DenseMatrix.prototype.swapRows = function (i, j) {
	    // check index
	    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
	      throw new Error('Row index must be positive integers');
	    } // check dimensions


	    if (this._size.length !== 2) {
	      throw new Error('Only two dimensional matrix is supported');
	    } // validate index


	    validateIndex(i, this._size[0]);
	    validateIndex(j, this._size[0]); // swap rows

	    DenseMatrix._swapRows(i, j, this._data); // return current instance


	    return this;
	  };
	  /**
	   * Swap rows i and j in Dense Matrix data structure.
	   *
	   * @param {number} i       Matrix row index 1
	   * @param {number} j       Matrix row index 2
	   * @param {Array} data     Matrix data
	   */


	  DenseMatrix._swapRows = function (i, j, data) {
	    // swap values i <-> j
	    var vi = data[i];
	    data[i] = data[j];
	    data[j] = vi;
	  };
	  /**
	   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
	   * Matrices. Replaces all nested Matrices with Arrays
	   * @memberof DenseMatrix
	   * @param {Array} data
	   * @return {Array} data
	   */


	  function preprocess(data) {
	    for (var i = 0, ii = data.length; i < ii; i++) {
	      var elem = data[i];

	      if (isArray(elem)) {
	        data[i] = preprocess(elem);
	      } else if (elem && elem.isMatrix === true) {
	        data[i] = preprocess(elem.valueOf());
	      }
	    }

	    return data;
	  }

	  return DenseMatrix;
	}, {
	  isClass: true
	});

	/**
	 * Execute the callback function element wise for each element in array and any
	 * nested array
	 * Returns an array with the results
	 * @param {Array | Matrix} array
	 * @param {Function} callback   The callback is called with two parameters:
	 *                              value1 and value2, which contain the current
	 *                              element of both arrays.
	 * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
	 *
	 * @return {Array | Matrix} res
	 */

	function deepMap(array, callback, skipZeros) {
	  if (array && typeof array.map === 'function') {
	    // TODO: replace array.map with a for loop to improve performance
	    return array.map(function (x) {
	      return deepMap(x, callback);
	    });
	  } else {
	    return callback(array);
	  }
	}

	var n1$1 = 'number';
	var n2 = 'number, number';
	function absNumber(a) {
	  return Math.abs(a);
	}
	absNumber.signature = n1$1;
	function addNumber(a, b) {
	  return a + b;
	}
	addNumber.signature = n2;
	function multiplyNumber(a, b) {
	  return a * b;
	}
	multiplyNumber.signature = n2;
	function unaryMinusNumber(x) {
	  return -x;
	}
	unaryMinusNumber.signature = n1$1;
	function signNumber(x) {
	  return sign$1(x);
	}
	signNumber.signature = n1$1;
	/**
	 * Calculates the power of x to y, x^y, for two numbers.
	 * @param {number} x
	 * @param {number} y
	 * @return {number} res
	 */

	function powNumber(x, y) {
	  // x^Infinity === 0 if -1 < x < 1
	  // A real number 0 is returned instead of complex(0)
	  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
	    return 0;
	  }

	  return Math.pow(x, y);
	}
	powNumber.signature = n2;

	var n1 = 'number';
	function isZeroNumber(x) {
	  return x === 0;
	}
	isZeroNumber.signature = n1;

	var name$_ = 'isZero';
	var dependencies$_ = ['typed'];
	var createIsZero = /* #__PURE__ */factory(name$_, dependencies$_, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Test whether a value is zero.
	   * The function can check for zero for types `number`, `BigNumber`, `Fraction`,
	   * `Complex`, and `Unit`.
	   *
	   * The function is evaluated element-wise in case of Array or Matrix input.
	   *
	   * Syntax:
	   *
	   *     math.isZero(x)
	   *
	   * Examples:
	   *
	   *    math.isZero(0)                     // returns true
	   *    math.isZero(2)                     // returns false
	   *    math.isZero(0.5)                   // returns false
	   *    math.isZero(math.bignumber(0))     // returns true
	   *    math.isZero(math.fraction(0))      // returns true
	   *    math.isZero(math.fraction(1,3))    // returns false
	   *    math.isZero(math.complex('2 - 4i') // returns false
	   *    math.isZero(math.complex('0i')     // returns true
	   *    math.isZero('0')                   // returns true
	   *    math.isZero('2')                   // returns false
	   *    math.isZero([2, 0, -3]')           // returns [false, true, false]
	   *
	   * See also:
	   *
	   *    isNumeric, isPositive, isNegative, isInteger
	   *
	   * @param {number | BigNumber | Complex | Fraction | Unit | Array | Matrix} x       Value to be tested
	   * @return {boolean}  Returns true when `x` is zero.
	   *                    Throws an error in case of an unknown data type.
	   */

	  return typed(name$_, {
	    number: isZeroNumber,
	    BigNumber: function BigNumber(x) {
	      return x.isZero();
	    },
	    Complex: function Complex(x) {
	      return x.re === 0 && x.im === 0;
	    },
	    Fraction: function Fraction(x) {
	      return x.d === 1 && x.n === 0;
	    },
	    Unit: function Unit(x) {
	      return this(x.value);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	/**
	 * Compares two BigNumbers.
	 * @param {BigNumber} x       First value to compare
	 * @param {BigNumber} y       Second value to compare
	 * @param {number} [epsilon]  The maximum relative difference between x and y
	 *                            If epsilon is undefined or null, the function will
	 *                            test whether x and y are exactly equal.
	 * @return {boolean} whether the two numbers are nearly equal
	 */
	function nearlyEqual(x, y, epsilon) {
	  // if epsilon is null or undefined, test whether x and y are exactly equal
	  if (epsilon === null || epsilon === undefined) {
	    return x.eq(y);
	  } // use "==" operator, handles infinities


	  if (x.eq(y)) {
	    return true;
	  } // NaN


	  if (x.isNaN() || y.isNaN()) {
	    return false;
	  } // at this point x and y should be finite


	  if (x.isFinite() && y.isFinite()) {
	    // check numbers are very close, needed when comparing numbers near zero
	    var diff = x.minus(y).abs();

	    if (diff.isZero()) {
	      return true;
	    } else {
	      // use relative error
	      var max = x.constructor.max(x.abs(), y.abs());
	      return diff.lte(max.times(epsilon));
	    }
	  } // Infinite and Number or negative Infinite and positive Infinite cases


	  return false;
	}

	/**
	 * Test whether two complex values are equal provided a given epsilon.
	 * Does not use or change the global Complex.EPSILON setting
	 * @param {Complex} x
	 * @param {Complex} y
	 * @param {number} epsilon
	 * @returns {boolean}
	 */

	function complexEquals(x, y, epsilon) {
	  return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
	}

	var name$Z = 'equalScalar';
	var dependencies$Z = ['typed', 'config'];
	var createEqualScalar = /* #__PURE__ */factory(name$Z, dependencies$Z, _ref => {
	  var {
	    typed,
	    config
	  } = _ref;
	  /**
	   * Test whether two scalar values are nearly equal.
	   *
	   * @param  {number | BigNumber | Fraction | boolean | Complex | Unit} x   First value to compare
	   * @param  {number | BigNumber | Fraction | boolean | Complex} y          Second value to compare
	   * @return {boolean}                                                  Returns true when the compared values are equal, else returns false
	   * @private
	   */

	  return typed(name$Z, {
	    'boolean, boolean': function booleanBoolean(x, y) {
	      return x === y;
	    },
	    'number, number': function numberNumber(x, y) {
	      return nearlyEqual$1(x, y, config.epsilon);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.eq(y) || nearlyEqual(x, y, config.epsilon);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.equals(y);
	    },
	    'Complex, Complex': function ComplexComplex(x, y) {
	      return complexEquals(x, y, config.epsilon);
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (!x.equalBase(y)) {
	        throw new Error('Cannot compare units with different base');
	      }

	      return this(x.value, y.value);
	    }
	  });
	});
	factory(name$Z, ['typed', 'config'], _ref2 => {
	  var {
	    typed,
	    config
	  } = _ref2;
	  return typed(name$Z, {
	    'number, number': function numberNumber(x, y) {
	      return nearlyEqual$1(x, y, config.epsilon);
	    }
	  });
	});

	var name$Y = 'SparseMatrix';
	var dependencies$Y = ['typed', 'equalScalar', 'Matrix'];
	var createSparseMatrixClass = /* #__PURE__ */factory(name$Y, dependencies$Y, _ref => {
	  var {
	    typed,
	    equalScalar,
	    Matrix
	  } = _ref;
	  /**
	   * Sparse Matrix implementation. This type implements
	   * a [Compressed Column Storage](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
	   * format for two-dimensional sparse matrices.
	   * @class SparseMatrix
	   */

	  function SparseMatrix(data, datatype) {
	    if (!(this instanceof SparseMatrix)) {
	      throw new SyntaxError('Constructor must be called with the new operator');
	    }

	    if (datatype && !isString$1(datatype)) {
	      throw new Error('Invalid datatype: ' + datatype);
	    }

	    if (isMatrix(data)) {
	      // create from matrix
	      _createFromMatrix(this, data, datatype);
	    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
	      // initialize fields
	      this._values = data.values;
	      this._index = data.index;
	      this._ptr = data.ptr;
	      this._size = data.size;
	      this._datatype = datatype || data.datatype;
	    } else if (isArray(data)) {
	      // create from array
	      _createFromArray(this, data, datatype);
	    } else if (data) {
	      // unsupported type
	      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
	    } else {
	      // nothing provided
	      this._values = [];
	      this._index = [];
	      this._ptr = [0];
	      this._size = [0, 0];
	      this._datatype = datatype;
	    }
	  }

	  function _createFromMatrix(matrix, source, datatype) {
	    // check matrix type
	    if (source.type === 'SparseMatrix') {
	      // clone arrays
	      matrix._values = source._values ? clone(source._values) : undefined;
	      matrix._index = clone(source._index);
	      matrix._ptr = clone(source._ptr);
	      matrix._size = clone(source._size);
	      matrix._datatype = datatype || source._datatype;
	    } else {
	      // build from matrix data
	      _createFromArray(matrix, source.valueOf(), datatype || source._datatype);
	    }
	  }

	  function _createFromArray(matrix, data, datatype) {
	    // initialize fields
	    matrix._values = [];
	    matrix._index = [];
	    matrix._ptr = [];
	    matrix._datatype = datatype; // discover rows & columns, do not use math.size() to avoid looping array twice

	    var rows = data.length;
	    var columns = 0; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0;

	    if (isString$1(datatype)) {
	      // find signature that matches (datatype, datatype)
	      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

	      zero = typed.convert(0, datatype);
	    } // check we have rows (empty array)


	    if (rows > 0) {
	      // column index
	      var j = 0;

	      do {
	        // store pointer to values index
	        matrix._ptr.push(matrix._index.length); // loop rows


	        for (var i = 0; i < rows; i++) {
	          // current row
	          var row = data[i]; // check row is an array

	          if (isArray(row)) {
	            // update columns if needed (only on first column)
	            if (j === 0 && columns < row.length) {
	              columns = row.length;
	            } // check row has column


	            if (j < row.length) {
	              // value
	              var v = row[j]; // check value != 0

	              if (!eq(v, zero)) {
	                // store value
	                matrix._values.push(v); // index


	                matrix._index.push(i);
	              }
	            }
	          } else {
	            // update columns if needed (only on first column)
	            if (j === 0 && columns < 1) {
	              columns = 1;
	            } // check value != 0 (row is a scalar)


	            if (!eq(row, zero)) {
	              // store value
	              matrix._values.push(row); // index


	              matrix._index.push(i);
	            }
	          }
	        } // increment index


	        j++;
	      } while (j < columns);
	    } // store number of values in ptr


	    matrix._ptr.push(matrix._index.length); // size


	    matrix._size = [rows, columns];
	  }

	  SparseMatrix.prototype = new Matrix();
	  /**
	   * Create a new SparseMatrix
	   */

	  SparseMatrix.prototype.createSparseMatrix = function (data, datatype) {
	    return new SparseMatrix(data, datatype);
	  };
	  /**
	   * Attach type information
	   */


	  SparseMatrix.prototype.type = 'SparseMatrix';
	  SparseMatrix.prototype.isSparseMatrix = true;
	  /**
	   * Get the matrix type
	   *
	   * Usage:
	   *    const matrixType = matrix.getDataType()  // retrieves the matrix type
	   *
	   * @memberOf SparseMatrix
	   * @return {string}   type information; if multiple types are found from the Matrix, it will return "mixed"
	   */

	  SparseMatrix.prototype.getDataType = function () {
	    return getArrayDataType(this._values, typeOf);
	  };
	  /**
	   * Get the storage format used by the matrix.
	   *
	   * Usage:
	   *     const format = matrix.storage()   // retrieve storage format
	   *
	   * @memberof SparseMatrix
	   * @return {string}           The storage format.
	   */


	  SparseMatrix.prototype.storage = function () {
	    return 'sparse';
	  };
	  /**
	   * Get the datatype of the data stored in the matrix.
	   *
	   * Usage:
	   *     const format = matrix.datatype()    // retrieve matrix datatype
	   *
	   * @memberof SparseMatrix
	   * @return {string}           The datatype.
	   */


	  SparseMatrix.prototype.datatype = function () {
	    return this._datatype;
	  };
	  /**
	   * Create a new SparseMatrix
	   * @memberof SparseMatrix
	   * @param {Array} data
	   * @param {string} [datatype]
	   */


	  SparseMatrix.prototype.create = function (data, datatype) {
	    return new SparseMatrix(data, datatype);
	  };
	  /**
	   * Get the matrix density.
	   *
	   * Usage:
	   *     const density = matrix.density()                   // retrieve matrix density
	   *
	   * @memberof SparseMatrix
	   * @return {number}           The matrix density.
	   */


	  SparseMatrix.prototype.density = function () {
	    // rows & columns
	    var rows = this._size[0];
	    var columns = this._size[1]; // calculate density

	    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
	  };
	  /**
	   * Get a subset of the matrix, or replace a subset of the matrix.
	   *
	   * Usage:
	   *     const subset = matrix.subset(index)               // retrieve subset
	   *     const value = matrix.subset(index, replacement)   // replace subset
	   *
	   * @memberof SparseMatrix
	   * @param {Index} index
	   * @param {Array | Matrix | *} [replacement]
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be filled with zeros.
	   */


	  SparseMatrix.prototype.subset = function (index, replacement, defaultValue) {
	    // check it is a pattern matrix
	    if (!this._values) {
	      throw new Error('Cannot invoke subset on a Pattern only matrix');
	    } // check arguments


	    switch (arguments.length) {
	      case 1:
	        return _getsubset(this, index);
	      // intentional fall through

	      case 2:
	      case 3:
	        return _setsubset(this, index, replacement, defaultValue);

	      default:
	        throw new SyntaxError('Wrong number of arguments');
	    }
	  };

	  function _getsubset(matrix, idx) {
	    // check idx
	    if (!isIndex(idx)) {
	      throw new TypeError('Invalid index');
	    }

	    var isScalar = idx.isScalar();

	    if (isScalar) {
	      // return a scalar
	      return matrix.get(idx.min());
	    } // validate dimensions


	    var size = idx.size();

	    if (size.length !== matrix._size.length) {
	      throw new DimensionError(size.length, matrix._size.length);
	    } // vars


	    var i, ii, k, kk; // validate if any of the ranges in the index is out of range

	    var min = idx.min();
	    var max = idx.max();

	    for (i = 0, ii = matrix._size.length; i < ii; i++) {
	      validateIndex(min[i], matrix._size[i]);
	      validateIndex(max[i], matrix._size[i]);
	    } // matrix arrays


	    var mvalues = matrix._values;
	    var mindex = matrix._index;
	    var mptr = matrix._ptr; // rows & columns dimensions for result matrix

	    var rows = idx.dimension(0);
	    var columns = idx.dimension(1); // workspace & permutation vector

	    var w = [];
	    var pv = []; // loop rows in resulting matrix

	    rows.forEach(function (i, r) {
	      // update permutation vector
	      pv[i] = r[0]; // mark i in workspace

	      w[i] = true;
	    }); // result matrix arrays

	    var values = mvalues ? [] : undefined;
	    var index = [];
	    var ptr = []; // loop columns in result matrix

	    columns.forEach(function (j) {
	      // update ptr
	      ptr.push(index.length); // loop values in column j

	      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
	        // row
	        i = mindex[k]; // check row is in result matrix

	        if (w[i] === true) {
	          // push index
	          index.push(pv[i]); // check we need to process values

	          if (values) {
	            values.push(mvalues[k]);
	          }
	        }
	      }
	    }); // update ptr

	    ptr.push(index.length); // return matrix

	    return new SparseMatrix({
	      values: values,
	      index: index,
	      ptr: ptr,
	      size: size,
	      datatype: matrix._datatype
	    });
	  }

	  function _setsubset(matrix, index, submatrix, defaultValue) {
	    // check index
	    if (!index || index.isIndex !== true) {
	      throw new TypeError('Invalid index');
	    } // get index size and check whether the index contains a single value


	    var iSize = index.size();
	    var isScalar = index.isScalar(); // calculate the size of the submatrix, and convert it into an Array if needed

	    var sSize;

	    if (isMatrix(submatrix)) {
	      // submatrix size
	      sSize = submatrix.size(); // use array representation

	      submatrix = submatrix.toArray();
	    } else {
	      // get submatrix size (array, scalar)
	      sSize = arraySize(submatrix);
	    } // check index is a scalar


	    if (isScalar) {
	      // verify submatrix is a scalar
	      if (sSize.length !== 0) {
	        throw new TypeError('Scalar expected');
	      } // set value


	      matrix.set(index.min(), submatrix, defaultValue);
	    } else {
	      // validate dimensions, index size must be one or two dimensions
	      if (iSize.length !== 1 && iSize.length !== 2) {
	        throw new DimensionError(iSize.length, matrix._size.length, '<');
	      } // check submatrix and index have the same dimensions


	      if (sSize.length < iSize.length) {
	        // calculate number of missing outer dimensions
	        var i = 0;
	        var outer = 0;

	        while (iSize[i] === 1 && sSize[i] === 1) {
	          i++;
	        }

	        while (iSize[i] === 1) {
	          outer++;
	          i++;
	        } // unsqueeze both outer and inner dimensions


	        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
	      } // check whether the size of the submatrix matches the index size


	      if (!deepStrictEqual(iSize, sSize)) {
	        throw new DimensionError(iSize, sSize, '>');
	      } // insert the sub matrix


	      if (iSize.length === 1) {
	        // if the replacement index only has 1 dimension, go trough each one and set its value
	        var range = index.dimension(0);
	        range.forEach(function (dataIndex, subIndex) {
	          validateIndex(dataIndex);
	          matrix.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
	        });
	      } else {
	        // if the replacement index has 2 dimensions, go through each one and set the value in the correct index
	        var firstDimensionRange = index.dimension(0);
	        var secondDimensionRange = index.dimension(1);
	        firstDimensionRange.forEach(function (firstDataIndex, firstSubIndex) {
	          validateIndex(firstDataIndex);
	          secondDimensionRange.forEach(function (secondDataIndex, secondSubIndex) {
	            validateIndex(secondDataIndex);
	            matrix.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
	          });
	        });
	      }
	    }

	    return matrix;
	  }
	  /**
	   * Get a single element from the matrix.
	   * @memberof SparseMatrix
	   * @param {number[]} index   Zero-based index
	   * @return {*} value
	   */


	  SparseMatrix.prototype.get = function (index) {
	    if (!isArray(index)) {
	      throw new TypeError('Array expected');
	    }

	    if (index.length !== this._size.length) {
	      throw new DimensionError(index.length, this._size.length);
	    } // check it is a pattern matrix


	    if (!this._values) {
	      throw new Error('Cannot invoke get on a Pattern only matrix');
	    } // row and column


	    var i = index[0];
	    var j = index[1]; // check i, j are valid

	    validateIndex(i, this._size[0]);
	    validateIndex(j, this._size[1]); // find value index

	    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row


	    if (k < this._ptr[j + 1] && this._index[k] === i) {
	      return this._values[k];
	    }

	    return 0;
	  };
	  /**
	   * Replace a single element in the matrix.
	   * @memberof SparseMatrix
	   * @param {number[]} index   Zero-based index
	   * @param {*} v
	   * @param {*} [defaultValue]        Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be set to zero.
	   * @return {SparseMatrix} self
	   */


	  SparseMatrix.prototype.set = function (index, v, defaultValue) {
	    if (!isArray(index)) {
	      throw new TypeError('Array expected');
	    }

	    if (index.length !== this._size.length) {
	      throw new DimensionError(index.length, this._size.length);
	    } // check it is a pattern matrix


	    if (!this._values) {
	      throw new Error('Cannot invoke set on a Pattern only matrix');
	    } // row and column


	    var i = index[0];
	    var j = index[1]; // rows & columns

	    var rows = this._size[0];
	    var columns = this._size[1]; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0;

	    if (isString$1(this._datatype)) {
	      // find signature that matches (datatype, datatype)
	      eq = typed.find(equalScalar, [this._datatype, this._datatype]) || equalScalar; // convert 0 to the same datatype

	      zero = typed.convert(0, this._datatype);
	    } // check we need to resize matrix


	    if (i > rows - 1 || j > columns - 1) {
	      // resize matrix
	      _resize(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue); // update rows & columns


	      rows = this._size[0];
	      columns = this._size[1];
	    } // check i, j are valid


	    validateIndex(i, rows);
	    validateIndex(j, columns); // find value index

	    var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index); // check k is prior to next column k and it is in the correct row


	    if (k < this._ptr[j + 1] && this._index[k] === i) {
	      // check value != 0
	      if (!eq(v, zero)) {
	        // update value
	        this._values[k] = v;
	      } else {
	        // remove value from matrix
	        _remove(k, j, this._values, this._index, this._ptr);
	      }
	    } else {
	      // insert value @ (i, j)
	      _insert(k, i, j, v, this._values, this._index, this._ptr);
	    }

	    return this;
	  };

	  function _getValueIndex(i, top, bottom, index) {
	    // check row is on the bottom side
	    if (bottom - top === 0) {
	      return bottom;
	    } // loop rows [top, bottom[


	    for (var r = top; r < bottom; r++) {
	      // check we found value index
	      if (index[r] === i) {
	        return r;
	      }
	    } // we did not find row


	    return top;
	  }

	  function _remove(k, j, values, index, ptr) {
	    // remove value @ k
	    values.splice(k, 1);
	    index.splice(k, 1); // update pointers

	    for (var x = j + 1; x < ptr.length; x++) {
	      ptr[x]--;
	    }
	  }

	  function _insert(k, i, j, v, values, index, ptr) {
	    // insert value
	    values.splice(k, 0, v); // update row for k

	    index.splice(k, 0, i); // update column pointers

	    for (var x = j + 1; x < ptr.length; x++) {
	      ptr[x]++;
	    }
	  }
	  /**
	   * Resize the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (resize in place).
	   *
	   * @memberof SparseMatrix
	   * @param {number[] | Matrix} size  The new size the matrix should have.
	   *                                  Since sparse matrices are always two-dimensional,
	   *                                  size must be two numbers in either an array or a matrix
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
	   *                                  If not provided, the matrix elements will
	   *                                  be filled with zeros.
	   * @param {boolean} [copy]          Return a resized copy of the matrix
	   *
	   * @return {Matrix}                 The resized matrix
	   */


	  SparseMatrix.prototype.resize = function (size, defaultValue, copy) {
	    // validate arguments
	    if (!isCollection(size)) {
	      throw new TypeError('Array or Matrix expected');
	    } // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector


	    var sizeArray = size.valueOf().map(value => {
	      return Array.isArray(value) && value.length === 1 ? value[0] : value;
	    });

	    if (sizeArray.length !== 2) {
	      throw new Error('Only two dimensions matrix are supported');
	    } // check sizes


	    sizeArray.forEach(function (value) {
	      if (!isNumber(value) || !isInteger(value) || value < 0) {
	        throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(sizeArray) + ')');
	      }
	    }); // matrix to resize

	    var m = copy ? this.clone() : this; // resize matrix

	    return _resize(m, sizeArray[0], sizeArray[1], defaultValue);
	  };

	  function _resize(matrix, rows, columns, defaultValue) {
	    // value to insert at the time of growing matrix
	    var value = defaultValue || 0; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0;

	    if (isString$1(matrix._datatype)) {
	      // find signature that matches (datatype, datatype)
	      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

	      zero = typed.convert(0, matrix._datatype); // convert value to the same datatype

	      value = typed.convert(value, matrix._datatype);
	    } // should we insert the value?


	    var ins = !eq(value, zero); // old columns and rows

	    var r = matrix._size[0];
	    var c = matrix._size[1];
	    var i, j, k; // check we need to increase columns

	    if (columns > c) {
	      // loop new columns
	      for (j = c; j < columns; j++) {
	        // update matrix._ptr for current column
	        matrix._ptr[j] = matrix._values.length; // check we need to insert matrix._values

	        if (ins) {
	          // loop rows
	          for (i = 0; i < r; i++) {
	            // add new matrix._values
	            matrix._values.push(value); // update matrix._index


	            matrix._index.push(i);
	          }
	        }
	      } // store number of matrix._values in matrix._ptr


	      matrix._ptr[columns] = matrix._values.length;
	    } else if (columns < c) {
	      // truncate matrix._ptr
	      matrix._ptr.splice(columns + 1, c - columns); // truncate matrix._values and matrix._index


	      matrix._values.splice(matrix._ptr[columns], matrix._values.length);

	      matrix._index.splice(matrix._ptr[columns], matrix._index.length);
	    } // update columns


	    c = columns; // check we need to increase rows

	    if (rows > r) {
	      // check we have to insert values
	      if (ins) {
	        // inserts
	        var n = 0; // loop columns

	        for (j = 0; j < c; j++) {
	          // update matrix._ptr for current column
	          matrix._ptr[j] = matrix._ptr[j] + n; // where to insert matrix._values

	          k = matrix._ptr[j + 1] + n; // pointer

	          var p = 0; // loop new rows, initialize pointer

	          for (i = r; i < rows; i++, p++) {
	            // add value
	            matrix._values.splice(k + p, 0, value); // update matrix._index


	            matrix._index.splice(k + p, 0, i); // increment inserts


	            n++;
	          }
	        } // store number of matrix._values in matrix._ptr


	        matrix._ptr[c] = matrix._values.length;
	      }
	    } else if (rows < r) {
	      // deletes
	      var d = 0; // loop columns

	      for (j = 0; j < c; j++) {
	        // update matrix._ptr for current column
	        matrix._ptr[j] = matrix._ptr[j] - d; // where matrix._values start for next column

	        var k0 = matrix._ptr[j];
	        var k1 = matrix._ptr[j + 1] - d; // loop matrix._index

	        for (k = k0; k < k1; k++) {
	          // row
	          i = matrix._index[k]; // check we need to delete value and matrix._index

	          if (i > rows - 1) {
	            // remove value
	            matrix._values.splice(k, 1); // remove item from matrix._index


	            matrix._index.splice(k, 1); // increase deletes


	            d++;
	          }
	        }
	      } // update matrix._ptr for current column


	      matrix._ptr[j] = matrix._values.length;
	    } // update matrix._size


	    matrix._size[0] = rows;
	    matrix._size[1] = columns; // return matrix

	    return matrix;
	  }
	  /**
	   * Reshape the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (reshape in place).
	   *
	   * NOTE: This might be better suited to copy by default, instead of modifying
	   *       in place. For now, it operates in place to remain consistent with
	   *       resize().
	   *
	   * @memberof SparseMatrix
	   * @param {number[]} sizes          The new size the matrix should have.
	   *                                  Since sparse matrices are always two-dimensional,
	   *                                  size must be two numbers in either an array or a matrix
	   * @param {boolean} [copy]          Return a reshaped copy of the matrix
	   *
	   * @return {Matrix}                 The reshaped matrix
	   */


	  SparseMatrix.prototype.reshape = function (sizes, copy) {
	    // validate arguments
	    if (!isArray(sizes)) {
	      throw new TypeError('Array expected');
	    }

	    if (sizes.length !== 2) {
	      throw new Error('Sparse matrices can only be reshaped in two dimensions');
	    } // check sizes


	    sizes.forEach(function (value) {
	      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
	        throw new TypeError('Invalid size, must contain positive integers or -1 ' + '(size: ' + format(sizes) + ')');
	      }
	    });
	    var currentLength = this._size[0] * this._size[1];
	    sizes = processSizesWildcard(sizes, currentLength);
	    var newLength = sizes[0] * sizes[1]; // m * n must not change

	    if (currentLength !== newLength) {
	      throw new Error('Reshaping sparse matrix will result in the wrong number of elements');
	    } // matrix to reshape


	    var m = copy ? this.clone() : this; // return unchanged if the same shape

	    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
	      return m;
	    } // Convert to COO format (generate a column index)


	    var colIndex = [];

	    for (var i = 0; i < m._ptr.length; i++) {
	      for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
	        colIndex.push(i);
	      }
	    } // Clone the values array


	    var values = m._values.slice(); // Clone the row index array


	    var rowIndex = m._index.slice(); // Transform the (row, column) indices


	    for (var _i = 0; _i < m._index.length; _i++) {
	      var r1 = rowIndex[_i];
	      var c1 = colIndex[_i];
	      var flat = r1 * m._size[1] + c1;
	      colIndex[_i] = flat % sizes[1];
	      rowIndex[_i] = Math.floor(flat / sizes[1]);
	    } // Now reshaping is supposed to preserve the row-major order, BUT these sparse matrices are stored
	    // in column-major order, so we have to reorder the value array now. One option is to use a multisort,
	    // sorting several arrays based on some other array.
	    // OR, we could easily just:
	    // 1. Remove all values from the matrix


	    m._values.length = 0;
	    m._index.length = 0;
	    m._ptr.length = sizes[1] + 1;
	    m._size = sizes.slice();

	    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
	      m._ptr[_i2] = 0;
	    } // 2. Re-insert all elements in the proper order (simplified code from SparseMatrix.prototype.set)
	    // This step is probably the most time-consuming


	    for (var h = 0; h < values.length; h++) {
	      var _i3 = rowIndex[h];
	      var _j = colIndex[h];
	      var v = values[h];

	      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);

	      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
	    } // The value indices are inserted out of order, but apparently that's... still OK?


	    return m;
	  };
	  /**
	   * Create a clone of the matrix
	   * @memberof SparseMatrix
	   * @return {SparseMatrix} clone
	   */


	  SparseMatrix.prototype.clone = function () {
	    var m = new SparseMatrix({
	      values: this._values ? clone(this._values) : undefined,
	      index: clone(this._index),
	      ptr: clone(this._ptr),
	      size: clone(this._size),
	      datatype: this._datatype
	    });
	    return m;
	  };
	  /**
	   * Retrieve the size of the matrix.
	   * @memberof SparseMatrix
	   * @returns {number[]} size
	   */


	  SparseMatrix.prototype.size = function () {
	    return this._size.slice(0); // copy the Array
	  };
	  /**
	   * Create a new matrix with the results of the callback function executed on
	   * each entry of the matrix.
	   * @memberof SparseMatrix
	   * @param {Function} callback   The callback function is invoked with three
	   *                              parameters: the value of the element, the index
	   *                              of the element, and the Matrix being traversed.
	   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
	   *
	   * @return {SparseMatrix} matrix
	   */


	  SparseMatrix.prototype.map = function (callback, skipZeros) {
	    // check it is a pattern matrix
	    if (!this._values) {
	      throw new Error('Cannot invoke map on a Pattern only matrix');
	    } // matrix instance


	    var me = this; // rows and columns

	    var rows = this._size[0];
	    var columns = this._size[1]; // invoke callback

	    var invoke = function invoke(v, i, j) {
	      // invoke callback
	      return callback(v, [i, j], me);
	    }; // invoke _map


	    return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
	  };
	  /**
	   * Create a new matrix with the results of the callback function executed on the interval
	   * [minRow..maxRow, minColumn..maxColumn].
	   */


	  function _map(matrix, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
	    // result arrays
	    var values = [];
	    var index = [];
	    var ptr = []; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0;

	    if (isString$1(matrix._datatype)) {
	      // find signature that matches (datatype, datatype)
	      eq = typed.find(equalScalar, [matrix._datatype, matrix._datatype]) || equalScalar; // convert 0 to the same datatype

	      zero = typed.convert(0, matrix._datatype);
	    } // invoke callback


	    var invoke = function invoke(v, x, y) {
	      // invoke callback
	      v = callback(v, x, y); // check value != 0

	      if (!eq(v, zero)) {
	        // store value
	        values.push(v); // index

	        index.push(x);
	      }
	    }; // loop columns


	    for (var j = minColumn; j <= maxColumn; j++) {
	      // store pointer to values index
	      ptr.push(values.length); // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]

	      var k0 = matrix._ptr[j];
	      var k1 = matrix._ptr[j + 1];

	      if (skipZeros) {
	        // loop k within [k0, k1[
	        for (var k = k0; k < k1; k++) {
	          // row index
	          var i = matrix._index[k]; // check i is in range

	          if (i >= minRow && i <= maxRow) {
	            // value @ k
	            invoke(matrix._values[k], i - minRow, j - minColumn);
	          }
	        }
	      } else {
	        // create a cache holding all defined values
	        var _values = {};

	        for (var _k = k0; _k < k1; _k++) {
	          var _i4 = matrix._index[_k];
	          _values[_i4] = matrix._values[_k];
	        } // loop over all rows (indexes can be unordered so we can't use that),
	        // and either read the value or zero


	        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
	          var value = _i5 in _values ? _values[_i5] : 0;
	          invoke(value, _i5 - minRow, j - minColumn);
	        }
	      }
	    } // store number of values in ptr


	    ptr.push(values.length); // return sparse matrix

	    return new SparseMatrix({
	      values: values,
	      index: index,
	      ptr: ptr,
	      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
	    });
	  }
	  /**
	   * Execute a callback function on each entry of the matrix.
	   * @memberof SparseMatrix
	   * @param {Function} callback   The callback function is invoked with three
	   *                              parameters: the value of the element, the index
	   *                              of the element, and the Matrix being traversed.
	   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.
	   *                              If false, the indices are guaranteed to be in order,
	   *                              if true, the indices can be unordered.
	   */


	  SparseMatrix.prototype.forEach = function (callback, skipZeros) {
	    // check it is a pattern matrix
	    if (!this._values) {
	      throw new Error('Cannot invoke forEach on a Pattern only matrix');
	    } // matrix instance


	    var me = this; // rows and columns

	    var rows = this._size[0];
	    var columns = this._size[1]; // loop columns

	    for (var j = 0; j < columns; j++) {
	      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
	      var k0 = this._ptr[j];
	      var k1 = this._ptr[j + 1];

	      if (skipZeros) {
	        // loop k within [k0, k1[
	        for (var k = k0; k < k1; k++) {
	          // row index
	          var i = this._index[k]; // value @ k

	          callback(this._values[k], [i, j], me);
	        }
	      } else {
	        // create a cache holding all defined values
	        var values = {};

	        for (var _k2 = k0; _k2 < k1; _k2++) {
	          var _i6 = this._index[_k2];
	          values[_i6] = this._values[_k2];
	        } // loop over all rows (indexes can be unordered so we can't use that),
	        // and either read the value or zero


	        for (var _i7 = 0; _i7 < rows; _i7++) {
	          var value = _i7 in values ? values[_i7] : 0;
	          callback(value, [_i7, j], me);
	        }
	      }
	    }
	  };
	  /**
	   * Iterate over the matrix elements, skipping zeros
	   * @return {Iterable<{ value, index: number[] }>}
	   */


	  SparseMatrix.prototype[Symbol.iterator] = function* () {
	    if (!this._values) {
	      throw new Error('Cannot iterate a Pattern only matrix');
	    }

	    var columns = this._size[1];

	    for (var j = 0; j < columns; j++) {
	      var k0 = this._ptr[j];
	      var k1 = this._ptr[j + 1];

	      for (var k = k0; k < k1; k++) {
	        // row index
	        var i = this._index[k];
	        yield {
	          value: this._values[k],
	          index: [i, j]
	        };
	      }
	    }
	  };
	  /**
	   * Create an Array with a copy of the data of the SparseMatrix
	   * @memberof SparseMatrix
	   * @returns {Array} array
	   */


	  SparseMatrix.prototype.toArray = function () {
	    return _toArray(this._values, this._index, this._ptr, this._size, true);
	  };
	  /**
	   * Get the primitive value of the SparseMatrix: a two dimensions array
	   * @memberof SparseMatrix
	   * @returns {Array} array
	   */


	  SparseMatrix.prototype.valueOf = function () {
	    return _toArray(this._values, this._index, this._ptr, this._size, false);
	  };

	  function _toArray(values, index, ptr, size, copy) {
	    // rows and columns
	    var rows = size[0];
	    var columns = size[1]; // result

	    var a = []; // vars

	    var i, j; // initialize array

	    for (i = 0; i < rows; i++) {
	      a[i] = [];

	      for (j = 0; j < columns; j++) {
	        a[i][j] = 0;
	      }
	    } // loop columns


	    for (j = 0; j < columns; j++) {
	      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
	      var k0 = ptr[j];
	      var k1 = ptr[j + 1]; // loop k within [k0, k1[

	      for (var k = k0; k < k1; k++) {
	        // row index
	        i = index[k]; // set value (use one for pattern matrix)

	        a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;
	      }
	    }

	    return a;
	  }
	  /**
	   * Get a string representation of the matrix, with optional formatting options.
	   * @memberof SparseMatrix
	   * @param {Object | number | Function} [options]  Formatting options. See
	   *                                                lib/utils/number:format for a
	   *                                                description of the available
	   *                                                options.
	   * @returns {string} str
	   */


	  SparseMatrix.prototype.format = function (options) {
	    // rows and columns
	    var rows = this._size[0];
	    var columns = this._size[1]; // density

	    var density = this.density(); // rows & columns

	    var str = 'Sparse Matrix [' + format(rows, options) + ' x ' + format(columns, options) + '] density: ' + format(density, options) + '\n'; // loop columns

	    for (var j = 0; j < columns; j++) {
	      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
	      var k0 = this._ptr[j];
	      var k1 = this._ptr[j + 1]; // loop k within [k0, k1[

	      for (var k = k0; k < k1; k++) {
	        // row index
	        var i = this._index[k]; // append value

	        str += '\n    (' + format(i, options) + ', ' + format(j, options) + ') ==> ' + (this._values ? format(this._values[k], options) : 'X');
	      }
	    }

	    return str;
	  };
	  /**
	   * Get a string representation of the matrix
	   * @memberof SparseMatrix
	   * @returns {string} str
	   */


	  SparseMatrix.prototype.toString = function () {
	    return format(this.toArray());
	  };
	  /**
	   * Get a JSON representation of the matrix
	   * @memberof SparseMatrix
	   * @returns {Object}
	   */


	  SparseMatrix.prototype.toJSON = function () {
	    return {
	      mathjs: 'SparseMatrix',
	      values: this._values,
	      index: this._index,
	      ptr: this._ptr,
	      size: this._size,
	      datatype: this._datatype
	    };
	  };
	  /**
	   * Get the kth Matrix diagonal.
	   *
	   * @memberof SparseMatrix
	   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.
	   *
	   * @returns {Matrix}                     The matrix vector with the diagonal values.
	   */


	  SparseMatrix.prototype.diagonal = function (k) {
	    // validate k if any
	    if (k) {
	      // convert BigNumber to a number
	      if (isBigNumber(k)) {
	        k = k.toNumber();
	      } // is must be an integer


	      if (!isNumber(k) || !isInteger(k)) {
	        throw new TypeError('The parameter k must be an integer number');
	      }
	    } else {
	      // default value
	      k = 0;
	    }

	    var kSuper = k > 0 ? k : 0;
	    var kSub = k < 0 ? -k : 0; // rows & columns

	    var rows = this._size[0];
	    var columns = this._size[1]; // number diagonal values

	    var n = Math.min(rows - kSub, columns - kSuper); // diagonal arrays

	    var values = [];
	    var index = [];
	    var ptr = []; // initial ptr value

	    ptr[0] = 0; // loop columns

	    for (var j = kSuper; j < columns && values.length < n; j++) {
	      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
	      var k0 = this._ptr[j];
	      var k1 = this._ptr[j + 1]; // loop x within [k0, k1[

	      for (var x = k0; x < k1; x++) {
	        // row index
	        var i = this._index[x]; // check row

	        if (i === j - kSuper + kSub) {
	          // value on this column
	          values.push(this._values[x]); // store row

	          index[values.length - 1] = i - kSub; // exit loop

	          break;
	        }
	      }
	    } // close ptr


	    ptr.push(values.length); // return matrix

	    return new SparseMatrix({
	      values: values,
	      index: index,
	      ptr: ptr,
	      size: [n, 1]
	    });
	  };
	  /**
	   * Generate a matrix from a JSON object
	   * @memberof SparseMatrix
	   * @param {Object} json  An object structured like
	   *                       `{"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []}`,
	   *                       where mathjs is optional
	   * @returns {SparseMatrix}
	   */


	  SparseMatrix.fromJSON = function (json) {
	    return new SparseMatrix(json);
	  };
	  /**
	   * Create a diagonal matrix.
	   *
	   * @memberof SparseMatrix
	   * @param {Array} size                       The matrix size.
	   * @param {number | Array | Matrix } value   The values for the diagonal.
	   * @param {number | BigNumber} [k=0]         The kth diagonal where the vector will be filled in.
	   * @param {number} [defaultValue]            The default value for non-diagonal
	   * @param {string} [datatype]                The Matrix datatype, values must be of this datatype.
	   *
	   * @returns {SparseMatrix}
	   */


	  SparseMatrix.diagonal = function (size, value, k, defaultValue, datatype) {
	    if (!isArray(size)) {
	      throw new TypeError('Array expected, size parameter');
	    }

	    if (size.length !== 2) {
	      throw new Error('Only two dimensions matrix are supported');
	    } // map size & validate


	    size = size.map(function (s) {
	      // check it is a big number
	      if (isBigNumber(s)) {
	        // convert it
	        s = s.toNumber();
	      } // validate arguments


	      if (!isNumber(s) || !isInteger(s) || s < 1) {
	        throw new Error('Size values must be positive integers');
	      }

	      return s;
	    }); // validate k if any

	    if (k) {
	      // convert BigNumber to a number
	      if (isBigNumber(k)) {
	        k = k.toNumber();
	      } // is must be an integer


	      if (!isNumber(k) || !isInteger(k)) {
	        throw new TypeError('The parameter k must be an integer number');
	      }
	    } else {
	      // default value
	      k = 0;
	    } // equal signature to use


	    var eq = equalScalar; // zero value

	    var zero = 0;

	    if (isString$1(datatype)) {
	      // find signature that matches (datatype, datatype)
	      eq = typed.find(equalScalar, [datatype, datatype]) || equalScalar; // convert 0 to the same datatype

	      zero = typed.convert(0, datatype);
	    }

	    var kSuper = k > 0 ? k : 0;
	    var kSub = k < 0 ? -k : 0; // rows and columns

	    var rows = size[0];
	    var columns = size[1]; // number of non-zero items

	    var n = Math.min(rows - kSub, columns - kSuper); // value extraction function

	    var _value; // check value


	    if (isArray(value)) {
	      // validate array
	      if (value.length !== n) {
	        // number of values in array must be n
	        throw new Error('Invalid value array length');
	      } // define function


	      _value = function _value(i) {
	        // return value @ i
	        return value[i];
	      };
	    } else if (isMatrix(value)) {
	      // matrix size
	      var ms = value.size(); // validate matrix

	      if (ms.length !== 1 || ms[0] !== n) {
	        // number of values in array must be n
	        throw new Error('Invalid matrix length');
	      } // define function


	      _value = function _value(i) {
	        // return value @ i
	        return value.get([i]);
	      };
	    } else {
	      // define function
	      _value = function _value() {
	        // return value
	        return value;
	      };
	    } // create arrays


	    var values = [];
	    var index = [];
	    var ptr = []; // loop items

	    for (var j = 0; j < columns; j++) {
	      // number of rows with value
	      ptr.push(values.length); // diagonal index

	      var i = j - kSuper; // check we need to set diagonal value

	      if (i >= 0 && i < n) {
	        // get value @ i
	        var v = _value(i); // check for zero


	        if (!eq(v, zero)) {
	          // column
	          index.push(i + kSub); // add value

	          values.push(v);
	        }
	      }
	    } // last value should be number of values


	    ptr.push(values.length); // create SparseMatrix

	    return new SparseMatrix({
	      values: values,
	      index: index,
	      ptr: ptr,
	      size: [rows, columns]
	    });
	  };
	  /**
	   * Swap rows i and j in Matrix.
	   *
	   * @memberof SparseMatrix
	   * @param {number} i       Matrix row index 1
	   * @param {number} j       Matrix row index 2
	   *
	   * @return {Matrix}        The matrix reference
	   */


	  SparseMatrix.prototype.swapRows = function (i, j) {
	    // check index
	    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
	      throw new Error('Row index must be positive integers');
	    } // check dimensions


	    if (this._size.length !== 2) {
	      throw new Error('Only two dimensional matrix is supported');
	    } // validate index


	    validateIndex(i, this._size[0]);
	    validateIndex(j, this._size[0]); // swap rows

	    SparseMatrix._swapRows(i, j, this._size[1], this._values, this._index, this._ptr); // return current instance


	    return this;
	  };
	  /**
	   * Loop rows with data in column j.
	   *
	   * @param {number} j            Column
	   * @param {Array} values        Matrix values
	   * @param {Array} index         Matrix row indeces
	   * @param {Array} ptr           Matrix column pointers
	   * @param {Function} callback   Callback function invoked for every row in column j
	   */


	  SparseMatrix._forEachRow = function (j, values, index, ptr, callback) {
	    // indeces for column j
	    var k0 = ptr[j];
	    var k1 = ptr[j + 1]; // loop

	    for (var k = k0; k < k1; k++) {
	      // invoke callback
	      callback(index[k], values[k]);
	    }
	  };
	  /**
	   * Swap rows x and y in Sparse Matrix data structures.
	   *
	   * @param {number} x         Matrix row index 1
	   * @param {number} y         Matrix row index 2
	   * @param {number} columns   Number of columns in matrix
	   * @param {Array} values     Matrix values
	   * @param {Array} index      Matrix row indeces
	   * @param {Array} ptr        Matrix column pointers
	   */


	  SparseMatrix._swapRows = function (x, y, columns, values, index, ptr) {
	    // loop columns
	    for (var j = 0; j < columns; j++) {
	      // k0 <= k < k1 where k0 = _ptr[j] && k1 = _ptr[j+1]
	      var k0 = ptr[j];
	      var k1 = ptr[j + 1]; // find value index @ x

	      var kx = _getValueIndex(x, k0, k1, index); // find value index @ x


	      var ky = _getValueIndex(y, k0, k1, index); // check both rows exist in matrix


	      if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
	        // swap values (check for pattern matrix)
	        if (values) {
	          var v = values[kx];
	          values[kx] = values[ky];
	          values[ky] = v;
	        } // next column


	        continue;
	      } // check x row exist & no y row


	      if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
	        // value @ x (check for pattern matrix)
	        var vx = values ? values[kx] : undefined; // insert value @ y

	        index.splice(ky, 0, y);

	        if (values) {
	          values.splice(ky, 0, vx);
	        } // remove value @ x (adjust array index if needed)


	        index.splice(ky <= kx ? kx + 1 : kx, 1);

	        if (values) {
	          values.splice(ky <= kx ? kx + 1 : kx, 1);
	        } // next column


	        continue;
	      } // check y row exist & no x row


	      if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
	        // value @ y (check for pattern matrix)
	        var vy = values ? values[ky] : undefined; // insert value @ x

	        index.splice(kx, 0, x);

	        if (values) {
	          values.splice(kx, 0, vy);
	        } // remove value @ y (adjust array index if needed)


	        index.splice(kx <= ky ? ky + 1 : ky, 1);

	        if (values) {
	          values.splice(kx <= ky ? ky + 1 : ky, 1);
	        }
	      }
	    }
	  };

	  return SparseMatrix;
	}, {
	  isClass: true
	});

	var name$X = 'number';
	var dependencies$X = ['typed'];
	/**
	 * Separates the radix, integer part, and fractional part of a non decimal number string
	 * @param {string} input string to parse
	 * @returns {object} the parts of the string or null if not a valid input
	 */

	function getNonDecimalNumberParts(input) {
	  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);

	  if (nonDecimalWithRadixMatch) {
	    var radix = {
	      '0b': 2,
	      '0o': 8,
	      '0x': 16
	    }[nonDecimalWithRadixMatch[1]];
	    var integerPart = nonDecimalWithRadixMatch[2];
	    var fractionalPart = nonDecimalWithRadixMatch[3];
	    return {
	      input,
	      radix,
	      integerPart,
	      fractionalPart
	    };
	  } else {
	    return null;
	  }
	}
	/**
	 * Makes a number from a radix, and integer part, and a fractional part
	 * @param {parts} [x] parts of the number string (from getNonDecimalNumberParts)
	 * @returns {number} the number
	 */


	function makeNumberFromNonDecimalParts(parts) {
	  var n = parseInt(parts.integerPart, parts.radix);
	  var f = 0;

	  for (var i = 0; i < parts.fractionalPart.length; i++) {
	    var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
	    f += digitValue / Math.pow(parts.radix, i + 1);
	  }

	  var result = n + f;

	  if (isNaN(result)) {
	    throw new SyntaxError('String "' + parts.input + '" is no valid number');
	  }

	  return result;
	}

	var createNumber = /* #__PURE__ */factory(name$X, dependencies$X, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Create a number or convert a string, boolean, or unit to a number.
	   * When value is a matrix, all elements will be converted to number.
	   *
	   * Syntax:
	   *
	   *    math.number(value)
	   *    math.number(unit, valuelessUnit)
	   *
	   * Examples:
	   *
	   *    math.number(2)                         // returns number 2
	   *    math.number('7.2')                     // returns number 7.2
	   *    math.number(true)                      // returns number 1
	   *    math.number([true, false, true, true]) // returns [1, 0, 1, 1]
	   *    math.number(math.unit('52cm'), 'm')    // returns 0.52
	   *
	   * See also:
	   *
	   *    bignumber, boolean, complex, index, matrix, string, unit
	   *
	   * @param {string | number | BigNumber | Fraction | boolean | Array | Matrix | Unit | null} [value]  Value to be converted
	   * @param {Unit | string} [valuelessUnit] A valueless unit, used to convert a unit to a number
	   * @return {number | Array | Matrix} The created number
	   */

	  var number = typed('number', {
	    '': function _() {
	      return 0;
	    },
	    number: function number(x) {
	      return x;
	    },
	    string: function string(x) {
	      if (x === 'NaN') return NaN;
	      var nonDecimalNumberParts = getNonDecimalNumberParts(x);

	      if (nonDecimalNumberParts) {
	        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
	      }

	      var size = 0;
	      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);

	      if (wordSizeSuffixMatch) {
	        // x includes a size suffix like 0xffffi32, so we extract
	        // the suffix and remove it from x
	        size = Number(wordSizeSuffixMatch[2]);
	        x = wordSizeSuffixMatch[1];
	      }

	      var num = Number(x);

	      if (isNaN(num)) {
	        throw new SyntaxError('String "' + x + '" is no valid number');
	      }

	      if (wordSizeSuffixMatch) {
	        // x is a signed bin, oct, or hex literal
	        // num is the value of string x if x is interpreted as unsigned
	        if (num > 2 ** size - 1) {
	          // literal is too large for size suffix
	          throw new SyntaxError("String \"".concat(x, "\" is out of range"));
	        } // check if the bit at index size - 1 is set and if so do the twos complement


	        if (num >= 2 ** (size - 1)) {
	          num = num - 2 ** size;
	        }
	      }

	      return num;
	    },
	    BigNumber: function BigNumber(x) {
	      return x.toNumber();
	    },
	    Fraction: function Fraction(x) {
	      return x.valueOf();
	    },
	    Unit: function Unit(x) {
	      throw new Error('Second argument with valueless unit expected');
	    },
	    null: function _null(x) {
	      return 0;
	    },
	    'Unit, string | Unit': function UnitStringUnit(unit, valuelessUnit) {
	      return unit.toNumber(valuelessUnit);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  }); // reviver function to parse a JSON object like:
	  //
	  //     {"mathjs":"number","value":"2.3"}
	  //
	  // into a number 2.3

	  number.fromJSON = function (json) {
	    return parseFloat(json.value);
	  };

	  return number;
	});

	var name$W = 'bignumber';
	var dependencies$W = ['typed', 'BigNumber'];
	var createBignumber = /* #__PURE__ */factory(name$W, dependencies$W, _ref => {
	  var {
	    typed,
	    BigNumber
	  } = _ref;
	  /**
	   * Create a BigNumber, which can store numbers with arbitrary precision.
	   * When a matrix is provided, all elements will be converted to BigNumber.
	   *
	   * Syntax:
	   *
	   *    math.bignumber(x)
	   *
	   * Examples:
	   *
	   *    0.1 + 0.2                                  // returns number 0.30000000000000004
	   *    math.bignumber(0.1) + math.bignumber(0.2)  // returns BigNumber 0.3
	   *
	   *
	   *    7.2e500                                    // returns number Infinity
	   *    math.bignumber('7.2e500')                  // returns BigNumber 7.2e500
	   *
	   * See also:
	   *
	   *    boolean, complex, index, matrix, string, unit
	   *
	   * @param {number | string | Fraction | BigNumber | Array | Matrix | boolean | null} [value]  Value for the big number,
	   *                                                    0 by default.
	   * @returns {BigNumber} The created bignumber
	   */

	  return typed('bignumber', {
	    '': function _() {
	      return new BigNumber(0);
	    },
	    number: function number(x) {
	      // convert to string to prevent errors in case of >15 digits
	      return new BigNumber(x + '');
	    },
	    string: function string(x) {
	      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);

	      if (wordSizeSuffixMatch) {
	        // x has a word size suffix
	        var size = wordSizeSuffixMatch[2];
	        var n = BigNumber(wordSizeSuffixMatch[1]);
	        var twoPowSize = new BigNumber(2).pow(Number(size));

	        if (n.gt(twoPowSize.sub(1))) {
	          throw new SyntaxError("String \"".concat(x, "\" is out of range"));
	        }

	        var twoPowSizeSubOne = new BigNumber(2).pow(Number(size) - 1);

	        if (n.gte(twoPowSizeSubOne)) {
	          return n.sub(twoPowSize);
	        } else {
	          return n;
	        }
	      }

	      return new BigNumber(x);
	    },
	    BigNumber: function BigNumber(x) {
	      // we assume a BigNumber is immutable
	      return x;
	    },
	    Fraction: function Fraction(x) {
	      return new BigNumber(x.n).div(x.d).times(x.s);
	    },
	    null: function _null(x) {
	      return new BigNumber(0);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$V = 'complex';
	var dependencies$V = ['typed', 'Complex'];
	var createComplex = /* #__PURE__ */factory(name$V, dependencies$V, _ref => {
	  var {
	    typed,
	    Complex
	  } = _ref;
	  /**
	   * Create a complex value or convert a value to a complex value.
	   *
	   * Syntax:
	   *
	   *     math.complex()                           // creates a complex value with zero
	   *                                              // as real and imaginary part.
	   *     math.complex(re : number, im : string)   // creates a complex value with provided
	   *                                              // values for real and imaginary part.
	   *     math.complex(re : number)                // creates a complex value with provided
	   *                                              // real value and zero imaginary part.
	   *     math.complex(complex : Complex)          // clones the provided complex value.
	   *     math.complex(arg : string)               // parses a string into a complex value.
	   *     math.complex(array : Array)              // converts the elements of the array
	   *                                              // or matrix element wise into a
	   *                                              // complex value.
	   *     math.complex({re: number, im: number})   // creates a complex value with provided
	   *                                              // values for real an imaginary part.
	   *     math.complex({r: number, phi: number})   // creates a complex value with provided
	   *                                              // polar coordinates
	   *
	   * Examples:
	   *
	   *    const a = math.complex(3, -4)     // a = Complex 3 - 4i
	   *    a.re = 5                          // a = Complex 5 - 4i
	   *    const i = a.im                    // Number -4
	   *    const b = math.complex('2 + 6i')  // Complex 2 + 6i
	   *    const c = math.complex()          // Complex 0 + 0i
	   *    const d = math.add(a, b)          // Complex 5 + 2i
	   *
	   * See also:
	   *
	   *    bignumber, boolean, index, matrix, number, string, unit
	   *
	   * @param {* | Array | Matrix} [args]
	   *            Arguments specifying the real and imaginary part of the complex number
	   * @return {Complex | Array | Matrix} Returns a complex value
	   */

	  return typed('complex', {
	    '': function _() {
	      return Complex.ZERO;
	    },
	    number: function number(x) {
	      return new Complex(x, 0);
	    },
	    'number, number': function numberNumber(re, im) {
	      return new Complex(re, im);
	    },
	    // TODO: this signature should be redundant
	    'BigNumber, BigNumber': function BigNumberBigNumber(re, im) {
	      return new Complex(re.toNumber(), im.toNumber());
	    },
	    Fraction: function Fraction(x) {
	      return new Complex(x.valueOf(), 0);
	    },
	    Complex: function Complex(x) {
	      return x.clone();
	    },
	    string: function string(x) {
	      return Complex(x); // for example '2 + 3i'
	    },
	    null: function _null(x) {
	      return Complex(0);
	    },
	    Object: function Object(x) {
	      if ('re' in x && 'im' in x) {
	        return new Complex(x.re, x.im);
	      }

	      if ('r' in x && 'phi' in x || 'abs' in x && 'arg' in x) {
	        return new Complex(x);
	      }

	      throw new Error('Expected object with properties (re and im) or (r and phi) or (abs and arg)');
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$U = 'fraction';
	var dependencies$U = ['typed', 'Fraction'];
	var createFraction = /* #__PURE__ */factory(name$U, dependencies$U, _ref => {
	  var {
	    typed,
	    Fraction
	  } = _ref;
	  /**
	   * Create a fraction or convert a value to a fraction.
	   *
	   * With one numeric argument, produces the closest rational approximation to the
	   * input.
	   * With two arguments, the first is the numerator and the second is the denominator,
	   * and creates the corresponding fraction. Both numerator and denominator must be
	   * integers.
	   * With one object argument, looks for the integer numerator as the value of property
	   * 'n' and the integer denominator as the value of property 'd'.
	   * With a matrix argument, creates a matrix of the same shape with entries
	   * converted into fractions.
	   *
	   * Syntax:
	   *     math.fraction(value)
	   *     math.fraction(numerator, denominator)
	   *     math.fraction({n: numerator, d: denominator})
	   *     math.fraction(matrix: Array | Matrix)
	   *
	   * Examples:
	   *
	   *     math.fraction(6.283)             // returns Fraction 6283/1000
	   *     math.fraction(1, 3)              // returns Fraction 1/3
	   *     math.fraction('2/3')             // returns Fraction 2/3
	   *     math.fraction({n: 2, d: 3})      // returns Fraction 2/3
	   *     math.fraction([0.2, 0.25, 1.25]) // returns Array [1/5, 1/4, 5/4]
	   *     math.fraction(4, 5.1)            // throws Error: Parameters must be integer
	   *
	   * See also:
	   *
	   *    bignumber, number, string, unit
	   *
	   * @param {number | string | Fraction | BigNumber | Array | Matrix} [args]
	   *            Arguments specifying the value, or numerator and denominator of
	   *            the fraction
	   * @return {Fraction | Array | Matrix} Returns a fraction
	   */

	  return typed('fraction', {
	    number: function number(x) {
	      if (!isFinite(x) || isNaN(x)) {
	        throw new Error(x + ' cannot be represented as a fraction');
	      }

	      return new Fraction(x);
	    },
	    string: function string(x) {
	      return new Fraction(x);
	    },
	    'number, number': function numberNumber(numerator, denominator) {
	      return new Fraction(numerator, denominator);
	    },
	    null: function _null(x) {
	      return new Fraction(0);
	    },
	    BigNumber: function BigNumber(x) {
	      return new Fraction(x.toString());
	    },
	    Fraction: function Fraction(x) {
	      return x; // fractions are immutable
	    },
	    Object: function Object(x) {
	      return new Fraction(x);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$T = 'matrix';
	var dependencies$T = ['typed', 'Matrix', 'DenseMatrix', 'SparseMatrix'];
	var createMatrix = /* #__PURE__ */factory(name$T, dependencies$T, _ref => {
	  var {
	    typed,
	    Matrix,
	    DenseMatrix,
	    SparseMatrix
	  } = _ref;
	  /**
	   * Create a Matrix. The function creates a new `math.Matrix` object from
	   * an `Array`. A Matrix has utility functions to manipulate the data in the
	   * matrix, like getting the size and getting or setting values in the matrix.
	   * Supported storage formats are 'dense' and 'sparse'.
	   *
	   * Syntax:
	   *
	   *    math.matrix()                         // creates an empty matrix using default storage format (dense).
	   *    math.matrix(data)                     // creates a matrix with initial data using default storage format (dense).
	   *    math.matrix('dense')                  // creates an empty matrix using the given storage format.
	   *    math.matrix(data, 'dense')            // creates a matrix with initial data using the given storage format.
	   *    math.matrix(data, 'sparse')           // creates a sparse matrix with initial data.
	   *    math.matrix(data, 'sparse', 'number') // creates a sparse matrix with initial data, number data type.
	   *
	   * Examples:
	   *
	   *    let m = math.matrix([[1, 2], [3, 4]])
	   *    m.size()                        // Array [2, 2]
	   *    m.resize([3, 2], 5)
	   *    m.valueOf()                     // Array [[1, 2], [3, 4], [5, 5]]
	   *    m.get([1, 0])                    // number 3
	   *
	   * See also:
	   *
	   *    bignumber, boolean, complex, index, number, string, unit, sparse
	   *
	   * @param {Array | Matrix} [data]    A multi dimensional array
	   * @param {string} [format]          The Matrix storage format, either `'dense'` or `'sparse'`
	   * @param {string} [datatype]        Type of the values
	   *
	   * @return {Matrix} The created matrix
	   */

	  return typed(name$T, {
	    '': function _() {
	      return _create([]);
	    },
	    string: function string(format) {
	      return _create([], format);
	    },
	    'string, string': function stringString(format, datatype) {
	      return _create([], format, datatype);
	    },
	    Array: function Array(data) {
	      return _create(data);
	    },
	    Matrix: function Matrix(data) {
	      return _create(data, data.storage());
	    },
	    'Array | Matrix, string': _create,
	    'Array | Matrix, string, string': _create
	  });
	  /**
	   * Create a new Matrix with given storage format
	   * @param {Array} data
	   * @param {string} [format]
	   * @param {string} [datatype]
	   * @returns {Matrix} Returns a new Matrix
	   * @private
	   */

	  function _create(data, format, datatype) {
	    // get storage format constructor
	    if (format === 'dense' || format === 'default' || format === undefined) {
	      return new DenseMatrix(data, datatype);
	    }

	    if (format === 'sparse') {
	      return new SparseMatrix(data, datatype);
	    }

	    throw new TypeError('Unknown matrix type ' + JSON.stringify(format) + '.');
	  }
	});

	var name$S = 'matrixFromColumns';
	var dependencies$S = ['typed', 'matrix', 'flatten', 'size'];
	var createMatrixFromColumns = /* #__PURE__ */factory(name$S, dependencies$S, _ref => {
	  var {
	    typed,
	    matrix,
	    flatten,
	    size
	  } = _ref;
	  /**
	   * Create a dense matrix from vectors as individual columns.
	   * If you pass row vectors, they will be transposed (but not conjugated!)
	   *
	   * Syntax:
	   *
	   *    math.matrixFromColumns(...arr)
	   *    math.matrixFromColumns(col1, col2)
	   *    math.matrixFromColumns(col1, col2, col3)
	   *
	   * Examples:
	   *
	   *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])
	   *    math.matrixFromColumns(...vectors)
	   *
	   * See also:
	   *
	   *    matrix, matrixFromRows, matrixFromFunction, zeros
	   *
	   * @param {... Array | Matrix} cols Multiple columns
	   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned
	   */

	  return typed(name$S, {
	    '...Array': function Array(arr) {
	      return _createArray(arr);
	    },
	    '...Matrix': function Matrix(arr) {
	      return matrix(_createArray(arr.map(m => m.toArray())));
	    } // TODO implement this properly for SparseMatrix

	  });

	  function _createArray(arr) {
	    if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');
	    var N = checkVectorTypeAndReturnLength(arr[0]); // create an array with empty rows

	    var result = [];

	    for (var i = 0; i < N; i++) {
	      result[i] = [];
	    } // loop columns


	    for (var col of arr) {
	      var colLength = checkVectorTypeAndReturnLength(col);

	      if (colLength !== N) {
	        throw new TypeError('The vectors had different length: ' + (N | 0) + '  ' + (colLength | 0));
	      }

	      var f = flatten(col); // push a value to each row

	      for (var _i = 0; _i < N; _i++) {
	        result[_i].push(f[_i]);
	      }
	    }

	    return result;
	  }

	  function checkVectorTypeAndReturnLength(vec) {
	    var s = size(vec);

	    if (s.length === 1) {
	      // 1D vector
	      return s[0];
	    } else if (s.length === 2) {
	      // 2D vector
	      if (s[0] === 1) {
	        // row vector
	        return s[1];
	      } else if (s[1] === 1) {
	        // col vector
	        return s[0];
	      } else {
	        throw new TypeError('At least one of the arguments is not a vector.');
	      }
	    } else {
	      throw new TypeError('Only one- or two-dimensional vectors are supported.');
	    }
	  }
	});

	var name$R = 'unaryMinus';
	var dependencies$R = ['typed'];
	var createUnaryMinus = /* #__PURE__ */factory(name$R, dependencies$R, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Inverse the sign of a value, apply a unary minus operation.
	   *
	   * For matrices, the function is evaluated element wise. Boolean values and
	   * strings will be converted to a number. For complex numbers, both real and
	   * complex value are inverted.
	   *
	   * Syntax:
	   *
	   *    math.unaryMinus(x)
	   *
	   * Examples:
	   *
	   *    math.unaryMinus(3.5)      // returns -3.5
	   *    math.unaryMinus(-4.2)     // returns 4.2
	   *
	   * See also:
	   *
	   *    add, subtract, unaryPlus
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x Number to be inverted.
	   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Returns the value with inverted sign.
	   */

	  return typed(name$R, {
	    number: unaryMinusNumber,
	    Complex: function Complex(x) {
	      return x.neg();
	    },
	    BigNumber: function BigNumber(x) {
	      return x.neg();
	    },
	    Fraction: function Fraction(x) {
	      return x.neg();
	    },
	    Unit: function Unit(x) {
	      var res = x.clone();
	      res.value = this(x.value);
	      return res;
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      // deep map collection, skip zeros since unaryMinus(0) = 0
	      return deepMap(x, this);
	    } // TODO: add support for string

	  });
	});

	var name$Q = 'abs';
	var dependencies$Q = ['typed'];
	var createAbs = /* #__PURE__ */factory(name$Q, dependencies$Q, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Calculate the absolute value of a number. For matrices, the function is
	   * evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.abs(x)
	   *
	   * Examples:
	   *
	   *    math.abs(3.5)                // returns number 3.5
	   *    math.abs(-4.2)               // returns number 4.2
	   *
	   *    math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]
	   *
	   * See also:
	   *
	   *    sign
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
	   *            A number or matrix for which to get the absolute value
	   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}
	   *            Absolute value of `x`
	   */

	  return typed(name$Q, {
	    number: absNumber,
	    Complex: function Complex(x) {
	      return x.abs();
	    },
	    BigNumber: function BigNumber(x) {
	      return x.abs();
	    },
	    Fraction: function Fraction(x) {
	      return x.abs();
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      // deep map collection, skip zeros since abs(0) = 0
	      return deepMap(x, this);
	    },
	    Unit: function Unit(x) {
	      return x.abs();
	    }
	  });
	});

	var name$P = 'addScalar';
	var dependencies$P = ['typed'];
	var createAddScalar = /* #__PURE__ */factory(name$P, dependencies$P, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Add two scalar values, `x + y`.
	   * This function is meant for internal use: it is used by the public function
	   * `add`
	   *
	   * This function does not support collections (Array or Matrix).
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to add
	   * @param  {number | BigNumber | Fraction | Complex} y          Second value to add
	   * @return {number | BigNumber | Fraction | Complex | Unit}     Sum of `x` and `y`
	   * @private
	   */

	  return typed(name$P, {
	    'number, number': addNumber,
	    'Complex, Complex': function ComplexComplex(x, y) {
	      return x.add(y);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.plus(y);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.add(y);
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (x.value === null || x.value === undefined) throw new Error('Parameter x contains a unit with undefined value');
	      if (y.value === null || y.value === undefined) throw new Error('Parameter y contains a unit with undefined value');
	      if (!x.equalBase(y)) throw new Error('Units do not match');
	      var res = x.clone();
	      res.value = this(res.value, y.value);
	      res.fixPrefix = false;
	      return res;
	    }
	  });
	});

	var name$O = 'algorithm11';
	var dependencies$O = ['typed', 'equalScalar'];
	var createAlgorithm11 = /* #__PURE__ */factory(name$O, dependencies$O, _ref => {
	  var {
	    typed,
	    equalScalar
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
	   * Callback function invoked NZ times (number of nonzero items in S).
	   *
	   *
	   *            f(Sij, b)  ; S(i,j) !== 0
	   * C(i,j) = 
	   *            0          ; otherwise
	   *
	   *
	   * @param {Matrix}   s                 The SparseMatrix instance (S)
	   * @param {Scalar}   b                 The Scalar value
	   * @param {Function} callback          The f(Aij,b) operation to invoke
	   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
	   *
	   * @return {Matrix}                    SparseMatrix (C)
	   *
	   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
	   */

	  return function algorithm11(s, b, callback, inverse) {
	    // sparse matrix arrays
	    var avalues = s._values;
	    var aindex = s._index;
	    var aptr = s._ptr;
	    var asize = s._size;
	    var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

	    if (!avalues) {
	      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signature that matches (dt, dt)

	      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

	      zero = typed.convert(0, dt); // convert b to the same datatype

	      b = typed.convert(b, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // result arrays


	    var cvalues = [];
	    var cindex = [];
	    var cptr = []; // loop columns

	    for (var j = 0; j < columns; j++) {
	      // initialize ptr
	      cptr[j] = cindex.length; // values in j

	      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        var i = aindex[k]; // invoke callback

	        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b); // check value is zero

	        if (!eq(v, zero)) {
	          // push index & value
	          cindex.push(i);
	          cvalues.push(v);
	        }
	      }
	    } // update ptr


	    cptr[columns] = cindex.length; // return sparse matrix

	    return s.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$N = 'algorithm14';
	var dependencies$N = ['typed'];
	var createAlgorithm14 = /* #__PURE__ */factory(name$N, dependencies$N, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, b).
	   * Callback function invoked MxN times.
	   *
	   * C(i,j,...z) = f(Aij..z, b)
	   *
	   * @param {Matrix}   a                 The DenseMatrix instance (A)
	   * @param {Scalar}   b                 The Scalar value
	   * @param {Function} callback          The f(Aij..z,b) operation to invoke
	   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Aij..z)
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97659042
	   */

	  return function algorithm14(a, b, callback, inverse) {
	    // a arrays
	    var adata = a._data;
	    var asize = a._size;
	    var adt = a._datatype; // datatype

	    var dt; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string') {
	      // datatype
	      dt = adt; // convert b to the same datatype

	      b = typed.convert(b, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // populate cdata, iterate through dimensions


	    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : []; // c matrix

	    return a.createDenseMatrix({
	      data: cdata,
	      size: clone(asize),
	      datatype: dt
	    });
	  }; // recursive function

	  function _iterate(f, level, s, n, av, bv, inverse) {
	    // initialize array for this level
	    var cv = []; // check we reach the last level

	    if (level === s.length - 1) {
	      // loop arrays in last level
	      for (var i = 0; i < n; i++) {
	        // invoke callback and store value
	        cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
	      }
	    } else {
	      // iterate current level
	      for (var j = 0; j < n; j++) {
	        // iterate next level
	        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
	      }
	    }

	    return cv;
	  }
	});

	var name$M = 'algorithm01';
	var dependencies$M = ['typed'];
	var createAlgorithm01 = /* #__PURE__ */factory(name$M, dependencies$M, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix nonzero items and invokes the callback function f(Dij, Sij).
	   * Callback function invoked NNZ times (number of nonzero items in SparseMatrix).
	   *
	   *
	   *            f(Dij, Sij)  ; S(i,j) !== 0
	   * C(i,j) = 
	   *            Dij          ; otherwise
	   *
	   *
	   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
	   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (S)
	   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
	   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
	   */

	  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
	    // dense matrix arrays
	    var adata = denseMatrix._data;
	    var asize = denseMatrix._size;
	    var adt = denseMatrix._datatype; // sparse matrix arrays

	    var bvalues = sparseMatrix._values;
	    var bindex = sparseMatrix._index;
	    var bptr = sparseMatrix._ptr;
	    var bsize = sparseMatrix._size;
	    var bdt = sparseMatrix._datatype; // validate dimensions

	    if (asize.length !== bsize.length) {
	      throw new DimensionError(asize.length, bsize.length);
	    } // check rows & columns


	    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
	      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
	    } // sparse matrix cannot be a Pattern matrix


	    if (!bvalues) {
	      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // process data types

	    var dt = typeof adt === 'string' && adt === bdt ? adt : undefined; // callback function

	    var cf = dt ? typed.find(callback, [dt, dt]) : callback; // vars

	    var i, j; // result (DenseMatrix)

	    var cdata = []; // initialize c

	    for (i = 0; i < rows; i++) {
	      cdata[i] = [];
	    } // workspace


	    var x = []; // marks indicating we have a value in x for a given column

	    var w = []; // loop columns in b

	    for (j = 0; j < columns; j++) {
	      // column mark
	      var mark = j + 1; // values in column j

	      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        i = bindex[k]; // update workspace

	        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]); // mark i as updated

	        w[i] = mark;
	      } // loop rows


	      for (i = 0; i < rows; i++) {
	        // check row is in workspace
	        if (w[i] === mark) {
	          // c[i][j] was already calculated
	          cdata[i][j] = x[i];
	        } else {
	          // item does not exist in S
	          cdata[i][j] = adata[i][j];
	        }
	      }
	    } // return dense matrix


	    return denseMatrix.createDenseMatrix({
	      data: cdata,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$L = 'algorithm04';
	var dependencies$L = ['typed', 'equalScalar'];
	var createAlgorithm04 = /* #__PURE__ */factory(name$L, dependencies$L, _ref => {
	  var {
	    typed,
	    equalScalar
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
	   * Callback function invoked MAX(NNZA, NNZB) times
	   *
	   *
	   *            f(Aij, Bij)  ; A(i,j) !== 0 && B(i,j) !== 0
	   * C(i,j) =   A(i,j)       ; A(i,j) !== 0
	   *            B(i,j)       ; B(i,j) !== 0
	   *
	   *
	   * @param {Matrix}   a                 The SparseMatrix instance (A)
	   * @param {Matrix}   b                 The SparseMatrix instance (B)
	   * @param {Function} callback          The f(Aij,Bij) operation to invoke
	   *
	   * @return {Matrix}                    SparseMatrix (C)
	   *
	   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
	   */

	  return function algorithm04(a, b, callback) {
	    // sparse matrix arrays
	    var avalues = a._values;
	    var aindex = a._index;
	    var aptr = a._ptr;
	    var asize = a._size;
	    var adt = a._datatype; // sparse matrix arrays

	    var bvalues = b._values;
	    var bindex = b._index;
	    var bptr = b._ptr;
	    var bsize = b._size;
	    var bdt = b._datatype; // validate dimensions

	    if (asize.length !== bsize.length) {
	      throw new DimensionError(asize.length, bsize.length);
	    } // check rows & columns


	    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
	      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string' && adt === bdt) {
	      // datatype
	      dt = adt; // find signature that matches (dt, dt)

	      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

	      zero = typed.convert(0, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // result arrays


	    var cvalues = avalues && bvalues ? [] : undefined;
	    var cindex = [];
	    var cptr = []; // workspace

	    var xa = avalues && bvalues ? [] : undefined;
	    var xb = avalues && bvalues ? [] : undefined; // marks indicating we have a value in x for a given column

	    var wa = [];
	    var wb = []; // vars

	    var i, j, k, k0, k1; // loop columns

	    for (j = 0; j < columns; j++) {
	      // update cptr
	      cptr[j] = cindex.length; // columns mark

	      var mark = j + 1; // loop A(:,j)

	      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        i = aindex[k]; // update c

	        cindex.push(i); // update workspace

	        wa[i] = mark; // check we need to process values

	        if (xa) {
	          xa[i] = avalues[k];
	        }
	      } // loop B(:,j)


	      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        i = bindex[k]; // check row exists in A

	        if (wa[i] === mark) {
	          // update record in xa @ i
	          if (xa) {
	            // invoke callback
	            var v = cf(xa[i], bvalues[k]); // check for zero

	            if (!eq(v, zero)) {
	              // update workspace
	              xa[i] = v;
	            } else {
	              // remove mark (index will be removed later)
	              wa[i] = null;
	            }
	          }
	        } else {
	          // update c
	          cindex.push(i); // update workspace

	          wb[i] = mark; // check we need to process values

	          if (xb) {
	            xb[i] = bvalues[k];
	          }
	        }
	      } // check we need to process values (non pattern matrix)


	      if (xa && xb) {
	        // initialize first index in j
	        k = cptr[j]; // loop index in j

	        while (k < cindex.length) {
	          // row
	          i = cindex[k]; // check workspace has value @ i

	          if (wa[i] === mark) {
	            // push value (Aij != 0 || (Aij != 0 && Bij != 0))
	            cvalues[k] = xa[i]; // increment pointer

	            k++;
	          } else if (wb[i] === mark) {
	            // push value (bij != 0)
	            cvalues[k] = xb[i]; // increment pointer

	            k++;
	          } else {
	            // remove index @ k
	            cindex.splice(k, 1);
	          }
	        }
	      }
	    } // update cptr


	    cptr[columns] = cindex.length; // return sparse matrix

	    return a.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$K = 'algorithm10';
	var dependencies$K = ['typed', 'DenseMatrix'];
	var createAlgorithm10 = /* #__PURE__ */factory(name$K, dependencies$K, _ref => {
	  var {
	    typed,
	    DenseMatrix
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
	   * Callback function invoked NZ times (number of nonzero items in S).
	   *
	   *
	   *            f(Sij, b)  ; S(i,j) !== 0
	   * C(i,j) = 
	   *            b          ; otherwise
	   *
	   *
	   * @param {Matrix}   s                 The SparseMatrix instance (S)
	   * @param {Scalar}   b                 The Scalar value
	   * @param {Function} callback          The f(Aij,b) operation to invoke
	   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
	   */

	  return function algorithm10(s, b, callback, inverse) {
	    // sparse matrix arrays
	    var avalues = s._values;
	    var aindex = s._index;
	    var aptr = s._ptr;
	    var asize = s._size;
	    var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

	    if (!avalues) {
	      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string') {
	      // datatype
	      dt = adt; // convert b to the same datatype

	      b = typed.convert(b, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // result arrays


	    var cdata = []; // workspaces

	    var x = []; // marks indicating we have a value in x for a given column

	    var w = []; // loop columns

	    for (var j = 0; j < columns; j++) {
	      // columns mark
	      var mark = j + 1; // values in j

	      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        var r = aindex[k]; // update workspace

	        x[r] = avalues[k];
	        w[r] = mark;
	      } // loop rows


	      for (var i = 0; i < rows; i++) {
	        // initialize C on first column
	        if (j === 0) {
	          // create row array
	          cdata[i] = [];
	        } // check sparse matrix has a value @ i,j


	        if (w[i] === mark) {
	          // invoke callback, update C
	          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
	        } else {
	          // dense matrix value @ i, j
	          cdata[i][j] = b;
	        }
	      }
	    } // return dense matrix


	    return new DenseMatrix({
	      data: cdata,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$J = 'algorithm13';
	var dependencies$J = ['typed'];
	var createAlgorithm13 = /* #__PURE__ */factory(name$J, dependencies$J, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Iterates over DenseMatrix items and invokes the callback function f(Aij..z, Bij..z).
	   * Callback function invoked MxN times.
	   *
	   * C(i,j,...z) = f(Aij..z, Bij..z)
	   *
	   * @param {Matrix}   a                 The DenseMatrix instance (A)
	   * @param {Matrix}   b                 The DenseMatrix instance (B)
	   * @param {Function} callback          The f(Aij..z,Bij..z) operation to invoke
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97658658
	   */

	  return function algorithm13(a, b, callback) {
	    // a arrays
	    var adata = a._data;
	    var asize = a._size;
	    var adt = a._datatype; // b arrays

	    var bdata = b._data;
	    var bsize = b._size;
	    var bdt = b._datatype; // c arrays

	    var csize = []; // validate dimensions

	    if (asize.length !== bsize.length) {
	      throw new DimensionError(asize.length, bsize.length);
	    } // validate each one of the dimension sizes


	    for (var s = 0; s < asize.length; s++) {
	      // must match
	      if (asize[s] !== bsize[s]) {
	        throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
	      } // update dimension in c


	      csize[s] = asize[s];
	    } // datatype


	    var dt; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string' && adt === bdt) {
	      // datatype
	      dt = adt; // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // populate cdata, iterate through dimensions


	    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : []; // c matrix

	    return a.createDenseMatrix({
	      data: cdata,
	      size: csize,
	      datatype: dt
	    });
	  }; // recursive function

	  function _iterate(f, level, s, n, av, bv) {
	    // initialize array for this level
	    var cv = []; // check we reach the last level

	    if (level === s.length - 1) {
	      // loop arrays in last level
	      for (var i = 0; i < n; i++) {
	        // invoke callback and store value
	        cv[i] = f(av[i], bv[i]);
	      }
	    } else {
	      // iterate current level
	      for (var j = 0; j < n; j++) {
	        // iterate next level
	        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
	      }
	    }

	    return cv;
	  }
	});

	var name$I = 'algorithm03';
	var dependencies$I = ['typed'];
	var createAlgorithm03 = /* #__PURE__ */factory(name$I, dependencies$I, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix items and invokes the callback function f(Dij, Sij).
	   * Callback function invoked M*N times.
	   *
	   *
	   *            f(Dij, Sij)  ; S(i,j) !== 0
	   * C(i,j) = 
	   *            f(Dij, 0)    ; otherwise
	   *
	   *
	   * @param {Matrix}   denseMatrix       The DenseMatrix instance (D)
	   * @param {Matrix}   sparseMatrix      The SparseMatrix instance (C)
	   * @param {Function} callback          The f(Dij,Sij) operation to invoke, where Dij = DenseMatrix(i,j) and Sij = SparseMatrix(i,j)
	   * @param {boolean}  inverse           A true value indicates callback should be invoked f(Sij,Dij)
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97477571
	   */

	  return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
	    // dense matrix arrays
	    var adata = denseMatrix._data;
	    var asize = denseMatrix._size;
	    var adt = denseMatrix._datatype; // sparse matrix arrays

	    var bvalues = sparseMatrix._values;
	    var bindex = sparseMatrix._index;
	    var bptr = sparseMatrix._ptr;
	    var bsize = sparseMatrix._size;
	    var bdt = sparseMatrix._datatype; // validate dimensions

	    if (asize.length !== bsize.length) {
	      throw new DimensionError(asize.length, bsize.length);
	    } // check rows & columns


	    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
	      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
	    } // sparse matrix cannot be a Pattern matrix


	    if (!bvalues) {
	      throw new Error('Cannot perform operation on Dense Matrix and Pattern Sparse Matrix');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // zero value

	    var zero = 0; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string' && adt === bdt) {
	      // datatype
	      dt = adt; // convert 0 to the same datatype

	      zero = typed.convert(0, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // result (DenseMatrix)


	    var cdata = []; // initialize dense matrix

	    for (var z = 0; z < rows; z++) {
	      // initialize row
	      cdata[z] = [];
	    } // workspace


	    var x = []; // marks indicating we have a value in x for a given column

	    var w = []; // loop columns in b

	    for (var j = 0; j < columns; j++) {
	      // column mark
	      var mark = j + 1; // values in column j

	      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        var i = bindex[k]; // update workspace

	        x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
	        w[i] = mark;
	      } // process workspace


	      for (var y = 0; y < rows; y++) {
	        // check we have a calculated value for current row
	        if (w[y] === mark) {
	          // use calculated value
	          cdata[y][j] = x[y];
	        } else {
	          // calculate value
	          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
	        }
	      }
	    } // return dense matrix


	    return denseMatrix.createDenseMatrix({
	      data: cdata,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$H = 'algorithm05';
	var dependencies$H = ['typed', 'equalScalar'];
	var createAlgorithm05 = /* #__PURE__ */factory(name$H, dependencies$H, _ref => {
	  var {
	    typed,
	    equalScalar
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix A and SparseMatrix B nonzero items and invokes the callback function f(Aij, Bij).
	   * Callback function invoked MAX(NNZA, NNZB) times
	   *
	   *
	   *            f(Aij, Bij)  ; A(i,j) !== 0 || B(i,j) !== 0
	   * C(i,j) = 
	   *            0            ; otherwise
	   *
	   *
	   * @param {Matrix}   a                 The SparseMatrix instance (A)
	   * @param {Matrix}   b                 The SparseMatrix instance (B)
	   * @param {Function} callback          The f(Aij,Bij) operation to invoke
	   *
	   * @return {Matrix}                    SparseMatrix (C)
	   *
	   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
	   */

	  return function algorithm05(a, b, callback) {
	    // sparse matrix arrays
	    var avalues = a._values;
	    var aindex = a._index;
	    var aptr = a._ptr;
	    var asize = a._size;
	    var adt = a._datatype; // sparse matrix arrays

	    var bvalues = b._values;
	    var bindex = b._index;
	    var bptr = b._ptr;
	    var bsize = b._size;
	    var bdt = b._datatype; // validate dimensions

	    if (asize.length !== bsize.length) {
	      throw new DimensionError(asize.length, bsize.length);
	    } // check rows & columns


	    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
	      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // equal signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string' && adt === bdt) {
	      // datatype
	      dt = adt; // find signature that matches (dt, dt)

	      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

	      zero = typed.convert(0, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // result arrays


	    var cvalues = avalues && bvalues ? [] : undefined;
	    var cindex = [];
	    var cptr = []; // workspaces

	    var xa = cvalues ? [] : undefined;
	    var xb = cvalues ? [] : undefined; // marks indicating we have a value in x for a given column

	    var wa = [];
	    var wb = []; // vars

	    var i, j, k, k1; // loop columns

	    for (j = 0; j < columns; j++) {
	      // update cptr
	      cptr[j] = cindex.length; // columns mark

	      var mark = j + 1; // loop values A(:,j)

	      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
	        // row
	        i = aindex[k]; // push index

	        cindex.push(i); // update workspace

	        wa[i] = mark; // check we need to process values

	        if (xa) {
	          xa[i] = avalues[k];
	        }
	      } // loop values B(:,j)


	      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
	        // row
	        i = bindex[k]; // check row existed in A

	        if (wa[i] !== mark) {
	          // push index
	          cindex.push(i);
	        } // update workspace


	        wb[i] = mark; // check we need to process values

	        if (xb) {
	          xb[i] = bvalues[k];
	        }
	      } // check we need to process values (non pattern matrix)


	      if (cvalues) {
	        // initialize first index in j
	        k = cptr[j]; // loop index in j

	        while (k < cindex.length) {
	          // row
	          i = cindex[k]; // marks

	          var wai = wa[i];
	          var wbi = wb[i]; // check Aij or Bij are nonzero

	          if (wai === mark || wbi === mark) {
	            // matrix values @ i,j
	            var va = wai === mark ? xa[i] : zero;
	            var vb = wbi === mark ? xb[i] : zero; // Cij

	            var vc = cf(va, vb); // check for zero

	            if (!eq(vc, zero)) {
	              // push value
	              cvalues.push(vc); // increment pointer

	              k++;
	            } else {
	              // remove value @ i, do not increment pointer
	              cindex.splice(k, 1);
	            }
	          }
	        }
	      }
	    } // update cptr


	    cptr[columns] = cindex.length; // return sparse matrix

	    return a.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$G = 'algorithm12';
	var dependencies$G = ['typed', 'DenseMatrix'];
	var createAlgorithm12 = /* #__PURE__ */factory(name$G, dependencies$G, _ref => {
	  var {
	    typed,
	    DenseMatrix
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix S nonzero items and invokes the callback function f(Sij, b).
	   * Callback function invoked MxN times.
	   *
	   *
	   *            f(Sij, b)  ; S(i,j) !== 0
	   * C(i,j) = 
	   *            f(0, b)    ; otherwise
	   *
	   *
	   * @param {Matrix}   s                 The SparseMatrix instance (S)
	   * @param {Scalar}   b                 The Scalar value
	   * @param {Function} callback          The f(Aij,b) operation to invoke
	   * @param {boolean}  inverse           A true value indicates callback should be invoked f(b,Sij)
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * https://github.com/josdejong/mathjs/pull/346#issuecomment-97626813
	   */

	  return function algorithm12(s, b, callback, inverse) {
	    // sparse matrix arrays
	    var avalues = s._values;
	    var aindex = s._index;
	    var aptr = s._ptr;
	    var asize = s._size;
	    var adt = s._datatype; // sparse matrix cannot be a Pattern matrix

	    if (!avalues) {
	      throw new Error('Cannot perform operation on Pattern Sparse Matrix and Scalar value');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string') {
	      // datatype
	      dt = adt; // convert b to the same datatype

	      b = typed.convert(b, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // result arrays


	    var cdata = []; // workspaces

	    var x = []; // marks indicating we have a value in x for a given column

	    var w = []; // loop columns

	    for (var j = 0; j < columns; j++) {
	      // columns mark
	      var mark = j + 1; // values in j

	      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
	        // row
	        var r = aindex[k]; // update workspace

	        x[r] = avalues[k];
	        w[r] = mark;
	      } // loop rows


	      for (var i = 0; i < rows; i++) {
	        // initialize C on first column
	        if (j === 0) {
	          // create row array
	          cdata[i] = [];
	        } // check sparse matrix has a value @ i,j


	        if (w[i] === mark) {
	          // invoke callback, update C
	          cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
	        } else {
	          // dense matrix value @ i, j
	          cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
	        }
	      }
	    } // return dense matrix


	    return new DenseMatrix({
	      data: cdata,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };
	});

	var name$F = 'multiplyScalar';
	var dependencies$F = ['typed'];
	var createMultiplyScalar = /* #__PURE__ */factory(name$F, dependencies$F, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Multiply two scalar values, `x * y`.
	   * This function is meant for internal use: it is used by the public function
	   * `multiply`
	   *
	   * This function does not support collections (Array or Matrix).
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit} x   First value to multiply
	   * @param  {number | BigNumber | Fraction | Complex} y          Second value to multiply
	   * @return {number | BigNumber | Fraction | Complex | Unit}     Multiplication of `x` and `y`
	   * @private
	   */

	  return typed('multiplyScalar', {
	    'number, number': multiplyNumber,
	    'Complex, Complex': function ComplexComplex(x, y) {
	      return x.mul(y);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.times(y);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.mul(y);
	    },
	    'number | Fraction | BigNumber | Complex, Unit': function numberFractionBigNumberComplexUnit(x, y) {
	      var res = y.clone();
	      res.value = res.value === null ? res._normalize(x) : this(res.value, x);
	      return res;
	    },
	    'Unit, number | Fraction | BigNumber | Complex': function UnitNumberFractionBigNumberComplex(x, y) {
	      var res = x.clone();
	      res.value = res.value === null ? res._normalize(y) : this(res.value, y);
	      return res;
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      return x.multiply(y);
	    }
	  });
	});

	var name$E = 'multiply';
	var dependencies$E = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];
	var createMultiply = /* #__PURE__ */factory(name$E, dependencies$E, _ref => {
	  var {
	    typed,
	    matrix,
	    addScalar,
	    multiplyScalar,
	    equalScalar,
	    dot
	  } = _ref;
	  var algorithm11 = createAlgorithm11({
	    typed,
	    equalScalar
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });

	  function _validateMatrixDimensions(size1, size2) {
	    // check left operand dimensions
	    switch (size1.length) {
	      case 1:
	        // check size2
	        switch (size2.length) {
	          case 1:
	            // Vector x Vector
	            if (size1[0] !== size2[0]) {
	              // throw error
	              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');
	            }

	            break;

	          case 2:
	            // Vector x Matrix
	            if (size1[0] !== size2[0]) {
	              // throw error
	              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');
	            }

	            break;

	          default:
	            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
	        }

	        break;

	      case 2:
	        // check size2
	        switch (size2.length) {
	          case 1:
	            // Matrix x Vector
	            if (size1[1] !== size2[0]) {
	              // throw error
	              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');
	            }

	            break;

	          case 2:
	            // Matrix x Matrix
	            if (size1[1] !== size2[0]) {
	              // throw error
	              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');
	            }

	            break;

	          default:
	            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');
	        }

	        break;

	      default:
	        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');
	    }
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            Dense Vector   (N)
	   * @param {Matrix} b            Dense Vector   (N)
	   *
	   * @return {number}             Scalar value
	   */


	  function _multiplyVectorVector(a, b, n) {
	    // check empty vector
	    if (n === 0) {
	      throw new Error('Cannot multiply two empty vectors');
	    }

	    return dot(a, b);
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            Dense Vector   (M)
	   * @param {Matrix} b            Matrix         (MxN)
	   *
	   * @return {Matrix}             Dense Vector   (N)
	   */


	  function _multiplyVectorMatrix(a, b) {
	    // process storage
	    if (b.storage() !== 'dense') {
	      throw new Error('Support for SparseMatrix not implemented');
	    }

	    return _multiplyVectorDenseMatrix(a, b);
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            Dense Vector   (M)
	   * @param {Matrix} b            Dense Matrix   (MxN)
	   *
	   * @return {Matrix}             Dense Vector   (N)
	   */


	  function _multiplyVectorDenseMatrix(a, b) {
	    // a dense
	    var adata = a._data;
	    var asize = a._size;
	    var adt = a._datatype; // b dense

	    var bdata = b._data;
	    var bsize = b._size;
	    var bdt = b._datatype; // rows & columns

	    var alength = asize[0];
	    var bcolumns = bsize[1]; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	    } // result


	    var c = []; // loop matrix columns

	    for (var j = 0; j < bcolumns; j++) {
	      // sum (do not initialize it with zero)
	      var sum = mf(adata[0], bdata[0][j]); // loop vector

	      for (var i = 1; i < alength; i++) {
	        // multiply & accumulate
	        sum = af(sum, mf(adata[i], bdata[i][j]));
	      }

	      c[j] = sum;
	    } // return matrix


	    return a.createDenseMatrix({
	      data: c,
	      size: [bcolumns],
	      datatype: dt
	    });
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            Matrix         (MxN)
	   * @param {Matrix} b            Dense Vector   (N)
	   *
	   * @return {Matrix}             Dense Vector   (M)
	   */


	  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {
	    'DenseMatrix, any': _multiplyDenseMatrixVector,
	    'SparseMatrix, any': _multiplySparseMatrixVector
	  });
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            Matrix         (MxN)
	   * @param {Matrix} b            Matrix         (NxC)
	   *
	   * @return {Matrix}             Matrix         (MxC)
	   */


	  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {
	    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,
	    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,
	    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,
	    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix
	  });
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            DenseMatrix  (MxN)
	   * @param {Matrix} b            Dense Vector (N)
	   *
	   * @return {Matrix}             Dense Vector (M)
	   */


	  function _multiplyDenseMatrixVector(a, b) {
	    // a dense
	    var adata = a._data;
	    var asize = a._size;
	    var adt = a._datatype; // b dense

	    var bdata = b._data;
	    var bdt = b._datatype; // rows & columns

	    var arows = asize[0];
	    var acolumns = asize[1]; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	    } // result


	    var c = []; // loop matrix a rows

	    for (var i = 0; i < arows; i++) {
	      // current row
	      var row = adata[i]; // sum (do not initialize it with zero)

	      var sum = mf(row[0], bdata[0]); // loop matrix a columns

	      for (var j = 1; j < acolumns; j++) {
	        // multiply & accumulate
	        sum = af(sum, mf(row[j], bdata[j]));
	      }

	      c[i] = sum;
	    } // return matrix


	    return a.createDenseMatrix({
	      data: c,
	      size: [arows],
	      datatype: dt
	    });
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            DenseMatrix    (MxN)
	   * @param {Matrix} b            DenseMatrix    (NxC)
	   *
	   * @return {Matrix}             DenseMatrix    (MxC)
	   */


	  function _multiplyDenseMatrixDenseMatrix(a, b) {
	    // a dense
	    var adata = a._data;
	    var asize = a._size;
	    var adt = a._datatype; // b dense

	    var bdata = b._data;
	    var bsize = b._size;
	    var bdt = b._datatype; // rows & columns

	    var arows = asize[0];
	    var acolumns = asize[1];
	    var bcolumns = bsize[1]; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	    } // result


	    var c = []; // loop matrix a rows

	    for (var i = 0; i < arows; i++) {
	      // current row
	      var row = adata[i]; // initialize row array

	      c[i] = []; // loop matrix b columns

	      for (var j = 0; j < bcolumns; j++) {
	        // sum (avoid initializing sum to zero)
	        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns

	        for (var x = 1; x < acolumns; x++) {
	          // multiply & accumulate
	          sum = af(sum, mf(row[x], bdata[x][j]));
	        }

	        c[i][j] = sum;
	      }
	    } // return matrix


	    return a.createDenseMatrix({
	      data: c,
	      size: [arows, bcolumns],
	      datatype: dt
	    });
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            DenseMatrix    (MxN)
	   * @param {Matrix} b            SparseMatrix   (NxC)
	   *
	   * @return {Matrix}             SparseMatrix   (MxC)
	   */


	  function _multiplyDenseMatrixSparseMatrix(a, b) {
	    // a dense
	    var adata = a._data;
	    var asize = a._size;
	    var adt = a._datatype; // b sparse

	    var bvalues = b._values;
	    var bindex = b._index;
	    var bptr = b._ptr;
	    var bsize = b._size;
	    var bdt = b._datatype; // validate b matrix

	    if (!bvalues) {
	      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');
	    } // rows & columns


	    var arows = asize[0];
	    var bcolumns = bsize[1]; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // equalScalar signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

	      zero = typed.convert(0, dt);
	    } // result


	    var cvalues = [];
	    var cindex = [];
	    var cptr = []; // c matrix

	    var c = b.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [arows, bcolumns],
	      datatype: dt
	    }); // loop b columns

	    for (var jb = 0; jb < bcolumns; jb++) {
	      // update ptr
	      cptr[jb] = cindex.length; // indeces in column jb

	      var kb0 = bptr[jb];
	      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists

	      if (kb1 > kb0) {
	        // last row mark processed
	        var last = 0; // loop a rows

	        for (var i = 0; i < arows; i++) {
	          // column mark
	          var mark = i + 1; // C[i, jb]

	          var cij = void 0; // values in b column j

	          for (var kb = kb0; kb < kb1; kb++) {
	            // row
	            var ib = bindex[kb]; // check value has been initialized

	            if (last !== mark) {
	              // first value in column jb
	              cij = mf(adata[i][ib], bvalues[kb]); // update mark

	              last = mark;
	            } else {
	              // accumulate value
	              cij = af(cij, mf(adata[i][ib], bvalues[kb]));
	            }
	          } // check column has been processed and value != 0


	          if (last === mark && !eq(cij, zero)) {
	            // push row & value
	            cindex.push(i);
	            cvalues.push(cij);
	          }
	        }
	      }
	    } // update ptr


	    cptr[bcolumns] = cindex.length; // return sparse matrix

	    return c;
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            SparseMatrix    (MxN)
	   * @param {Matrix} b            Dense Vector (N)
	   *
	   * @return {Matrix}             SparseMatrix    (M, 1)
	   */


	  function _multiplySparseMatrixVector(a, b) {
	    // a sparse
	    var avalues = a._values;
	    var aindex = a._index;
	    var aptr = a._ptr;
	    var adt = a._datatype; // validate a matrix

	    if (!avalues) {
	      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
	    } // b dense


	    var bdata = b._data;
	    var bdt = b._datatype; // rows & columns

	    var arows = a._size[0];
	    var brows = b._size[0]; // result

	    var cvalues = [];
	    var cindex = [];
	    var cptr = []; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // equalScalar signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

	      zero = typed.convert(0, dt);
	    } // workspace


	    var x = []; // vector with marks indicating a value x[i] exists in a given column

	    var w = []; // update ptr

	    cptr[0] = 0; // rows in b

	    for (var ib = 0; ib < brows; ib++) {
	      // b[ib]
	      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops

	      if (!eq(vbi, zero)) {
	        // A values & index in ib column
	        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
	          // a row
	          var ia = aindex[ka]; // check value exists in current j

	          if (!w[ia]) {
	            // ia is new entry in j
	            w[ia] = true; // add i to pattern of C

	            cindex.push(ia); // x(ia) = A

	            x[ia] = mf(vbi, avalues[ka]);
	          } else {
	            // i exists in C already
	            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
	          }
	        }
	      }
	    } // copy values from x to column jb of c


	    for (var p1 = cindex.length, p = 0; p < p1; p++) {
	      // row
	      var ic = cindex[p]; // copy value

	      cvalues[p] = x[ic];
	    } // update ptr


	    cptr[1] = cindex.length; // return sparse matrix

	    return a.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [arows, 1],
	      datatype: dt
	    });
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            SparseMatrix      (MxN)
	   * @param {Matrix} b            DenseMatrix       (NxC)
	   *
	   * @return {Matrix}             SparseMatrix      (MxC)
	   */


	  function _multiplySparseMatrixDenseMatrix(a, b) {
	    // a sparse
	    var avalues = a._values;
	    var aindex = a._index;
	    var aptr = a._ptr;
	    var adt = a._datatype; // validate a matrix

	    if (!avalues) {
	      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');
	    } // b dense


	    var bdata = b._data;
	    var bdt = b._datatype; // rows & columns

	    var arows = a._size[0];
	    var brows = b._size[0];
	    var bcolumns = b._size[1]; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // equalScalar signature to use

	    var eq = equalScalar; // zero value

	    var zero = 0; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype

	      zero = typed.convert(0, dt);
	    } // result


	    var cvalues = [];
	    var cindex = [];
	    var cptr = []; // c matrix

	    var c = a.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [arows, bcolumns],
	      datatype: dt
	    }); // workspace

	    var x = []; // vector with marks indicating a value x[i] exists in a given column

	    var w = []; // loop b columns

	    for (var jb = 0; jb < bcolumns; jb++) {
	      // update ptr
	      cptr[jb] = cindex.length; // mark in workspace for current column

	      var mark = jb + 1; // rows in jb

	      for (var ib = 0; ib < brows; ib++) {
	        // b[ib, jb]
	        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops

	        if (!eq(vbij, zero)) {
	          // A values & index in ib column
	          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
	            // a row
	            var ia = aindex[ka]; // check value exists in current j

	            if (w[ia] !== mark) {
	              // ia is new entry in j
	              w[ia] = mark; // add i to pattern of C

	              cindex.push(ia); // x(ia) = A

	              x[ia] = mf(vbij, avalues[ka]);
	            } else {
	              // i exists in C already
	              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
	            }
	          }
	        }
	      } // copy values from x to column jb of c


	      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
	        // row
	        var ic = cindex[p]; // copy value

	        cvalues[p] = x[ic];
	      }
	    } // update ptr


	    cptr[bcolumns] = cindex.length; // return sparse matrix

	    return c;
	  }
	  /**
	   * C = A * B
	   *
	   * @param {Matrix} a            SparseMatrix      (MxN)
	   * @param {Matrix} b            SparseMatrix      (NxC)
	   *
	   * @return {Matrix}             SparseMatrix      (MxC)
	   */


	  function _multiplySparseMatrixSparseMatrix(a, b) {
	    // a sparse
	    var avalues = a._values;
	    var aindex = a._index;
	    var aptr = a._ptr;
	    var adt = a._datatype; // b sparse

	    var bvalues = b._values;
	    var bindex = b._index;
	    var bptr = b._ptr;
	    var bdt = b._datatype; // rows & columns

	    var arows = a._size[0];
	    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data

	    var values = avalues && bvalues; // datatype

	    var dt; // addScalar signature to use

	    var af = addScalar; // multiplyScalar signature to use

	    var mf = multiplyScalar; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      // datatype
	      dt = adt; // find signatures that matches (dt, dt)

	      af = typed.find(addScalar, [dt, dt]);
	      mf = typed.find(multiplyScalar, [dt, dt]);
	    } // result


	    var cvalues = values ? [] : undefined;
	    var cindex = [];
	    var cptr = []; // c matrix

	    var c = a.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [arows, bcolumns],
	      datatype: dt
	    }); // workspace

	    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column

	    var w = []; // variables

	    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns

	    for (var jb = 0; jb < bcolumns; jb++) {
	      // update ptr
	      cptr[jb] = cindex.length; // mark in workspace for current column

	      var mark = jb + 1; // B values & index in j

	      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
	        // b row
	        ib = bindex[kb]; // check we need to process values

	        if (values) {
	          // loop values in a[:,ib]
	          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
	            // row
	            ia = aindex[ka]; // check value exists in current j

	            if (w[ia] !== mark) {
	              // ia is new entry in j
	              w[ia] = mark; // add i to pattern of C

	              cindex.push(ia); // x(ia) = A

	              x[ia] = mf(bvalues[kb], avalues[ka]);
	            } else {
	              // i exists in C already
	              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
	            }
	          }
	        } else {
	          // loop values in a[:,ib]
	          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
	            // row
	            ia = aindex[ka]; // check value exists in current j

	            if (w[ia] !== mark) {
	              // ia is new entry in j
	              w[ia] = mark; // add i to pattern of C

	              cindex.push(ia);
	            }
	          }
	        }
	      } // check we need to process matrix values (pattern matrix)


	      if (values) {
	        // copy values from x to column jb of c
	        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
	          // row
	          var ic = cindex[p]; // copy value

	          cvalues[p] = x[ic];
	        }
	      }
	    } // update ptr


	    cptr[bcolumns] = cindex.length; // return sparse matrix

	    return c;
	  }
	  /**
	   * Multiply two or more values, `x * y`.
	   * For matrices, the matrix product is calculated.
	   *
	   * Syntax:
	   *
	   *    math.multiply(x, y)
	   *    math.multiply(x, y, z, ...)
	   *
	   * Examples:
	   *
	   *    math.multiply(4, 5.2)        // returns number 20.8
	   *    math.multiply(2, 3, 4)       // returns number 24
	   *
	   *    const a = math.complex(2, 3)
	   *    const b = math.complex(4, 1)
	   *    math.multiply(a, b)          // returns Complex 5 + 14i
	   *
	   *    const c = [[1, 2], [4, 3]]
	   *    const d = [[1, 2, 3], [3, -4, 7]]
	   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]
	   *
	   *    const e = math.unit('2.1 km')
	   *    math.multiply(3, e)          // returns Unit 6.3 km
	   *
	   * See also:
	   *
	   *    divide, prod, cross, dot
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply
	   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`
	   */


	  return typed(name$E, extend({
	    // we extend the signatures of multiplyScalar with signatures dealing with matrices
	    'Array, Array': function ArrayArray(x, y) {
	      // check dimensions
	      _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation


	      var m = this(matrix(x), matrix(y)); // return array or scalar

	      return isMatrix(m) ? m.valueOf() : m;
	    },
	    'Matrix, Matrix': function MatrixMatrix(x, y) {
	      // dimensions
	      var xsize = x.size();
	      var ysize = y.size(); // check dimensions

	      _validateMatrixDimensions(xsize, ysize); // process dimensions


	      if (xsize.length === 1) {
	        // process y dimensions
	        if (ysize.length === 1) {
	          // Vector * Vector
	          return _multiplyVectorVector(x, y, xsize[0]);
	        } // Vector * Matrix


	        return _multiplyVectorMatrix(x, y);
	      } // process y dimensions


	      if (ysize.length === 1) {
	        // Matrix * Vector
	        return _multiplyMatrixVector(x, y);
	      } // Matrix * Matrix


	      return _multiplyMatrixMatrix(x, y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use Matrix * Matrix implementation
	      return this(x, matrix(y));
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use Matrix * Matrix implementation
	      return this(matrix(x, y.storage()), y);
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm11(x, y, multiplyScalar, false);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, multiplyScalar, false);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm11(y, x, multiplyScalar, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, multiplyScalar, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, multiplyScalar, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, multiplyScalar, true).valueOf();
	    },
	    'any, any': multiplyScalar,
	    'any, any, ...any': function anyAnyAny(x, y, rest) {
	      var result = this(x, y);

	      for (var i = 0; i < rest.length; i++) {
	        result = this(result, rest[i]);
	      }

	      return result;
	    }
	  }, multiplyScalar.signatures));
	});

	var name$D = 'sign';
	var dependencies$D = ['typed', 'BigNumber', 'Fraction', 'complex'];
	var createSign = /* #__PURE__ */factory(name$D, dependencies$D, _ref => {
	  var {
	    typed,
	    BigNumber: _BigNumber,
	    complex,
	    Fraction: _Fraction
	  } = _ref;
	  /**
	   * Compute the sign of a value. The sign of a value x is:
	   *
	   * -  1 when x > 0
	   * - -1 when x < 0
	   * -  0 when x == 0
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.sign(x)
	   *
	   * Examples:
	   *
	   *    math.sign(3.5)               // returns 1
	   *    math.sign(-4.2)              // returns -1
	   *    math.sign(0)                 // returns 0
	   *
	   *    math.sign([3, 5, -2, 0, 2])  // returns [1, 1, -1, 0, 1]
	   *
	   * See also:
	   *
	   *    abs
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix | Unit} x
	   *            The number for which to determine the sign
	   * @return {number | BigNumber | Fraction | Complex | Array | Matrix | Unit}e
	   *            The sign of `x`
	   */

	  return typed(name$D, {
	    number: signNumber,
	    Complex: function Complex(x) {
	      return x.im === 0 ? complex(signNumber(x.re)) : x.sign();
	    },
	    BigNumber: function BigNumber(x) {
	      return new _BigNumber(x.cmp(0));
	    },
	    Fraction: function Fraction(x) {
	      return new _Fraction(x.s, 1);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      // deep map collection, skip zeros since sign(0) = 0
	      return deepMap(x, this);
	    },
	    Unit: function Unit(x) {
	      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
	        throw new TypeError('sign is ambiguous for units with offset');
	      }

	      return this(x.value);
	    }
	  });
	});

	var name$C = 'sqrt';
	var dependencies$C = ['config', 'typed', 'Complex'];
	var createSqrt = /* #__PURE__ */factory(name$C, dependencies$C, _ref => {
	  var {
	    config,
	    typed,
	    Complex
	  } = _ref;
	  /**
	   * Calculate the square root of a value.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.sqrt(x)
	   *
	   * Examples:
	   *
	   *    math.sqrt(25)                // returns 5
	   *    math.square(5)               // returns 25
	   *    math.sqrt(-4)                // returns Complex 2i
	   *
	   * See also:
	   *
	   *    square, multiply, cube, cbrt, sqrtm
	   *
	   * @param {number | BigNumber | Complex | Array | Matrix | Unit} x
	   *            Value for which to calculate the square root.
	   * @return {number | BigNumber | Complex | Array | Matrix | Unit}
	   *            Returns the square root of `x`
	   */

	  return typed('sqrt', {
	    number: _sqrtNumber,
	    Complex: function Complex(x) {
	      return x.sqrt();
	    },
	    BigNumber: function BigNumber(x) {
	      if (!x.isNegative() || config.predictable) {
	        return x.sqrt();
	      } else {
	        // negative value -> downgrade to number to do complex value computation
	        return _sqrtNumber(x.toNumber());
	      }
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      // deep map collection, skip zeros since sqrt(0) = 0
	      return deepMap(x, this);
	    },
	    Unit: function Unit(x) {
	      // Someday will work for complex units when they are implemented
	      return x.pow(0.5);
	    }
	  });
	  /**
	   * Calculate sqrt for a number
	   * @param {number} x
	   * @returns {number | Complex} Returns the square root of x
	   * @private
	   */

	  function _sqrtNumber(x) {
	    if (isNaN(x)) {
	      return NaN;
	    } else if (x >= 0 || config.predictable) {
	      return Math.sqrt(x);
	    } else {
	      return new Complex(x, 0).sqrt();
	    }
	  }
	});

	var name$B = 'subtract';
	var dependencies$B = ['typed', 'matrix', 'equalScalar', 'addScalar', 'unaryMinus', 'DenseMatrix'];
	var createSubtract = /* #__PURE__ */factory(name$B, dependencies$B, _ref => {
	  var {
	    typed,
	    matrix,
	    equalScalar,
	    addScalar,
	    unaryMinus,
	    DenseMatrix
	  } = _ref; // TODO: split function subtract in two: subtract and subtractScalar

	  var algorithm01 = createAlgorithm01({
	    typed
	  });
	  var algorithm03 = createAlgorithm03({
	    typed
	  });
	  var algorithm05 = createAlgorithm05({
	    typed,
	    equalScalar
	  });
	  var algorithm10 = createAlgorithm10({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Subtract two values, `x - y`.
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.subtract(x, y)
	   *
	   * Examples:
	   *
	   *    math.subtract(5.3, 2)        // returns number 3.3
	   *
	   *    const a = math.complex(2, 3)
	   *    const b = math.complex(4, 1)
	   *    math.subtract(a, b)          // returns Complex -2 + 2i
	   *
	   *    math.subtract([5, 7, 4], 4)  // returns Array [1, 3, 0]
	   *
	   *    const c = math.unit('2.1 km')
	   *    const d = math.unit('500m')
	   *    math.subtract(c, d)          // returns Unit 1.6 km
	   *
	   * See also:
	   *
	   *    add
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x
	   *            Initial value
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y
	   *            Value to subtract from `x`
	   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}
	   *            Subtraction of `x` and `y`
	   */

	  return typed(name$B, {
	    'number, number': function numberNumber(x, y) {
	      return x - y;
	    },
	    'Complex, Complex': function ComplexComplex(x, y) {
	      return x.sub(y);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.minus(y);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.sub(y);
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (x.value === null) {
	        throw new Error('Parameter x contains a unit with undefined value');
	      }

	      if (y.value === null) {
	        throw new Error('Parameter y contains a unit with undefined value');
	      }

	      if (!x.equalBase(y)) {
	        throw new Error('Units do not match');
	      }

	      var res = x.clone();
	      res.value = this(res.value, y.value);
	      res.fixPrefix = false;
	      return res;
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      checkEqualDimensions(x, y);
	      return algorithm05(x, y, this);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      checkEqualDimensions(x, y);
	      return algorithm03(y, x, this, true);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      checkEqualDimensions(x, y);
	      return algorithm01(x, y, this, false);
	    },
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      checkEqualDimensions(x, y);
	      return algorithm13(x, y, this);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm10(x, unaryMinus(y), addScalar);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, this);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm10(y, x, this, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, this, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, this, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, this, true).valueOf();
	    }
	  });
	});
	/**
	 * Check whether matrix x and y have the same number of dimensions.
	 * Throws a DimensionError when dimensions are not equal
	 * @param {Matrix} x
	 * @param {Matrix} y
	 */

	function checkEqualDimensions(x, y) {
	  var xsize = x.size();
	  var ysize = y.size();

	  if (xsize.length !== ysize.length) {
	    throw new DimensionError(xsize.length, ysize.length);
	  }
	}

	var name$A = 'algorithm07';
	var dependencies$A = ['typed', 'DenseMatrix'];
	var createAlgorithm07 = /* #__PURE__ */factory(name$A, dependencies$A, _ref => {
	  var {
	    typed,
	    DenseMatrix
	  } = _ref;
	  /**
	   * Iterates over SparseMatrix A and SparseMatrix B items (zero and nonzero) and invokes the callback function f(Aij, Bij).
	   * Callback function invoked MxN times.
	   *
	   * C(i,j) = f(Aij, Bij)
	   *
	   * @param {Matrix}   a                 The SparseMatrix instance (A)
	   * @param {Matrix}   b                 The SparseMatrix instance (B)
	   * @param {Function} callback          The f(Aij,Bij) operation to invoke
	   *
	   * @return {Matrix}                    DenseMatrix (C)
	   *
	   * see https://github.com/josdejong/mathjs/pull/346#issuecomment-97620294
	   */

	  return function algorithm07(a, b, callback) {
	    // sparse matrix arrays
	    var asize = a._size;
	    var adt = a._datatype; // sparse matrix arrays

	    var bsize = b._size;
	    var bdt = b._datatype; // validate dimensions

	    if (asize.length !== bsize.length) {
	      throw new DimensionError(asize.length, bsize.length);
	    } // check rows & columns


	    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
	      throw new RangeError('Dimension mismatch. Matrix A (' + asize + ') must match Matrix B (' + bsize + ')');
	    } // rows & columns


	    var rows = asize[0];
	    var columns = asize[1]; // datatype

	    var dt; // zero value

	    var zero = 0; // callback signature to use

	    var cf = callback; // process data types

	    if (typeof adt === 'string' && adt === bdt) {
	      // datatype
	      dt = adt; // convert 0 to the same datatype

	      zero = typed.convert(0, dt); // callback

	      cf = typed.find(callback, [dt, dt]);
	    } // vars


	    var i, j; // result arrays

	    var cdata = []; // initialize c

	    for (i = 0; i < rows; i++) {
	      cdata[i] = [];
	    } // workspaces


	    var xa = [];
	    var xb = []; // marks indicating we have a value in x for a given column

	    var wa = [];
	    var wb = []; // loop columns

	    for (j = 0; j < columns; j++) {
	      // columns mark
	      var mark = j + 1; // scatter the values of A(:,j) into workspace

	      _scatter(a, j, wa, xa, mark); // scatter the values of B(:,j) into workspace


	      _scatter(b, j, wb, xb, mark); // loop rows


	      for (i = 0; i < rows; i++) {
	        // matrix values @ i,j
	        var va = wa[i] === mark ? xa[i] : zero;
	        var vb = wb[i] === mark ? xb[i] : zero; // invoke callback

	        cdata[i][j] = cf(va, vb);
	      }
	    } // return dense matrix


	    return new DenseMatrix({
	      data: cdata,
	      size: [rows, columns],
	      datatype: dt
	    });
	  };

	  function _scatter(m, j, w, x, mark) {
	    // a arrays
	    var values = m._values;
	    var index = m._index;
	    var ptr = m._ptr; // loop values in column j

	    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
	      // row
	      var i = index[k]; // update workspace

	      w[i] = mark;
	      x[i] = values[k];
	    }
	  }
	});

	var name$z = 'conj';
	var dependencies$z = ['typed'];
	var createConj = /* #__PURE__ */factory(name$z, dependencies$z, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Compute the complex conjugate of a complex value.
	   * If `x = a+bi`, the complex conjugate of `x` is `a - bi`.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.conj(x)
	   *
	   * Examples:
	   *
	   *    math.conj(math.complex('2 + 3i'))  // returns Complex 2 - 3i
	   *    math.conj(math.complex('2 - 3i'))  // returns Complex 2 + 3i
	   *    math.conj(math.complex('-5.2i'))  // returns Complex 5.2i
	   *
	   * See also:
	   *
	   *    re, im, arg, abs
	   *
	   * @param {number | BigNumber | Complex | Array | Matrix} x
	   *            A complex number or array with complex numbers
	   * @return {number | BigNumber | Complex | Array | Matrix}
	   *            The complex conjugate of x
	   */

	  return typed(name$z, {
	    number: function number(x) {
	      return x;
	    },
	    BigNumber: function BigNumber(x) {
	      return x;
	    },
	    Complex: function Complex(x) {
	      return x.conjugate();
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$y = 'im';
	var dependencies$y = ['typed'];
	var createIm = /* #__PURE__ */factory(name$y, dependencies$y, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Get the imaginary part of a complex number.
	   * For a complex number `a + bi`, the function returns `b`.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.im(x)
	   *
	   * Examples:
	   *
	   *    const a = math.complex(2, 3)
	   *    math.re(a)                     // returns number 2
	   *    math.im(a)                     // returns number 3
	   *
	   *    math.re(math.complex('-5.2i')) // returns number -5.2
	   *    math.re(math.complex(2.4))     // returns number 0
	   *
	   * See also:
	   *
	   *    re, conj, abs, arg
	   *
	   * @param {number | BigNumber | Complex | Array | Matrix} x
	   *            A complex number or array with complex numbers
	   * @return {number | BigNumber | Array | Matrix} The imaginary part of x
	   */

	  return typed(name$y, {
	    number: function number(x) {
	      return 0;
	    },
	    BigNumber: function BigNumber(x) {
	      return x.mul(0);
	    },
	    Fraction: function Fraction(x) {
	      return x.mul(0);
	    },
	    Complex: function Complex(x) {
	      return x.im;
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$x = 're';
	var dependencies$x = ['typed'];
	var createRe = /* #__PURE__ */factory(name$x, dependencies$x, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Get the real part of a complex number.
	   * For a complex number `a + bi`, the function returns `a`.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.re(x)
	   *
	   * Examples:
	   *
	   *    const a = math.complex(2, 3)
	   *    math.re(a)                     // returns number 2
	   *    math.im(a)                     // returns number 3
	   *
	   *    math.re(math.complex('-5.2i')) // returns number 0
	   *    math.re(math.complex(2.4))     // returns number 2.4
	   *
	   * See also:
	   *
	   *    im, conj, abs, arg
	   *
	   * @param {number | BigNumber | Complex | Array | Matrix} x
	   *            A complex number or array with complex numbers
	   * @return {number | BigNumber | Array | Matrix} The real part of x
	   */

	  return typed(name$x, {
	    number: function number(x) {
	      return x;
	    },
	    BigNumber: function BigNumber(x) {
	      return x;
	    },
	    Fraction: function Fraction(x) {
	      return x;
	    },
	    Complex: function Complex(x) {
	      return x.re;
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$w = 'column';
	var dependencies$w = ['typed', 'Index', 'matrix', 'range'];
	var createColumn = /* #__PURE__ */factory(name$w, dependencies$w, _ref => {
	  var {
	    typed,
	    Index,
	    matrix,
	    range
	  } = _ref;
	  /**
	   * Return a column from a Matrix.
	   *
	   * Syntax:
	   *
	   *     math.column(value, index)
	   *
	   * Example:
	   *
	   *     // get a column
	   *     const d = [[1, 2], [3, 4]]
	   *     math.column(d, 1) // returns [[2], [4]]
	   *
	   * See also:
	   *
	   *     row
	   *
	   * @param {Array | Matrix } value   An array or matrix
	   * @param {number} column           The index of the column
	   * @return {Array | Matrix}         The retrieved column
	   */

	  return typed(name$w, {
	    'Matrix, number': _column,
	    'Array, number': function ArrayNumber(value, column) {
	      return _column(matrix(clone(value)), column).valueOf();
	    }
	  });
	  /**
	   * Retrieve a column of a matrix
	   * @param {Matrix } value  A matrix
	   * @param {number} column  The index of the column
	   * @return {Matrix}        The retrieved column
	   */

	  function _column(value, column) {
	    // check dimensions
	    if (value.size().length !== 2) {
	      throw new Error('Only two dimensional matrix is supported');
	    }

	    validateIndex(column, value.size()[1]);
	    var rowRange = range(0, value.size()[0]);
	    var index = new Index(rowRange, column);
	    return value.subset(index);
	  }
	});

	var name$v = 'cross';
	var dependencies$v = ['typed', 'matrix', 'subtract', 'multiply'];
	var createCross = /* #__PURE__ */factory(name$v, dependencies$v, _ref => {
	  var {
	    typed,
	    matrix,
	    subtract,
	    multiply
	  } = _ref;
	  /**
	   * Calculate the cross product for two vectors in three dimensional space.
	   * The cross product of `A = [a1, a2, a3]` and `B = [b1, b2, b3]` is defined
	   * as:
	   *
	   *    cross(A, B) = [
	   *      a2 * b3 - a3 * b2,
	   *      a3 * b1 - a1 * b3,
	   *      a1 * b2 - a2 * b1
	   *    ]
	   *
	   * If one of the input vectors has a dimension greater than 1, the output
	   * vector will be a 1x3 (2-dimensional) matrix.
	   *
	   * Syntax:
	   *
	   *    math.cross(x, y)
	   *
	   * Examples:
	   *
	   *    math.cross([1, 1, 0],   [0, 1, 1])       // Returns [1, -1, 1]
	   *    math.cross([3, -3, 1],  [4, 9, 2])       // Returns [-15, -2, 39]
	   *    math.cross([2, 3, 4],   [5, 6, 7])       // Returns [-3, 6, -3]
	   *    math.cross([[1, 2, 3]], [[4], [5], [6]]) // Returns [[-3, 6, -3]]
	   *
	   * See also:
	   *
	   *    dot, multiply
	   *
	   * @param  {Array | Matrix} x   First vector
	   * @param  {Array | Matrix} y   Second vector
	   * @return {Array | Matrix}     Returns the cross product of `x` and `y`
	   */

	  return typed(name$v, {
	    'Matrix, Matrix': function MatrixMatrix(x, y) {
	      return matrix(_cross(x.toArray(), y.toArray()));
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      return matrix(_cross(x.toArray(), y));
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      return matrix(_cross(x, y.toArray()));
	    },
	    'Array, Array': _cross
	  });
	  /**
	   * Calculate the cross product for two arrays
	   * @param {Array} x  First vector
	   * @param {Array} y  Second vector
	   * @returns {Array} Returns the cross product of x and y
	   * @private
	   */

	  function _cross(x, y) {
	    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
	    x = squeeze(x);
	    y = squeeze(y);
	    var xSize = arraySize(x);
	    var ySize = arraySize(y);

	    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
	      throw new RangeError('Vectors with length 3 expected ' + '(Size A = [' + xSize.join(', ') + '], B = [' + ySize.join(', ') + '])');
	    }

	    var product = [subtract(multiply(x[1], y[2]), multiply(x[2], y[1])), subtract(multiply(x[2], y[0]), multiply(x[0], y[2])), subtract(multiply(x[0], y[1]), multiply(x[1], y[0]))];

	    if (highestDimension > 1) {
	      return [product];
	    } else {
	      return product;
	    }
	  }
	});

	var name$u = 'diag';
	var dependencies$u = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];
	var createDiag = /* #__PURE__ */factory(name$u, dependencies$u, _ref => {
	  var {
	    typed,
	    matrix,
	    DenseMatrix,
	    SparseMatrix
	  } = _ref;
	  /**
	   * Create a diagonal matrix or retrieve the diagonal of a matrix
	   *
	   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.
	   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.
	   * When k is positive, the values are placed on the super diagonal.
	   * When k is negative, the values are placed on the sub diagonal.
	   *
	   * Syntax:
	   *
	   *     math.diag(X)
	   *     math.diag(X, format)
	   *     math.diag(X, k)
	   *     math.diag(X, k, format)
	   *
	   * Examples:
	   *
	   *     // create a diagonal matrix
	   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
	   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]
	   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]
	   *
	   *    // retrieve the diagonal from a matrix
	   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
	   *    math.diag(a)   // returns [1, 5, 9]
	   *
	   * See also:
	   *
	   *     ones, zeros, identity
	   *
	   * @param {Matrix | Array} x          A two dimensional matrix or a vector
	   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled
	   *                                    in or retrieved.
	   * @param {string} [format='dense']   The matrix storage format.
	   *
	   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.
	   */

	  return typed(name$u, {
	    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
	    Array: function Array(x) {
	      return _diag(x, 0, arraySize(x), null);
	    },
	    'Array, number': function ArrayNumber(x, k) {
	      return _diag(x, k, arraySize(x), null);
	    },
	    'Array, BigNumber': function ArrayBigNumber(x, k) {
	      return _diag(x, k.toNumber(), arraySize(x), null);
	    },
	    'Array, string': function ArrayString(x, format) {
	      return _diag(x, 0, arraySize(x), format);
	    },
	    'Array, number, string': function ArrayNumberString(x, k, format) {
	      return _diag(x, k, arraySize(x), format);
	    },
	    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {
	      return _diag(x, k.toNumber(), arraySize(x), format);
	    },
	    Matrix: function Matrix(x) {
	      return _diag(x, 0, x.size(), x.storage());
	    },
	    'Matrix, number': function MatrixNumber(x, k) {
	      return _diag(x, k, x.size(), x.storage());
	    },
	    'Matrix, BigNumber': function MatrixBigNumber(x, k) {
	      return _diag(x, k.toNumber(), x.size(), x.storage());
	    },
	    'Matrix, string': function MatrixString(x, format) {
	      return _diag(x, 0, x.size(), format);
	    },
	    'Matrix, number, string': function MatrixNumberString(x, k, format) {
	      return _diag(x, k, x.size(), format);
	    },
	    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {
	      return _diag(x, k.toNumber(), x.size(), format);
	    }
	  });
	  /**
	   * Creeate diagonal matrix from a vector or vice versa
	   * @param {Array | Matrix} x
	   * @param {number} k
	   * @param {string} format Storage format for matrix. If null,
	   *                          an Array is returned
	   * @returns {Array | Matrix}
	   * @private
	   */

	  function _diag(x, k, size, format) {
	    if (!isInteger(k)) {
	      throw new TypeError('Second parameter in function diag must be an integer');
	    }

	    var kSuper = k > 0 ? k : 0;
	    var kSub = k < 0 ? -k : 0; // check dimensions

	    switch (size.length) {
	      case 1:
	        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);

	      case 2:
	        return _getDiagonal(x, k, format, size, kSub, kSuper);
	    }

	    throw new RangeError('Matrix for function diag must be 2 dimensional');
	  }

	  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {
	    // matrix size
	    var ms = [l + kSub, l + kSuper];

	    if (format && format !== 'sparse' && format !== 'dense') {
	      throw new TypeError("Unknown matrix type ".concat(format, "\""));
	    } // create diagonal matrix


	    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix

	    return format !== null ? m : m.valueOf();
	  }

	  function _getDiagonal(x, k, format, s, kSub, kSuper) {
	    // check x is a Matrix
	    if (isMatrix(x)) {
	      // get diagonal matrix
	      var dm = x.diagonal(k); // check we need to return a matrix

	      if (format !== null) {
	        // check we need to change matrix format
	        if (format !== dm.storage()) {
	          return matrix(dm, format);
	        }

	        return dm;
	      }

	      return dm.valueOf();
	    } // vector size


	    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values

	    var vector = []; // loop diagonal

	    for (var i = 0; i < n; i++) {
	      vector[i] = x[i + kSub][i + kSuper];
	    } // check we need to return a matrix


	    return format !== null ? matrix(vector) : vector;
	  }
	});

	var name$t = 'flatten';
	var dependencies$t = ['typed', 'matrix'];
	var createFlatten = /* #__PURE__ */factory(name$t, dependencies$t, _ref => {
	  var {
	    typed,
	    matrix
	  } = _ref;
	  /**
	   * Flatten a multi dimensional matrix into a single dimensional matrix.
	   * It is guaranteed to always return a clone of the argument.
	   *
	   * Syntax:
	   *
	   *    math.flatten(x)
	   *
	   * Examples:
	   *
	   *    math.flatten([[1,2], [3,4]])   // returns [1, 2, 3, 4]
	   *
	   * See also:
	   *
	   *    concat, resize, size, squeeze
	   *
	   * @param {Matrix | Array} x   Matrix to be flattened
	   * @return {Matrix | Array} Returns the flattened matrix
	   */

	  return typed(name$t, {
	    Array: function Array(x) {
	      return flatten$1(clone(x));
	    },
	    Matrix: function Matrix(x) {
	      var flat = flatten$1(clone(x.toArray())); // TODO: return the same matrix type as x

	      return matrix(flat);
	    }
	  });
	});

	var name$s = 'identity';
	var dependencies$s = ['typed', 'config', 'matrix', 'BigNumber', 'DenseMatrix', 'SparseMatrix'];
	var createIdentity = /* #__PURE__ */factory(name$s, dependencies$s, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    BigNumber,
	    DenseMatrix,
	    SparseMatrix
	  } = _ref;
	  /**
	   * Create a 2-dimensional identity matrix with size m x n or n x n.
	   * The matrix has ones on the diagonal and zeros elsewhere.
	   *
	   * Syntax:
	   *
	   *    math.identity(n)
	   *    math.identity(n, format)
	   *    math.identity(m, n)
	   *    math.identity(m, n, format)
	   *    math.identity([m, n])
	   *    math.identity([m, n], format)
	   *
	   * Examples:
	   *
	   *    math.identity(3)                    // returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
	   *    math.identity(3, 2)                 // returns [[1, 0], [0, 1], [0, 0]]
	   *
	   *    const A = [[1, 2, 3], [4, 5, 6]]
	   *    math.identity(math.size(A))         // returns [[1, 0, 0], [0, 1, 0]]
	   *
	   * See also:
	   *
	   *    diag, ones, zeros, size, range
	   *
	   * @param {...number | Matrix | Array} size   The size for the matrix
	   * @param {string} [format]                   The Matrix storage format
	   *
	   * @return {Matrix | Array | number} A matrix with ones on the diagonal.
	   */

	  return typed(name$s, {
	    '': function _() {
	      return config.matrix === 'Matrix' ? matrix([]) : [];
	    },
	    string: function string(format) {
	      return matrix(format);
	    },
	    'number | BigNumber': function numberBigNumber(rows) {
	      return _identity(rows, rows, config.matrix === 'Matrix' ? 'dense' : undefined);
	    },
	    'number | BigNumber, string': function numberBigNumberString(rows, format) {
	      return _identity(rows, rows, format);
	    },
	    'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(rows, cols) {
	      return _identity(rows, cols, config.matrix === 'Matrix' ? 'dense' : undefined);
	    },
	    'number | BigNumber, number | BigNumber, string': function numberBigNumberNumberBigNumberString(rows, cols, format) {
	      return _identity(rows, cols, format);
	    },
	    Array: function Array(size) {
	      return _identityVector(size);
	    },
	    'Array, string': function ArrayString(size, format) {
	      return _identityVector(size, format);
	    },
	    Matrix: function Matrix(size) {
	      return _identityVector(size.valueOf(), size.storage());
	    },
	    'Matrix, string': function MatrixString(size, format) {
	      return _identityVector(size.valueOf(), format);
	    }
	  });

	  function _identityVector(size, format) {
	    switch (size.length) {
	      case 0:
	        return format ? matrix(format) : [];

	      case 1:
	        return _identity(size[0], size[0], format);

	      case 2:
	        return _identity(size[0], size[1], format);

	      default:
	        throw new Error('Vector containing two values expected');
	    }
	  }
	  /**
	   * Create an identity matrix
	   * @param {number | BigNumber} rows
	   * @param {number | BigNumber} cols
	   * @param {string} [format]
	   * @returns {Matrix}
	   * @private
	   */


	  function _identity(rows, cols, format) {
	    // BigNumber constructor with the right precision
	    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber : null;
	    if (isBigNumber(rows)) rows = rows.toNumber();
	    if (isBigNumber(cols)) cols = cols.toNumber();

	    if (!isInteger(rows) || rows < 1) {
	      throw new Error('Parameters in function identity must be positive integers');
	    }

	    if (!isInteger(cols) || cols < 1) {
	      throw new Error('Parameters in function identity must be positive integers');
	    }

	    var one = Big ? new BigNumber(1) : 1;
	    var defaultValue = Big ? new Big(0) : 0;
	    var size = [rows, cols]; // check we need to return a matrix

	    if (format) {
	      // create diagonal matrix (use optimized implementation for storage format)
	      if (format === 'sparse') {
	        return SparseMatrix.diagonal(size, one, 0, defaultValue);
	      }

	      if (format === 'dense') {
	        return DenseMatrix.diagonal(size, one, 0, defaultValue);
	      }

	      throw new TypeError("Unknown matrix type \"".concat(format, "\""));
	    } // create and resize array


	    var res = resize([], size, defaultValue); // fill in ones on the diagonal

	    var minimum = rows < cols ? rows : cols; // fill diagonal

	    for (var d = 0; d < minimum; d++) {
	      res[d][d] = one;
	    }

	    return res;
	  }
	});

	function noBignumber() {
	  throw new Error('No "bignumber" implementation available');
	}
	function noFraction() {
	  throw new Error('No "fraction" implementation available');
	}
	function noMatrix() {
	  throw new Error('No "matrix" implementation available');
	}

	var name$r = 'range';
	var dependencies$r = ['typed', 'config', '?matrix', '?bignumber', 'smaller', 'smallerEq', 'larger', 'largerEq'];
	var createRange = /* #__PURE__ */factory(name$r, dependencies$r, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    bignumber,
	    smaller,
	    smallerEq,
	    larger,
	    largerEq
	  } = _ref;
	  /**
	   * Create an array from a range.
	   * By default, the range end is excluded. This can be customized by providing
	   * an extra parameter `includeEnd`.
	   *
	   * Syntax:
	   *
	   *     math.range(str [, includeEnd])               // Create a range from a string,
	   *                                                  // where the string contains the
	   *                                                  // start, optional step, and end,
	   *                                                  // separated by a colon.
	   *     math.range(start, end [, includeEnd])        // Create a range with start and
	   *                                                  // end and a step size of 1.
	   *     math.range(start, end, step [, includeEnd])  // Create a range with start, step,
	   *                                                  // and end.
	   *
	   * Where:
	   *
	   * - `str: string`
	   *   A string 'start:end' or 'start:step:end'
	   * - `start: {number | BigNumber}`
	   *   Start of the range
	   * - `end: number | BigNumber`
	   *   End of the range, excluded by default, included when parameter includeEnd=true
	   * - `step: number | BigNumber`
	   *   Step size. Default value is 1.
	   * - `includeEnd: boolean`
	   *   Option to specify whether to include the end or not. False by default.
	   *
	   * Examples:
	   *
	   *     math.range(2, 6)        // [2, 3, 4, 5]
	   *     math.range(2, -3, -1)   // [2, 1, 0, -1, -2]
	   *     math.range('2:1:6')     // [2, 3, 4, 5]
	   *     math.range(2, 6, true)  // [2, 3, 4, 5, 6]
	   *
	   * See also:
	   *
	   *     ones, zeros, size, subset
	   *
	   * @param {*} args   Parameters describing the ranges `start`, `end`, and optional `step`.
	   * @return {Array | Matrix} range
	   */

	  return typed(name$r, {
	    // TODO: simplify signatures when typed-function supports default values and optional arguments
	    // TODO: a number or boolean should not be converted to string here
	    string: _strRange,
	    'string, boolean': _strRange,
	    'number, number': function numberNumber(start, end) {
	      return _out(_rangeEx(start, end, 1));
	    },
	    'number, number, number': function numberNumberNumber(start, end, step) {
	      return _out(_rangeEx(start, end, step));
	    },
	    'number, number, boolean': function numberNumberBoolean(start, end, includeEnd) {
	      return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
	    },
	    'number, number, number, boolean': function numberNumberNumberBoolean(start, end, step, includeEnd) {
	      return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(start, end) {
	      var BigNumber = start.constructor;
	      return _out(_bigRangeEx(start, end, new BigNumber(1)));
	    },
	    'BigNumber, BigNumber, BigNumber': function BigNumberBigNumberBigNumber(start, end, step) {
	      return _out(_bigRangeEx(start, end, step));
	    },
	    'BigNumber, BigNumber, boolean': function BigNumberBigNumberBoolean(start, end, includeEnd) {
	      var BigNumber = start.constructor;
	      return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber(1))) : _out(_bigRangeEx(start, end, new BigNumber(1)));
	    },
	    'BigNumber, BigNumber, BigNumber, boolean': function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
	      return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
	    }
	  });

	  function _out(arr) {
	    if (config.matrix === 'Matrix') {
	      return matrix ? matrix(arr) : noMatrix();
	    }

	    return arr;
	  }

	  function _strRange(str, includeEnd) {
	    var r = _parse(str);

	    if (!r) {
	      throw new SyntaxError('String "' + str + '" is no valid range');
	    }

	    var fn;

	    if (config.number === 'BigNumber') {
	      if (bignumber === undefined) {
	        noBignumber();
	      }

	      fn = includeEnd ? _bigRangeInc : _bigRangeEx;
	      return _out(fn(bignumber(r.start), bignumber(r.end), bignumber(r.step)));
	    } else {
	      fn = includeEnd ? _rangeInc : _rangeEx;
	      return _out(fn(r.start, r.end, r.step));
	    }
	  }
	  /**
	   * Create a range with numbers. End is excluded
	   * @param {number} start
	   * @param {number} end
	   * @param {number} step
	   * @returns {Array} range
	   * @private
	   */


	  function _rangeEx(start, end, step) {
	    var array = [];
	    var x = start;

	    if (step > 0) {
	      while (smaller(x, end)) {
	        array.push(x);
	        x += step;
	      }
	    } else if (step < 0) {
	      while (larger(x, end)) {
	        array.push(x);
	        x += step;
	      }
	    }

	    return array;
	  }
	  /**
	   * Create a range with numbers. End is included
	   * @param {number} start
	   * @param {number} end
	   * @param {number} step
	   * @returns {Array} range
	   * @private
	   */


	  function _rangeInc(start, end, step) {
	    var array = [];
	    var x = start;

	    if (step > 0) {
	      while (smallerEq(x, end)) {
	        array.push(x);
	        x += step;
	      }
	    } else if (step < 0) {
	      while (largerEq(x, end)) {
	        array.push(x);
	        x += step;
	      }
	    }

	    return array;
	  }
	  /**
	   * Create a range with big numbers. End is excluded
	   * @param {BigNumber} start
	   * @param {BigNumber} end
	   * @param {BigNumber} step
	   * @returns {Array} range
	   * @private
	   */


	  function _bigRangeEx(start, end, step) {
	    var zero = bignumber(0);
	    var array = [];
	    var x = start;

	    if (step.gt(zero)) {
	      while (smaller(x, end)) {
	        array.push(x);
	        x = x.plus(step);
	      }
	    } else if (step.lt(zero)) {
	      while (larger(x, end)) {
	        array.push(x);
	        x = x.plus(step);
	      }
	    }

	    return array;
	  }
	  /**
	   * Create a range with big numbers. End is included
	   * @param {BigNumber} start
	   * @param {BigNumber} end
	   * @param {BigNumber} step
	   * @returns {Array} range
	   * @private
	   */


	  function _bigRangeInc(start, end, step) {
	    var zero = bignumber(0);
	    var array = [];
	    var x = start;

	    if (step.gt(zero)) {
	      while (smallerEq(x, end)) {
	        array.push(x);
	        x = x.plus(step);
	      }
	    } else if (step.lt(zero)) {
	      while (largerEq(x, end)) {
	        array.push(x);
	        x = x.plus(step);
	      }
	    }

	    return array;
	  }
	  /**
	   * Parse a string into a range,
	   * The string contains the start, optional step, and end, separated by a colon.
	   * If the string does not contain a valid range, null is returned.
	   * For example str='0:2:11'.
	   * @param {string} str
	   * @return {{start: number, end: number, step: number} | null} range Object containing properties start, end, step
	   * @private
	   */


	  function _parse(str) {
	    var args = str.split(':'); // number

	    var nums = args.map(function (arg) {
	      // use Number and not parseFloat as Number returns NaN on invalid garbage in the string
	      return Number(arg);
	    });
	    var invalid = nums.some(function (num) {
	      return isNaN(num);
	    });

	    if (invalid) {
	      return null;
	    }

	    switch (nums.length) {
	      case 2:
	        return {
	          start: nums[0],
	          end: nums[1],
	          step: 1
	        };

	      case 3:
	        return {
	          start: nums[0],
	          end: nums[2],
	          step: nums[1]
	        };

	      default:
	        return null;
	    }
	  }
	});

	var name$q = 'size';
	var dependencies$q = ['typed', 'config', '?matrix'];
	var createSize = /* #__PURE__ */factory(name$q, dependencies$q, _ref => {
	  var {
	    typed,
	    config,
	    matrix
	  } = _ref;
	  /**
	   * Calculate the size of a matrix or scalar.
	   *
	   * Syntax:
	   *
	   *     math.size(x)
	   *
	   * Examples:
	   *
	   *     math.size(2.3)                  // returns []
	   *     math.size('hello world')        // returns [11]
	   *
	   *     const A = [[1, 2, 3], [4, 5, 6]]
	   *     math.size(A)                    // returns [2, 3]
	   *     math.size(math.range(1,6))      // returns [5]
	   *
	   * See also:
	   *
	   *     count, resize, squeeze, subset
	   *
	   * @param {boolean | number | Complex | Unit | string | Array | Matrix} x  A matrix
	   * @return {Array | Matrix} A vector with size of `x`.
	   */

	  return typed(name$q, {
	    Matrix: function Matrix(x) {
	      return x.create(x.size());
	    },
	    Array: arraySize,
	    string: function string(x) {
	      return config.matrix === 'Array' ? [x.length] : matrix([x.length]);
	    },
	    'number | Complex | BigNumber | Unit | boolean | null': function numberComplexBigNumberUnitBooleanNull(x) {
	      // scalar
	      return config.matrix === 'Array' ? [] : matrix ? matrix([]) : noMatrix();
	    }
	  });
	});

	var name$p = 'transpose';
	var dependencies$p = ['typed', 'matrix'];
	var createTranspose = /* #__PURE__ */factory(name$p, dependencies$p, _ref => {
	  var {
	    typed,
	    matrix
	  } = _ref;
	  /**
	   * Transpose a matrix. All values of the matrix are reflected over its
	   * main diagonal. Only applicable to two dimensional matrices containing
	   * a vector (i.e. having size `[1,n]` or `[n,1]`). One dimensional
	   * vectors and scalars return the input unchanged.
	   *
	   * Syntax:
	   *
	   *     math.transpose(x)
	   *
	   * Examples:
	   *
	   *     const A = [[1, 2, 3], [4, 5, 6]]
	   *     math.transpose(A)               // returns [[1, 4], [2, 5], [3, 6]]
	   *
	   * See also:
	   *
	   *     diag, inv, subset, squeeze
	   *
	   * @param {Array | Matrix} x  Matrix to be transposed
	   * @return {Array | Matrix}   The transposed matrix
	   */

	  return typed('transpose', {
	    Array: function Array(x) {
	      // use dense matrix implementation
	      return this(matrix(x)).valueOf();
	    },
	    Matrix: function Matrix(x) {
	      // matrix size
	      var size = x.size(); // result

	      var c; // process dimensions

	      switch (size.length) {
	        case 1:
	          // vector
	          c = x.clone();
	          break;

	        case 2:
	          {
	            // rows and columns
	            var rows = size[0];
	            var columns = size[1]; // check columns

	            if (columns === 0) {
	              // throw exception
	              throw new RangeError('Cannot transpose a 2D matrix with no columns (size: ' + format(size) + ')');
	            } // process storage format


	            switch (x.storage()) {
	              case 'dense':
	                c = _denseTranspose(x, rows, columns);
	                break;

	              case 'sparse':
	                c = _sparseTranspose(x, rows, columns);
	                break;
	            }
	          }
	          break;

	        default:
	          // multi dimensional
	          throw new RangeError('Matrix must be a vector or two dimensional (size: ' + format(this._size) + ')');
	      }

	      return c;
	    },
	    // scalars
	    any: function any(x) {
	      return clone(x);
	    }
	  });

	  function _denseTranspose(m, rows, columns) {
	    // matrix array
	    var data = m._data; // transposed matrix data

	    var transposed = [];
	    var transposedRow; // loop columns

	    for (var j = 0; j < columns; j++) {
	      // initialize row
	      transposedRow = transposed[j] = []; // loop rows

	      for (var i = 0; i < rows; i++) {
	        // set data
	        transposedRow[i] = clone(data[i][j]);
	      }
	    } // return matrix


	    return m.createDenseMatrix({
	      data: transposed,
	      size: [columns, rows],
	      datatype: m._datatype
	    });
	  }

	  function _sparseTranspose(m, rows, columns) {
	    // matrix arrays
	    var values = m._values;
	    var index = m._index;
	    var ptr = m._ptr; // result matrices

	    var cvalues = values ? [] : undefined;
	    var cindex = [];
	    var cptr = []; // row counts

	    var w = [];

	    for (var x = 0; x < rows; x++) {
	      w[x] = 0;
	    } // vars


	    var p, l, j; // loop values in matrix

	    for (p = 0, l = index.length; p < l; p++) {
	      // number of values in row
	      w[index[p]]++;
	    } // cumulative sum


	    var sum = 0; // initialize cptr with the cummulative sum of row counts

	    for (var i = 0; i < rows; i++) {
	      // update cptr
	      cptr.push(sum); // update sum

	      sum += w[i]; // update w

	      w[i] = cptr[i];
	    } // update cptr


	    cptr.push(sum); // loop columns

	    for (j = 0; j < columns; j++) {
	      // values & index in column
	      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
	        // C values & index
	        var q = w[index[k]]++; // C[j, i] = A[i, j]

	        cindex[q] = j; // check we need to process values (pattern matrix)

	        if (values) {
	          cvalues[q] = clone(values[k]);
	        }
	      }
	    } // return matrix


	    return m.createSparseMatrix({
	      values: cvalues,
	      index: cindex,
	      ptr: cptr,
	      size: [columns, rows],
	      datatype: m._datatype
	    });
	  }
	});

	var name$o = 'ctranspose';
	var dependencies$o = ['typed', 'transpose', 'conj'];
	var createCtranspose = /* #__PURE__ */factory(name$o, dependencies$o, _ref => {
	  var {
	    typed,
	    transpose,
	    conj
	  } = _ref;
	  /**
	   * Transpose and complex conjugate a matrix. All values of the matrix are
	   * reflected over its main diagonal and then the complex conjugate is
	   * taken. This is equivalent to complex conjugation for scalars and
	   * vectors.
	   *
	   * Syntax:
	   *
	   *     math.ctranspose(x)
	   *
	   * Examples:
	   *
	   *     const A = [[1, 2, 3], [4, 5, math.complex(6,7)]]
	   *     math.ctranspose(A)               // returns [[1, 4], [2, 5], [3, {re:6,im:7}]]
	   *
	   * See also:
	   *
	   *     transpose, diag, inv, subset, squeeze
	   *
	   * @param {Array | Matrix} x  Matrix to be ctransposed
	   * @return {Array | Matrix}   The ctransposed matrix
	   */

	  return typed(name$o, {
	    any: function any(x) {
	      return conj(transpose(x));
	    }
	  });
	});

	var name$n = 'zeros';
	var dependencies$n = ['typed', 'config', 'matrix', 'BigNumber'];
	var createZeros = /* #__PURE__ */factory(name$n, dependencies$n, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    BigNumber
	  } = _ref;
	  /**
	   * Create a matrix filled with zeros. The created matrix can have one or
	   * multiple dimensions.
	   *
	   * Syntax:
	   *
	   *    math.zeros(m)
	   *    math.zeros(m, format)
	   *    math.zeros(m, n)
	   *    math.zeros(m, n, format)
	   *    math.zeros([m, n])
	   *    math.zeros([m, n], format)
	   *
	   * Examples:
	   *
	   *    math.zeros(3)                  // returns [0, 0, 0]
	   *    math.zeros(3, 2)               // returns [[0, 0], [0, 0], [0, 0]]
	   *    math.zeros(3, 'dense')         // returns [0, 0, 0]
	   *
	   *    const A = [[1, 2, 3], [4, 5, 6]]
	   *    math.zeros(math.size(A))       // returns [[0, 0, 0], [0, 0, 0]]
	   *
	   * See also:
	   *
	   *    ones, identity, size, range
	   *
	   * @param {...number | Array} size    The size of each dimension of the matrix
	   * @param {string} [format]           The Matrix storage format
	   *
	   * @return {Array | Matrix}           A matrix filled with zeros
	   */

	  return typed(name$n, {
	    '': function _() {
	      return config.matrix === 'Array' ? _zeros([]) : _zeros([], 'default');
	    },
	    // math.zeros(m, n, p, ..., format)
	    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
	    '...number | BigNumber | string': function numberBigNumberString(size) {
	      var last = size[size.length - 1];

	      if (typeof last === 'string') {
	        var format = size.pop();
	        return _zeros(size, format);
	      } else if (config.matrix === 'Array') {
	        return _zeros(size);
	      } else {
	        return _zeros(size, 'default');
	      }
	    },
	    Array: _zeros,
	    Matrix: function Matrix(size) {
	      var format = size.storage();
	      return _zeros(size.valueOf(), format);
	    },
	    'Array | Matrix, string': function ArrayMatrixString(size, format) {
	      return _zeros(size.valueOf(), format);
	    }
	  });
	  /**
	   * Create an Array or Matrix with zeros
	   * @param {Array} size
	   * @param {string} [format='default']
	   * @return {Array | Matrix}
	   * @private
	   */

	  function _zeros(size, format) {
	    var hasBigNumbers = _normalize(size);

	    var defaultValue = hasBigNumbers ? new BigNumber(0) : 0;

	    _validate(size);

	    if (format) {
	      // return a matrix
	      var m = matrix(format);

	      if (size.length > 0) {
	        return m.resize(size, defaultValue);
	      }

	      return m;
	    } else {
	      // return an Array
	      var arr = [];

	      if (size.length > 0) {
	        return resize(arr, size, defaultValue);
	      }

	      return arr;
	    }
	  } // replace BigNumbers with numbers, returns true if size contained BigNumbers


	  function _normalize(size) {
	    var hasBigNumbers = false;
	    size.forEach(function (value, index, arr) {
	      if (isBigNumber(value)) {
	        hasBigNumbers = true;
	        arr[index] = value.toNumber();
	      }
	    });
	    return hasBigNumbers;
	  } // validate arguments


	  function _validate(size) {
	    size.forEach(function (value) {
	      if (typeof value !== 'number' || !isInteger(value) || value < 0) {
	        throw new Error('Parameters in function zeros must be positive integers');
	      }
	    });
	  }
	}); // TODO: zeros contains almost the same code as ones. Reuse this?

	var name$m = 'numeric';
	var dependencies$m = ['number', '?bignumber', '?fraction'];
	var createNumeric = /* #__PURE__ */factory(name$m, dependencies$m, _ref => {
	  var {
	    number: _number,
	    bignumber,
	    fraction
	  } = _ref;
	  var validInputTypes = {
	    string: true,
	    number: true,
	    BigNumber: true,
	    Fraction: true
	  }; // Load the conversion functions for each output type

	  var validOutputTypes = {
	    number: x => _number(x),
	    BigNumber: bignumber ? x => bignumber(x) : noBignumber,
	    Fraction: fraction ? x => fraction(x) : noFraction
	  };
	  /**
	   * Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.
	   *
	   * Syntax:
	   *
	   *    math.numeric(x)
	   *
	   * Examples:
	   *
	   *    math.numeric('4')                           // returns number 4
	   *    math.numeric('4', 'number')                 // returns number 4
	   *    math.numeric('4', 'BigNumber')              // returns BigNumber 4
	   *    math.numeric('4', 'Fraction')               // returns Fraction 4
	   *    math.numeric(4, 'Fraction')                 // returns Fraction 4
	   *    math.numeric(math.fraction(2, 5), 'number') // returns number 0.4
	   *
	   * See also:
	   *
	   *    number, fraction, bignumber, string, format
	   *
	   * @param {string | number | BigNumber | Fraction } value
	   *              A numeric value or a string containing a numeric value
	   * @param {string} outputType
	   *              Desired numeric output type.
	   *              Available values: 'number', 'BigNumber', or 'Fraction'
	   * @return {number | BigNumber | Fraction}
	   *              Returns an instance of the numeric in the requested type
	   */

	  return function numeric(value, outputType) {
	    var inputType = typeOf(value);

	    if (!(inputType in validInputTypes)) {
	      throw new TypeError('Cannot convert ' + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(', '));
	    }

	    if (!(outputType in validOutputTypes)) {
	      throw new TypeError('Cannot convert ' + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(', '));
	    }

	    if (outputType === inputType) {
	      return value;
	    } else {
	      return validOutputTypes[outputType](value);
	    }
	  };
	});

	var name$l = 'divideScalar';
	var dependencies$l = ['typed', 'numeric'];
	var createDivideScalar = /* #__PURE__ */factory(name$l, dependencies$l, _ref => {
	  var {
	    typed,
	    numeric
	  } = _ref;
	  /**
	   * Divide two scalar values, `x / y`.
	   * This function is meant for internal use: it is used by the public functions
	   * `divide` and `inv`.
	   *
	   * This function does not support collections (Array or Matrix).
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit} x   Numerator
	   * @param  {number | BigNumber | Fraction | Complex} y          Denominator
	   * @return {number | BigNumber | Fraction | Complex | Unit}     Quotient, `x / y`
	   * @private
	   */

	  return typed(name$l, {
	    'number, number': function numberNumber(x, y) {
	      return x / y;
	    },
	    'Complex, Complex': function ComplexComplex(x, y) {
	      return x.div(y);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.div(y);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.div(y);
	    },
	    'Unit, number | Fraction | BigNumber': function UnitNumberFractionBigNumber(x, y) {
	      var res = x.clone(); // TODO: move the divide function to Unit.js, it uses internals of Unit

	      var one = numeric(1, typeOf(y));
	      res.value = this(res.value === null ? res._normalize(one) : res.value, y);
	      return res;
	    },
	    'number | Fraction | BigNumber, Unit': function numberFractionBigNumberUnit(x, y) {
	      var res = y.clone();
	      res = res.pow(-1); // TODO: move the divide function to Unit.js, it uses internals of Unit

	      var one = numeric(1, typeOf(x));
	      res.value = this(x, y.value === null ? y._normalize(one) : y.value);
	      return res;
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      return x.divide(y);
	    }
	  });
	});

	var name$k = 'pow';
	var dependencies$k = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];
	var createPow = /* #__PURE__ */factory(name$k, dependencies$k, _ref => {
	  var {
	    typed,
	    config,
	    identity,
	    multiply,
	    matrix,
	    inv,
	    number,
	    fraction,
	    Complex
	  } = _ref;
	  /**
	   * Calculates the power of x to y, `x ^ y`.
	   *
	   * Matrix exponentiation is supported for square matrices `x` and integers `y`:
	   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is
	   * negative, `x` must be invertible, and then this function returns
	   * inv(x)^(-y).
	   *
	   * For cubic roots of negative numbers, the function returns the principal
	   * root by default. In order to let the function return the real root,
	   * math.js can be configured with `math.config({predictable: true})`.
	   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.
	   *
	   * Syntax:
	   *
	   *    math.pow(x, y)
	   *
	   * Examples:
	   *
	   *    math.pow(2, 3)               // returns number 8
	   *
	   *    const a = math.complex(2, 3)
	   *    math.pow(a, 2)                // returns Complex -5 + 12i
	   *
	   *    const b = [[1, 2], [4, 3]]
	   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]
	   *
	   *    const c = [[1, 2], [4, 3]]
	   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]
	   *
	   * See also:
	   *
	   *    multiply, sqrt, cbrt, nthRoot
	   *
	   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base
	   * @param  {number | BigNumber | Complex} y                          The exponent
	   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`
	   */

	  return typed(name$k, {
	    'number, number': _pow,
	    'Complex, Complex': function ComplexComplex(x, y) {
	      return x.pow(y);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      if (y.isInteger() || x >= 0 || config.predictable) {
	        return x.pow(y);
	      } else {
	        return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);
	      }
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      var result = x.pow(y);

	      if (result != null) {
	        return result;
	      }

	      if (config.predictable) {
	        throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');
	      } else {
	        return _pow(x.valueOf(), y.valueOf());
	      }
	    },
	    'Array, number': _powArray,
	    'Array, BigNumber': function ArrayBigNumber(x, y) {
	      return _powArray(x, y.toNumber());
	    },
	    'Matrix, number': _powMatrix,
	    'Matrix, BigNumber': function MatrixBigNumber(x, y) {
	      return _powMatrix(x, y.toNumber());
	    },
	    'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {
	      return x.pow(y);
	    }
	  });
	  /**
	   * Calculates the power of x to y, x^y, for two numbers.
	   * @param {number} x
	   * @param {number} y
	   * @return {number | Complex} res
	   * @private
	   */

	  function _pow(x, y) {
	    // Alternatively could define a 'realmode' config option or something, but
	    // 'predictable' will work for now
	    if (config.predictable && !isInteger(y) && x < 0) {
	      // Check to see if y can be represented as a fraction
	      try {
	        var yFrac = fraction(y);
	        var yNum = number(yFrac);

	        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
	          if (yFrac.d % 2 === 1) {
	            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
	          }
	        }
	      } catch (ex) {// fraction() throws an error if y is Infinity, etc.
	      } // Unable to express y as a fraction, so continue on

	    } // **for predictable mode** x^Infinity === NaN if x < -1
	    // N.B. this behavour is different from `Math.pow` which gives
	    // (-2)^Infinity === Infinity


	    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
	      return NaN;
	    }

	    if (isInteger(y) || x >= 0 || config.predictable) {
	      return powNumber(x, y);
	    } else {
	      // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow
	      // x^Infinity === 0 if -1 < x < 1
	      // A real number 0 is returned instead of complex(0)
	      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
	        return 0;
	      }

	      return new Complex(x, 0).pow(y, 0);
	    }
	  }
	  /**
	   * Calculate the power of a 2d array
	   * @param {Array} x     must be a 2 dimensional, square matrix
	   * @param {number} y    a integer value (positive if `x` is not invertible)
	   * @returns {Array}
	   * @private
	   */


	  function _powArray(x, y) {
	    if (!isInteger(y)) {
	      throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');
	    } // verify that A is a 2 dimensional square matrix


	    var s = arraySize(x);

	    if (s.length !== 2) {
	      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');
	    }

	    if (s[0] !== s[1]) {
	      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');
	    }

	    if (y < 0) {
	      try {
	        return _powArray(inv(x), -y);
	      } catch (error) {
	        if (error.message === 'Cannot calculate inverse, determinant is zero') {
	          throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');
	        }

	        throw error;
	      }
	    }

	    var res = identity(s[0]).valueOf();
	    var px = x;

	    while (y >= 1) {
	      if ((y & 1) === 1) {
	        res = multiply(px, res);
	      }

	      y >>= 1;
	      px = multiply(px, px);
	    }

	    return res;
	  }
	  /**
	   * Calculate the power of a 2d matrix
	   * @param {Matrix} x     must be a 2 dimensional, square matrix
	   * @param {number} y    a positive, integer value
	   * @returns {Matrix}
	   * @private
	   */


	  function _powMatrix(x, y) {
	    return matrix(_powArray(x.valueOf(), y));
	  }
	});

	function createSolveValidation(_ref) {
	  var {
	    DenseMatrix
	  } = _ref;
	  /**
	   * Validates matrix and column vector b for backward/forward substitution algorithms.
	   *
	   * @param {Matrix} m            An N x N matrix
	   * @param {Array | Matrix} b    A column vector
	   * @param {Boolean} copy        Return a copy of vector b
	   *
	   * @return {DenseMatrix}        Dense column vector b
	   */

	  return function solveValidation(m, b, copy) {
	    var mSize = m.size();

	    if (mSize.length !== 2) {
	      throw new RangeError('Matrix must be two dimensional (size: ' + format(mSize) + ')');
	    }

	    var rows = mSize[0];
	    var columns = mSize[1];

	    if (rows !== columns) {
	      throw new RangeError('Matrix must be square (size: ' + format(mSize) + ')');
	    }

	    var data = [];

	    if (isMatrix(b)) {
	      var bSize = b.size();
	      var bdata = b._data; // 1-dim vector

	      if (bSize.length === 1) {
	        if (bSize[0] !== rows) {
	          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
	        }

	        for (var i = 0; i < rows; i++) {
	          data[i] = [bdata[i]];
	        }

	        return new DenseMatrix({
	          data: data,
	          size: [rows, 1],
	          datatype: b._datatype
	        });
	      } // 2-dim column


	      if (bSize.length === 2) {
	        if (bSize[0] !== rows || bSize[1] !== 1) {
	          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
	        }

	        if (isDenseMatrix(b)) {
	          if (copy) {
	            data = [];

	            for (var _i = 0; _i < rows; _i++) {
	              data[_i] = [bdata[_i][0]];
	            }

	            return new DenseMatrix({
	              data: data,
	              size: [rows, 1],
	              datatype: b._datatype
	            });
	          }

	          return b;
	        }

	        if (isSparseMatrix(b)) {
	          for (var _i2 = 0; _i2 < rows; _i2++) {
	            data[_i2] = [0];
	          }

	          var values = b._values;
	          var index = b._index;
	          var ptr = b._ptr;

	          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
	            var _i3 = index[k];
	            data[_i3][0] = values[k];
	          }

	          return new DenseMatrix({
	            data: data,
	            size: [rows, 1],
	            datatype: b._datatype
	          });
	        }
	      }

	      throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
	    }

	    if (isArray(b)) {
	      var bsize = arraySize(b);

	      if (bsize.length === 1) {
	        if (bsize[0] !== rows) {
	          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
	        }

	        for (var _i4 = 0; _i4 < rows; _i4++) {
	          data[_i4] = [b[_i4]];
	        }

	        return new DenseMatrix({
	          data: data,
	          size: [rows, 1]
	        });
	      }

	      if (bsize.length === 2) {
	        if (bsize[0] !== rows || bsize[1] !== 1) {
	          throw new RangeError('Dimension mismatch. Matrix columns must match vector length.');
	        }

	        for (var _i5 = 0; _i5 < rows; _i5++) {
	          data[_i5] = [b[_i5][0]];
	        }

	        return new DenseMatrix({
	          data: data,
	          size: [rows, 1]
	        });
	      }

	      throw new RangeError('Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.');
	    }
	  };
	}

	var name$j = 'usolve';
	var dependencies$j = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
	var createUsolve = /* #__PURE__ */factory(name$j, dependencies$j, _ref => {
	  var {
	    typed,
	    matrix,
	    divideScalar,
	    multiplyScalar,
	    subtract,
	    equalScalar,
	    DenseMatrix
	  } = _ref;
	  var solveValidation = createSolveValidation({
	    DenseMatrix
	  });
	  /**
	   * Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there's no solution.
	   *
	   * `U * x = b`
	   *
	   * Syntax:
	   *
	   *    math.usolve(U, b)
	   *
	   * Examples:
	   *
	   *    const a = [[-2, 3], [2, 1]]
	   *    const b = [11, 9]
	   *    const x = usolve(a, b)  // [[8], [9]]
	   *
	   * See also:
	   *
	   *    usolveAll, lup, slu, usolve, lusolve
	   *
	   * @param {Matrix, Array} U       A N x N matrix or array (U)
	   * @param {Matrix, Array} b       A column vector with the b values
	   *
	   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)
	   */

	  return typed(name$j, {
	    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
	      return _sparseBackwardSubstitution(m, b);
	    },
	    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
	      return _denseBackwardSubstitution(m, b);
	    },
	    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
	      var m = matrix(a);

	      var r = _denseBackwardSubstitution(m, b);

	      return r.valueOf();
	    }
	  });

	  function _denseBackwardSubstitution(m, b) {
	    // make b into a column vector
	    b = solveValidation(m, b, true);
	    var bdata = b._data;
	    var rows = m._size[0];
	    var columns = m._size[1]; // result

	    var x = [];
	    var mdata = m._data; // loop columns backwards

	    for (var j = columns - 1; j >= 0; j--) {
	      // b[j]
	      var bj = bdata[j][0] || 0; // x[j]

	      var xj = void 0;

	      if (!equalScalar(bj, 0)) {
	        // value at [j, j]
	        var vjj = mdata[j][j];

	        if (equalScalar(vjj, 0)) {
	          // system cannot be solved
	          throw new Error('Linear system cannot be solved since matrix is singular');
	        }

	        xj = divideScalar(bj, vjj); // loop rows

	        for (var i = j - 1; i >= 0; i--) {
	          // update copy of b
	          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];
	        }
	      } else {
	        // zero value at j
	        xj = 0;
	      } // update x


	      x[j] = [xj];
	    }

	    return new DenseMatrix({
	      data: x,
	      size: [rows, 1]
	    });
	  }

	  function _sparseBackwardSubstitution(m, b) {
	    // make b into a column vector
	    b = solveValidation(m, b, true);
	    var bdata = b._data;
	    var rows = m._size[0];
	    var columns = m._size[1];
	    var values = m._values;
	    var index = m._index;
	    var ptr = m._ptr; // result

	    var x = []; // loop columns backwards

	    for (var j = columns - 1; j >= 0; j--) {
	      var bj = bdata[j][0] || 0;

	      if (!equalScalar(bj, 0)) {
	        // non-degenerate row, find solution
	        var vjj = 0; // upper triangular matrix values & index (column j)

	        var jValues = [];
	        var jIndices = []; // first & last indeces in column

	        var firstIndex = ptr[j];
	        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j], loop backwards

	        for (var k = lastIndex - 1; k >= firstIndex; k--) {
	          var i = index[k]; // check row (rows are not sorted!)

	          if (i === j) {
	            vjj = values[k];
	          } else if (i < j) {
	            // store upper triangular
	            jValues.push(values[k]);
	            jIndices.push(i);
	          }
	        } // at this point we must have a value in vjj


	        if (equalScalar(vjj, 0)) {
	          throw new Error('Linear system cannot be solved since matrix is singular');
	        }

	        var xj = divideScalar(bj, vjj);

	        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
	          var _i = jIndices[_k];
	          bdata[_i] = [subtract(bdata[_i][0], multiplyScalar(xj, jValues[_k]))];
	        }

	        x[j] = [xj];
	      } else {
	        // degenerate row, we can choose any value
	        x[j] = [0];
	      }
	    }

	    return new DenseMatrix({
	      data: x,
	      size: [rows, 1]
	    });
	  }
	});

	var name$i = 'usolveAll';
	var dependencies$i = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];
	var createUsolveAll = /* #__PURE__ */factory(name$i, dependencies$i, _ref => {
	  var {
	    typed,
	    matrix,
	    divideScalar,
	    multiplyScalar,
	    subtract,
	    equalScalar,
	    DenseMatrix
	  } = _ref;
	  var solveValidation = createSolveValidation({
	    DenseMatrix
	  });
	  /**
	   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.
	   *
	   * `U * x = b`
	   *
	   * Syntax:
	   *
	   *    math.usolveAll(U, b)
	   *
	   * Examples:
	   *
	   *    const a = [[-2, 3], [2, 1]]
	   *    const b = [11, 9]
	   *    const x = usolveAll(a, b)  // [ [[8], [9]] ]
	   *
	   * See also:
	   *
	   *    usolve, lup, slu, usolve, lusolve
	   *
	   * @param {Matrix, Array} U       A N x N matrix or array (U)
	   * @param {Matrix, Array} b       A column vector with the b values
	   *
	   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system
	   */

	  return typed(name$i, {
	    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {
	      return _sparseBackwardSubstitution(m, b);
	    },
	    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {
	      return _denseBackwardSubstitution(m, b);
	    },
	    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {
	      var m = matrix(a);

	      var R = _denseBackwardSubstitution(m, b);

	      return R.map(r => r.valueOf());
	    }
	  });

	  function _denseBackwardSubstitution(m, b_) {
	    // the algorithm is derived from
	    // https://www.overleaf.com/read/csvgqdxggyjv
	    // array of right-hand sides
	    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
	    var M = m._data;
	    var rows = m._size[0];
	    var columns = m._size[1]; // loop columns backwards

	    for (var i = columns - 1; i >= 0; i--) {
	      var L = B.length; // loop right-hand sides

	      for (var k = 0; k < L; k++) {
	        var b = B[k];

	        if (!equalScalar(M[i][i], 0)) {
	          // non-singular row
	          b[i] = divideScalar(b[i], M[i][i]);

	          for (var j = i - 1; j >= 0; j--) {
	            // b[j] -= b[i] * M[j,i]
	            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));
	          }
	        } else if (!equalScalar(b[i], 0)) {
	          // singular row, nonzero RHS
	          if (k === 0) {
	            // There is no valid solution
	            return [];
	          } else {
	            // This RHS is invalid but other solutions may still exist
	            B.splice(k, 1);
	            k -= 1;
	            L -= 1;
	          }
	        } else if (k === 0) {
	          // singular row, RHS is zero
	          var bNew = [...b];
	          bNew[i] = 1;

	          for (var _j = i - 1; _j >= 0; _j--) {
	            bNew[_j] = subtract(bNew[_j], M[_j][i]);
	          }

	          B.push(bNew);
	        }
	      }
	    }

	    return B.map(x => new DenseMatrix({
	      data: x.map(e => [e]),
	      size: [rows, 1]
	    }));
	  }

	  function _sparseBackwardSubstitution(m, b_) {
	    // array of right-hand sides
	    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];
	    var rows = m._size[0];
	    var columns = m._size[1];
	    var values = m._values;
	    var index = m._index;
	    var ptr = m._ptr; // loop columns backwards

	    for (var i = columns - 1; i >= 0; i--) {
	      var L = B.length; // loop right-hand sides

	      for (var k = 0; k < L; k++) {
	        var b = B[k]; // values & indices (column i)

	        var iValues = [];
	        var iIndices = []; // first & last indeces in column

	        var firstIndex = ptr[i];
	        var lastIndex = ptr[i + 1]; // find the value at [i, i]

	        var Mii = 0;

	        for (var j = lastIndex - 1; j >= firstIndex; j--) {
	          var J = index[j]; // check row

	          if (J === i) {
	            Mii = values[j];
	          } else if (J < i) {
	            // store upper triangular
	            iValues.push(values[j]);
	            iIndices.push(J);
	          }
	        }

	        if (!equalScalar(Mii, 0)) {
	          // non-singular row
	          b[i] = divideScalar(b[i], Mii); // loop upper triangular

	          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
	            var _J = iIndices[_j2];
	            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));
	          }
	        } else if (!equalScalar(b[i], 0)) {
	          // singular row, nonzero RHS
	          if (k === 0) {
	            // There is no valid solution
	            return [];
	          } else {
	            // This RHS is invalid but other solutions may still exist
	            B.splice(k, 1);
	            k -= 1;
	            L -= 1;
	          }
	        } else if (k === 0) {
	          // singular row, RHS is zero
	          var bNew = [...b];
	          bNew[i] = 1; // loop upper triangular

	          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
	            var _J2 = iIndices[_j3];
	            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);
	          }

	          B.push(bNew);
	        }
	      }
	    }

	    return B.map(x => new DenseMatrix({
	      data: x.map(e => [e]),
	      size: [rows, 1]
	    }));
	  }
	});

	var name$h = 'equal';
	var dependencies$h = ['typed', 'matrix', 'equalScalar', 'DenseMatrix'];
	var createEqual = /* #__PURE__ */factory(name$h, dependencies$h, _ref => {
	  var {
	    typed,
	    matrix,
	    equalScalar,
	    DenseMatrix
	  } = _ref;
	  var algorithm03 = createAlgorithm03({
	    typed
	  });
	  var algorithm07 = createAlgorithm07({
	    typed,
	    DenseMatrix
	  });
	  var algorithm12 = createAlgorithm12({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Test whether two values are equal.
	   *
	   * The function tests whether the relative difference between x and y is
	   * smaller than the configured epsilon. The function cannot be used to
	   * compare values smaller than approximately 2.22e-16.
	   *
	   * For matrices, the function is evaluated element wise.
	   * In case of complex numbers, x.re must equal y.re, and x.im must equal y.im.
	   *
	   * Values `null` and `undefined` are compared strictly, thus `null` is only
	   * equal to `null` and nothing else, and `undefined` is only equal to
	   * `undefined` and nothing else. Strings are compared by their numerical value.
	   *
	   * Syntax:
	   *
	   *    math.equal(x, y)
	   *
	   * Examples:
	   *
	   *    math.equal(2 + 2, 3)         // returns false
	   *    math.equal(2 + 2, 4)         // returns true
	   *
	   *    const a = math.unit('50 cm')
	   *    const b = math.unit('5 m')
	   *    math.equal(a, b)             // returns true
	   *
	   *    const c = [2, 5, 1]
	   *    const d = [2, 7, 1]
	   *
	   *    math.equal(c, d)             // returns [true, false, true]
	   *    math.deepEqual(c, d)         // returns false
	   *
	   *    math.equal("1000", "1e3")    // returns true
	   *    math.equal(0, null)          // returns false
	   *
	   * See also:
	   *
	   *    unequal, smaller, smallerEq, larger, largerEq, compare, deepEqual, equalText
	   *
	   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} x First value to compare
	   * @param  {number | BigNumber | boolean | Complex | Unit | string | Array | Matrix} y Second value to compare
	   * @return {boolean | Array | Matrix} Returns true when the compared values are equal, else returns false
	   */

	  return typed(name$h, {
	    'any, any': function anyAny(x, y) {
	      // strict equality for null and undefined?
	      if (x === null) {
	        return y === null;
	      }

	      if (y === null) {
	        return x === null;
	      }

	      if (x === undefined) {
	        return y === undefined;
	      }

	      if (y === undefined) {
	        return x === undefined;
	      }

	      return equalScalar(x, y);
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      return algorithm07(x, y, equalScalar);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      return algorithm03(y, x, equalScalar, true);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      return algorithm03(x, y, equalScalar, false);
	    },
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      return algorithm13(x, y, equalScalar);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm12(x, y, equalScalar, false);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, equalScalar, false);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm12(y, x, equalScalar, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, equalScalar, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, equalScalar, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, equalScalar, true).valueOf();
	    }
	  });
	});
	factory(name$h, ['typed', 'equalScalar'], _ref2 => {
	  var {
	    typed,
	    equalScalar
	  } = _ref2;
	  return typed(name$h, {
	    'any, any': function anyAny(x, y) {
	      // strict equality for null and undefined?
	      if (x === null) {
	        return y === null;
	      }

	      if (y === null) {
	        return x === null;
	      }

	      if (x === undefined) {
	        return y === undefined;
	      }

	      if (y === undefined) {
	        return x === undefined;
	      }

	      return equalScalar(x, y);
	    }
	  });
	});

	var name$g = 'smaller';
	var dependencies$g = ['typed', 'config', 'matrix', 'DenseMatrix'];
	var createSmaller = /* #__PURE__ */factory(name$g, dependencies$g, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    DenseMatrix
	  } = _ref;
	  var algorithm03 = createAlgorithm03({
	    typed
	  });
	  var algorithm07 = createAlgorithm07({
	    typed,
	    DenseMatrix
	  });
	  var algorithm12 = createAlgorithm12({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Test whether value x is smaller than y.
	   *
	   * The function returns true when x is smaller than y and the relative
	   * difference between x and y is smaller than the configured epsilon. The
	   * function cannot be used to compare values smaller than approximately 2.22e-16.
	   *
	   * For matrices, the function is evaluated element wise.
	   * Strings are compared by their numerical value.
	   *
	   * Syntax:
	   *
	   *    math.smaller(x, y)
	   *
	   * Examples:
	   *
	   *    math.smaller(2, 3)            // returns true
	   *    math.smaller(5, 2 * 2)        // returns false
	   *
	   *    const a = math.unit('5 cm')
	   *    const b = math.unit('2 inch')
	   *    math.smaller(a, b)            // returns true
	   *
	   * See also:
	   *
	   *    equal, unequal, smallerEq, smaller, smallerEq, compare
	   *
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
	   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
	   */

	  return typed(name$g, {
	    'boolean, boolean': function booleanBoolean(x, y) {
	      return x < y;
	    },
	    'number, number': function numberNumber(x, y) {
	      return x < y && !nearlyEqual$1(x, y, config.epsilon);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.lt(y) && !nearlyEqual(x, y, config.epsilon);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.compare(y) === -1;
	    },
	    'Complex, Complex': function ComplexComplex(x, y) {
	      throw new TypeError('No ordering relation is defined for complex numbers');
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (!x.equalBase(y)) {
	        throw new Error('Cannot compare units with different base');
	      }

	      return this(x.value, y.value);
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      return algorithm07(x, y, this);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      return algorithm03(y, x, this, true);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      return algorithm03(x, y, this, false);
	    },
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      return algorithm13(x, y, this);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm12(x, y, this, false);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, this, false);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm12(y, x, this, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, this, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, this, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, this, true).valueOf();
	    }
	  });
	});

	var name$f = 'smallerEq';
	var dependencies$f = ['typed', 'config', 'matrix', 'DenseMatrix'];
	var createSmallerEq = /* #__PURE__ */factory(name$f, dependencies$f, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    DenseMatrix
	  } = _ref;
	  var algorithm03 = createAlgorithm03({
	    typed
	  });
	  var algorithm07 = createAlgorithm07({
	    typed,
	    DenseMatrix
	  });
	  var algorithm12 = createAlgorithm12({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Test whether value x is smaller or equal to y.
	   *
	   * The function returns true when x is smaller than y or the relative
	   * difference between x and y is smaller than the configured epsilon. The
	   * function cannot be used to compare values smaller than approximately 2.22e-16.
	   *
	   * For matrices, the function is evaluated element wise.
	   * Strings are compared by their numerical value.
	   *
	   * Syntax:
	   *
	   *    math.smallerEq(x, y)
	   *
	   * Examples:
	   *
	   *    math.smaller(1 + 2, 3)        // returns false
	   *    math.smallerEq(1 + 2, 3)      // returns true
	   *
	   * See also:
	   *
	   *    equal, unequal, smaller, larger, largerEq, compare
	   *
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
	   * @return {boolean | Array | Matrix} Returns true when the x is smaller than y, else returns false
	   */

	  return typed(name$f, {
	    'boolean, boolean': function booleanBoolean(x, y) {
	      return x <= y;
	    },
	    'number, number': function numberNumber(x, y) {
	      return x <= y || nearlyEqual$1(x, y, config.epsilon);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.lte(y) || nearlyEqual(x, y, config.epsilon);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.compare(y) !== 1;
	    },
	    'Complex, Complex': function ComplexComplex() {
	      throw new TypeError('No ordering relation is defined for complex numbers');
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (!x.equalBase(y)) {
	        throw new Error('Cannot compare units with different base');
	      }

	      return this(x.value, y.value);
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      return algorithm07(x, y, this);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      return algorithm03(y, x, this, true);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      return algorithm03(x, y, this, false);
	    },
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      return algorithm13(x, y, this);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm12(x, y, this, false);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, this, false);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm12(y, x, this, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, this, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, this, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, this, true).valueOf();
	    }
	  });
	});

	var name$e = 'larger';
	var dependencies$e = ['typed', 'config', 'matrix', 'DenseMatrix'];
	var createLarger = /* #__PURE__ */factory(name$e, dependencies$e, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    DenseMatrix
	  } = _ref;
	  var algorithm03 = createAlgorithm03({
	    typed
	  });
	  var algorithm07 = createAlgorithm07({
	    typed,
	    DenseMatrix
	  });
	  var algorithm12 = createAlgorithm12({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Test whether value x is larger than y.
	   *
	   * The function returns true when x is larger than y and the relative
	   * difference between x and y is larger than the configured epsilon. The
	   * function cannot be used to compare values smaller than approximately 2.22e-16.
	   *
	   * For matrices, the function is evaluated element wise.
	   * Strings are compared by their numerical value.
	   *
	   * Syntax:
	   *
	   *    math.larger(x, y)
	   *
	   * Examples:
	   *
	   *    math.larger(2, 3)             // returns false
	   *    math.larger(5, 2 + 2)         // returns true
	   *
	   *    const a = math.unit('5 cm')
	   *    const b = math.unit('2 inch')
	   *    math.larger(a, b)             // returns false
	   *
	   * See also:
	   *
	   *    equal, unequal, smaller, smallerEq, largerEq, compare
	   *
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
	   * @return {boolean | Array | Matrix} Returns true when the x is larger than y, else returns false
	   */

	  return typed(name$e, {
	    'boolean, boolean': function booleanBoolean(x, y) {
	      return x > y;
	    },
	    'number, number': function numberNumber(x, y) {
	      return x > y && !nearlyEqual$1(x, y, config.epsilon);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.gt(y) && !nearlyEqual(x, y, config.epsilon);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.compare(y) === 1;
	    },
	    'Complex, Complex': function ComplexComplex() {
	      throw new TypeError('No ordering relation is defined for complex numbers');
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (!x.equalBase(y)) {
	        throw new Error('Cannot compare units with different base');
	      }

	      return this(x.value, y.value);
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      return algorithm07(x, y, this);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      return algorithm03(y, x, this, true);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      return algorithm03(x, y, this, false);
	    },
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      return algorithm13(x, y, this);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm12(x, y, this, false);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, this, false);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm12(y, x, this, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, this, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, this, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, this, true).valueOf();
	    }
	  });
	});

	var name$d = 'largerEq';
	var dependencies$d = ['typed', 'config', 'matrix', 'DenseMatrix'];
	var createLargerEq = /* #__PURE__ */factory(name$d, dependencies$d, _ref => {
	  var {
	    typed,
	    config,
	    matrix,
	    DenseMatrix
	  } = _ref;
	  var algorithm03 = createAlgorithm03({
	    typed
	  });
	  var algorithm07 = createAlgorithm07({
	    typed,
	    DenseMatrix
	  });
	  var algorithm12 = createAlgorithm12({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Test whether value x is larger or equal to y.
	   *
	   * The function returns true when x is larger than y or the relative
	   * difference between x and y is smaller than the configured epsilon. The
	   * function cannot be used to compare values smaller than approximately 2.22e-16.
	   *
	   * For matrices, the function is evaluated element wise.
	   * Strings are compared by their numerical value.
	   *
	   * Syntax:
	   *
	   *    math.largerEq(x, y)
	   *
	   * Examples:
	   *
	   *    math.larger(2, 1 + 1)         // returns false
	   *    math.largerEq(2, 1 + 1)       // returns true
	   *
	   * See also:
	   *
	   *    equal, unequal, smaller, smallerEq, larger, compare
	   *
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} x First value to compare
	   * @param  {number | BigNumber | Fraction | boolean | Unit | string | Array | Matrix} y Second value to compare
	   * @return {boolean | Array | Matrix} Returns true when the x is larger or equal to y, else returns false
	   */

	  return typed(name$d, {
	    'boolean, boolean': function booleanBoolean(x, y) {
	      return x >= y;
	    },
	    'number, number': function numberNumber(x, y) {
	      return x >= y || nearlyEqual$1(x, y, config.epsilon);
	    },
	    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {
	      return x.gte(y) || nearlyEqual(x, y, config.epsilon);
	    },
	    'Fraction, Fraction': function FractionFraction(x, y) {
	      return x.compare(y) !== -1;
	    },
	    'Complex, Complex': function ComplexComplex() {
	      throw new TypeError('No ordering relation is defined for complex numbers');
	    },
	    'Unit, Unit': function UnitUnit(x, y) {
	      if (!x.equalBase(y)) {
	        throw new Error('Cannot compare units with different base');
	      }

	      return this(x.value, y.value);
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      return algorithm07(x, y, this);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      return algorithm03(y, x, this, true);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      return algorithm03(x, y, this, false);
	    },
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      return algorithm13(x, y, this);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm12(x, y, this, false);
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, this, false);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm12(y, x, this, true);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, this, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, this, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, this, true).valueOf();
	    }
	  });
	});

	var name$c = 'ImmutableDenseMatrix';
	var dependencies$c = ['smaller', 'DenseMatrix'];
	var createImmutableDenseMatrixClass = /* #__PURE__ */factory(name$c, dependencies$c, _ref => {
	  var {
	    smaller,
	    DenseMatrix
	  } = _ref;

	  function ImmutableDenseMatrix(data, datatype) {
	    if (!(this instanceof ImmutableDenseMatrix)) {
	      throw new SyntaxError('Constructor must be called with the new operator');
	    }

	    if (datatype && !isString$1(datatype)) {
	      throw new Error('Invalid datatype: ' + datatype);
	    }

	    if (isMatrix(data) || isArray(data)) {
	      // use DenseMatrix implementation
	      var matrix = new DenseMatrix(data, datatype); // internal structures

	      this._data = matrix._data;
	      this._size = matrix._size;
	      this._datatype = matrix._datatype;
	      this._min = null;
	      this._max = null;
	    } else if (data && isArray(data.data) && isArray(data.size)) {
	      // initialize fields from JSON representation
	      this._data = data.data;
	      this._size = data.size;
	      this._datatype = data.datatype;
	      this._min = typeof data.min !== 'undefined' ? data.min : null;
	      this._max = typeof data.max !== 'undefined' ? data.max : null;
	    } else if (data) {
	      // unsupported type
	      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');
	    } else {
	      // nothing provided
	      this._data = [];
	      this._size = [0];
	      this._datatype = datatype;
	      this._min = null;
	      this._max = null;
	    }
	  }

	  ImmutableDenseMatrix.prototype = new DenseMatrix();
	  /**
	   * Attach type information
	   */

	  ImmutableDenseMatrix.prototype.type = 'ImmutableDenseMatrix';
	  ImmutableDenseMatrix.prototype.isImmutableDenseMatrix = true;
	  /**
	   * Get a subset of the matrix, or replace a subset of the matrix.
	   *
	   * Usage:
	   *     const subset = matrix.subset(index)               // retrieve subset
	   *     const value = matrix.subset(index, replacement)   // replace subset
	   *
	   * @param {Index} index
	   * @param {Array | ImmutableDenseMatrix | *} [replacement]
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be filled with zeros.
	   */

	  ImmutableDenseMatrix.prototype.subset = function (index) {
	    switch (arguments.length) {
	      case 1:
	        {
	          // use base implementation
	          var m = DenseMatrix.prototype.subset.call(this, index); // check result is a matrix

	          if (isMatrix(m)) {
	            // return immutable matrix
	            return new ImmutableDenseMatrix({
	              data: m._data,
	              size: m._size,
	              datatype: m._datatype
	            });
	          }

	          return m;
	        }
	      // intentional fall through

	      case 2:
	      case 3:
	        throw new Error('Cannot invoke set subset on an Immutable Matrix instance');

	      default:
	        throw new SyntaxError('Wrong number of arguments');
	    }
	  };
	  /**
	   * Replace a single element in the matrix.
	   * @param {Number[]} index   Zero-based index
	   * @param {*} value
	   * @param {*} [defaultValue]        Default value, filled in on new entries when
	   *                                  the matrix is resized. If not provided,
	   *                                  new matrix elements will be left undefined.
	   * @return {ImmutableDenseMatrix} self
	   */


	  ImmutableDenseMatrix.prototype.set = function () {
	    throw new Error('Cannot invoke set on an Immutable Matrix instance');
	  };
	  /**
	   * Resize the matrix to the given size. Returns a copy of the matrix when
	   * `copy=true`, otherwise return the matrix itself (resize in place).
	   *
	   * @param {Number[]} size           The new size the matrix should have.
	   * @param {*} [defaultValue=0]      Default value, filled in on new entries.
	   *                                  If not provided, the matrix elements will
	   *                                  be filled with zeros.
	   * @param {boolean} [copy]          Return a resized copy of the matrix
	   *
	   * @return {Matrix}                 The resized matrix
	   */


	  ImmutableDenseMatrix.prototype.resize = function () {
	    throw new Error('Cannot invoke resize on an Immutable Matrix instance');
	  };
	  /**
	   * Disallows reshaping in favor of immutability.
	   *
	   * @throws {Error} Operation not allowed
	   */


	  ImmutableDenseMatrix.prototype.reshape = function () {
	    throw new Error('Cannot invoke reshape on an Immutable Matrix instance');
	  };
	  /**
	   * Create a clone of the matrix
	   * @return {ImmutableDenseMatrix} clone
	   */


	  ImmutableDenseMatrix.prototype.clone = function () {
	    return new ImmutableDenseMatrix({
	      data: clone(this._data),
	      size: clone(this._size),
	      datatype: this._datatype
	    });
	  };
	  /**
	   * Get a JSON representation of the matrix
	   * @returns {Object}
	   */


	  ImmutableDenseMatrix.prototype.toJSON = function () {
	    return {
	      mathjs: 'ImmutableDenseMatrix',
	      data: this._data,
	      size: this._size,
	      datatype: this._datatype
	    };
	  };
	  /**
	   * Generate a matrix from a JSON object
	   * @param {Object} json  An object structured like
	   *                       `{"mathjs": "ImmutableDenseMatrix", data: [], size: []}`,
	   *                       where mathjs is optional
	   * @returns {ImmutableDenseMatrix}
	   */


	  ImmutableDenseMatrix.fromJSON = function (json) {
	    return new ImmutableDenseMatrix(json);
	  };
	  /**
	   * Swap rows i and j in Matrix.
	   *
	   * @param {Number} i       Matrix row index 1
	   * @param {Number} j       Matrix row index 2
	   *
	   * @return {Matrix}        The matrix reference
	   */


	  ImmutableDenseMatrix.prototype.swapRows = function () {
	    throw new Error('Cannot invoke swapRows on an Immutable Matrix instance');
	  };
	  /**
	   * Calculate the minimum value in the set
	   * @return {Number | undefined} min
	   */


	  ImmutableDenseMatrix.prototype.min = function () {
	    // check min has been calculated before
	    if (this._min === null) {
	      // minimum
	      var m = null; // compute min

	      this.forEach(function (v) {
	        if (m === null || smaller(v, m)) {
	          m = v;
	        }
	      });
	      this._min = m !== null ? m : undefined;
	    }

	    return this._min;
	  };
	  /**
	   * Calculate the maximum value in the set
	   * @return {Number | undefined} max
	   */


	  ImmutableDenseMatrix.prototype.max = function () {
	    // check max has been calculated before
	    if (this._max === null) {
	      // maximum
	      var m = null; // compute max

	      this.forEach(function (v) {
	        if (m === null || smaller(m, v)) {
	          m = v;
	        }
	      });
	      this._max = m !== null ? m : undefined;
	    }

	    return this._max;
	  };

	  return ImmutableDenseMatrix;
	}, {
	  isClass: true
	});

	var name$b = 'Index';
	var dependencies$b = ['ImmutableDenseMatrix'];
	var createIndexClass = /* #__PURE__ */factory(name$b, dependencies$b, _ref => {
	  var {
	    ImmutableDenseMatrix
	  } = _ref;
	  /**
	   * Create an index. An Index can store ranges and sets for multiple dimensions.
	   * Matrix.get, Matrix.set, and math.subset accept an Index as input.
	   *
	   * Usage:
	   *     const index = new Index(range1, range2, matrix1, array1, ...)
	   *
	   * Where each parameter can be any of:
	   *     A number
	   *     A string (containing a name of an object property)
	   *     An instance of Range
	   *     An Array with the Set values
	   *     A Matrix with the Set values
	   *
	   * The parameters start, end, and step must be integer numbers.
	   *
	   * @class Index
	   * @Constructor Index
	   * @param {...*} ranges
	   */

	  function Index(ranges) {
	    if (!(this instanceof Index)) {
	      throw new SyntaxError('Constructor must be called with the new operator');
	    }

	    this._dimensions = [];
	    this._isScalar = true;

	    for (var i = 0, ii = arguments.length; i < ii; i++) {
	      var arg = arguments[i];

	      if (isRange(arg)) {
	        this._dimensions.push(arg);

	        this._isScalar = false;
	      } else if (Array.isArray(arg) || isMatrix(arg)) {
	        // create matrix
	        var m = _createImmutableMatrix(arg.valueOf());

	        this._dimensions.push(m); // size


	        var size = m.size(); // scalar

	        if (size.length !== 1 || size[0] !== 1) {
	          this._isScalar = false;
	        }
	      } else if (typeof arg === 'number') {
	        this._dimensions.push(_createImmutableMatrix([arg]));
	      } else if (typeof arg === 'string') {
	        // object property (arguments.count should be 1)
	        this._dimensions.push(arg);
	      } else {
	        throw new TypeError('Dimension must be an Array, Matrix, number, string, or Range');
	      } // TODO: implement support for wildcard '*'

	    }
	  }
	  /**
	   * Attach type information
	   */


	  Index.prototype.type = 'Index';
	  Index.prototype.isIndex = true;

	  function _createImmutableMatrix(arg) {
	    // loop array elements
	    for (var i = 0, l = arg.length; i < l; i++) {
	      if (typeof arg[i] !== 'number' || !isInteger(arg[i])) {
	        throw new TypeError('Index parameters must be positive integer numbers');
	      }
	    } // create matrix


	    return new ImmutableDenseMatrix(arg);
	  }
	  /**
	   * Create a clone of the index
	   * @memberof Index
	   * @return {Index} clone
	   */


	  Index.prototype.clone = function () {
	    var index = new Index();
	    index._dimensions = clone(this._dimensions);
	    index._isScalar = this._isScalar;
	    return index;
	  };
	  /**
	   * Create an index from an array with ranges/numbers
	   * @memberof Index
	   * @param {Array.<Array | number>} ranges
	   * @return {Index} index
	   * @private
	   */


	  Index.create = function (ranges) {
	    var index = new Index();
	    Index.apply(index, ranges);
	    return index;
	  };
	  /**
	   * Retrieve the size of the index, the number of elements for each dimension.
	   * @memberof Index
	   * @returns {number[]} size
	   */


	  Index.prototype.size = function () {
	    var size = [];

	    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
	      var d = this._dimensions[i];
	      size[i] = typeof d === 'string' ? 1 : d.size()[0];
	    }

	    return size;
	  };
	  /**
	   * Get the maximum value for each of the indexes ranges.
	   * @memberof Index
	   * @returns {number[]} max
	   */


	  Index.prototype.max = function () {
	    var values = [];

	    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
	      var range = this._dimensions[i];
	      values[i] = typeof range === 'string' ? range : range.max();
	    }

	    return values;
	  };
	  /**
	   * Get the minimum value for each of the indexes ranges.
	   * @memberof Index
	   * @returns {number[]} min
	   */


	  Index.prototype.min = function () {
	    var values = [];

	    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
	      var range = this._dimensions[i];
	      values[i] = typeof range === 'string' ? range : range.min();
	    }

	    return values;
	  };
	  /**
	   * Loop over each of the ranges of the index
	   * @memberof Index
	   * @param {Function} callback   Called for each range with a Range as first
	   *                              argument, the dimension as second, and the
	   *                              index object as third.
	   */


	  Index.prototype.forEach = function (callback) {
	    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
	      callback(this._dimensions[i], i, this);
	    }
	  };
	  /**
	   * Retrieve the dimension for the given index
	   * @memberof Index
	   * @param {Number} dim                  Number of the dimension
	   * @returns {Range | null} range
	   */


	  Index.prototype.dimension = function (dim) {
	    return this._dimensions[dim] || null;
	  };
	  /**
	   * Test whether this index contains an object property
	   * @returns {boolean} Returns true if the index is an object property
	   */


	  Index.prototype.isObjectProperty = function () {
	    return this._dimensions.length === 1 && typeof this._dimensions[0] === 'string';
	  };
	  /**
	   * Returns the object property name when the Index holds a single object property,
	   * else returns null
	   * @returns {string | null}
	   */


	  Index.prototype.getObjectProperty = function () {
	    return this.isObjectProperty() ? this._dimensions[0] : null;
	  };
	  /**
	   * Test whether this index contains only a single value.
	   *
	   * This is the case when the index is created with only scalar values as ranges,
	   * not for ranges resolving into a single value.
	   * @memberof Index
	   * @return {boolean} isScalar
	   */


	  Index.prototype.isScalar = function () {
	    return this._isScalar;
	  };
	  /**
	   * Expand the Index into an array.
	   * For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]
	   * @memberof Index
	   * @returns {Array} array
	   */


	  Index.prototype.toArray = function () {
	    var array = [];

	    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
	      var dimension = this._dimensions[i];
	      array.push(typeof dimension === 'string' ? dimension : dimension.toArray());
	    }

	    return array;
	  };
	  /**
	   * Get the primitive value of the Index, a two dimensional array.
	   * Equivalent to Index.toArray().
	   * @memberof Index
	   * @returns {Array} array
	   */


	  Index.prototype.valueOf = Index.prototype.toArray;
	  /**
	   * Get the string representation of the index, for example '[2:6]' or '[0:2:10, 4:7, [1,2,3]]'
	   * @memberof Index
	   * @returns {String} str
	   */

	  Index.prototype.toString = function () {
	    var strings = [];

	    for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
	      var dimension = this._dimensions[i];

	      if (typeof dimension === 'string') {
	        strings.push(JSON.stringify(dimension));
	      } else {
	        strings.push(dimension.toString());
	      }
	    }

	    return '[' + strings.join(', ') + ']';
	  };
	  /**
	   * Get a JSON representation of the Index
	   * @memberof Index
	   * @returns {Object} Returns a JSON object structured as:
	   *                   `{"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
	   */


	  Index.prototype.toJSON = function () {
	    return {
	      mathjs: 'Index',
	      dimensions: this._dimensions
	    };
	  };
	  /**
	   * Instantiate an Index from a JSON object
	   * @memberof Index
	   * @param {Object} json A JSON object structured as:
	   *                     `{"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}`
	   * @return {Index}
	   */


	  Index.fromJSON = function (json) {
	    return Index.create(json.dimensions);
	  };

	  return Index;
	}, {
	  isClass: true
	});

	var name$a = 'atan';
	var dependencies$a = ['typed'];
	var createAtan = /* #__PURE__ */factory(name$a, dependencies$a, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Calculate the inverse tangent of a value.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.atan(x)
	   *
	   * Examples:
	   *
	   *    math.atan(0.5)           // returns number 0.4636476090008061
	   *    math.atan(math.tan(1.5)) // returns number 1.5
	   *
	   *    math.atan(2)             // returns Complex 1.5707963267948966 -1.3169578969248166 i
	   *
	   * See also:
	   *
	   *    tan, asin, acos
	   *
	   * @param {number | BigNumber | Complex | Array | Matrix} x   Function input
	   * @return {number | BigNumber | Complex | Array | Matrix} The arc tangent of x
	   */

	  return typed('atan', {
	    number: function number(x) {
	      return Math.atan(x);
	    },
	    Complex: function Complex(x) {
	      return x.atan();
	    },
	    BigNumber: function BigNumber(x) {
	      return x.atan();
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      // deep map collection, skip zeros since atan(0) = 0
	      return deepMap(x, this);
	    }
	  });
	});

	var name$9 = 'cos';
	var dependencies$9 = ['typed'];
	var createCos = /* #__PURE__ */factory(name$9, dependencies$9, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Calculate the cosine of a value.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.cos(x)
	   *
	   * Examples:
	   *
	   *    math.cos(2)                      // returns number -0.4161468365471422
	   *    math.cos(math.pi / 4)            // returns number  0.7071067811865475
	   *    math.cos(math.unit(180, 'deg'))  // returns number -1
	   *    math.cos(math.unit(60, 'deg'))   // returns number  0.5
	   *
	   *    const angle = 0.2
	   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
	   *
	   * See also:
	   *
	   *    cos, tan
	   *
	   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
	   * @return {number | BigNumber | Complex | Array | Matrix} Cosine of x
	   */

	  return typed(name$9, {
	    number: Math.cos,
	    Complex: function Complex(x) {
	      return x.cos();
	    },
	    BigNumber: function BigNumber(x) {
	      return x.cos();
	    },
	    Unit: function Unit(x) {
	      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
	        throw new TypeError('Unit in function cos is no angle');
	      }

	      return this(x.value);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      return deepMap(x, this);
	    }
	  });
	});

	var name$8 = 'sin';
	var dependencies$8 = ['typed'];
	var createSin = /* #__PURE__ */factory(name$8, dependencies$8, _ref => {
	  var {
	    typed
	  } = _ref;
	  /**
	   * Calculate the sine of a value.
	   *
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.sin(x)
	   *
	   * Examples:
	   *
	   *    math.sin(2)                      // returns number 0.9092974268256813
	   *    math.sin(math.pi / 4)            // returns number 0.7071067811865475
	   *    math.sin(math.unit(90, 'deg'))   // returns number 1
	   *    math.sin(math.unit(30, 'deg'))   // returns number 0.5
	   *
	   *    const angle = 0.2
	   *    math.pow(math.sin(angle), 2) + math.pow(math.cos(angle), 2) // returns number ~1
	   *
	   * See also:
	   *
	   *    cos, tan
	   *
	   * @param {number | BigNumber | Complex | Unit | Array | Matrix} x  Function input
	   * @return {number | BigNumber | Complex | Array | Matrix} Sine of x
	   */

	  return typed(name$8, {
	    number: Math.sin,
	    Complex: function Complex(x) {
	      return x.sin();
	    },
	    BigNumber: function BigNumber(x) {
	      return x.sin();
	    },
	    Unit: function Unit(x) {
	      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
	        throw new TypeError('Unit in function sin is no angle');
	      }

	      return this(x.value);
	    },
	    'Array | Matrix': function ArrayMatrix(x) {
	      // deep map collection, skip zeros since sin(0) = 0
	      return deepMap(x, this);
	    }
	  });
	});

	var name$7 = 'add';
	var dependencies$7 = ['typed', 'matrix', 'addScalar', 'equalScalar', 'DenseMatrix', 'SparseMatrix'];
	var createAdd = /* #__PURE__ */factory(name$7, dependencies$7, _ref => {
	  var {
	    typed,
	    matrix,
	    addScalar,
	    equalScalar,
	    DenseMatrix,
	    SparseMatrix
	  } = _ref;
	  var algorithm01 = createAlgorithm01({
	    typed
	  });
	  var algorithm04 = createAlgorithm04({
	    typed,
	    equalScalar
	  });
	  var algorithm10 = createAlgorithm10({
	    typed,
	    DenseMatrix
	  });
	  var algorithm13 = createAlgorithm13({
	    typed
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Add two or more values, `x + y`.
	   * For matrices, the function is evaluated element wise.
	   *
	   * Syntax:
	   *
	   *    math.add(x, y)
	   *    math.add(x, y, z, ...)
	   *
	   * Examples:
	   *
	   *    math.add(2, 3)               // returns number 5
	   *    math.add(2, 3, 4)            // returns number 9
	   *
	   *    const a = math.complex(2, 3)
	   *    const b = math.complex(-4, 1)
	   *    math.add(a, b)               // returns Complex -2 + 4i
	   *
	   *    math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]
	   *
	   *    const c = math.unit('5 cm')
	   *    const d = math.unit('2.1 mm')
	   *    math.add(c, d)               // returns Unit 52.1 mm
	   *
	   *    math.add("2.3", "4")         // returns number 6.3
	   *
	   * See also:
	   *
	   *    subtract, sum
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to add
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to add
	   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Sum of `x` and `y`
	   */

	  return typed(name$7, extend({
	    // we extend the signatures of addScalar with signatures dealing with matrices
	    'DenseMatrix, DenseMatrix': function DenseMatrixDenseMatrix(x, y) {
	      return algorithm13(x, y, addScalar);
	    },
	    'DenseMatrix, SparseMatrix': function DenseMatrixSparseMatrix(x, y) {
	      return algorithm01(x, y, addScalar, false);
	    },
	    'SparseMatrix, DenseMatrix': function SparseMatrixDenseMatrix(x, y) {
	      return algorithm01(y, x, addScalar, true);
	    },
	    'SparseMatrix, SparseMatrix': function SparseMatrixSparseMatrix(x, y) {
	      return algorithm04(x, y, addScalar);
	    },
	    'Array, Array': function ArrayArray(x, y) {
	      // use matrix implementation
	      return this(matrix(x), matrix(y)).valueOf();
	    },
	    'Array, Matrix': function ArrayMatrix(x, y) {
	      // use matrix implementation
	      return this(matrix(x), y);
	    },
	    'Matrix, Array': function MatrixArray(x, y) {
	      // use matrix implementation
	      return this(x, matrix(y));
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, addScalar, false);
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm10(x, y, addScalar, false);
	    },
	    'any, DenseMatrix': function anyDenseMatrix(x, y) {
	      return algorithm14(y, x, addScalar, true);
	    },
	    'any, SparseMatrix': function anySparseMatrix(x, y) {
	      return algorithm10(y, x, addScalar, true);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, addScalar, false).valueOf();
	    },
	    'any, Array': function anyArray(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(y), x, addScalar, true).valueOf();
	    },
	    'any, any': addScalar,
	    'any, any, ...any': function anyAnyAny(x, y, rest) {
	      var result = this(x, y);

	      for (var i = 0; i < rest.length; i++) {
	        result = this(result, rest[i]);
	      }

	      return result;
	    }
	  }, addScalar.signatures));
	});

	var name$6 = 'norm';
	var dependencies$6 = ['typed', 'abs', 'add', 'pow', 'conj', 'sqrt', 'multiply', 'equalScalar', 'larger', 'smaller', 'matrix', 'ctranspose', 'eigs'];
	var createNorm = /* #__PURE__ */factory(name$6, dependencies$6, _ref => {
	  var {
	    typed,
	    abs,
	    add,
	    pow,
	    conj,
	    sqrt,
	    multiply,
	    equalScalar,
	    larger,
	    smaller,
	    matrix,
	    ctranspose,
	    eigs
	  } = _ref;
	  /**
	   * Calculate the norm of a number, vector or matrix.
	   *
	   * The second parameter p is optional. If not provided, it defaults to 2.
	   *
	   * Syntax:
	   *
	   *    math.norm(x)
	   *    math.norm(x, p)
	   *
	   * Examples:
	   *
	   *    math.abs(-3.5)                         // returns 3.5
	   *    math.norm(-3.5)                        // returns 3.5
	   *
	   *    math.norm(math.complex(3, -4))         // returns 5
	   *
	   *    math.norm([1, 2, -3], Infinity)        // returns 3
	   *    math.norm([1, 2, -3], -Infinity)       // returns 1
	   *
	   *    math.norm([3, 4], 2)                   // returns 5
	   *
	   *    math.norm([[1, 2], [3, 4]], 1)          // returns 6
	   *    math.norm([[1, 2], [3, 4]], 'inf')     // returns 7
	   *    math.norm([[1, 2], [3, 4]], 'fro')     // returns 5.477225575051661
	   *
	   * See also:
	   *
	   *    abs, hypot
	   *
	   * @param  {number | BigNumber | Complex | Array | Matrix} x
	   *            Value for which to calculate the norm
	   * @param  {number | BigNumber | string} [p=2]
	   *            Vector space.
	   *            Supported numbers include Infinity and -Infinity.
	   *            Supported strings are: 'inf', '-inf', and 'fro' (The Frobenius norm)
	   * @return {number | BigNumber} the p-norm
	   */

	  return typed(name$6, {
	    number: Math.abs,
	    Complex: function Complex(x) {
	      return x.abs();
	    },
	    BigNumber: function BigNumber(x) {
	      // norm(x) = abs(x)
	      return x.abs();
	    },
	    boolean: function boolean(x) {
	      // norm(x) = abs(x)
	      return Math.abs(x);
	    },
	    Array: function Array(x) {
	      return _norm(matrix(x), 2);
	    },
	    Matrix: function Matrix(x) {
	      return _norm(x, 2);
	    },
	    'number | Complex | BigNumber | boolean, number | BigNumber | string': function numberComplexBigNumberBooleanNumberBigNumberString(x) {
	      // ignore second parameter, TODO: remove the option of second parameter for these types
	      return this(x);
	    },
	    'Array, number | BigNumber | string': function ArrayNumberBigNumberString(x, p) {
	      return _norm(matrix(x), p);
	    },
	    'Matrix, number | BigNumber | string': function MatrixNumberBigNumberString(x, p) {
	      return _norm(x, p);
	    }
	  });
	  /**
	   * Calculate the plus infinity norm for a vector
	   * @param {Matrix} x
	   * @returns {number} Returns the norm
	   * @private
	   */

	  function _vectorNormPlusInfinity(x) {
	    // norm(x, Infinity) = max(abs(x))
	    var pinf = 0; // skip zeros since abs(0) === 0

	    x.forEach(function (value) {
	      var v = abs(value);

	      if (larger(v, pinf)) {
	        pinf = v;
	      }
	    }, true);
	    return pinf;
	  }
	  /**
	   * Calculate the minus infinity norm for a vector
	   * @param {Matrix} x
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _vectorNormMinusInfinity(x) {
	    // norm(x, -Infinity) = min(abs(x))
	    var ninf; // skip zeros since abs(0) === 0

	    x.forEach(function (value) {
	      var v = abs(value);

	      if (!ninf || smaller(v, ninf)) {
	        ninf = v;
	      }
	    }, true);
	    return ninf || 0;
	  }
	  /**
	   * Calculate the norm for a vector
	   * @param {Matrix} x
	   * @param {number | string} p
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _vectorNorm(x, p) {
	    // check p
	    if (p === Number.POSITIVE_INFINITY || p === 'inf') {
	      return _vectorNormPlusInfinity(x);
	    }

	    if (p === Number.NEGATIVE_INFINITY || p === '-inf') {
	      return _vectorNormMinusInfinity(x);
	    }

	    if (p === 'fro') {
	      return _norm(x, 2);
	    }

	    if (typeof p === 'number' && !isNaN(p)) {
	      // check p != 0
	      if (!equalScalar(p, 0)) {
	        // norm(x, p) = sum(abs(xi) ^ p) ^ 1/p
	        var n = 0; // skip zeros since abs(0) === 0

	        x.forEach(function (value) {
	          n = add(pow(abs(value), p), n);
	        }, true);
	        return pow(n, 1 / p);
	      }

	      return Number.POSITIVE_INFINITY;
	    } // invalid parameter value


	    throw new Error('Unsupported parameter value');
	  }
	  /**
	   * Calculate the Frobenius norm for a matrix
	   * @param {Matrix} x
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _matrixNormFrobenius(x) {
	    // norm(x) = sqrt(sum(diag(x'x)))
	    var fro = 0;
	    x.forEach(function (value, index) {
	      fro = add(fro, multiply(value, conj(value)));
	    });
	    return abs(sqrt(fro));
	  }
	  /**
	   * Calculate the norm L1 for a matrix
	   * @param {Matrix} x
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _matrixNormOne(x) {
	    // norm(x) = the largest column sum
	    var c = []; // result

	    var maxc = 0; // skip zeros since abs(0) == 0

	    x.forEach(function (value, index) {
	      var j = index[1];
	      var cj = add(c[j] || 0, abs(value));

	      if (larger(cj, maxc)) {
	        maxc = cj;
	      }

	      c[j] = cj;
	    }, true);
	    return maxc;
	  }
	  /**
	   * Calculate the norm L2 for a matrix
	   * @param {Matrix} x
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _matrixNormTwo(x) {
	    // norm(x) = sqrt( max eigenvalue of A*.A)
	    var sizeX = x.size();

	    if (sizeX[0] !== sizeX[1]) {
	      throw new RangeError('Invalid matrix dimensions');
	    }

	    var tx = ctranspose(x);
	    var squaredX = multiply(tx, x);
	    var eigenVals = eigs(squaredX).values.toArray();
	    var rho = eigenVals[eigenVals.length - 1];
	    return abs(sqrt(rho));
	  }
	  /**
	   * Calculate the infinity norm for a matrix
	   * @param {Matrix} x
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _matrixNormInfinity(x) {
	    // norm(x) = the largest row sum
	    var r = []; // result

	    var maxr = 0; // skip zeros since abs(0) == 0

	    x.forEach(function (value, index) {
	      var i = index[0];
	      var ri = add(r[i] || 0, abs(value));

	      if (larger(ri, maxr)) {
	        maxr = ri;
	      }

	      r[i] = ri;
	    }, true);
	    return maxr;
	  }
	  /**
	   * Calculate the norm for a 2D Matrix (M*N)
	   * @param {Matrix} x
	   * @param {number | string} p
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _matrixNorm(x, p) {
	    // check p
	    if (p === 1) {
	      return _matrixNormOne(x);
	    }

	    if (p === Number.POSITIVE_INFINITY || p === 'inf') {
	      return _matrixNormInfinity(x);
	    }

	    if (p === 'fro') {
	      return _matrixNormFrobenius(x);
	    }

	    if (p === 2) {
	      return _matrixNormTwo(x);
	    } // invalid parameter value


	    throw new Error('Unsupported parameter value ' + p);
	  }
	  /**
	   * Calculate the norm for an array
	   * @param {Matrix} x
	   * @param {number | string} p
	   * @returns {number} Returns the norm
	   * @private
	   */


	  function _norm(x, p) {
	    // size
	    var sizeX = x.size(); // check if it is a vector

	    if (sizeX.length === 1) {
	      return _vectorNorm(x, p);
	    } // MxN matrix


	    if (sizeX.length === 2) {
	      if (sizeX[0] && sizeX[1]) {
	        return _matrixNorm(x, p);
	      } else {
	        throw new RangeError('Invalid matrix dimensions');
	      }
	    }
	  }
	});

	var name$5 = 'dot';
	var dependencies$5 = ['typed', 'addScalar', 'multiplyScalar', 'conj', 'size'];
	var createDot = /* #__PURE__ */factory(name$5, dependencies$5, _ref => {
	  var {
	    typed,
	    addScalar,
	    multiplyScalar,
	    conj,
	    size
	  } = _ref;
	  /**
	   * Calculate the dot product of two vectors. The dot product of
	   * `A = [a1, a2, ..., an]` and `B = [b1, b2, ..., bn]` is defined as:
	   *
	   *    dot(A, B) = conj(a1) * b1 + conj(a2) * b2 + ... + conj(an) * bn
	   *
	   * Syntax:
	   *
	   *    math.dot(x, y)
	   *
	   * Examples:
	   *
	   *    math.dot([2, 4, 1], [2, 2, 3])       // returns number 15
	   *    math.multiply([2, 4, 1], [2, 2, 3])  // returns number 15
	   *
	   * See also:
	   *
	   *    multiply, cross
	   *
	   * @param  {Array | Matrix} x     First vector
	   * @param  {Array | Matrix} y     Second vector
	   * @return {number}               Returns the dot product of `x` and `y`
	   */

	  return typed(name$5, {
	    'Array | DenseMatrix, Array | DenseMatrix': _denseDot,
	    'SparseMatrix, SparseMatrix': _sparseDot
	  });

	  function _validateDim(x, y) {
	    var xSize = _size(x);

	    var ySize = _size(y);

	    var xLen, yLen;

	    if (xSize.length === 1) {
	      xLen = xSize[0];
	    } else if (xSize.length === 2 && xSize[1] === 1) {
	      xLen = xSize[0];
	    } else {
	      throw new RangeError('Expected a column vector, instead got a matrix of size (' + xSize.join(', ') + ')');
	    }

	    if (ySize.length === 1) {
	      yLen = ySize[0];
	    } else if (ySize.length === 2 && ySize[1] === 1) {
	      yLen = ySize[0];
	    } else {
	      throw new RangeError('Expected a column vector, instead got a matrix of size (' + ySize.join(', ') + ')');
	    }

	    if (xLen !== yLen) throw new RangeError('Vectors must have equal length (' + xLen + ' != ' + yLen + ')');
	    if (xLen === 0) throw new RangeError('Cannot calculate the dot product of empty vectors');
	    return xLen;
	  }

	  function _denseDot(a, b) {
	    var N = _validateDim(a, b);

	    var adata = isMatrix(a) ? a._data : a;
	    var adt = isMatrix(a) ? a._datatype : undefined;
	    var bdata = isMatrix(b) ? b._data : b;
	    var bdt = isMatrix(b) ? b._datatype : undefined; // are these 2-dimensional column vectors? (as opposed to 1-dimensional vectors)

	    var aIsColumn = _size(a).length === 2;
	    var bIsColumn = _size(b).length === 2;
	    var add = addScalar;
	    var mul = multiplyScalar; // process data types

	    if (adt && bdt && adt === bdt && typeof adt === 'string') {
	      var dt = adt; // find signatures that matches (dt, dt)

	      add = typed.find(addScalar, [dt, dt]);
	      mul = typed.find(multiplyScalar, [dt, dt]);
	    } // both vectors 1-dimensional


	    if (!aIsColumn && !bIsColumn) {
	      var c = mul(conj(adata[0]), bdata[0]);

	      for (var i = 1; i < N; i++) {
	        c = add(c, mul(conj(adata[i]), bdata[i]));
	      }

	      return c;
	    } // a is 1-dim, b is column


	    if (!aIsColumn && bIsColumn) {
	      var _c = mul(conj(adata[0]), bdata[0][0]);

	      for (var _i = 1; _i < N; _i++) {
	        _c = add(_c, mul(conj(adata[_i]), bdata[_i][0]));
	      }

	      return _c;
	    } // a is column, b is 1-dim


	    if (aIsColumn && !bIsColumn) {
	      var _c2 = mul(conj(adata[0][0]), bdata[0]);

	      for (var _i2 = 1; _i2 < N; _i2++) {
	        _c2 = add(_c2, mul(conj(adata[_i2][0]), bdata[_i2]));
	      }

	      return _c2;
	    } // both vectors are column


	    if (aIsColumn && bIsColumn) {
	      var _c3 = mul(conj(adata[0][0]), bdata[0][0]);

	      for (var _i3 = 1; _i3 < N; _i3++) {
	        _c3 = add(_c3, mul(conj(adata[_i3][0]), bdata[_i3][0]));
	      }

	      return _c3;
	    }
	  }

	  function _sparseDot(x, y) {
	    _validateDim(x, y);

	    var xindex = x._index;
	    var xvalues = x._values;
	    var yindex = y._index;
	    var yvalues = y._values; // TODO optimize add & mul using datatype

	    var c = 0;
	    var add = addScalar;
	    var mul = multiplyScalar;
	    var i = 0;
	    var j = 0;

	    while (i < xindex.length && j < yindex.length) {
	      var I = xindex[i];
	      var J = yindex[j];

	      if (I < J) {
	        i++;
	        continue;
	      }

	      if (I > J) {
	        j++;
	        continue;
	      }

	      if (I === J) {
	        c = add(c, mul(xvalues[i], yvalues[j]));
	        i++;
	        j++;
	      }
	    }

	    return c;
	  } // TODO remove this once #1771 is fixed


	  function _size(x) {
	    return isMatrix(x) ? x.size() : size(x);
	  }
	});

	var name$4 = 'qr';
	var dependencies$4 = ['typed', 'matrix', 'zeros', 'identity', 'isZero', 'equal', 'sign', 'sqrt', 'conj', 'unaryMinus', 'addScalar', 'divideScalar', 'multiplyScalar', 'subtract', 'complex'];
	var createQr = /* #__PURE__ */factory(name$4, dependencies$4, _ref => {
	  var {
	    typed,
	    matrix,
	    zeros,
	    identity,
	    isZero,
	    equal,
	    sign,
	    sqrt,
	    conj,
	    unaryMinus,
	    addScalar,
	    divideScalar,
	    multiplyScalar,
	    subtract,
	    complex
	  } = _ref;
	  /**
	   * Calculate the Matrix QR decomposition. Matrix `A` is decomposed in
	   * two matrices (`Q`, `R`) where `Q` is an
	   * orthogonal matrix and `R` is an upper triangular matrix.
	   *
	   * Syntax:
	   *
	   *    math.qr(A)
	   *
	   * Example:
	   *
	   *    const m = [
	   *      [1, -1,  4],
	   *      [1,  4, -2],
	   *      [1,  4,  2],
	   *      [1,  -1, 0]
	   *    ]
	   *    const result = math.qr(m)
	   *    // r = {
	   *    //   Q: [
	   *    //     [0.5, -0.5,   0.5],
	   *    //     [0.5,  0.5,  -0.5],
	   *    //     [0.5,  0.5,   0.5],
	   *    //     [0.5, -0.5,  -0.5],
	   *    //   ],
	   *    //   R: [
	   *    //     [2, 3,  2],
	   *    //     [0, 5, -2],
	   *    //     [0, 0,  4],
	   *    //     [0, 0,  0]
	   *    //   ]
	   *    // }
	   *
	   * See also:
	   *
	   *    lup, lusolve
	   *
	   * @param {Matrix | Array} A    A two dimensional matrix or array
	   * for which to get the QR decomposition.
	   *
	   * @return {{Q: Array | Matrix, R: Array | Matrix}} Q: the orthogonal
	   * matrix and R: the upper triangular matrix
	   */

	  return _extends(typed(name$4, {
	    DenseMatrix: function DenseMatrix(m) {
	      return _denseQR(m);
	    },
	    SparseMatrix: function SparseMatrix(m) {
	      return _sparseQR();
	    },
	    Array: function Array(a) {
	      // create dense matrix from array
	      var m = matrix(a); // lup, use matrix implementation

	      var r = _denseQR(m); // result


	      return {
	        Q: r.Q.valueOf(),
	        R: r.R.valueOf()
	      };
	    }
	  }), {
	    _denseQRimpl
	  });

	  function _denseQRimpl(m) {
	    // rows & columns (m x n)
	    var rows = m._size[0]; // m

	    var cols = m._size[1]; // n

	    var Q = identity([rows], 'dense');
	    var Qdata = Q._data;
	    var R = m.clone();
	    var Rdata = R._data; // vars

	    var i, j, k;
	    var w = zeros([rows], '');

	    for (k = 0; k < Math.min(cols, rows); ++k) {
	      /*
	       * **k-th Household matrix**
	       *
	       * The matrix I - 2*v*transpose(v)
	       * x     = first column of A
	       * x1    = first element of x
	       * alpha = x1 / |x1| * |x|
	       * e1    = tranpose([1, 0, 0, ...])
	       * u     = x - alpha * e1
	       * v     = u / |u|
	       *
	       * Household matrix = I - 2 * v * tranpose(v)
	       *
	       *  * Initially Q = I and R = A.
	       *  * Household matrix is a reflection in a plane normal to v which
	       *    will zero out all but the top right element in R.
	       *  * Appplying reflection to both Q and R will not change product.
	       *  * Repeat this process on the (1,1) minor to get R as an upper
	       *    triangular matrix.
	       *  * Reflections leave the magnitude of the columns of Q unchanged
	       *    so Q remains othoganal.
	       *
	       */
	      var pivot = Rdata[k][k];
	      var sgn = unaryMinus(equal(pivot, 0) ? 1 : sign(pivot));
	      var conjSgn = conj(sgn);
	      var alphaSquared = 0;

	      for (i = k; i < rows; i++) {
	        alphaSquared = addScalar(alphaSquared, multiplyScalar(Rdata[i][k], conj(Rdata[i][k])));
	      }

	      var alpha = multiplyScalar(sgn, sqrt(alphaSquared));

	      if (!isZero(alpha)) {
	        // first element in vector u
	        var u1 = subtract(pivot, alpha); // w = v * u1 / |u|    (only elements k to (rows-1) are used)

	        w[k] = 1;

	        for (i = k + 1; i < rows; i++) {
	          w[i] = divideScalar(Rdata[i][k], u1);
	        } // tau = - conj(u1 / alpha)


	        var tau = unaryMinus(conj(divideScalar(u1, alpha)));
	        var s = void 0;
	        /*
	         * tau and w have been choosen so that
	         *
	         * 2 * v * tranpose(v) = tau * w * tranpose(w)
	         */

	        /*
	         * -- calculate R = R - tau * w * tranpose(w) * R --
	         * Only do calculation with rows k to (rows-1)
	         * Additionally columns 0 to (k-1) will not be changed by this
	         *   multiplication so do not bother recalculating them
	         */

	        for (j = k; j < cols; j++) {
	          s = 0.0; // calculate jth element of [tranpose(w) * R]

	          for (i = k; i < rows; i++) {
	            s = addScalar(s, multiplyScalar(conj(w[i]), Rdata[i][j]));
	          } // calculate the jth element of [tau * transpose(w) * R]


	          s = multiplyScalar(s, tau);

	          for (i = k; i < rows; i++) {
	            Rdata[i][j] = multiplyScalar(subtract(Rdata[i][j], multiplyScalar(w[i], s)), conjSgn);
	          }
	        }
	        /*
	         * -- calculate Q = Q - tau * Q * w * transpose(w) --
	         * Q is a square matrix (rows x rows)
	         * Only do calculation with columns k to (rows-1)
	         * Additionally rows 0 to (k-1) will not be changed by this
	         *   multiplication so do not bother recalculating them
	         */


	        for (i = 0; i < rows; i++) {
	          s = 0.0; // calculate ith element of [Q * w]

	          for (j = k; j < rows; j++) {
	            s = addScalar(s, multiplyScalar(Qdata[i][j], w[j]));
	          } // calculate the ith element of [tau * Q * w]


	          s = multiplyScalar(s, tau);

	          for (j = k; j < rows; ++j) {
	            Qdata[i][j] = divideScalar(subtract(Qdata[i][j], multiplyScalar(s, conj(w[j]))), conjSgn);
	          }
	        }
	      }
	    } // return matrices


	    return {
	      Q: Q,
	      R: R,
	      toString: function toString() {
	        return 'Q: ' + this.Q.toString() + '\nR: ' + this.R.toString();
	      }
	    };
	  }

	  function _denseQR(m) {
	    var ret = _denseQRimpl(m);

	    var Rdata = ret.R._data;

	    if (m._data.length > 0) {
	      var zero = Rdata[0][0].type === 'Complex' ? complex(0) : 0;

	      for (var i = 0; i < Rdata.length; ++i) {
	        for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
	          Rdata[i][j] = zero;
	        }
	      }
	    }

	    return ret;
	  }

	  function _sparseQR(m) {
	    throw new Error('qr not implemented for sparse matrices yet');
	  }
	});

	var name$3 = 'det';
	var dependencies$3 = ['typed', 'matrix', 'subtract', 'multiply', 'divideScalar', 'isZero', 'unaryMinus'];
	var createDet = /* #__PURE__ */factory(name$3, dependencies$3, _ref => {
	  var {
	    typed,
	    matrix,
	    subtract,
	    multiply,
	    divideScalar,
	    isZero,
	    unaryMinus
	  } = _ref;
	  /**
	   * Calculate the determinant of a matrix.
	   *
	   * Syntax:
	   *
	   *    math.det(x)
	   *
	   * Examples:
	   *
	   *    math.det([[1, 2], [3, 4]]) // returns -2
	   *
	   *    const A = [
	   *      [-2, 2, 3],
	   *      [-1, 1, 3],
	   *      [2, 0, -1]
	   *    ]
	   *    math.det(A) // returns 6
	   *
	   * See also:
	   *
	   *    inv
	   *
	   * @param {Array | Matrix} x  A matrix
	   * @return {number} The determinant of `x`
	   */

	  return typed(name$3, {
	    any: function any(x) {
	      return clone(x);
	    },
	    'Array | Matrix': function det(x) {
	      var size;

	      if (isMatrix(x)) {
	        size = x.size();
	      } else if (Array.isArray(x)) {
	        x = matrix(x);
	        size = x.size();
	      } else {
	        // a scalar
	        size = [];
	      }

	      switch (size.length) {
	        case 0:
	          // scalar
	          return clone(x);

	        case 1:
	          // vector
	          if (size[0] === 1) {
	            return clone(x.valueOf()[0]);
	          } else {
	            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
	          }

	        case 2:
	          {
	            // two dimensional array
	            var rows = size[0];
	            var cols = size[1];

	            if (rows === cols) {
	              return _det(x.clone().valueOf(), rows);
	            } else {
	              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
	            }
	          }

	        default:
	          // multi dimensional array
	          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');
	      }
	    }
	  });
	  /**
	   * Calculate the determinant of a matrix
	   * @param {Array[]} matrix  A square, two dimensional matrix
	   * @param {number} rows     Number of rows of the matrix (zero-based)
	   * @param {number} cols     Number of columns of the matrix (zero-based)
	   * @returns {number} det
	   * @private
	   */

	  function _det(matrix, rows, cols) {
	    if (rows === 1) {
	      // this is a 1 x 1 matrix
	      return clone(matrix[0][0]);
	    } else if (rows === 2) {
	      // this is a 2 x 2 matrix
	      // the determinant of [a11,a12;a21,a22] is det = a11*a22-a21*a12
	      return subtract(multiply(matrix[0][0], matrix[1][1]), multiply(matrix[1][0], matrix[0][1]));
	    } else {
	      // Bareiss algorithm
	      // this algorithm have same complexity as LUP decomposition (O(n^3))
	      // but it preserve precision of floating point more relative to the LUP decomposition
	      var negated = false;
	      var rowIndices = new Array(rows).fill(0).map((_, i) => i); // matrix index of row i

	      for (var k = 0; k < rows; k++) {
	        var k_ = rowIndices[k];

	        if (isZero(matrix[k_][k])) {
	          var _k = void 0;

	          for (_k = k + 1; _k < rows; _k++) {
	            if (!isZero(matrix[rowIndices[_k]][k])) {
	              k_ = rowIndices[_k];
	              rowIndices[_k] = rowIndices[k];
	              rowIndices[k] = k_;
	              negated = !negated;
	              break;
	            }
	          }

	          if (_k === rows) return matrix[k_][k]; // some zero of the type
	        }

	        var piv = matrix[k_][k];
	        var piv_ = k === 0 ? 1 : matrix[rowIndices[k - 1]][k - 1];

	        for (var i = k + 1; i < rows; i++) {
	          var i_ = rowIndices[i];

	          for (var j = k + 1; j < rows; j++) {
	            matrix[i_][j] = divideScalar(subtract(multiply(matrix[i_][j], piv), multiply(matrix[i_][k], matrix[k_][j])), piv_);
	          }
	        }
	      }

	      var det = matrix[rowIndices[rows - 1]][rows - 1];
	      return negated ? unaryMinus(det) : det;
	    }
	  }
	});

	var name$2 = 'inv';
	var dependencies$2 = ['typed', 'matrix', 'divideScalar', 'addScalar', 'multiply', 'unaryMinus', 'det', 'identity', 'abs'];
	var createInv = /* #__PURE__ */factory(name$2, dependencies$2, _ref => {
	  var {
	    typed,
	    matrix,
	    divideScalar,
	    addScalar,
	    multiply,
	    unaryMinus,
	    det,
	    identity,
	    abs
	  } = _ref;
	  /**
	   * Calculate the inverse of a square matrix.
	   *
	   * Syntax:
	   *
	   *     math.inv(x)
	   *
	   * Examples:
	   *
	   *     math.inv([[1, 2], [3, 4]])  // returns [[-2, 1], [1.5, -0.5]]
	   *     math.inv(4)                 // returns 0.25
	   *     1 / 4                       // returns 0.25
	   *
	   * See also:
	   *
	   *     det, transpose
	   *
	   * @param {number | Complex | Array | Matrix} x     Matrix to be inversed
	   * @return {number | Complex | Array | Matrix} The inverse of `x`.
	   */

	  return typed(name$2, {
	    'Array | Matrix': function ArrayMatrix(x) {
	      var size = isMatrix(x) ? x.size() : arraySize(x);

	      switch (size.length) {
	        case 1:
	          // vector
	          if (size[0] === 1) {
	            if (isMatrix(x)) {
	              return matrix([divideScalar(1, x.valueOf()[0])]);
	            } else {
	              return [divideScalar(1, x[0])];
	            }
	          } else {
	            throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
	          }

	        case 2:
	          // two dimensional array
	          {
	            var rows = size[0];
	            var cols = size[1];

	            if (rows === cols) {
	              if (isMatrix(x)) {
	                return matrix(_inv(x.valueOf(), rows, cols), x.storage());
	              } else {
	                // return an Array
	                return _inv(x, rows, cols);
	              }
	            } else {
	              throw new RangeError('Matrix must be square ' + '(size: ' + format(size) + ')');
	            }
	          }

	        default:
	          // multi dimensional array
	          throw new RangeError('Matrix must be two dimensional ' + '(size: ' + format(size) + ')');
	      }
	    },
	    any: function any(x) {
	      // scalar
	      return divideScalar(1, x); // FIXME: create a BigNumber one when configured for bignumbers
	    }
	  });
	  /**
	   * Calculate the inverse of a square matrix
	   * @param {Array[]} mat     A square matrix
	   * @param {number} rows     Number of rows
	   * @param {number} cols     Number of columns, must equal rows
	   * @return {Array[]} inv    Inverse matrix
	   * @private
	   */

	  function _inv(mat, rows, cols) {
	    var r, s, f, value, temp;

	    if (rows === 1) {
	      // this is a 1 x 1 matrix
	      value = mat[0][0];

	      if (value === 0) {
	        throw Error('Cannot calculate inverse, determinant is zero');
	      }

	      return [[divideScalar(1, value)]];
	    } else if (rows === 2) {
	      // this is a 2 x 2 matrix
	      var d = det(mat);

	      if (d === 0) {
	        throw Error('Cannot calculate inverse, determinant is zero');
	      }

	      return [[divideScalar(mat[1][1], d), divideScalar(unaryMinus(mat[0][1]), d)], [divideScalar(unaryMinus(mat[1][0]), d), divideScalar(mat[0][0], d)]];
	    } else {
	      // this is a matrix of 3 x 3 or larger
	      // calculate inverse using gauss-jordan elimination
	      //      https://en.wikipedia.org/wiki/Gaussian_elimination
	      //      http://mathworld.wolfram.com/MatrixInverse.html
	      //      http://math.uww.edu/~mcfarlat/inverse.htm
	      // make a copy of the matrix (only the arrays, not of the elements)
	      var A = mat.concat();

	      for (r = 0; r < rows; r++) {
	        A[r] = A[r].concat();
	      } // create an identity matrix which in the end will contain the
	      // matrix inverse


	      var B = identity(rows).valueOf(); // loop over all columns, and perform row reductions

	      for (var c = 0; c < cols; c++) {
	        // Pivoting: Swap row c with row r, where row r contains the largest element A[r][c]
	        var ABig = abs(A[c][c]);
	        var rBig = c;
	        r = c + 1;

	        while (r < rows) {
	          if (abs(A[r][c]) > ABig) {
	            ABig = abs(A[r][c]);
	            rBig = r;
	          }

	          r++;
	        }

	        if (ABig === 0) {
	          throw Error('Cannot calculate inverse, determinant is zero');
	        }

	        r = rBig;

	        if (r !== c) {
	          temp = A[c];
	          A[c] = A[r];
	          A[r] = temp;
	          temp = B[c];
	          B[c] = B[r];
	          B[r] = temp;
	        } // eliminate non-zero values on the other rows at column c


	        var Ac = A[c];
	        var Bc = B[c];

	        for (r = 0; r < rows; r++) {
	          var Ar = A[r];
	          var Br = B[r];

	          if (r !== c) {
	            // eliminate value at column c and row r
	            if (Ar[c] !== 0) {
	              f = divideScalar(unaryMinus(Ar[c]), Ac[c]); // add (f * row c) to row r to eliminate the value
	              // at column c

	              for (s = c; s < cols; s++) {
	                Ar[s] = addScalar(Ar[s], multiply(f, Ac[s]));
	              }

	              for (s = 0; s < cols; s++) {
	                Br[s] = addScalar(Br[s], multiply(f, Bc[s]));
	              }
	            }
	          } else {
	            // normalize value at Acc to 1,
	            // divide each value on row r with the value at Acc
	            f = Ac[c];

	            for (s = c; s < cols; s++) {
	              Ar[s] = divideScalar(Ar[s], f);
	            }

	            for (s = 0; s < cols; s++) {
	              Br[s] = divideScalar(Br[s], f);
	            }
	          }
	        }
	      }

	      return B;
	    }
	  }
	});

	function createComplexEigs(_ref) {
	  var {
	    addScalar,
	    subtract,
	    flatten,
	    multiply,
	    multiplyScalar,
	    divideScalar,
	    sqrt,
	    abs,
	    bignumber,
	    diag,
	    inv,
	    qr,
	    usolve,
	    usolveAll,
	    equal,
	    complex,
	    larger,
	    smaller,
	    matrixFromColumns,
	    dot
	  } = _ref;
	  /**
	   * @param {number[][]} arr the matrix to find eigenvalues of
	   * @param {number} N size of the matrix
	   * @param {number|BigNumber} prec precision, anything lower will be considered zero
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @param {boolean} findVectors should we find eigenvectors?
	   *
	   * @returns {{ values: number[], vectors: number[][] }}
	   */

	  function complexEigs(arr, N, prec, type, findVectors) {
	    if (findVectors === undefined) {
	      findVectors = true;
	    } // TODO check if any row/col are zero except the diagonal
	    // make sure corresponding rows and columns have similar magnitude
	    // important because of numerical stability
	    // MODIFIES arr by side effect!


	    var R = balance(arr, N, prec, type, findVectors); // R is the row transformation matrix
	    // arr = A' = R A R, A is the original matrix
	    // (if findVectors is false, R is undefined)
	    // (And so to return to original matrix: A = R arr R)
	    // TODO if magnitudes of elements vary over many orders,
	    // move greatest elements to the top left corner
	    // using similarity transformations, reduce the matrix
	    // to Hessenberg form (upper triangular plus one subdiagonal row)
	    // updates the transformation matrix R with new row operationsq
	    // MODIFIES arr by side effect!

	    reduceToHessenberg(arr, N, prec, type, findVectors, R); // still true that original A = R arr R)
	    // find eigenvalues

	    var {
	      values,
	      C
	    } = iterateUntilTriangular(arr, N, prec, type, findVectors); // values is the list of eigenvalues, C is the column
	    // transformation matrix that transforms arr, the hessenberg
	    // matrix, to upper triangular
	    // (So U = C arr C and the relationship between current arr
	    // and original A is unchanged.)

	    var vectors;

	    if (findVectors) {
	      vectors = findEigenvectors(arr, N, C, R, values, prec, type);
	      vectors = matrixFromColumns(...vectors);
	    }

	    return {
	      values,
	      vectors
	    };
	  }
	  /**
	   * @param {number[][]} arr
	   * @param {number} N
	   * @param {number} prec
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @returns {number[][]}
	   */


	  function balance(arr, N, prec, type, findVectors) {
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex';
	    var realzero = big ? bignumber(0) : 0;
	    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
	    var realone = big ? bignumber(1) : 1; // base of the floating-point arithmetic

	    var radix = big ? bignumber(10) : 2;
	    var radixSq = multiplyScalar(radix, radix); // the diagonal transformation matrix R

	    var Rdiag;

	    if (findVectors) {
	      Rdiag = Array(N).fill(one);
	    } // this isn't the only time we loop thru the matrix...


	    var last = false;

	    while (!last) {
	      // ...haha I'm joking! unless...
	      last = true;

	      for (var i = 0; i < N; i++) {
	        // compute the taxicab norm of i-th column and row
	        // TODO optimize for complex numbers
	        var colNorm = realzero;
	        var rowNorm = realzero;

	        for (var j = 0; j < N; j++) {
	          if (i === j) continue;
	          var c = abs(arr[i][j]); // should be real

	          colNorm = addScalar(colNorm, c);
	          rowNorm = addScalar(rowNorm, c);
	        }

	        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {
	          // find integer power closest to balancing the matrix
	          // (we want to scale only by integer powers of radix,
	          // so that we don't lose any precision due to round-off)
	          var f = realone;
	          var _c = colNorm;
	          var rowDivRadix = divideScalar(rowNorm, radix);
	          var rowMulRadix = multiplyScalar(rowNorm, radix);

	          while (smaller(_c, rowDivRadix)) {
	            _c = multiplyScalar(_c, radixSq);
	            f = multiplyScalar(f, radix);
	          }

	          while (larger(_c, rowMulRadix)) {
	            _c = divideScalar(_c, radixSq);
	            f = divideScalar(f, radix);
	          } // check whether balancing is needed
	          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)


	          var condition = smaller(divideScalar(addScalar(_c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95)); // apply balancing similarity transformation

	          if (condition) {
	            // we should loop once again to check whether
	            // another rebalancing is needed
	            last = false;
	            var g = divideScalar(1, f);

	            for (var _j = 0; _j < N; _j++) {
	              if (i === _j) {
	                continue;
	              }

	              arr[i][_j] = multiplyScalar(arr[i][_j], f);
	              arr[_j][i] = multiplyScalar(arr[_j][i], g);
	            } // keep track of transformations


	            if (findVectors) {
	              Rdiag[i] = multiplyScalar(Rdiag[i], f);
	            }
	          }
	        }
	      }
	    } // return the diagonal row transformation matrix


	    return diag(Rdiag);
	  }
	  /**
	   * @param {number[][]} arr
	   * @param {number} N
	   * @param {number} prec
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @param {boolean} findVectors
	   * @param {number[][]} R the row transformation matrix that will be modified
	   */


	  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex';
	    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;

	    if (big) {
	      prec = bignumber(prec);
	    }

	    for (var i = 0; i < N - 2; i++) {
	      // Find the largest subdiag element in the i-th col
	      var maxIndex = 0;
	      var max = zero;

	      for (var j = i + 1; j < N; j++) {
	        var el = arr[j][i];

	        if (smaller(abs(max), abs(el))) {
	          max = el;
	          maxIndex = j;
	        }
	      } // This col is pivoted, no need to do anything


	      if (smaller(abs(max), prec)) {
	        continue;
	      }

	      if (maxIndex !== i + 1) {
	        // Interchange maxIndex-th and (i+1)-th row
	        var tmp1 = arr[maxIndex];
	        arr[maxIndex] = arr[i + 1];
	        arr[i + 1] = tmp1; // Interchange maxIndex-th and (i+1)-th column

	        for (var _j2 = 0; _j2 < N; _j2++) {
	          var tmp2 = arr[_j2][maxIndex];
	          arr[_j2][maxIndex] = arr[_j2][i + 1];
	          arr[_j2][i + 1] = tmp2;
	        } // keep track of transformations


	        if (findVectors) {
	          var tmp3 = R[maxIndex];
	          R[maxIndex] = R[i + 1];
	          R[i + 1] = tmp3;
	        }
	      } // Reduce following rows and columns


	      for (var _j3 = i + 2; _j3 < N; _j3++) {
	        var n = divideScalar(arr[_j3][i], max);

	        if (n === 0) {
	          continue;
	        } // from j-th row subtract n-times (i+1)th row


	        for (var k = 0; k < N; k++) {
	          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));
	        } // to (i+1)th column add n-times j-th column


	        for (var _k = 0; _k < N; _k++) {
	          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));
	        } // keep track of transformations


	        if (findVectors) {
	          for (var _k2 = 0; _k2 < N; _k2++) {
	            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));
	          }
	        }
	      }
	    }

	    return R;
	  }
	  /**
	   * @returns {{values: values, C: Matrix}}
	   * @see Press, Wiliams: Numerical recipes in Fortran 77
	   * @see https://en.wikipedia.org/wiki/QR_algorithm
	   */


	  function iterateUntilTriangular(A, N, prec, type, findVectors) {
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex';
	    var one = big ? bignumber(1) : cplx ? complex(1) : 1;

	    if (big) {
	      prec = bignumber(prec);
	    } // The Francis Algorithm
	    // The core idea of this algorithm is that doing successive
	    // A' = QAQ transformations will eventually converge to block-
	    // upper-triangular with diagonal blocks either 1x1 or 2x2.
	    // The Q here is the one from the QR decomposition, A = QR.
	    // Since the eigenvalues of a block-upper-triangular matrix are
	    // the eigenvalues of its diagonal blocks and we know how to find
	    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.


	    var arr = clone(A); // the list of converged eigenvalues

	    var lambdas = []; // size of arr, which will get smaller as eigenvalues converge

	    var n = N; // the diagonal of the block-diagonal matrix that turns
	    // converged 2x2 matrices into upper triangular matrices

	    var Sdiag = []; // NN matrix describing the overall transformation done during the QR algorithm

	    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined; // nn matrix describing the QR transformations done since last convergence

	    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined; // last eigenvalue converged before this many steps

	    var lastConvergenceBefore = 0;

	    while (lastConvergenceBefore <= 100) {
	      lastConvergenceBefore += 1; // TODO if the convergence is slow, do something clever
	      // Perform the factorization

	      var k = 0; // TODO set close to an eigenvalue

	      for (var i = 0; i < n; i++) {
	        arr[i][i] = subtract(arr[i][i], k);
	      } // TODO do an implicit QR transformation


	      var {
	        Q,
	        R
	      } = qr(arr);
	      arr = multiply(R, Q);

	      for (var _i = 0; _i < n; _i++) {
	        arr[_i][_i] = addScalar(arr[_i][_i], k);
	      } // keep track of transformations


	      if (findVectors) {
	        Qpartial = multiply(Qpartial, Q);
	      } // The rightmost diagonal element converged to an eigenvalue


	      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {
	        lastConvergenceBefore = 0;
	        lambdas.push(arr[n - 1][n - 1]); // keep track of transformations

	        if (findVectors) {
	          Sdiag.unshift([[1]]);
	          inflateMatrix(Qpartial, N);
	          Qtotal = multiply(Qtotal, Qpartial);

	          if (n > 1) {
	            Qpartial = diag(Array(n - 1).fill(one));
	          }
	        } // reduce the matrix size


	        n -= 1;
	        arr.pop();

	        for (var _i2 = 0; _i2 < n; _i2++) {
	          arr[_i2].pop();
	        } // The rightmost diagonal 2x2 block converged

	      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {
	        lastConvergenceBefore = 0;
	        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
	        lambdas.push(...ll); // keep track of transformations

	        if (findVectors) {
	          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
	          inflateMatrix(Qpartial, N);
	          Qtotal = multiply(Qtotal, Qpartial);

	          if (n > 2) {
	            Qpartial = diag(Array(n - 2).fill(one));
	          }
	        } // reduce the matrix size


	        n -= 2;
	        arr.pop();
	        arr.pop();

	        for (var _i3 = 0; _i3 < n; _i3++) {
	          arr[_i3].pop();

	          arr[_i3].pop();
	        }
	      }

	      if (n === 0) {
	        break;
	      }
	    } // standard sorting


	    lambdas.sort((a, b) => +subtract(abs(a), abs(b))); // the algorithm didn't converge

	    if (lastConvergenceBefore > 100) {
	      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));
	      err.values = lambdas;
	      err.vectors = [];
	      throw err;
	    } // combine the overall QR transformation Qtotal with the subsequent
	    // transformation S that turns the diagonal 2x2 blocks to upper triangular


	    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;
	    return {
	      values: lambdas,
	      C
	    };
	  }
	  /**
	   * @param {Matrix} A hessenberg-form matrix
	   * @param {number} N size of A
	   * @param {Matrix} C column transformation matrix that turns A into upper triangular
	   * @param {Matrix} R similarity that turns original matrix into A
	   * @param {number[]} values array of eigenvalues of A
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @returns {number[][]} eigenvalues
	   */


	  function findEigenvectors(A, N, C, R, values, prec, type) {
	    var Cinv = inv(C);
	    var U = multiply(Cinv, A, C);
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex';
	    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
	    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // turn values into a kind of "multiset"
	    // this way it is easier to find eigenvectors

	    var uniqueValues = [];
	    var multiplicities = [];

	    for (var  of values) {
	      var i = indexOf(uniqueValues, , equal);

	      if (i === -1) {
	        uniqueValues.push();
	        multiplicities.push(1);
	      } else {
	        multiplicities[i] += 1;
	      }
	    } // find eigenvectors by solving U  E = 0
	    // TODO replace with an iterative eigenvector algorithm
	    // (this one might fail for imprecise eigenvalues)


	    var vectors = [];
	    var len = uniqueValues.length;
	    var b = Array(N).fill(zero);
	    var E = diag(Array(N).fill(one)); // eigenvalues for which usolve failed (due to numerical error)

	    var failedLambdas = [];

	    var _loop = function _loop(_i4) {
	      var  = uniqueValues[_i4];
	      var S = subtract(U, multiply(, E)); // the characteristic matrix

	      var solutions = usolveAll(S, b);
	      solutions.shift(); // ignore the null vector
	      // looks like we missed something, try inverse iteration

	      while (solutions.length < multiplicities[_i4]) {
	        var approxVec = inverseIterate(S, N, solutions, prec, type);

	        if (approxVec == null) {
	          // no more vectors were found
	          failedLambdas.push();
	          break;
	        }

	        solutions.push(approxVec);
	      } // Transform back into original array coordinates


	      var correction = multiply(inv(R), C);
	      solutions = solutions.map(v => multiply(correction, v));
	      vectors.push(...solutions.map(v => flatten(v)));
	    };

	    for (var _i4 = 0; _i4 < len; _i4++) {
	      _loop(_i4);
	    }

	    if (failedLambdas.length !== 0) {
	      var err = new Error('Failed to find eigenvectors for the following eigenvalues: ' + failedLambdas.join(', '));
	      err.values = values;
	      err.vectors = vectors;
	      throw err;
	    }

	    return vectors;
	  }
	  /**
	   * Compute the eigenvalues of an 2x2 matrix
	   * @return {[number,number]}
	   */


	  function eigenvalues2x2(a, b, c, d) {
	    //  =  trA   ( trA - 4 detA )
	    var trA = addScalar(a, d);
	    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));
	    var x = multiplyScalar(trA, 0.5);
	    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);
	    return [addScalar(x, y), subtract(x, y)];
	  }
	  /**
	   * For an 2x2 matrix compute the transformation matrix S,
	   * so that SAS is an upper triangular matrix
	   * @return {[[number,number],[number,number]]}
	   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf
	   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html
	   */


	  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex';
	    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;
	    var one = big ? bignumber(1) : cplx ? complex(1) : 1; // matrix is already upper triangular
	    // return an identity matrix

	    if (smaller(abs(c), prec)) {
	      return [[one, zero], [zero, one]];
	    } // matrix is diagonalizable
	    // return its eigenvectors as columns


	    if (larger(abs(subtract(l1, l2)), prec)) {
	      return [[subtract(l1, d), subtract(l2, d)], [c, c]];
	    } // matrix is not diagonalizable
	    // compute off-diagonal elements of N = A - I
	    // N = 0  S = ( N, I )
	    // N  0  S = ( N, I )


	    var na = subtract(a, l1);
	    var nb = subtract(b, l1);
	    var nc = subtract(c, l1);
	    var nd = subtract(d, l1);

	    if (smaller(abs(nb), prec)) {
	      return [[na, one], [nc, zero]];
	    } else {
	      return [[nb, zero], [nd, one]];
	    }
	  }
	  /**
	   * Enlarge the matrix from nn to NN, setting the new
	   * elements to 1 on diagonal and 0 elsewhere
	   */


	  function inflateMatrix(arr, N) {
	    // add columns
	    for (var i = 0; i < arr.length; i++) {
	      arr[i].push(...Array(N - arr[i].length).fill(0));
	    } // add rows


	    for (var _i5 = arr.length; _i5 < N; _i5++) {
	      arr.push(Array(N).fill(0));
	      arr[_i5][_i5] = 1;
	    }

	    return arr;
	  }
	  /**
	   * Create a block-diagonal matrix with the given square matrices on the diagonal
	   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal
	   * @param {number} N the size of the resulting matrix
	   */


	  function blockDiag(arr, N) {
	    var M = [];

	    for (var i = 0; i < N; i++) {
	      M[i] = Array(N).fill(0);
	    }

	    var I = 0;

	    for (var sub of arr) {
	      var n = sub.length;

	      for (var _i6 = 0; _i6 < n; _i6++) {
	        for (var j = 0; j < n; j++) {
	          M[I + _i6][I + j] = sub[_i6][j];
	        }
	      }

	      I += n;
	    }

	    return M;
	  }
	  /**
	   * Finds the index of an element in an array using a custom equality function
	   * @template T
	   * @param {Array<T>} arr array in which to search
	   * @param {T} el the element to find
	   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`
	   * @returns {number} the index of `el`, or -1 when it's not in `arr`
	   */


	  function indexOf(arr, el, fn) {
	    for (var i = 0; i < arr.length; i++) {
	      if (fn(arr[i], el)) {
	        return i;
	      }
	    }

	    return -1;
	  }
	  /**
	   * Provided a near-singular upper-triangular matrix A and a list of vectors,
	   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal
	   * to each vector in the list
	   * @template T
	   * @param {T[][]} A near-singular square matrix
	   * @param {number} N dimension
	   * @param {T[][]} orthog list of vectors
	   * @param {number} prec epsilon
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @return {T[] | null} eigenvector
	   *
	   * @see Numerical Recipes for Fortran 77  11.7 Eigenvalues or Eigenvectors by Inverse Iteration
	   */


	  function inverseIterate(A, N, orthog, prec, type) {
	    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;
	    var b; // the vector
	    // you better choose a random vector before I count to five

	    var i = 0;

	    while (true) {
	      b = randomOrthogonalVector(N, orthog, type);
	      b = usolve(A, b);

	      if (larger(norm(b), largeNum)) {
	        break;
	      }

	      if (++i >= 5) {
	        return null;
	      }
	    } // you better converge before I count to ten


	    i = 0;

	    while (true) {
	      var c = usolve(A, b);

	      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {
	        break;
	      }

	      if (++i >= 10) {
	        return null;
	      }

	      b = normalize(c);
	    }

	    return b;
	  }
	  /**
	   * Generates a random unit vector of dimension N, orthogonal to each vector in the list
	   * @template T
	   * @param {number} N dimension
	   * @param {T[][]} orthog list of vectors
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @returns {T[]} random vector
	   */


	  function randomOrthogonalVector(N, orthog, type) {
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex'; // generate random vector with the correct type

	    var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);

	    if (big) {
	      v = v.map(n => bignumber(n));
	    }

	    if (cplx) {
	      v = v.map(n => complex(n));
	    } // project to orthogonal complement


	    v = orthogonalComplement(v, orthog); // normalize

	    return normalize(v, type);
	  }
	  /**
	   * Project vector v to the orthogonal complement of an array of vectors
	   */


	  function orthogonalComplement(v, orthog) {
	    for (var w of orthog) {
	      // v := v  (w, v)/w w
	      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));
	    }

	    return v;
	  }
	  /**
	   * Calculate the norm of a vector.
	   * We can't use math.norm because factory can't handle circular dependency.
	   * Seriously, I'm really fed up with factory.
	   */


	  function norm(v) {
	    return abs(sqrt(dot(v, v)));
	  }
	  /**
	   * Normalize a vector
	   * @template T
	   * @param {T[]} v
	   * @param {'number'|'BigNumber'|'Complex'} type
	   * @returns {T[]} normalized vec
	   */


	  function normalize(v, type) {
	    var big = type === 'BigNumber';
	    var cplx = type === 'Complex';
	    var one = big ? bignumber(1) : cplx ? complex(1) : 1;
	    return multiply(divideScalar(one, norm(v)), v);
	  }

	  return complexEigs;
	}

	function createRealSymmetric(_ref) {
	  var {
	    config,
	    addScalar,
	    subtract,
	    abs,
	    atan,
	    cos,
	    sin,
	    multiplyScalar,
	    inv,
	    bignumber,
	    multiply,
	    add
	  } = _ref;
	  /**
	   * @param {number[] | BigNumber[]} arr
	   * @param {number} N
	   * @param {number} prec
	   * @param {'number' | 'BigNumber'} type
	   */

	  function main(arr, N) {
	    var prec = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : config.epsilon;
	    var type = arguments.length > 3 ? arguments[3] : undefined;

	    if (type === 'number') {
	      return diag(arr, prec);
	    }

	    if (type === 'BigNumber') {
	      return diagBig(arr, prec);
	    }

	    throw TypeError('Unsupported data type: ' + type);
	  } // diagonalization implementation for number (efficient)


	  function diag(x, precision) {
	    var N = x.length;
	    var e0 = Math.abs(precision / N);
	    var psi;
	    var Sij = new Array(N); // Sij is Identity Matrix

	    for (var i = 0; i < N; i++) {
	      Sij[i] = createArray(N, 0);
	      Sij[i][i] = 1.0;
	    } // initial error


	    var Vab = getAij(x);

	    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
	      var _i = Vab[0][0];
	      var j = Vab[0][1];
	      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
	      x = x1(x, psi, _i, j);
	      Sij = Sij1(Sij, psi, _i, j);
	      Vab = getAij(x);
	    }

	    var Ei = createArray(N, 0); // eigenvalues

	    for (var _i2 = 0; _i2 < N; _i2++) {
	      Ei[_i2] = x[_i2][_i2];
	    }

	    return sorting(clone(Ei), clone(Sij));
	  } // diagonalization implementation for bigNumber


	  function diagBig(x, precision) {
	    var N = x.length;
	    var e0 = abs(precision / N);
	    var psi;
	    var Sij = new Array(N); // Sij is Identity Matrix

	    for (var i = 0; i < N; i++) {
	      Sij[i] = createArray(N, 0);
	      Sij[i][i] = 1.0;
	    } // initial error


	    var Vab = getAijBig(x);

	    while (abs(Vab[1]) >= abs(e0)) {
	      var _i3 = Vab[0][0];
	      var j = Vab[0][1];
	      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
	      x = x1Big(x, psi, _i3, j);
	      Sij = Sij1Big(Sij, psi, _i3, j);
	      Vab = getAijBig(x);
	    }

	    var Ei = createArray(N, 0); // eigenvalues

	    for (var _i4 = 0; _i4 < N; _i4++) {
	      Ei[_i4] = x[_i4][_i4];
	    } // return [clone(Ei), clone(Sij)]


	    return sorting(clone(Ei), clone(Sij));
	  } // get angle


	  function getTheta(aii, ajj, aij) {
	    var denom = ajj - aii;

	    if (Math.abs(denom) <= config.epsilon) {
	      return Math.PI / 4.0;
	    } else {
	      return 0.5 * Math.atan(2.0 * aij / (ajj - aii));
	    }
	  } // get angle


	  function getThetaBig(aii, ajj, aij) {
	    var denom = subtract(ajj, aii);

	    if (abs(denom) <= config.epsilon) {
	      return bignumber(-1).acos().div(4);
	    } else {
	      return multiplyScalar(0.5, atan(multiply(2.0, aij, inv(denom))));
	    }
	  } // update eigvec


	  function Sij1(Sij, theta, i, j) {
	    var N = Sij.length;
	    var c = Math.cos(theta);
	    var s = Math.sin(theta);
	    var Ski = createArray(N, 0);
	    var Skj = createArray(N, 0);

	    for (var k = 0; k < N; k++) {
	      Ski[k] = c * Sij[k][i] - s * Sij[k][j];
	      Skj[k] = s * Sij[k][i] + c * Sij[k][j];
	    }

	    for (var _k = 0; _k < N; _k++) {
	      Sij[_k][i] = Ski[_k];
	      Sij[_k][j] = Skj[_k];
	    }

	    return Sij;
	  } // update eigvec for overlap


	  function Sij1Big(Sij, theta, i, j) {
	    var N = Sij.length;
	    var c = cos(theta);
	    var s = sin(theta);
	    var Ski = createArray(N, bignumber(0));
	    var Skj = createArray(N, bignumber(0));

	    for (var k = 0; k < N; k++) {
	      Ski[k] = subtract(multiplyScalar(c, Sij[k][i]), multiplyScalar(s, Sij[k][j]));
	      Skj[k] = addScalar(multiplyScalar(s, Sij[k][i]), multiplyScalar(c, Sij[k][j]));
	    }

	    for (var _k2 = 0; _k2 < N; _k2++) {
	      Sij[_k2][i] = Ski[_k2];
	      Sij[_k2][j] = Skj[_k2];
	    }

	    return Sij;
	  } // update matrix


	  function x1Big(Hij, theta, i, j) {
	    var N = Hij.length;
	    var c = bignumber(cos(theta));
	    var s = bignumber(sin(theta));
	    var c2 = multiplyScalar(c, c);
	    var s2 = multiplyScalar(s, s);
	    var Aki = createArray(N, bignumber(0));
	    var Akj = createArray(N, bignumber(0)); // 2cs Hij

	    var csHij = multiply(bignumber(2), c, s, Hij[i][j]); //  Aii

	    var Aii = addScalar(subtract(multiplyScalar(c2, Hij[i][i]), csHij), multiplyScalar(s2, Hij[j][j]));
	    var Ajj = add(multiplyScalar(s2, Hij[i][i]), csHij, multiplyScalar(c2, Hij[j][j])); // 0  to i

	    for (var k = 0; k < N; k++) {
	      Aki[k] = subtract(multiplyScalar(c, Hij[i][k]), multiplyScalar(s, Hij[j][k]));
	      Akj[k] = addScalar(multiplyScalar(s, Hij[i][k]), multiplyScalar(c, Hij[j][k]));
	    } // Modify Hij


	    Hij[i][i] = Aii;
	    Hij[j][j] = Ajj;
	    Hij[i][j] = bignumber(0);
	    Hij[j][i] = bignumber(0); // 0  to i

	    for (var _k3 = 0; _k3 < N; _k3++) {
	      if (_k3 !== i && _k3 !== j) {
	        Hij[i][_k3] = Aki[_k3];
	        Hij[_k3][i] = Aki[_k3];
	        Hij[j][_k3] = Akj[_k3];
	        Hij[_k3][j] = Akj[_k3];
	      }
	    }

	    return Hij;
	  } // update matrix


	  function x1(Hij, theta, i, j) {
	    var N = Hij.length;
	    var c = Math.cos(theta);
	    var s = Math.sin(theta);
	    var c2 = c * c;
	    var s2 = s * s;
	    var Aki = createArray(N, 0);
	    var Akj = createArray(N, 0); //  Aii

	    var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
	    var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j]; // 0  to i

	    for (var k = 0; k < N; k++) {
	      Aki[k] = c * Hij[i][k] - s * Hij[j][k];
	      Akj[k] = s * Hij[i][k] + c * Hij[j][k];
	    } // Modify Hij


	    Hij[i][i] = Aii;
	    Hij[j][j] = Ajj;
	    Hij[i][j] = 0;
	    Hij[j][i] = 0; // 0  to i

	    for (var _k4 = 0; _k4 < N; _k4++) {
	      if (_k4 !== i && _k4 !== j) {
	        Hij[i][_k4] = Aki[_k4];
	        Hij[_k4][i] = Aki[_k4];
	        Hij[j][_k4] = Akj[_k4];
	        Hij[_k4][j] = Akj[_k4];
	      }
	    }

	    return Hij;
	  } // get max off-diagonal value from Upper Diagonal


	  function getAij(Mij) {
	    var N = Mij.length;
	    var maxMij = 0;
	    var maxIJ = [0, 1];

	    for (var i = 0; i < N; i++) {
	      for (var j = i + 1; j < N; j++) {
	        if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
	          maxMij = Math.abs(Mij[i][j]);
	          maxIJ = [i, j];
	        }
	      }
	    }

	    return [maxIJ, maxMij];
	  } // get max off-diagonal value from Upper Diagonal


	  function getAijBig(Mij) {
	    var N = Mij.length;
	    var maxMij = 0;
	    var maxIJ = [0, 1];

	    for (var i = 0; i < N; i++) {
	      for (var j = i + 1; j < N; j++) {
	        if (abs(maxMij) < abs(Mij[i][j])) {
	          maxMij = abs(Mij[i][j]);
	          maxIJ = [i, j];
	        }
	      }
	    }

	    return [maxIJ, maxMij];
	  } // sort results


	  function sorting(E, S) {
	    var N = E.length;
	    var values = Array(N);
	    var vectors = Array(N);

	    for (var k = 0; k < N; k++) {
	      vectors[k] = Array(N);
	    }

	    for (var i = 0; i < N; i++) {
	      var minID = 0;
	      var minE = E[0];

	      for (var j = 0; j < E.length; j++) {
	        if (abs(E[j]) < abs(minE)) {
	          minID = j;
	          minE = E[minID];
	        }
	      }

	      values[i] = E.splice(minID, 1)[0];

	      for (var _k5 = 0; _k5 < N; _k5++) {
	        vectors[_k5][i] = S[_k5][minID];

	        S[_k5].splice(minID, 1);
	      }
	    }

	    return {
	      values,
	      vectors
	    };
	  }
	  /**
	   * Create an array of a certain size and fill all items with an initial value
	   * @param {number} size
	   * @param {number} value
	   * @return {number[]}
	   */


	  function createArray(size, value) {
	    // TODO: as soon as all browsers support Array.fill, use that instead (IE doesn't support it)
	    var array = new Array(size);

	    for (var i = 0; i < size; i++) {
	      array[i] = value;
	    }

	    return array;
	  }

	  return main;
	}

	var name$1 = 'eigs'; // The absolute state of math.js's dependency system:

	var dependencies$1 = ['config', 'typed', 'matrix', 'addScalar', 'equal', 'subtract', 'abs', 'atan', 'cos', 'sin', 'multiplyScalar', 'divideScalar', 'inv', 'bignumber', 'multiply', 'add', 'larger', 'column', 'flatten', 'number', 'complex', 'sqrt', 'diag', 'qr', 'usolve', 'usolveAll', 'im', 're', 'smaller', 'matrixFromColumns', 'dot'];
	var createEigs = /* #__PURE__ */factory(name$1, dependencies$1, _ref => {
	  var {
	    config,
	    typed,
	    matrix,
	    addScalar,
	    subtract,
	    equal,
	    abs,
	    atan,
	    cos,
	    sin,
	    multiplyScalar,
	    divideScalar,
	    inv,
	    bignumber,
	    multiply,
	    add,
	    larger,
	    column,
	    flatten,
	    number,
	    complex,
	    sqrt,
	    diag,
	    qr,
	    usolve,
	    usolveAll,
	    im,
	    re,
	    smaller,
	    matrixFromColumns,
	    dot
	  } = _ref;
	  var doRealSymetric = createRealSymmetric({
	    config,
	    addScalar,
	    subtract,
	    column,
	    flatten,
	    equal,
	    abs,
	    atan,
	    cos,
	    sin,
	    multiplyScalar,
	    inv,
	    bignumber,
	    complex,
	    multiply,
	    add
	  });
	  var doComplexEigs = createComplexEigs({
	    config,
	    addScalar,
	    subtract,
	    multiply,
	    multiplyScalar,
	    flatten,
	    divideScalar,
	    sqrt,
	    abs,
	    bignumber,
	    diag,
	    qr,
	    inv,
	    usolve,
	    usolveAll,
	    equal,
	    complex,
	    larger,
	    smaller,
	    matrixFromColumns,
	    dot
	  });
	  /**
	   * Compute eigenvalues and eigenvectors of a matrix. The eigenvalues are sorted by their absolute value, ascending.
	   * An eigenvalue with multiplicity k will be listed k times. The eigenvectors are returned as columns of a matrix 
	   * the eigenvector that belongs to the j-th eigenvalue in the list (eg. `values[j]`) is the j-th column (eg. `column(vectors, j)`).
	   * If the algorithm fails to converge, it will throw an error  in that case, however, you may still find useful information
	   * in `err.values` and `err.vectors`.
	   *
	   * Syntax:
	   *
	   *     math.eigs(x, [prec])
	   *
	   * Examples:
	   *
	   *     const { eigs, multiply, column, transpose } = math
	   *     const H = [[5, 2.3], [2.3, 1]]
	   *     const ans = eigs(H) // returns {values: [E1,E2...sorted], vectors: [v1,v2.... corresponding vectors as columns]}
	   *     const E = ans.values
	   *     const U = ans.vectors
	   *     multiply(H, column(U, 0)) // returns multiply(E[0], column(U, 0))
	   *     const UTxHxU = multiply(transpose(U), H, U) // diagonalizes H
	   *     E[0] == UTxHxU[0][0]  // returns true
	   *
	   * See also:
	   *
	   *     inv
	   *
	   * @param {Array | Matrix} x  Matrix to be diagonalized
	   *
	   * @param {number | BigNumber} [prec] Precision, default value: 1e-15
	   * @return {{values: Array|Matrix, vectors: Array|Matrix}} Object containing an array of eigenvalues and a matrix with eigenvectors as columns.
	   *
	   */

	  return typed('eigs', {
	    Array: function Array(x) {
	      var mat = matrix(x);
	      return computeValuesAndVectors(mat);
	    },
	    'Array, number|BigNumber': function ArrayNumberBigNumber(x, prec) {
	      var mat = matrix(x);
	      return computeValuesAndVectors(mat, prec);
	    },
	    Matrix: function Matrix(mat) {
	      var {
	        values,
	        vectors
	      } = computeValuesAndVectors(mat);
	      return {
	        values: matrix(values),
	        vectors: matrix(vectors)
	      };
	    },
	    'Matrix, number|BigNumber': function MatrixNumberBigNumber(mat, prec) {
	      var {
	        values,
	        vectors
	      } = computeValuesAndVectors(mat, prec);
	      return {
	        values: matrix(values),
	        vectors: matrix(vectors)
	      };
	    }
	  });

	  function computeValuesAndVectors(mat, prec) {
	    if (prec === undefined) {
	      prec = config.epsilon;
	    }

	    var size = mat.size();

	    if (size.length !== 2 || size[0] !== size[1]) {
	      throw new RangeError('Matrix must be square (size: ' + format(size) + ')');
	    }

	    var arr = mat.toArray();
	    var N = size[0];

	    if (isReal(arr, N, prec)) {
	      coerceReal(arr, N);

	      if (isSymmetric(arr, N, prec)) {
	        var _type = coerceTypes(mat, arr, N);

	        return doRealSymetric(arr, N, prec, _type);
	      }
	    }

	    var type = coerceTypes(mat, arr, N);
	    return doComplexEigs(arr, N, prec, type);
	  }
	  /** @return {boolean} */


	  function isSymmetric(arr, N, prec) {
	    for (var i = 0; i < N; i++) {
	      for (var j = i; j < N; j++) {
	        // TODO proper comparison of bignum and frac
	        if (larger(bignumber(abs(subtract(arr[i][j], arr[j][i]))), prec)) {
	          return false;
	        }
	      }
	    }

	    return true;
	  }
	  /** @return {boolean} */


	  function isReal(arr, N, prec) {
	    for (var i = 0; i < N; i++) {
	      for (var j = 0; j < N; j++) {
	        // TODO proper comparison of bignum and frac
	        if (larger(bignumber(abs(im(arr[i][j]))), prec)) {
	          return false;
	        }
	      }
	    }

	    return true;
	  }

	  function coerceReal(arr, N) {
	    for (var i = 0; i < N; i++) {
	      for (var j = 0; j < N; j++) {
	        arr[i][j] = re(arr[i][j]);
	      }
	    }
	  }
	  /** @return {'number' | 'BigNumber' | 'Complex'} */


	  function coerceTypes(mat, arr, N) {
	    /** @type {string} */
	    var type = mat.datatype();

	    if (type === 'number' || type === 'BigNumber' || type === 'Complex') {
	      return type;
	    }

	    var hasNumber = false;
	    var hasBig = false;
	    var hasComplex = false;

	    for (var i = 0; i < N; i++) {
	      for (var j = 0; j < N; j++) {
	        var el = arr[i][j];

	        if (isNumber(el) || isFraction(el)) {
	          hasNumber = true;
	        } else if (isBigNumber(el)) {
	          hasBig = true;
	        } else if (isComplex(el)) {
	          hasComplex = true;
	        } else {
	          throw TypeError('Unsupported type in Matrix: ' + typeOf(el));
	        }
	      }
	    }

	    if (hasBig && hasComplex) {
	      console.warn('Complex BigNumbers not supported, this operation will lose precission.');
	    }

	    if (hasComplex) {
	      for (var _i = 0; _i < N; _i++) {
	        for (var _j = 0; _j < N; _j++) {
	          arr[_i][_j] = complex(arr[_i][_j]);
	        }
	      }

	      return 'Complex';
	    }

	    if (hasBig) {
	      for (var _i2 = 0; _i2 < N; _i2++) {
	        for (var _j2 = 0; _j2 < N; _j2++) {
	          arr[_i2][_j2] = bignumber(arr[_i2][_j2]);
	        }
	      }

	      return 'BigNumber';
	    }

	    if (hasNumber) {
	      for (var _i3 = 0; _i3 < N; _i3++) {
	        for (var _j3 = 0; _j3 < N; _j3++) {
	          arr[_i3][_j3] = number(arr[_i3][_j3]);
	        }
	      }

	      return 'number';
	    } else {
	      throw TypeError('Matrix contains unsupported types only.');
	    }
	  }
	});

	var name = 'divide';
	var dependencies = ['typed', 'matrix', 'multiply', 'equalScalar', 'divideScalar', 'inv'];
	var createDivide = /* #__PURE__ */factory(name, dependencies, _ref => {
	  var {
	    typed,
	    matrix,
	    multiply,
	    equalScalar,
	    divideScalar,
	    inv
	  } = _ref;
	  var algorithm11 = createAlgorithm11({
	    typed,
	    equalScalar
	  });
	  var algorithm14 = createAlgorithm14({
	    typed
	  });
	  /**
	   * Divide two values, `x / y`.
	   * To divide matrices, `x` is multiplied with the inverse of `y`: `x * inv(y)`.
	   *
	   * Syntax:
	   *
	   *    math.divide(x, y)
	   *
	   * Examples:
	   *
	   *    math.divide(2, 3)            // returns number 0.6666666666666666
	   *
	   *    const a = math.complex(5, 14)
	   *    const b = math.complex(4, 1)
	   *    math.divide(a, b)            // returns Complex 2 + 3i
	   *
	   *    const c = [[7, -6], [13, -4]]
	   *    const d = [[1, 2], [4, 3]]
	   *    math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]
	   *
	   *    const e = math.unit('18 km')
	   *    math.divide(e, 4.5)          // returns Unit 4 km
	   *
	   * See also:
	   *
	   *    multiply
	   *
	   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x   Numerator
	   * @param  {number | BigNumber | Fraction | Complex | Array | Matrix} y          Denominator
	   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix}                      Quotient, `x / y`
	   */

	  return typed('divide', extend({
	    // we extend the signatures of divideScalar with signatures dealing with matrices
	    'Array | Matrix, Array | Matrix': function ArrayMatrixArrayMatrix(x, y) {
	      // TODO: implement matrix right division using pseudo inverse
	      // https://www.mathworks.nl/help/matlab/ref/mrdivide.html
	      // https://www.gnu.org/software/octave/doc/interpreter/Arithmetic-Ops.html
	      // https://stackoverflow.com/questions/12263932/how-does-gnu-octave-matrix-division-work-getting-unexpected-behaviour
	      return multiply(x, inv(y));
	    },
	    'DenseMatrix, any': function DenseMatrixAny(x, y) {
	      return algorithm14(x, y, divideScalar, false);
	    },
	    'SparseMatrix, any': function SparseMatrixAny(x, y) {
	      return algorithm11(x, y, divideScalar, false);
	    },
	    'Array, any': function ArrayAny(x, y) {
	      // use matrix implementation
	      return algorithm14(matrix(x), y, divideScalar, false).valueOf();
	    },
	    'any, Array | Matrix': function anyArrayMatrix(x, y) {
	      return multiply(x, inv(y));
	    }
	  }, divideScalar.signatures));
	});

	/**
	 * THIS FILE IS AUTO-GENERATED
	 * DON'T MAKE CHANGES HERE
	 */
	var BigNumber = /* #__PURE__ */createBigNumberClass({
	  config
	});
	var Complex = /* #__PURE__ */createComplexClass({});
	var Fraction = /* #__PURE__ */createFractionClass({});
	var Matrix = /* #__PURE__ */createMatrixClass({});
	var DenseMatrix = /* #__PURE__ */createDenseMatrixClass({
	  Matrix
	});
	var typed = /* #__PURE__ */createTyped({
	  BigNumber,
	  Complex,
	  DenseMatrix,
	  Fraction
	});
	var abs = /* #__PURE__ */createAbs({
	  typed
	});
	var addScalar = /* #__PURE__ */createAddScalar({
	  typed
	});
	var atan = /* #__PURE__ */createAtan({
	  typed
	});
	var bignumber = /* #__PURE__ */createBignumber({
	  BigNumber,
	  typed
	});
	var complex = /* #__PURE__ */createComplex({
	  Complex,
	  typed
	});
	var conj = /* #__PURE__ */createConj({
	  typed
	});
	var equalScalar = /* #__PURE__ */createEqualScalar({
	  config,
	  typed
	});
	var im = /* #__PURE__ */createIm({
	  typed
	});
	var isZero = /* #__PURE__ */createIsZero({
	  typed
	});
	var multiplyScalar = /* #__PURE__ */createMultiplyScalar({
	  typed
	});
	var number = /* #__PURE__ */createNumber({
	  typed
	});
	var re$1 = /* #__PURE__ */createRe({
	  typed
	});
	var sign = /* #__PURE__ */createSign({
	  BigNumber,
	  Fraction,
	  complex,
	  typed
	});
	var sin$2 = /* #__PURE__ */createSin({
	  typed
	});
	var SparseMatrix = /* #__PURE__ */createSparseMatrixClass({
	  Matrix,
	  equalScalar,
	  typed
	});
	var cos$2 = /* #__PURE__ */createCos({
	  typed
	});
	var sqrt = /* #__PURE__ */createSqrt({
	  Complex,
	  config,
	  typed
	});
	var unaryMinus = /* #__PURE__ */createUnaryMinus({
	  typed
	});
	var fraction = /* #__PURE__ */createFraction({
	  Fraction,
	  typed
	});
	var matrix = /* #__PURE__ */createMatrix({
	  DenseMatrix,
	  Matrix,
	  SparseMatrix,
	  typed
	});
	var numeric = /* #__PURE__ */createNumeric({
	  bignumber,
	  fraction,
	  number
	});
	var size = /* #__PURE__ */createSize({
	  matrix,
	  config,
	  typed
	});
	var smaller = /* #__PURE__ */createSmaller({
	  DenseMatrix,
	  config,
	  matrix,
	  typed
	});
	var subtract = /* #__PURE__ */createSubtract({
	  DenseMatrix,
	  addScalar,
	  equalScalar,
	  matrix,
	  typed,
	  unaryMinus
	});
	var transpose = /* #__PURE__ */createTranspose({
	  matrix,
	  typed
	});
	var zeros = /* #__PURE__ */createZeros({
	  BigNumber,
	  config,
	  matrix,
	  typed
	});
	var ctranspose = /* #__PURE__ */createCtranspose({
	  conj,
	  transpose,
	  typed
	});
	var diag = /* #__PURE__ */createDiag({
	  DenseMatrix,
	  SparseMatrix,
	  matrix,
	  typed
	});
	var divideScalar = /* #__PURE__ */createDivideScalar({
	  numeric,
	  typed
	});
	var equal = /* #__PURE__ */createEqual({
	  DenseMatrix,
	  equalScalar,
	  matrix,
	  typed
	});
	var flatten = /* #__PURE__ */createFlatten({
	  matrix,
	  typed
	});
	var ImmutableDenseMatrix = /* #__PURE__ */createImmutableDenseMatrixClass({
	  DenseMatrix,
	  smaller
	});
	var Index = /* #__PURE__ */createIndexClass({
	  ImmutableDenseMatrix
	});
	var largerEq = /* #__PURE__ */createLargerEq({
	  DenseMatrix,
	  config,
	  matrix,
	  typed
	});
	var matrixFromColumns = /* #__PURE__ */createMatrixFromColumns({
	  flatten,
	  matrix,
	  size,
	  typed
	});
	var smallerEq = /* #__PURE__ */createSmallerEq({
	  DenseMatrix,
	  config,
	  matrix,
	  typed
	});
	var usolve = /* #__PURE__ */createUsolve({
	  DenseMatrix,
	  divideScalar,
	  equalScalar,
	  matrix,
	  multiplyScalar,
	  subtract,
	  typed
	});
	var add = /* #__PURE__ */createAdd({
	  DenseMatrix,
	  SparseMatrix,
	  addScalar,
	  equalScalar,
	  matrix,
	  typed
	});
	var dot = /* #__PURE__ */createDot({
	  addScalar,
	  conj,
	  multiplyScalar,
	  size,
	  typed
	});
	var identity = /* #__PURE__ */createIdentity({
	  BigNumber,
	  DenseMatrix,
	  SparseMatrix,
	  config,
	  matrix,
	  typed
	});
	var larger = /* #__PURE__ */createLarger({
	  DenseMatrix,
	  config,
	  matrix,
	  typed
	});
	var multiply = /* #__PURE__ */createMultiply({
	  addScalar,
	  dot,
	  equalScalar,
	  matrix,
	  multiplyScalar,
	  typed
	});
	var qr = /* #__PURE__ */createQr({
	  addScalar,
	  complex,
	  conj,
	  divideScalar,
	  equal,
	  identity,
	  isZero,
	  matrix,
	  multiplyScalar,
	  sign,
	  sqrt,
	  subtract,
	  typed,
	  unaryMinus,
	  zeros
	});
	var range = /* #__PURE__ */createRange({
	  bignumber,
	  matrix,
	  config,
	  larger,
	  largerEq,
	  smaller,
	  smallerEq,
	  typed
	});
	var usolveAll = /* #__PURE__ */createUsolveAll({
	  DenseMatrix,
	  divideScalar,
	  equalScalar,
	  matrix,
	  multiplyScalar,
	  subtract,
	  typed
	});
	var column = /* #__PURE__ */createColumn({
	  Index,
	  matrix,
	  range,
	  typed
	});
	var cross = /* #__PURE__ */createCross({
	  matrix,
	  multiply,
	  subtract,
	  typed
	});
	var det = /* #__PURE__ */createDet({
	  divideScalar,
	  isZero,
	  matrix,
	  multiply,
	  subtract,
	  typed,
	  unaryMinus
	});
	var inv = /* #__PURE__ */createInv({
	  abs,
	  addScalar,
	  det,
	  divideScalar,
	  identity,
	  matrix,
	  multiply,
	  typed,
	  unaryMinus
	});
	var pow = /* #__PURE__ */createPow({
	  Complex,
	  config,
	  fraction,
	  identity,
	  inv,
	  matrix,
	  multiply,
	  number,
	  typed
	});
	var divide = /* #__PURE__ */createDivide({
	  divideScalar,
	  equalScalar,
	  inv,
	  matrix,
	  multiply,
	  typed
	});
	var eigs = /* #__PURE__ */createEigs({
	  abs,
	  add,
	  addScalar,
	  atan,
	  bignumber,
	  column,
	  complex,
	  config,
	  cos: cos$2,
	  diag,
	  divideScalar,
	  dot,
	  equal,
	  flatten,
	  im,
	  inv,
	  larger,
	  matrix,
	  matrixFromColumns,
	  multiply,
	  multiplyScalar,
	  number,
	  qr,
	  re: re$1,
	  sin: sin$2,
	  smaller,
	  sqrt,
	  subtract,
	  typed,
	  usolve,
	  usolveAll
	});
	var norm = /* #__PURE__ */createNorm({
	  abs,
	  add,
	  conj,
	  ctranspose,
	  eigs,
	  equalScalar,
	  larger,
	  matrix,
	  multiply,
	  pow,
	  smaller,
	  sqrt,
	  typed
	});

	function DegToRad(value) {
	  return value * (Math.PI / 180);
	}

	function RadToDeg(value) {
	  return value * (180 / Math.PI);
	}
	const MIN_LON = -180;
	const MAX_LON = 180;
	const EARTH_RADIUS = 3443.91846652;

	const sin$1 = angle => Math.sin(DegToRad(angle));

	const cos$1 = angle => Math.cos(DegToRad(angle));

	function asin$1(angle) {
	  return RadToDeg(Math.asin(angle));
	}

	function atan2(y, x) {
	  return RadToDeg(Math.atan2(y, x));
	}
	/**
	 * Calculates the bearing from one point to another (referenced at the first coordinate, bearing can be different at different points between the two)
	 * @param from
	 * @param to
	 */


	function bearingTo(from, to) {
	  return (atan2(sin$1(to.long - from.long) * cos$1(to.lat), cos$1(from.lat) * sin$1(to.lat) - sin$1(from.lat) * cos$1(to.lat) * cos$1(to.long - from.long)) + 360) % 360;
	}

	const robustAcos = value => {
	  if (value > 1) {
	    return 1;
	  }

	  if (value < -1) {
	    return -1;
	  }

	  return value;
	};

	function clampAngle(a) {
	  while (a >= 360) {
	    a -= 360;
	  }

	  while (a < 0) {
	    a += 360;
	  }

	  return a;
	}

	function diffAngle(a, b) {
	  let diff = b - a;

	  while (diff > 180) {
	    diff -= 360;
	  }

	  while (diff <= -180) {
	    diff += 360;
	  }

	  return diff;
	}

	function coordinatesToSpherical(location) {
	  return [cos$1(location.lat) * cos$1(location.long), cos$1(location.lat) * sin$1(location.long), sin$1(location.lat)];
	}

	function sphericalToCoordinates(spherical) {
	  return {
	    lat: asin$1(spherical[2]),
	    long: atan2(spherical[1], spherical[0])
	  };
	}
	/**
	 * Calculates the distance between two coordinates on the globe
	 * @param from
	 * @param to
	 */


	function distanceTo(from, to) {
	  return Math.acos(robustAcos(sin$1(to.lat) * sin$1(from.lat) + cos$1(to.lat) * cos$1(from.lat) * cos$1(from.long - to.long))) * EARTH_RADIUS;
	}
	/**
	 * Calculates a Coordinate at a bearing and distance from a reference point
	 * @param place - Point to reference from
	 * @param bearing
	 * @param distance
	 */


	function placeBearingDistance(place, bearing, distance) {
	  const delta = distance / EARTH_RADIUS;
	  const lat = asin$1(sin$1(place.lat) * Math.cos(delta) + cos$1(place.lat) * Math.sin(delta) * cos$1(bearing));
	  let long = place.long + atan2(sin$1(bearing) * Math.sin(delta) * cos$1(place.lat), Math.cos(delta) - sin$1(place.lat) * sin$1(lat));

	  if (long < MIN_LON || long > MAX_LON) {
	    long = (long + 540) % 360 - 180;
	  }

	  return {
	    lat,
	    long
	  };
	}
	/**
	 * Calculates the intercept points of two Coordinates and two bearings
	 * @param point1
	 * @param bearing1
	 * @param point2
	 * @param bearing2
	 */


	function placeBearingIntersection(point1, bearing1, point2, bearing2) {
	  const Pa11 = coordinatesToSpherical(point1);
	  const point12 = placeBearingDistance(point1, clampAngle(bearing1), 500);
	  const Pa12 = coordinatesToSpherical(point12);
	  const Pa21 = coordinatesToSpherical(point2);
	  const point22 = placeBearingDistance(point2, clampAngle(bearing2), 500);
	  const Pa22 = coordinatesToSpherical(point22);
	  const N1 = cross(Pa11, Pa12);
	  const N2 = cross(Pa21, Pa22);
	  const L = cross(N1, N2);
	  const l = norm(L);
	  const I1 = divide(L, l);
	  const I2 = multiply(I1, -1);
	  const s1 = sphericalToCoordinates(I1);
	  const s2 = sphericalToCoordinates(I2);
	  const brgTos1 = bearingTo(point1, s1);
	  const brgTos2 = bearingTo(point1, s2);
	  const delta1 = Math.abs(clampAngle(bearing1) - brgTos1);
	  const delta2 = Math.abs(clampAngle(bearing1) - brgTos2);
	  return [delta1 < delta2 ? s1 : s2, delta1 < delta2 ? s2 : s1];
	}

	function xyzToCoordinates(x, y, z) {
	  const theta = Math.atan2(Math.sqrt(x ** 2 + y ** 2), z); // From: https://en.wikipedia.org/wiki/Spherical_coordinate_system#Coordinate_system_conversions

	  let phi = NaN;
	  if (x > 0) phi = Math.atan(y / x);else if (x < 0 && y >= 0) phi = Math.atan(y / x) + Math.PI;else if (x < 0 && y < 0) phi = Math.atan(y / x) - Math.PI;else if (x === 0 && y > 0) phi = Math.PI;else if (x === 0 && y < 0) phi = -Math.PI;
	  return {
	    lat: thetaToLat(theta),
	    long: phiToLong(phi)
	  };
	}

	function thetaToLat(theta) {
	  return 90 - theta * 180 / Math.PI;
	}

	function phiToLong(phi) {
	  if (phi > Math.PI) return 180 - phi * 180 / Math.PI;
	  return phi * 180 / Math.PI;
	}

	function latToTheta(lat) {
	  return (90 - lat) * Math.PI / 180;
	}

	function longToPhi(long) {
	  if (long < 0) return (long + 360) * Math.PI / 180;
	  return long * Math.PI / 180;
	}

	function coordinatesToXyz(coordinates, radius) {
	  const theta = latToTheta(coordinates.lat);
	  const phi = longToPhi(coordinates.long);
	  return [radius * Math.sin(theta) * Math.cos(phi), radius * Math.sin(theta) * Math.sin(phi), radius * Math.cos(theta)];
	}

	function crossProduct(x1, y1, z1, x2, y2, z2) {
	  return [y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2];
	}

	function thetaUnitVector(theta, phi) {
	  return [Math.cos(theta) * Math.cos(phi), Math.cos(theta) * Math.sin(phi), -Math.sin(theta)];
	}

	function phiUnitVector(theta, phi) {
	  return [-Math.sin(phi), Math.cos(phi), 0];
	}

	function calculateV(course, theta, phi) {
	  const [thetaUnitX, thetaUnitY, thetaUnitZ] = thetaUnitVector(theta, phi);
	  const [phiUnitX, phiUnitY, phiUnitZ] = phiUnitVector(theta, phi);
	  return [-Math.cos(course) * thetaUnitX + Math.sin(course) * phiUnitX, -Math.cos(course) * thetaUnitY + Math.sin(course) * phiUnitY, -Math.cos(course) * thetaUnitZ + Math.sin(course) * phiUnitZ];
	}

	function solveWithPermutations(smallCircleCoordinates, ns, smallCircleRadius, permutations) {
	  let permutation = permutations[0];
	  let denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];

	  for (let i = 1; Math.abs(denominator) < 1e-4 && i < 3; i++) {
	    permutation = permutations[i];
	    denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
	  }

	  const A = -ns[permutation[2]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2) / 2 / denominator;
	  const B = -(ns[permutation[2]] * smallCircleCoordinates[permutation[0]] - ns[permutation[0]] * smallCircleCoordinates[permutation[2]]) / denominator;
	  const C = ns[permutation[1]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2) / 2 / denominator;
	  const D = -(-ns[permutation[1]] * smallCircleCoordinates[permutation[0]] + ns[permutation[0]] * smallCircleCoordinates[permutation[1]]) / denominator;
	  const discriminant = -(C ** 2) * (1 + B ** 2) + 2 * A * B * C * D - A ** 2 * (1 + D ** 2) + (1 + B ** 2 + D ** 2) * EARTH_RADIUS ** 2;

	  if (discriminant < 0) {
	    return null;
	  }

	  const result1 = [0, 0, 0];
	  const result2 = [0, 0, 0];
	  result1[permutation[0]] = (-A * B - C * D - Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
	  result2[permutation[0]] = (-A * B - C * D + Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
	  result1[permutation[1]] = A + B * result1[permutation[0]];
	  result2[permutation[1]] = A + B * result2[permutation[0]];
	  result1[permutation[2]] = C + D * result1[permutation[0]];
	  result2[permutation[2]] = C + D * result2[permutation[0]];
	  return [xyzToCoordinates(result1[0], result1[1], result1[2]), xyzToCoordinates(result2[0], result2[1], result2[2])];
	}

	function smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
	  const smallCircleCoords = coordinatesToXyz(smallCircleCentre, EARTH_RADIUS);
	  const [greatCircleX, greatCircleY, greatCircleZ] = coordinatesToXyz(greatCircleReference, EARTH_RADIUS);
	  const [vx, vy, vz] = calculateV(greatCircleBearing * Math.PI / 180, latToTheta(greatCircleReference.lat), longToPhi(greatCircleReference.long));
	  const normalVector = crossProduct(greatCircleX, greatCircleY, greatCircleZ, vx, vy, vz);
	  return solveWithPermutations(smallCircleCoords, normalVector, smallCircleRadius, [[0, 1, 2], [2, 0, 1], [1, 2, 0]]);
	}
	/**
	 * Returns the first small circle intersection to occur on a given bearing
	 * @param smallCircleCentre
	 * @param smallCircleRadius
	 * @param greatCircleReference
	 * @param greatCircleBearing
	 */


	function firstSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
	  const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
	  if (!intercepts) return null;

	  if (distanceTo(greatCircleReference, smallCircleCentre) <= smallCircleRadius) {
	    // The great circle reference is inside the circle, use the intercept which is in-front of the great circle reference as per the great circle bearing
	    if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, intercepts[0]))) <= 90) {
	      return intercepts[0];
	    }

	    return intercepts[1];
	  }

	  if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, smallCircleCentre))) <= 90) {
	    // The small circle centre is in-front of the great circle reference, use the closest intercept
	    if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
	      return intercepts[0];
	    }

	    return intercepts[1];
	  } // The small circle centre is behind the great circle reference, use the furthest intercept


	  if (distanceTo(greatCircleReference, intercepts[0]) > distanceTo(greatCircleReference, intercepts[1])) {
	    return intercepts[0];
	  }

	  return intercepts[1];
	}
	/**
	 * Returns the closest to greatCircleReference of two intercepts between a great circle and a small circle
	 * @param smallCircleCentre
	 * @param smallCircleRadius
	 * @param greatCircleReference
	 * @param greatCircleBearing
	 */


	function closestSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
	  const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
	  if (!intercepts) return null;

	  if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
	    return intercepts[0];
	  }

	  return intercepts[1];
	}

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/** Generates fix names based on the ARINC default naming scheme. */
	class FixNamingScheme {
	  /**
	     * Generates a fix name for a vector type fix.
	     *
	     * @returns The generated fix name.
	     */
	  static vector() {
	    return 'MANUAL';
	  }
	  /**
	     * Generates a fix name for a heading to altitude type fix.
	     *
	     * @param altitudeFeet The altitude that will be flown to.
	     *
	     * @returns The generated fix name.
	     */


	  static headingUntilAltitude(altitudeFeet) {
	    return Math.round(altitudeFeet).toString();
	  }
	  /**
	   * Generates a fix name for a course to distance type fix.
	   *
	   * @param course The course that will be flown.
	   * @param distance The distance along the course or from the reference fix.
	   *
	   * @returns The generated fix name.
	   */


	  static courseToDistance(course, distance) {
	    const roundedDistance = Math.round(distance);
	    const distanceAlpha = distance > 26 ? 'Z' : this.alphabet[roundedDistance];
	    return "D".concat(course.toFixed(0).padStart(3, '0')).concat(distanceAlpha);
	  }
	  /**
	   * Generates a fix name for a course turn to intercept type fix.
	   *
	   * @param course The course that will be turned to.
	   *
	   * @returns The generated fix name.
	   */


	  static courseToIntercept(course) {
	    return 'INTCPT';
	  }

	}

	_defineProperty(FixNamingScheme, "alphabet", ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']);

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	function WorldMagneticModel() {
	  this.coff = ['  1,  0,  -29404.5  ,     0.0    ,    6.7  ,      0.0', '  1,  1,   -1450.7  ,  4652.9    ,    7.7  ,    -25.1', '  2,  0,   -2500.0  ,     0.0    ,  -11.5  ,      0.0', '  2,  1,    2982.0  , -2991.6    ,   -7.1  ,    -30.2', '  2,  2,    1676.8  ,  -734.8    ,   -2.2  ,    -23.9', '  3,  0,    1363.9  ,     0.0    ,    2.8  ,      0.0', '  3,  1,   -2381.0  ,   -82.2    ,   -6.2  ,      5.7', '  3,  2,    1236.2  ,   241.8    ,    3.4  ,     -1.0', '  3,  3,     525.7  ,  -542.9    ,  -12.2  ,      1.1', '  4,  0,     903.1  ,     0.0    ,   -1.1  ,      0.0', '  4,  1,     809.4  ,   282.0    ,   -1.6  ,      0.2', '  4,  2,      86.2  ,  -158.4    ,   -6.0  ,      6.9', '  4,  3,    -309.4  ,   199.8    ,    5.4  ,      3.7', '  4,  4,      47.9  ,  -350.1    ,   -5.5  ,     -5.6', '  5,  0,    -234.4  ,     0.0    ,   -0.3  ,      0.0', '  5,  1,     363.1  ,    47.7    ,    0.6  ,      0.1', '  5,  2,     187.8  ,   208.4    ,   -0.7  ,      2.5', '  5,  3,    -140.7  ,  -121.3    ,    0.1  ,     -0.9', '  5,  4,    -151.2  ,    32.2    ,    1.2  ,      3.0', '  5,  5,      13.7  ,    99.1    ,    1.0  ,      0.5', '  6,  0,      65.9  ,     0.0    ,   -0.6  ,      0.0', '  6,  1,      65.6  ,   -19.1    ,   -0.4  ,      0.1', '  6,  2,      73.0  ,    25.0    ,    0.5  ,     -1.8', '  6,  3,    -121.5  ,    52.7    ,    1.4  ,     -1.4', '  6,  4,     -36.2  ,   -64.4    ,   -1.4  ,      0.9', '  6,  5,      13.5  ,     9.0    ,   -0.0  ,      0.1', '  6,  6,     -64.7  ,    68.1    ,    0.8  ,      1.0', '  7,  0,      80.6  ,     0.0    ,   -0.1  ,      0.0', '  7,  1,     -76.8  ,   -51.4    ,   -0.3  ,      0.5', '  7,  2,      -8.3  ,   -16.8    ,   -0.1  ,      0.6', '  7,  3,      56.5  ,     2.3    ,    0.7  ,     -0.7', '  7,  4,      15.8  ,    23.5    ,    0.2  ,     -0.2', '  7,  5,       6.4  ,    -2.2    ,   -0.5  ,     -1.2', '  7,  6,      -7.2  ,   -27.2    ,   -0.8  ,      0.2', '  7,  7,       9.8  ,    -1.9    ,    1.0  ,      0.3', '  8,  0,      23.6  ,     0.0    ,   -0.1  ,      0.0', '  8,  1,       9.8  ,     8.4    ,    0.1  ,     -0.3', '  8,  2,     -17.5  ,   -15.3    ,   -0.1  ,      0.7', '  8,  3,      -0.4  ,    12.8    ,    0.5  ,     -0.2', '  8,  4,     -21.1  ,   -11.8    ,   -0.1  ,      0.5', '  8,  5,      15.3  ,    14.9    ,    0.4  ,     -0.3', '  8,  6,      13.7  ,     3.6    ,    0.5  ,     -0.5', '  8,  7,     -16.5  ,    -6.9    ,    0.0  ,      0.4', '  8,  8,      -0.3  ,     2.8    ,    0.4  ,      0.1', '  9,  0,       5.0  ,     0.0    ,   -0.1  ,      0.0', '  9,  1,       8.2  ,   -23.3    ,   -0.2  ,     -0.3', '  9,  2,       2.9  ,    11.1    ,   -0.0  ,      0.2', '  9,  3,      -1.4  ,     9.8    ,    0.4  ,     -0.4', '  9,  4,      -1.1  ,    -5.1    ,   -0.3  ,      0.4', '  9,  5,     -13.3  ,    -6.2    ,   -0.0  ,      0.1', '  9,  6,       1.1  ,     7.8    ,    0.3  ,     -0.0', '  9,  7,       8.9  ,     0.4    ,   -0.0  ,     -0.2', '  9,  8,      -9.3  ,    -1.5    ,   -0.0  ,      0.5', '  9,  9,     -11.9  ,     9.7    ,   -0.4  ,      0.2', ' 10,  0,      -1.9  ,     0.0    ,    0.0  ,      0.0', ' 10,  1,      -6.2  ,     3.4    ,   -0.0  ,     -0.0', ' 10,  2,      -0.1  ,    -0.2    ,   -0.0  ,      0.1', ' 10,  3,       1.7  ,     3.5    ,    0.2  ,     -0.3', ' 10,  4,      -0.9  ,     4.8    ,   -0.1  ,      0.1', ' 10,  5,       0.6  ,    -8.6    ,   -0.2  ,     -0.2', ' 10,  6,      -0.9  ,    -0.1    ,   -0.0  ,      0.1', ' 10,  7,       1.9  ,    -4.2    ,   -0.1  ,     -0.0', ' 10,  8,       1.4  ,    -3.4    ,   -0.2  ,     -0.1', ' 10,  9,      -2.4  ,    -0.1    ,   -0.1  ,      0.2', ' 10, 10,      -3.9  ,    -8.8    ,   -0.0  ,     -0.0', ' 11,  0,       3.0  ,     0.0    ,   -0.0  ,      0.0', ' 11,  1,      -1.4  ,    -0.0    ,   -0.1  ,     -0.0', ' 11,  2,      -2.5  ,     2.6    ,   -0.0  ,      0.1', ' 11,  3,       2.4  ,    -0.5    ,    0.0  ,      0.0', ' 11,  4,      -0.9  ,    -0.4    ,   -0.0  ,      0.2', ' 11,  5,       0.3  ,     0.6    ,   -0.1  ,     -0.0', ' 11,  6,      -0.7  ,    -0.2    ,    0.0  ,      0.0', ' 11,  7,      -0.1  ,    -1.7    ,   -0.0  ,      0.1', ' 11,  8,       1.4  ,    -1.6    ,   -0.1  ,     -0.0', ' 11,  9,      -0.6  ,    -3.0    ,   -0.1  ,     -0.1', ' 11, 10,       0.2  ,    -2.0    ,   -0.1  ,      0.0', ' 11, 11,       3.1  ,    -2.6    ,   -0.1  ,     -0.0', ' 12,  0,      -2.0  ,     0.0    ,    0.0  ,      0.0', ' 12,  1,      -0.1  ,    -1.2    ,   -0.0  ,     -0.0', ' 12,  2,       0.5  ,     0.5    ,   -0.0  ,      0.0', ' 12,  3,       1.3  ,     1.3    ,    0.0  ,     -0.1', ' 12,  4,      -1.2  ,    -1.8    ,   -0.0  ,      0.1', ' 12,  5,       0.7  ,     0.1    ,   -0.0  ,     -0.0', ' 12,  6,       0.3  ,     0.7    ,    0.0  ,      0.0', ' 12,  7,       0.5  ,    -0.1    ,   -0.0  ,     -0.0', ' 12,  8,      -0.2  ,     0.6    ,    0.0  ,      0.1', ' 12,  9,      -0.5  ,     0.2    ,   -0.0  ,     -0.0', ' 12, 10,       0.1  ,    -0.9    ,   -0.0  ,     -0.0', ' 12, 11,      -1.1  ,    -0.0    ,   -0.0  ,      0.0', ' 12, 12,      -0.3  ,     0.5    ,   -0.1  ,     -0.1'];
	  /* static variables */

	  /* some 13x13 2D arrays */

	  this.c = new Array(13);
	  this.cd = new Array(13);
	  this.tc = new Array(13);
	  this.dp = new Array(13);
	  this.k = new Array(13);

	  for (var i = 0; i < 13; i++) {
	    this.c[i] = new Array(13);
	    this.cd[i] = new Array(13);
	    this.tc[i] = new Array(13);
	    this.dp[i] = new Array(13);
	    this.k[i] = new Array(13);
	  }
	  /* some 1D arrays */


	  this.snorm = new Array(169);
	  this.sp = new Array(13);
	  this.cp = new Array(13);
	  this.fn = new Array(13);
	  this.fm = new Array(13);
	  this.pp = new Array(13);
	  /* locals */

	  const maxdeg = 12;
	  let maxord;
	  var i;
	  let j;
	  let D1;
	  let D2;
	  let n;
	  let m;
	  let gnm;
	  let hnm;
	  let dgnm;
	  let dhnm;
	  let flnmj;
	  let c_str;
	  let c_flds;
	  /* INITIALIZE CONSTANTS */

	  maxord = maxdeg;
	  this.sp[0] = 0.0;
	  this.cp[0] = this.snorm[0] = this.pp[0] = 1.0;
	  this.dp[0][0] = 0.0;
	  /* READ WORLD MAGNETIC MODEL SPHERICAL HARMONIC COEFFICIENTS */

	  this.c[0][0] = 0.0;
	  this.cd[0][0] = 0.0;

	  for (i = 0; i < this.coff.length; i++) {
	    c_str = this.coff[i];
	    c_flds = c_str.split(',');
	    n = parseInt(c_flds[0], 10);
	    m = parseInt(c_flds[1], 10);
	    gnm = parseFloat(c_flds[2]);
	    hnm = parseFloat(c_flds[3]);
	    dgnm = parseFloat(c_flds[4]);
	    dhnm = parseFloat(c_flds[5]);

	    if (m <= n) {
	      this.c[m][n] = gnm;
	      this.cd[m][n] = dgnm;

	      if (m != 0) {
	        this.c[n][m - 1] = hnm;
	        this.cd[n][m - 1] = dhnm;
	      }
	    }
	  }
	  /* CONVERT SCHMIDT NORMALIZED GAUSS COEFFICIENTS TO UNNORMALIZED */


	  this.snorm[0] = 1.0;

	  for (n = 1; n <= maxord; n++) {
	    this.snorm[n] = this.snorm[n - 1] * (2 * n - 1) / n;
	    j = 2;

	    for (m = 0, D1 = 1, D2 = (n - m + D1) / D1; D2 > 0; D2--, m += D1) {
	      this.k[m][n] = ((n - 1) * (n - 1) - m * m) / ((2 * n - 1) * (2 * n - 3));

	      if (m > 0) {
	        flnmj = (n - m + 1) * j / (n + m);
	        this.snorm[n + m * 13] = this.snorm[n + (m - 1) * 13] * Math.sqrt(flnmj);
	        j = 1;
	        this.c[n][m - 1] = this.snorm[n + m * 13] * this.c[n][m - 1];
	        this.cd[n][m - 1] = this.snorm[n + m * 13] * this.cd[n][m - 1];
	      }

	      this.c[m][n] = this.snorm[n + m * 13] * this.c[m][n];
	      this.cd[m][n] = this.snorm[n + m * 13] * this.cd[m][n];
	    }

	    this.fn[n] = n + 1;
	    this.fm[n] = n;
	  }

	  this.k[1][1] = 0.0;
	  this.fm[0] = 0.0; // !!!!!! WMM C and Fortran both have a bug in that fm[0] is not initialised
	}

	WorldMagneticModel.prototype.declination = function (altitudeKm, latitudeDegrees, longitudeDegrees, yearFloat) {
	  /* locals */
	  const a = 6378.137;
	  const b = 6356.7523142;
	  const re = 6371.2;
	  const a2 = a * a;
	  const b2 = b * b;
	  const c2 = a2 - b2;
	  const a4 = a2 * a2;
	  const b4 = b2 * b2;
	  const c4 = a4 - b4;
	  let D3;
	  let D4;
	  let dec;
	  let n;
	  let m;
	  let pi;
	  let dt;
	  let rlon;
	  let rlat;
	  let srlon;
	  let srlat;
	  let crlon;
	  let crlat;
	  let srlat2;
	  let crlat2;
	  let q;
	  let q1;
	  let q2;
	  let ct;
	  let d;
	  let aor;
	  let ar;
	  let br;
	  let r;
	  let r2;
	  let bpp;
	  let par;
	  let temp1;
	  let parp;
	  let temp2;
	  let bx;
	  let by;
	  let dtr;
	  let bp;
	  let bt;
	  let st;
	  let ca;
	  let sa;
	  const maxord = 12;
	  const alt = altitudeKm;
	  const glon = longitudeDegrees;
	  const glat = latitudeDegrees;
	  /** ********************************************************************** */

	  dt = yearFloat - 2020.0; // if more then 5 years has passed since last epoch update then return invalid

	  if (dt < 0.0 || dt > 5.0) return -999;
	  pi = 3.14159265359;
	  dtr = pi / 180.0;
	  rlon = glon * dtr;
	  rlat = glat * dtr;
	  srlon = Math.sin(rlon);
	  srlat = Math.sin(rlat);
	  crlon = Math.cos(rlon);
	  crlat = Math.cos(rlat);
	  srlat2 = srlat * srlat;
	  crlat2 = crlat * crlat;
	  this.sp[1] = srlon;
	  this.cp[1] = crlon;
	  /* CONVERT FROM GEODETIC COORDS. TO SPHERICAL COORDS. */

	  q = Math.sqrt(a2 - c2 * srlat2);
	  q1 = alt * q;
	  q2 = (q1 + a2) / (q1 + b2) * ((q1 + a2) / (q1 + b2));
	  ct = srlat / Math.sqrt(q2 * crlat2 + srlat2);
	  st = Math.sqrt(1.0 - ct * ct);
	  r2 = alt * alt + 2.0 * q1 + (a4 - c4 * srlat2) / (q * q);
	  r = Math.sqrt(r2);
	  d = Math.sqrt(a2 * crlat2 + b2 * srlat2);
	  ca = (alt + d) / r;
	  sa = c2 * crlat * srlat / (r * d);

	  for (m = 2; m <= maxord; m++) {
	    this.sp[m] = this.sp[1] * this.cp[m - 1] + this.cp[1] * this.sp[m - 1];
	    this.cp[m] = this.cp[1] * this.cp[m - 1] - this.sp[1] * this.sp[m - 1];
	  }

	  aor = re / r;
	  ar = aor * aor;
	  br = bt = bp = bpp = 0.0;

	  for (n = 1; n <= maxord; n++) {
	    ar *= aor;

	    for (m = 0, D3 = 1, D4 = (n + m + D3) / D3; D4 > 0; D4--, m += D3) {
	      /*
	       COMPUTE UNNORMALIZED ASSOCIATED LEGENDRE POLYNOMIALS
	       AND DERIVATIVES VIA RECURSION RELATIONS
	      */
	      if (n == m) {
	        this.snorm[n + m * 13] = st * this.snorm[n - 1 + (m - 1) * 13];
	        this.dp[m][n] = st * this.dp[m - 1][n - 1] + ct * this.snorm[n - 1 + (m - 1) * 13];
	      } else if (n == 1 && m == 0) {
	        this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13];
	        this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13];
	      } else if (n > 1 && n != m) {
	        if (m > n - 2) this.snorm[n - 2 + m * 13] = 0.0;
	        if (m > n - 2) this.dp[m][n - 2] = 0.0;
	        this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.snorm[n - 2 + m * 13];
	        this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.dp[m][n - 2];
	      }
	      /*
	      TIME ADJUST THE GAUSS COEFFICIENTS
	      */


	      this.tc[m][n] = this.c[m][n] + dt * this.cd[m][n];
	      if (m != 0) this.tc[n][m - 1] = this.c[n][m - 1] + dt * this.cd[n][m - 1];
	      /*
	      ACCUMULATE TERMS OF THE SPHERICAL HARMONIC EXPANSIONS
	      */

	      par = ar * this.snorm[n + m * 13];

	      if (m == 0) {
	        temp1 = this.tc[m][n] * this.cp[m];
	        temp2 = this.tc[m][n] * this.sp[m];
	      } else {
	        temp1 = this.tc[m][n] * this.cp[m] + this.tc[n][m - 1] * this.sp[m];
	        temp2 = this.tc[m][n] * this.sp[m] - this.tc[n][m - 1] * this.cp[m];
	      }

	      bt -= ar * temp1 * this.dp[m][n];
	      bp += this.fm[m] * temp2 * par;
	      br += this.fn[n] * temp1 * par;
	      /*
	      SPECIAL CASE:  NORTH/SOUTH GEOGRAPHIC POLES
	      */

	      if (st == 0.0 && m == 1) {
	        if (n == 1) this.pp[n] = this.pp[n - 1];else this.pp[n] = this.ct * this.pp[n - 1] - this.k[m][n] * this.pp[n - 2];
	        parp = ar * this.pp[n];
	        bpp += this.fm[m] * temp2 * parp;
	      }
	    }
	  }

	  if (st == 0.0) bp = bpp;else bp /= st;
	  /*
	    ROTATE MAGNETIC VECTOR COMPONENTS FROM SPHERICAL TO
	    GEODETIC COORDINATES
	  */

	  bx = -bt * ca - br * sa;
	  by = bp;
	  dec = Math.atan2(by, bx) / dtr;

	  return dec;
	};

	WorldMagneticModel.prototype.knownAnswerTest = function () {
	  /* http://www.ngdc.noaa.gov/geomag/WMM WMM2010testvalues.pdf */

	  /* Lat	Lon Dec	    */

	  /* Lon 240 = 120W, Lon 300 = 60W */

	  /* Alt 0 km */
	  const kat2010 = ['80.00	,0.00	 ,-6.13	    ', '0.00	,120.00	 ,0.97	    ', '-80.00	,240.00	 ,70.21	    '];
	  const kat2012p5 = ['80.00	,0.00	 ,-5.21	    ', '0.00	,120.00	 ,0.88	    ', '-80.00	,240.00	 ,70.04	    '];
	  let maxErr = 0.0;

	  for (var i = 0; i < kat2010.length; i++) {
	    var c_str = kat2010[i];
	    var c_flds = c_str.split(',');
	    var lat = parseFloat(c_flds[0]);
	    var lon = parseFloat(c_flds[1]);
	    var exp = parseFloat(c_flds[2]);
	    var maxExp;
	    var dec = this.declination(0, lat, lon, 2010.0);

	    if (Math.abs(dec - exp) > maxErr) {
	      maxErr = Math.abs(dec - exp);
	      maxExp = exp;
	    }
	  }

	  for (var i = 0; i < kat2012p5.length; i++) {
	    var c_str = kat2012p5[i];
	    var c_flds = c_str.split(',');
	    var lat = parseFloat(c_flds[0]);
	    var lon = parseFloat(c_flds[1]);
	    var exp = parseFloat(c_flds[2]);
	    var maxExp;
	    var dec = this.declination(0, lat, lon, 2012.5);

	    if (Math.abs(dec - exp) > maxErr) {
	      maxErr = Math.abs(dec - exp);
	      maxExp = exp;
	    }
	  }

	  return maxErr * 100 / maxExp; // max % error
	};
	/*

	  C***********************************************************************
	  C
	  C
	  C     SUBROUTINE GEOMAG (GEOMAGNETIC FIELD COMPUTATION)
	  C
	  C
	  C***********************************************************************
	  C
	  C     GEOMAG IS A NATIONAL GEOSPATIAL INTELLIGENCE AGENCY (NGA) STANDARD
	  C     PRODUCT.  IT IS COVERED UNDER NGA MILITARY SPECIFICATION:
	  C     MIL-W-89500 (1993).
	  C
	  C***********************************************************************
	  C     Contact Information
	  C
	  C     Software and Model Support
	  C     	National Geophysical Data Center
	  C     	NOAA EGC/2
	  C     	325 Broadway
	  C     	Boulder, CO 80303 USA
	  C     	Attn: Susan McLean or Stefan Maus
	  C     	Phone:  (303) 497-6478 or -6522
	  C     	Email:  Susan.McLean@noaa.gov or Stefan.Maus@noaa.gov
	  C		Web: http://www.ngdc.noaa.gov/seg/WMM/
	  C
	  C     Sponsoring Government Agency
	  C	   National Geospatial-Intelligence Agency
	  C    	   PRG / CSAT, M.S. L-41
	  C    	   3838 Vogel Road
	  C    	   Arnold, MO 63010
	  C    	   Attn: Craig Rollins
	  C    	   Phone:  (314) 263-4186
	  C    	   Email:  Craig.M.Rollins@Nga.Mil
	  C
	  C      Original Program By:
	  C        Dr. John Quinn
	  C        FLEET PRODUCTS DIVISION, CODE N342
	  C        NAVAL OCEANOGRAPHIC OFFICE (NAVOCEANO)
	  C        STENNIS SPACE CENTER (SSC), MS 39522-5001
	  C
	  C***********************************************************************
	  C
	  C     PURPOSE:  THIS ROUTINE COMPUTES THE DECLINATION (DEC),
	  C               INCLINATION (DIP), TOTAL INTENSITY (TI) AND
	  C               GRID VARIATION (GV - POLAR REGIONS ONLY, REFERENCED
	  C               TO GRID NORTH OF A STEREOGRAPHIC PROJECTION) OF THE
	  C               EARTH'S MAGNETIC FIELD IN GEODETIC COORDINATES
	  C               FROM THE COEFFICIENTS OF THE CURRENT OFFICIAL
	  C               DEPARTMENT OF DEFENSE (DOD) SPHERICAL HARMONIC WORLD
	  C               MAGNETIC MODEL (WMM.COF).  THE WMM SERIES OF MODELS IS
	  C               UPDATED EVERY 5 YEARS ON JANUARY 1ST OF THOSE YEARS
	  C               WHICH ARE DIVISIBLE BY 5 (I.E. 2000, 2005, 2010 ETC.)
	  C               BY NOAA'S NATIONAL GEOPHYSICAL DATA CENTER IN
	  C               COOPERATION WITH THE BRITISH GEOLOGICAL SURVEY (BGS).
	  C               THE MODEL IS BASED ON GEOMAGNETIC FIELD MEASUREMENTS
	  C               FROM SATELLITE AND GROUND OBSERVATORIES.
	  C
	  C***********************************************************************
	  C
	  C     MODEL:  THE WMM SERIES GEOMAGNETIC MODELS ARE COMPOSED
	  C             OF TWO PARTS:  THE MAIN FIELD MODEL, WHICH IS
	  C             VALID AT THE BASE EPOCH OF THE CURRENT MODEL AND
	  C             A SECULAR VARIATION MODEL, WHICH ACCOUNTS FOR SLOW
	  C             TEMPORAL VARIATIONS IN THE MAIN GEOMAGNETIC FIELD
	  C             FROM THE BASE EPOCH TO A MAXIMUM OF 5 YEARS BEYOND
	  C             THE BASE EPOCH.  FOR EXAMPLE, THE BASE EPOCH OF
	  C             THE WMM-2005 MODEL IS 2005.0.  THIS MODEL IS THEREFORE
	  C             CONSIDERED VALID BETWEEN 2005.0 AND 2010.0. THE
	  C             COMPUTED MAGNETIC PARAMETERS ARE REFERENCED TO THE
	  C             WGS-84 ELLIPSOID.
	  C
	  C***********************************************************************
	  C
	  C     ACCURACY:  IN OCEAN AREAS AT THE EARTH'S SURFACE OVER THE
	  C                ENTIRE 5 YEAR LIFE OF THE DEGREE AND ORDER 12
	  C                SPHERICAL HARMONIC MODEL WMM-2005, THE ESTIMATED
	  C                MAXIMUM RMS ERRORS FOR THE VARIOUS MAGNETIC COMPONENTS
	  C                ARE:
	  C
	  C                DEC  -   0.5 Degrees
	  C                DIP  -   0.5 Degrees
	  C                TI   - 280.0 nanoTeslas (nT)
	  C                GV   -   0.5 Degrees
	  C
	  C                OTHER MAGNETIC COMPONENTS THAT CAN BE DERIVED FROM
	  C                THESE FOUR BY SIMPLE TRIGONOMETRIC RELATIONS WILL
	  C                HAVE THE FOLLOWING APPROXIMATE ERRORS OVER OCEAN AREAS:
	  C
	  C                X    - 140 nT (North)
	  C                Y    - 140 nT (East)
	  C                Z    - 200 nT (Vertical) Positive is down
	  C                H    - 200 nT (Horizontal)
	  C
	  C                OVER LAND THE MAXIMUM RMS ERRORS ARE EXPECTED TO BE
	  C                HIGHER, ALTHOUGH THE RMS ERRORS FOR DEC, DIP, AND GV
	  C                ARE STILL ESTIMATED TO BE LESS THAN 1.0 DEGREE, FOR
	  C                THE ENTIRE 5-YEAR LIFE OF THE MODEL AT THE EARTH's
	  C                SURFACE.  THE OTHER COMPONENT ERRORS OVER LAND ARE
	  C                MORE DIFFICULT TO ESTIMATE AND SO ARE NOT GIVEN.
	  C
	  C                THE ACCURACY AT ANY GIVEN TIME FOR ALL OF THESE
	  C                GEOMAGNETIC PARAMETERS DEPENDS ON THE GEOMAGNETIC
	  C                LATITUDE.  THE ERRORS ARE LEAST FROM THE EQUATOR TO
	  C                MID-LATITUDES AND GREATEST NEAR THE MAGNETIC POLES.
	  C
	  C                IT IS VERY IMPORTANT TO NOTE THAT A DEGREE AND
	  C                ORDER 12 MODEL, SUCH AS WMM-2005, DESCRIBES ONLY
	  C                THE LONG WAVELENGTH SPATIAL MAGNETIC FLUCTUATIONS
	  C                DUE TO EARTH'S CORE.  NOT INCLUDED IN THE WMM SERIES
	  C                MODELS ARE INTERMEDIATE AND SHORT WAVELENGTH
	  C                SPATIAL FLUCTUATIONS OF THE GEOMAGNETIC FIELD
	  C                WHICH ORIGINATE IN THE EARTH'S MANTLE AND CRUST.
	  C                CONSEQUENTLY, ISOLATED ANGULAR ERRORS AT VARIOUS
	  C                POSITIONS ON THE SURFACE (PRIMARILY OVER LAND, IN
	  C                CONTINENTAL MARGINS AND OVER OCEANIC SEAMOUNTS,
	  C                RIDGES AND TRENCHES) OF SEVERAL DEGREES MAY BE
	  C                EXPECTED. ALSO NOT INCLUDED IN THE MODEL ARE
	  C                NONSECULAR TEMPORAL FLUCTUATIONS OF THE GEOMAGNETIC
	  C                FIELD OF MAGNETOSPHERIC AND IONOSPHERIC ORIGIN.
	  C                DURING MAGNETIC STORMS, TEMPORAL FLUCTUATIONS CAN
	  C                CAUSE SUBSTANTIAL DEVIATIONS OF THE GEOMAGNETIC
	  C                FIELD FROM MODEL VALUES.  IN ARCTIC AND ANTARCTIC
	  C                REGIONS, AS WELL AS IN EQUATORIAL REGIONS, DEVIATIONS
	  C                FROM MODEL VALUES ARE BOTH FREQUENT AND PERSISTENT.
	  C
	  C                IF THE REQUIRED DECLINATION ACCURACY IS MORE
	  C                STRINGENT THAN THE WMM SERIES OF MODELS PROVIDE, THEN
	  C                THE USER IS ADVISED TO REQUEST SPECIAL (REGIONAL OR
	  C                LOCAL) SURVEYS BE PERFORMED AND MODELS PREPARED.
	  C                REQUESTS OF THIS NATURE SHOULD BE MADE TO NIMA
	  C                AT THE ADDRESS ABOVE.
	  C
	  C***********************************************************************
	  C
	  C     USAGE:  THIS ROUTINE IS BROKEN UP INTO TWO PARTS:
	  C
	  C             A) AN INITIALIZATION MODULE, WHICH IS CALLED ONLY
	  C                ONCE AT THE BEGINNING OF THE MAIN (CALLING)
	  C                PROGRAM
	  C             B) A PROCESSING MODULE, WHICH COMPUTES THE MAGNETIC
	  C                FIELD PARAMETERS FOR EACH SPECIFIED GEODETIC
	  C                POSITION (ALTITUDE, LATITUDE, LONGITUDE) AND TIME
	  C
	  C             INITIALIZATION IS MADE VIA A SINGLE CALL TO THE MAIN
	  C             ENTRY POINT (GEOMAG), WHILE SUBSEQUENT PROCESSING
	  C             CALLS ARE MADE THROUGH THE SECOND ENTRY POINT (GEOMG1).
	  C             ONE CALL TO THE PROCESSING MODULE IS REQUIRED FOR EACH
	  C             POSITION AND TIME.
	  C
	  C             THE VARIABLE MAXDEG IN THE INITIALIZATION CALL IS THE
	  C             MAXIMUM DEGREE TO WHICH THE SPHERICAL HARMONIC MODEL
	  C             IS TO BE COMPUTED.  IT MUST BE SPECIFIED BY THE USER
	  C             IN THE CALLING ROUTINE.  NORMALLY IT IS 12 BUT IT MAY
	  C             BE SET LESS THAN 12 TO INCREASE COMPUTATIONAL SPEED AT
	  C             THE EXPENSE OF REDUCED ACCURACY.
	  C
	  C             THE PC VERSION OF THIS SUBROUTINE MUST BE COMPILED
	  C             WITH A FORTRAN 77 COMPATIBLE COMPILER SUCH AS THE
	  C             MICROSOFT OPTIMIZING FORTRAN COMPILER VERSION 4.1
	  C             OR LATER.
	  C
	  C**********************************************************************
	  C
	  C     REFERENCES:
	  C
	  C       JOHN M. QUINN, DAVID J. KERRIDGE AND DAVID R. BARRACLOUGH,
	  C            WORLD MAGNETIC CHARTS FOR 1985 - SPHERICAL HARMONIC
	  C            MODELS OF THE GEOMAGNETIC FIELD AND ITS SECULAR
	  C            VARIATION, GEOPHYS. J. R. ASTR. SOC. (1986) 87,
	  C            PP 1143-1157
	  C
	  C       DEFENSE MAPPING AGENCY TECHNICAL REPORT, TR 8350.2:
	  C            DEPARTMENT OF DEFENSE WORLD GEODETIC SYSTEM 1984,
	  C            SEPT. 30 (1987)
	  C
	  C       JOHN M. QUINN, RACHEL J. COLEMAN, MICHAEL R. PECK, AND
	  C            STEPHEN E. LAUBER; THE JOINT US/UK 1990 EPOCH
	  C            WORLD MAGNETIC MODEL, TECHNICAL REPORT NO. 304,
	  C            NAVAL OCEANOGRAPHIC OFFICE (1991)
	  C
	  C       JOHN M. QUINN, RACHEL J. COLEMAN, DONALD L. SHIEL, AND
	  C            JOHN M. NIGRO; THE JOINT US/UK 1995 EPOCH WORLD
	  C            MAGNETIC MODEL, TECHNICAL REPORT NO. 314, NAVAL
	  C            OCEANOGRAPHIC OFFICE (1995)
	  C
	  C            SUSAN AMCMILLAN, DAVID R. BARRACLOUGH, JOHN M. QUINN, AND
	  C            RACHEL J. COLEMAN;  THE 1995 REVISION OF THE JOINT US/UK
	  C            GEOMAGNETIC FIELD MODELS - I. SECULAR VARIATION, JOURNAL OF
	  C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 229-243
	  C            (1997)
	  C
	  C            JOHN M. QUINN, RACHEL J. COELMAN, SUSAM MACMILLAN, AND
	  C            DAVID R. BARRACLOUGH;  THE 1995 REVISION OF THE JOINT
	  C            US/UK GEOMAGNETIC FIELD MODELS: II. MAIN FIELD,JOURNAL OF
	  C            GEOMAGNETISM AND GEOELECTRICITY, VOL. 49, PP. 245 - 261
	  C            (1997)
	  C
	  C***********************************************************************
	  C
	  C     PARAMETER DESCRIPTIONS:
	  C
	  C       A      - SEMIMAJOR AXIS OF WGS-84 ELLIPSOID (KM)
	  C       B      - SEMIMINOR AXIS OF WGS-84 ELLIPSOID (KM)
	  C       RE     - MEAN RADIUS OF IAU-66 ELLIPSOID (KM)
	  C       SNORM  - SCHMIDT NORMALIZATION FACTORS
	  C       C      - GAUSS COEFFICIENTS OF MAIN GEOMAGNETIC MODEL (NT)
	  C       CD     - GAUSS COEFFICIENTS OF SECULAR GEOMAGNETIC MODEL (NT/YR)
	  C       TC     - TIME ADJUSTED GEOMAGNETIC GAUSS COEFFICIENTS (NT)
	  C       OTIME  - TIME ON PREVIOUS CALL TO GEOMAG (YRS)
	  C       OALT   - GEODETIC ALTITUDE ON PREVIOUS CALL TO GEOMAG (YRS)
	  C       OLAT   - GEODETIC LATITUDE ON PREVIOUS CALL TO GEOMAG (DEG.)
	  C       TIME   - COMPUTATION TIME (YRS)                        (INPUT)
	  C                (EG. 1 JULY 1995 = 1995.500)
	  C       ALT    - GEODETIC ALTITUDE (KM)                        (INPUT)
	  C       GLAT   - GEODETIC LATITUDE (DEG.)                      (INPUT)
	  C       GLON   - GEODETIC LONGITUDE (DEG.)                     (INPUT)
	  C       EPOCH  - BASE TIME OF GEOMAGNETIC MODEL (YRS)
	  C       DTR    - DEGREE TO RADIAN CONVERSION
	  C       SP(M)  - SINE OF (M*SPHERICAL COORD. LONGITUDE)
	  C       CP(M)  - COSINE OF (M*SPHERICAL COORD. LONGITUDE)
	  C       ST     - SINE OF (SPHERICAL COORD. LATITUDE)
	  C       CT     - COSINE OF (SPHERICAL COORD. LATITUDE)
	  C       R      - SPHERICAL COORDINATE RADIAL POSITION (KM)
	  C       CA     - COSINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
	  C       SA     - SINE OF SPHERICAL TO GEODETIC VECTOR ROTATION ANGLE
	  C       BR     - RADIAL COMPONENT OF GEOMAGNETIC FIELD (NT)
	  C       BT     - THETA COMPONENT OF GEOMAGNETIC FIELD (NT)
	  C       BP     - PHI COMPONENT OF GEOMAGNETIC FIELD (NT)
	  C       P(N,M) - ASSOCIATED LEGENDRE POLYNOMIALS (UNNORMALIZED)
	  C       PP(N)  - ASSOCIATED LEGENDRE POLYNOMIALS FOR M=1 (UNNORMALIZED)
	  C       DP(N,M)- THETA DERIVATIVE OF P(N,M) (UNNORMALIZED)
	  C       BX     - NORTH GEOMAGNETIC COMPONENT (NT)
	  C       BY     - EAST GEOMAGNETIC COMPONENT (NT)
	  C       BZ     - VERTICALLY DOWN GEOMAGNETIC COMPONENT (NT)
	  C       BH     - HORIZONTAL GEOMAGNETIC COMPONENT (NT)
	  C       DEC    - GEOMAGNETIC DECLINATION (DEG.)                (OUTPUT)
	  C                  EAST=POSITIVE ANGLES
	  C                  WEST=NEGATIVE ANGLES
	  C       DIP    - GEOMAGNETIC INCLINATION (DEG.)                (OUTPUT)
	  C                  DOWN=POSITIVE ANGLES
	  C                    UP=NEGATIVE ANGLES
	  C       TI     - GEOMAGNETIC TOTAL INTENSITY (NT)              (OUTPUT)
	  C       GV     - GEOMAGNETIC GRID VARIATION (DEG.)             (OUTPUT)
	  C                REFERENCED TO GRID NORTH
	  C                GRID NORTH REFERENCED TO 0 MERIDIAN
	  C                OF A POLAR STEREOGRAPHIC PROJECTION
	  C                (ARCTIC/ANTARCTIC ONLY)
	  C       MAXDEG - MAXIMUM DEGREE OF SPHERICAL HARMONIC MODEL    (INPUT)
	  C       MOXORD - MAXIMUM ORDER OF SPHERICAL HARMONIC MODEL
	  C
	  C***********************************************************************
	  C
	  C     NOTE:  THIS VERSION OF GEOMAG USES A WMM SERIES GEOMAGNETIC
	  C            FIELS MODEL REFERENCED TO THE WGS-84 GRAVITY MODEL
	  C            ELLIPSOID
	  C

	  */

	/** A class for geographical mathematics. */

	class GeoMath {
	  /**
	   * Gets coordinates at a relative bearing and distance from a set of coordinates.
	   * @param course The course, in degrees, from the reference coordinates.
	   * @param distanceInNM The distance, in nautical miles, from the reference coordinates.
	   * @param referenceCoordinates The reference coordinates to calculate from.
	   * @returns The calculated coordinates.
	   */
	  static relativeBearingDistanceToCoords(course, distanceInNM, referenceCoordinates) {
	    const courseRadians = course * Avionics.Utils.DEG2RAD;
	    const distanceRadians = Math.PI / (180 * 60) * distanceInNM;
	    const refLat = referenceCoordinates.lat * Avionics.Utils.DEG2RAD;
	    const refLon = -(referenceCoordinates.long * Avionics.Utils.DEG2RAD);
	    const lat = Math.asin(Math.sin(refLat) * Math.cos(distanceRadians) + Math.cos(refLat) * Math.sin(distanceRadians) * Math.cos(courseRadians));
	    const dlon = Math.atan2(Math.sin(courseRadians) * Math.sin(distanceRadians) * Math.cos(refLat), Math.cos(distanceRadians) - Math.sin(refLat) * Math.sin(lat));
	    const lon = Avionics.Utils.fmod(refLon - dlon + Math.PI, 2 * Math.PI) - Math.PI;
	    return new LatLongAlt(lat * Avionics.Utils.RAD2DEG, -(lon * Avionics.Utils.RAD2DEG));
	  }
	  /**
	   * Gets a magnetic heading given a true course and a magnetic variation.
	   * @param trueCourse The true course to correct.
	   * @param magneticVariation The measured magnetic variation.
	   * @returns The magnetic heading, corrected for magnetic variation.
	   */


	  static correctMagvar(trueCourse, magneticVariation) {
	    return trueCourse - GeoMath.normalizeMagVar(magneticVariation);
	  }
	  /**
	   * Gets a true course given a magnetic heading and a magnetic variation.
	   * @param headingMagnetic The magnetic heading to correct.
	   * @param magneticVariation The measured magnetic variation.
	   * @returns The true course, corrected for magnetic variation.
	   */


	  static removeMagvar(headingMagnetic, magneticVariation) {
	    return headingMagnetic + GeoMath.normalizeMagVar(magneticVariation);
	  }
	  /**
	   * Gets a magnetic variation difference in 0-360 degrees.
	   * @param magneticVariation The magnetic variation to normalize.
	   * @returns A normalized magnetic variation.
	   */


	  static normalizeMagVar(magneticVariation) {
	    let normalizedMagVar;

	    if (magneticVariation <= 180) {
	      normalizedMagVar = magneticVariation;
	    } else {
	      normalizedMagVar = magneticVariation - 360;
	    }

	    return normalizedMagVar;
	  }
	  /**
	   * Gets the magnetic variation for a given latitude and longitude.
	   * @param lat The latitude to get a magvar for.
	   * @param lon The longitude to get a magvar for.
	   * @returns The magnetic variation at the specific latitude and longitude.
	   */


	  static getMagvar(lat, lon) {
	    return GeoMath.magneticModel.declination(0, lat, lon, 2020);
	  }

	  static directedDistanceToGo(from, to, acDirectedLineBearing) {
	    const absDtg = Avionics.Utils.computeGreatCircleDistance(from, to); // @todo should be abeam distance

	    if (acDirectedLineBearing >= 90 && acDirectedLineBearing <= 270) {
	      // Since a line perpendicular to the leg is formed by two 90 degree angles, an aircraftLegBearing outside
	      // (North - 90) and (North + 90) is in the lower quadrants of a plane centered at the TO fix. This means
	      // the aircraft is NOT past the TO fix, and DTG must be positive.
	      return absDtg;
	    }

	    return -absDtg;
	  }

	}

	_defineProperty(GeoMath, "magneticModel", new WorldMagneticModel());

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	/**
	 * A class for mapping raw facility data to WayPoints.
	 */

	class RawDataMapper {
	  /**
	   * Maps a raw facility record to a WayPoint.
	   * @param facility The facility record to map.
	   * @param instrument The instrument to attach to the WayPoint.
	   * @returns The mapped waypoint.
	   */
	  static toWaypoint(facility, instrument) {
	    const waypoint = new WayPoint(instrument);
	    waypoint.ident = WayPoint.formatIdentFromIcao(facility.icao);
	    waypoint.icao = facility.icao;
	    waypoint.type = facility.icao[0];
	    let alt = 0;

	    switch (waypoint.type) {
	      case 'A':
	        {
	          const info = new AirportInfo(instrument);
	          info.CopyBaseInfosFrom(waypoint);
	          info.UpdateNamedFrequencies();
	          alt = 3.28084 * facility.runways.reduce((sum, r) => sum + r.elevation, 0) / facility.runways.length;
	          info.approaches = facility.approaches;
	          info.approaches.forEach(approach => approach.name = normaliseApproachName(approach.name));
	          info.approaches.forEach(approach => approach.transitions.forEach(trans => trans.name = trans.legs[0].fixIcao.substring(7, 12).trim()));
	          info.approaches.forEach(approach => approach.runway = approach.runway.trim());
	          info.departures = facility.departures;
	          info.departures.forEach(departure => departure.runwayTransitions.forEach(trans => trans.name = RawDataMapper.generateRunwayTransitionName(trans)));
	          info.departures.forEach(departure => departure.enRouteTransitions.forEach(trans => trans.name = RawDataMapper.generateDepartureEnRouteTransitionName(trans)));
	          info.arrivals = facility.arrivals;
	          info.arrivals.forEach(arrival => arrival.runwayTransitions.forEach(trans => trans.name = RawDataMapper.generateRunwayTransitionName(trans)));
	          info.arrivals.forEach(arrival => arrival.enRouteTransitions.forEach(trans => trans.name = RawDataMapper.generateArrivalTransitionName(trans)));
	          info.runways = facility.runways;
	          info.oneWayRunways = [];
	          facility.runways.forEach(runway => info.oneWayRunways.push(...Object.assign(new Runway(), runway).splitIfTwoWays()));
	          info.oneWayRunways.sort(RawDataMapper.sortRunways);
	          waypoint.infos = info;
	        }
	        break;

	      case 'V':
	        waypoint.infos = new VORInfo(instrument);
	        break;

	      case 'N':
	        waypoint.infos = new NDBInfo(instrument);
	        break;

	      case 'W':
	        waypoint.infos = new IntersectionInfo(instrument);
	        break;

	      default:
	        waypoint.infos = new WayPointInfo(instrument);
	        break;
	    }

	    if (waypoint.type !== 'A') {
	      waypoint.infos.CopyBaseInfosFrom(waypoint);
	      waypoint.infos.routes = facility.routes;
	    }

	    waypoint.infos.coordinates = new LatLongAlt(facility.lat, facility.lon, alt);
	    waypoint.additionalData = {};
	    return waypoint;
	  }
	  /**
	   * A comparer for sorting runways by number, and then by L, C, and R.
	   * @param r1 The first runway to compare.
	   * @param r2 The second runway to compare.
	   * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
	   */


	  static sortRunways(r1, r2) {
	    if (parseInt(r1.designation) === parseInt(r2.designation)) {
	      let v1 = 0;

	      if (r1.designation.indexOf('L') !== -1) {
	        v1 = 1;
	      } else if (r1.designation.indexOf('C') !== -1) {
	        v1 = 2;
	      } else if (r1.designation.indexOf('R') !== -1) {
	        v1 = 3;
	      }

	      let v2 = 0;

	      if (r2.designation.indexOf('L') !== -1) {
	        v2 = 1;
	      } else if (r2.designation.indexOf('C') !== -1) {
	        v2 = 2;
	      } else if (r2.designation.indexOf('R') !== -1) {
	        v2 = 3;
	      }

	      return v1 - v2;
	    }

	    return parseInt(r1.designation) - parseInt(r2.designation);
	  }
	  /**
	   * Generates a runway transition name from the designated runway in the transition data.
	   * @param runwayTransition The runway transition to generate the name for.
	   * @returns The runway transition name.
	   */


	  static generateRunwayTransitionName(runwayTransition) {
	    let name = "RW".concat(runwayTransition.runwayNumber);

	    switch (runwayTransition.runwayDesignation) {
	      case 1:
	        name += 'L';
	        break;

	      case 2:
	        name += 'R';
	        break;

	      case 3:
	        name += 'C';
	        break;
	    }

	    return name;
	  }
	  /**
	   * Generates an arrival transition name from a provided arrival enroute transition.
	   * @param enrouteTransition The enroute transition to generate a name for.
	   * @returns The generated transition name.
	   */


	  static generateArrivalTransitionName(enrouteTransition) {
	    return enrouteTransition.legs[0].fixIcao.substring(7, 12).trim();
	  }
	  /**
	   * Generates a departure transition name from a provided departure enroute transition.
	   * @param enrouteTransition The enroute transition to generate a name for.
	   * @returns The generated transition name.
	   */


	  static generateDepartureEnRouteTransitionName(enrouteTransition) {
	    return enrouteTransition.legs[enrouteTransition.legs.length - 1].fixIcao.substring(7, 12).trim();
	  }

	}

	/**
	 * Creates a collection of waypoints from a legs procedure.
	 */

	class LegsProcedure {
	  /** The current index in the procedure. */

	  /** Whether or not there is a discontinuity pending to be mapped. */

	  /** A collection of the loaded facilities needed for this procedure. */

	  /** Whether or not the facilities have completed loading. */

	  /** The collection of facility promises to await on first load. */

	  /** Whether or not a non initial-fix procedure start has been added to the procedure. */

	  /** A normalization factor for calculating distances from triangular ratios. */

	  /** A collection of filtering rules for filtering ICAO data to pre-load for the procedure. */

	  /**
	   * Creates an instance of a LegsProcedure.
	   * @param legs The legs that are part of the procedure.
	   * @param startingPoint The starting point for the procedure.
	   * @param instrument The instrument that is attached to the flight plan.
	   * @param approachType The approach type if this is an approach procedure
	   */
	  constructor(_legs, _previousFix, _instrument, airportMagVar, approachType, legAnnotations) {
	    this._legs = _legs;
	    this._previousFix = _previousFix;
	    this._instrument = _instrument;
	    this.airportMagVar = airportMagVar;
	    this.approachType = approachType;
	    this.legAnnotations = legAnnotations;

	    _defineProperty(this, "_currentIndex", 0);

	    _defineProperty(this, "_isDiscontinuityPending", false);

	    _defineProperty(this, "_facilities", new Map());

	    _defineProperty(this, "_facilitiesLoaded", false);

	    _defineProperty(this, "_facilitiesToLoad", new Map());

	    _defineProperty(this, "_addedProcedureStart", false);

	    _defineProperty(this, "legFilteringRules", [icao => icao.trim() !== '', // Icao is not empty
	    icao => icao[0] !== 'R', // Icao is not runway icao, which is not searchable
	    icao => icao[0] !== 'A', // Icao is not airport icao, which can be skipped
	    icao => icao.substr(1, 2) !== '  ', // Icao is not missing a region code
	    icao => !this._facilitiesToLoad.has(icao) // Icao is not already being loaded
	    ]);

	    for (const leg of this._legs) {
	      if (this.isIcaoValid(leg.fixIcao)) {
	        this._facilitiesToLoad.set(leg.fixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.fixIcao, 2000, true));
	      }

	      if (this.isIcaoValid(leg.originIcao)) {
	        this._facilitiesToLoad.set(leg.originIcao, this._instrument.facilityLoader.getFacilityRaw(leg.originIcao, 2000, true));
	      }

	      if (this.isIcaoValid(leg.arcCenterFixIcao)) {
	        this._facilitiesToLoad.set(leg.arcCenterFixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.arcCenterFixIcao, 2000, true));
	      }
	    }
	  }
	  /**
	   * Checks whether or not there are any legs remaining in the procedure.
	   * @returns True if there is a next leg, false otherwise.
	   */


	  hasNext() {
	    return this._currentIndex < this._legs.length || this._isDiscontinuityPending;
	  }

	  async ensureFacilitiesLoaded() {
	    if (!this._facilitiesLoaded) {
	      const facilityResults = await Promise.all(this._facilitiesToLoad.values());

	      for (const facility of facilityResults.filter(f => f !== undefined)) {
	        this._facilities.set(facility.icao, facility);
	      }

	      this._facilitiesLoaded = true;
	    }
	  }
	  /**
	   * Gets the next mapped leg from the procedure.
	   * @returns The mapped waypoint from the leg of the procedure.
	   */


	  async getNext() {
	    let isLegMappable = false;
	    let mappedLeg;
	    await this.ensureFacilitiesLoaded();

	    while (!isLegMappable && this._currentIndex < this._legs.length) {
	      const currentLeg = this._legs[this._currentIndex];
	      const currentAnnotation = this.legAnnotations[this._currentIndex];
	      isLegMappable = true; // Some procedures don't start with 15 (initial fix) but instead start with a heading and distance from
	      // a fix: the procedure then starts with the fix exactly

	      if (this._currentIndex === 0 && currentLeg.type === 10 && !this._addedProcedureStart) {
	        mappedLeg = this.mapExactFix(currentLeg);
	        this._addedProcedureStart = true;
	      } else {
	        try {
	          switch (currentLeg.type) {
	            case LegType.AF:
	            case LegType.PI:
	              mappedLeg = this.mapExactFix(currentLeg);
	              break;

	            case LegType.CD:
	            case LegType.VD:
	              mappedLeg = this.mapHeadingUntilDistanceFromOrigin(currentLeg, this._previousFix);
	              break;

	            case LegType.CF:
	              // Only map if the fix is itself not a runway fix to avoid double
	              // adding runway fixes
	              if (currentLeg.fixIcao === '' || currentLeg.fixIcao[0] !== 'R') {
	                mappedLeg = this.mapOriginRadialForDistance(currentLeg, this._previousFix);
	              } else {
	                isLegMappable = false;
	              }

	              break;

	            case LegType.CI:
	            case LegType.VI:
	              mappedLeg = this.mapHeadingToInterceptNextLeg(currentLeg, this._previousFix, this._legs[this._currentIndex + 1]);
	              break;

	            case LegType.CR:
	            case LegType.VR:
	              mappedLeg = this.mapHeadingUntilRadialCrossing(currentLeg, this._previousFix);
	              break;

	            case LegType.FC:
	            case LegType.FD:
	              mappedLeg = this.mapBearingAndDistanceFromOrigin(currentLeg);
	              break;

	            case LegType.FM:
	            case LegType.VM:
	              mappedLeg = this.mapVectors(currentLeg, this._previousFix);
	              break;

	            case LegType.IF:
	              if (currentLeg.fixIcao[0] !== 'A') {
	                const leg = this.mapExactFix(currentLeg);
	                const prevLeg = this._previousFix; // If a type 15 (initial fix) comes up in the middle of a plan

	                if (leg.icao === prevLeg.icao && leg.infos.coordinates.lat === prevLeg.infos.coordinates.lat && leg.infos.coordinates.long === prevLeg.infos.coordinates.long) {
	                  isLegMappable = false;
	                } else {
	                  mappedLeg = leg;
	                }
	              } else {
	                // If type 15 is an airport itself, we don't need to map it (and the data is generally wrong)
	                isLegMappable = false;
	              }

	              break;

	            case LegType.DF:
	            case LegType.TF:
	              // Only map if the fix is itself not a runway fix to avoid double
	              // adding runway fixes
	              if (currentLeg.fixIcao === '' || currentLeg.fixIcao[0] !== 'R') {
	                mappedLeg = this.mapExactFix(currentLeg);
	              } else {
	                isLegMappable = false;
	              }

	              break;

	            case LegType.RF:
	              mappedLeg = this.mapRadiusToFix(currentLeg);
	              break;

	            case LegType.CA:
	            case LegType.VA:
	              mappedLeg = this.mapHeadingUntilAltitude(currentLeg, this._previousFix);
	              break;

	            case LegType.HA:
	            case LegType.HF:
	            case LegType.HM:
	              mappedLeg = this.mapHold(currentLeg);
	              break;

	            default:
	              isLegMappable = false;
	              break;
	          }
	        } catch (err) {
	          console.log("LegsProcedure: Unexpected unmappable leg: ".concat(err));
	        }

	        if (mappedLeg !== undefined) {
	          const magCorrection = this.getMagCorrection(currentLeg);

	          if (this.approachType === ApproachType.APPROACH_TYPE_ILS && (currentLeg.fixTypeFlags & FixTypeFlags.FAF) > 0) {
	            if (currentLeg.altDesc === AltitudeDescriptor.At) {
	              mappedLeg.legAltitudeDescription = AltitudeDescriptor.G;
	            } else {
	              mappedLeg.legAltitudeDescription = AltitudeDescriptor.H;
	            }
	          } else {
	            mappedLeg.legAltitudeDescription = currentLeg.altDesc;
	          }

	          mappedLeg.legAltitude1 = currentLeg.altitude1 * 3.28084;
	          mappedLeg.legAltitude2 = currentLeg.altitude2 * 3.28084;
	          mappedLeg.speedConstraint = currentLeg.speedRestriction;
	          mappedLeg.turnDirection = currentLeg.turnDirection;

	          const recNavaid = this._facilities.get(currentLeg.originIcao);

	          mappedLeg.additionalData.legType = currentLeg.type;
	          mappedLeg.additionalData.overfly = currentLeg.flyOver;
	          mappedLeg.additionalData.fixTypeFlags = currentLeg.fixTypeFlags;
	          mappedLeg.additionalData.distance = currentLeg.distanceMinutes ? undefined : currentLeg.distance / 1852;
	          mappedLeg.additionalData.distanceInMinutes = currentLeg.distanceMinutes ? currentLeg.distance : undefined;
	          mappedLeg.additionalData.course = currentLeg.trueDegrees ? currentLeg.course : A32NX_Util.magneticToTrue(currentLeg.course, magCorrection);
	          mappedLeg.additionalData.recommendedIcao = currentLeg.originIcao.trim().length > 0 ? currentLeg.originIcao : undefined;
	          mappedLeg.additionalData.recommendedFrequency = recNavaid ? recNavaid.freqMHz : undefined;
	          mappedLeg.additionalData.recommendedLocation = recNavaid ? {
	            lat: recNavaid.lat,
	            long: recNavaid.lon
	          } : undefined;
	          mappedLeg.additionalData.rho = currentLeg.rho / 1852;
	          mappedLeg.additionalData.theta = currentLeg.theta;
	          mappedLeg.additionalData.thetaTrue = A32NX_Util.magneticToTrue(currentLeg.theta, magCorrection);
	          mappedLeg.additionalData.annotation = currentAnnotation;
	        }

	        this._currentIndex++;
	      }
	    }

	    if (mappedLeg !== undefined) {
	      this._previousFix = mappedLeg;
	      return mappedLeg;
	    }

	    return undefined;
	  }

	  getMagCorrection(currentLeg) {
	    // we try to interpret PANS OPs as accurately as possible within the limits of available data
	    // magnetic tracks to/from a VOR always use VOR station declination
	    if (currentLeg.fixIcao.charAt(0) === 'V') {
	      const vor = this._facilities.get(currentLeg.fixIcao);

	      if (!vor || vor.magneticVariation === undefined) {
	        console.warn('Leg coded incorrectly (missing vor fix or station declination)', currentLeg, vor);
	        return this.airportMagVar;
	      }

	      return 360 - vor.magneticVariation;
	    } // we use station declination for VOR/DME approaches


	    if (this.approachType === ApproachType.APPROACH_TYPE_VORDME) {
	      // find a leg with the reference navaid for the procedure
	      for (let i = this._legs.length - 1; i >= 0; i--) {
	        if (this._legs[i].originIcao.trim().length > 0) {
	          const recNavaid = this._facilities.get(currentLeg.originIcao);

	          if (recNavaid && recNavaid.magneticVariation !== undefined) {
	            return 360 - recNavaid.magneticVariation;
	          }
	        }
	      }

	      console.warn('VOR/DME approach coded incorrectly (missing recommended navaid or station declination)', currentLeg);
	      return this.airportMagVar;
	    } // for RNAV procedures use recommended navaid station declination for these leg types


	    let useStationDeclination = currentLeg.type === LegType.CF || currentLeg.type === LegType.FA || currentLeg.type === LegType.FM; // for localiser bearings (i.e. at or beyond FACF), always use airport value

	    if (this.approachType === ApproachType.APPROACH_TYPE_ILS || this.approachType === ApproachType.APPROACH_TYPE_LOCALIZER) {
	      useStationDeclination = useStationDeclination && this._legs.indexOf(currentLeg) < this.getFacfIndex();
	    }

	    if (useStationDeclination) {
	      const recNavaid = this._facilities.get(currentLeg.originIcao);

	      if (!recNavaid || recNavaid.magneticVariation === undefined) {
	        console.warn('Leg coded incorrectly (missing recommended navaid or station declination)', currentLeg, recNavaid);
	        return this.airportMagVar;
	      }

	      return 360 - recNavaid.magneticVariation;
	    } // for all other terminal procedure legs we use airport magnetic variation


	    return this.airportMagVar;
	  }

	  getFacfIndex() {
	    if (this.approachType !== undefined) {
	      for (let i = this._legs.length - 1; i >= 0; i--) {
	        if (this._legs[i].fixTypeFlags & FixTypeFlags.IF) {
	          return i;
	        }
	      }
	    }

	    return undefined;
	  }
	  /**
	   * Maps a heading until distance from origin leg.
	   * @param leg The procedure leg to map.
	   * @param prevLeg The previously mapped waypoint in the procedure.
	   * @returns The mapped leg.
	   */


	  mapHeadingUntilDistanceFromOrigin(leg, prevLeg) {
	    const origin = this._facilities.get(leg.originIcao);

	    const originIdent = origin.icao.substring(7, 12).trim();
	    const bearingToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
	    const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon)) / LegsProcedure.distanceNormalFactorNM;
	    const deltaAngle = this.deltaAngleRadians(bearingToOrigin, leg.course);
	    const targetDistance = leg.distance / 1852 / LegsProcedure.distanceNormalFactorNM;
	    const distanceAngle = Math.asin(Math.sin(distanceToOrigin) * Math.sin(deltaAngle) / Math.sin(targetDistance));
	    const inverseDistanceAngle = Math.PI - distanceAngle;
	    const legDistance1 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + distanceAngle)) / Math.sin(0.5 * (deltaAngle - distanceAngle))));
	    const legDistance2 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + inverseDistanceAngle)) / Math.sin(0.5 * (deltaAngle - inverseDistanceAngle))));
	    const legDistance = targetDistance > distanceToOrigin ? legDistance1 : Math.min(legDistance1, legDistance2);
	    const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, legDistance * LegsProcedure.distanceNormalFactorNM, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const waypoint = this.buildWaypoint("".concat(originIdent.substring(0, 3), "/").concat(Math.round(leg.distance / 1852).toString().padStart(2, '0')), coordinates);
	    return waypoint;
	  }
	  /**
	   * Maps an FC or FD leg in the procedure.
	   * @note FC and FD legs are mapped to CF legs in the real FMS
	   * @todo move the code into the CF leg (maybe static functions fromFc and fromFd to construct the leg)
	   * @todo FD should overfly the termination... needs a messy refactor to do that
	   * @param leg The procedure leg to map.
	   * @returns The mapped leg.
	   */


	  mapBearingAndDistanceFromOrigin(leg) {
	    const origin = this._facilities.get(leg.fixIcao);

	    const originIdent = origin.icao.substring(7, 12).trim();
	    const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, Facilities.getMagVar(origin.lat, origin.lon)); // this is the leg length for FC, and the DME distance for FD

	    const refDistance = leg.distance / 1852;
	    let termPoint;
	    let legLength;

	    if (leg.type === LegType.FD) {
	      const recNavaid = this._facilities.get(leg.originIcao);

	      termPoint = firstSmallCircleIntersection({
	        lat: recNavaid.lat,
	        long: recNavaid.lon
	      }, refDistance, {
	        lat: origin.lat,
	        long: origin.lon
	      }, course);
	      legLength = Avionics.Utils.computeGreatCircleDistance({
	        lat: origin.lat,
	        long: origin.lon
	      }, termPoint);
	    } else {
	      // FC
	      termPoint = Avionics.Utils.bearingDistanceToCoordinates(course, refDistance, origin.lat, origin.lon);
	      legLength = refDistance;
	    }

	    return this.buildWaypoint("".concat(originIdent.substring(0, 3), "/").concat(Math.round(legLength).toString().padStart(2, '0')), termPoint);
	  }
	  /**
	   * Maps a radial on the origin for a specified distance leg in the procedure.
	   * @param leg The procedure leg to map.
	   * @param prevLeg The previously mapped leg.
	   * @returns The mapped leg.
	   */


	  mapOriginRadialForDistance(leg, prevLeg) {
	    if (leg.fixIcao.trim() !== '') {
	      return this.mapExactFix(leg);
	    }

	    const origin = this._facilities.get(leg.originIcao);

	    const originIdent = origin.icao.substring(7, 12).trim();
	    const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, leg.distance / 1852, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const distanceFromOrigin = Avionics.Utils.computeGreatCircleDistance(new LatLongAlt(origin.lat, origin.lon), coordinates);
	    return this.buildWaypoint("".concat(originIdent).concat(Math.trunc(distanceFromOrigin / 1852)), coordinates);
	  }
	  /**
	   * Maps a heading turn to intercept the next leg in the procedure.
	   * @param leg The procedure leg to map.
	   * @param prevLeg The previously mapped leg.
	   * @param nextLeg The next leg in the procedure to intercept.
	   * @returns The mapped leg.
	   */


	  mapHeadingToInterceptNextLeg(leg, prevLeg, nextLeg) {
	    const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
	    const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
	    const waypoint = this.buildWaypoint(FixNamingScheme.courseToIntercept(course), coordinates, prevLeg.infos.magneticVariation);
	    return waypoint;
	  }
	  /**
	   * Maps flying a heading until crossing a radial of a reference fix.
	   * @param leg The procedure leg to map.
	   * @param prevLeg The previously mapped leg.
	   * @returns The mapped leg.
	   */


	  mapHeadingUntilRadialCrossing(leg, prevLeg) {
	    const origin = this._facilities.get(leg.originIcao);

	    const originCoordinates = new LatLongAlt(origin.lat, origin.lon);
	    const originToCoordinates = Avionics.Utils.computeGreatCircleHeading(originCoordinates, prevLeg.infos.coordinates);
	    const coordinatesToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
	    const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, originCoordinates) / LegsProcedure.distanceNormalFactorNM;
	    const alpha = this.deltaAngleRadians(coordinatesToOrigin, leg.course);
	    const beta = this.deltaAngleRadians(originToCoordinates, leg.theta);
	    const gamma = Math.acos(Math.sin(alpha) * Math.sin(beta) * Math.cos(distanceToOrigin) - Math.cos(alpha) * Math.cos(beta));
	    const legDistance = Math.acos((Math.cos(beta) + Math.cos(alpha) * Math.cos(gamma)) / (Math.sin(alpha) * Math.sin(gamma)));
	    const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
	    const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, legDistance * LegsProcedure.distanceNormalFactorNM, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const waypoint = this.buildWaypoint("".concat(this.getIdent(origin.icao)).concat(leg.theta), coordinates);
	    return waypoint;
	  }
	  /**
	   * Maps flying a heading until a proscribed altitude.
	   * @param leg The procedure leg to map.
	   * @param prevLeg The previous leg in the procedure.
	   * @returns The mapped leg.
	   */


	  mapHeadingUntilAltitude(leg, prevLeg) {
	    const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
	    leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course;
	    const altitudeFeet = leg.altitude1 * 3.2808399;
	    const distanceInNM = altitudeFeet / 500.0;
	    const coordinates = GeoMath.relativeBearingDistanceToCoords(course, distanceInNM, prevLeg.infos.coordinates);
	    const waypoint = this.buildWaypoint(FixNamingScheme.headingUntilAltitude(altitudeFeet), coordinates, prevLeg.infos.magneticVariation);
	    waypoint.additionalData.vectorsAltitude = altitudeFeet;
	    return waypoint;
	  }
	  /**
	   * Maps a vectors instruction.
	   * @param leg The procedure leg to map.
	   * @param prevLeg The previous leg in the procedure.
	   * @returns The mapped leg.
	   */


	  mapVectors(leg, prevLeg) {
	    const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
	    const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
	    leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course;
	    const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
	    const waypoint = this.buildWaypoint(FixNamingScheme.vector(), coordinates);
	    waypoint.isVectors = true;
	    waypoint.endsInDiscontinuity = true;
	    waypoint.discontinuityCanBeCleared = false;
	    return waypoint;
	  }
	  /**
	   * Maps an exact fix leg in the procedure.
	   * @param leg The procedure leg to map.
	   * @returns The mapped leg.
	   */


	  mapExactFix(leg) {
	    const facility = this._facilities.get(leg.fixIcao);

	    return RawDataMapper.toWaypoint(facility, this._instrument);
	  }

	  mapArcToFix(leg, prevLeg) {
	    const toFix = this._facilities.get(leg.fixIcao);

	    const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
	    return waypoint;
	  }

	  mapRadiusToFix(leg) {
	    const arcCentreFix = this._facilities.get(leg.arcCenterFixIcao);

	    const arcCenterCoordinates = new LatLongAlt(arcCentreFix.lat, arcCentreFix.lon, 0);

	    const toFix = this._facilities.get(leg.fixIcao);

	    const toCoordinates = new LatLongAlt(toFix.lat, toFix.lon, 0);
	    const radius = Avionics.Utils.computeGreatCircleDistance(arcCenterCoordinates, toCoordinates);
	    const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
	    waypoint.additionalData.radius = radius;
	    waypoint.additionalData.center = arcCenterCoordinates;
	    return waypoint;
	  }

	  mapHold(leg) {
	    const facility = this._facilities.get(leg.fixIcao);

	    const waypoint = RawDataMapper.toWaypoint(facility, this._instrument);
	    const magVar = Facilities.getMagVar(facility.lat, facility.lon);
	    waypoint.additionalData.defaultHold = {
	      inboundMagneticCourse: leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course,
	      turnDirection: leg.turnDirection,
	      distance: leg.distanceMinutes ? undefined : leg.distance / 1852,
	      time: leg.distanceMinutes ? leg.distance : undefined,
	      type: HoldType.Database
	    };
	    waypoint.additionalData.modifiedHold = {};
	    return waypoint;
	  }
	  /**
	   * Gets the difference between two headings in zero north normalized radians.
	   * @param a The degrees of heading a.
	   * @param b The degrees of heading b.
	   * @returns The difference between the two headings in zero north normalized radians.
	   */


	  deltaAngleRadians(a, b) {
	    return Math.abs((Avionics.Utils.fmod(a - b + 180, 360) - 180) * Avionics.Utils.DEG2RAD);
	  }
	  /**
	   * Gets an ident from an ICAO.
	   * @param icao The icao to pull the ident from.
	   * @returns The parsed ident.
	   */


	  getIdent(icao) {
	    return icao.substring(7, 12).trim();
	  }
	  /**
	   * Checks if an ICAO is valid to load.
	   * @param icao The icao to check.
	   * @returns Whether or not the ICAO is valid.
	   */


	  isIcaoValid(icao) {
	    for (const rule of this.legFilteringRules) {
	      if (!rule(icao)) {
	        return false;
	      }
	    }

	    return true;
	  }
	  /**
	   * Builds a WayPoint from basic data.
	   * @param ident The ident of the waypoint.
	   * @param coordinates The coordinates of the waypoint.
	   * @param magneticVariation The magnetic variation of the waypoint, if any.
	   * @returns The built waypoint.
	   */


	  buildWaypoint(ident, coordinates, magneticVariation) {
	    const waypoint = new WayPoint(this._instrument);
	    waypoint.type = 'W';
	    waypoint.infos = new IntersectionInfo(this._instrument);
	    waypoint.infos.coordinates = coordinates;
	    waypoint.infos.magneticVariation = magneticVariation;
	    waypoint.ident = ident;
	    waypoint.infos.ident = ident;
	    waypoint.additionalData = {};
	    return waypoint;
	  }

	  async calculateApproachData(runway) {
	    await this.ensureFacilitiesLoaded(); // our fallback for threshold crossing altitude is threshold + 50 feet

	    let threshCrossAlt = runway.thresholdElevation + 15.24; // if the last waypoint is the MAP, use its altitude instead

	    if (this._legs[this._legs.length - 1].fixTypeFlags & FixTypeFlags.MAP) {
	      threshCrossAlt = this._legs[this._legs.length - 1].altitude1;
	    } // see if we have a runway fix, to give us coded TCH
	    // it can either be the MAP, or be before the MAP (MAP must be last leg of final approach)
	    // TCH altitude must be coded in altitude1 according to ARINC


	    for (let i = this._legs.length - 1; i > 0; i--) {
	      const leg = this._legs[i]; // TODO check it's the same runway for robustness?

	      if (leg.fixIcao.charAt(0) === 'R') {
	        threshCrossAlt = leg.altitude1;
	        break;
	      }
	    } // MSFS does not give the coded descent angle
	    // we do our best to calculate one...


	    let fafAlt;
	    let fafIndex;
	    let fafToTcaDist = 0;
	    let lastLegPoint;

	    for (let i = 0; i < this._legs.length; i++) {
	      const leg = this._legs[i];
	      let termPoint;

	      if (leg.fixIcao.charAt(0) === 'R') {
	        termPoint = runway.thresholdCoordinates;
	      } else {
	        const fix = this._facilities.get(leg.fixIcao);

	        termPoint = new LatLongAlt(fix.lat, fix.lon);
	      }

	      if (leg.fixTypeFlags & FixTypeFlags.FAF) {
	        if (leg.altDesc === AltitudeDescriptor.Empty) {
	          // this is illegal by ARINC
	          break;
	        }

	        fafIndex = i; // MSFS codes the wrong altDesc... but the right data...

	        fafAlt = leg.altitude2 > 0 ? leg.altitude2 : leg.altitude1;
	      } else if (fafIndex !== undefined) {
	        if (leg.distance > 0) {
	          fafToTcaDist += leg.distance;
	        } else {
	          // assume a straight leg
	          fafToTcaDist += 1852 * Avionics.Utils.computeGreatCircleDistance(lastLegPoint, termPoint);
	        }
	      }

	      if (leg.fixIcao.charAt(0) === 'R') {
	        break;
	      }

	      lastLegPoint = termPoint;
	    }

	    if (fafIndex !== undefined && fafAlt > 0 && fafToTcaDist > 0) {
	      let glideAngle = Math.atan((fafAlt - threshCrossAlt) / fafToTcaDist) * 180 / Math.PI; // arinc specifics < 3 degrees is rounded up to 3 degrees when calculating glide angle from alt sources
	      // we do the same if we have invalid data..

	      if (!Number.isFinite(glideAngle) || glideAngle < 3 || glideAngle > 10) {
	        glideAngle = 3;
	      }

	      for (let i = fafIndex + 1; i < this._legs.length; i++) {
	        this._legs[i].verticalAngle = glideAngle;
	      }
	    }
	  }

	}

	_defineProperty(LegsProcedure, "distanceNormalFactorNM", 21639 / 2 * Math.PI);

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/**
	 * Methods for interacting with the FS9GPS subsystem.
	 */
	class GPS {
	  /**
	  * Clears the FS9GPS flight plan.
	  */
	  static async clearPlan() {
	    const totalGpsWaypoints = SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointsNumber', 'number');

	    for (let i = 0; i < totalGpsWaypoints; i++) {
	      // Always remove waypoint 0 here, which shifts the rest of the waypoints down one
	      GPS.deleteWaypoint(0).catch(console.error);
	    }
	  }
	  /**
	  * Adds a waypoint to the FS9GPS flight plan by ICAO designation.
	  * @param icao The MSFS ICAO to add to the flight plan.
	  * @param index The index of the waypoint to add in the flight plan.
	  */


	  static async addIcaoWaypoint(icao, index) {
	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointICAO', 'string', icao).catch(console.error);
	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanAddWaypoint', 'number', index).catch(console.error);
	  }
	  /**
	  * Adds a user waypoint to the FS9GPS flight plan.
	  * @param lat The latitude of the user waypoint.
	  * @param lon The longitude of the user waypoint.
	  * @param index The index of the waypoint to add in the flight plan.
	  * @param ident The ident of the waypoint.
	  */


	  static async addUserWaypoint(lat, lon, index, ident) {
	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointLatitude', 'degrees', lat).catch(console.error);
	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointLongitude', 'degrees', lon).catch(console.error);

	    if (ident) {
	      await SimVar.SetSimVarValue('C:fs9gps:FlightPlanNewWaypointIdent', 'string', ident).catch(console.error);
	    }

	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanAddWaypoint', 'number', index).catch(console.error);
	  }
	  /**
	  * Deletes a waypoint from the FS9GPS flight plan.
	  * @param index The index of the waypoint in the flight plan to delete.
	  */


	  static async deleteWaypoint(index) {
	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanDeleteWaypoint', 'number', index).catch(console.error);
	  }
	  /**
	  * Sets the active FS9GPS waypoint.
	  * @param {Number} index The index of the waypoint to set active.
	  */


	  static async setActiveWaypoint(index) {
	    await SimVar.SetSimVarValue('C:fs9gps:FlightPlanActiveWaypoint', 'number', index).catch(console.error);
	  }
	  /**
	  * Gets the active FS9GPS waypoint.
	  */


	  static getActiveWaypoint() {
	    return SimVar.GetSimVarValue('C:fs9gps:FlightPlanActiveWaypoint', 'number');
	  }
	  /**
	  * Logs the current FS9GPS flight plan.
	  */


	  static async logCurrentPlan() {
	    const waypointIdents = [];
	    const totalGpsWaypoints = SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointsNumber', 'number');

	    for (let i = 0; i < totalGpsWaypoints; i++) {
	      SimVar.SetSimVarValue('C:fs9gps:FlightPlanWaypointIndex', 'number', i);
	      waypointIdents.push(SimVar.GetSimVarValue('C:fs9gps:FlightPlanWaypointIdent', 'string'));
	    }

	    console.log("GPS Plan: ".concat(waypointIdents.join(' ')));
	  }

	}

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/**
	 * The details of procedures selected in the flight plan.
	 */
	class ProcedureDetails {
	  constructor() {
	    _defineProperty(this, "originRunwayIndex", -1);

	    _defineProperty(this, "departureIndex", -1);

	    _defineProperty(this, "departureTransitionIndex", -1);

	    _defineProperty(this, "departureRunwayIndex", -1);

	    _defineProperty(this, "arrivalIndex", -1);

	    _defineProperty(this, "arrivalTransitionIndex", -1);

	    _defineProperty(this, "arrivalRunwayIndex", -1);

	    _defineProperty(this, "approachIndex", -1);

	    _defineProperty(this, "approachTransitionIndex", -1);

	    _defineProperty(this, "destinationRunwayIndex", -1);

	    _defineProperty(this, "destinationRunwayExtension", -1);

	    _defineProperty(this, "approachType", void 0);
	  }

	}

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/**
	 * Information about the current direct-to procedures in the flight plan.
	 */
	class DirectTo {
	  constructor() {
	    _defineProperty(this, "waypointIsInFlightPlan", false);

	    _defineProperty(this, "isActive", false);

	    _defineProperty(this, "waypoint", void 0);

	    _defineProperty(this, "planWaypointIndex", 0);

	    _defineProperty(this, "interceptPoints", void 0);

	    _defineProperty(this, "currentWaypointIndex", 0);

	    _defineProperty(this, "segments", void 0);
	  }

	}

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	/**
	 * Creating a new waypoint to be added to a flight plan.
	 */

	class WaypointBuilder {
	  /**
	  * Builds a WayPoint from basic data.
	  * @param ident The ident of the waypoint to be created.
	  * @param coordinates The coordinates of the waypoint.
	  * @param instrument The base instrument instance.
	  * @returns The built waypoint.
	  */
	  static fromCoordinates(ident, coordinates, instrument, additionalData, icao) {
	    const waypoint = new WayPoint(instrument);
	    waypoint.type = 'W';
	    waypoint.infos = new IntersectionInfo(instrument);
	    waypoint.infos.coordinates = coordinates;
	    waypoint.ident = ident;
	    waypoint.infos.ident = ident;
	    waypoint.icao = icao !== null && icao !== void 0 ? icao : "W      ".concat(ident);
	    waypoint.infos.icao = waypoint.icao;
	    waypoint.additionalData = additionalData !== null && additionalData !== void 0 ? additionalData : {};
	    return waypoint;
	  }
	  /**
	  * Builds a WayPoint from a refrence waypoint.
	  * @param ident The ident of the waypoint to be created.
	  * @param placeCoordinates The coordinates of the reference waypoint.
	  * @param bearing The bearing from the reference waypoint.
	  * @param distance The distance from the reference waypoint.
	  * @param instrument The base instrument instance.
	  * @returns The built waypoint.
	  */


	  static fromPlaceBearingDistance(ident, placeCoordinates, bearing, distance, instrument) {
	    let magneticBearing = bearing + GeoMath.getMagvar(placeCoordinates.lat, placeCoordinates.long);
	    magneticBearing = magneticBearing < 0 ? 360 + magneticBearing : magneticBearing;
	    const coordinates = Avionics.Utils.bearingDistanceToCoordinates(magneticBearing, distance, placeCoordinates.lat, placeCoordinates.long);
	    return WaypointBuilder.fromCoordinates(ident, coordinates, instrument);
	  }
	  /**
	  * Builds a WayPoint at a distance from an existing waypoint along the flight plan.
	  * @param ident The ident of the waypoint to be created.
	  * @param placeIndex The index of the reference waypoint in the flight plan.
	  * @param distance The distance from the reference waypoint.
	  * @param instrument The base instrument instance.
	  * @param fpm The flightplanmanager instance.
	  * @returns The built waypoint.
	  */


	  static fromPlaceAlongFlightPlan(ident, placeIndex, distance, instrument, fpm) {
	    console.log('running fromPlaceAlongFlightPlan');
	    console.log("destination? ".concat(fpm.getDestination()) ? 'True' : 'False');
	    const destinationDistanceInFlightplan = fpm.getDestination().cumulativeDistanceInFP;
	    console.log("destinationDistanceInFlightplan ".concat(destinationDistanceInFlightplan));
	    const placeDistanceFromDestination = fpm.getWaypoint(placeIndex, 0, true).cumulativeDistanceInFP;
	    console.log("placeDistanceFromDestination ".concat(placeDistanceFromDestination));
	    const distanceFromDestination = destinationDistanceInFlightplan - placeDistanceFromDestination - distance;
	    console.log("distanceFromDestination ".concat(distanceFromDestination));
	    const coordinates = fpm.getCoordinatesAtNMFromDestinationAlongFlightPlan(distanceFromDestination);
	    return WaypointBuilder.fromCoordinates(ident, coordinates, instrument);
	  }

	  static fromWaypointManualHold(waypoint, holdDirection, inboundCourse, holdLength, holdTime, instrument) {
	    const newWaypoint = WaypointBuilder.fromCoordinates(waypoint.ident, waypoint.infos.coordinates, instrument);
	    newWaypoint.icao = waypoint.icao;
	    newWaypoint.infos = waypoint.infos;
	    newWaypoint.additionalData.legType = LegType.HM;
	    newWaypoint.turnDirection = holdDirection;
	    newWaypoint.additionalData.course = inboundCourse;
	    newWaypoint.additionalData.distance = holdLength;
	    newWaypoint.additionalData.distanceInMinutes = holdTime;
	    newWaypoint.speedConstraint = waypoint.speedConstraint;
	    newWaypoint.legAltitudeDescription = waypoint.legAltitudeDescription;
	    newWaypoint.legAltitude1 = waypoint.legAltitude1;
	    newWaypoint.legAltitude2 = waypoint.legAltitude2;
	    newWaypoint.additionalData.constraintType = waypoint.additionalData.constraintType;
	    return newWaypoint;
	  }

	}

	function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	/**
	 * A flight plan managed by the FlightPlanManager.
	 */

	class ManagedFlightPlan {
	  constructor() {
	    _defineProperty(this, "originAirfield", void 0);

	    _defineProperty(this, "persistentOriginAirfield", void 0);

	    _defineProperty(this, "originTransitionAltitudeDb", void 0);

	    _defineProperty(this, "originTransitionAltitudePilot", void 0);

	    _defineProperty(this, "destinationAirfield", void 0);

	    _defineProperty(this, "destinationTransitionLevelDb", void 0);

	    _defineProperty(this, "destinationTransitionLevelPilot", void 0);

	    _defineProperty(this, "cruiseAltitude", 0);

	    _defineProperty(this, "activeWaypointIndex", 0);

	    _defineProperty(this, "procedureDetails", new ProcedureDetails());

	    _defineProperty(this, "directTo", new DirectTo());

	    _defineProperty(this, "turningPointIndex", 0);

	    _defineProperty(this, "_parentInstrument", void 0);

	    _defineProperty(this, "_segments", [new FlightPlanSegment(SegmentType.Enroute, 0, [])]);
	  }

	  /** The departure segment of the flight plan. */
	  get departure() {
	    return this.getSegment(SegmentType.Departure);
	  }
	  /** The enroute segment of the flight plan. */


	  get enroute() {
	    return this.getSegment(SegmentType.Enroute);
	  }
	  /** The arrival segment of the flight plan. */


	  get arrival() {
	    return this.getSegment(SegmentType.Arrival);
	  }
	  /** The approach segment of the flight plan. */


	  get approach() {
	    return this.getSegment(SegmentType.Approach);
	  }
	  /** The approach segment of the flight plan. */


	  get missed() {
	    return this.getSegment(SegmentType.Missed);
	  }
	  /** Whether the flight plan has an origin airfield. */


	  get hasOrigin() {
	    return this.originAirfield;
	  }
	  /** Whether the flight plan has a persistent origin airfield. */


	  get hasPersistentOrigin() {
	    return this.persistentOriginAirfield;
	  }
	  /** Whether the flight plan has a destination airfield. */


	  get hasDestination() {
	    return this.destinationAirfield;
	  }
	  /** The currently active waypoint. */


	  get activeWaypoint() {
	    return this.waypoints[this.activeWaypointIndex];
	  }
	  /**
	   * Returns a list of {@link WaypointStats} for the waypoints in the flight plan
	   *
	   * @return {WaypointStats[]} array of statistics for the waypoints in the flight plan, with matching indices to
	   *                           flight plan waypoints
	   */


	  computeWaypointStatistics(ppos) {
	    // TODO this should be moved into its own dedicated module
	    const stats = new Map();
	    const firstData = this.computeActiveWaypointStatistics(ppos);
	    stats.set(this.activeWaypointIndex, firstData);
	    this.waypoints.slice(0).forEach((waypoint, index) => {
	      var _firstData$distanceFr, _this$activeWaypoint$, _this$activeWaypoint;

	      // TODO redo when we have a better solution for vector legs
	      const firstDistFromPpos = (_firstData$distanceFr = firstData === null || firstData === void 0 ? void 0 : firstData.distanceFromPpos) !== null && _firstData$distanceFr !== void 0 ? _firstData$distanceFr : 0;
	      const activeWpCumulativeDist = (_this$activeWaypoint$ = (_this$activeWaypoint = this.activeWaypoint) === null || _this$activeWaypoint === void 0 ? void 0 : _this$activeWaypoint.cumulativeDistanceInFP) !== null && _this$activeWaypoint$ !== void 0 ? _this$activeWaypoint$ : 0;
	      const distPpos = waypoint.isVectors ? 1 : waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos;
	      const data = {
	        ident: waypoint.ident,
	        bearingInFp: waypoint.bearingInFP,
	        distanceInFP: waypoint.distanceInFP,
	        distanceFromPpos: distPpos,
	        timeFromPpos: this.computeWaypointTime(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos),
	        etaFromPpos: this.computeWaypointEta(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos)
	      };
	      stats.set(index, data);
	    });
	    return stats;
	  }
	  /**
	   * Returns info for the currently active waypoint, to be displayed by the Navigation Display
	   */


	  computeActiveWaypointStatistics(ppos) {
	    // TODO this should be moved into its own dedicated module
	    if (!this.activeWaypoint) {
	      return undefined;
	    }

	    const bearingInFp = Avionics.Utils.computeGreatCircleHeading(ppos, this.activeWaypoint.infos.coordinates);
	    let distanceFromPpos;

	    if (Number.isNaN(ppos.lat) || Number.isNaN(ppos.long)) {
	      distanceFromPpos = this.activeWaypoint.distanceInFP;
	    } else if (this.activeWaypoint.isVectors) {
	      // TODO redo when we have a better solution for vector legs
	      distanceFromPpos = 1;
	    } else {
	      distanceFromPpos = Avionics.Utils.computeGreatCircleDistance(ppos, this.activeWaypoint.infos.coordinates);
	    }

	    const timeFromPpos = this.computeWaypointTime(distanceFromPpos);
	    const etaFromPpos = this.computeWaypointEta(distanceFromPpos, timeFromPpos);
	    return {
	      ident: this.activeWaypoint.ident,
	      bearingInFp,
	      distanceInFP: this.activeWaypoint.distanceInFP,
	      distanceFromPpos,
	      timeFromPpos,
	      etaFromPpos,
	      magneticVariation: GeoMath.getMagvar(this.activeWaypoint.infos.coordinates.lat, this.activeWaypoint.infos.coordinates.long)
	    };
	  } // TODO is this accurate? Logic is same like in the old FPM


	  computeWaypointTime(distance) {
	    const groundSpeed = Simplane.getGroundSpeed();

	    if (groundSpeed < 100) {
	      return distance / 400 * 3600;
	    }

	    return distance / groundSpeed * 3600;
	  }

	  computeWaypointEta(distance, preComputedTime) {
	    const eta = preComputedTime !== null && preComputedTime !== void 0 ? preComputedTime : this.computeWaypointTime(distance);
	    const utcTime = SimVar.GetGlobalVarValue('ZULU TIME', 'seconds'); // // console.log(`BRUHEGG: ${utcTime}, BRUHHH #2: ${eta}`);

	    return eta + utcTime;
	  }
	  /** The parent instrument this flight plan is attached to locally. */


	  /** The waypoints of the flight plan. */
	  get waypoints() {
	    const waypoints = [];

	    if (this.originAirfield) {
	      waypoints.push(this.originAirfield);
	    }

	    for (const segment of this._segments) {
	      waypoints.push(...segment.waypoints);
	    }

	    if (this.destinationAirfield) {
	      waypoints.push(this.destinationAirfield);
	    }

	    return waypoints;
	  }
	  /**
	   * Gets all the waypoints that are currently visible and part of the routing.
	   *
	   * This is used to obtain the list of waypoints to display after a DIRECT TO.
	   */


	  get visibleWaypoints() {
	    const allWaypoints = this.waypoints;

	    if (this.directTo.isActive) {
	      const directToWaypointIndex = this.directTo.planWaypointIndex;
	      return allWaypoints.slice(Math.max(this.activeWaypointIndex - 1, directToWaypointIndex), allWaypoints.length - 1);
	    }

	    return allWaypoints.slice(this.activeWaypointIndex - 1, allWaypoints.length);
	  }

	  get activeVisibleWaypointIndex() {
	    if (this.directTo.isActive) {
	      const directToWaypointIndex = this.directTo.planWaypointIndex;
	      return this.activeWaypointIndex - 1 > directToWaypointIndex ? 1 : 0;
	    }

	    return 1;
	  }

	  get segments() {
	    return this._segments;
	  }
	  /** The length of the flight plan. */


	  get length() {
	    const lastSeg = this._segments[this._segments.length - 1];
	    return lastSeg.offset + lastSeg.waypoints.length + (this.hasDestination ? 1 : 0);
	  }

	  get checksum() {
	    let checksum = 0;
	    const {
	      waypoints
	    } = this;

	    for (let i = 0; i < waypoints.length; i++) checksum += waypoints[i].infos.coordinates.lat;

	    return checksum;
	  }
	  /** The non-approach waypoints of the flight plan. */


	  get nonApproachWaypoints() {
	    const waypoints = [];

	    if (this.originAirfield) {
	      waypoints.push(this.originAirfield);
	    }

	    for (const segment of this._segments.filter(s => s.type < SegmentType.Approach)) {
	      waypoints.push(...segment.waypoints);
	    }

	    if (this.destinationAirfield) {
	      waypoints.push(this.destinationAirfield);
	    }

	    return waypoints;
	  }
	  /**
	   * Sets the parent instrument that the flight plan is attached to locally.
	   * @param instrument The instrument that the flight plan is attached to.
	   */


	  setParentInstrument(instrument) {
	    this._parentInstrument = instrument;
	  }
	  /**
	   * Clears the flight plan.
	   */


	  async clearPlan() {
	    this.originAirfield = undefined;
	    this.originTransitionAltitudeDb = undefined;
	    this.originTransitionAltitudePilot = undefined;
	    this.persistentOriginAirfield = undefined;
	    this.destinationAirfield = undefined;
	    this.destinationTransitionLevelDb = undefined;
	    this.destinationTransitionLevelPilot = undefined;
	    this.cruiseAltitude = 0;
	    this.activeWaypointIndex = 0;
	    this.procedureDetails = new ProcedureDetails();
	    this.directTo = new DirectTo();
	    await GPS.clearPlan().catch(console.error);
	    this._segments = [new FlightPlanSegment(SegmentType.Enroute, 0, [])];
	  }
	  /**
	   * Syncs the flight plan to FS9GPS.
	   */


	  async syncToGPS() {
	    await GPS.clearPlan().catch(console.error);

	    for (let i = 0; i < this.waypoints.length; i++) {
	      const waypoint = this.waypoints[i];

	      if (waypoint.icao && waypoint.icao.trim() !== '') {
	        GPS.addIcaoWaypoint(waypoint.icao, i).catch(console.error);
	      } else {
	        GPS.addUserWaypoint(waypoint.infos.coordinates.lat, waypoint.infos.coordinates.long, i, waypoint.ident).catch(console.error);
	      }

	      if (waypoint.endsInDiscontinuity) {
	        break;
	      }
	    }

	    await GPS.setActiveWaypoint(this.activeWaypointIndex).catch(console.error);
	    await GPS.logCurrentPlan().catch(console.error);
	  }
	  /**
	   * Adds a waypoint to the flight plan.
	   *
	   * @param waypoint    The waypoint to add
	   *
	   * @param index       The index to add the waypoint at. If omitted the waypoint will
	   *                    be appended to the end of the flight plan.
	   *
	   * @param segmentType The type of segment to add the waypoint to
	   * @returns The index the waypoint was actually inserted at
	   */


	  addWaypoint(waypoint, index, segmentType) {
	    console.log('addWaypoint', waypoint, index, SegmentType[segmentType]);
	    const mappedWaypoint = waypoint instanceof WayPoint ? waypoint : RawDataMapper.toWaypoint(waypoint, this._parentInstrument);

	    if (mappedWaypoint.type === 'A' && index === 0) {
	      mappedWaypoint.endsInDiscontinuity = true;
	      mappedWaypoint.discontinuityCanBeCleared = true;
	      this.originAirfield = mappedWaypoint;
	      this.persistentOriginAirfield = mappedWaypoint;
	      this.procedureDetails.departureIndex = -1;
	      this.procedureDetails.departureRunwayIndex = -1;
	      this.procedureDetails.departureTransitionIndex = -1;
	      this.procedureDetails.originRunwayIndex = -1;
	      this.reflowSegments();
	      this.reflowDistances();
	    } else if (mappedWaypoint.type === 'A' && index === undefined) {
	      this.destinationAirfield = mappedWaypoint;
	      this.procedureDetails.arrivalIndex = -1;
	      this.procedureDetails.arrivalRunwayIndex = -1;
	      this.procedureDetails.arrivalTransitionIndex = -1;
	      this.procedureDetails.approachIndex = -1;
	      this.procedureDetails.approachTransitionIndex = -1;
	      this.reflowSegments();
	      this.reflowDistances();
	    } else {
	      let segment;

	      if (segmentType !== undefined) {
	        segment = this.getSegment(segmentType);

	        if (segment === FlightPlanSegment.Empty) {
	          segment = this.addSegment(segmentType);
	        }
	      } else {
	        segment = this.findSegmentByWaypointIndex(index);

	        if (segment === FlightPlanSegment.Empty) {
	          throw new Error('ManagedFlightPlan::addWaypoint: no segment found!');
	        }
	      } // hitting first waypoint in segment > enroute


	      if (segment.type > SegmentType.Enroute && index === segment.offset) {
	        const segIdx = this._segments.findIndex(seg => seg.type === segment.type); // is prev segment enroute?


	        const prevSeg = this._segments[segIdx - 1];

	        if (prevSeg.type === SegmentType.Enroute) {
	          segment = prevSeg;
	        }
	      }

	      if (segment) {
	        if (index > this.length) {
	          index = undefined;
	        }

	        if (mappedWaypoint.additionalData.legType === undefined) {
	          if (segment.waypoints.length < 1) {
	            mappedWaypoint.additionalData.legType = LegType.IF;
	          } else {
	            mappedWaypoint.additionalData.legType = LegType.TF;
	          }
	        }

	        if (index !== undefined) {
	          const segmentIndex = index - segment.offset;

	          if (segmentIndex < segment.waypoints.length) {
	            segment.waypoints.splice(segmentIndex, 0, mappedWaypoint);
	          } else {
	            segment.waypoints.push(mappedWaypoint);
	          }
	        } else {
	          segment.waypoints.push(mappedWaypoint);
	        }

	        this.reflowSegments();
	        this.reflowDistances();
	        const finalIndex = this.waypoints.indexOf(mappedWaypoint);
	        const previousWp = finalIndex > 0 ? this.waypoints[finalIndex - 1] : undefined; // Transfer discontinuity forwards if previous waypoint has one and it can be cleared,
	        // AND the new waypoint isn't the T-P of a direct to

	        if (previousWp && previousWp.endsInDiscontinuity && !mappedWaypoint.isTurningPoint) {
	          if (previousWp.discontinuityCanBeCleared === undefined || previousWp.discontinuityCanBeCleared) {
	            previousWp.endsInDiscontinuity = false;
	            previousWp.discontinuityCanBeCleared = undefined; // Don't mark the mapped waypoint's discontinuity as clearable if this is a MANUAL
	            // TODO maybe extract this logic since we also use it when building a LegsProcedure

	            mappedWaypoint.endsInDiscontinuity = true;

	            if (!mappedWaypoint.isVectors) {
	              mappedWaypoint.discontinuityCanBeCleared = true;
	            }
	          }
	        }

	        if (this.activeWaypointIndex === 0 && this.length > 1) {
	          this.activeWaypointIndex = 1;
	        } else if (this.activeWaypointIndex === 1 && waypoint.isRunway && segment.type === SegmentType.Departure) {
	          this.activeWaypointIndex = 2;
	        }

	        return finalIndex;
	      }
	    }

	    return -1;
	  }
	  /**
	   * Removes a waypoint from the flight plan.
	   * @param index The index of the waypoint to remove.
	   */


	  removeWaypoint(index) {
	    let noDiscontinuity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (this.originAirfield && index === 0) {
	      this.originAirfield = undefined;
	      this.reflowSegments();
	      this.reflowDistances();
	    } else if (this.destinationAirfield && index === this.length - 1) {
	      this.destinationAirfield = undefined;
	    } else {
	      const segment = this.findSegmentByWaypointIndex(index);

	      if (segment) {
	        // console.log("--> REMOVING WAYPOINT ", this.getWaypoint(index), ", FROM SEGMENT ", segment);
	        segment.waypoints.splice(index - segment.offset, 1);

	        if (segment.waypoints.length === 0 && segment.type !== SegmentType.Enroute) {
	          // console.log("SEGMENT LENGTH is 0, REMOVING...");
	          this.removeSegment(segment.type);
	        }

	        this.reflowSegments();
	        this.reflowDistances();
	      }
	    } // transfer a potential discontinuity backward


	    const beforeRemoved = this.waypoints[index - 1];

	    if (!noDiscontinuity && beforeRemoved && !beforeRemoved.endsInDiscontinuity) {
	      beforeRemoved.endsInDiscontinuity = true;
	      beforeRemoved.discontinuityCanBeCleared = true;
	    }

	    if (index < this.activeWaypointIndex || this.activeWaypointIndex === this.waypoints.length) {
	      this.activeWaypointIndex--;
	    }
	  }
	  /**
	   * Gets a waypoint by index from the flight plan.
	   * @param index The index of the waypoint to get.
	   */


	  getWaypoint(index) {
	    if (this.originAirfield && index === 0) {
	      return this.originAirfield;
	    }

	    if (this.destinationAirfield && index === this.length - 1) {
	      return this.destinationAirfield;
	    }

	    const segment = this.findSegmentByWaypointIndex(index);

	    if (segment) {
	      return segment.waypoints[index - segment.offset];
	    }

	    return null;
	  }

	  setWaypointOverfly(index, value) {
	    // FIXME origin airfield isn't necessarily index 0
	    if (this.originAirfield && index === 0) {
	      return;
	    } // FIXME origin airfield isn't necessarily last index (never will be with missed approach)


	    if (this.destinationAirfield && index === this.length - 1) {
	      return;
	    }

	    const segment = this.findSegmentByWaypointIndex(index);

	    if (segment) {
	      segment.waypoints[index - segment.offset].additionalData.overfly = value;
	    }
	  }

	  addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
	    const atWaypoint = this.getWaypoint(index);

	    if (!atWaypoint) {
	      return;
	    }

	    const magVar = Facilities.getMagVar(atWaypoint.infos.coordinates.lat, atWaypoint.infos.coordinates.long);
	    const trueCourse = A32NX_Util.magneticToTrue(desiredHold.inboundMagneticCourse, magVar);

	    if (atWaypoint.additionalData.legType === LegType.HA || atWaypoint.additionalData.legType === LegType.HF || atWaypoint.additionalData.legType === LegType.HM) {
	      atWaypoint.additionalData.legType = LegType.HM;
	      atWaypoint.turnDirection = desiredHold.turnDirection;
	      atWaypoint.additionalData.course = trueCourse;
	      atWaypoint.additionalData.distance = desiredHold.distance;
	      atWaypoint.additionalData.distanceInMinutes = desiredHold.time;
	      atWaypoint.additionalData.modifiedHold = modifiedHold;

	      if (atWaypoint.additionalData.defaultHold === undefined) {
	        atWaypoint.additionalData.defaultHold = defaultHold;
	      }

	      return index;
	    } else {
	      const manualHoldWaypoint = WaypointBuilder.fromWaypointManualHold(atWaypoint, desiredHold.turnDirection, trueCourse, desiredHold.distance, desiredHold.time, this._parentInstrument);
	      manualHoldWaypoint.additionalData.modifiedHold = modifiedHold;
	      manualHoldWaypoint.additionalData.defaultHold = defaultHold;
	      this.addWaypoint(manualHoldWaypoint, index + 1);
	      return index + 1;
	    }
	  }
	  /**
	   * Adds a plan segment to the flight plan.
	   * @param type The type of the segment to add.
	   */


	  addSegment(type) {
	    const segment = new FlightPlanSegment(type, 0, []);

	    this._segments.push(segment);

	    this._segments.sort((a, b) => a.type - b.type);

	    this.reflowSegments();
	    return segment;
	  }
	  /**
	   * Removes a plan segment from the flight plan.
	   * @param type The type of plan segment to remove.
	   */


	  removeSegment(type) {
	    const segmentIndex = this._segments.findIndex(s => s.type === type);

	    if (segmentIndex > -1) {
	      this._segments.splice(segmentIndex, 1);
	    }
	  }
	  /**
	   * Reflows waypoint index offsets accross plans segments.
	   */


	  reflowSegments() {
	    let index = 0;

	    if (this.originAirfield) {
	      index = 1;
	    }

	    for (const segment of this._segments) {
	      segment.offset = index;
	      index += segment.waypoints.length;
	    }
	  }
	  /**
	   * Gets a flight plan segment of the specified type.
	   * @param type The type of flight plan segment to get.
	   * @returns The found segment, or FlightPlanSegment.Empty if not found.
	   */


	  getSegment(type) {
	    const segment = this._segments.find(s => s.type === type);

	    return segment !== undefined ? segment : FlightPlanSegment.Empty;
	  }
	  /**
	   * Finds a flight plan segment by waypoint index.
	   * @param index The index of the waypoint to find the segment for.
	   * @returns The located segment, if any.
	   */


	  findSegmentByWaypointIndex(index) {
	    for (let i = 0; i < this._segments.length; i++) {
	      const segMaxIdx = this._segments[i].offset + this._segments[i].waypoints.length;

	      if (segMaxIdx > index) {
	        return this._segments[i];
	      }
	    }

	    return this._segments[this._segments.length - 1];
	  }

	  isLastWaypointInSegment(fpIndex) {
	    const segment = this.findSegmentByWaypointIndex(fpIndex);

	    if (fpIndex >= this.waypoints.length) {
	      return false;
	    }

	    if (fpIndex === segment.offset + segment.waypoints.length - 1) {
	      return true;
	    }

	    return false;
	  }
	  /**
	   * Recalculates all waypoint bearings and distances in the flight plan.
	   */


	  reflowDistances() {
	    let cumulativeDistance = 0;
	    const {
	      waypoints
	    } = this;

	    for (let i = 0; i < waypoints.length; i++) {
	      if (i > 0) {
	        // If there's an approach selected and this is the last approach waypoint, use the destination waypoint for coordinates
	        // Runway waypoints do not have coordinates
	        const referenceWaypoint = waypoints[i];
	        const prevWaypoint = waypoints[i - 1];
	        const trueCourseToWaypoint = Avionics.Utils.computeGreatCircleHeading(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
	        referenceWaypoint.bearingInFP = trueCourseToWaypoint - GeoMath.getMagvar(prevWaypoint.infos.coordinates.lat, prevWaypoint.infos.coordinates.long);
	        referenceWaypoint.bearingInFP = referenceWaypoint.bearingInFP < 0 ? 360 + referenceWaypoint.bearingInFP : referenceWaypoint.bearingInFP;

	        if (prevWaypoint.endsInDiscontinuity && !prevWaypoint.discontinuityCanBeCleared) {
	          referenceWaypoint.distanceInFP = 0;
	        } else if (referenceWaypoint.additionalData) {
	          switch (referenceWaypoint.additionalData.legType) {
	            case 11:
	            case 22:
	              referenceWaypoint.distanceInFP = 1;
	              break;

	            default:
	              referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
	              break;
	          }
	        } else {
	          referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
	        }

	        cumulativeDistance += referenceWaypoint.distanceInFP;
	        referenceWaypoint.cumulativeDistanceInFP = cumulativeDistance;
	      }
	    }
	  }
	  /**
	   * Copies a sanitized version of the flight plan for shared data storage.
	   * @returns The sanitized flight plan.
	   */


	  serialize() {
	    var _planCopy$directTo$in;

	    const planCopy = new ManagedFlightPlan();

	    const copyWaypoint = waypoint => ({
	      icao: waypoint.icao,
	      ident: waypoint.ident,
	      type: waypoint.type,
	      legAltitudeDescription: waypoint.legAltitudeDescription,
	      legAltitude1: waypoint.legAltitude1,
	      legAltitude2: waypoint.legAltitude2,
	      speedConstraint: waypoint.speedConstraint,
	      turnDirection: waypoint.turnDirection,
	      isVectors: waypoint.isVectors,
	      endsInDiscontinuity: waypoint.endsInDiscontinuity,
	      discontinuityCanBeCleared: waypoint.discontinuityCanBeCleared,
	      distanceInFP: waypoint.distanceInFP,
	      cumulativeDistanceInFP: waypoint.cumulativeDistanceInFP,
	      isRunway: waypoint.isRunway,
	      additionalData: waypoint.additionalData,
	      infos: {
	        icao: waypoint.infos.icao,
	        ident: waypoint.infos.ident,
	        airwayIn: waypoint.infos.airwayIn,
	        airwayOut: waypoint.infos.airwayOut,
	        routes: waypoint.infos.routes,
	        coordinates: {
	          lat: waypoint.infos.coordinates.lat,
	          long: waypoint.infos.coordinates.long,
	          alt: waypoint.infos.coordinates.alt
	        }
	      }
	    });

	    const copyAirfield = airfield => {
	      const copy = Object.assign(new WayPoint(undefined), airfield);
	      copy.infos = Object.assign(new AirportInfo(undefined), copy.infos);
	      delete copy.instrument;
	      delete copy.infos.instrument;
	      delete copy._svgElements;
	      delete copy.infos._svgElements;
	      return copy;
	    };

	    planCopy.activeWaypointIndex = this.activeWaypointIndex;
	    planCopy.destinationAirfield = this.destinationAirfield && copyAirfield(this.destinationAirfield);
	    planCopy.originAirfield = this.originAirfield && copyAirfield(this.originAirfield);
	    planCopy.persistentOriginAirfield = this.persistentOriginAirfield && copyAirfield(this.persistentOriginAirfield);
	    planCopy.procedureDetails = _objectSpread$4({}, this.procedureDetails);
	    planCopy.directTo = _objectSpread$4({}, this.directTo);
	    planCopy.directTo.interceptPoints = (_planCopy$directTo$in = planCopy.directTo.interceptPoints) === null || _planCopy$directTo$in === void 0 ? void 0 : _planCopy$directTo$in.map(w => copyWaypoint(w));
	    const copySegments = [];

	    for (const segment of this._segments) {
	      const copySegment = new FlightPlanSegment(segment.type, segment.offset, []);

	      for (const waypoint of segment.waypoints) {
	        copySegment.waypoints.push(copyWaypoint(waypoint));
	      }

	      copySegments.push(copySegment);
	    }

	    planCopy._segments = copySegments;
	    return planCopy;
	  }
	  /**
	   * Copies the flight plan.
	   * @returns The copied flight plan.
	   */


	  copy() {
	    const newFlightPlan = Object.assign(new ManagedFlightPlan(), this);
	    newFlightPlan.setParentInstrument(this._parentInstrument);
	    newFlightPlan._segments = [];

	    for (let i = 0; i < this._segments.length; i++) {
	      const seg = this._segments[i];
	      newFlightPlan._segments[i] = Object.assign(new FlightPlanSegment(seg.type, seg.offset, []), seg);
	      newFlightPlan._segments[i].waypoints = [...seg.waypoints.map(wp => {
	        const clone = new wp.constructor();
	        Object.assign(clone, wp);
	        clone.additionalData = Object.assign({}, wp.additionalData);
	        return clone;
	      })];
	    }

	    newFlightPlan.procedureDetails = Object.assign(new ProcedureDetails(), this.procedureDetails);
	    newFlightPlan.directTo = Object.assign(new DirectTo(), this.directTo);
	    newFlightPlan.directTo.interceptPoints = this.directTo.interceptPoints !== undefined ? [...this.directTo.interceptPoints] : undefined;
	    return newFlightPlan;
	  }
	  /**
	   * Reverses the flight plan.
	   */


	  reverse() {// TODO: Fix flight plan indexes after reversal
	    // this._waypoints.reverse();
	  }
	  /**
	   * Goes direct to the specified waypoint index in the flight plan.
	   *
	   * @param waypoint The waypoint to go direct to
	   */


	  async addDirectTo(waypoint) {
	    // TODO Replace with FMGC pos
	    const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
	    const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
	    const trueTrack = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
	    const oldToWp = this.waypoints[this.activeWaypointIndex];
	    const turningPoint = WaypointBuilder.fromCoordinates('T-P', new LatLongAlt(lat, long), this._parentInstrument, {
	      legType: LegType.CF,
	      course: trueTrack,
	      dynamicPpos: true
	    }, this.getTurningPointIcao());
	    turningPoint.isTurningPoint = true;
	    let waypointIndex = this.waypoints.findIndex((w, idx) => idx >= this.activeWaypointIndex && w.icao === waypoint.icao);

	    if (waypointIndex === -1) {
	      // in this case the waypoint is not already in the flight plan
	      // we string it to the start of the flight plan, add a discontinuity after, and then the existing flight plan
	      waypoint.endsInDiscontinuity = true;
	      waypoint.discontinuityCanBeCleared = true;
	      waypoint.additionalData.legType = LegType.DF;
	      this.addWaypoint(waypoint, this.activeWaypointIndex);
	      this.activeWaypointIndex = this.addWaypoint(turningPoint, this.activeWaypointIndex) + 1; // fix up the old leg that's now after the discont

	      if (ManagedFlightPlan.isXfLeg(oldToWp)) {
	        oldToWp.additionalData.legType = LegType.IF;
	      }
	    } else {
	      // in this case the waypoint is already in the flight plan...
	      // we can skip all the legs before it, and add our dir to
	      const toWp = this.waypoints[waypointIndex];
	      toWp.additionalData.legType = LegType.DF;
	      toWp.turnDirection = 0;
	      this.addWaypoint(turningPoint, waypointIndex);
	      this.activeWaypointIndex = waypointIndex + 1;
	    }
	  }
	  /**
	   *
	   * @param force force updating a turning point even if it's not marked dynamic
	   */


	  updateTurningPoint() {
	    var _wp$additionalData;

	    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    const wp = this.getWaypoint(this.activeWaypointIndex - 1);

	    if (wp !== null && wp !== void 0 && (_wp$additionalData = wp.additionalData) !== null && _wp$additionalData !== void 0 && _wp$additionalData.dynamicPpos || force && wp !== null && wp !== void 0 && wp.isTurningPoint) {
	      wp.infos.coordinates.lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
	      wp.infos.coordinates.long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
	      wp.additionalData.course = SimVar.GetSimVarValue('GPS GROUND TRUE TRACK', 'degree');
	      wp.icao = this.getTurningPointIcao();
	      wp.infos.icao = wp.icao;
	      console.log('updated T-P:', force, wp.additionalData, wp.infos.coordinates);
	      return true;
	    }

	    return false;
	  }

	  getTurningPointIcao() {
	    this.turningPointIndex = (this.turningPointIndex + 1) % 1000;
	    return "WXX    TP".concat(this.turningPointIndex.toFixed(0).padStart(3, '0'));
	  }
	  /**
	   * Builds a departure into the flight plan from indexes in the departure airport information.
	   */


	  async buildDeparture() {
	    const legs = [];
	    const legAnnotations = [];
	    const origin = this.originAirfield;
	    const {
	      departureIndex
	    } = this.procedureDetails;
	    const runwayIndex = this.procedureDetails.departureRunwayIndex;
	    const transitionIndex = this.procedureDetails.departureTransitionIndex;
	    const selectedOriginRunwayIndex = this.procedureDetails.originRunwayIndex;
	    const airportInfo = origin.infos;
	    const airportMagVar = Facilities.getMagVar(airportInfo.coordinates.lat, airportInfo.coordinates.long); // Make origin fix an IF leg

	    if (origin) {
	      origin.additionalData.legType = LegType.IF;
	      origin.endsInDiscontinuity = true;
	      origin.discontinuityCanBeCleared = true;
	      const departure = airportInfo.departures[departureIndex];

	      if (departure) {
	        origin.additionalData.annotation = departure.name;
	      } else {
	        origin.additionalData.annotation = '';
	      }
	    } // Set origin fix coordinates to runway beginning coordinates


	    if (origin && selectedOriginRunwayIndex >= 0) {
	      origin.infos.coordinates = airportInfo.oneWayRunways[selectedOriginRunwayIndex].beginningCoordinates;
	      origin.additionalData.runwayElevation = airportInfo.oneWayRunways[selectedOriginRunwayIndex].elevation * 3.2808399;
	      origin.additionalData.runwayLength = airportInfo.oneWayRunways[selectedOriginRunwayIndex].length;
	    }

	    if (departureIndex >= 0 && runwayIndex >= 0) {
	      const runwayTransition = airportInfo.departures[departureIndex].runwayTransitions[runwayIndex];
	      const departure = airportInfo.departures[departureIndex];

	      if (runwayTransition) {
	        legs.push(...runwayTransition.legs);
	        legAnnotations.push(...runwayTransition.legs.map(_ => departure.name));
	        origin.endsInDiscontinuity = false;
	        origin.discontinuityCanBeCleared = undefined;
	      }
	    }

	    if (departureIndex >= 0) {
	      const departure = airportInfo.departures[departureIndex];
	      legs.push(...departure.commonLegs);
	      legAnnotations.push(...departure.commonLegs.map(_ => departure.name));
	    }

	    if (transitionIndex >= 0 && departureIndex >= 0) {
	      if (airportInfo.departures[departureIndex].enRouteTransitions.length > 0) {
	        const transition = airportInfo.departures[departureIndex].enRouteTransitions[transitionIndex];
	        legs.push(...transition.legs);
	        legAnnotations.push(...transition.legs.map(_ => transition.name));
	      }
	    }

	    let segment = this.departure;

	    if (segment !== FlightPlanSegment.Empty) {
	      for (let i = 0; i < segment.waypoints.length; i++) {
	        this.removeWaypoint(segment.offset);
	      }

	      this.removeSegment(segment.type);
	    }

	    if (legs.length > 0 || selectedOriginRunwayIndex >= 0 || departureIndex >= 0 && runwayIndex >= 0) {
	      segment = this.addSegment(SegmentType.Departure);
	      let procedure = new LegsProcedure(legs, origin, this._parentInstrument, airportMagVar, undefined, legAnnotations);
	      const runway = this.getOriginRunway();

	      if (runway) {
	        // console.error('bruh');
	        // Reference : AMM - 22-71-00 PB001, Page 4
	        if (departureIndex < 0 && transitionIndex < 0) {
	          const TEMPORARY_VERTICAL_SPEED = 2000.0; // ft/min

	          const TEMPORARY_GROUND_SPEED = 160; // knots

	          const altitudeFeet = runway.elevation * 3.2808399 + 1500;
	          const distanceInNM = altitudeFeet / TEMPORARY_VERTICAL_SPEED * (TEMPORARY_GROUND_SPEED / 60);
	          const coordinates = GeoMath.relativeBearingDistanceToCoords(runway.direction, distanceInNM, runway.endCoordinates);
	          const faLeg = procedure.buildWaypoint("".concat(Math.round(altitudeFeet)), coordinates); // TODO should this check for unclr discont? (probs not)

	          faLeg.endsInDiscontinuity = true;
	          faLeg.discontinuityCanBeCleared = true;
	          this.addWaypoint(faLeg, undefined, segment.type);
	        }
	      }

	      let waypointIndex = segment.offset;

	      while (procedure.hasNext()) {
	        const waypoint = await procedure.getNext();

	        if (waypoint !== undefined) {
	          waypoint.additionalData.constraintType = WaypointConstraintType.CLB;
	          this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
	        }
	      }
	    }

	    this.restringSegmentBoundaries(SegmentType.Departure, SegmentType.Enroute);
	  }
	  /**
	   * Rebuilds the arrival and approach segment after a change of procedure
	   */


	  async rebuildArrivalApproach() {
	    // remove all legs from these segments to prevent weird stuff
	    this.truncateSegment(SegmentType.Arrival);
	    this.truncateSegment(SegmentType.Approach);
	    this.truncateSegment(SegmentType.Missed);
	    await this.buildArrival().catch(console.error);
	    await this.buildApproach().catch(console.error);
	  }
	  /**
	   * Builds an arrival into the flight plan from indexes in the arrival airport information.
	   */


	  async buildArrival() {
	    const legs = [];
	    const legAnnotations = [];
	    const destination = this.destinationAirfield;
	    const {
	      arrivalIndex
	    } = this.procedureDetails;
	    this.procedureDetails;
	    const {
	      arrivalRunwayIndex
	    } = this.procedureDetails;
	    const {
	      arrivalTransitionIndex
	    } = this.procedureDetails;
	    const destinationInfo = destination.infos;
	    const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);

	    if (arrivalIndex >= 0 && arrivalTransitionIndex >= 0) {
	      const transition = destinationInfo.arrivals[arrivalIndex].enRouteTransitions[arrivalTransitionIndex];

	      if (transition !== undefined) {
	        legs.push(...transition.legs);
	        legAnnotations.push(...transition.legs.map(_ => transition.name)); // console.log('MFP: buildArrival - pushing transition legs ->', legs);
	      }
	    }

	    if (arrivalIndex >= 0) {
	      // string the common legs in the middle of the STAR
	      const arrival = destinationInfo.arrivals[arrivalIndex];
	      legs.push(...arrival.commonLegs);
	      legAnnotations.push(...arrival.commonLegs.map(_ => arrival.name)); // console.log('MFP: buildArrival - pushing STAR legs ->', legs);
	      // if no runway is selected at all (non-runway-specific approach)
	      // and the selected STAR only has runway transition legs... string them
	      // TODO research IRL behaviour

	      const starHasOneRunwayTrans = arrival.commonLegs.length === 0 && arrival.runwayTransitions.length === 1;
	      const approachIsRunwaySpecific = this.procedureDetails.destinationRunwayIndex >= 0;
	      const runwayTransIndex = arrivalRunwayIndex < 0 && starHasOneRunwayTrans && !approachIsRunwaySpecific ? 0 : arrivalRunwayIndex;
	      const runwayTransition = arrival.runwayTransitions[runwayTransIndex];

	      if (runwayTransition) {
	        legs.push(...runwayTransition.legs);
	        legAnnotations.push(...runwayTransition.legs.map(_ => arrival.name));
	      }
	    }

	    let {
	      _startIndex,
	      segment
	    } = this.truncateSegment(SegmentType.Arrival);

	    if (legs.length > 0) {
	      if (segment === FlightPlanSegment.Empty) {
	        segment = this.addSegment(SegmentType.Arrival);
	        _startIndex = segment.offset;
	      }

	      const procedure = new LegsProcedure(legs, this.getWaypoint(segment.offset - 1), this._parentInstrument, airportMagVar, undefined, legAnnotations);
	      let waypointIndex = segment.offset; // console.log('MFP: buildArrival - ADDING WAYPOINTS ------------------------');

	      while (procedure.hasNext()) {
	        const waypoint = await procedure.getNext();

	        if (waypoint) {
	          waypoint.additionalData.constraintType = WaypointConstraintType.DES; // console.log('  ---- MFP: buildArrival: added waypoint ', waypoint.ident, ' to segment ', segment);

	          this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
	        }
	      }
	    }

	    this.restringSegmentBoundaries(SegmentType.Enroute, SegmentType.Arrival);
	    this.restringSegmentBoundaries(SegmentType.Arrival, SegmentType.Approach);
	  }
	  /**
	   * Builds an approach into the flight plan from indexes in the arrival airport information.
	   */


	  async buildApproach() {
	    const legs = [];
	    const legAnnotations = [];
	    const missedLegs = [];
	    const destination = this.destinationAirfield;
	    this.procedureDetails.approachType = undefined;
	    const {
	      approachIndex
	    } = this.procedureDetails;
	    const {
	      approachTransitionIndex
	    } = this.procedureDetails;
	    const {
	      destinationRunwayIndex
	    } = this.procedureDetails;
	    const destinationInfo = destination.infos;
	    const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
	    const approach = destinationInfo.approaches[approachIndex];
	    const approachName = approach && approach.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN ? approach.name : '';

	    if (approachIndex >= 0 && approachTransitionIndex >= 0) {
	      const transition = destinationInfo.approaches[approachIndex].transitions[approachTransitionIndex];
	      legs.push(...transition.legs);
	      legAnnotations.push(...transition.legs.map(_ => transition.name)); // console.log('MFP: buildApproach - pushing approachTransition legs ->', legs);
	    }

	    if (approachIndex >= 0) {
	      var _legs, _finalLegs$;

	      const finalLegs = [...approach.finalLegs]; // PI legs can only occur in approach vias
	      // if the via ends in one, we must omit the IF leg at the start of the approach

	      const viaLastLegType = (_legs = legs[legs.length - 1]) === null || _legs === void 0 ? void 0 : _legs.type;

	      if (viaLastLegType === LegType.PI && ((_finalLegs$ = finalLegs[0]) === null || _finalLegs$ === void 0 ? void 0 : _finalLegs$.type) === LegType.IF) {
	        var _finalLegs$2;

	        finalLegs.splice(0, 1); // @ts-expect-error (ts compiler doesn't see that splice mutates finalLegs)

	        if (((_finalLegs$2 = finalLegs[0]) === null || _finalLegs$2 === void 0 ? void 0 : _finalLegs$2.type) !== LegType.CF) {
	          console.error('PI must be followed by CF!');
	        }
	      }

	      this.procedureDetails.approachType = approach.approachType;
	      legs.push(...finalLegs);
	      legAnnotations.push(...finalLegs.map(_ => approachName));
	      missedLegs.push(...approach.missedLegs);
	    }

	    let {
	      _startIndex,
	      segment
	    } = this.truncateSegment(SegmentType.Approach);

	    if (legs.length > 0 || approachIndex >= 0 || destinationRunwayIndex >= 0) {
	      if (segment === FlightPlanSegment.Empty) {
	        segment = this.addSegment(SegmentType.Approach);
	        _startIndex = segment.offset;
	        const prevWaypointIndex = segment.offset - 1;

	        if (prevWaypointIndex > 0) {
	          const prevWaypoint = this.getWaypoint(segment.offset - 1);

	          if (!prevWaypoint.endsInDiscontinuity) {
	            prevWaypoint.endsInDiscontinuity = true;
	            prevWaypoint.discontinuityCanBeCleared = true;
	          }
	        }
	      }

	      const runway = this.getDestinationRunway();
	      const procedure = new LegsProcedure(legs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar, this.procedureDetails.approachType, legAnnotations);

	      if (runway) {
	        procedure.calculateApproachData(runway);
	      }

	      let waypointIndex = _startIndex; // console.log('MFP: buildApproach - ADDING WAYPOINTS ------------------------');

	      while (procedure.hasNext()) {
	        const waypoint = await procedure.getNext();

	        if (waypoint !== undefined) {
	          waypoint.additionalData.constraintType = WaypointConstraintType.DES; // console.log('  ---- MFP: buildApproach: added waypoint', waypoint.ident, ' to segment ', segment);

	          this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
	        }
	      }

	      if (runway) {
	        const selectedRunwayMod = runway.designation.slice(-1);

	        if (selectedRunwayMod === 'L' || selectedRunwayMod === 'C' || selectedRunwayMod === 'R') {
	          if (runway.designation.length === 2) {
	            "0".concat(runway.designation);
	          }
	        } else if (runway.designation.length === 2) ; else {
	          "0".concat(runway.designation);
	        } // When adding approach, edit destination waypoint


	        this.destinationAirfield.infos.coordinates = runway.beginningCoordinates;
	        this.destinationAirfield.legAltitudeDescription = 1;
	        this.destinationAirfield.legAltitude1 = Math.round((runway.elevation * 3.28084 + 50) / 10) * 10;
	        this.destinationAirfield.isRunway = true;

	        if (approachIndex >= 0) {
	          const lastLeg = approach.finalLegs[approach.finalLegs.length - 1];

	          if (lastLeg.type === LegType.CF) {
	            const magCourse = lastLeg.trueDegrees ? A32NX_Util.trueToMagnetic(lastLeg.course, Facilities.getMagVar(runway.beginningCoordinates.lat, runway.beginningCoordinates.long)) : lastLeg.course;
	            this.destinationAirfield.additionalData.annotation = "C".concat(magCourse.toFixed(0).padStart(3, '0'), "\xB0");
	          } else {
	            this.destinationAirfield.additionalData.annotation = approachName;
	          }

	          this.destinationAirfield.verticalAngle = lastLeg.verticalAngle;
	        } // Clear discontinuity before destination, if any


	        const wpBeforeDestIdx = this.waypoints.indexOf(this.destinationAirfield) - 1;

	        if (wpBeforeDestIdx >= 0) {
	          const wpBeforeDest = this.getWaypoint(wpBeforeDestIdx);

	          if (wpBeforeDest.endsInDiscontinuity && wpBeforeDest.discontinuityCanBeCleared) {
	            wpBeforeDest.endsInDiscontinuity = false;
	          }
	        }
	      }
	    }

	    this.restringSegmentBoundaries(SegmentType.Arrival, SegmentType.Approach);
	    /* if (missedLegs.length > 0) {
	        let { _startIndex, segment } = this.truncateSegment(SegmentType.Missed);
	         if (segment === FlightPlanSegment.Empty) {
	            segment = this.addSegment(SegmentType.Missed);
	            _startIndex = segment.offset;
	        }
	         let waypointIndex = _startIndex;
	         const missedProcedure = new LegsProcedure(missedLegs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar);
	        while (missedProcedure.hasNext()) {
	            // eslint-disable-next-line no-await-in-loop
	            const waypoint = await missedProcedure.getNext().catch(console.error);
	             if (waypoint !== undefined) {
	                // console.log('  ---- MFP: buildApproach: added waypoint', waypoint.ident, ' to segment ', segment);
	                this.addWaypoint(waypoint, ++waypointIndex, segment.type);
	            }
	        }
	    } */
	  }

	  static isXfLeg(leg) {
	    var _leg$additionalData;

	    switch (leg === null || leg === void 0 ? void 0 : (_leg$additionalData = leg.additionalData) === null || _leg$additionalData === void 0 ? void 0 : _leg$additionalData.legType) {
	      case LegType.CF:
	      case LegType.DF:
	      case LegType.IF:
	      case LegType.RF:
	      case LegType.TF:
	        return true;

	      default:
	        return false;
	    }
	  }

	  static isFxLeg(leg) {
	    var _leg$additionalData2;

	    switch (leg === null || leg === void 0 ? void 0 : (_leg$additionalData2 = leg.additionalData) === null || _leg$additionalData2 === void 0 ? void 0 : _leg$additionalData2.legType) {
	      case LegType.FA:
	      case LegType.FC:
	      case LegType.FD:
	      case LegType.FM:
	        return true;

	      default:
	        return false;
	    }
	  }

	  static legsStartOrEndAtSameFix(legA, legB) {
	    return legA.icao === legB.icao && (ManagedFlightPlan.isXfLeg(legA) && ManagedFlightPlan.isXfLeg(legB) || ManagedFlightPlan.isFxLeg(legA) && ManagedFlightPlan.isFxLeg(legB));
	  }

	  static climbConstraint(leg) {
	    switch (leg.legAltitudeDescription) {
	      case AltitudeDescriptor.At:
	      case AltitudeDescriptor.AtOrBelow:
	        return leg.legAltitude1;

	      case AltitudeDescriptor.Between:
	        return leg.legAltitude2;
	    }

	    return Infinity;
	  }

	  static descentConstraint(leg) {
	    switch (leg.legAltitudeDescription) {
	      case AltitudeDescriptor.At:
	      case AltitudeDescriptor.AtOrAbove:
	      case AltitudeDescriptor.Between:
	        return leg.legAltitude1;
	    }

	    return -Infinity;
	  }

	  static mergeConstraints(legA, legB) {
	    let legAltitudeDescription = AltitudeDescriptor.Empty;
	    let legAltitude1 = 0;
	    let legAltitude2 = 0;

	    if (legA.legAltitudeDescription === AltitudeDescriptor.At) {
	      legAltitudeDescription = AltitudeDescriptor.At;

	      if (legB.legAltitudeDescription === AltitudeDescriptor.At) {
	        legAltitude1 = Math.min(legA.legAltitude1, legB.legAltitude1);
	      } else {
	        legAltitude1 = legA.legAltitude1;
	      }
	    } else if (legB.legAltitudeDescription === AltitudeDescriptor.At) {
	      legAltitudeDescription = AltitudeDescriptor.At;
	      legAltitude1 = legB.legAltitude1;
	    } else if (legA.legAltitudeDescription > 0 || legB.legAltitudeDescription > 0) {
	      const maxAlt = Math.min(ManagedFlightPlan.climbConstraint(legA), ManagedFlightPlan.climbConstraint(legB));
	      const minAlt = Math.max(ManagedFlightPlan.descentConstraint(legA), ManagedFlightPlan.descentConstraint(legB));

	      if (Number.isFinite(maxAlt)) {
	        if (Number.isFinite(minAlt)) {
	          if (Math.abs(minAlt - maxAlt) < 1) {
	            legAltitudeDescription = AltitudeDescriptor.At;
	            legAltitude1 = minAlt;
	          } else {
	            legAltitudeDescription = AltitudeDescriptor.Between;
	            legAltitude1 = minAlt;
	            legAltitude2 = maxAlt;
	          }
	        } else {
	          legAltitudeDescription = AltitudeDescriptor.AtOrBelow;
	          legAltitude1 = maxAlt;
	        }
	      } else if (Number.isFinite(minAlt)) {
	        legAltitudeDescription = AltitudeDescriptor.AtOrAbove;
	        legAltitude1 = minAlt;
	      }
	    }

	    const speed = Math.min(legA.speedConstraint > 0 ? legA.speedConstraint : Infinity, legB.speedConstraint > 0 ? legB.speedConstraint : Infinity);
	    return {
	      legAltitudeDescription,
	      legAltitude1,
	      legAltitude2,
	      speedConstraint: Number.isFinite(speed) ? speed : 0
	    };
	  }
	  /**
	   * Check for common waypoints at the boundaries of segments, and merge them if found
	   * segmentA must be before segmentB in the plan!
	   */


	  restringSegmentBoundaries(segmentTypeA, segmentTypeB) {
	    if (segmentTypeB < segmentTypeA) {
	      throw new Error('restringSegmentBoundaries: segmentTypeA must be before segmentTypeB');
	    }

	    const segmentA = this.getSegment(segmentTypeA);
	    const segmentB = this.getSegment(segmentTypeB);

	    if ((segmentA === null || segmentA === void 0 ? void 0 : segmentA.waypoints.length) < 1 || (segmentB === null || segmentB === void 0 ? void 0 : segmentB.waypoints.length) < 1) {
	      return;
	    }

	    const lastLegIndexA = segmentA.offset + segmentA.waypoints.length - 1;
	    const lastLegA = segmentA.waypoints[segmentA.waypoints.length - 1];
	    const firstLegIndexB = segmentB.offset;
	    const firstLegB = segmentB.waypoints[0];

	    if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, firstLegB)) {
	      const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);

	      if (segmentA.type === SegmentType.Departure) {
	        this.removeWaypoint(firstLegIndexB, true);
	        Object.assign(lastLegA, constraints);
	        lastLegA.endsInDiscontinuity = false;
	        lastLegA.discontinuityCanBeCleared = undefined;
	      } else {
	        this.removeWaypoint(lastLegIndexA, true);
	        Object.assign(firstLegB, constraints);
	        firstLegB.endsInDiscontinuity = false;
	        firstLegB.discontinuityCanBeCleared = undefined;
	      }
	    } else if (segmentTypeA === SegmentType.Arrival && segmentTypeB === SegmentType.Approach) {
	      let toDeleteFromB = 0;

	      for (let i = 0; i < segmentB.waypoints.length; i++) {
	        if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, segmentB.waypoints[i])) {
	          const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
	          Object.assign(lastLegA, constraints);
	          toDeleteFromB = i + 1;
	          break;
	        }
	      }

	      for (let i = 0; i < toDeleteFromB; i++) {
	        this.removeWaypoint(segmentB.offset, true);
	      }

	      if (toDeleteFromB === 0 && firstLegB.additionalData.legType === LegType.IF) {
	        lastLegA.endsInDiscontinuity = true;
	        lastLegA.discontinuityCanBeCleared = true;
	      }
	    }
	  }
	  /**
	   * Truncates a flight plan segment. If the active waypoint index is current in the segment,
	   * a discontinuity will be added at the end of the active waypoint and the startIndex will
	   * point to the next waypoint in the segment after the active.
	   * @param type The type of segment to truncate.
	   * @returns A segment to add to and a starting waypoint index.
	   */


	  truncateSegment(type) {
	    let segment = this.getSegment(type); // const startIndex = this.findSegmentByWaypointIndex(this.activeWaypointIndex) === segment
	    //     ? this.activeWaypointIndex + 1
	    //     : segment.offset;

	    const startIndex = segment.offset;

	    if (segment !== FlightPlanSegment.Empty) {
	      const finalIndex = segment.offset + segment.waypoints.length;

	      if (startIndex < finalIndex) {
	        for (let i = startIndex; i < finalIndex; i++) {
	          // console.log(' MFP ---> truncateSegment: removing waypoint ', this.getWaypoint(startIndex).ident);
	          this.removeWaypoint(startIndex);
	        }
	      }
	    }

	    if (segment.waypoints.length === 0) {
	      this.removeSegment(segment.type);
	      segment = FlightPlanSegment.Empty;
	    } else {
	      const waypoint = segment.waypoints[Math.max(startIndex - 1 - segment.offset, 0)];
	      waypoint.endsInDiscontinuity = true;
	      waypoint.discontinuityCanBeCleared = true;
	    }

	    return {
	      _startIndex: startIndex,
	      segment
	    };
	  }
	  /**
	   * Converts a plain object into a ManagedFlightPlan.
	   * @param flightPlanObject The object to convert.
	   * @param parentInstrument The parent instrument attached to this flight plan.
	   * @returns The converted ManagedFlightPlan.
	   */


	  static fromObject(flightPlanObject, parentInstrument) {
	    const plan = Object.assign(new ManagedFlightPlan(), flightPlanObject);
	    plan.setParentInstrument(parentInstrument);
	    plan.directTo = Object.assign(new DirectTo(), plan.directTo);

	    const mapObject = (obj, parentType) => {
	      if (obj && obj.infos) {
	        obj = Object.assign(new WayPoint(parentInstrument), obj);
	      }

	      if (obj && obj.coordinates) {
	        switch (parentType) {
	          case 'A':
	            obj = Object.assign(new AirportInfo(parentInstrument), obj);
	            break;

	          case 'W':
	            obj = Object.assign(new IntersectionInfo(parentInstrument), obj);
	            break;

	          case 'V':
	            obj = Object.assign(new VORInfo(parentInstrument), obj);
	            break;

	          case 'N':
	            obj = Object.assign(new NDBInfo(parentInstrument), obj);
	            break;

	          default:
	            obj = Object.assign(new WayPointInfo(parentInstrument), obj);
	        }

	        obj.coordinates = Object.assign(new LatLongAlt(), obj.coordinates);
	      }

	      return obj;
	    };

	    const visitObject = obj => {
	      for (const key in obj) {
	        if (typeof obj[key] === 'object' && obj[key] && obj[key].scroll === undefined) {
	          if (Array.isArray(obj[key])) {
	            visitArray(obj[key]);
	          } else {
	            visitObject(obj[key]);
	          }

	          obj[key] = mapObject(obj[key], obj.type);
	        }
	      }
	    };

	    const visitArray = array => {
	      array.forEach((item, index) => {
	        if (Array.isArray(item)) {
	          visitArray(item);
	        } else if (typeof item === 'object') {
	          visitObject(item);
	        }

	        array[index] = mapObject(item);
	      });
	    };

	    visitObject(plan);
	    return plan;
	  }

	  legDataMatches(a, b, fields) {
	    return fields.every(field => a.additionalData[field] === b.additionalData[field]);
	  }

	  isLegDuplicate(a, b) {
	    if (a.additionalData.legType === b.additionalData.legType) {
	      switch (a.additionalData.legType) {
	        case LegType.AF:
	        case LegType.CR:
	        case LegType.VR:
	          return this.legDataMatches(a, b, ['course', 'theta', 'recommendedIcao']);

	        case LegType.CA:
	        case LegType.VA:
	          return this.legDataMatches(a, b, ['course']) && a.legAltitude1 === b.legAltitude1;

	        case LegType.CD:
	        case LegType.VD:
	          return this.legDataMatches(a, b, ['course', 'distance', 'recommendedIcao']);

	        case LegType.CF:
	          return this.legDataMatches(a, b, ['course']) && a.icao === b.icao;

	        case LegType.CI:
	        case LegType.VI:
	        case LegType.VM:
	          return this.legDataMatches(a, b, ['course']);

	        case LegType.DF:
	        case LegType.IF:
	        case LegType.TF:
	          return a.icao === b.icao;

	        case LegType.FA:
	          return a.icao === b.icao && a.legAltitude1 === b.legAltitude1;

	        case LegType.FC:
	          return this.legDataMatches(a, b, ['course', 'distance']) && a.icao === b.icao;

	        case LegType.FD:
	          return this.legDataMatches(a, b, ['course', 'distance', 'recommendedIcao']) && a.icao === b.icao;

	        case LegType.FM:
	          return this.legDataMatches(a, b, ['course']) && a.icao === b.icao;

	        case LegType.HA:
	          return this.legDataMatches(a, b, ['course', 'distance', 'distanceInMinutes']) && a.icao === b.icao && a.legAltitude1 === b.legAltitude1;

	        case LegType.HF:
	        case LegType.HM:
	        case LegType.PI:
	          return this.legDataMatches(a, b, ['course', 'distance', 'distanceInMinutes']) && a.icao === b.icao;

	        case LegType.RF:
	          return this.legDataMatches(a, b, ['center', 'radius']) && a.icao === b.icao;
	      }
	    } else if (ManagedFlightPlan.isXfLeg(a) && ManagedFlightPlan.isXfLeg(b) || ManagedFlightPlan.isFxLeg(a) && ManagedFlightPlan.isFxLeg(b)) {
	      return a.icao === b.icao;
	    }

	    return false;
	  }

	  addWaypointAvoidingDuplicates(waypoint, waypointIndex, segment) {
	    const index = this.waypoints.findIndex(wp => this.isLegDuplicate(waypoint, wp)); // FIXME this should collapse any legs between the old position and the newly inserted position

	    const wptDist = Math.abs(index - waypointIndex);

	    if (index !== -1 && wptDist <= 2) {
	      // console.log('  -------> MFP: addWaypointAvoidingDuplicates: removing duplicate waypoint ', this.getWaypoint(index).ident);
	      const removedWp = this.getWaypoint(index);

	      if (waypoint.legAltitudeDescription === AltitudeDescriptor.Empty && removedWp.legAltitudeDescription !== AltitudeDescriptor.Empty) {
	        waypoint.legAltitudeDescription = removedWp.legAltitudeDescription;
	        waypoint.legAltitude1 = removedWp.legAltitude1;
	        waypoint.legAltitude2 = removedWp.legAltitude2;
	      }

	      if (waypoint.speedConstraint <= 0 && removedWp.speedConstraint > 0) {
	        waypoint.speedConstraint = removedWp.speedConstraint;
	      }

	      this.removeWaypoint(index);
	    }

	    this.addWaypoint(waypoint, waypointIndex, segment.type);
	  }

	  getOriginRunway() {
	    if (this.originAirfield) {
	      if (this.procedureDetails.originRunwayIndex >= 0) {
	        return this.originAirfield.infos.oneWayRunways[this.procedureDetails.originRunwayIndex];
	      }
	    }

	    return null;
	  }

	  getDestinationRunway() {
	    if (this.destinationAirfield) {
	      if (this.procedureDetails.destinationRunwayIndex >= 0) {
	        return this.destinationAirfield.infos.oneWayRunways[this.procedureDetails.destinationRunwayIndex];
	      }
	    }

	    return null;
	  }

	  get manualHoldActive() {
	    var _this$waypoints$this$, _this$waypoints$this$2;

	    return ((_this$waypoints$this$ = this.waypoints[this.activeWaypointIndex]) === null || _this$waypoints$this$ === void 0 ? void 0 : (_this$waypoints$this$2 = _this$waypoints$this$.additionalData) === null || _this$waypoints$this$2 === void 0 ? void 0 : _this$waypoints$this$2.legType) === LegType.HM;
	  }

	  get glideslopeIntercept() {
	    const appr = this.getSegment(SegmentType.Approach);

	    for (const wp of appr.waypoints) {
	      if (wp.additionalData.fixTypeFlags & FixTypeFlags.FAF && (wp.legAltitudeDescription === AltitudeDescriptor.G || wp.legAltitudeDescription === AltitudeDescriptor.H)) {
	        return wp.legAltitude1;
	      }
	    }
	  }

	  get destinationIndex() {
	    const appr = this.getSegment(SegmentType.Approach);
	    const index = appr.offset + appr.waypoints.length;

	    if (this.destinationAirfield) {
	      return index + 1;
	    }

	    return -1;
	  }

	  get finalApproachActive() {
	    const appr = this.getSegment(SegmentType.Approach);

	    if (appr === FlightPlanSegment.Empty) {
	      return false;
	    }

	    const offset = this.activeWaypointIndex - appr.offset;

	    if (offset >= 0 && offset < appr.waypoints.length) {
	      for (const [index, wp] of appr.waypoints.entries()) {
	        if (wp.additionalData.fixTypeFlags & FixTypeFlags.FAF) {
	          return offset >= index;
	        }
	      }
	    }

	    return false;
	  }

	  tryAddOrUpdateCruiseStep(ident, toAltitude) {
	    // TODO: Handle optimum steps
	    const waypointIndex = this.findWaypointIndexByIdent(ident);
	    const waypoint = this.getWaypoint(waypointIndex);

	    if (waypointIndex > 0) {
	      waypoint.additionalData.cruiseStep = {
	        distanceBeforeTermination: 0,
	        toAltitude,
	        waypointIndex: waypointIndex
	      };
	      return true;
	    }

	    return false;
	  }

	  tryRemoveCruiseStep(waypointIndex) {
	    const waypoint = this.getWaypoint(waypointIndex);

	    if (waypoint) {
	      waypoint.additionalData.cruiseStep = undefined;
	      return true;
	    }

	    return false;
	  }

	  findWaypointIndexByIdent(ident) {
	    return this.waypoints.findIndex(waypoint => waypoint.ident === ident);
	  }

	}

	/*
	 * MIT License
	 *
	 * Copyright (c) 2020-2021 Working Title, FlyByWire Simulations
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */

	/** A class for syncing a flight plan with the game */
	class FlightPlanAsoboSync {
	  static init() {
	    if (!this.fpListenerInitialized) {
	      RegisterViewListener('JS_LISTENER_FLIGHTPLAN');
	      this.fpListenerInitialized = true;
	    }
	  }

	  static async LoadFromGame(fpln) {
	    return new Promise(resolve => {
	      this.init();
	      setTimeout(() => {
	        Coherent.call('LOAD_CURRENT_GAME_FLIGHT').catch(console.error);
	        Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN').catch(console.error);
	        setTimeout(() => {
	          Coherent.call('GET_FLIGHTPLAN').then(async data => {
	            console.log('COHERENT GET_FLIGHTPLAN received');
	            const {
	              isDirectTo
	            } = data; // TODO: talk to matt about dirto

	            if (!isDirectTo) {
	              // TODO FIXME: better handling of mid-air spawning and syncing fpln
	              if (data.waypoints.length === 0 || data.waypoints[0].icao[0] !== 'A') {
	                fpln.resumeSync();
	                resolve();
	                return;
	              }

	              await fpln._parentInstrument.facilityLoader.getFacilityRaw(data.waypoints[0].icao, 10000).catch(e => {
	                console.error('[FP LOAD] Error getting first wp data');
	                console.error(e);
	              }); // set origin

	              await fpln.setOrigin(data.waypoints[0].icao).catch(e => {
	                console.error('[FP LOAD] Error setting origin');
	                console.error(e);
	              }); // set dest

	              await fpln.setDestination(data.waypoints[data.waypoints.length - 1].icao).catch(e => {
	                console.error('[FP LOAD] Error setting Destination');
	                console.error(e);
	              }); // set route

	              const enrouteStart = data.departureWaypointsSize === -1 ? 1 : data.departureWaypointsSize; // Find out first approach waypoint, - 1 to skip destination

	              const enrouteEnd = data.waypoints.length - (data.arrivalWaypointsSize === -1 ? 1 : data.arrivalWaypointsSize) - 1;
	              const enroute = data.waypoints.slice(enrouteStart, enrouteEnd - 1);

	              for (let i = 0; i < enroute.length - 1; i++) {
	                const wpt = enroute[i];

	                if (wpt.icao.trim() !== '') {
	                  fpln.addWaypoint(wpt.icao, Infinity, () => console.log("[FP LOAD] Adding [".concat(wpt.icao, "]... SUCCESS"))).catch(console.error);
	                }
	              } // set departure
	              //  rwy index


	              await fpln.setDepartureRunwayIndex(data.departureRunwayIndex) // .then(() => console.log(`[FP LOAD] Setting Departure Runway ${data.departureRunwayIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Departure Runway ".concat(data.departureRunwayIndex, " ... FAILED"));
	                console.error(e);
	              }); // proc index

	              await fpln.setDepartureProcIndex(data.departureProcIndex) // .then(() => console.log(`[FP LOAD] Setting Departure Procedure  ${data.departureProcIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Departure Procedure ".concat(data.departureProcIndex, " ... FAILED"));
	                console.error(e);
	              }); // origin runway

	              if (data.originRunwayIndex !== -1) {
	                await fpln.setOriginRunwayIndex(data.originRunwayIndex) // .then(() => console.log(`[FP LOAD] Setting Origin  ${data.originRunwayIndex} ... SUCCESS`))
	                .catch(e => {
	                  console.error("[FP LOAD] Setting Origin ".concat(data.originRunwayIndex, " ... FAILED"));
	                  console.error(e);
	                });
	              } else if (data.departureRunwayIndex !== -1 && data.departureProcIndex !== -1) {
	                await fpln.setOriginRunwayIndexFromDeparture() // .then(() => console.log(`[FP LOAD] Setting Origin using ${data.departureProcIndex}/${data.departureRunwayIndex}... SUCCESS`))
	                .catch(e => {
	                  console.error("[FP LOAD] Setting Origin using ".concat(data.departureProcIndex, "/").concat(data.departureRunwayIndex, " ... FAILED"));
	                  console.error(e);
	                });
	              } //  enroutetrans index


	              await fpln.setDepartureEnRouteTransitionIndex(data.departureEnRouteTransitionIndex) // .then(() => console.log(`[FP LOAD] Setting Departure En Route Transition ${data.departureEnRouteTransitionIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Departure En Route Transition ".concat(data.departureEnRouteTransitionIndex, " ... FAILED"));
	                console.error(e);
	              }); // set approach
	              //  rwy index

	              await fpln.setArrivalRunwayIndex(data.arrivalRunwayIndex) // .then(() => console.log(`[FP LOAD] Setting Arrival Runway ${data.arrivalRunwayIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Arrival Runway ".concat(data.arrivalRunwayIndex, " ... FAILED"));
	                console.error(e);
	              }); //  approach index

	              await fpln.setApproachIndex(data.approachIndex) // .then(() => console.log(`[FP LOAD] Setting Approach ${data.approachIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Approach ".concat(data.approachIndex, " ... FAILED"));
	                console.error(e);
	              }); //  approachtrans index

	              await fpln.setApproachTransitionIndex(data.approachTransitionIndex) // .then(() => console.log(`[FP LOAD] Setting Approach Transition ${data.approachTransitionIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Approach Transition ".concat(data.approachTransitionIndex, " ... FAILED"));
	                console.error(e);
	              }); // set arrival
	              //  arrivalproc index

	              await fpln.setArrivalProcIndex(data.arrivalProcIndex) // .then(() => console.log(`[FP LOAD] Setting Arrival Procedure ${data.arrivalProcIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Arrival Procedure ".concat(data.arrivalProcIndex, " ... FAILED"));
	                console.error(e);
	              }); //  arrivaltrans index

	              await fpln.setArrivalEnRouteTransitionIndex(data.arrivalEnRouteTransitionIndex) // .then(() => console.log(`[FP LOAD] Setting En Route Transition ${data.arrivalEnRouteTransitionIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting En Route Transition ".concat(data.arrivalEnRouteTransitionIndex, " ... FAILED"));
	                console.error(e);
	              });
	              await fpln.setDestinationRunwayIndexFromApproach() // .then(() => console.log(`[FP LOAD] Setting Destination Runway using ${data.approachIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP LOAD] Setting Destination Runway using ".concat(data.approachIndex, " ... FAILED"));
	                console.error(e);
	              });
	              fpln.resumeSync();
	              this.fpChecksum = fpln.getCurrentFlightPlan().checksum; // Potential CTD source?

	              Coherent.call('SET_ACTIVE_WAYPOINT_INDEX', 0).catch(e => console.error('[FP LOAD] Error when setting Active WP'));
	              Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch(e => console.error('[FP LOAD] Error when recomputing Active WP'));
	              resolve();
	            }
	          }).catch(console.error);
	        }, 500);
	      }, 200);
	    });
	  }

	  static async SaveToGame(fpln) {
	    return __awaiter(this, 0, 0, function* () {
	      return new Promise(() => __awaiter(this, 0, 0, function* () {
	        FlightPlanAsoboSync.init();
	        const plan = fpln.getCurrentFlightPlan();

	        if (plan.checksum !== this.fpChecksum) {
	          // await Coherent.call("CREATE_NEW_FLIGHTPLAN").catch(console.error);
	          yield Coherent.call('SET_CURRENT_FLIGHTPLAN_INDEX', 0, false).catch(console.error);
	          yield Coherent.call('CLEAR_CURRENT_FLIGHT_PLAN').catch(console.error);

	          if (plan.hasPersistentOrigin && plan.hasDestination) {
	            yield Coherent.call('SET_ORIGIN', plan.persistentOriginAirfield.icao, false).catch(console.error); // .then(() => console.log('[FP SAVE] Setting Origin Airfield... SUCCESS'));

	            yield Coherent.call('SET_DESTINATION', plan.destinationAirfield.icao, false).catch(console.error); // .then(() => console.log('[FP SAVE] Setting Destination Airfield... SUCCESS'));

	            let coIndex = 1;

	            for (let i = 0; i < plan.enroute.waypoints.length; i++) {
	              const wpt = plan.enroute.waypoints[i];

	              if (wpt.icao.trim() !== '') {
	                yield Coherent.call('ADD_WAYPOINT', wpt.icao, coIndex, false).catch(console.error); // .then(() => console.log(`[FP SAVE] Adding Waypoint [${wpt.icao}]... SUCCESS`));

	                coIndex++;
	              }
	            }

	            yield Coherent.call('SET_ORIGIN_RUNWAY_INDEX', plan.procedureDetails.originRunwayIndex) // .then(() => console.log(`[FP SAVE] Setting Origin Runway ${plan.procedureDetails.originRunwayIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting Origin Runway ".concat(plan.procedureDetails.originRunwayIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_DEPARTURE_RUNWAY_INDEX', plan.procedureDetails.departureRunwayIndex) // .then(() => console.log(`[FP SAVE] Setting Departure Runway ${plan.procedureDetails.departureRunwayIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting Departure Runway ".concat(plan.procedureDetails.departureRunwayIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_DEPARTURE_PROC_INDEX', plan.procedureDetails.departureIndex) // .then(() => console.log(`[FP SAVE] Setting Departure Procedure ${plan.procedureDetails.departureIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting Departure Procedure ".concat(plan.procedureDetails.departureIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_DEPARTURE_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.departureTransitionIndex) // .then(() => console.log(`[FP SAVE] Setting Departure Transition ${plan.procedureDetails.departureTransitionIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting Departure Transition ".concat(plan.procedureDetails.departureTransitionIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_ARRIVAL_RUNWAY_INDEX', plan.procedureDetails.arrivalRunwayIndex) // .then(() => console.log(`[FP SAVE] Setting Arrival Runway ${plan.procedureDetails.arrivalRunwayIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting  Arrival Runway ".concat(plan.procedureDetails.arrivalRunwayIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_ARRIVAL_PROC_INDEX', plan.procedureDetails.arrivalIndex) // .then(() => console.log(`[FP SAVE] Setting Arrival Procedure ${plan.procedureDetails.arrivalIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting Arrival Procedure ".concat(plan.procedureDetails.arrivalIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_ARRIVAL_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.arrivalTransitionIndex) // .then(() => console.log(`[FP SAVE] Setting Arrival En Route Transition ${plan.procedureDetails.arrivalTransitionIndex} ... SUCCESS`))
	            .catch(e => {
	              console.error("[FP SAVE] Setting Arrival En Route Transition ".concat(plan.procedureDetails.arrivalTransitionIndex, " ... FAILED"));
	              console.error(e);
	            });
	            yield Coherent.call('SET_APPROACH_INDEX', plan.procedureDetails.approachIndex).then(() => {
	              // console.log(`[FP SAVE] Setting Approach ${plan.procedureDetails.approachIndex} ... SUCCESS`);
	              Coherent.call('SET_APPROACH_TRANSITION_INDEX', plan.procedureDetails.approachTransitionIndex) // .then(() => console.log(`[FP SAVE] Setting Approach Transition ${plan.procedureDetails.approachTransitionIndex} ... SUCCESS`))
	              .catch(e => {
	                console.error("[FP SAVE] Setting Approach Transition ".concat(plan.procedureDetails.approachTransitionIndex, " ... FAILED"));
	                console.error(e);
	              });
	            }).catch(e => {
	              console.error("[FP SAVE] Setting Approach ".concat(plan.procedureDetails.approachIndex, " ... FAILED"));
	              console.error(e);
	            });
	          }

	          this.fpChecksum = plan.checksum;
	        }

	        Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch(e => console.log('[FP SAVE] Setting Active Waypoint... FAILED')).then(() => console.log('[FP SAVE] Setting Active Waypoint... SUCCESS'));
	      }));
	    });
	  }

	}

	_defineProperty(FlightPlanAsoboSync, "fpChecksum", 0);

	_defineProperty(FlightPlanAsoboSync, "fpListenerInitialized", false);

	function __awaiter(thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(resolve => {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))((resolve, reject) => {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	}

	// Copyright (c) 2021 FlyByWire Simulations
	// SPDX-License-Identifier: GPL-3.0
	class FixInfo {
	  constructor(flightPlanManager) {
	    _defineProperty(this, "flightPlanManager", void 0);

	    _defineProperty(this, "refFix", void 0);

	    _defineProperty(this, "radials", []);

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "abeam", false);

	    this.flightPlanManager = flightPlanManager;
	  }

	  setRefFix(fix) {
	    this.radials.length = 0;
	    this.radius = undefined;
	    this.abeam = false;
	    this.refFix = fix;
	    this.flightPlanManager.updateFlightPlanVersion();
	  }

	  getRefFix() {
	    return this.refFix;
	  }

	  getRefFixIdent() {
	    var _this$refFix;

	    return (_this$refFix = this.refFix) === null || _this$refFix === void 0 ? void 0 : _this$refFix.ident;
	  }

	  setRadial(index, magneticBearing) {
	    if (magneticBearing !== undefined) {
	      const trueBearing = Avionics.Utils.clampAngle(magneticBearing + Facilities.getMagVar(this.refFix.infos.coordinates.lat, this.refFix.infos.coordinates.long));
	      this.radials[index] = {
	        magneticBearing,
	        trueBearing
	      };
	    } else {
	      this.radials.splice(index, 1);
	    } // TODO calculate flight plan intercepts


	    this.flightPlanManager.updateFlightPlanVersion();
	  }

	  getRadial(index) {
	    return this.radials[index];
	  }

	  getRadialTrueBearings() {
	    return this.radials.map(r => r.trueBearing);
	  }

	  setRadius(radius) {
	    if (radius !== undefined) {
	      this.radius = {
	        radius
	      };
	    } else {
	      this.radius = undefined;
	    } // TODO calculate flight plan intercepts


	    this.flightPlanManager.updateFlightPlanVersion();
	  }

	  getRadius() {
	    return this.radius;
	  }

	  getRadiusValue() {
	    var _this$radius;

	    return (_this$radius = this.radius) === null || _this$radius === void 0 ? void 0 : _this$radius.radius;
	  }

	}

	// Copyright (c) 2021-2022 FlyByWire Simulations
	// Copyright (c) 2021-2022 Synaptic Simulations
	//
	// SPDX-License-Identifier: GPL-3.0
	const LnavConfig = {
	  /* ========== PATHGEN CONFIG ========== */

	  /**
	   * The minimum TAS we ever compute guidables with
	   */
	  DEFAULT_MIN_PREDICTED_TAS: 160,

	  /**
	   * Coefficient applied to all transition turn radii
	   */
	  TURN_RADIUS_FACTOR: 1.0,

	  /**
	   * The number of transitions to compute after the active leg (-1: no limit, compute all transitions)
	   */
	  NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE: -1,

	  /* ========== false INFO ========== */

	  /**
	   * Whether to print geometry generation / update debug info
	   */
	  DEBUG_GEOMETRY: false,

	  /**
	   * Whether to use the L:A32NX_DEBUG_TAS and L:A32NX_DEBUG_GS LVar for prediction speeds
	   */
	  DEBUG_USE_SPEED_LVARS: false,

	  /**
	   * Whether to force the drawing of course reversal (hold, proc turn) vectors at any point in the path
	   */
	  DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS: false,

	  /**
	   * Whether to print guidance debug information on the ND
	   */
	  DEBUG_GUIDANCE: false,

	  /**
	   * Whether to print guidable recomputation info
	   */
	  DEBUG_GUIDABLE_RECOMPUTATION: false,

	  /**
	   * Whether to draw path debug points and print them out
	   */
	  DEBUG_PREDICTED_PATH: false,

	  /**
	   * Whether to print SVG path generation debug info
	   */
	  DEBUG_PATH_DRAWING: false,

	  /**
	   * Whether to print FMS timing information
	   */
	  DEBUG_PERF: false,

	  /**
	   * Whether to save the flight plan to local storage (keeps flight plan over instrument reload)
	   */
	  DEBUG_SAVE_FPLN_LOCAL_STORAGE: false
	};

	let WaypointConstraintType;

	(function (WaypointConstraintType) {
	  WaypointConstraintType[WaypointConstraintType["CLB"] = 1] = "CLB";
	  WaypointConstraintType[WaypointConstraintType["DES"] = 2] = "DES";
	})(WaypointConstraintType || (WaypointConstraintType = {}));

	let FlightPlans;
	/**
	 * Navigation flight areas defined in the OPC database
	 */

	(function (FlightPlans) {
	  FlightPlans[FlightPlans["Active"] = 0] = "Active";
	  FlightPlans[FlightPlans["Temporary"] = 1] = "Temporary";
	})(FlightPlans || (FlightPlans = {}));

	let FlightArea;
	/**
	 * A system for managing flight plan data used by various instruments.
	 */

	(function (FlightArea) {
	  FlightArea[FlightArea["Terminal"] = 0] = "Terminal";
	  FlightArea[FlightArea["Takeoff"] = 1] = "Takeoff";
	  FlightArea[FlightArea["Enroute"] = 2] = "Enroute";
	  FlightArea[FlightArea["Oceanic"] = 3] = "Oceanic";
	  FlightArea[FlightArea["VorApproach"] = 4] = "VorApproach";
	  FlightArea[FlightArea["GpsApproach"] = 5] = "GpsApproach";
	  FlightArea[FlightArea["PrecisionApproach"] = 6] = "PrecisionApproach";
	  FlightArea[FlightArea["NonPrecisionApproach"] = 7] = "NonPrecisionApproach";
	})(FlightArea || (FlightArea = {}));

	class FlightPlanManager {
	  /**
	   * The current stored flight plan data.
	   * @type ManagedFlightPlan[]
	   */

	  /**
	   * Constructs an instance of the FlightPlanManager with the provided
	   * parent instrument attached.
	   * @param parentInstrument The parent instrument attached to this FlightPlanManager.
	   */
	  constructor(_parentInstrument) {
	    this._parentInstrument = _parentInstrument;

	    _defineProperty(this, "_isRegistered", false);

	    _defineProperty(this, "_isMaster", false);

	    _defineProperty(this, "_isSyncPaused", false);

	    _defineProperty(this, "_currentFlightPlanVersion", 0);

	    _defineProperty(this, "__currentFlightPlanIndex", 0);

	    _defineProperty(this, "activeArea", FlightArea.Terminal);

	    _defineProperty(this, "_flightPlans", []);

	    _defineProperty(this, "_fixInfos", []);

	    _defineProperty(this, "updateThrottler", new A32NX_Util.UpdateThrottler(2000));

	    this._currentFlightPlanVersion = SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number');

	    this._loadFlightPlans();

	    if (_parentInstrument.instrumentIdentifier === 'A320_Neo_CDU') {
	      this._isMaster = true;

	      _parentInstrument.addEventListener('FlightStart', async () => {
	        const plan = new ManagedFlightPlan();
	        plan.setParentInstrument(_parentInstrument);
	        this._flightPlans = [];

	        this._flightPlans.push(plan);

	        if (NXDataStore.get('FP_SYNC', 'LOAD') !== 'NONE') {
	          this.pauseSync();
	          await FlightPlanAsoboSync.LoadFromGame(this).catch(console.error);
	        }

	        this.resumeSync();
	      });

	      for (let i = 0; i < 4; i++) {
	        this._fixInfos.push(new FixInfo(this));
	      }
	    }

	    FlightPlanManager.DEBUG_INSTANCE = this;
	  }

	  get _currentFlightPlanIndex() {
	    return this.__currentFlightPlanIndex;
	  }

	  set _currentFlightPlanIndex(value) {
	    this.__currentFlightPlanIndex = value;
	  }

	  update(deltaTime) {
	    if (this.updateThrottler.canUpdate(deltaTime) !== -1) {
	      const tmpy = this._flightPlans[FlightPlans.Temporary];

	      if (tmpy && this.__currentFlightPlanIndex === FlightPlans.Temporary) {
	        if (tmpy.updateTurningPoint()) {
	          this.updateFlightPlanVersion();
	        }
	      }
	    }

	    this.updateActiveArea();
	  }

	  onCurrentGameFlightLoaded(_callback) {
	    _callback();
	  }

	  registerListener() {}

	  addHardCodedConstraints(wp) {}
	  /**
	   * Loads sim flight plan data into WayPoint objects for consumption.
	   * @param data The flight plan data to load.
	   * @param currentWaypoints The waypoints array to modify with the data loaded.
	   * @param callback A callback to call when the data has completed loading.
	   */


	  _loadWaypoints(data, currentWaypoints, callback) {}
	  /**
	   * Updates the current active waypoint index from the sim.
	   */


	  async updateWaypointIndex() {// const waypointIndex = await Coherent.call("GET_ACTIVE_WAYPOINT_INDEX");
	    // this._activeWaypointIndex = waypointIndex;
	  }
	  /**
	   * Scans for updates to the synchronized flight plan and loads them into the flight plan
	   * manager if the flight plan is out of date.
	   * @param {() => void} callback A callback to call when the update has completed.
	   * @param {Boolean} log Whether or not to log the loaded flight plan value.
	   */


	  updateFlightPlan() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
	    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    const flightPlanVersion = SimVar.GetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number');

	    if (flightPlanVersion !== this._currentFlightPlanVersion || force) {
	      this._loadFlightPlans();

	      this._currentFlightPlanVersion = flightPlanVersion;
	    }

	    callback();
	  }
	  /**
	   * Loads the flight plans from data storage.
	   */


	  _loadFlightPlans() {
	    this._getFlightPlan();

	    if (this._flightPlans.length === 0) {
	      const newFpln = new ManagedFlightPlan();
	      newFpln.setParentInstrument(this._parentInstrument);

	      this._flightPlans.push(new ManagedFlightPlan());
	    } else {
	      this._flightPlans = this._flightPlans.map(fp => ManagedFlightPlan.fromObject(fp, this._parentInstrument));
	    }
	  }

	  updateCurrentApproach() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
	    callback();
	  }

	  get cruisingAltitude() {
	    return 0;
	  }

	  isCurrentFlightPlanTemporary() {
	    return this.getCurrentFlightPlanIndex() === 1;
	  }
	  /**
	   * Gets the index of the currently active flight plan.
	   */


	  getCurrentFlightPlanIndex() {
	    return this._currentFlightPlanIndex;
	  }
	  /**
	   * Switches the active flight plan index to the supplied index.
	   * @param index The index to now use for the active flight plan.
	   * @param callback A callback to call when the operation has completed.
	   */


	  setCurrentFlightPlanIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Boolean;

	    if (index >= 0 && index < this._flightPlans.length) {
	      this._currentFlightPlanIndex = index;
	      callback(true);
	    } else {
	      callback(false);
	    }
	  }
	  /**
	   * Creates a new flight plan.
	   * @param callback A callback to call when the operation has completed.
	   */


	  createNewFlightPlan() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    const newFlightPlan = new ManagedFlightPlan();
	    newFlightPlan.setParentInstrument(this._parentInstrument);

	    this._flightPlans.push(newFlightPlan);

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Copies the currently active flight plan into the specified flight plan index.
	   * @param index The index to copy the currently active flight plan into.
	   * @param callback A callback to call when the operation has completed.
	   */


	  async copyCurrentFlightPlanInto(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;

	    const copiedFlightPlan = this._flightPlans[this._currentFlightPlanIndex].copy();

	    const {
	      activeWaypointIndex
	    } = copiedFlightPlan;

	    if (this._currentFlightPlanIndex === FlightPlans.Temporary && index === FlightPlans.Active) {
	      copiedFlightPlan.waypoints.forEach(wp => delete wp.additionalData.dynamicPpos);
	    }

	    this._flightPlans[index] = copiedFlightPlan;

	    if (index === 0) {
	      await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Copies the flight plan at the specified index to the currently active flight plan index.
	   * @param index The index to copy into the currently active flight plan.
	   * @param callback A callback to call when the operation has completed.
	   */


	  async copyFlightPlanIntoCurrent(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;

	    const copiedFlightPlan = this._flightPlans[index].copy();

	    const {
	      activeWaypointIndex
	    } = copiedFlightPlan;
	    this._flightPlans[this._currentFlightPlanIndex] = copiedFlightPlan;

	    if (this._currentFlightPlanIndex === 0) {
	      await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Clears the currently active flight plan.
	   * @param callback A callback to call when the operation has completed.
	   */


	  async clearFlightPlan() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    await this._flightPlans[this._currentFlightPlanIndex].clearPlan().catch(console.error);

	    for (const fixInfo of this._fixInfos) {
	      fixInfo.setRefFix();
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }

	  async deleteFlightPlan(flightPlanIndex) {
	    if (this._flightPlans[flightPlanIndex]) {
	      delete this._flightPlans[flightPlanIndex];
	    }
	  }
	  /**
	   * Gets the origin of the currently active flight plan.
	   */


	  getOrigin() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    return this._flightPlans[flightPlanIndex].originAirfield;
	  }
	  /**
	   * Gets the origin of the currently active flight plan, even after it has been cleared for a direct-to.
	   */


	  getPersistentOrigin() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    return this._flightPlans[flightPlanIndex].persistentOriginAirfield;
	  }
	  /**
	   * Sets the origin in the currently active flight plan.
	   * @param icao The ICAO designation of the origin airport.
	   * @param callback A callback to call when the operation has completed.
	   */


	  async setOrigin(icao) {
	    var _this$getOrigin;

	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const sameAirport = ((_this$getOrigin = this.getOrigin()) === null || _this$getOrigin === void 0 ? void 0 : _this$getOrigin.ident) === icao;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const airport = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(console.error);

	    if (airport) {
	      airport.additionalData = {};
	      airport.additionalData.legType = LegType.IF;
	      await currentFlightPlan.clearPlan().catch(console.error);
	      await currentFlightPlan.addWaypoint(airport, 0); // clear pilot trans alt

	      this.setOriginTransitionAltitude(undefined, false); // TODO get origin trans alt from database
	      // until then, don't erase the database value from ATSU if same airport as before

	      if (!sameAirport) {
	        this.setOriginTransitionAltitude(undefined, true);
	      }

	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Gets the index of the active waypoint in the flight plan.
	   * @param forceSimVarCall Unused
	   * @param useCorrection Unused
	   */


	  getActiveWaypointIndex() {
	    var _this$_flightPlans$fl, _this$_flightPlans$fl2;
	    let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
	    }

	    return (_this$_flightPlans$fl = (_this$_flightPlans$fl2 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl2 === void 0 ? void 0 : _this$_flightPlans$fl2.activeWaypointIndex) !== null && _this$_flightPlans$fl !== void 0 ? _this$_flightPlans$fl : -1;
	  }

	  isActiveWaypointAtEnd() {
	    let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex + 1 === this.getWaypointsCount(this._currentFlightPlanIndex) - 1;
	    }

	    return this._flightPlans[flightPlanIndex].activeWaypointIndex === this.getWaypointsCount(flightPlanIndex) - 1;
	  }
	  /**
	   * Sets the index of the active waypoint in the flight plan.
	   * @param index The index to make active in the flight plan.
	   * @param callback A callback to call when the operation has completed.
	   * @param fplnIndex The index of the flight plan
	   */


	  setActiveWaypointIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
	    let fplnIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[fplnIndex]; // we allow the last leg to be sequenced therefore the index can be 1 past the end of the plan length

	    if (index >= 0 && index <= currentFlightPlan.length) {
	      currentFlightPlan.activeWaypointIndex = index;
	      Coherent.call('SET_ACTIVE_WAYPOINT_INDEX', index + 1).catch(console.error);

	      if (currentFlightPlan.directTo.isActive && currentFlightPlan.directTo.waypointIsInFlightPlan && currentFlightPlan.activeWaypointIndex > currentFlightPlan.directTo.planWaypointIndex) {
	        currentFlightPlan.directTo.isActive = false;
	      }
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /** Unknown */


	  recomputeActiveWaypointIndex() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    callback();
	  }
	  /**
	   * Gets the index of the waypoint prior to the currently active waypoint.
	   * @param forceSimVarCall Unused
	   */


	  getPreviousActiveWaypoint() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const previousWaypointIndex = currentFlightPlan.activeWaypointIndex - 1;
	    return currentFlightPlan.getWaypoint(previousWaypointIndex);
	  }
	  /**
	   * Gets the ident of the active waypoint.
	   * @param forceSimVarCall Unused
	   */


	  getActiveWaypointIdent() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.activeWaypoint) {
	      return currentFlightPlan.activeWaypoint.ident;
	    }

	    return '';
	  }
	  /**
	   * Gets the active waypoint index from fs9gps. Currently unimplemented.
	   * @param forceSimVarCall Unused
	   */


	  getGPSActiveWaypointIndex() {
	    return this.getActiveWaypointIndex();
	  }
	  /**
	   * Gets the active waypoint.
	   * @param forceSimVarCall Unused
	   * @param useCorrection Unused
	   */


	  getActiveWaypoint() {
	    let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      flightPlanIndex = this._currentFlightPlanIndex;
	    }

	    return this._flightPlans[flightPlanIndex].activeWaypoint;
	  }
	  /**
	   * Gets the next waypoint following the active waypoint.
	   * @param forceSimVarCall Unused
	   */


	  getNextActiveWaypoint() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const nextWaypointIndex = currentFlightPlan.activeWaypointIndex + 1;
	    return currentFlightPlan.getWaypoint(nextWaypointIndex);
	  }
	  /**
	   * Gets the distance, in NM, to the active waypoint.
	   */


	  getDistanceToActiveWaypoint() {
	    // TODO Replace with ADIRS getLatitude() getLongitude()
	    const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
	    const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
	    const ll = new LatLongAlt(lat, long);
	    const waypoint = this.getActiveWaypoint();

	    if (waypoint && waypoint.infos) {
	      return Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
	    }

	    return 0;
	  }
	  /**
	   *
	   * @param fplnIndex index of the flight plan of interest, default active fp
	   * @returns distance in NM, or -1 on error
	   */


	  getDistanceToDestination() {
	    var _stats$get$distanceFr, _stats$get;

	    let fplnIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

	    if (fplnIndex < 0) {
	      fplnIndex = this._currentFlightPlanIndex;
	    }

	    const destIndex = this.getDestinationIndex();

	    if (destIndex < 0) {
	      return -1;
	    } // TODO get proper pos from FMGC


	    const fmPos = {
	      lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
	      long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
	    };
	    const fpln = this._flightPlans[fplnIndex];
	    const stats = fpln.computeWaypointStatistics(fmPos);
	    return (_stats$get$distanceFr = (_stats$get = stats.get(destIndex)) === null || _stats$get === void 0 ? void 0 : _stats$get.distanceFromPpos) !== null && _stats$get$distanceFr !== void 0 ? _stats$get$distanceFr : -1;
	  }

	  getApproachStats() {
	    var _this$getApproach;

	    const name = (_this$getApproach = this.getApproach(FlightPlans.Active)) === null || _this$getApproach === void 0 ? void 0 : _this$getApproach.name;

	    if (!name) {
	      return undefined;
	    }

	    const distanceFromPpos = this.getDistanceToDestination(FlightPlans.Active);
	    return {
	      name,
	      distanceFromPpos
	    };
	  }
	  /**
	   * Gets the bearing, in degrees, to the active waypoint.
	   */


	  getBearingToActiveWaypoint() {
	    // TODO Replace with ADIRS getLatitude() getLongitude()
	    const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
	    const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
	    const ll = new LatLongAlt(lat, long);
	    const waypoint = this.getActiveWaypoint();

	    if (waypoint && waypoint.infos) {
	      return Avionics.Utils.computeGreatCircleHeading(ll, waypoint.infos.coordinates);
	    }

	    return 0;
	  }
	  /**
	   * Gets the estimated time enroute to the active waypoint.
	   */


	  getETEToActiveWaypoint() {
	    // TODO Replace with ADIRS getLatitude() getLongitude()
	    const lat = SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude');
	    const long = SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude');
	    const ll = new LatLongAlt(lat, long);
	    const waypoint = this.getActiveWaypoint();

	    if (waypoint && waypoint.infos) {
	      const dist = Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
	      let groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'knots');

	      if (groundSpeed < 50) {
	        groundSpeed = 50;
	      }

	      if (groundSpeed > 0.1) {
	        return dist / groundSpeed * 3600;
	      }
	    }

	    return 0;
	  }
	  /**
	   * Gets the destination airfield of the current flight plan, if any.
	   */


	  getDestination() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    return this._flightPlans[flightPlanIndex].destinationAirfield;
	  }
	  /**
	   * Gets the index of the destination airfield in the current flight plan, if any
	   * @param flightPlanIndex flight plan index
	   * @returns Index of destination
	   */


	  getDestinationIndex() {
	    if (this.getDestination()) {
	      return this.getWaypointsCount() - 1;
	    }

	    return -1;
	  }
	  /**
	   * Gets the currently selected departure information for the current flight plan.
	   */


	  getDeparture() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;
	    const origin = this.getOrigin();

	    if (isNaN(flightPlanIndex)) {
	      flightPlanIndex = this._currentFlightPlanIndex;
	    }

	    const currentFlightPlan = this._flightPlans[flightPlanIndex];

	    if (origin) {
	      const originInfos = origin.infos;

	      if (originInfos.departures !== undefined && currentFlightPlan.procedureDetails.departureIndex >= 0) {
	        return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex];
	      }
	    }

	    return undefined;
	  }
	  /**
	   * Gets the currently selected departure information for the current flight plan, even after a direct-to.
	   */


	  getDepartureName() {
	    const origin = this.getPersistentOrigin();
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (origin) {
	      const originInfos = origin.infos;

	      if (originInfos.departures !== undefined && currentFlightPlan.procedureDetails.departureIndex >= 0) {
	        return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex].name;
	      }
	    }

	    return undefined;
	  }
	  /**
	   * Gets the currently selected arrival information for the current flight plan.
	   */


	  getArrival() {
	    const destination = this.getDestination();
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (destination) {
	      const originInfos = destination.infos;

	      if (originInfos.arrivals !== undefined && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
	        return originInfos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex];
	      }
	    }

	    return undefined;
	  }
	  /**
	   * Gets the currently selected approach information for the current flight plan.
	   */


	  getAirportApproach() {
	    const destination = this.getDestination();
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (destination) {
	      const originInfos = destination.infos;

	      if (originInfos.approaches !== undefined && currentFlightPlan.procedureDetails.approachIndex >= 0) {
	        return originInfos.approaches[currentFlightPlan.procedureDetails.approachIndex];
	      }
	    }

	    return undefined;
	  }
	  /**
	   * Gets the departure waypoints for the current flight plan.
	   */


	  getDepartureWaypoints() {
	    return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
	  }
	  /**
	   * Gets a map of the departure waypoints (?)
	   */


	  getDepartureWaypointsMap() {
	    return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
	  }
	  /**
	   * Gets the enroute waypoints for the current flight plan.
	   * @param outFPIndex An array of waypoint indexes to be pushed to.
	   */


	  getEnRouteWaypoints(outFPIndex) {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const enrouteSegment = currentFlightPlan.enroute;

	    if (enrouteSegment !== FlightPlanSegment.Empty) {
	      for (let i = 0; i < enrouteSegment.waypoints.length; i++) {
	        outFPIndex.push(enrouteSegment.offset + i);
	      }
	    }

	    return enrouteSegment.waypoints;
	  }
	  /**
	   * Gets the index of the last waypoint in the enroute segment of the current flight plan.
	   */


	  getEnRouteWaypointsFirstIndex() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    const enrouteSegment = currentFlightPlan === null || currentFlightPlan === void 0 ? void 0 : currentFlightPlan.enroute;
	    return enrouteSegment === null || enrouteSegment === void 0 ? void 0 : enrouteSegment.offset;
	  }
	  /**
	   * Gets the index of the last waypoint in the enroute segment of the current flight plan.
	   */


	  getEnRouteWaypointsLastIndex() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    const enrouteSegment = currentFlightPlan === null || currentFlightPlan === void 0 ? void 0 : currentFlightPlan.enroute;
	    return enrouteSegment ? enrouteSegment.offset + (enrouteSegment.waypoints.length - 1) : null;
	  }
	  /**
	   * Gets the arrival waypoints for the current flight plan.
	   */


	  getArrivalWaypoints() {
	    return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
	  }
	  /**
	   * Gets the arrival waypoints for the current flight plan as a map. (?)
	   */


	  getArrivalWaypointsMap() {
	    return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
	  }
	  /**
	   * Gets the waypoints for the current flight plan with altitude constraints.
	   */


	  getWaypointsWithAltitudeConstraints() {
	    return this._flightPlans[this._currentFlightPlanIndex].waypoints;
	  }
	  /**
	   * Gets the flight plan segment for a flight plan waypoint.
	   * @param waypoint The waypoint we want to find the segment for.
	   */


	  getSegmentFromWaypoint(waypoint) {
	    let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      flightPlanIndex = this._currentFlightPlanIndex;
	    }

	    const index = waypoint === undefined ? this.getActiveWaypointIndex() : this.indexOfWaypoint(waypoint);
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    return currentFlightPlan.findSegmentByWaypointIndex(index);
	  }
	  /**
	   * Sets the destination for the current flight plan.
	   * @param icao The ICAO designation for the destination airfield.
	   * @param callback A callback to call once the operation completes.
	   */


	  async setDestination(icao) {
	    var _this$getDestination;

	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const sameAirport = ((_this$getDestination = this.getDestination()) === null || _this$getDestination === void 0 ? void 0 : _this$getDestination.ident) === icao;
	    const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao);
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const destinationIndex = currentFlightPlan.length - 1;

	    if (currentFlightPlan.hasDestination) {
	      currentFlightPlan.removeWaypoint(destinationIndex);
	    }

	    currentFlightPlan.addWaypoint(waypoint); // make the waypoint before a discontinuity

	    /*
	    const { waypoints } = currentFlightPlan;
	    if (waypoints.length > 0 && destinationIndex > 0) {
	        const previous = currentFlightPlan.waypoints[destinationIndex - 1];
	        // ensure we do not overwrite a possible discontinuityCanBeCleared
	        if (!previous.endsInDiscontinuity) {
	            previous.endsInDiscontinuity = true;
	            previous.discontinuityCanBeCleared = true;
	        }
	    }
	    */
	    // clear pilot trans level

	    this.setDestinationTransitionLevel(undefined, false); // TODO get destination trans level from database
	    // until then, don't erase the database value from ATSU if same airport as before

	    if (!sameAirport) {
	      this.setDestinationTransitionLevel(undefined, true);
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Adds a waypoint to the current flight plan.
	   * @param icao The ICAO designation for the waypoint.
	   * @param index The index of the waypoint to add.
	   * @param callback A callback to call once the operation completes.
	   * @param setActive Whether or not to set the added waypoint as active immediately.
	   */


	  async addWaypoint(icao) {
	    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(e => {
	      console.log("addWaypoint: [".concat(icao, "] Error"));
	      console.error(e);
	    });

	    if (waypoint) {
	      currentFlightPlan.addWaypoint(waypoint, index);

	      this.updateFlightPlanVersion().catch(console.error);
	      callback();
	    }
	  }
	  /**
	   * Adds a user waypoint to the current flight plan.
	   * @param waypoint The user waypoint to add.
	   * @param index The index to add the waypoint at in the flight plan.
	   * @param callback A callback to call once the operation completes.
	   */


	  async addUserWaypoint(waypoint) {
	    let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    currentFlightPlan.addWaypoint(waypoint, index);
	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }

	  setLegAltitudeDescription(waypoint, code) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};

	    if (waypoint) {
	      waypoint.legAltitudeDescription = code;
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the altitude constraint for a waypoint in the current flight plan.
	   * @param altitude The altitude to set for the waypoint.
	   * @param index The index of the waypoint to set.
	   * @param callback A callback to call once the operation is complete.
	   * @param isDescentConstraint For enroute waypoints, indicates whether constraint is a descent or climb constraint
	   */


	  setWaypointAltitude(altitude, index) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    let isDescentConstraint = arguments.length > 3 ? arguments[3] : undefined;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const waypoint = currentFlightPlan.getWaypoint(index);

	    if (waypoint) {
	      waypoint.legAltitude1 = altitude;

	      if (isDescentConstraint !== undefined && !waypoint.additionalData.constraintType) {
	        // this propagates through intermediate waypoints
	        if (isDescentConstraint) {
	          this.setFirstDesConstraintWaypoint(index);
	        } else {
	          this.setLastClbConstraintWaypoint(index);
	        }
	      }

	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the speed constraint for a waypoint in the current flight plan.
	   * @param speed The speed to set for the waypoint.
	   * @param index The index of the waypoint to set.
	   * @param callback A callback to call once the operation is complete.
	   * @param isDescentConstraint For enroute waypoints, indicates whether constraint is a descent or climb constraint
	   */


	  setWaypointSpeed(speed, index) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    let isDescentConstraint = arguments.length > 3 ? arguments[3] : undefined;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const waypoint = currentFlightPlan.getWaypoint(index);

	    if (waypoint) {
	      waypoint.speedConstraint = speed; // this propagates through intermediate waypoints

	      if (isDescentConstraint) {
	        this.setFirstDesConstraintWaypoint(index);
	      } else {
	        this.setLastClbConstraintWaypoint(index);
	      }

	      this.updateFlightPlanVersion();
	    }

	    callback();
	  }

	  setLastClbConstraintWaypoint(index) {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    for (let i = index; i >= 0; i--) {
	      const waypoint = currentFlightPlan.getWaypoint(i);

	      if (waypoint) {
	        waypoint.additionalData.constraintType = WaypointConstraintType.CLB;
	      }
	    }
	  }

	  setFirstDesConstraintWaypoint(index) {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    for (let i = index; i < this.getWaypointsCount(); i++) {
	      const waypoint = currentFlightPlan.getWaypoint(i);

	      if (waypoint) {
	        waypoint.additionalData.constraintType = WaypointConstraintType.DES;
	      }
	    }
	  }
	  /**
	   * Sets additional data on a waypoint in the current flight plan.
	   * @param index The index of the waypoint to set additional data for.
	   * @param key The key of the data.
	   * @param value The value of the data.
	   * @param callback A callback to call once the operation is complete.
	   */


	  setWaypointAdditionalData(index, key, value) {
	    let callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const waypoint = currentFlightPlan.getWaypoint(index);

	    if (waypoint) {
	      waypoint.additionalData[key] = value;
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Gets additional data on a waypoint in the current flight plan.
	   * @param index The index of the waypoint to set additional data for.
	   * @param key The key of the data.
	   * @param callback A callback to call with the value once the operation is complete.
	   */


	  getWaypointAdditionalData(index, key) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const waypoint = currentFlightPlan.getWaypoint(index);

	    if (waypoint) {
	      callback(waypoint.additionalData[key]);
	    } else {
	      callback(undefined);
	    }
	  }
	  /**
	   * Reverses the currently active flight plan.
	   * @param {() => void} callback A callback to call when the operation is complete.
	   */


	  invertActiveFlightPlan() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};

	    this._flightPlans[this._currentFlightPlanIndex].reverse();

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Not sure what this is supposed to do.
	   * @param callback Stuff?
	   */


	  getApproachIfIcao() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
	    callback(this.getApproach());
	  }
	  /**
	   * Unused
	   * @param {*} _callback Unused
	   */


	  addFlightPlanUpdateCallback(_callback) {}
	  /**
	   * Adds a waypoint to the currently active flight plan by ident(?)
	   * @param ident The ident of the waypoint.
	   * @param index The index to add the waypoint at.
	   * @param callback A callback to call when the operation finishes.
	   */


	  addWaypointByIdent(ident, index) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyCallback.Void;
	    this.addWaypoint(ident, index, callback).catch(console.error);
	  }
	  /**
	   * Removes a waypoint from the currently active flight plan.
	   * @param index The index of the waypoint to remove.
	   * @param noDiscontinuity Don't create a discontinuity
	   * @param callback A callback to call when the operation finishes.
	   */


	  removeWaypoint(index) {
	    let noDiscontinuity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};

	    this._flightPlans[this._currentFlightPlanIndex].removeWaypoint(index, noDiscontinuity);

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }

	  addWaypointOverfly(index) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};

	    this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, true);

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }

	  removeWaypointOverfly(index) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};

	    this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, false);

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }

	  addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
	    const holdIndex = this._flightPlans[this._currentFlightPlanIndex].addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold);

	    this.updateFlightPlanVersion().catch(console.error);
	    return holdIndex;
	  }
	  /**
	   * Truncates a flight plan after a specific waypoint.
	   * @param index The index of the first waypoint to remove.
	   * @param callback A callback to call when the operation finishes.
	   */


	  truncateWaypoints(index) {
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    const fp = this._flightPlans[this._currentFlightPlanIndex];

	    for (let i = fp.length; i >= index; i--) {
	      fp.removeWaypoint(index);
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Gets the index of a given waypoint in the current flight plan.
	   * @param waypoint The waypoint to get the index of.
	   */


	  indexOfWaypoint(waypoint) {
	    return this._flightPlans[this._currentFlightPlanIndex].waypoints.indexOf(waypoint);
	  }
	  /**
	   * Gets the number of waypoints in a flight plan.
	   * @param flightPlanIndex The index of the flight plan. If omitted, will get the current flight plan.
	   */


	  getWaypointsCount() {
	    var _this$_flightPlans$fl3, _this$_flightPlans$fl4;

	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      var _this$_flightPlans$th, _this$_flightPlans$th2;

	      return (_this$_flightPlans$th = (_this$_flightPlans$th2 = this._flightPlans[this._currentFlightPlanIndex]) === null || _this$_flightPlans$th2 === void 0 ? void 0 : _this$_flightPlans$th2.length) !== null && _this$_flightPlans$th !== void 0 ? _this$_flightPlans$th : 0;
	    }

	    return (_this$_flightPlans$fl3 = (_this$_flightPlans$fl4 = this._flightPlans[flightPlanIndex]) === null || _this$_flightPlans$fl4 === void 0 ? void 0 : _this$_flightPlans$fl4.length) !== null && _this$_flightPlans$fl3 !== void 0 ? _this$_flightPlans$fl3 : 0;
	  }
	  /**
	   * Gets a count of the number of departure waypoints in the current flight plan.
	   */


	  getDepartureWaypointsCount() {
	    return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints.length;
	  }
	  /**
	   * Gets a count of the number of arrival waypoints in the current flight plan.
	   */


	  getArrivalWaypointsCount() {
	    return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints.length;
	  }
	  /**
	   * Gets a waypoint from a flight plan.
	   * @param index The index of the waypoint to get.
	   * @param flightPlanIndex The index of the flight plan to get the waypoint from. If omitted, will get from the current flight plan.
	   * @param considerApproachWaypoints Whether or not to consider approach waypoints.
	   */


	  getWaypoint(index) {
	    let flightPlanIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      flightPlanIndex = this._currentFlightPlanIndex;
	    }

	    return this._flightPlans[flightPlanIndex].getWaypoint(index);
	  }
	  /**
	   * Gets all non-approach waypoints from a flight plan.
	   *
	   * @param flightPlanIndex The index of the flight plan to get the waypoints from. If omitted, will get from the current flight plan.
	   */


	  getWaypoints() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;

	    if (isNaN(flightPlanIndex)) {
	      flightPlanIndex = this._currentFlightPlanIndex;
	    }

	    return this._flightPlans[flightPlanIndex].nonApproachWaypoints;
	  }
	  /**
	   * Gets all waypoints from a flight plan.
	   * @param flightPlanIndex The index of the flight plan to get the waypoints from. If omitted, will get from the current flight plan.
	   */


	  getAllWaypoints(flightPlanIndex) {
	    if (flightPlanIndex === undefined) {
	      flightPlanIndex = this._currentFlightPlanIndex;
	    }

	    return this._flightPlans[flightPlanIndex].waypoints;
	  }
	  /**
	   * Gets the departure runway index, based on the departure in a flight plan.
	   */


	  getDepartureRunwayIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.hasOrigin) {
	      return currentFlightPlan.procedureDetails.departureRunwayIndex;
	    }

	    return -1;
	  }
	  /**
	   * Gets the index value of the origin runway (oneWayRunways) in a flight plan.
	   */


	  getOriginRunwayIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.originRunwayIndex >= 0 && currentFlightPlan.originAirfield) {
	      return currentFlightPlan.procedureDetails.originRunwayIndex;
	    }

	    return -1;
	  }
	  /**
	   * Gets the string value of the departure runway in the current flight plan.
	   */


	  getOriginRunway() {
	    const runwayIndex = this.getOriginRunwayIndex();

	    if (runwayIndex >= 0) {
	      return this.getOrigin().infos.oneWayRunways[runwayIndex];
	    }

	    return undefined;
	  }
	  /**
	   * Gets the best runway based on the current plane heading.
	   */


	  getDetectedCurrentRunway() {
	    const origin = this.getOrigin();

	    if (origin && origin.infos instanceof AirportInfo) {
	      const runways = origin.infos.oneWayRunways;

	      if (runways && runways.length > 0) {
	        const direction = Simplane.getHeadingMagnetic();
	        let bestRunway = runways[0];
	        let bestDeltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, bestRunway.direction));

	        for (let i = 1; i < runways.length; i++) {
	          const deltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, runways[i].direction));

	          if (deltaAngle < bestDeltaAngle) {
	            bestDeltaAngle = deltaAngle;
	            bestRunway = runways[i];
	          }
	        }

	        return bestRunway;
	      }
	    }

	    return undefined;
	  }
	  /**
	   * Gets the departure procedure index for the current flight plan.
	   */


	  getDepartureProcIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    return currentFlightPlan.procedureDetails.departureIndex;
	  }
	  /**
	   * Sets the departure procedure index for the current flight plan.
	   * @param index The index of the departure procedure in the origin airport departures information.
	   * @param callback A callback to call when the operation completes.
	   */


	  async setDepartureProcIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.departureIndex !== index) {
	      currentFlightPlan.procedureDetails.departureIndex = index;
	      await currentFlightPlan.buildDeparture().catch(console.error);
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the departure runway index for the current flight plan.
	   * @param index The index of the runway in the origin airport runway information.
	   * @param callback A callback to call when the operation completes.
	   */


	  async setDepartureRunwayIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.departureRunwayIndex !== index) {
	      currentFlightPlan.procedureDetails.departureRunwayIndex = index;
	      await currentFlightPlan.buildDeparture().catch(console.error);
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the origin runway index for the current flight plan.
	   * @param index The index of the runway in the origin airport runway information.
	   * @param callback A callback to call when the operation completes.
	   */


	  async setOriginRunwayIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.originRunwayIndex !== index) {
	      currentFlightPlan.procedureDetails.originRunwayIndex = index;
	      await currentFlightPlan.buildDeparture().catch(console.error);
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }

	  async setOriginRunwayIndexFromDeparture() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.hasOrigin && currentFlightPlan.procedureDetails.departureRunwayIndex >= 0 && currentFlightPlan.procedureDetails.departureIndex >= 0 && currentFlightPlan.originAirfield) {
	      const transition = currentFlightPlan.originAirfield.infos.departures[currentFlightPlan.procedureDetails.departureIndex].runwayTransitions[currentFlightPlan.procedureDetails.departureRunwayIndex];
	      const runways = currentFlightPlan.originAirfield.infos.oneWayRunways;
	      await this.setOriginRunwayIndex(runways.findIndex(r => r.number === transition.runwayNumber && r.designator === transition.runwayDesignation));
	    }
	  }
	  /**
	   * Gets the departure transition index for the current flight plan.
	   */


	  getDepartureEnRouteTransitionIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    return currentFlightPlan.procedureDetails.departureTransitionIndex;
	  }
	  /**
	   * Sets the departure transition index for the current flight plan.
	   * @param index The index of the departure transition to select.
	   * @param callback A callback to call when the operation completes.
	   */


	  async setDepartureEnRouteTransitionIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EmptyCallback.Void;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.departureTransitionIndex !== index) {
	      currentFlightPlan.procedureDetails.departureTransitionIndex = index;
	      await currentFlightPlan.buildDeparture().catch(console.error);
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Unused
	   */


	  getDepartureDiscontinuity() {}
	  /**
	   * Unused
	   * @param callback A callback to call when the operation completes.
	   */


	  clearDepartureDiscontinuity() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    callback();
	  }
	  /**
	   * Removes the departure from the currently active flight plan.
	   * @param callback A callback to call when the operation completes.
	   */


	  async removeDeparture() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    currentFlightPlan.procedureDetails.departureIndex = -1;
	    await currentFlightPlan.buildDeparture().catch(console.error);
	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Gets the arrival procedure index in the currenly active flight plan.
	   */


	  getArrivalProcIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
	      return currentFlightPlan.procedureDetails.arrivalIndex;
	    }

	    return -1;
	  }
	  /**
	   * Gets the arrival transition procedure index in the currently active flight plan.
	   */


	  getArrivalTransitionIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    return currentFlightPlan.procedureDetails.arrivalTransitionIndex;
	  }
	  /**
	   * Sets the arrival procedure index for the current flight plan.
	   * @param {Number} index The index of the arrival procedure to select.
	   * @param {() => void} callback A callback to call when the operation completes.
	   */


	  async setArrivalProcIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.arrivalIndex !== index) {
	      // console.log('FPM: setArrivalProcIndex: SET STAR ', currentFlightPlan.destinationAirfield.infos.arrivals[index].name);
	      currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
	      currentFlightPlan.procedureDetails.arrivalIndex = index;
	      currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
	      await currentFlightPlan.rebuildArrivalApproach();
	      this.updateFlightPlanVersion().catch(console.error);
	    } // TODO check for transition level coded in procedure...
	    // pick higher of procedure or destination airfield trans fl


	    callback();
	  }
	  /**
	   * Unused
	   */


	  getArrivalDiscontinuity() {}
	  /**
	   * Unused
	   * @param {*} callback
	   */


	  clearArrivalDiscontinuity() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    callback();
	  }
	  /**
	   * Clears a discontinuity from the end of a waypoint.
	   * @param index
	   */


	  clearDiscontinuity(index) {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    const waypoint = currentFlightPlan.getWaypoint(index);
	    const nextWaypoint = currentFlightPlan.getWaypoint(index + 1);

	    if (waypoint !== undefined && nextWaypoint !== undefined && waypoint.discontinuityCanBeCleared) {
	      waypoint.endsInDiscontinuity = false;

	      switch (nextWaypoint.additionalData.legType) {
	        case LegType.FA:
	        case LegType.FC:
	        case LegType.FD:
	        case LegType.FM:
	        case LegType.HA:
	        case LegType.HF:
	        case LegType.HM:
	        case LegType.PI:
	          this.addWaypointByIdent(nextWaypoint.icao, index + 1, () => this.updateFlightPlanVersion().catch(console.error));
	          break;

	        default:
	          this.updateFlightPlanVersion().catch(console.error);
	      }

	      return true;
	    }

	    this.updateFlightPlanVersion().catch(console.error);
	    return false;
	  }
	  /**
	   * Sets the arrival transition index for the current flight plan.
	   * @param {Number} index The index of the arrival transition to select.
	   * @param {() => void} callback A callback to call when the operation completes.
	   */


	  async setArrivalEnRouteTransitionIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex]; // console.log('FPM: setArrivalEnRouteTransitionIndex: SET TRANSITION - ARRIVAL',
	    // currentFlightPlan.destinationAirfield.infos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex].enRouteTransitions[index].name);

	    if (currentFlightPlan.procedureDetails.arrivalTransitionIndex !== index) {
	      currentFlightPlan.procedureDetails.arrivalTransitionIndex = index;
	      await currentFlightPlan.rebuildArrivalApproach();
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the arrival runway index in the currently active flight plan.
	   * @param {Number} index The index of the runway to select.
	   * @param {() => void} callback A callback to call when the operation completes.
	   */


	  async setArrivalRunwayIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.procedureDetails.arrivalRunwayIndex !== index) {
	      /* if (currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
	          console.log(`setArrivalRunwayIndex: Finishing at
	          ${currentFlightPlan.destinationAirfield.infos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex].runwayTransitions[index].name}`);
	      } else {
	          console.log('setArrivalRunwayIndex: Finishing at none');
	      } */
	      currentFlightPlan.procedureDetails.arrivalRunwayIndex = index;
	      await currentFlightPlan.rebuildArrivalApproach();
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the destination runway index in the currently active flight plan.
	   * @param index The index of the runway to select.
	   * @param runwayExtension The length of the runway extension fix to create, or -1 if none.
	   * @param callback A callback to call when the operation completes.
	   */


	  async setDestinationRunwayIndex(index) {
	    let runwayExtension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
	    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex]; // console.log('setDestinationRunwayIndex - APPROACH');

	    if (currentFlightPlan.procedureDetails.destinationRunwayIndex !== index || currentFlightPlan.procedureDetails.destinationRunwayExtension !== runwayExtension) {
	      currentFlightPlan.procedureDetails.destinationRunwayIndex = index;
	      currentFlightPlan.procedureDetails.destinationRunwayExtension = runwayExtension;
	      await currentFlightPlan.buildApproach().catch(console.error);
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Sets the destination runway index using the current selected approach
	   */


	  async setDestinationRunwayIndexFromApproach() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
	      console.error('Destination runway index is -1 with valid STAR');
	      const approach = currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
	      const destRunways = currentFlightPlan.destinationAirfield.infos.oneWayRunways;
	      await this.setDestinationRunwayIndex(destRunways.findIndex(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator));
	    }
	  }
	  /**
	   * Gets the index of the approach in the currently active flight plan.
	   */


	  getApproachIndex() {
	    return this._flightPlans[this._currentFlightPlanIndex].procedureDetails.approachIndex;
	  }
	  /**
	   * Sets the approach index in the currently active flight plan.
	   * @param index The index of the approach in the destination airport information.
	   * @param callback A callback to call when the operation has completed.
	   * @param transition The approach transition index to set in the approach information.
	   */


	  async setApproachIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex]; // console.log(currentFlightPlan);

	    if (currentFlightPlan.procedureDetails.approachIndex !== index) {
	      // console.log('FPM: setApproachIndex - APPROACH', currentFlightPlan.destinationAirfield.infos.approaches[index].name);
	      currentFlightPlan.procedureDetails.approachIndex = index;
	      currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
	      currentFlightPlan.procedureDetails.arrivalIndex = -1;
	      currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
	      await currentFlightPlan.rebuildArrivalApproach();
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Whether or not an approach is loaded in the current flight plan.
	   * @param forceSimVarCall Unused
	   */


	  isLoadedApproach() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    return currentFlightPlan.procedureDetails.approachIndex >= 0;
	  }
	  /**
	   * Whether or not the approach is active in the current flight plan.
	   * @param forceSimVarCall Unused
	   */


	  isActiveApproach() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    return currentFlightPlan.approach.waypoints.length > 0 && currentFlightPlan.activeWaypointIndex >= currentFlightPlan.approach.offset;
	  }
	  /**
	   * Activates the approach segment in the current flight plan.
	   * @param {() => void} callback
	   */


	  async activateApproach() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (!this.isActiveApproach() && currentFlightPlan.approach.offset >= 0) {
	      await GPS.setActiveWaypoint(currentFlightPlan.approach.offset).catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Deactivates the approach segments in the current flight plan.
	   */


	  deactivateApproach() {}
	  /**
	   * Attemptes to auto-activate the approach in the current flight plan.
	   */


	  tryAutoActivateApproach() {}
	  /**
	   * Gets the index of the active waypoint on the approach in the current flight plan.
	   */


	  getApproachActiveWaypointIndex() {
	    return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
	  }
	  /**
	   * Gets the approach procedure from the current flight plan destination airport procedure information.
	   */


	  getApproach() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];

	    if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
	      return currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
	    }

	    return undefined;
	  }
	  /**
	   * Gets the index of the approach transition in the current flight plan.
	   */


	  getApproachTransitionIndex() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    return currentFlightPlan.procedureDetails.approachTransitionIndex;
	  }
	  /**
	   * Gets the last waypoint index before the start of the approach segment in
	   * the current flight plan.
	   */


	  getLastIndexBeforeApproach() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex]; // TODO: if we have an approach return last index

	    if (currentFlightPlan.approach !== FlightPlanSegment.Empty) {
	      return currentFlightPlan.approach.offset - 1;
	    }

	    return this.getWaypointsCount();
	  }
	  /**
	   * Gets the destination runway from the current flight plan.
	   */


	  getDestinationRunway() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const flightPlan = this._flightPlans[flightPlanIndex];
	    const runwayIndex = this.getDestinationRunwayIndex(flightPlanIndex);

	    if (runwayIndex >= 0) {
	      return flightPlan.destinationAirfield.infos.oneWayRunways[runwayIndex];
	    }

	    return undefined;
	  }
	  /**
	   * Gets the destination runway index (oneWayRunways) from the current flight plan.
	   */


	  getDestinationRunwayIndex() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const flightPlan = this._flightPlans[flightPlanIndex];

	    if (flightPlan.procedureDetails.destinationRunwayIndex >= 0 && flightPlan.destinationAirfield) {
	      return flightPlan.procedureDetails.destinationRunwayIndex;
	    }

	    if (flightPlan.hasDestination && flightPlan.procedureDetails.approachIndex >= 0) {
	      console.error('Destination runway index is -1 with valid STAR');
	      const approach = flightPlan.destinationAirfield.infos.approaches[flightPlan.procedureDetails.approachIndex];
	      const runways = flightPlan.destinationAirfield.infos.oneWayRunways;
	      return runways.findIndex(r => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
	    }

	    return -1;
	  }
	  /**
	   * Gets the approach waypoints for the current flight plan.
	   */


	  getApproachWaypoints() {
	    return this._flightPlans[this._currentFlightPlanIndex].approach.waypoints;
	  }
	  /**
	   * Sets the approach transition index for the current flight plan.
	   * @param index The index of the transition in the destination airport approach information.
	   * @param callback A callback to call when the operation completes.
	   */


	  async setApproachTransitionIndex(index) {
	    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex]; // console.log('setApproachTransitionIndex - APPROACH');

	    if (currentFlightPlan.procedureDetails.approachTransitionIndex !== index) {
	      // console.log(`setApproachIndex: APPR TRANS ${currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex].transitions[index].name}`);
	      currentFlightPlan.procedureDetails.approachTransitionIndex = index;
	      await currentFlightPlan.rebuildArrivalApproach();
	      this.updateFlightPlanVersion().catch(console.error);
	    }

	    callback();
	  }
	  /**
	   * Removes the arrival segment from the current flight plan.
	   * @param callback A callback to call when the operation completes.
	   */


	  async removeArrival() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex]; // console.log('remove arrival - ARRIVAL');

	    currentFlightPlan.procedureDetails.arrivalIndex = -1;
	    currentFlightPlan.procedureDetails.arrivalRunwayIndex = -1;
	    currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
	    await currentFlightPlan.buildArrival().catch(console.error);
	    this.updateFlightPlanVersion().catch(console.error);
	    callback();
	  }
	  /**
	   * Inserts direct-to an ICAO designated fix.
	   *
	   * @param icao The ICAO designation for the fix to fly direct-to.
	   */


	  async insertDirectTo(waypoint) {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
	    await currentFlightPlan.addDirectTo(waypoint);
	    this.updateFlightPlanVersion().catch(console.error);
	  }
	  /**
	   * Cancels the current direct-to and proceeds back along the flight plan.
	   * @param callback A callback to call when the operation completes.
	   */


	  cancelDirectTo() {
	    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EmptyCallback.Void;
	    this._flightPlans[this._currentFlightPlanIndex]; // currentFlightPlan.directTo.cancel();

	    callback();
	  }
	  /**
	   * Gets whether or not the flight plan is current in a direct-to procedure.
	   */


	  getIsDirectTo() {
	    return this._flightPlans[this._currentFlightPlanIndex].directTo.isActive;
	  }
	  /**
	   * Gets the target of the direct-to procedure in the current flight plan.
	   */


	  getDirectToTarget() {
	    const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];

	    if (currentFlightPlan.directTo.waypointIsInFlightPlan) {
	      return currentFlightPlan.waypoints[currentFlightPlan.directTo.planWaypointIndex];
	    }

	    return currentFlightPlan.directTo.waypoint;
	  }
	  /**
	   * Gets the origin/start waypoint of the direct-to procedure in the current flight plan.
	   */


	  getDirecToOrigin() {
	    return this._flightPlans[this._currentFlightPlanIndex].directTo.interceptPoints[0];
	  }

	  getCoordinatesHeadingAtDistanceAlongFlightPlan(_distance) {}
	  /**
	   * Gets the coordinates of a point that is a specific distance from the destination along the flight plan.
	   * @param distance The distance from destination we want the coordinates for.
	   */


	  getCoordinatesAtNMFromDestinationAlongFlightPlan(distance) {
	    const allWaypoints = this.getAllWaypoints();
	    const destination = this.getDestination();

	    if (destination) {
	      const fromStartDistance = destination.cumulativeDistanceInFP - distance;
	      let prev;
	      let next;

	      for (let i = 0; i < allWaypoints.length - 1; i++) {
	        prev = allWaypoints[i];
	        next = allWaypoints[i + 1];

	        if (prev.cumulativeDistanceInFP < fromStartDistance && next.cumulativeDistanceInFP > fromStartDistance) {
	          break;
	        }
	      }

	      const prevCD = prev.cumulativeDistanceInFP;
	      const nextCD = next.cumulativeDistanceInFP;
	      const d = (fromStartDistance - prevCD) / (nextCD - prevCD);
	      const output = new LatLongAlt();
	      output.lat = Avionics.Utils.lerpAngle(prev.infos.coordinates.lat, next.infos.coordinates.lat, d);
	      output.long = Avionics.Utils.lerpAngle(prev.infos.coordinates.long, next.infos.coordinates.long, d);
	      return output;
	    }

	    return null;
	  }
	  /**
	   * Gets the current stored flight plan
	   */


	  _getFlightPlan() {
	    {
	      return;
	    }
	  }

	  getCurrentFlightPlan() {
	    return this._flightPlans[this._currentFlightPlanIndex];
	  }

	  getFlightPlan(index) {
	    return this._flightPlans[index];
	  }
	  /**
	   * Updates the synchronized flight plan version and saves it to shared storage.
	   */


	  async updateFlightPlanVersion() {
	    if (this._isSyncPaused) {
	      return;
	    }

	    SimVar.SetSimVarValue(FlightPlanManager.FlightPlanVersionKey, 'number', ++this._currentFlightPlanVersion);

	    if (NXDataStore.get('FP_SYNC', 'LOAD') === 'SAVE') {
	      FlightPlanAsoboSync.SaveToGame(this).catch(console.error);
	    }
	  }

	  pauseSync() {
	    this._isSyncPaused = true;
	    console.log('FlightPlan Sync Paused');
	  }

	  resumeSync() {
	    this._isSyncPaused = false;
	    this.updateFlightPlanVersion().catch(console.error);
	    console.log('FlightPlan Sync Resume');
	  }

	  get currentFlightPlanVersion() {
	    return this._currentFlightPlanVersion;
	  }

	  getOriginTransitionAltitude() {
	    var _currentFlightPlan$or;

	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    return (_currentFlightPlan$or = currentFlightPlan.originTransitionAltitudePilot) !== null && _currentFlightPlan$or !== void 0 ? _currentFlightPlan$or : currentFlightPlan.originTransitionAltitudeDb;
	  }
	  /**
	   * The transition altitude for the origin in the *active* flight plan
	   */


	  get originTransitionAltitude() {
	    return this.getOriginTransitionAltitude(0);
	  }

	  getOriginTransitionAltitudeIsFromDb() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    return currentFlightPlan.originTransitionAltitudePilot === undefined;
	  }
	  /**
	   * Is the transition altitude for the origin in the *active* flight plan from the database?
	   */


	  get originTransitionAltitudeIsFromDb() {
	    return this.getOriginTransitionAltitudeIsFromDb(0);
	  }
	  /**
	   * Set the transition altitude for the origin
	   * @param altitude transition altitude
	   * @param database is this value from the database, or pilot?
	   * @param flightPlanIndex index of flight plan to be edited, defaults to current plan being edited (not active!)
	   */


	  setOriginTransitionAltitude(altitude) {
	    let database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];

	    if (database) {
	      currentFlightPlan.originTransitionAltitudeDb = altitude;
	    } else {
	      currentFlightPlan.originTransitionAltitudePilot = altitude;
	    }

	    this.updateFlightPlanVersion();
	  }

	  getDestinationTransitionLevel() {
	    var _currentFlightPlan$de;

	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    return (_currentFlightPlan$de = currentFlightPlan.destinationTransitionLevelPilot) !== null && _currentFlightPlan$de !== void 0 ? _currentFlightPlan$de : currentFlightPlan.destinationTransitionLevelDb;
	  }
	  /**
	   * The transition level for the destination in the *active* flight plan
	   */


	  get destinationTransitionLevel() {
	    return this.getDestinationTransitionLevel(0);
	  }

	  getDestinationTransitionLevelIsFromDb() {
	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];
	    return currentFlightPlan.destinationTransitionLevelPilot === undefined;
	  }
	  /**
	   * Is the transition level for the destination in the *active* flight plan from the database?
	   */


	  get destinationTransitionLevelIsFromDb() {
	    return this.getDestinationTransitionLevelIsFromDb(0);
	  }
	  /**
	   * Set the transition level for the destination
	   * @param flightLevel transition level
	   * @param database is this value from the database, or pilot?
	   * @param flightPlanIndex index of flight plan to be edited, defaults to current plan being edited (not active!)
	   */


	  setDestinationTransitionLevel(flightLevel) {
	    let database = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    let flightPlanIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._currentFlightPlanIndex;
	    const currentFlightPlan = this._flightPlans[flightPlanIndex];

	    if (database) {
	      currentFlightPlan.destinationTransitionLevelDb = flightLevel;
	    } else {
	      currentFlightPlan.destinationTransitionLevelPilot = flightLevel;
	    }

	    this.updateFlightPlanVersion();
	  }

	  getFixInfo(index) {
	    return this._fixInfos[index];
	  }

	  isWaypointInUse(icao) {
	    for (const fp of this._flightPlans) {
	      for (let i = 0; i < (fp === null || fp === void 0 ? void 0 : fp.waypoints.length); i++) {
	        if (fp.getWaypoint(i).icao === icao) {
	          return true;
	        }
	      }
	    }

	    for (const fixInfo of this._fixInfos) {
	      var _fixInfo$getRefFix;

	      if ((fixInfo === null || fixInfo === void 0 ? void 0 : (_fixInfo$getRefFix = fixInfo.getRefFix()) === null || _fixInfo$getRefFix === void 0 ? void 0 : _fixInfo$getRefFix.infos.icao) === icao) {
	        return true;
	      }
	    }

	    return false;
	  }

	  get activeFlightPlan() {
	    return this._flightPlans[FlightPlans.Active];
	  }

	  getApproachType() {
	    var _fp$procedureDetails$;

	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const fp = this._flightPlans[flightPlanIndex];
	    return (_fp$procedureDetails$ = fp === null || fp === void 0 ? void 0 : fp.procedureDetails.approachType) !== null && _fp$procedureDetails$ !== void 0 ? _fp$procedureDetails$ : undefined;
	  }

	  getGlideslopeIntercept() {
	    var _fp$glideslopeInterce;

	    let flightPlanIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._currentFlightPlanIndex;
	    const fp = this._flightPlans[flightPlanIndex];
	    return (_fp$glideslopeInterce = fp === null || fp === void 0 ? void 0 : fp.glideslopeIntercept) !== null && _fp$glideslopeInterce !== void 0 ? _fp$glideslopeInterce : undefined;
	  }

	  updateActiveArea() {
	    const activeFp = this._flightPlans[FlightPlans.Active];

	    if (!activeFp) {
	      this.activeArea = FlightArea.Terminal;
	      return;
	    }

	    this.activeArea = this.calculateActiveArea(activeFp);
	  }

	  calculateActiveArea(activeFp) {
	    const activeIndex = activeFp.activeWaypointIndex;
	    const appr = activeFp.getSegment(SegmentType.Approach);
	    const arrival = activeFp.getSegment(SegmentType.Arrival);
	    const departure = activeFp.getSegment(SegmentType.Departure);

	    if (departure !== FlightPlanSegment.Empty && activeIndex < departure.offset + departure.waypoints.length) {
	      return FlightArea.Terminal;
	    }

	    if (arrival !== FlightPlanSegment.Empty && activeIndex >= arrival.offset && activeIndex < arrival.offset + arrival.waypoints.length) {
	      return FlightArea.Terminal;
	    }

	    if (appr !== FlightPlanSegment.Empty && activeIndex >= appr.offset && activeIndex < appr.offset + appr.waypoints.length && activeFp.finalApproachActive) {
	      const apprType = activeFp.procedureDetails.approachType;

	      switch (apprType) {
	        case ApproachType.APPROACH_TYPE_ILS:
	          return FlightArea.PrecisionApproach;

	        case ApproachType.APPROACH_TYPE_GPS:
	        case ApproachType.APPROACH_TYPE_RNAV:
	          return FlightArea.GpsApproach;

	        case ApproachType.APPROACH_TYPE_VOR:
	        case ApproachType.APPROACH_TYPE_VORDME:
	          return FlightArea.VorApproach;

	        default:
	          return FlightArea.NonPrecisionApproach;
	      }
	    }

	    return FlightArea.Enroute;
	  }

	  tryAddOrUpdateCruiseStep(waypointIdent, toAltitude) {
	    if (this._flightPlans[this._currentFlightPlanIndex].tryAddOrUpdateCruiseStep(waypointIdent, toAltitude)) {
	      this.updateFlightPlanVersion().catch(console.error);
	      return true;
	    }

	    return false;
	  }

	  tryRemoveCruiseStep(waypointIndex) {
	    this._flightPlans[this._currentFlightPlanIndex].tryRemoveCruiseStep(waypointIndex);

	    this.updateFlightPlanVersion().catch(console.error);
	  }

	}

	_defineProperty(FlightPlanManager, "DEBUG_INSTANCE", void 0);

	_defineProperty(FlightPlanManager, "FlightPlanKey", 'A32NX.FlightPlan');

	_defineProperty(FlightPlanManager, "FlightPlanCompressedKey", 'A32NX.FlightPlan.Compressed');

	_defineProperty(FlightPlanManager, "FlightPlanVersionKey", 'L:A32NX.FlightPlan.Version');

	// Copyright (c) 2021-2022 FlyByWire Simulations
	// Copyright (c) 2021-2022 Synaptic Simulations
	//
	// SPDX-License-Identifier: GPL-3.0

	/**
	 * This enum represents a Control Law selected by the guidance system.
	 */
	let ControlLaw;

	(function (ControlLaw) {
	  ControlLaw[ControlLaw["HEADING"] = 1] = "HEADING";
	  ControlLaw[ControlLaw["TRACK"] = 2] = "TRACK";
	  ControlLaw[ControlLaw["LATERAL_PATH"] = 3] = "LATERAL_PATH";
	})(ControlLaw || (ControlLaw = {}));

	let RequestedVerticalMode;

	(function (RequestedVerticalMode) {
	  RequestedVerticalMode[RequestedVerticalMode["None"] = 0] = "None";
	  RequestedVerticalMode[RequestedVerticalMode["SpeedThrust"] = 1] = "SpeedThrust";
	  RequestedVerticalMode[RequestedVerticalMode["VpathThrust"] = 2] = "VpathThrust";
	  RequestedVerticalMode[RequestedVerticalMode["VpathSpeed"] = 3] = "VpathSpeed";
	  RequestedVerticalMode[RequestedVerticalMode["FpaSpeed"] = 4] = "FpaSpeed";
	  RequestedVerticalMode[RequestedVerticalMode["VsSpeed"] = 5] = "VsSpeed";
	})(RequestedVerticalMode || (RequestedVerticalMode = {}));

	var LateralMode;

	(function (LateralMode) {
	  LateralMode[LateralMode["NONE"] = 0] = "NONE";
	  LateralMode[LateralMode["HDG"] = 10] = "HDG";
	  LateralMode[LateralMode["TRACK"] = 11] = "TRACK";
	  LateralMode[LateralMode["NAV"] = 20] = "NAV";
	  LateralMode[LateralMode["LOC_CPT"] = 30] = "LOC_CPT";
	  LateralMode[LateralMode["LOC_TRACK"] = 31] = "LOC_TRACK";
	  LateralMode[LateralMode["LAND"] = 32] = "LAND";
	  LateralMode[LateralMode["FLARE"] = 33] = "FLARE";
	  LateralMode[LateralMode["ROLL_OUT"] = 34] = "ROLL_OUT";
	  LateralMode[LateralMode["RWY"] = 40] = "RWY";
	  LateralMode[LateralMode["RWY_TRACK"] = 41] = "RWY_TRACK";
	  LateralMode[LateralMode["GA_TRACK"] = 50] = "GA_TRACK";
	})(LateralMode || (LateralMode = {}));

	var ArmedLateralMode;

	(function (ArmedLateralMode) {
	  ArmedLateralMode[ArmedLateralMode["NAV"] = 0] = "NAV";
	  ArmedLateralMode[ArmedLateralMode["LOC"] = 1] = "LOC";
	})(ArmedLateralMode || (ArmedLateralMode = {}));

	var VerticalMode;

	(function (VerticalMode) {
	  VerticalMode[VerticalMode["NONE"] = 0] = "NONE";
	  VerticalMode[VerticalMode["ALT"] = 10] = "ALT";
	  VerticalMode[VerticalMode["ALT_CPT"] = 11] = "ALT_CPT";
	  VerticalMode[VerticalMode["OP_CLB"] = 12] = "OP_CLB";
	  VerticalMode[VerticalMode["OP_DES"] = 13] = "OP_DES";
	  VerticalMode[VerticalMode["VS"] = 14] = "VS";
	  VerticalMode[VerticalMode["FPA"] = 15] = "FPA";
	  VerticalMode[VerticalMode["ALT_CST"] = 20] = "ALT_CST";
	  VerticalMode[VerticalMode["ALT_CST_CPT"] = 21] = "ALT_CST_CPT";
	  VerticalMode[VerticalMode["CLB"] = 22] = "CLB";
	  VerticalMode[VerticalMode["DES"] = 23] = "DES";
	  VerticalMode[VerticalMode["FINAL"] = 24] = "FINAL";
	  VerticalMode[VerticalMode["GS_CPT"] = 30] = "GS_CPT";
	  VerticalMode[VerticalMode["GS_TRACK"] = 31] = "GS_TRACK";
	  VerticalMode[VerticalMode["LAND"] = 32] = "LAND";
	  VerticalMode[VerticalMode["FLARE"] = 33] = "FLARE";
	  VerticalMode[VerticalMode["ROLL_OUT"] = 34] = "ROLL_OUT";
	  VerticalMode[VerticalMode["SRS"] = 40] = "SRS";
	  VerticalMode[VerticalMode["SRS_GA"] = 41] = "SRS_GA";
	  VerticalMode[VerticalMode["TCAS"] = 50] = "TCAS";
	})(VerticalMode || (VerticalMode = {}));

	var ArmedVerticalMode;

	(function (ArmedVerticalMode) {
	  ArmedVerticalMode[ArmedVerticalMode["ALT"] = 0] = "ALT";
	  ArmedVerticalMode[ArmedVerticalMode["ALT_CST"] = 1] = "ALT_CST";
	  ArmedVerticalMode[ArmedVerticalMode["CLB"] = 2] = "CLB";
	  ArmedVerticalMode[ArmedVerticalMode["DES"] = 3] = "DES";
	  ArmedVerticalMode[ArmedVerticalMode["GS"] = 4] = "GS";
	  ArmedVerticalMode[ArmedVerticalMode["FINAL"] = 5] = "FINAL";
	  ArmedVerticalMode[ArmedVerticalMode["TCAS"] = 6] = "TCAS";
	})(ArmedVerticalMode || (ArmedVerticalMode = {}));

	function isArmed(bitmask, armedBit) {
	  return (bitmask >> armedBit & 1) === 1;
	}

	let FmgcFlightPhase;

	(function (FmgcFlightPhase) {
	  FmgcFlightPhase[FmgcFlightPhase["Preflight"] = 0] = "Preflight";
	  FmgcFlightPhase[FmgcFlightPhase["Takeoff"] = 1] = "Takeoff";
	  FmgcFlightPhase[FmgcFlightPhase["Climb"] = 2] = "Climb";
	  FmgcFlightPhase[FmgcFlightPhase["Cruise"] = 3] = "Cruise";
	  FmgcFlightPhase[FmgcFlightPhase["Descent"] = 4] = "Descent";
	  FmgcFlightPhase[FmgcFlightPhase["Approach"] = 5] = "Approach";
	  FmgcFlightPhase[FmgcFlightPhase["GoAround"] = 6] = "GoAround";
	  FmgcFlightPhase[FmgcFlightPhase["Done"] = 7] = "Done";
	})(FmgcFlightPhase || (FmgcFlightPhase = {}));

	function isReady() {
	  return SimVar.GetSimVarValue('L:A32NX_IS_READY', 'number') === 1;
	}
	function isSlewActive() {
	  return SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
	}
	function isOnGround() {
	  return SimVar.GetSimVarValue('L:A32NX_LGCIU_1_NOSE_GEAR_COMPRESSED', 'bool') || SimVar.GetSimVarValue('L:A32NX_LGCIU_2_NOSE_GEAR_COMPRESSED', 'bool');
	}

	function isEngineOn(index) {
	  return SimVar.GetSimVarValue("L:A32NX_ENGINE_N2:".concat(index), 'number') > 20;
	}

	function isEngineOnTakeOffThrust(index) {
	  return SimVar.GetSimVarValue("L:A32NX_ENGINE_N1:".concat(index), 'number') >= 70;
	}

	function isAnEngineOn() {
	  return isEngineOn(1) || isEngineOn(2);
	}
	function isAllEngineOn() {
	  return isEngineOn(1) && isEngineOn(2);
	}
	function getAutopilotVerticalMode() {
	  return SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
	}
	function conditionTakeOff() {
	  return getAutopilotVerticalMode() === VerticalMode.SRS && isEngineOnTakeOffThrust(1) && isEngineOnTakeOffThrust(2) || Math.abs(Simplane.getGroundSpeed()) > 90;
	}

	class ConfirmationNode {
	  constructor(triggerTime) {
	    this.triggerTime = triggerTime;

	    _defineProperty(this, "lastInput", false);

	    _defineProperty(this, "input", false);

	    _defineProperty(this, "output", false);

	    _defineProperty(this, "timer", 0.0);
	  }

	  update(deltaTime) {
	    // State change - reset timer
	    if (this.lastInput !== this.input) {
	      this.lastInput = this.input;
	      this.output = false;
	      this.timer = 0.0;
	      return;
	    }

	    this.lastInput = this.input;

	    if (this.input) {
	      this.timer += deltaTime;
	    }

	    if (this.timer > this.triggerTime) {
	      this.output = true;
	    }
	  }

	}
	class Trigger {
	  constructor(risingEdge) {
	    this.risingEdge = risingEdge;

	    _defineProperty(this, "lastInput", false);

	    _defineProperty(this, "input", false);

	    _defineProperty(this, "output", false);
	  }

	  update(_) {
	    // State change - set output
	    if (this.lastInput !== this.input) {
	      if (this.risingEdge && this.input) {
	        this.output = true;
	      } else if (!this.risingEdge && this.input) {
	        this.output = false;
	      }
	    } else {
	      this.output = false;
	    }

	    this.lastInput = this.input;
	  }

	}

	class Phase {
	  constructor() {
	    _defineProperty(this, "nextPhase", void 0);
	  }

	  // eslint-disable-next-line no-empty-function
	  init() {
	    /* prototype function */
	  }

	}
	class PreFlightPhase extends Phase {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "takeoffConfirmation", new ConfirmationNode(0.2 * 1000));
	  }

	  init() {
	    this.nextPhase = FmgcFlightPhase.Takeoff;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    this.takeoffConfirmation.input = conditionTakeOff();
	    this.takeoffConfirmation.update(_deltaTime);
	    return this.takeoffConfirmation.output;
	  }

	}
	class TakeOffPhase extends Phase {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "accelerationAltitudeMsl", void 0);

	    _defineProperty(this, "accelerationAltitudeMslEo", void 0);
	  }

	  init() {
	    this.nextPhase = FmgcFlightPhase.Climb;
	    SimVar.SetSimVarValue('L:A32NX_COLD_AND_DARK_SPAWN', 'Bool', false);
	    const accAlt = SimVar.GetSimVarValue('L:AIRLINER_ACC_ALT', 'Number');
	    const thrRedAlt = SimVar.GetSimVarValue('L:AIRLINER_THR_RED_ALT', 'Number');
	    this.accelerationAltitudeMsl = accAlt || thrRedAlt;
	    this.accelerationAltitudeMslEo = SimVar.GetSimVarValue('L:A32NX_ENG_OUT_ACC_ALT', 'feet');
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    return Simplane.getAltitude() > (isAllEngineOn() ? this.accelerationAltitudeMsl : this.accelerationAltitudeMslEo);
	  }

	}
	class ClimbPhase extends Phase {
	  init() {
	    this.nextPhase = FmgcFlightPhase.Cruise;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;
	    const fl = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
	    return fl >= cruiseFl;
	  }

	}
	class CruisePhase extends Phase {
	  init() {
	    // switch out of cruise phase is handled in FlightPhaseManager
	    this.nextPhase = FmgcFlightPhase.Cruise;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    return false;
	  }

	}
	class DescentPhase extends Phase {
	  init() {
	    this.nextPhase = FmgcFlightPhase.Approach;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    const fl = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);
	    const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue('feet') / 100;
	    const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100;

	    if (fl === cruiseFl && fcuSelFl === fl) {
	      this.nextPhase = FmgcFlightPhase.Cruise;
	      return true;
	    } // APPROACH phase from DECEL pseudo waypoint case. This is decided by the new TS FMS.


	    return !!SimVar.GetSimVarValue('L:A32NX_FM_ENABLE_APPROACH_PHASE', 'Bool');
	  }

	}
	class ApproachPhase extends Phase {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "landingConfirmation", new ConfirmationNode(30 * 1000));
	  }

	  init() {
	    SimVar.SetSimVarValue('L:A32NX_TO_FLEX_TEMP', 'Number', 0);
	    this.nextPhase = FmgcFlightPhase.Done;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    if (getAutopilotVerticalMode() === VerticalMode.SRS_GA) {
	      this.nextPhase = FmgcFlightPhase.GoAround;
	      return true;
	    }

	    this.landingConfirmation.input = isOnGround();
	    this.landingConfirmation.update(_deltaTime);
	    return this.landingConfirmation.output || !isAnEngineOn();
	  }

	}
	class GoAroundPhase extends Phase {
	  init() {
	    SimVar.SetSimVarValue('L:A32NX_TO_FLEX_TEMP', 'Number', 0);
	    this.nextPhase = FmgcFlightPhase.GoAround;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    // there is no automatic switch from this phase
	    return false;
	  }

	}
	class DonePhase extends Phase {
	  init() {
	    SimVar.SetSimVarValue('L:A32NX_TO_FLEX_TEMP', 'Number', 0);
	    this.nextPhase = FmgcFlightPhase.Done;
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    // there is no automatic switch from this phase
	    return false;
	  }

	}

	function canInitiateDes(distanceToDestination) {
	  const fl = Math.round(Simplane.getAltitude() / 100);
	  const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue('feet') / 100;
	  const cruiseFl = SimVar.GetSimVarValue('L:AIRLINER_CRUISE_ALTITUDE', 'number') / 100; // Can initiate descent? OR Can initiate early descent?

	  return (distanceToDestination < 200 || fl < 200) && fcuSelFl < cruiseFl && fcuSelFl < fl || distanceToDestination >= 200 && fl > 200 && fcuSelFl <= 200;
	}

	class FlightPhaseManager {
	  constructor() {
	    _defineProperty(this, "onGroundConfirmationNode", new ConfirmationNode(30 * 1000));

	    _defineProperty(this, "activePhase", this.initialPhase || FmgcFlightPhase.Preflight);

	    _defineProperty(this, "phases", {
	      [FmgcFlightPhase.Preflight]: new PreFlightPhase(),
	      [FmgcFlightPhase.Takeoff]: new TakeOffPhase(),
	      [FmgcFlightPhase.Climb]: new ClimbPhase(),
	      [FmgcFlightPhase.Cruise]: new CruisePhase(),
	      [FmgcFlightPhase.Descent]: new DescentPhase(),
	      [FmgcFlightPhase.Approach]: new ApproachPhase(),
	      [FmgcFlightPhase.GoAround]: new GoAroundPhase(),
	      [FmgcFlightPhase.Done]: new DonePhase()
	    });

	    _defineProperty(this, "phaseChangeListeners", []);
	  }

	  get phase() {
	    return this.activePhase;
	  }

	  get initialPhase() {
	    return SimVar.GetSimVarValue('L:A32NX_INITIAL_FLIGHT_PHASE', 'number');
	  }

	  init() {
	    console.log("FMGC Flight Phase: ".concat(this.phase));
	    this.phases[this.phase].init();
	    this.changePhase(this.activePhase);
	  }

	  shouldActivateNextPhase(_deltaTime) {
	    // process transitions only when plane is ready
	    if (isReady() && !isSlewActive()) {
	      if (this.shouldActivateDonePhase(_deltaTime)) {
	        this.changePhase(FmgcFlightPhase.Done);
	      } else if (this.phases[this.phase].shouldActivateNextPhase(_deltaTime)) {
	        this.changePhase(this.phases[this.phase].nextPhase);
	      }
	    } else if (isReady() && isSlewActive()) {
	      this.handleSlewSituation(_deltaTime);
	    } else if (this.activePhase !== this.initialPhase) {
	      // ensure correct init of phase
	      this.activePhase = this.initialPhase;
	      this.changePhase(this.initialPhase);
	    }
	  }

	  addOnPhaseChanged(cb) {
	    this.phaseChangeListeners.push(cb);
	  }

	  handleFcuAltKnobPushPull(distanceToDestination) {
	    switch (this.phase) {
	      case FmgcFlightPhase.Takeoff:
	        this.changePhase(FmgcFlightPhase.Climb);
	        break;

	      case FmgcFlightPhase.Climb:
	      case FmgcFlightPhase.Cruise:
	        if (canInitiateDes(distanceToDestination)) {
	          this.changePhase(FmgcFlightPhase.Descent);
	        }

	        break;
	    }
	  }

	  handleFcuAltKnobTurn(distanceToDestination) {
	    if (this.phase === FmgcFlightPhase.Cruise) {
	      const activeVerticalMode = SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
	      const VS = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_VS_SELECTED', 'feet per minute');
	      const FPA = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_FPA_SELECTED', 'Degrees');

	      if ((activeVerticalMode === VerticalMode.OP_DES || activeVerticalMode === VerticalMode.VS && VS < 0 || activeVerticalMode === VerticalMode.FPA && FPA < 0 || activeVerticalMode === VerticalMode.DES) && canInitiateDes(distanceToDestination)) {
	        this.changePhase(FmgcFlightPhase.Descent);
	      }
	    }
	  }

	  handleFcuVSKnob(distanceToDestination, onStepClimbDescent) {
	    if (this.phase === FmgcFlightPhase.Climb || this.phase === FmgcFlightPhase.Cruise) {
	      /** a timeout of 100ms is required in order to receive the updated autopilot vertical mode */
	      setTimeout(() => {
	        const activeVerticalMode = SimVar.GetSimVarValue('L:A32NX_FMA_VERTICAL_MODE', 'Enum');
	        const VS = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_VS_SELECTED', 'feet per minute');
	        const FPA = SimVar.GetSimVarValue('L:A32NX_AUTOPILOT_FPA_SELECTED', 'Degrees');

	        if (activeVerticalMode === VerticalMode.VS && VS < 0 || activeVerticalMode === VerticalMode.FPA && FPA < 0) {
	          if (canInitiateDes(distanceToDestination)) {
	            this.changePhase(FmgcFlightPhase.Descent);
	          } else {
	            onStepClimbDescent();
	          }
	        }
	      }, 100);
	    }
	  }

	  handleNewCruiseAltitudeEntered(newCruiseFlightLevel) {
	    const currentFlightLevel = Math.round(SimVar.GetSimVarValue('INDICATED ALTITUDE:3', 'feet') / 100);

	    if (this.activePhase === FmgcFlightPhase.Approach) {
	      this.changePhase(FmgcFlightPhase.Climb);
	    } else if (currentFlightLevel < newCruiseFlightLevel && this.activePhase === FmgcFlightPhase.Descent) {
	      this.changePhase(FmgcFlightPhase.Climb);
	    } else if (currentFlightLevel > newCruiseFlightLevel && (this.activePhase === FmgcFlightPhase.Climb || this.activePhase === FmgcFlightPhase.Descent)) {
	      this.changePhase(FmgcFlightPhase.Cruise);
	    }
	  }

	  handleNewDestinationAirportEntered() {
	    if (this.activePhase === FmgcFlightPhase.GoAround) {
	      const accAlt = SimVar.GetSimVarValue('L:AIRLINER_ACC_ALT_GOAROUND', 'Number');

	      if (Simplane.getAltitude() > accAlt) {
	        this.changePhase(FmgcFlightPhase.Climb);
	      }
	    }
	  }

	  changePhase(newPhase) {
	    const prevPhase = this.phase;
	    console.log("FMGC Flight Phase: ".concat(prevPhase, " => ").concat(newPhase));
	    this.activePhase = newPhase;
	    SimVar.SetSimVarValue('L:A32NX_FMGC_FLIGHT_PHASE', 'number', newPhase); // Updating old SimVar to ensure backwards compatibility

	    SimVar.SetSimVarValue('L:AIRLINER_FLIGHT_PHASE', 'number', newPhase < FmgcFlightPhase.Takeoff ? FmgcFlightPhase.Preflight : newPhase + 1);
	    this.phases[this.phase].init();

	    for (const pcl of this.phaseChangeListeners) {
	      pcl(prevPhase, newPhase);
	    }

	    this.shouldActivateNextPhase(0);
	  }

	  tryGoInApproachPhase() {
	    if (this.phase === FmgcFlightPhase.Preflight || this.phase === FmgcFlightPhase.Takeoff || this.phase === FmgcFlightPhase.Done) {
	      return false;
	    }

	    if (this.phase !== FmgcFlightPhase.Approach) {
	      this.changePhase(FmgcFlightPhase.Approach);
	    }

	    return true;
	  }

	  shouldActivateDonePhase(_deltaTime) {
	    this.onGroundConfirmationNode.input = isOnGround();
	    this.onGroundConfirmationNode.update(_deltaTime);
	    return this.onGroundConfirmationNode.output && !isAnEngineOn() && this.phase !== FmgcFlightPhase.Done && this.phase !== FmgcFlightPhase.Preflight;
	  }

	  handleSlewSituation(_deltaTime) {
	    switch (this.phase) {
	      case FmgcFlightPhase.Preflight:
	      case FmgcFlightPhase.Takeoff:
	      case FmgcFlightPhase.Done:
	        if (Simplane.getAltitudeAboveGround() >= 1500) {
	          this.changePhase(FmgcFlightPhase.Climb);
	        }

	        break;
	    }
	  }

	}

	const flightPhaseManager = new FlightPhaseManager();
	function getFlightPhaseManager() {
	  return flightPhaseManager;
	}

	class MathUtils {
	  static fastToFixed(val, fraction) {
	    if (fraction <= 0) {
	      return Math.round(val).toString();
	    }

	    let coefficient = MathUtils.optiPow10[fraction];

	    if (!coefficient || Number.isNaN(coefficient)) {
	      coefficient = 10 ** fraction;
	      MathUtils.optiPow10[fraction] = coefficient;
	    }

	    return (Math.round(val * coefficient) / coefficient).toString();
	  }

	  static fastToFixedNum(val, fraction) {
	    if (fraction <= 0) {
	      return Math.round(val);
	    }

	    let coefficient = MathUtils.optiPow10[fraction];

	    if (!coefficient || Number.isNaN(coefficient)) {
	      coefficient = 10 ** fraction;
	      MathUtils.optiPow10[fraction] = coefficient;
	    }

	    return Math.round(val * coefficient) / coefficient;
	  }
	  /**
	    * Adds two angles with wrap around to result in 0-360
	    * @param a - positive or negative angle
	    * @param b - positive or negative angle
	    */


	  static angleAdd(a, b) {
	    let r = a + b;

	    while (r > 360) {
	      r -= 360;
	    }

	    while (r < 0) {
	      r += 360;
	    }

	    return r;
	  }

	  static diffAngle(a, b, direction) {
	    let diff = b - a;

	    while (diff > 180) {
	      diff -= 360;
	    }

	    while (diff <= -180) {
	      diff += 360;
	    }

	    if (diff < 0 && direction === TurnDirection.Right) {
	      diff += 360;
	    }

	    if (diff > 0 && direction === TurnDirection.Left) {
	      diff -= 360;
	    }

	    return diff;
	  }

	  static adjustAngleForTurnDirection(angle, turnDirection) {
	    let ret = angle;

	    if (angle < 0 && turnDirection === TurnDirection.Right) {
	      ret += 360;
	    }

	    if (angle > 0 && turnDirection === TurnDirection.Left) {
	      ret -= 360;
	    }

	    return ret;
	  }
	  /**
	   * Calculates the inner angle of the small triangle formed by two intersecting lines
	   *
	   * This effectively returns the angle XYZ in the figure shown below:
	   *
	   * ```
	   * * Y
	   * |\
	   * | \
	   * |  \
	   * |   \
	   * |    \
	   * |     \
	   * |      \
	   * * X     * Z
	   * ```
	   *
	   * @param xyAngle {number} bearing of line XY
	   * @param zyAngle {number} bearing of line ZY
	   */


	  static smallCrossingAngle(xyAngle, zyAngle) {
	    // Rotate frame of reference to 0deg
	    let correctedXyBearing = xyAngle - zyAngle;

	    if (correctedXyBearing < 0) {
	      correctedXyBearing = 360 + correctedXyBearing;
	    }

	    let xyzAngle = 180 - correctedXyBearing;

	    if (xyzAngle < 0) {
	      // correctedXyBearing was > 180
	      xyzAngle = 360 + xyzAngle;
	    }

	    return xyzAngle;
	  }

	  static mod(x, n) {
	    return x - Math.floor(x / n) * n;
	  }

	  static highestPower2(n) {
	    let res = 0;

	    for (let i = n; i >= 1; i--) {
	      if ((i & i - 1) === 0) {
	        res = i;
	        break;
	      }
	    }

	    return res;
	  }

	  static unpackPowers(n) {
	    const res = [];
	    let x = n;

	    while (x > 0) {
	      const pow = MathUtils.highestPower2(x);
	      res.push(pow);
	      x -= pow;
	    }

	    return res;
	  }

	  static packPowers(ns) {
	    if (ns.some(it => it === 0 || (it & it - 1) !== 0)) {
	      throw new Error('Cannot pack number which is not a power of 2 or is equal to zero.');
	    }

	    return ns.reduce((acc, v) => acc + v);
	  }
	  /**
	    * Convert degrees Celsius into Kelvin
	    * @param celsius degrees Celsius
	    * @returns degrees Kelvin
	    */


	  static convertCtoK(celsius) {
	    return celsius + 273.15;
	  }
	  /**
	    * Convert Mach to True Air Speed
	    * @param mach Mach
	    * @param oat Kelvin
	    * @returns True Air Speed
	    */


	  static convertMachToKTas(mach, oat) {
	    return mach * 661.4786 * Math.sqrt(oat / 288.15);
	  }
	  /**
	    * Convert TAS to Mach
	    * @param tas TAS
	    * @param oat Kelvin
	    * @returns True Air Speed
	    */


	  static convertKTASToMach(tas, oat) {
	    return tas / 661.4786 / Math.sqrt(oat / 288.15);
	  }
	  /**
	    * Convert TAS to Calibrated Air Speed
	    * @param tas velocity true air speed
	    * @param oat current temperature Kelvin
	    * @param pressure current pressure hpa
	    * @returns Calibrated Air Speed
	    */


	  static convertTasToKCas(tas, oat, pressure) {
	    return 1479.1 * Math.sqrt((pressure / 1013 * ((1 + 1 / (oat / 288.15) * (tas / 1479.1) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1);
	  }
	  /**
	    * Convert KCAS to KTAS
	    * @param kcas velocity true air speed
	    * @param oat current temperature Kelvin
	    * @param pressure current pressure hpa
	    * @returns True Air Speed
	    */


	  static convertKCasToKTAS(kcas, oat, pressure) {
	    return 1479.1 * Math.sqrt(oat / 288.15 * ((1 / (pressure / 1013) * ((1 + 0.2 * (kcas / 661.4786) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1));
	  }
	  /**
	    * Convert Mach to Calibrated Air Speed
	    * @param mach Mach
	    * @param oat Kelvin
	    * @param pressure current pressure hpa
	    * @returns Calibrated Air Speed
	    */


	  static convertMachToKCas(mach, oat, pressure) {
	    return MathUtils.convertTasToKCas(MathUtils.convertMachToKTas(mach, oat), oat, pressure);
	  }
	  /**
	    * Gets the horizontal distance between 2 points, given in lat/lon
	    * @param pos0Lat {number} Position 0 lat
	    * @param pos0Lon {number} Position 0 lon
	    * @param pos1Lat {number} Position 1 lat
	    * @param pos1Lon {number} Position 1 lon
	    * @return {number} distance in nautical miles
	    */


	  static computeGreatCircleDistance(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
	    const lat0 = pos0Lat * MathUtils.DEGREES_TO_RADIANS;
	    const lon0 = pos0Lon * MathUtils.DEGREES_TO_RADIANS;
	    const lat1 = pos1Lat * MathUtils.DEGREES_TO_RADIANS;
	    const lon1 = pos1Lon * MathUtils.DEGREES_TO_RADIANS;
	    const dlon = lon1 - lon0;
	    const cosLat0 = Math.cos(lat0);
	    const cosLat1 = Math.cos(lat1);
	    const a1 = Math.sin((lat1 - lat0) / 2);
	    const a2 = Math.sin(dlon / 2);
	    return Math.asin(Math.sqrt(a1 * a1 + cosLat0 * cosLat1 * a2 * a2)) * 6880.126;
	  }
	  /**
	    * Gets the heading between 2 points, given in lat/lon
	    * @param pos0Lat {number} Position 0 lat
	    * @param pos0Lon {number} Position 0 lon
	    * @param pos1Lat {number} Position 1 lat
	    * @param pos1Lon {number} Position 1 lon
	    * @return {number} distance in nautical miles
	    */


	  static computeGreatCircleHeading(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
	    const lat0 = pos0Lat * MathUtils.DEGREES_TO_RADIANS;
	    const lon0 = pos0Lon * MathUtils.DEGREES_TO_RADIANS;
	    const lat1 = pos1Lat * MathUtils.DEGREES_TO_RADIANS;
	    const lon1 = pos1Lon * MathUtils.DEGREES_TO_RADIANS;
	    const dlon = lon1 - lon0;
	    const cosLat1 = Math.cos(lat1);
	    let x = Math.sin(lat1 - lat0);
	    const sinLon2 = Math.sin(dlon / 2.0);
	    x += sinLon2 * sinLon2 * 2.0 * Math.sin(lat0) * cosLat1;
	    let heading = Math.atan2(cosLat1 * Math.sin(dlon), x);

	    if (heading < 0) {
	      heading += 2 * Math.PI;
	    }

	    return heading * MathUtils.RADIANS_TO_DEGREES;
	  }
	  /**
	    * Gets the distance between 2 points, given in lat/lon/alt above sea level
	    * @param pos0Lat {number} Position 0 lat
	    * @param pos0Lon {number} Position 0 lon
	    * @param pos0alt {number} Position 0 alt (feet)
	    * @param pos1Lat {number} Position 1 lat
	    * @param pos1Lon {number} Position 1 lon
	    * @param pos1alt {number} Position 1 alt (feet)
	    * @return {number} distance in nautical miles
	    */


	  static computeDistance3D(pos0Lat, pos0Lon, pos0alt, pos1Lat, pos1Lon, pos1alt) {
	    const earthRadius = 3440.065; // earth radius in nautcal miles

	    const deg2rad = Math.PI / 180;
	    const radius1 = pos0alt / 6076 + earthRadius;
	    const radius2 = pos1alt / 6076 + earthRadius;
	    const x1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.cos(deg2rad * (pos0Lon + 180));
	    const y1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.sin(deg2rad * (pos0Lon + 180));
	    const z1 = radius1 * Math.cos(deg2rad * (pos0Lat + 90));
	    const x2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.cos(deg2rad * (pos1Lon + 180));
	    const y2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.sin(deg2rad * (pos1Lon + 180));
	    const z2 = radius2 * Math.cos(deg2rad * (pos1Lat + 90));
	    return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
	  }
	  /**
	    * Check if point is inside a given ellipse
	    *
	    * @param {number} xPos x value of point
	    * @param {number} yPos y value of point
	    * @param {number} xLimPos +ve xLimit of ellipse
	    * @param {number} xLimNeg -ve xLimit of ellipse
	    * @param {number} yLimPos +ve yLimit of ellipse
	    * @param {number} yLimNeg -ve yLimit of ellipse
	    * @return {boolean} Whether the point is in the ellipse
	    *
	    */


	  static pointInEllipse(xPos, yPos, xLimPos, yLimPos) {
	    let xLimNeg = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : xLimPos;
	    let yLimNeg = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : yLimPos;
	    return xPos ** 2 / (xPos >= 0 ? xLimPos : xLimNeg) ** 2 + yPos ** 2 / (yPos >= 0 ? yLimPos : yLimNeg) ** 2 <= 1;
	  }
	  /**
	    * Performs the even-odd-rule Algorithm (a raycasting algorithm) to find out whether a point is in a given polygon.
	    * This runs in O(n) where n is the number of edges of the polygon.
	    *
	    * @param {Array} polygon an array representation of the polygon where polygon[i][0] is the x Value of the i-th point and polygon[i][1] is the y Value.
	    * @param {number} xPos  x value of point
	    * @param {number} yPos y value of point
	    * @return {boolean} Whether the point is in the polygon (not on the edge, just turn < into <= and > into >= for that)
	    */


	  static pointInPolygon(xPos, yPos, polygon) {
	    // A point is in a polygon if a line from the point to infinity crosses the polygon an odd number of times
	    let odd = false; // For each edge (In this case for each point of the polygon and the previous one)

	    for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
	      // If a line from the point into infinity crosses this edge
	      if (polygon[i][1] > yPos !== polygon[j][1] > yPos // One point needs to be above, one below our y coordinate
	      // ...and the edge doesn't cross our Y corrdinate before our x coordinate (but between our x coordinate and infinity)
	      && xPos < (polygon[j][0] - polygon[i][0]) * (yPos - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {
	        // Invert odd
	        odd = !odd;
	      }

	      j = i;
	    } // If the number of crossings was odd, the point is in the polygon


	    return odd;
	  }
	  /**
	    * Line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
	    * Determine the intersection point of two line segments
	    * Return null if the lines don't intersect
	    *
	    * @param {number} x1 line0 x origin
	    * @param {number} y1 line0 y origin
	    * @param {number} x2 line0 x end
	    * @param {number} y2 line0 y end
	    * @param {number} x3 line1 x origin
	    * @param {number} y3 line1 y origin
	    * @param {number} x4 line1 x end
	    * @param {number} y4 line1 y end
	    *
	    * @return {[number, number] | null} [x,y] of intercept, null if no intercept.
	    */


	  static intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	    // Check if none of the lines are of length 0
	    if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) {
	      return null;
	    }

	    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1); // Lines are parallel

	    if (denominator === 0) {
	      return null;
	    }

	    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
	    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator; // is the intersection along the segments

	    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
	      return null;
	    } // Return a object with the x and y coordinates of the intersection


	    const x = x1 + ua * (x2 - x1);
	    const y = y1 + ua * (y2 - y1);
	    return [x, y];
	  } // Find intersect with polygon


	  static intersectWithPolygon(x1, y1, x2, y2, polygon) {
	    let ret = null;
	    polygon.forEach((xy, index, polygon) => {
	      if (ret) return;

	      if (index + 1 >= polygon.length) {
	        return;
	      }

	      const x3 = xy[0];
	      const y3 = xy[1];
	      const x4 = polygon[index + 1][0];
	      const y4 = polygon[index + 1][1];
	      ret = MathUtils.intersect(x1, y1, x2, y2, x3, y3, x4, y4);
	    });
	    return ret;
	  }
	  /**
	    * Returns the given value if the value is >=lower or <= upper. Otherwise returns the boundary value.
	    * @param value the value to be clamped
	    * @param lower lowest boundary value
	    * @param upper highest boundary value
	    */


	  static clamp(value, lower, upper) {
	    return Math.min(Math.max(value, lower), upper);
	  }
	  /**
	    * Returns a value rounded to the given number of decimal precission.
	    * @param value
	    * @param decimalPrecision
	    */


	  static round(value, decimalPrecision) {
	    const shift = 10 ** decimalPrecision;
	    return Math.round((value + Number.EPSILON) * shift) / shift;
	  }

	}

	_defineProperty(MathUtils, "DEGREES_TO_RADIANS", Math.PI / 180);

	_defineProperty(MathUtils, "RADIANS_TO_DEGREES", 180 / Math.PI);

	_defineProperty(MathUtils, "optiPow10", []);

	let Constants;

	(function (Constants) {
	  Constants[Constants["G"] = 9.81] = "G";
	  Constants[Constants["EARTH_RADIUS_NM"] = 3440.1] = "EARTH_RADIUS_NM";
	  Constants[Constants["TONS_TO_POUNDS"] = 2204.62] = "TONS_TO_POUNDS";
	})(Constants || (Constants = {}));

	// Copyright (c) 2021-2022 FlyByWire Simulations
	/**
	 * Compute the remaining distance around an arc
	 * This is only valid once past the itp
	 * @param ppos       current aircraft position
	 * @param itp        current aircraft track
	 * @param centreFix  centre of the arc
	 * @param sweepAngle angle swept around the arc, +ve for clockwise
	 * @returns
	 */

	function arcDistanceToGo(ppos, itp, centreFix, sweepAngle) {
	  const itpBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, itp);
	  const pposBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
	  const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
	  const refFrameOffset = Avionics.Utils.diffAngle(0, itpBearing);
	  const pposAngle = sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - pposBearing) : Avionics.Utils.clampAngle(pposBearing - refFrameOffset); // before the arc... this implies max sweep angle is <340, arinc allows less than that anyway

	  if (pposAngle >= 340) {
	    return radius * Math.PI * Math.abs(sweepAngle) / 180;
	  }

	  if (pposAngle >= Math.abs(sweepAngle)) {
	    return 0;
	  }

	  return radius * Math.PI * (Math.abs(sweepAngle) - pposAngle) / 180;
	}
	/**
	 * Compute guidance parameters for an arc path
	 *
	 * @param ppos       current aircraft position
	 * @param trueTrack  current aircraft track
	 * @param itp        initial turning point for the arc
	 * @param centreFix  centre of the arc
	 * @param sweepAngle angle swept around the arc, +ve for clockwise
	 *
	 * @returns lateral path law params
	 */

	function arcGuidance(ppos, trueTrack, itp, centreFix, sweepAngle) {
	  const bearingPpos = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
	  const desiredTrack = sweepAngle > 0 ? Avionics.Utils.clampAngle(bearingPpos + 90) : Avionics.Utils.clampAngle(bearingPpos - 90);
	  const trackAngleError = Avionics.Utils.diffAngle(trueTrack, desiredTrack);
	  const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
	  const distanceFromCenter = Avionics.Utils.computeGreatCircleDistance(centreFix, ppos);
	  const crossTrackError = sweepAngle > 0 ? distanceFromCenter - radius : radius - distanceFromCenter;
	  const groundSpeed = SimVar.GetSimVarValue('GPS GROUND SPEED', 'meters per second');
	  const radiusInMetre = radius * 1852;
	  const phiCommand = (sweepAngle > 0 ? 1 : -1) * Math.atan(groundSpeed * groundSpeed / (radiusInMetre * 9.81)) * (180 / Math.PI);
	  return {
	    law: ControlLaw.LATERAL_PATH,
	    trackAngleError,
	    crossTrackError,
	    phiCommand
	  };
	}
	/**
	 * Computes a point along a course to a fix
	 *
	 * @param distanceFromEnd distance before end of line
	 * @param course          course of the line to the fix
	 * @param fix             self-explanatory
	 */

	function pointOnCourseToFix(distanceFromEnd, course, fix) {
	  return Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(course + 180), distanceFromEnd, fix.lat, fix.long);
	}
	/**
	 * Computes a point along an arc at a distance before its termination
	 *
	 * @param distanceFromFtp distance before end of arc
	 * @param ftp             arc exit point
	 * @param centreFix       arc centre fix
	 * @param sweepAngle      angle swept around the arc, +ve for clockwise
	 */

	function pointOnArc(distanceFromFtp, ftp, centreFix, sweepAngle) {
	  const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, ftp);
	  const distanceRatio = distanceFromFtp / arcLength(radius, sweepAngle);
	  const angleFromFtp = -distanceRatio * sweepAngle;
	  const centerToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ftp);
	  return Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(centerToTerminationBearing + angleFromFtp), radius, centreFix.lat, centreFix.long);
	}
	function minBank(segment) {
	  return segment === SegmentType.Enroute ? 5 : 10;
	}
	/**
	 *
	 * @param tas
	 * @param pathCapture true when the turn is to capture a path or heading, or for curved legs
	 * @returns
	 */

	function maxBank(tas, pathCapture) {
	  /*
	  TODO
	  if (engineOut) {
	      return 15;
	  }
	  */
	  if (pathCapture) {
	    // roll limit 2 from honeywell doc
	    if (tas < 100) {
	      return 15 + tas / 10;
	    }

	    if (tas > 350) {
	      return 19 + Math.max(0, (450 - tas) * 6 / 100);
	    }

	    return 25;
	  } // roll limit 1


	  if (tas < 150) {
	    return 15 + tas / 10;
	  }

	  if (tas > 300) {
	    return 19 + Math.max(0, (450 - tas) * 11 / 150);
	  }

	  return 30;
	}
	/**
	 * Returns the largest acceptable turn anticipation distance for a given true air speed
	 *
	 * @param tas the current or predicted true airspeed
	 */

	function maxTad(tas) {
	  if (tas === undefined) {
	    return 10;
	  }

	  if (tas <= 100) {
	    return 4;
	  }

	  if (tas >= 100 && tas <= 400) {
	    return tas / 100 * 4;
	  }

	  return 16;
	}
	function courseToFixDistanceToGo(ppos, course, fix) {
	  const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
	  const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
	  const pposToFixAngle = Avionics.Utils.diffAngle(pposToFixBearing, course);
	  return Math.max(0, pposToFixDist * Math.cos(pposToFixAngle * Math.PI / 180));
	}
	function courseToFixGuidance(ppos, trueTrack, course, fix) {
	  const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
	  const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
	  const pposToFixAngle = Avionics.Utils.diffAngle(course, pposToFixBearing);
	  const crossTrackError = pposToFixDist * Math.sin(pposToFixAngle * Math.PI / 180);
	  const trackAngleError = Avionics.Utils.diffAngle(trueTrack, course);
	  return {
	    law: ControlLaw.LATERAL_PATH,
	    trackAngleError,
	    crossTrackError,
	    phiCommand: 0
	  };
	}
	let PointSide;
	/**
	 * Returns the side of a fix (considering a course inbound to that fix) a point is lying on, assuming they lie on the same
	 * great circle.
	 *
	 * @param fix    destination fix
	 * @param course course to the fix
	 * @param point  point to compare with
	 *
	 * @returns `-1` if the point is before the fix, `1` if the point is after the fix
	 */

	(function (PointSide) {
	  PointSide[PointSide["Before"] = 0] = "Before";
	  PointSide[PointSide["After"] = 1] = "After";
	})(PointSide || (PointSide = {}));

	function sideOfPointOnCourseToFix(fix, course, point) {
	  const bearingFixPoint = bearingTo(fix, point);
	  const onOtherSide = Math.abs(MathUtils.diffAngle(bearingFixPoint, course)) < 3;

	  if (onOtherSide) {
	    return PointSide.After;
	  }

	  return PointSide.Before;
	}

	function getAlongTrackDistanceTo(start, end, ppos) {
	  const R = Constants.EARTH_RADIUS_NM;
	  const d13 = Avionics.Utils.computeGreatCircleDistance(start, ppos) / R;
	  const Theta13 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, ppos);
	  const Theta12 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, end);
	  const deltaXt = Math.asin(Math.sin(d13) * Math.sin(Theta13 - Theta12));
	  const deltaAt = Math.acos(Math.cos(d13) / Math.abs(Math.cos(deltaXt)));
	  return deltaAt * Math.sign(Math.cos(Theta12 - Theta13)) * R;
	}

	function getIntermediatePoint(start, end, fraction) {
	  const Phi1 = start.lat * Avionics.Utils.DEG2RAD;
	  const Gamma1 = start.long * Avionics.Utils.DEG2RAD;
	  const Phi2 = end.lat * Avionics.Utils.DEG2RAD;
	  const Gamma2 = end.long * Avionics.Utils.DEG2RAD;
	  const deltaPhi = Phi2 - Phi1;
	  const deltaGamma = Gamma2 - Gamma1;
	  const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(Phi1) * Math.cos(Phi2) * Math.sin(deltaGamma / 2) * Math.sin(deltaGamma / 2);
	  const delta = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	  const A = Math.sin((1 - fraction) * delta) / Math.sin(delta);
	  const B = Math.sin(fraction * delta) / Math.sin(delta);
	  const x = A * Math.cos(Phi1) * Math.cos(Gamma1) + B * Math.cos(Phi2) * Math.cos(Gamma2);
	  const y = A * Math.cos(Phi1) * Math.sin(Gamma1) + B * Math.cos(Phi2) * Math.sin(Gamma2);
	  const z = A * Math.sin(Phi1) + B * Math.sin(Phi2);
	  const Phi3 = Math.atan2(z, Math.sqrt(x * x + y * y));
	  const Gamma3 = Math.atan2(y, x);
	  return {
	    lat: Phi3 * Avionics.Utils.RAD2DEG,
	    long: Gamma3 * Avionics.Utils.RAD2DEG
	  };
	}
	function fixToFixGuidance(ppos, trueTrack, from, to) {
	  // Track angle error
	  const totalTrackDistance = Avionics.Utils.computeGreatCircleDistance(from, to);
	  const alongTrackDistance = getAlongTrackDistanceTo(from, to, ppos);
	  const intermediatePoint = getIntermediatePoint(from, to, Math.min(Math.max(alongTrackDistance / totalTrackDistance, 0.05), 0.95));
	  const desiredTrack = Avionics.Utils.computeGreatCircleHeading(intermediatePoint, to);
	  const trackAngleError = MathUtils.mod(desiredTrack - trueTrack + 180, 360) - 180; // Cross track error

	  const bearingAC = Avionics.Utils.computeGreatCircleHeading(from, ppos);
	  const bearingAB = Avionics.Utils.computeGreatCircleHeading(from, to);
	  const distanceAC = Avionics.Utils.computeDistance(from, ppos);
	  const desiredOffset = 0;
	  const actualOffset = Math.asin(Math.sin(Avionics.Utils.DEG2RAD * (distanceAC / Constants.EARTH_RADIUS_NM)) * Math.sin(Avionics.Utils.DEG2RAD * (bearingAC - bearingAB))) * Avionics.Utils.RAD2DEG * Constants.EARTH_RADIUS_NM;
	  const crossTrackError = desiredOffset - actualOffset;
	  return {
	    law: ControlLaw.LATERAL_PATH,
	    trackAngleError,
	    crossTrackError,
	    phiCommand: 0
	  };
	}
	function arcLength(radius, sweepAngle) {
	  const circumference = 2 * Math.PI * radius;
	  return circumference / 360 * Math.abs(sweepAngle);
	}
	function reciprocal(course) {
	  return Avionics.Utils.clampAngle(course + 180);
	}

	let PathVectorType;

	(function (PathVectorType) {
	  PathVectorType[PathVectorType["Line"] = 0] = "Line";
	  PathVectorType[PathVectorType["Arc"] = 1] = "Arc";
	  PathVectorType[PathVectorType["DebugPoint"] = 2] = "DebugPoint";
	})(PathVectorType || (PathVectorType = {}));

	let DebugPointColour;

	(function (DebugPointColour) {
	  DebugPointColour[DebugPointColour["White"] = 0] = "White";
	  DebugPointColour[DebugPointColour["Green"] = 1] = "Green";
	  DebugPointColour[DebugPointColour["Yellow"] = 2] = "Yellow";
	  DebugPointColour[DebugPointColour["Cyan"] = 3] = "Cyan";
	  DebugPointColour[DebugPointColour["Magenta"] = 4] = "Magenta";
	})(DebugPointColour || (DebugPointColour = {}));

	function pathVectorLength(vector) {
	  if (vector.type === PathVectorType.Line) {
	    return Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.endPoint);
	  }

	  if (vector.type === PathVectorType.Arc) {
	    const radius = Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.centrePoint);
	    return arcLength(radius, vector.sweepAngle);
	  }

	  return 0;
	}
	function pathVectorPoint(vector, distanceFromEnd) {
	  if (vector.type === PathVectorType.Line) {
	    return pointOnCourseToFix(distanceFromEnd, Avionics.Utils.computeGreatCircleHeading(vector.startPoint, vector.endPoint), vector.endPoint);
	  }

	  if (vector.type === PathVectorType.Arc) {
	    return pointOnArc(distanceFromEnd, vector.endPoint, vector.centrePoint, vector.sweepAngle);
	  }

	  return undefined;
	}

	/**
	 * A `Guidable` is a part of an LNAV path. It can be either a leg or a transition.
	 */

	class Guidable {
	  /**
	   * Whether the guidable should be considered for map display, guidance and sequencing
	   *
	   * For a transition, this indicates that the transition between the legs is selected but has no geometry.
	   * For a leg, this indicates that geometry conditions cause the leg to be skipped.
	   */

	  /**
	   * The first valid guidable that precedes this one. This takes into account the `isNull` property, meaning other
	   * guidables can exist before this one but would not be referred to by this property if they were to be null.
	   */

	  /**
	   * The first valid guidable that succeeds this one. This takes into account the `isNull` property, meaning other
	   * guidables can exist after this one but would not be referred to by this property if they were to be null.
	   */
	  constructor() {
	    _defineProperty(this, "isNull", false);

	    _defineProperty(this, "inboundGuidable", void 0);

	    _defineProperty(this, "outboundGuidable", void 0);

	    _defineProperty(this, "isComputed", false);
	  }
	  /**
	   * Used to update the {@link inboundGuidable} and {@link outboundGuidable} properties.
	   */


	  setNeighboringGuidables(inbound, outbound) {
	    this.inboundGuidable = inbound;
	    this.outboundGuidable = outbound;
	  }

	  getPathEndPoint() {
	    if (this.isNull) {
	      return this.inboundGuidable.getPathEndPoint();
	    }

	    if (this.predictedPath) {
	      for (let i = this.predictedPath.length - 1; i >= 0; i--) {
	        const vector = this.predictedPath[i];

	        if (vector.type === PathVectorType.DebugPoint) {
	          continue;
	        }

	        if (vector.endPoint) {
	          return vector.endPoint;
	        }
	      }
	    }

	    return undefined;
	  }

	  /**
	   * Obtains the location of a pseudo-waypoint on the guidable (does NOT include inbound or outbound
	   * transitions for legs; see {@link PseudoWaypoints.pointFromEndOfPath} for a function that includes those).
	   *
	   * @param distanceBeforeTerminator
	   */
	  getPseudoWaypointLocation(distanceBeforeTerminator) {
	    let accumulator = 0;

	    for (const vector of [...this.predictedPath].reverse()) {
	      const length = pathVectorLength(vector);

	      if (accumulator + length > distanceBeforeTerminator) {
	        return pathVectorPoint(vector, distanceBeforeTerminator - accumulator);
	      }

	      accumulator += length;
	    }

	    return undefined;
	  }
	  /**
	   * Path vectors for the predicted path.
	   *
	   * This path always represents what is being drawn on the ND, and is used for the vast majority of prediction computations. It is
	   * however not always representative of guidance, for example in case of path capture or course capture transitions or CX/VX legs.
	   */


	  /**
	   * Whether the path ends in a curved arc - for entry roll anticipation
	   */
	  get startsInCircularArc() {
	    return false;
	  }
	  /**
	   * Whether the path ends in a curved arc - for exit roll anticipation
	   */


	  get endsInCircularArc() {
	    return false;
	  }
	  /**
	   * Obtain the nominal roll angle for the curved portion of the path
	   */


	}

	let TransitionState;

	(function (TransitionState) {
	  TransitionState[TransitionState["UPCOMING"] = 0] = "UPCOMING";
	  TransitionState[TransitionState["OUT_OF_ACTIVE_LEG"] = 1] = "OUT_OF_ACTIVE_LEG";
	  TransitionState[TransitionState["ACTIVE"] = 2] = "ACTIVE";
	  TransitionState[TransitionState["INTO_ACTIVE_LEG"] = 3] = "INTO_ACTIVE_LEG";
	  TransitionState[TransitionState["PASSED"] = 4] = "PASSED";
	})(TransitionState || (TransitionState = {}));

	class Transition extends Guidable {
	  constructor(previousLeg, nextLeg) {
	    super();
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "isFrozen", false);

	    this.inboundGuidable = previousLeg;
	    this.outboundGuidable = nextLeg;
	  }

	  freeze() {
	    this.isFrozen = true;
	  }
	  /**
	   * Used to update the {@link previousLeg} and {@link nextLeg} properties.
	   */


	  setNeighboringLegs(previous, next) {
	    this.previousLeg = previous;
	    this.nextLeg = next;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {// Default impl.
	  }

	}

	var constants = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.areaConversion = exports.timeConversion = exports.distanceConversion = exports.altitudeKeys = exports.latitudeKeys = exports.longitudeKeys = exports.MAXLON = exports.MINLON = exports.MAXLAT = exports.MINLAT = exports.earthRadius = exports.sexagesimalPattern = void 0;
	  var sexagesimalPattern = /^([0-9]{1,3})\s*([0-9]{1,3}(?:\.(?:[0-9]{1,}))?)[']\s*(([0-9]{1,3}(\.([0-9]{1,}))?)["]\s*)?([NEOSW]?)$/;
	  exports.sexagesimalPattern = sexagesimalPattern;
	  var earthRadius = 6378137;
	  exports.earthRadius = earthRadius;
	  var MINLAT = -90;
	  exports.MINLAT = MINLAT;
	  var MAXLAT = 90;
	  exports.MAXLAT = MAXLAT;
	  var MINLON = -180;
	  exports.MINLON = MINLON;
	  var MAXLON = 180;
	  exports.MAXLON = MAXLON;
	  var longitudeKeys = ["lng", "lon", "longitude", 0];
	  exports.longitudeKeys = longitudeKeys;
	  var latitudeKeys = ["lat", "latitude", 1];
	  exports.latitudeKeys = latitudeKeys;
	  var altitudeKeys = ["alt", "altitude", "elevation", "elev", 2];
	  exports.altitudeKeys = altitudeKeys;
	  var distanceConversion = {
	    m: 1,
	    km: 0.001,
	    cm: 100,
	    mm: 1000,
	    mi: 1 / 1609.344,
	    sm: 1 / 1852.216,
	    ft: 100 / 30.48,
	    in: 100 / 2.54,
	    yd: 1 / 0.9144
	  };
	  exports.distanceConversion = distanceConversion;
	  var timeConversion = {
	    m: 60,
	    h: 3600,
	    d: 86400
	  };
	  exports.timeConversion = timeConversion;
	  var areaConversion = {
	    m2: 1,
	    km2: 0.000001,
	    ha: 0.0001,
	    a: 0.01,
	    ft2: 10.763911,
	    yd2: 1.19599,
	    in2: 1550.0031
	  };
	  exports.areaConversion = areaConversion;
	  areaConversion.sqm = areaConversion.m2;
	  areaConversion.sqkm = areaConversion.km2;
	  areaConversion.sqft = areaConversion.ft2;
	  areaConversion.sqyd = areaConversion.yd2;
	  areaConversion.sqin = areaConversion.in2;
	});

	var getCoordinateKey_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var getCoordinateKey = function getCoordinateKey(point, keysToLookup) {
	    return keysToLookup.reduce(function (foundKey, key) {
	      if (typeof point === "undefined" || point === null) {
	        throw new Error("'".concat(point, "' is no valid coordinate."));
	      }

	      if (Object.prototype.hasOwnProperty.call(point, key) && typeof key !== "undefined" && typeof foundKey === "undefined") {
	        foundKey = key;
	        return key;
	      }

	      return foundKey;
	    }, undefined);
	  };

	  var _default = getCoordinateKey;
	  exports.default = _default;
	});

	var isDecimal_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var isDecimal = function isDecimal(value) {
	    var checkedValue = value.toString().trim();

	    if (isNaN(parseFloat(checkedValue))) {
	      return false;
	    }

	    return parseFloat(checkedValue) === Number(checkedValue);
	  };

	  var _default = isDecimal;
	  exports.default = _default;
	});

	var isSexagesimal_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var isSexagesimal = function isSexagesimal(value) {
	    return constants.sexagesimalPattern.test(value.toString().trim());
	  };

	  var _default = isSexagesimal;
	  exports.default = _default;
	});

	var sexagesimalToDecimal_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var sexagesimalToDecimal = function sexagesimalToDecimal(sexagesimal) {
	    var data = new RegExp(constants.sexagesimalPattern).exec(sexagesimal.toString().trim());

	    if (typeof data === "undefined" || data === null) {
	      throw new Error("Given value is not in sexagesimal format");
	    }

	    var min = Number(data[2]) / 60 || 0;
	    var sec = Number(data[4]) / 3600 || 0;
	    var decimal = parseFloat(data[1]) + min + sec;
	    return ["S", "W"].includes(data[7]) ? -decimal : decimal;
	  };

	  var _default = sexagesimalToDecimal;
	  exports.default = _default;
	});

	var getCoordinateKeys_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function ownKeys(object, enumerableOnly) {
	    var keys = Object.keys(object);

	    if (Object.getOwnPropertySymbols) {
	      var symbols = Object.getOwnPropertySymbols(object);
	      if (enumerableOnly) symbols = symbols.filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	      });
	      keys.push.apply(keys, symbols);
	    }

	    return keys;
	  }

	  function _objectSpread(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i] != null ? arguments[i] : {};

	      if (i % 2) {
	        ownKeys(Object(source), true).forEach(function (key) {
	          _defineProperty(target, key, source[key]);
	        });
	      } else if (Object.getOwnPropertyDescriptors) {
	        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	      } else {
	        ownKeys(Object(source)).forEach(function (key) {
	          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	        });
	      }
	    }

	    return target;
	  }

	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }

	    return obj;
	  }

	  var getCoordinateKeys = function getCoordinateKeys(point) {
	    var keysToLookup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	      longitude: constants.longitudeKeys,
	      latitude: constants.latitudeKeys,
	      altitude: constants.altitudeKeys
	    };
	    var longitude = (0, _getCoordinateKey.default)(point, keysToLookup.longitude);
	    var latitude = (0, _getCoordinateKey.default)(point, keysToLookup.latitude);
	    var altitude = (0, _getCoordinateKey.default)(point, keysToLookup.altitude);
	    return _objectSpread({
	      latitude: latitude,
	      longitude: longitude
	    }, altitude ? {
	      altitude: altitude
	    } : {});
	  };

	  var _default = getCoordinateKeys;
	  exports.default = _default;
	});

	var isValidLatitude_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _isDecimal = _interopRequireDefault(isDecimal_1);

	  var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);

	  var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isValidLatitude = function isValidLatitude(value) {
	    if ((0, _isDecimal.default)(value)) {
	      if (parseFloat(value) > constants.MAXLAT || value < constants.MINLAT) {
	        return false;
	      }

	      return true;
	    }

	    if ((0, _isSexagesimal.default)(value)) {
	      return isValidLatitude((0, _sexagesimalToDecimal.default)(value));
	    }

	    return false;
	  };

	  var _default = isValidLatitude;
	  exports.default = _default;
	});

	var isValidLongitude_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _isDecimal = _interopRequireDefault(isDecimal_1);

	  var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);

	  var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isValidLongitude = function isValidLongitude(value) {
	    if ((0, _isDecimal.default)(value)) {
	      if (parseFloat(value) > constants.MAXLON || value < constants.MINLON) {
	        return false;
	      }

	      return true;
	    }

	    if ((0, _isSexagesimal.default)(value)) {
	      return isValidLongitude((0, _sexagesimalToDecimal.default)(value));
	    }

	    return false;
	  };

	  var _default = isValidLongitude;
	  exports.default = _default;
	});

	var isValidCoordinate_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getCoordinateKeys2 = _interopRequireDefault(getCoordinateKeys_1);

	  var _isValidLatitude = _interopRequireDefault(isValidLatitude_1);

	  var _isValidLongitude = _interopRequireDefault(isValidLongitude_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isValidCoordinate = function isValidCoordinate(point) {
	    var _getCoordinateKeys = (0, _getCoordinateKeys2.default)(point),
	        latitude = _getCoordinateKeys.latitude,
	        longitude = _getCoordinateKeys.longitude;

	    if (Array.isArray(point) && point.length >= 2) {
	      return (0, _isValidLongitude.default)(point[0]) && (0, _isValidLatitude.default)(point[1]);
	    }

	    if (typeof latitude === "undefined" || typeof longitude === "undefined") {
	      return false;
	    }

	    var lon = point[longitude];
	    var lat = point[latitude];

	    if (typeof lat === "undefined" || typeof lon === "undefined") {
	      return false;
	    }

	    if ((0, _isValidLatitude.default)(lat) === false || (0, _isValidLongitude.default)(lon) === false) {
	      return false;
	    }

	    return true;
	  };

	  var _default = isValidCoordinate;
	  exports.default = _default;
	});

	var toDecimal_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _isDecimal = _interopRequireDefault(isDecimal_1);

	  var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);

	  var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);

	  var _isValidCoordinate = _interopRequireDefault(isValidCoordinate_1);

	  var _getCoordinateKeys = _interopRequireDefault(getCoordinateKeys_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function ownKeys(object, enumerableOnly) {
	    var keys = Object.keys(object);

	    if (Object.getOwnPropertySymbols) {
	      var symbols = Object.getOwnPropertySymbols(object);
	      if (enumerableOnly) symbols = symbols.filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	      });
	      keys.push.apply(keys, symbols);
	    }

	    return keys;
	  }

	  function _objectSpread(target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i] != null ? arguments[i] : {};

	      if (i % 2) {
	        ownKeys(Object(source), true).forEach(function (key) {
	          _defineProperty(target, key, source[key]);
	        });
	      } else if (Object.getOwnPropertyDescriptors) {
	        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	      } else {
	        ownKeys(Object(source)).forEach(function (key) {
	          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	        });
	      }
	    }

	    return target;
	  }

	  function _defineProperty(obj, key, value) {
	    if (key in obj) {
	      Object.defineProperty(obj, key, {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    } else {
	      obj[key] = value;
	    }

	    return obj;
	  }

	  var toDecimal = function toDecimal(value) {
	    if ((0, _isDecimal.default)(value)) {
	      return Number(value);
	    }

	    if ((0, _isSexagesimal.default)(value)) {
	      return (0, _sexagesimalToDecimal.default)(value);
	    }

	    if ((0, _isValidCoordinate.default)(value)) {
	      var keys = (0, _getCoordinateKeys.default)(value);

	      if (Array.isArray(value)) {
	        return value.map(function (v, index) {
	          return [0, 1].includes(index) ? toDecimal(v) : v;
	        });
	      }

	      return _objectSpread(_objectSpread(_objectSpread({}, value), keys.latitude && _defineProperty({}, keys.latitude, toDecimal(value[keys.latitude]))), keys.longitude && _defineProperty({}, keys.longitude, toDecimal(value[keys.longitude])));
	    }

	    if (Array.isArray(value)) {
	      return value.map(function (point) {
	        return (0, _isValidCoordinate.default)(point) ? toDecimal(point) : point;
	      });
	    }

	    return value;
	  };

	  var _default = toDecimal;
	  exports.default = _default;
	});

	var getLatitude_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);

	  var _toDecimal = _interopRequireDefault(toDecimal_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getLatitude = function getLatitude(point, raw) {
	    var latKey = (0, _getCoordinateKey.default)(point, constants.latitudeKeys);

	    if (typeof latKey === "undefined" || latKey === null) {
	      return;
	    }

	    var value = point[latKey];
	    return raw === true ? value : (0, _toDecimal.default)(value);
	  };

	  var _default = getLatitude;
	  exports.default = _default;
	});

	var getLongitude_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);

	  var _toDecimal = _interopRequireDefault(toDecimal_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getLongitude = function getLongitude(point, raw) {
	    var latKey = (0, _getCoordinateKey.default)(point, constants.longitudeKeys);

	    if (typeof latKey === "undefined" || latKey === null) {
	      return;
	    }

	    var value = point[latKey];
	    return raw === true ? value : (0, _toDecimal.default)(value);
	  };

	  var _default = getLongitude;
	  exports.default = _default;
	});

	var toRad_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var toRad = function toRad(value) {
	    return value * Math.PI / 180;
	  };

	  var _default = toRad;
	  exports.default = _default;
	});

	var toDeg_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var toDeg = function toDeg(value) {
	    return value * 180 / Math.PI;
	  };

	  var _default = toDeg;
	  exports.default = _default;
	});

	var computeDestinationPoint_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _toDeg = _interopRequireDefault(toDeg_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var computeDestinationPoint = function computeDestinationPoint(start, distance, bearing) {
	    var radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371000;
	    var lat = (0, _getLatitude.default)(start);
	    var lng = (0, _getLongitude.default)(start);
	    var delta = distance / radius;
	    var theta = (0, _toRad.default)(bearing);
	    var phi1 = (0, _toRad.default)(lat);
	    var lambda1 = (0, _toRad.default)(lng);
	    var phi2 = Math.asin(Math.sin(phi1) * Math.cos(delta) + Math.cos(phi1) * Math.sin(delta) * Math.cos(theta));
	    var lambda2 = lambda1 + Math.atan2(Math.sin(theta) * Math.sin(delta) * Math.cos(phi1), Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2));
	    var longitude = (0, _toDeg.default)(lambda2);

	    if (longitude < constants.MINLON || longitude > constants.MAXLON) {
	      lambda2 = (lambda2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
	      longitude = (0, _toDeg.default)(lambda2);
	    }

	    return {
	      latitude: (0, _toDeg.default)(phi2),
	      longitude: longitude
	    };
	  };

	  var _default = computeDestinationPoint;
	  exports.default = _default;
	});

	var convertArea_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var convertArea = function convertArea(squareMeters) {
	    var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";
	    var factor = constants.areaConversion[targetUnit];

	    if (factor) {
	      return squareMeters * factor;
	    }

	    throw new Error("Invalid unit used for area conversion.");
	  };

	  var _default = convertArea;
	  exports.default = _default;
	});

	var convertDistance_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var convertDistance = function convertDistance(meters) {
	    var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";
	    var factor = constants.distanceConversion[targetUnit];

	    if (factor) {
	      return meters * factor;
	    }

	    throw new Error("Invalid unit used for distance conversion.");
	  };

	  var _default = convertDistance;
	  exports.default = _default;
	});

	var convertSpeed_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var convertSpeed = function convertSpeed(metersPerSecond) {
	    var targetUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "kmh";

	    switch (targetUnit) {
	      case "kmh":
	        return metersPerSecond * constants.timeConversion.h * constants.distanceConversion.km;

	      case "mph":
	        return metersPerSecond * constants.timeConversion.h * constants.distanceConversion.mi;

	      default:
	        return metersPerSecond;
	    }
	  };

	  var _default = convertSpeed;
	  exports.default = _default;
	});

	var decimalToSexagesimal = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  function _slicedToArray(arr, i) {
	    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	  }

	  function _nonIterableRest() {
	    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  function _unsupportedIterableToArray(o, minLen) {
	    if (!o) return;
	    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	    var n = Object.prototype.toString.call(o).slice(8, -1);
	    if (n === "Object" && o.constructor) n = o.constructor.name;
	    if (n === "Map" || n === "Set") return Array.from(o);
	    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	  }

	  function _arrayLikeToArray(arr, len) {
	    if (len == null || len > arr.length) len = arr.length;

	    for (var i = 0, arr2 = new Array(len); i < len; i++) {
	      arr2[i] = arr[i];
	    }

	    return arr2;
	  }

	  function _iterableToArrayLimit(arr, i) {
	    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"] != null) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  function _arrayWithHoles(arr) {
	    if (Array.isArray(arr)) return arr;
	  }

	  var imprecise = function imprecise(number) {
	    var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
	    var factor = Math.pow(10, decimals);
	    return Math.round(number * factor) / factor;
	  };

	  var decimal2sexagesimalNext = function decimal2sexagesimalNext(decimal) {
	    var _decimal$toString$spl = decimal.toString().split("."),
	        _decimal$toString$spl2 = _slicedToArray(_decimal$toString$spl, 2),
	        pre = _decimal$toString$spl2[0],
	        post = _decimal$toString$spl2[1];

	    var deg = Math.abs(Number(pre));
	    var min0 = Number("0." + (post || 0)) * 60;
	    var sec0 = min0.toString().split(".");
	    var min = Math.floor(min0);
	    var sec = imprecise(Number("0." + (sec0[1] || 0)) * 60).toString();

	    var _sec$split = sec.split("."),
	        _sec$split2 = _slicedToArray(_sec$split, 2),
	        secPreDec = _sec$split2[0],
	        _sec$split2$ = _sec$split2[1],
	        secDec = _sec$split2$ === void 0 ? "0" : _sec$split2$;

	    return deg + "\xB0 " + min.toString().padStart(2, "0") + "' " + secPreDec.padStart(2, "0") + "." + secDec.padEnd(1, "0") + "\"";
	  };

	  var _default = decimal2sexagesimalNext;
	  exports.default = _default;
	});

	var robustAcos_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var robustAcos = function robustAcos(value) {
	    if (value > 1) {
	      return 1;
	    }

	    if (value < -1) {
	      return -1;
	    }

	    return value;
	  };

	  var _default = robustAcos;
	  exports.default = _default;
	});

	var getDistance_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _robustAcos = _interopRequireDefault(robustAcos_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getDistance = function getDistance(from, to) {
	    var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	    accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
	    var fromLat = (0, _getLatitude.default)(from);
	    var fromLon = (0, _getLongitude.default)(from);
	    var toLat = (0, _getLatitude.default)(to);
	    var toLon = (0, _getLongitude.default)(to);

	    var distance = Math.acos((0, _robustAcos.default)(Math.sin((0, _toRad.default)(toLat)) * Math.sin((0, _toRad.default)(fromLat)) + Math.cos((0, _toRad.default)(toLat)) * Math.cos((0, _toRad.default)(fromLat)) * Math.cos((0, _toRad.default)(fromLon) - (0, _toRad.default)(toLon)))) * constants.earthRadius;

	    return Math.round(distance / accuracy) * accuracy;
	  };

	  var _default = getDistance;
	  exports.default = _default;
	});

	var orderByDistance_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var orderByDistance = function orderByDistance(point, coords) {
	    var distanceFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getDistance.default;
	    distanceFn = typeof distanceFn === "function" ? distanceFn : _getDistance.default;
	    return coords.slice().sort(function (a, b) {
	      return distanceFn(point, a) - distanceFn(point, b);
	    });
	  };

	  var _default = orderByDistance;
	  exports.default = _default;
	});

	var findNearest_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _orderByDistance = _interopRequireDefault(orderByDistance_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var findNearest = function findNearest(point, coords) {
	    return (0, _orderByDistance.default)(point, coords)[0];
	  };

	  var _default = findNearest;
	  exports.default = _default;
	});

	var getAreaOfPolygon_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getAreaOfPolygon = function getAreaOfPolygon(points) {
	    var area = 0;

	    if (points.length > 2) {
	      var lowerIndex;
	      var middleIndex;
	      var upperIndex;

	      for (var i = 0; i < points.length; i++) {
	        if (i === points.length - 2) {
	          lowerIndex = points.length - 2;
	          middleIndex = points.length - 1;
	          upperIndex = 0;
	        } else if (i === points.length - 1) {
	          lowerIndex = points.length - 1;
	          middleIndex = 0;
	          upperIndex = 1;
	        } else {
	          lowerIndex = i;
	          middleIndex = i + 1;
	          upperIndex = i + 2;
	        }

	        var p1lon = (0, _getLongitude.default)(points[lowerIndex]);
	        var p2lat = (0, _getLatitude.default)(points[middleIndex]);
	        var p3lon = (0, _getLongitude.default)(points[upperIndex]);
	        area += ((0, _toRad.default)(p3lon) - (0, _toRad.default)(p1lon)) * Math.sin((0, _toRad.default)(p2lat));
	      }

	      area = area * constants.earthRadius * constants.earthRadius / 2;
	    }

	    return Math.abs(area);
	  };

	  var _default = getAreaOfPolygon;
	  exports.default = _default;
	});

	var getBounds_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getBounds = function getBounds(points) {
	    if (Array.isArray(points) === false || points.length === 0) {
	      throw new Error("No points were given.");
	    }

	    return points.reduce(function (stats, point) {
	      var latitude = (0, _getLatitude.default)(point);
	      var longitude = (0, _getLongitude.default)(point);
	      return {
	        maxLat: Math.max(latitude, stats.maxLat),
	        minLat: Math.min(latitude, stats.minLat),
	        maxLng: Math.max(longitude, stats.maxLng),
	        minLng: Math.min(longitude, stats.minLng)
	      };
	    }, {
	      maxLat: -Infinity,
	      minLat: Infinity,
	      maxLng: -Infinity,
	      minLng: Infinity
	    });
	  };

	  var _default = getBounds;
	  exports.default = _default;
	});

	var getBoundsOfDistance_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _toDeg = _interopRequireDefault(toDeg_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getBoundsOfDistance = function getBoundsOfDistance(point, distance) {
	    var latitude = (0, _getLatitude.default)(point);
	    var longitude = (0, _getLongitude.default)(point);
	    var radLat = (0, _toRad.default)(latitude);
	    var radLon = (0, _toRad.default)(longitude);
	    var radDist = distance / constants.earthRadius;
	    var minLat = radLat - radDist;
	    var maxLat = radLat + radDist;
	    var MAX_LAT_RAD = (0, _toRad.default)(constants.MAXLAT);
	    var MIN_LAT_RAD = (0, _toRad.default)(constants.MINLAT);
	    var MAX_LON_RAD = (0, _toRad.default)(constants.MAXLON);
	    var MIN_LON_RAD = (0, _toRad.default)(constants.MINLON);
	    var minLon;
	    var maxLon;

	    if (minLat > MIN_LAT_RAD && maxLat < MAX_LAT_RAD) {
	      var deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));
	      minLon = radLon - deltaLon;

	      if (minLon < MIN_LON_RAD) {
	        minLon += Math.PI * 2;
	      }

	      maxLon = radLon + deltaLon;

	      if (maxLon > MAX_LON_RAD) {
	        maxLon -= Math.PI * 2;
	      }
	    } else {
	      minLat = Math.max(minLat, MIN_LAT_RAD);
	      maxLat = Math.min(maxLat, MAX_LAT_RAD);
	      minLon = MIN_LON_RAD;
	      maxLon = MAX_LON_RAD;
	    }

	    return [{
	      latitude: (0, _toDeg.default)(minLat),
	      longitude: (0, _toDeg.default)(minLon)
	    }, {
	      latitude: (0, _toDeg.default)(maxLat),
	      longitude: (0, _toDeg.default)(maxLon)
	    }];
	  };

	  var _default = getBoundsOfDistance;
	  exports.default = _default;
	});

	var getCenter_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _toDeg = _interopRequireDefault(toDeg_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getCenter = function getCenter(points) {
	    if (Array.isArray(points) === false || points.length === 0) {
	      return false;
	    }

	    var numberOfPoints = points.length;
	    var sum = points.reduce(function (acc, point) {
	      var pointLat = (0, _toRad.default)((0, _getLatitude.default)(point));
	      var pointLon = (0, _toRad.default)((0, _getLongitude.default)(point));
	      return {
	        X: acc.X + Math.cos(pointLat) * Math.cos(pointLon),
	        Y: acc.Y + Math.cos(pointLat) * Math.sin(pointLon),
	        Z: acc.Z + Math.sin(pointLat)
	      };
	    }, {
	      X: 0,
	      Y: 0,
	      Z: 0
	    });
	    var X = sum.X / numberOfPoints;
	    var Y = sum.Y / numberOfPoints;
	    var Z = sum.Z / numberOfPoints;
	    return {
	      longitude: (0, _toDeg.default)(Math.atan2(Y, X)),
	      latitude: (0, _toDeg.default)(Math.atan2(Z, Math.sqrt(X * X + Y * Y)))
	    };
	  };

	  var _default = getCenter;
	  exports.default = _default;
	});

	var getCenterOfBounds_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getBounds = _interopRequireDefault(getBounds_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getCenterOfBounds = function getCenterOfBounds(coords) {
	    var bounds = (0, _getBounds.default)(coords);
	    var latitude = bounds.minLat + (bounds.maxLat - bounds.minLat) / 2;
	    var longitude = bounds.minLng + (bounds.maxLng - bounds.minLng) / 2;
	    return {
	      latitude: parseFloat(latitude.toFixed(6)),
	      longitude: parseFloat(longitude.toFixed(6))
	    };
	  };

	  var _default = getCenterOfBounds;
	  exports.default = _default;
	});

	var getRhumbLineBearing_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _toDeg = _interopRequireDefault(toDeg_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getRhumbLineBearing = function getRhumbLineBearing(origin, dest) {
	    var diffLon = (0, _toRad.default)((0, _getLongitude.default)(dest)) - (0, _toRad.default)((0, _getLongitude.default)(origin));
	    var diffPhi = Math.log(Math.tan((0, _toRad.default)((0, _getLatitude.default)(dest)) / 2 + Math.PI / 4) / Math.tan((0, _toRad.default)((0, _getLatitude.default)(origin)) / 2 + Math.PI / 4));

	    if (Math.abs(diffLon) > Math.PI) {
	      if (diffLon > 0) {
	        diffLon = (Math.PI * 2 - diffLon) * -1;
	      } else {
	        diffLon = Math.PI * 2 + diffLon;
	      }
	    }

	    return ((0, _toDeg.default)(Math.atan2(diffLon, diffPhi)) + 360) % 360;
	  };

	  var _default = getRhumbLineBearing;
	  exports.default = _default;
	});

	var getCompassDirection_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getRhumbLineBearing = _interopRequireDefault(getRhumbLineBearing_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getCompassDirection = function getCompassDirection(origin, dest) {
	    var bearingFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getRhumbLineBearing.default;
	    var bearing = typeof bearingFn === "function" ? bearingFn(origin, dest) : (0, _getRhumbLineBearing.default)(origin, dest);

	    if (isNaN(bearing)) {
	      throw new Error("Could not calculate bearing for given points. Check your bearing function");
	    }

	    switch (Math.round(bearing / 22.5)) {
	      case 1:
	        return "NNE";

	      case 2:
	        return "NE";

	      case 3:
	        return "ENE";

	      case 4:
	        return "E";

	      case 5:
	        return "ESE";

	      case 6:
	        return "SE";

	      case 7:
	        return "SSE";

	      case 8:
	        return "S";

	      case 9:
	        return "SSW";

	      case 10:
	        return "SW";

	      case 11:
	        return "WSW";

	      case 12:
	        return "W";

	      case 13:
	        return "WNW";

	      case 14:
	        return "NW";

	      case 15:
	        return "NNW";

	      default:
	        return "N";
	    }
	  };

	  var _default = getCompassDirection;
	  exports.default = _default;
	});

	var getDistanceFromLine_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  var _robustAcos = _interopRequireDefault(robustAcos_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getDistanceFromLine = function getDistanceFromLine(point, lineStart, lineEnd) {
	    var accuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
	    var d1 = (0, _getDistance.default)(lineStart, point, accuracy);
	    var d2 = (0, _getDistance.default)(point, lineEnd, accuracy);
	    var d3 = (0, _getDistance.default)(lineStart, lineEnd, accuracy);
	    var alpha = Math.acos((0, _robustAcos.default)((d1 * d1 + d3 * d3 - d2 * d2) / (2 * d1 * d3)));
	    var beta = Math.acos((0, _robustAcos.default)((d2 * d2 + d3 * d3 - d1 * d1) / (2 * d2 * d3)));

	    if (alpha > Math.PI / 2) {
	      return d1;
	    }

	    if (beta > Math.PI / 2) {
	      return d2;
	    }

	    return Math.sin(alpha) * d1;
	  };

	  var _default = getDistanceFromLine;
	  exports.default = _default;
	});

	var getGreatCircleBearing_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _toDeg = _interopRequireDefault(toDeg_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getGreatCircleBearing = function getGreatCircleBearing(origin, dest) {
	    var destLat = (0, _getLatitude.default)(dest);
	    var detLon = (0, _getLongitude.default)(dest);
	    var originLat = (0, _getLatitude.default)(origin);
	    var originLon = (0, _getLongitude.default)(origin);
	    var bearing = ((0, _toDeg.default)(Math.atan2(Math.sin((0, _toRad.default)(detLon) - (0, _toRad.default)(originLon)) * Math.cos((0, _toRad.default)(destLat)), Math.cos((0, _toRad.default)(originLat)) * Math.sin((0, _toRad.default)(destLat)) - Math.sin((0, _toRad.default)(originLat)) * Math.cos((0, _toRad.default)(destLat)) * Math.cos((0, _toRad.default)(detLon) - (0, _toRad.default)(originLon)))) + 360) % 360;
	    return bearing;
	  };

	  var _default = getGreatCircleBearing;
	  exports.default = _default;
	});

	var getPathLength_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _typeof(obj) {
	    "@babel/helpers - typeof";

	    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	      _typeof = function _typeof(obj) {
	        return typeof obj;
	      };
	    } else {
	      _typeof = function _typeof(obj) {
	        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	      };
	    }

	    return _typeof(obj);
	  }

	  var getPathLength = function getPathLength(points) {
	    var distanceFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _getDistance.default;
	    return points.reduce(function (acc, point) {
	      if (_typeof(acc) === "object" && acc.last !== null) {
	        acc.distance += distanceFn(point, acc.last);
	      }

	      acc.last = point;
	      return acc;
	    }, {
	      last: null,
	      distance: 0
	    }).distance;
	  };

	  var _default = getPathLength;
	  exports.default = _default;
	});

	var getPreciseDistance = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getDistance = function getDistance(start, end) {
	    var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	    accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
	    var startLat = (0, _getLatitude.default)(start);
	    var startLon = (0, _getLongitude.default)(start);
	    var endLat = (0, _getLatitude.default)(end);
	    var endLon = (0, _getLongitude.default)(end);
	    var b = 6356752.314245;
	    var ellipsoidParams = 1 / 298.257223563;
	    var L = (0, _toRad.default)(endLon - startLon);
	    var cosSigma;
	    var sigma;
	    var sinAlpha;
	    var cosSqAlpha;
	    var cos2SigmaM;
	    var sinSigma;
	    var U1 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(startLat))));
	    var U2 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(endLat))));
	    var sinU1 = Math.sin(U1);
	    var cosU1 = Math.cos(U1);
	    var sinU2 = Math.sin(U2);
	    var cosU2 = Math.cos(U2);
	    var lambda = L;
	    var lambdaP;
	    var iterLimit = 100;

	    do {
	      var sinLambda = Math.sin(lambda);
	      var cosLambda = Math.cos(lambda);
	      sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));

	      if (sinSigma === 0) {
	        return 0;
	      }

	      cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
	      sigma = Math.atan2(sinSigma, cosSigma);
	      sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
	      cosSqAlpha = 1 - sinAlpha * sinAlpha;
	      cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;

	      if (isNaN(cos2SigmaM)) {
	        cos2SigmaM = 0;
	      }

	      var C = ellipsoidParams / 16 * cosSqAlpha * (4 + ellipsoidParams * (4 - 3 * cosSqAlpha));
	      lambdaP = lambda;
	      lambda = L + (1 - C) * ellipsoidParams * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
	    } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);

	    if (iterLimit === 0) {
	      return NaN;
	    }

	    var uSq = cosSqAlpha * (constants.earthRadius * constants.earthRadius - b * b) / (b * b);
	    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
	    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
	    var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
	    var distance = b * A * (sigma - deltaSigma);
	    return Math.round(distance / accuracy) * accuracy;
	  };

	  var _default = getDistance;
	  exports.default = _default;
	});

	var getRoughCompassDirection_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var getRoughCompassDirection = function getRoughCompassDirection(exact) {
	    if (/^NNE|NE|NNW|N$/.test(exact)) {
	      return "N";
	    }

	    if (/^ENE|E|ESE|SE$/.test(exact)) {
	      return "E";
	    }

	    if (/^SSE|S|SSW|SW$/.test(exact)) {
	      return "S";
	    }

	    if (/^WSW|W|WNW|NW$/.test(exact)) {
	      return "W";
	    }
	  };

	  var _default = getRoughCompassDirection;
	  exports.default = _default;
	});

	var getSpeed_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var getSpeed = function getSpeed(start, end) {
	    var distanceFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _getDistance.default;
	    var distance = distanceFn(start, end);
	    var time = Number(end.time) - Number(start.time);
	    var metersPerSecond = distance / time * 1000;
	    return metersPerSecond;
	  };

	  var _default = getSpeed;
	  exports.default = _default;
	});

	var isPointInLine_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isPointInLine = function isPointInLine(point, lineStart, lineEnd) {
	    return (0, _getDistance.default)(lineStart, point) + (0, _getDistance.default)(point, lineEnd) === (0, _getDistance.default)(lineStart, lineEnd);
	  };

	  var _default = isPointInLine;
	  exports.default = _default;
	});

	var isPointInPolygon_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isPointInPolygon = function isPointInPolygon(point, polygon) {
	    var isInside = false;
	    var totalPolys = polygon.length;

	    for (var i = -1, j = totalPolys - 1; ++i < totalPolys; j = i) {
	      if (((0, _getLongitude.default)(polygon[i]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[j]) || (0, _getLongitude.default)(polygon[j]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[i])) && (0, _getLatitude.default)(point) < ((0, _getLatitude.default)(polygon[j]) - (0, _getLatitude.default)(polygon[i])) * ((0, _getLongitude.default)(point) - (0, _getLongitude.default)(polygon[i])) / ((0, _getLongitude.default)(polygon[j]) - (0, _getLongitude.default)(polygon[i])) + (0, _getLatitude.default)(polygon[i])) {
	        isInside = !isInside;
	      }
	    }

	    return isInside;
	  };

	  var _default = isPointInPolygon;
	  exports.default = _default;
	});

	var isPointNearLine_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistanceFromLine = _interopRequireDefault(getDistanceFromLine_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isPointNearLine = function isPointNearLine(point, start, end, distance) {
	    return (0, _getDistanceFromLine.default)(point, start, end) < distance;
	  };

	  var _default = isPointNearLine;
	  exports.default = _default;
	});

	var isPointWithinRadius_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var isPointWithinRadius = function isPointWithinRadius(point, center, radius) {
	    return (0, _getDistance.default)(point, center) < radius;
	  };

	  var _default = isPointWithinRadius;
	  exports.default = _default;
	});

	var wktToPolygon_1 = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.default = void 0;

	  function _slicedToArray(arr, i) {
	    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	  }

	  function _nonIterableRest() {
	    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  function _unsupportedIterableToArray(o, minLen) {
	    if (!o) return;
	    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	    var n = Object.prototype.toString.call(o).slice(8, -1);
	    if (n === "Object" && o.constructor) n = o.constructor.name;
	    if (n === "Map" || n === "Set") return Array.from(o);
	    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	  }

	  function _arrayLikeToArray(arr, len) {
	    if (len == null || len > arr.length) len = arr.length;

	    for (var i = 0, arr2 = new Array(len); i < len; i++) {
	      arr2[i] = arr[i];
	    }

	    return arr2;
	  }

	  function _iterableToArrayLimit(arr, i) {
	    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"] != null) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  function _arrayWithHoles(arr) {
	    if (Array.isArray(arr)) return arr;
	  }

	  var wktToPolygon = function wktToPolygon(wkt) {
	    if (!wkt.startsWith("POLYGON")) {
	      throw new Error("Invalid wkt.");
	    }

	    var coordsText = wkt.slice(wkt.indexOf("(") + 2, wkt.indexOf(")")).split(", ");
	    var polygon = coordsText.map(function (coordText) {
	      var _coordText$split = coordText.split(" "),
	          _coordText$split2 = _slicedToArray(_coordText$split, 2),
	          longitude = _coordText$split2[0],
	          latitude = _coordText$split2[1];

	      return {
	        longitude: parseFloat(longitude),
	        latitude: parseFloat(latitude)
	      };
	    });
	    return polygon;
	  };

	  var _default = wktToPolygon;
	  exports.default = _default;
	});

	var es = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var _exportNames = {
	    computeDestinationPoint: true,
	    convertArea: true,
	    convertDistance: true,
	    convertSpeed: true,
	    decimalToSexagesimal: true,
	    findNearest: true,
	    getAreaOfPolygon: true,
	    getBounds: true,
	    getBoundsOfDistance: true,
	    getCenter: true,
	    getCenterOfBounds: true,
	    getCompassDirection: true,
	    getCoordinateKey: true,
	    getCoordinateKeys: true,
	    getDistance: true,
	    getDistanceFromLine: true,
	    getGreatCircleBearing: true,
	    getLatitude: true,
	    getLongitude: true,
	    getPathLength: true,
	    getPreciseDistance: true,
	    getRhumbLineBearing: true,
	    getRoughCompassDirection: true,
	    getSpeed: true,
	    isDecimal: true,
	    isPointInLine: true,
	    isPointInPolygon: true,
	    isPointNearLine: true,
	    isPointWithinRadius: true,
	    isSexagesimal: true,
	    isValidCoordinate: true,
	    isValidLatitude: true,
	    isValidLongitude: true,
	    orderByDistance: true,
	    sexagesimalToDecimal: true,
	    toDecimal: true,
	    toRad: true,
	    toDeg: true,
	    wktToPolygon: true
	  };
	  Object.defineProperty(exports, "computeDestinationPoint", {
	    enumerable: true,
	    get: function get() {
	      return _computeDestinationPoint.default;
	    }
	  });
	  Object.defineProperty(exports, "convertArea", {
	    enumerable: true,
	    get: function get() {
	      return _convertArea.default;
	    }
	  });
	  Object.defineProperty(exports, "convertDistance", {
	    enumerable: true,
	    get: function get() {
	      return _convertDistance.default;
	    }
	  });
	  Object.defineProperty(exports, "convertSpeed", {
	    enumerable: true,
	    get: function get() {
	      return _convertSpeed.default;
	    }
	  });
	  Object.defineProperty(exports, "decimalToSexagesimal", {
	    enumerable: true,
	    get: function get() {
	      return _decimalToSexagesimal.default;
	    }
	  });
	  Object.defineProperty(exports, "findNearest", {
	    enumerable: true,
	    get: function get() {
	      return _findNearest.default;
	    }
	  });
	  Object.defineProperty(exports, "getAreaOfPolygon", {
	    enumerable: true,
	    get: function get() {
	      return _getAreaOfPolygon.default;
	    }
	  });
	  Object.defineProperty(exports, "getBounds", {
	    enumerable: true,
	    get: function get() {
	      return _getBounds.default;
	    }
	  });
	  Object.defineProperty(exports, "getBoundsOfDistance", {
	    enumerable: true,
	    get: function get() {
	      return _getBoundsOfDistance.default;
	    }
	  });
	  Object.defineProperty(exports, "getCenter", {
	    enumerable: true,
	    get: function get() {
	      return _getCenter.default;
	    }
	  });
	  Object.defineProperty(exports, "getCenterOfBounds", {
	    enumerable: true,
	    get: function get() {
	      return _getCenterOfBounds.default;
	    }
	  });
	  Object.defineProperty(exports, "getCompassDirection", {
	    enumerable: true,
	    get: function get() {
	      return _getCompassDirection.default;
	    }
	  });
	  Object.defineProperty(exports, "getCoordinateKey", {
	    enumerable: true,
	    get: function get() {
	      return _getCoordinateKey.default;
	    }
	  });
	  Object.defineProperty(exports, "getCoordinateKeys", {
	    enumerable: true,
	    get: function get() {
	      return _getCoordinateKeys.default;
	    }
	  });
	  Object.defineProperty(exports, "getDistance", {
	    enumerable: true,
	    get: function get() {
	      return _getDistance.default;
	    }
	  });
	  Object.defineProperty(exports, "getDistanceFromLine", {
	    enumerable: true,
	    get: function get() {
	      return _getDistanceFromLine.default;
	    }
	  });
	  Object.defineProperty(exports, "getGreatCircleBearing", {
	    enumerable: true,
	    get: function get() {
	      return _getGreatCircleBearing.default;
	    }
	  });
	  Object.defineProperty(exports, "getLatitude", {
	    enumerable: true,
	    get: function get() {
	      return _getLatitude.default;
	    }
	  });
	  Object.defineProperty(exports, "getLongitude", {
	    enumerable: true,
	    get: function get() {
	      return _getLongitude.default;
	    }
	  });
	  Object.defineProperty(exports, "getPathLength", {
	    enumerable: true,
	    get: function get() {
	      return _getPathLength.default;
	    }
	  });
	  Object.defineProperty(exports, "getPreciseDistance", {
	    enumerable: true,
	    get: function get() {
	      return _getPreciseDistance.default;
	    }
	  });
	  Object.defineProperty(exports, "getRhumbLineBearing", {
	    enumerable: true,
	    get: function get() {
	      return _getRhumbLineBearing.default;
	    }
	  });
	  Object.defineProperty(exports, "getRoughCompassDirection", {
	    enumerable: true,
	    get: function get() {
	      return _getRoughCompassDirection.default;
	    }
	  });
	  Object.defineProperty(exports, "getSpeed", {
	    enumerable: true,
	    get: function get() {
	      return _getSpeed.default;
	    }
	  });
	  Object.defineProperty(exports, "isDecimal", {
	    enumerable: true,
	    get: function get() {
	      return _isDecimal.default;
	    }
	  });
	  Object.defineProperty(exports, "isPointInLine", {
	    enumerable: true,
	    get: function get() {
	      return _isPointInLine.default;
	    }
	  });
	  Object.defineProperty(exports, "isPointInPolygon", {
	    enumerable: true,
	    get: function get() {
	      return _isPointInPolygon.default;
	    }
	  });
	  Object.defineProperty(exports, "isPointNearLine", {
	    enumerable: true,
	    get: function get() {
	      return _isPointNearLine.default;
	    }
	  });
	  Object.defineProperty(exports, "isPointWithinRadius", {
	    enumerable: true,
	    get: function get() {
	      return _isPointWithinRadius.default;
	    }
	  });
	  Object.defineProperty(exports, "isSexagesimal", {
	    enumerable: true,
	    get: function get() {
	      return _isSexagesimal.default;
	    }
	  });
	  Object.defineProperty(exports, "isValidCoordinate", {
	    enumerable: true,
	    get: function get() {
	      return _isValidCoordinate.default;
	    }
	  });
	  Object.defineProperty(exports, "isValidLatitude", {
	    enumerable: true,
	    get: function get() {
	      return _isValidLatitude.default;
	    }
	  });
	  Object.defineProperty(exports, "isValidLongitude", {
	    enumerable: true,
	    get: function get() {
	      return _isValidLongitude.default;
	    }
	  });
	  Object.defineProperty(exports, "orderByDistance", {
	    enumerable: true,
	    get: function get() {
	      return _orderByDistance.default;
	    }
	  });
	  Object.defineProperty(exports, "sexagesimalToDecimal", {
	    enumerable: true,
	    get: function get() {
	      return _sexagesimalToDecimal.default;
	    }
	  });
	  Object.defineProperty(exports, "toDecimal", {
	    enumerable: true,
	    get: function get() {
	      return _toDecimal.default;
	    }
	  });
	  Object.defineProperty(exports, "toRad", {
	    enumerable: true,
	    get: function get() {
	      return _toRad.default;
	    }
	  });
	  Object.defineProperty(exports, "toDeg", {
	    enumerable: true,
	    get: function get() {
	      return _toDeg.default;
	    }
	  });
	  Object.defineProperty(exports, "wktToPolygon", {
	    enumerable: true,
	    get: function get() {
	      return _wktToPolygon.default;
	    }
	  });

	  var _computeDestinationPoint = _interopRequireDefault(computeDestinationPoint_1);

	  var _convertArea = _interopRequireDefault(convertArea_1);

	  var _convertDistance = _interopRequireDefault(convertDistance_1);

	  var _convertSpeed = _interopRequireDefault(convertSpeed_1);

	  var _decimalToSexagesimal = _interopRequireDefault(decimalToSexagesimal);

	  var _findNearest = _interopRequireDefault(findNearest_1);

	  var _getAreaOfPolygon = _interopRequireDefault(getAreaOfPolygon_1);

	  var _getBounds = _interopRequireDefault(getBounds_1);

	  var _getBoundsOfDistance = _interopRequireDefault(getBoundsOfDistance_1);

	  var _getCenter = _interopRequireDefault(getCenter_1);

	  var _getCenterOfBounds = _interopRequireDefault(getCenterOfBounds_1);

	  var _getCompassDirection = _interopRequireDefault(getCompassDirection_1);

	  var _getCoordinateKey = _interopRequireDefault(getCoordinateKey_1);

	  var _getCoordinateKeys = _interopRequireDefault(getCoordinateKeys_1);

	  var _getDistance = _interopRequireDefault(getDistance_1);

	  var _getDistanceFromLine = _interopRequireDefault(getDistanceFromLine_1);

	  var _getGreatCircleBearing = _interopRequireDefault(getGreatCircleBearing_1);

	  var _getLatitude = _interopRequireDefault(getLatitude_1);

	  var _getLongitude = _interopRequireDefault(getLongitude_1);

	  var _getPathLength = _interopRequireDefault(getPathLength_1);

	  var _getPreciseDistance = _interopRequireDefault(getPreciseDistance);

	  var _getRhumbLineBearing = _interopRequireDefault(getRhumbLineBearing_1);

	  var _getRoughCompassDirection = _interopRequireDefault(getRoughCompassDirection_1);

	  var _getSpeed = _interopRequireDefault(getSpeed_1);

	  var _isDecimal = _interopRequireDefault(isDecimal_1);

	  var _isPointInLine = _interopRequireDefault(isPointInLine_1);

	  var _isPointInPolygon = _interopRequireDefault(isPointInPolygon_1);

	  var _isPointNearLine = _interopRequireDefault(isPointNearLine_1);

	  var _isPointWithinRadius = _interopRequireDefault(isPointWithinRadius_1);

	  var _isSexagesimal = _interopRequireDefault(isSexagesimal_1);

	  var _isValidCoordinate = _interopRequireDefault(isValidCoordinate_1);

	  var _isValidLatitude = _interopRequireDefault(isValidLatitude_1);

	  var _isValidLongitude = _interopRequireDefault(isValidLongitude_1);

	  var _orderByDistance = _interopRequireDefault(orderByDistance_1);

	  var _sexagesimalToDecimal = _interopRequireDefault(sexagesimalToDecimal_1);

	  var _toDecimal = _interopRequireDefault(toDecimal_1);

	  var _toRad = _interopRequireDefault(toRad_1);

	  var _toDeg = _interopRequireDefault(toDeg_1);

	  var _wktToPolygon = _interopRequireDefault(wktToPolygon_1);

	  Object.keys(constants).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	    Object.defineProperty(exports, key, {
	      enumerable: true,
	      get: function get() {
	        return constants[key];
	      }
	    });
	  });

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }
	});

	class Leg extends Guidable {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "segment", void 0);

	    _defineProperty(this, "metadata", void 0);

	    _defineProperty(this, "constrainedTurnDirection", void 0);

	    _defineProperty(this, "isNull", false);

	    _defineProperty(this, "displayedOnMap", true);

	    _defineProperty(this, "predictedTas", void 0);

	    _defineProperty(this, "predictedGs", void 0);
	  }

	  get disableAutomaticSequencing() {
	    return false;
	  }
	  /** @inheritDoc */


	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {// Default impl.
	  }

	  get distance() {
	    try {
	      return distanceTo(this.getPathStartPoint(), this.getPathEndPoint());
	    } catch (_unused) {
	      return 0;
	    }
	  }

	  get overflyTermFix() {
	    return false;
	  }

	  get initialLegTermPoint() {
	    return this.getPathEndPoint();
	  }

	}

	const tan$3 = input => Math.tan(input * (Math.PI / 180));

	class DmeArcTransition extends Transition {
	  constructor(previousLeg, nextLeg) {
	    super(previousLeg, nextLeg);
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "predictedPath", []);

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "itp", void 0);

	    _defineProperty(this, "centre", void 0);

	    _defineProperty(this, "ftp", void 0);

	    _defineProperty(this, "sweepAngle", void 0);

	    _defineProperty(this, "clockwise", void 0);
	  }

	  getPathStartPoint() {
	    return this.itp;
	  }

	  getPathEndPoint() {
	    return this.ftp;
	  }

	  recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
	    if (this.isFrozen) {
	      return;
	    }

	    this.radius = gs ** 2 / (9.81 * tan$3(maxBank(tas, true))) / 6080.2;

	    if (this.previousLeg instanceof AFLeg) {
	      const turnDirection = Math.sign(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
	      const nextLegReference = this.nextLeg.getPathStartPoint(); // FIXME FX legs

	      const reference = placeBearingDistance(nextLegReference, this.nextLeg.inboundCourse + 90 * turnDirection, this.radius);
	      const dme = this.previousLeg.centre;
	      const turnCentre = closestSmallCircleIntersection(dme, this.previousLeg.radius + this.radius * turnDirection * -this.previousLeg.turnDirectionSign, reference, this.nextLeg.inboundCourse - 180);

	      if (!turnCentre) {
	        throw new Error('AFLeg did not intersect with previous leg offset reference');
	      }

	      this.centre = turnCentre;
	      this.itp = placeBearingDistance(turnCentre, turnDirection * -this.previousLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
	      this.ftp = placeBearingDistance(turnCentre, this.nextLeg.inboundCourse - 90 * turnDirection, this.radius);
	      this.sweepAngle = MathUtils.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
	      this.clockwise = this.sweepAngle > 0;
	      this.predictedPath.length = 0;
	      this.predictedPath.push({
	        type: PathVectorType.Arc,
	        startPoint: this.itp,
	        centrePoint: turnCentre,
	        endPoint: this.ftp,
	        sweepAngle: this.sweepAngle
	      });
	      this.isComputed = true;
	    } else if (this.nextLeg instanceof AFLeg) {
	      const turnDirection = Math.sign(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
	      const reference = placeBearingDistance(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse + 90 * turnDirection, this.radius);
	      const dme = this.nextLeg.centre;
	      let turnCentre;

	      if (this.previousLeg instanceof XFLeg && !(this.previousLeg instanceof AFLeg)) {
	        const intersection = closestSmallCircleIntersection(dme, this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign, reference, this.previousLeg.outboundCourse);

	        if (intersection) {
	          turnCentre = intersection;
	          this.itp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse - 90 * turnDirection, this.radius);
	          this.ftp = placeBearingDistance(turnCentre, turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
	        } else {
	          this.ftp = placeBearingDistance(dme, this.nextLeg.boundaryRadial, this.nextLeg.radius);
	          const turnSign = turnDirection > 0 ? 1 : -1;
	          turnCentre = placeBearingDistance(this.ftp, Avionics.Utils.clampAngle(this.nextLeg.boundaryRadial + (turnSign > 0 ? 180 : 0)), this.radius);
	          this.itp = placeBearingDistance(turnCentre, Avionics.Utils.clampAngle(this.previousLeg.outboundCourse - turnSign * 90), this.radius);
	        }
	      } else {
	        turnCentre = closestSmallCircleIntersection(dme, this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign, reference, this.previousLeg.outboundCourse);

	        if (!turnCentre) {
	          throw new Error('AFLeg did not intersect with previous leg offset reference');
	        }

	        this.itp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse - 90 * turnDirection, this.radius);
	        this.ftp = placeBearingDistance(turnCentre, turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre), this.radius);
	      }

	      this.centre = turnCentre;
	      this.sweepAngle = MathUtils.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
	      this.clockwise = this.sweepAngle > 0;
	      this.predictedPath.length = 0;
	      this.predictedPath.push({
	        type: PathVectorType.Arc,
	        startPoint: this.itp,
	        centrePoint: turnCentre,
	        endPoint: this.ftp,
	        sweepAngle: this.sweepAngle
	      });
	      this.isComputed = true;
	    }
	  }

	  addDebugPoints() {
	    if (this.itp && this.centre && this.ftp) {
	      this.predictedPath.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.itp,
	        annotation: 'DME TRANS ITP'
	      }, {
	        type: PathVectorType.DebugPoint,
	        startPoint: this.centre,
	        annotation: 'DME TRANS C'
	      }, {
	        type: PathVectorType.DebugPoint,
	        startPoint: this.ftp,
	        annotation: 'DME TRANS FTP'
	      });
	    }
	  }

	  getTurningPoints() {
	    return [this.itp, this.ftp];
	  }

	  get distance() {
	    return pathVectorLength(this.predictedPath[0]); // FIXME HAX
	  }

	  get startsInCircularArc() {
	    return true;
	  }

	  get endsInCircularArc() {
	    return true;
	  }

	  getNominalRollAngle(gs) {
	    const gsMs = gs * (463 / 900);
	    return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
	  }

	  getGuidanceParameters(ppos, trueTrack) {
	    return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
	  }

	  getDistanceToGo(ppos) {
	    return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
	  }

	  isAbeam(ppos) {
	    const turningPoints = this.getTurningPoints();

	    if (!turningPoints) {
	      return false;
	    }

	    const [inbound, outbound] = turningPoints;
	    const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
	    const inHeadingAc = Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
	    const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
	    const outHeadingAc = Math.abs(MathUtils.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
	    return inHeadingAc <= 90 && outHeadingAc >= 90;
	  }

	  get repr() {
	    return "DME(".concat(this.previousLeg.repr, ", ").concat(this.nextLeg.repr, ")");
	  }

	}

	// Copyright (c) 2021-2022 FlyByWire Simulations
	class XFLeg extends Leg {
	  constructor(fix) {
	    super();
	    this.fix = fix;
	  }

	  getPathEndPoint() {
	    if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
	      return this.outboundGuidable.getPathStartPoint();
	    }

	    if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
	      return this.outboundGuidable.getPathStartPoint();
	    }

	    return this.fix.infos.coordinates;
	  }

	  get terminationWaypoint() {
	    return this.fix;
	  }

	  get ident() {
	    return this.fix.ident;
	  }

	  get overflyTermFix() {
	    return this.metadata.isOverfly;
	  }
	  /**
	   * Returns `true` if the inbound transition has overshot the leg
	   */


	  get overshot() {
	    const side = sideOfPointOnCourseToFix(this.fix.infos.coordinates, this.outboundCourse, this.getPathStartPoint());
	    return side === PointSide.After;
	  }

	  get distanceToTermination() {
	    const startPoint = this.getPathStartPoint();

	    if (this.overshot) {
	      return 0;
	    }

	    return distanceTo(startPoint, this.fix.infos.coordinates);
	  }

	}

	class AFLeg extends XFLeg {
	  constructor(fix, navaid, rho, theta, boundaryRadial, metadata, segment) {
	    super(fix);
	    this.navaid = navaid;
	    this.rho = rho;
	    this.theta = theta;
	    this.boundaryRadial = boundaryRadial;
	    this.metadata = metadata;

	    _defineProperty(this, "predictedPath", []);

	    _defineProperty(this, "centre", void 0);

	    _defineProperty(this, "terminationRadial", void 0);

	    _defineProperty(this, "bearing", void 0);

	    _defineProperty(this, "arcStartPoint", void 0);

	    _defineProperty(this, "arcEndPoint", void 0);

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "sweepAngle", void 0);

	    _defineProperty(this, "clockwise", void 0);

	    _defineProperty(this, "inboundCourse", void 0);

	    _defineProperty(this, "outboundCourse", void 0);

	    this.segment = segment;
	    this.centre = navaid;
	    this.radius = distanceTo(navaid, this.fix.infos.coordinates);
	    this.terminationRadial = this.theta;
	    this.bearing = Avionics.Utils.clampAngle(bearingTo(this.centre, this.fix.infos.coordinates) + 90 * this.turnDirectionSign);
	    this.arcStartPoint = placeBearingDistance(this.centre, this.boundaryRadial, this.radius);
	    this.arcEndPoint = placeBearingDistance(this.centre, this.terminationRadial, this.radius);
	    this.inboundCourse = this.boundaryRadial + 90 * this.turnDirectionSign;
	    this.outboundCourse = this.terminationRadial + 90 * this.turnDirectionSign;
	  }

	  getPathStartPoint() {
	    return this.inboundGuidable instanceof DmeArcTransition ? this.inboundGuidable.getPathEndPoint() : this.arcStartPoint;
	  }

	  getPathEndPoint() {
	    if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
	      return this.outboundGuidable.getPathStartPoint();
	    }

	    return this.arcEndPoint;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    this.sweepAngle = MathUtils.diffAngle(bearingTo(this.centre, this.getPathStartPoint()), bearingTo(this.centre, this.getPathEndPoint()));
	    this.clockwise = this.sweepAngle > 0; // We do not consider the path capture end point in this class' getPathEndPoint since that causes a race condition with the path capture
	    // finding its intercept point onto this leg

	    const startPoint = this.inboundGuidable instanceof PathCaptureTransition ? this.inboundGuidable.getPathEndPoint() : this.getPathStartPoint();
	    this.predictedPath.length = 0;
	    this.predictedPath.push({
	      type: PathVectorType.Arc,
	      startPoint,
	      centrePoint: this.centre,
	      endPoint: this.getPathEndPoint(),
	      sweepAngle: this.sweepAngle
	    });
	  }

	  get turnDirectionSign() {
	    if (this.fix.turnDirection !== TurnDirection.Right && this.fix.turnDirection !== TurnDirection.Left) {
	      throw new Error('AFLeg found without specific turnDirection');
	    }

	    return this.fix.turnDirection === TurnDirection.Left ? -1 : 1;
	  }

	  get startsInCircularArc() {
	    return true;
	  }

	  get endsInCircularArc() {
	    return true;
	  }

	  getNominalRollAngle(gs) {
	    const gsMs = gs * (463 / 900);
	    return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
	  }

	  getGuidanceParameters(ppos, trueTrack) {
	    return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
	  }

	  getDistanceToGo(ppos) {
	    return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
	  }

	  isAbeam(ppos) {
	    const bearingPpos = Avionics.Utils.computeGreatCircleHeading(this.centre, ppos);
	    const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.centre, this.getPathStartPoint());
	    const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
	    return trackAngleError >= 0;
	  }

	  get repr() {
	    return "AF(".concat(this.radius.toFixed(1), "NM) TO ").concat(this.fix.ident);
	  }

	}

	class TFLeg extends XFLeg {
	  constructor(from, to, metadata, segment) {
	    super(to);
	    this.metadata = metadata;

	    _defineProperty(this, "from", void 0);

	    _defineProperty(this, "to", void 0);

	    _defineProperty(this, "constraintType", void 0);

	    _defineProperty(this, "course", void 0);

	    _defineProperty(this, "computedPath", []);

	    this.from = from;
	    this.to = to;
	    this.segment = segment;
	    this.constraintType = to.constraintType;
	    this.course = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, this.to.infos.coordinates);
	  }

	  get inboundCourse() {
	    return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
	  }

	  get outboundCourse() {
	    return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  getPathStartPoint() {
	    var _this$inboundGuidable;

	    return (_this$inboundGuidable = this.inboundGuidable) !== null && _this$inboundGuidable !== void 0 && _this$inboundGuidable.isComputed ? this.inboundGuidable.getPathEndPoint() : this.from.infos.coordinates;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    const startPoint = this.getPathStartPoint();
	    const endPoint = this.getPathEndPoint();
	    this.computedPath.length = 0;

	    if (this.overshot) {
	      this.computedPath.push({
	        type: PathVectorType.Line,
	        startPoint: endPoint,
	        endPoint
	      });
	    } else {
	      this.computedPath.push({
	        type: PathVectorType.Line,
	        startPoint,
	        endPoint
	      });
	    }

	    this.isComputed = true;
	  }

	  getPseudoWaypointLocation(distanceBeforeTerminator) {
	    return getIntermediatePoint(this.getPathStartPoint(), this.getPathEndPoint(), (this.distance - distanceBeforeTerminator) / this.distance);
	  }

	  getGuidanceParameters(ppos, trueTrack) {
	    return fixToFixGuidance(ppos, trueTrack, this.from.infos.coordinates, this.to.infos.coordinates);
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }
	  /**
	   * Calculates the angle between the leg and the aircraft PPOS.
	   *
	   * This effectively returns the angle ABC in the figure shown below:
	   *
	   * ```
	   * * A
	   * |
	   * * B (TO)
	   * |\
	   * | \
	   * |  \
	   * |   \
	   * |    \
	   * |     \
	   * |      \
	   * * FROM  * C (PPOS)
	   * ```
	   *
	   * @param ppos {LatLong} the current position of the aircraft
	   */


	  getAircraftToLegBearing(ppos) {
	    const aircraftToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(ppos, this.to.infos.coordinates);
	    const aircraftLegBearing = MathUtils.smallCrossingAngle(this.outboundCourse, aircraftToTerminationBearing);
	    return aircraftLegBearing;
	  }

	  getDistanceToGo(ppos) {
	    return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	  }

	  isAbeam(ppos) {
	    const bearingAC = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, ppos);
	    const headingAC = Math.abs(MathUtils.diffAngle(this.inboundCourse, bearingAC));

	    if (headingAC > 90) {
	      // if we're even not abeam of the starting point
	      return false;
	    }

	    const distanceAC = Avionics.Utils.computeDistance(this.from.infos.coordinates, ppos);
	    const distanceAX = Math.cos(headingAC * Avionics.Utils.DEG2RAD) * distanceAC; // if we're too far away from the starting point to be still abeam of the ending point

	    return distanceAX <= this.distance;
	  }

	  get repr() {
	    return "TF FROM ".concat(this.from.ident, " TO ").concat(this.to.ident);
	  }

	}

	function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	const sin = input => Math.sin(input * (Math.PI / 180));

	const asin = input => Math.asin(input) * (180 / Math.PI);

	class Geo {
	  static computeDestinationPoint(start, distance, bearing) {
	    let radius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6371000;
	    // FIXME rm -f geolib ?
	    const a = es.computeDestinationPoint(_objectSpread$3(_objectSpread$3({}, start), {}, {
	      lon: start.long
	    }), distance * 1852, bearing, radius);
	    return {
	      lat: a.latitude,
	      long: a.longitude
	    };
	  }

	  static distanceToLeg(from, leg) {
	    const intersections1 = placeBearingIntersection(from, Avionics.Utils.clampAngle(leg.outboundCourse - 90), leg.initialLegTermPoint, Avionics.Utils.clampAngle(leg.outboundCourse - 180));
	    const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[0]);
	    const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[1]);
	    let legStartReference;

	    if (leg instanceof TFLeg) {
	      legStartReference = leg.from.infos.coordinates;
	    } else {
	      legStartReference = leg.getPathStartPoint();
	    } // We might call this on legs that do not have a defined start point yet, as it depends on their inbound transition, which is what is passing
	    // them in to this function.
	    // In that case, do not consider the second intersection set.


	    if (!legStartReference) {
	      return Math.min(d1, d2);
	    }

	    const intersections2 = placeBearingIntersection(from, Avionics.Utils.clampAngle(leg.outboundCourse - 90), legStartReference, Avionics.Utils.clampAngle(leg.outboundCourse - 180));
	    const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
	    const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
	    return Math.min(d1, d2, d3, d4);
	  }

	  static legIntercept(from, bearing, leg) {
	    if (leg instanceof AFLeg) {
	      const intersections = smallCircleGreatCircleIntersection(leg.centre, leg.radius, from, bearing);
	      const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections[0]);
	      const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections[1]);
	      return d1 > d2 ? intersections[1] : intersections[0];
	    }

	    if (leg.getPathEndPoint() === undefined || leg.outboundCourse === undefined) {
	      throw new Error('[FMS/LNAV] Cannot compute leg intercept if leg end point or outbound course are undefined');
	    }

	    const intersections1 = placeBearingIntersection(from, Avionics.Utils.clampAngle(bearing), 'fix' in leg ? leg.fix.infos.coordinates : leg.getPathEndPoint(), Avionics.Utils.clampAngle(leg.outboundCourse - 180));
	    const d1 = distanceTo(from, intersections1[0]);
	    const d2 = distanceTo(from, intersections1[1]); // We might call this on legs that do not have a defined start point yet, as it depends on their inbound transition, which is what is passing
	    // them in to this function.
	    // In that case, do not consider the second intersection set.

	    if (!leg.getPathStartPoint()) {
	      return d1 > d2 ? intersections1[1] : intersections1[0];
	    }

	    const intersections2 = placeBearingIntersection(from, Avionics.Utils.clampAngle(bearing), leg.getPathStartPoint(), Avionics.Utils.clampAngle(leg.outboundCourse - 180));
	    const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
	    const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
	    const smallest = Math.min(d1, d2, d3, d4);

	    if (smallest === d1) {
	      return intersections1[0];
	    }

	    if (smallest === d2) {
	      return intersections1[1];
	    }

	    if (smallest === d3) {
	      return intersections2[0];
	    }

	    return intersections2[1];
	  }

	  static placeBearingPlaceDistanceIntercept(bearingPoint, distancePoint, bearing, distance) {
	    const relativeBearing = bearingTo(bearingPoint, distancePoint);
	    const distanceBetween = distanceTo(bearingPoint, distancePoint);
	    const angleA = Math.abs(MathUtils.diffAngle(relativeBearing, bearing));
	    const angleC = angleA > 90 ? asin(distanceBetween * (sin(angleA) / distance)) : 180 - asin(distanceBetween * (sin(angleA) / distance));
	    const angleB = 180 - angleA - angleC;
	    return placeBearingDistance(bearingPoint, bearing, Math.abs(sin(angleB) * (distance / sin(angleA))));
	  }

	  static doublePlaceBearingIntercept(pointA, pointB, bearingA, bearingB) {
	    return A32NX_Util.greatCircleIntersection(pointA, bearingA, pointB, bearingB);
	  }

	}

	// Copyright (c) 2021-2022 FlyByWire Simulations
	// Copyright (c) 2021-2022 Synaptic Simulations
	//
	// SPDX-License-Identifier: GPL-3.0

	/**
	 * Functions for figuring out an appropriate course change for leg captures
	 */
	class CourseChange {
	  static normal(turnDirection, turnCenterDistance, trackChange, radius) {
	    if (turnDirection > 0) {
	      if (turnCenterDistance >= radius) {
	        return trackChange - 45;
	      }

	      return trackChange + 45;
	    }

	    if (-turnCenterDistance >= radius) {
	      return trackChange + 45;
	    }

	    return trackChange - 45;
	  }

	  static reverse(turnDirection, turnCenterDistance, trackChange, radius) {
	    if (trackChange > 0) {
	      if (turnCenterDistance > 0) {
	        if (turnCenterDistance > radius) {
	          return trackChange - 45;
	        }

	        return trackChange + 45;
	      }

	      return trackChange + 45;
	    }

	    if (turnCenterDistance > 0) {
	      return trackChange - 45;
	    }

	    if (-turnCenterDistance > radius) {
	      return trackChange + 45;
	    }

	    return trackChange - 45;
	  }

	  static acuteFar(turnDirection, turnCenterDistance, trackChange) {
	    return turnDirection * (45 - Math.abs(trackChange));
	  }

	  static acuteNear(turnDirection, turnCenterDistance, trackChange) {
	    return trackChange + (turnDirection > 0 ? 45 : -45);
	  }

	}

	// Copyright (c) 2021-2022 FlyByWire Simulations
	class IFLeg extends XFLeg {
	  constructor(fix, metadata, segment) {
	    super(fix);
	    this.metadata = metadata;
	    this.segment = segment;
	  }

	  get predictedPath() {
	    return [];
	  }

	  getPathStartPoint() {
	    return this.fix.infos.coordinates;
	  }

	  getPathEndPoint() {
	    return this.fix.infos.coordinates;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    this.isComputed = true;
	  }
	  /** @inheritdoc */


	  setNeighboringGuidables(inbound, outbound) {
	    if (outbound && !(outbound instanceof Leg) && outbound !== this.outboundGuidable) {
	      console.error("IF outboundGuidable must be a leg (is ".concat(outbound === null || outbound === void 0 ? void 0 : outbound.constructor, ")"));
	    }

	    super.setNeighboringGuidables(inbound, outbound);
	  }

	  get inboundCourse() {
	    return undefined;
	  }

	  get outboundCourse() {
	    return undefined;
	  }

	  get distance() {
	    return 0;
	  }

	  getDistanceToGo(_ppos) {
	    return undefined;
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    var _this$outboundGuidabl, _this$outboundGuidabl2;

	    return (_this$outboundGuidabl = (_this$outboundGuidabl2 = this.outboundGuidable) === null || _this$outboundGuidabl2 === void 0 ? void 0 : _this$outboundGuidabl2.getGuidanceParameters(ppos, trueTrack, tas, gs)) !== null && _this$outboundGuidabl !== void 0 ? _this$outboundGuidabl : undefined;
	  }

	  getNominalRollAngle(_gs) {
	    return undefined;
	  }

	  getPseudoWaypointLocation(_distanceBeforeTerminator) {
	    return undefined;
	  }

	  isAbeam(_ppos) {
	    return false;
	  }

	  get repr() {
	    return "IF AT ".concat(this.fix.ident);
	  }

	}

	class CFLeg extends XFLeg {
	  constructor(fix, course, metadata, segment) {
	    super(fix);
	    this.course = course;
	    this.metadata = metadata;

	    _defineProperty(this, "computedPath", []);

	    this.segment = segment;
	  }

	  getPathStartPoint() {
	    if (this.inboundGuidable instanceof IFLeg) {
	      return this.inboundGuidable.fix.infos.coordinates;
	    }

	    if (this.inboundGuidable instanceof Transition && this.inboundGuidable.isComputed) {
	      return this.inboundGuidable.getPathEndPoint();
	    }

	    if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
	      return this.outboundGuidable.getPathStartPoint();
	    } // Estimate where we should start the leg


	    return this.estimateStartWithoutInboundTransition();
	  }
	  /**
	   * Based on FBW-22-07
	   *
	   * @private
	   */


	  estimateStartWithoutInboundTransition() {
	    const inverseCourse = Avionics.Utils.clampAngle(this.course + 180);

	    if (this.inboundGuidable && this.inboundGuidable.isComputed) {
	      const prevLegTerm = this.inboundGuidable.getPathEndPoint();
	      return Geo.doublePlaceBearingIntercept(this.getPathEndPoint(), prevLegTerm, inverseCourse, Avionics.Utils.clampAngle(inverseCourse + 90));
	    } // We start the leg at (tad + 0.1) from the fix if we have a fixed radius transition outbound. This allows showing a better looking path after sequencing.


	    let distance = 1;

	    if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
	      distance = this.outboundGuidable.tad + 0.1;
	    }

	    return Avionics.Utils.bearingDistanceToCoordinates(inverseCourse, distance, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    // Is start point after the fix ?
	    if (this.overshot) {
	      this.computedPath = [{
	        type: PathVectorType.Line,
	        startPoint: this.getPathEndPoint(),
	        endPoint: this.getPathEndPoint()
	      }];
	    } else {
	      this.computedPath = [{
	        type: PathVectorType.Line,
	        startPoint: this.getPathStartPoint(),
	        endPoint: this.getPathEndPoint()
	      }];
	    }

	    this.isComputed = true;
	  }

	  get inboundCourse() {
	    return this.course;
	  }

	  get outboundCourse() {
	    return this.course;
	  }

	  getDistanceToGo(ppos) {
	    return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	  }

	  getGuidanceParameters(ppos, trueTrack, _tas) {
	    return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }

	  isAbeam(ppos) {
	    const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	    return dtg >= 0 && dtg <= this.distance;
	  }

	  get repr() {
	    return "CF(".concat(this.course.toFixed(1), "T) TO ").concat(this.fix.ident);
	  }

	}

	var PiState;

	(function (PiState) {
	  PiState[PiState["Straight"] = 0] = "Straight";
	  PiState[PiState["Turn1"] = 1] = "Turn1";
	  PiState[PiState["Outbound"] = 2] = "Outbound";
	  PiState[PiState["Turn2"] = 3] = "Turn2";
	  PiState[PiState["Intercept"] = 4] = "Intercept";
	})(PiState || (PiState = {}));

	class PILeg extends Leg {
	  constructor(fix, nextLeg, metadata, segment) {
	    super();
	    this.fix = fix;
	    this.nextLeg = nextLeg;
	    this.metadata = metadata;
	    this.segment = segment;

	    _defineProperty(this, "radius", 1);

	    _defineProperty(this, "straight", {});

	    _defineProperty(this, "turn1", {});

	    _defineProperty(this, "outbound", {});

	    _defineProperty(this, "turn2", {});

	    _defineProperty(this, "intercept", {});

	    _defineProperty(this, "state", PiState.Straight);

	    _defineProperty(this, "debugPoints", []);

	    this.recomputeWithParameters(false, 220, 220, {
	      lat: 0,
	      long: 0
	    }, 0);
	  }

	  recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
	    if (isActive) {
	      return;
	    }

	    if (this.nextLeg && !(this.nextLeg instanceof CFLeg)) {
	      throw new Error('PI must be followed by CF!');
	    } else if (!this.nextLeg) {
	      return;
	    }

	    this.debugPoints.length = 0;
	    const turn1Sign = this.fix.turnDirection === TurnDirection.Left ? 1 : -1;
	    const turn2Sign = -1 * turn1Sign;
	    const gsMs = gs / 1.94384;
	    this.radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(tas, true) * Math.PI / 180)) / 1852;
	    const minStraightDist = this.radius * 2;
	    const brgToCf = Avionics.Utils.computeGreatCircleHeading(this.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates);
	    const distToCf = Avionics.Utils.computeGreatCircleDistance(this.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates);
	    const cfInverseCrs = (this.nextLeg.course + 180) % 360;
	    this.outbound.course = this.fix.additionalData.course;
	    this.straight.itp = this.fix.infos.coordinates;
	    this.straight.course = cfInverseCrs;
	    let tp;

	    if (Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, brgToCf)) < 90 && distToCf > minStraightDist) {
	      tp = this.nextLeg.fix.infos.coordinates;
	    } else {
	      // find an intercept on the CF at min dist
	      [tp] = smallCircleGreatCircleIntersection(this.fix.infos.coordinates, minStraightDist, this.nextLeg.fix.infos.coordinates, cfInverseCrs).filter(p => Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, bearingTo(this.nextLeg.fix.infos.coordinates, p))) < 90);
	      this.straight.course = Avionics.Utils.computeGreatCircleHeading(this.fix.infos.coordinates, tp);
	    }

	    this.turn1.sweepAngle = turn1Sign * Math.abs(Avionics.Utils.diffAngle(this.straight.course, this.outbound.course));
	    const tpT1FtpDist = this.radius * Math.tan(Math.abs(this.turn1.sweepAngle) * Math.PI / 360);
	    this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outbound.course, tpT1FtpDist, tp.lat, tp.long);
	    this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn1Sign * 90) % 360, this.radius, this.turn1.ftp.lat, this.turn1.ftp.long);
	    this.turn1.itp = Avionics.Utils.bearingDistanceToCoordinates((this.straight.course + 180) % 360, this.radius * (1 - Math.cos(this.turn1.sweepAngle * Math.PI / 180)), tp.lat, tp.long);
	    this.turn1.length = Math.abs(this.turn1.sweepAngle / 180 * this.radius);
	    this.straight.ftp = this.turn1.itp;
	    this.straight.length = Avionics.Utils.computeGreatCircleDistance(this.fix.infos.coordinates, this.turn1.itp);

	    const theta = Math.abs(Avionics.Utils.diffAngle(this.outbound.course, (this.nextLeg.course + 180) % 360)) * Math.PI / 180;
	    this.outbound.length = this.radius * (1 / Math.tan(theta / 2));
	    this.outbound.itp = this.turn1.ftp;
	    this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outbound.course, this.outbound.length + tpT1FtpDist, tp.lat, tp.long);
	    this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn2Sign * 90) % 360, this.radius, this.turn2.itp.lat, this.turn2.itp.long);
	    this.turn2.sweepAngle = turn2Sign * 180;
	    this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates((360 + this.outbound.course + turn2Sign * 90) % 360, this.radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
	    this.turn2.length = Math.abs(this.turn2.sweepAngle / 180 * this.radius);
	    this.outbound.ftp = this.turn2.itp;

	    this.intercept.itp = this.turn2.ftp;
	    this.intercept.ftp = A32NX_Util.greatCircleIntersection(this.turn2.ftp, (this.outbound.course + 180) % 360, tp, cfInverseCrs);
	    this.intercept.length = Avionics.Utils.computeGreatCircleDistance(this.intercept.itp, this.intercept.ftp);
	    this.intercept.course = Avionics.Utils.computeGreatCircleHeading(this.intercept.itp, this.intercept.ftp);
	    this.isComputed = true;
	  }

	  get initialLegTermPoint() {
	    return this.turn1.itp;
	  }

	  get distanceToTermination() {
	    return this.straight.length;
	  }

	  get distance() {
	    return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + this.straight.length;
	  }
	  /**
	   * Do we end up further away from the fix than the coded limit
	   */


	  get turnAreaExceeded() {
	    if (!this.turn2) {
	      return false;
	    }

	    const maxExcursion = distanceTo(this.fix.infos.coordinates, this.turn2.arcCentre) + this.radius;
	    return maxExcursion > this.fix.additionalData.distance;
	  }

	  getDistanceToGo(ppos) {
	    switch (this.state) {
	      case PiState.Intercept:
	        return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);

	      case PiState.Turn2:
	        return this.intercept.length + arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);

	      case PiState.Outbound:
	        return this.intercept.length + this.turn2.length + courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);

	      case PiState.Turn1:
	        return this.intercept.length + this.turn2.length + this.outbound.length + arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);

	      case PiState.Straight:
	        return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);

	      default:
	        return 1;
	    }
	  }

	  dtgCurrentSegment(ppos) {
	    switch (this.state) {
	      case PiState.Intercept:
	        return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);

	      case PiState.Turn2:
	        return arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);

	      case PiState.Outbound:
	        return courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);

	      case PiState.Turn1:
	        return arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);

	      case PiState.Straight:
	        return courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);

	      default:
	        return 0;
	    }
	  }

	  radCurrentSegment(tas, gs) {
	    const turn1Sign = this.fix.turnDirection === TurnDirection.Left ? 1 : -1;
	    const turn2Sign = -1 * turn1Sign;
	    let currentBank;
	    let nextBank;

	    switch (this.state) {
	      case PiState.Turn1:
	        currentBank = turn1Sign * maxBank(tas, true);
	        nextBank = 0;
	        break;

	      case PiState.Turn2:
	        currentBank = turn2Sign * maxBank(tas, true);
	        nextBank = 0;
	        break;

	      case PiState.Straight:
	        currentBank = 0;
	        nextBank = turn1Sign * maxBank(tas, true);
	        break;

	      case PiState.Outbound:
	        currentBank = 0;
	        nextBank = turn2Sign * maxBank(tas, true);
	        break;

	      default:
	        return [0, 0];
	    }

	    return [Geometry.getRollAnticipationDistance(gs, currentBank, nextBank), nextBank];
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    var _this$nextLeg;

	    let dtg = this.dtgCurrentSegment(ppos);

	    if (dtg <= 0 && this.state < PiState.Intercept) {
	      this.state++;
	      dtg = this.dtgCurrentSegment(ppos);
	    }

	    let params;

	    switch (this.state) {
	      case PiState.Intercept:
	        return (_this$nextLeg = this.nextLeg) === null || _this$nextLeg === void 0 ? void 0 : _this$nextLeg.getGuidanceParameters(ppos, trueTrack, tas);

	      case PiState.Turn2:
	        return arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);

	      case PiState.Outbound:
	        params = courseToFixGuidance(ppos, trueTrack, this.outbound.course, this.outbound.ftp);
	        break;

	      case PiState.Turn1:
	        params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
	        break;

	      case PiState.Straight:
	        params = courseToFixGuidance(ppos, trueTrack, this.straight.course, this.straight.ftp);
	        break;
	    }

	    const [rad, nextBank] = this.radCurrentSegment(tas, gs);

	    if (params && rad > 0 && dtg <= rad) {
	      params.phiCommand = nextBank;
	    }

	    return params;
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }

	  getPathStartPoint() {
	    var _this$inboundGuidable;

	    return (_this$inboundGuidable = this.inboundGuidable) !== null && _this$inboundGuidable !== void 0 && _this$inboundGuidable.isComputed ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates;
	  }

	  getPathEndPoint() {
	    return this.intercept.ftp;
	  }

	  get terminationWaypoint() {
	    return this.intercept.ftp;
	  }

	  get inboundCourse() {
	    var _this$straight$course;

	    return (_this$straight$course = this.straight.course) !== null && _this$straight$course !== void 0 ? _this$straight$course : 0;
	  }

	  get outboundCourse() {
	    var _this$nextLeg$course, _this$nextLeg2;

	    return (_this$nextLeg$course = (_this$nextLeg2 = this.nextLeg) === null || _this$nextLeg2 === void 0 ? void 0 : _this$nextLeg2.course) !== null && _this$nextLeg$course !== void 0 ? _this$nextLeg$course : 0;
	  }

	  isAbeam(_ppos) {
	    return true; // TODO y needed
	  }

	  get predictedPath() {
	    var _this$inboundGuidable2;

	    return [{
	      type: PathVectorType.Line,
	      startPoint: (_this$inboundGuidable2 = this.inboundGuidable) !== null && _this$inboundGuidable2 !== void 0 && _this$inboundGuidable2.isComputed ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates,
	      endPoint: this.turn1.itp
	    }, {
	      type: PathVectorType.Arc,
	      startPoint: this.turn1.itp,
	      centrePoint: this.turn1.arcCentre,
	      endPoint: this.turn1.ftp,
	      sweepAngle: this.turn1.sweepAngle
	    }, {
	      type: PathVectorType.Line,
	      startPoint: this.turn1.ftp,
	      endPoint: this.turn2.itp
	    }, {
	      type: PathVectorType.Arc,
	      startPoint: this.turn2.itp,
	      centrePoint: this.turn2.arcCentre,
	      endPoint: this.turn2.ftp,
	      sweepAngle: this.turn2.sweepAngle
	    }, {
	      type: PathVectorType.Line,
	      startPoint: this.turn2.ftp,
	      endPoint: this.intercept.ftp
	    }, ...this.debugPoints];
	  }

	  get ident() {
	    return 'INTCPT';
	  }

	  get repr() {
	    return "PI ".concat(this.ident);
	  }

	}

	let AltitudeConstraintType; // TODO at and atOrAbove do not exist in the airbus (former interpreted as atOrBelow, latter discarded)

	(function (AltitudeConstraintType) {
	  AltitudeConstraintType[AltitudeConstraintType["at"] = 0] = "at";
	  AltitudeConstraintType[AltitudeConstraintType["atOrAbove"] = 1] = "atOrAbove";
	  AltitudeConstraintType[AltitudeConstraintType["atOrBelow"] = 2] = "atOrBelow";
	  AltitudeConstraintType[AltitudeConstraintType["range"] = 3] = "range";
	})(AltitudeConstraintType || (AltitudeConstraintType = {}));

	let SpeedConstraintType;

	(function (SpeedConstraintType) {
	  SpeedConstraintType[SpeedConstraintType["at"] = 0] = "at";
	  SpeedConstraintType[SpeedConstraintType["atOrAbove"] = 1] = "atOrAbove";
	  SpeedConstraintType[SpeedConstraintType["atOrBelow"] = 2] = "atOrBelow";
	})(SpeedConstraintType || (SpeedConstraintType = {}));
	function isHold(leg) {
	  return leg instanceof HALeg || leg instanceof HFLeg || leg instanceof HMLeg;
	}
	function isCourseReversalLeg(leg) {
	  return isHold(leg) || leg instanceof PILeg;
	}

	const cos = input => Math.cos(input * (Math.PI / 180));

	const tan$2 = input => Math.tan(input * MathUtils.DEGREES_TO_RADIANS);

	const compareTurnDirections = (sign, data) => {
	  if ((data === TurnDirection.Left || data === TurnDirection.Right) && (sign === -1 || sign === 1)) {
	    return data === TurnDirection.Left && sign === -1 || data === TurnDirection.Right && sign === 1;
	  }

	  return true;
	};
	/**
	 * A type II transition
	 */


	class PathCaptureTransition extends Transition {
	  constructor(previousLeg, nextLeg) {
	    super(previousLeg, nextLeg);
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "startWithTad", false);

	    _defineProperty(this, "predictedPath", []);

	    _defineProperty(this, "itp", void 0);

	    _defineProperty(this, "ftp", void 0);

	    _defineProperty(this, "tad", void 0);

	    _defineProperty(this, "forcedTurnComplete", false);

	    _defineProperty(this, "computedTurnDirection", TurnDirection.Either);

	    _defineProperty(this, "computedTargetTrack", 0);

	    _defineProperty(this, "distance", 0);
	  }

	  getPathStartPoint() {
	    return this.itp;
	  }

	  get turnDirection() {
	    return this.nextLeg.metadata.turnDirection;
	  }

	  get deltaTrack() {
	    return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
	  }

	  recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
	    if (this.isFrozen) {
	      return;
	    }

	    if (!(this.inboundGuidable instanceof Leg)) {
	      throw new Error('[FMS/Geometry/PathCapture] previousGuidable must be a leg');
	    }

	    const targetTrack = this.inboundGuidable.outboundCourse;
	    const naturalTurnDirectionSign = Math.sign(MathUtils.diffAngle(targetTrack, this.nextLeg.inboundCourse));
	    this.computedTurnDirection = TurnDirection.Either;
	    this.computedTargetTrack = this.nextLeg.inboundCourse;
	    let prevLegTermFix;

	    if (this.previousLeg instanceof AFLeg) {
	      prevLegTermFix = this.previousLeg.arcEndPoint;
	    } else {
	      prevLegTermFix = this.previousLeg.terminationWaypoint instanceof WayPoint ? this.previousLeg.terminationWaypoint.infos.coordinates : this.previousLeg.terminationWaypoint;
	    } // Start the transition before the termination fix if we are reverted because of an overshoot


	    let initialTurningPoint;

	    if (this.startWithTad) {
	      const prevLegDistanceToTerm = this.previousLeg.distanceToTermination;
	      this.tad = Math.min(maxTad(tas), prevLegDistanceToTerm - 0.05); // If we are inbound of a TF leg, we use getIntermediatePoint in order to get more accurate results

	      if ('from' in this.previousLeg) {
	        const start = this.previousLeg.from.infos.coordinates;
	        const end = this.previousLeg.to.infos.coordinates;
	        const length = distanceTo(start, end);
	        const ratio = (length - this.tad) / length;
	        initialTurningPoint = getIntermediatePoint(start, end, ratio);
	      } else {
	        initialTurningPoint = placeBearingDistance(prevLegTermFix, reciprocal(this.previousLeg.outboundCourse), this.tad);
	      }
	    } else {
	      this.tad = 0;
	      initialTurningPoint = prevLegTermFix;
	    }

	    const distanceFromItp = Geo.distanceToLeg(initialTurningPoint, this.nextLeg); // for some legs the turn direction is not for forced turn onto the leg

	    const desiredDirection = isCourseReversalLeg(this.nextLeg) ? TurnDirection.Either : this.nextLeg.metadata.turnDirection;
	    const deltaTrack = MathUtils.diffAngle(targetTrack, this.nextLeg.inboundCourse, desiredDirection);
	    this.predictedPath.length = 0;

	    if (Math.abs(deltaTrack) < 3 && distanceFromItp < 0.1) {
	      this.itp = this.previousLeg.getPathEndPoint();
	      this.ftp = this.previousLeg.getPathEndPoint();
	      this.predictedPath.push({
	        type: PathVectorType.Line,
	        startPoint: this.previousLeg.getPathEndPoint(),
	        endPoint: this.previousLeg.getPathEndPoint()
	      });
	      this.isNull = true;
	      this.distance = 0;
	      this.isComputed = true;
	      return;
	    }

	    this.isNull = false; // If track change is very similar to a 45 degree intercept, we do a direct intercept

	    if (Math.abs(deltaTrack) > 42 && Math.abs(deltaTrack) < 48 && distanceFromItp > 0.01) {
	      this.computeDirectIntercept();
	      this.isComputed = true;
	      return;
	    }

	    let turnDirection = Math.sign(deltaTrack); // Theta variable should be stored based on turn direction and max roll, but it is only used once in an absolute sense, so it is useless

	    const radius = gs ** 2 / (Constants.G * tan$2(maxBank(tas, true)) * 6997.84) * LnavConfig.TURN_RADIUS_FACTOR;
	    const distanceLimit = radius * cos(48); // TODO: Turn center is slightly off for some reason, fix

	    let turnCenter = placeBearingDistance(initialTurningPoint, targetTrack + turnDirection * 90, radius);
	    let turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
	    let courseChange;

	    if (Math.abs(deltaTrack) < 45) {
	      if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
	        turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
	        turnDirection = -turnDirection; // Turn direction is to be flipped, FBW-22-05

	        turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
	        courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
	      } else {
	        courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
	      }
	    } else if (Math.abs(deltaTrack) >= 45 && !compareTurnDirections(turnDirection, this.nextLeg.metadata.turnDirection)) {
	      turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
	      turnDirection = -turnDirection;
	      turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
	    } // Omit 45 degree intercept segment if possible


	    if (distanceLimit <= Math.abs(turnCenterDistance) && Math.abs(turnCenterDistance) < radius) {
	      const radiusToLeg = radius - Math.abs(turnCenterDistance);
	      let intercept; // If we are inbound of a TF leg, we use the TF leg ref fix for our small circle intersect in order to get
	      // more accurate results

	      if ('from' in this.nextLeg) {
	        const intersects = smallCircleGreatCircleIntersection(turnCenter, radius, this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);

	        if (intersects) {
	          const [one, two] = intersects;

	          if (distanceTo(initialTurningPoint, one) > distanceTo(initialTurningPoint, two)) {
	            intercept = one;
	          } else {
	            intercept = two;
	          }
	        }
	      } else {
	        intercept = firstSmallCircleIntersection(turnCenter, radius, this.nextLeg.getPathEndPoint(), reciprocal(this.nextLeg.outboundCourse));
	      } // If the difference between the radius and turnCenterDistance is very small, we might not find an intercept using the circle.
	      // Do a direct intercept instead.


	      if (!intercept && radiusToLeg < 0.1) {
	        this.computeDirectIntercept();
	        this.isComputed = true;
	        return;
	      }

	      if (intercept && !Number.isNaN(intercept.lat)) {
	        const bearingTcFtp = bearingTo(turnCenter, intercept);
	        const angleToLeg = MathUtils.diffAngle(Avionics.Utils.clampAngle(bearingTcFtp - (turnDirection > 0 ? -90 : 90)), this.nextLeg.outboundCourse);

	        if (Math.abs(angleToLeg) <= 48) {
	          this.itp = initialTurningPoint;
	          this.ftp = intercept;
	          this.predictedPath.push({
	            type: PathVectorType.Arc,
	            startPoint: initialTurningPoint,
	            endPoint: intercept,
	            centrePoint: turnCenter,
	            sweepAngle: Math.abs(deltaTrack) * turnDirection
	          });
	          this.distance = arcLength(radius, Math.abs(deltaTrack) * turnDirection);

	          this.isComputed = true;
	          return;
	        }
	      }
	    }

	    if (Math.abs(deltaTrack) < 45) {
	      if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
	        courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
	      } else {
	        courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
	      }
	    } else {
	      const isReverse = !compareTurnDirections(naturalTurnDirectionSign, this.nextLeg.metadata.turnDirection);

	      if (isReverse) {
	        courseChange = CourseChange.reverse(turnDirection, turnCenterDistance, deltaTrack, radius);
	        this.computedTurnDirection = this.nextLeg.metadata.turnDirection;
	      } else {
	        courseChange = CourseChange.normal(turnDirection, turnCenterDistance, deltaTrack, radius);
	        this.computedTurnDirection = turnDirection < 0 ? TurnDirection.Left : TurnDirection.Right;
	      }
	    }

	    this.computedTargetTrack = (360 + this.previousLeg.outboundCourse + courseChange) % 360;
	    const finalTurningPoint = placeBearingDistance(turnCenter, targetTrack + courseChange - 90 * turnDirection, radius);
	    let intercept; // If we are inbound of a TF leg, we use the TF leg FROM ref fix for our great circle intersect in order to get
	    // more accurate results

	    if ('from' in this.nextLeg) {
	      const intersections = placeBearingIntersection(finalTurningPoint, Avionics.Utils.clampAngle(targetTrack + courseChange), this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);

	      if (intersections) {
	        const [one, two] = intersections;

	        if (distanceTo(finalTurningPoint, one) < distanceTo(finalTurningPoint, two)) {
	          intercept = one;
	        } else {
	          intercept = two;
	        }
	      }
	    } else {
	      intercept = Geo.legIntercept(finalTurningPoint, targetTrack + courseChange, this.nextLeg);
	    }

	    const overshot = sideOfPointOnCourseToFix(finalTurningPoint, targetTrack + courseChange, intercept) === PointSide.Before;
	    this.itp = initialTurningPoint;
	    this.ftp = finalTurningPoint;
	    this.isComputed = true;
	    this.predictedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: initialTurningPoint,
	      endPoint: finalTurningPoint,
	      centrePoint: turnCenter,
	      sweepAngle: courseChange
	    });

	    if (!overshot) {
	      this.predictedPath.push({
	        type: PathVectorType.Line,
	        startPoint: finalTurningPoint,
	        endPoint: intercept
	      });
	    }

	    this.distance = arcLength(radius, courseChange) + (overshot ? 0 : distanceTo(finalTurningPoint, intercept));
	  }
	  /**
	   * Computes the path capture as a direct leg intercept from the previous leg path end point to the next leg,
	   * with previous leg outbound course
	   *
	   * @private
	   */


	  computeDirectIntercept() {
	    const intercept = Geo.legIntercept(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse, this.nextLeg);
	    this.itp = this.previousLeg.getPathEndPoint();
	    this.ftp = intercept;
	    this.predictedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.previousLeg.getPathEndPoint(),
	      endPoint: intercept
	    });

	    this.distance = distanceTo(this.previousLeg.getPathEndPoint(), intercept);
	  }

	  get startsInCircularArc() {
	    return false; // We don't want to do RAD for path captures
	  }

	  get endsInCircularArc() {
	    return false; // We don't want to do RAD for path captures
	  }

	  isAbeam(ppos) {
	    return !this.isNull && this.computedTurnDirection !== TurnDirection.Either && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
	  }

	  getTurningPoints() {
	    return [this.itp, this.ftp];
	  }

	  getDistanceToGo(_ppos) {
	    return 1;
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    if (this.computedTurnDirection !== TurnDirection.Either) {
	      const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
	      let trackAngleError = this.computedTargetTrack - trueTrack;

	      if (turnSign !== Math.sign(trackAngleError)) {
	        trackAngleError += turnSign * 360;
	      }

	      if (Math.abs(trackAngleError) > 130) {
	        const phiCommand = turnSign * maxBank(tas, true);
	        return {
	          law: ControlLaw.LATERAL_PATH,
	          trackAngleError: 0,
	          phiCommand,
	          crossTrackError: 0
	        };
	      }

	      this.forcedTurnComplete = true;
	    }

	    return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }

	  get repr() {
	    return "PATH CAPTURE(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
	  } // This is for VNAV to estimate the amount of track miles left


	  getActualDistanceToGo(ppos, trueTrack) {
	    let dtg = 0;

	    for (const path of this.predictedPath) {
	      if ('centrePoint' in path) {
	        // Arc
	        const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
	        let trackAngleError = this.computedTargetTrack - trueTrack;

	        if (turnSign !== Math.sign(trackAngleError)) {
	          trackAngleError += turnSign * 360;
	        }

	        dtg += pathVectorLength(path) * trackAngleError / path.sweepAngle;
	      } else if ('endPoint' in path) {
	        // Line
	        dtg += Math.min(pathVectorLength(path), distanceTo(path.endPoint, ppos));
	      }
	    }

	    return dtg;
	  }

	}

	class CILeg extends Leg {
	  constructor(course, nextLeg, metadata, segment) {
	    super();
	    this.course = course;
	    this.nextLeg = nextLeg;
	    this.metadata = metadata;

	    _defineProperty(this, "computedPath", []);

	    _defineProperty(this, "intercept", undefined);

	    this.segment = segment;
	  }

	  get terminationWaypoint() {
	    return this.intercept;
	  }

	  get distanceToTermFix() {
	    return Avionics.Utils.computeGreatCircleDistance(this.getPathStartPoint(), this.intercept);
	  }

	  get ident() {
	    return 'INTCPT';
	  }

	  getPathStartPoint() {
	    if (this.inboundGuidable instanceof IFLeg) {
	      return this.inboundGuidable.fix.infos.coordinates;
	    }

	    if (this.inboundGuidable && this.inboundGuidable.isComputed) {
	      return this.inboundGuidable.getPathEndPoint();
	    }

	    throw new Error('[CILeg] No computed inbound guidable.');
	  }

	  getPathEndPoint() {
	    if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
	      return this.outboundGuidable.getPathStartPoint();
	    }

	    if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
	      return this.outboundGuidable.getPathStartPoint();
	    }

	    return this.intercept;
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    this.intercept = Geo.legIntercept(this.getPathStartPoint(), this.course, this.nextLeg);
	    const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
	    const overshot = side === PointSide.After;

	    if (this.intercept && !Number.isNaN(this.intercept.lat) && !overshot) {
	      this.isNull = false;
	      this.computedPath = [{
	        type: PathVectorType.Line,
	        startPoint: this.getPathStartPoint(),
	        endPoint: this.getPathEndPoint()
	      }];
	      this.isComputed = true;
	    } else {
	      this.computedPath.length = 0;
	      this.isNull = true;
	      this.isComputed = true;
	    }
	  }

	  get inboundCourse() {
	    return this.course;
	  }

	  get outboundCourse() {
	    return this.course;
	  }

	  get distanceToTermination() {
	    const startPoint = this.getPathStartPoint();
	    return distanceTo(startPoint, this.intercept);
	  }

	  getDistanceToGo(ppos) {
	    return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	  }

	  getGuidanceParameters(_ppos, _trueTrack) {
	    return {
	      law: ControlLaw.TRACK,
	      course: this.course
	    };
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }

	  isAbeam(ppos) {
	    const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	    return dtg >= 0 && dtg <= this.distance;
	  }

	  get repr() {
	    return "CI(".concat(Math.trunc(this.course), "T)");
	  }

	}

	const mod$1 = (x, n) => x - Math.floor(x / n) * n;
	/**
	 * A type I transition uses a fixed turn radius between two fix-referenced legs.
	 */


	class FixedRadiusTransition extends Transition {
	  constructor(previousLeg, // FIXME temporary
	  nextLeg // FIXME temporary
	  ) {
	    super(previousLeg, nextLeg);
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "tad", void 0);

	    _defineProperty(this, "clockwise", void 0);

	    _defineProperty(this, "isFrozen", false);

	    _defineProperty(this, "computedPath", []);

	    _defineProperty(this, "sweepAngle", void 0);

	    _defineProperty(this, "centre", undefined);

	    _defineProperty(this, "revertTo", undefined);

	    _defineProperty(this, "turningPoints", void 0);
	  }

	  get isReverted() {
	    return this.revertTo !== undefined;
	  }

	  getPathStartPoint() {
	    if (this.revertTo) {
	      return this.revertTo.getPathStartPoint();
	    }

	    if (this.isComputed) {
	      return this.turningPoints[0];
	    }

	    throw Error('?');
	  }

	  getPathEndPoint() {
	    if (this.revertTo) {
	      return this.revertTo.getPathEndPoint();
	    }

	    if (this.isComputed) {
	      return this.turningPoints[1];
	    }

	    throw Error('?');
	  }

	  recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
	    if (this.isFrozen) {

	      return;
	    } // Sweep angle


	    this.sweepAngle = MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse); // Start with half the track change

	    const bankAngle = Math.abs(this.sweepAngle) / 2; // apply limits

	    const finalBankAngle = Math.max(Math.min(bankAngle, maxBank(tas, true)), minBank(this.nextLeg.segment)); // Turn radius

	    this.radius = tas ** 2 / (9.81 * Math.tan(finalBankAngle * Avionics.Utils.DEG2RAD)) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR; // Turn anticipation distance

	    this.tad = this.radius * Math.tan(Math.abs(this.sweepAngle / 2) * MathUtils.DEGREES_TO_RADIANS); // Check what the distance from the fix to the next leg is (to avoid being not lined up in some XF -> CF cases)

	    const prevLegTermDistanceToNextLeg = Geo.distanceToLeg(this.previousLeg instanceof XFLeg ? this.previousLeg.fix.infos.coordinates : this.previousLeg.intercept, this.nextLeg);
	    const defaultTurnDirection = this.sweepAngle >= 0 ? TurnDirection.Right : TurnDirection.Left;
	    const forcedTurn = (this.nextLeg.metadata.turnDirection === TurnDirection.Left || this.nextLeg.metadata.turnDirection === TurnDirection.Right) && defaultTurnDirection !== this.nextLeg.metadata.turnDirection;
	    const tooBigForPrevious = this.previousLeg.distanceToTermination < this.tad + 0.1;
	    const tooBigForNext = 'from' in this.nextLeg ? distanceTo(this.nextLeg.from.infos.coordinates, this.nextLeg.to.infos.coordinates) < this.tad + 0.1 : false;
	    const notLinedUp = Math.abs(prevLegTermDistanceToNextLeg) >= 0.25; // "reasonable" distance
	    // in some circumstances we revert to a path capture transition where the fixed radius won't work well

	    const shouldRevert = Math.abs(this.sweepAngle) <= 3 || Math.abs(this.sweepAngle) > 175 || this.previousLeg.overflyTermFix || forcedTurn || tooBigForPrevious || tooBigForNext || notLinedUp; // We do not revert to a path capture if the previous leg was overshot anyway - draw the normal fixed radius turn

	    const previousLegOvershot = 'overshot' in this.previousLeg && this.previousLeg.overshot;

	    if (shouldRevert && !previousLegOvershot) {
	      const shouldHaveTad = !this.previousLeg.overflyTermFix && !notLinedUp && (tooBigForPrevious || tooBigForNext);

	      if (!this.revertTo) {
	        const reverted = new PathCaptureTransition(this.previousLeg, this.nextLeg);
	        reverted.startWithTad = shouldHaveTad;
	        reverted.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
	        const reversionTad = reverted.tad;
	        const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.tad; // See if there is enough space left for the reverted transition

	        if (fixDtg > reversionTad) {
	          this.revertTo = reverted;
	          this.isComputed = this.revertTo.isComputed;
	          return;
	        }
	      } else {
	        this.revertTo.startWithTad = shouldHaveTad;
	        this.revertTo.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
	        this.isComputed = this.revertTo.isComputed;
	        return;
	      }
	    } // Try to de-revert if needed


	    if (this.revertTo) {
	      // We assume we are inactive here
	      const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.revertTo.tad; // Only de-revert if there is space for the fixed radius TAD

	      if (fixDtg > this.tad + 0.05 || !isActive) {
	        this.revertTo = undefined;
	      }
	    } // Turn direction


	    this.clockwise = this.sweepAngle >= 0; // Turning points

	    this.turningPoints = this.computeTurningPoints();
	    this.computedPath.length = 0;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.getTurningPoints()[0],
	      centrePoint: this.centre,
	      endPoint: this.getTurningPoints()[1],
	      sweepAngle: this.sweepAngle
	    });
	    this.isComputed = true;
	  }

	  get startsInCircularArc() {
	    return true;
	  }

	  get endsInCircularArc() {
	    return true;
	  }

	  isAbeam(ppos) {
	    if (this.revertTo !== undefined) {
	      return this.revertTo.isAbeam(ppos);
	    }

	    const turningPoints = this.getTurningPoints();

	    if (!turningPoints) {
	      return false;
	    }

	    const [inbound, outbound] = turningPoints;
	    const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
	    const inHeadingAc = Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
	    const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
	    const outHeadingAc = Math.abs(MathUtils.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
	    return inHeadingAc <= 90 && outHeadingAc >= 90;
	  }

	  get distance() {
	    if (this.revertTo) {
	      return this.revertTo.distance;
	    }

	    return arcLength(this.radius, this.sweepAngle);
	  }
	  /**
	   * Returns the distance between the inbound turning point and the reference fix
	   */


	  get unflownDistance() {
	    if (this.revertTo) {
	      return 0;
	    }

	    if (!this.getTurningPoints()) {
	      return 0;
	    }

	    return Avionics.Utils.computeGreatCircleDistance(this.previousLeg.getPathEndPoint(), this.getTurningPoints()[0]);
	  }

	  computeTurningPoints() {
	    const {
	      lat,
	      long
	    } = this.previousLeg instanceof CILeg ? this.previousLeg.intercept : this.previousLeg.fix.infos.coordinates;
	    const inbound = Avionics.Utils.bearingDistanceToCoordinates(mod$1(this.previousLeg.outboundCourse + 180, 360), this.tad, lat, long);
	    const outbound = Avionics.Utils.bearingDistanceToCoordinates(this.nextLeg.inboundCourse, this.tad, lat, long);
	    this.centre = Avionics.Utils.bearingDistanceToCoordinates(Avionics.Utils.clampAngle(this.previousLeg.outboundCourse + (this.clockwise ? 90 : -90)), this.radius, inbound.lat, inbound.long);
	    return [inbound, outbound];
	  }

	  getTurningPoints() {
	    if (this.revertTo) {
	      return this.revertTo.getTurningPoints();
	    }

	    return this.turningPoints;
	  }

	  get predictedPath() {
	    if (this.revertTo) {
	      return this.revertTo.predictedPath;
	    }

	    return this.computedPath;
	  }

	  getDistanceToGo(ppos) {
	    if (this.revertTo) {
	      return this.revertTo.getDistanceToGo(ppos);
	    }

	    const [itp] = this.getTurningPoints();
	    return arcDistanceToGo(ppos, itp, this.centre, this.sweepAngle);
	  }

	  getGuidanceParameters(ppos, trueTrack, tas) {
	    if (this.revertTo) {
	      return this.revertTo.getGuidanceParameters(ppos, trueTrack, tas);
	    }

	    const [itp] = this.getTurningPoints();
	    return arcGuidance(ppos, trueTrack, itp, this.centre, this.sweepAngle);
	  }

	  getNominalRollAngle(gs) {
	    if (this.revertTo) {
	      return this.revertTo.getNominalRollAngle(gs);
	    }

	    return (this.clockwise ? 1 : -1) * Math.atan((gs * 463 / 900) ** 2 / (this.radius * 1852 * Constants.G)) * (180 / Math.PI);
	  }

	  get repr() {
	    return "TYPE1(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
	  }

	}

	const tan$1 = input => Math.tan(input * (Math.PI / 180));
	/**
	 * A type I transition uses a fixed turn radius between two fix-referenced legs.
	 */


	class CourseCaptureTransition extends Transition {
	  constructor(previousLeg, nextLeg // FIXME temporary
	  ) {
	    super(previousLeg, nextLeg);
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "terminator", void 0);

	    _defineProperty(this, "isArc", void 0);

	    _defineProperty(this, "startPoint", void 0);

	    _defineProperty(this, "endPoint", void 0);

	    _defineProperty(this, "center", void 0);

	    _defineProperty(this, "sweepAngle", void 0);

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "clockwise", void 0);

	    _defineProperty(this, "predictedPath", []);

	    _defineProperty(this, "forcedTurnComplete", false);

	    _defineProperty(this, "computedTurnDirection", TurnDirection.Either);
	  }

	  getPathStartPoint() {
	    return this.previousLeg.getPathEndPoint();
	  }

	  getPathEndPoint() {
	    return this.terminator;
	  }

	  get turnDirection() {
	    return Math.sign(this.courseVariation) === -1 ? TurnDirection.Left : TurnDirection.Right;
	  }

	  get deltaTrack() {
	    return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
	  }

	  get courseVariation() {
	    return MathUtils.adjustAngleForTurnDirection(this.deltaTrack, this.nextLeg.metadata.turnDirection);
	  }

	  recomputeWithParameters(_isActive, tas, gs, ppos, _trueTrack) {
	    const termFix = this.previousLeg.getPathEndPoint();
	    this.computedTurnDirection = TurnDirection.Either;
	    let courseChange;
	    let initialTurningPoint;

	    if (!this.inboundGuidable) {
	      if (this.courseVariation <= 90) {
	        courseChange = this.deltaTrack;
	      } else if (Math.sign(this.courseVariation) === Math.sign(this.deltaTrack)) {
	        courseChange = this.deltaTrack;
	      } else {
	        courseChange = Math.sign(this.courseVariation) * 360 + this.deltaTrack;
	      }

	      initialTurningPoint = ppos;
	    } else {
	      courseChange = this.courseVariation;
	      initialTurningPoint = termFix;
	    } // Course change and delta track?


	    const radius = gs ** 2 / (Constants.G * tan$1(Math.abs(maxBank(tas, false)))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
	    const turnCenter = Geo.computeDestinationPoint(initialTurningPoint, radius, this.previousLeg.outboundCourse + 90 * Math.sign(courseChange));
	    const finalTurningPoint = Geo.computeDestinationPoint(turnCenter, radius, this.previousLeg.outboundCourse - 90 * Math.sign(courseChange) + courseChange);
	    this.radius = radius; // Turn direction

	    this.clockwise = courseChange >= 0;

	    if (courseChange === 0) {
	      this.isArc = false;
	      this.startPoint = this.previousLeg.getPathEndPoint();
	      this.endPoint = this.previousLeg.getPathEndPoint();
	      this.terminator = this.endPoint;
	      this.isComputed = true;
	      this.predictedPath.length = 0;
	      this.predictedPath.push({
	        type: PathVectorType.Line,
	        startPoint: this.startPoint,
	        endPoint: this.endPoint
	      });
	      this.isNull = true;
	      return;
	    }

	    this.computedTurnDirection = this.clockwise ? TurnDirection.Right : TurnDirection.Left;
	    this.isNull = false;
	    this.isArc = true;
	    this.startPoint = initialTurningPoint;
	    this.center = turnCenter;
	    this.endPoint = finalTurningPoint;
	    this.sweepAngle = courseChange;
	    this.terminator = this.endPoint;
	    this.predictedPath.length = 0;
	    this.predictedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.startPoint,
	      centrePoint: this.center,
	      endPoint: this.endPoint,
	      sweepAngle: this.sweepAngle
	    });
	    this.isComputed = true;
	  }

	  get startsInCircularArc() {
	    return this.isArc;
	  }

	  get endsInCircularArc() {
	    return this.isArc;
	  }

	  get angle() {
	    return this.sweepAngle;
	  }

	  isAbeam(ppos) {
	    return !this.isNull && this.computedTurnDirection !== TurnDirection.Either && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
	  }

	  get distance() {
	    if (this.isNull) {
	      return 0;
	    }

	    return arcLength(this.radius, this.angle);
	  }

	  getTurningPoints() {
	    return [this.startPoint, this.endPoint];
	  }

	  getDistanceToGo(ppos) {
	    const [itp] = this.getTurningPoints();
	    return arcDistanceToGo(ppos, itp, this.center, this.clockwise ? this.angle : -this.angle);
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    if (this.computedTurnDirection !== TurnDirection.Either) {
	      const turnSign = this.computedTurnDirection === TurnDirection.Left ? -1 : 1;
	      let trackAngleError = this.nextLeg.inboundCourse - trueTrack;

	      if (turnSign !== Math.sign(trackAngleError)) {
	        trackAngleError += turnSign * 360;
	      }

	      if (Math.abs(trackAngleError) > 130) {
	        const phiCommand = turnSign * maxBank(tas, false);
	        return {
	          law: ControlLaw.LATERAL_PATH,
	          trackAngleError: 0,
	          phiCommand,
	          crossTrackError: 0
	        };
	      }

	      this.forcedTurnComplete = true;
	    } // FIXME PPOS guidance and all...


	    return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
	  }

	  getNominalRollAngle(gs) {
	    const gsMs = gs * (463 / 900);
	    return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
	  }

	  get repr() {
	    return "COURSE CAPTURE(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
	  }

	}

	/* | FALeg | FMLeg */
	const tan = input => Math.tan(input * (Math.PI / 180));

	const acos = input => Math.acos(input) * (180 / Math.PI);

	let DirectToFixTransitionGuidanceState;
	/**
	 * A type I transition uses a fixed turn radius between two fix-referenced legs.
	 */

	(function (DirectToFixTransitionGuidanceState) {
	  DirectToFixTransitionGuidanceState[DirectToFixTransitionGuidanceState["Straight"] = 0] = "Straight";
	  DirectToFixTransitionGuidanceState[DirectToFixTransitionGuidanceState["Turn"] = 1] = "Turn";
	})(DirectToFixTransitionGuidanceState || (DirectToFixTransitionGuidanceState = {}));

	class DirectToFixTransition extends Transition {
	  constructor(previousLeg, nextLeg) {
	    super(previousLeg, nextLeg);
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "state", DirectToFixTransitionGuidanceState.Straight);

	    _defineProperty(this, "straightCourse", void 0);

	    _defineProperty(this, "terminator", void 0);

	    _defineProperty(this, "hasArc", void 0);

	    _defineProperty(this, "center", void 0);

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "clockwise", void 0);

	    _defineProperty(this, "lineStartPoint", void 0);

	    _defineProperty(this, "lineEndPoint", void 0);

	    _defineProperty(this, "arcStartPoint", void 0);

	    _defineProperty(this, "arcCentrePoint", void 0);

	    _defineProperty(this, "arcEndPoint", void 0);

	    _defineProperty(this, "arcSweepAngle", void 0);

	    _defineProperty(this, "computedPath", []);
	  }

	  getPathStartPoint() {
	    return this.previousLeg.getPathEndPoint();
	  }

	  get turnDirection() {
	    return Math.sign(this.deltaTrack);
	  }

	  get deltaTrack() {
	    return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
	  }

	  get courseVariation() {
	    // TODO reverse turn direction
	    return this.deltaTrack;
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
	    if (this.isFrozen) {
	      return;
	    }

	    const termFix = this.previousLeg.getPathEndPoint(); // FIXME fix for FX legs

	    const nextFix = this.nextLeg.fix.infos.coordinates;
	    this.radius = gs ** 2 / (Constants.G * tan(maxBank(tas, true))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
	    let trackChange = MathUtils.diffAngle(this.previousLeg.outboundCourse, bearingTo(this.previousLeg.getPathEndPoint(), nextFix), this.nextLeg.metadata.turnDirection);

	    if (Math.abs(trackChange) < 3 || !Number.isFinite(trackChange)) {
	      this.isNull = true;
	      this.isComputed = true;
	      return;
	    }

	    const turnDirectionSign = trackChange > 0 ? 1 : -1;
	    const turnDirection = turnDirectionSign > 0 ? TurnDirection.Right : TurnDirection.Left;
	    const currentRollAngle = isActive ? -SimVar.GetSimVarValue('PLANE BANK DEGREES', 'degrees') : 0;
	    const rollAngleChange = Math.abs(turnDirectionSign * maxBank(tas, true) - currentRollAngle);
	    const rollAnticipationDistance = Geometry.getRollAnticipationDistance(gs, 0, rollAngleChange);
	    let itp = rollAnticipationDistance >= 0.05 ? placeBearingDistance(termFix, this.previousLeg.outboundCourse, rollAnticipationDistance) : termFix;
	    let turnCentre = placeBearingDistance(itp, this.previousLeg.outboundCourse + turnDirectionSign * 90, this.radius);
	    let distanceToFix = distanceTo(turnCentre, nextFix);

	    if (distanceToFix < this.radius) {
	      if (Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, bearingTo(termFix, nextFix), this.nextLeg.metadata.turnDirection)) < 60) {
	        this.hasArc = false;
	        this.lineStartPoint = termFix;
	        this.lineEndPoint = termFix;
	        this.terminator = this.lineEndPoint;
	        this.predictedPath.length = 0;
	        this.predictedPath.push({
	          type: PathVectorType.Line,
	          startPoint: this.lineStartPoint,
	          endPoint: this.lineEndPoint
	        });

	        this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
	        this.isNull = true;
	        this.isComputed = true;
	        return;
	      }

	      const tcFixBearing = bearingTo(turnCentre, nextFix);
	      const extendDist = Math.sqrt(this.radius ** 2 - distanceToFix ** 2 * Math.sin((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) ** 2) + distanceToFix * Math.cos((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) + 0.3;
	      itp = placeBearingDistance(itp, this.previousLeg.outboundCourse, extendDist);
	      turnCentre = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse, extendDist);
	      distanceToFix = distanceTo(turnCentre, nextFix);
	    }

	    const bearingTcItp = bearingTo(turnCentre, itp);
	    const bearingTcFix = bearingTo(turnCentre, nextFix);
	    const angleFtpFix = acos(this.radius / distanceToFix);
	    trackChange = MathUtils.diffAngle(bearingTcItp, MathUtils.diffAngle(turnDirectionSign * angleFtpFix, bearingTcFix), turnDirection);
	    const ftp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse + trackChange - 90 * turnDirectionSign, this.radius);
	    this.lineStartPoint = this.previousLeg.getPathEndPoint();
	    this.lineEndPoint = itp;
	    this.hasArc = true;
	    this.arcStartPoint = itp;
	    this.arcCentrePoint = turnCentre;
	    this.arcEndPoint = ftp;
	    this.arcSweepAngle = trackChange;
	    this.terminator = this.arcEndPoint;
	    this.predictedPath.length = 0;
	    this.predictedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.lineStartPoint,
	      endPoint: this.lineEndPoint
	    });
	    this.predictedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.arcStartPoint,
	      centrePoint: this.arcCentrePoint,
	      endPoint: this.arcEndPoint,
	      sweepAngle: this.arcSweepAngle
	    });

	    this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
	    this.isNull = false;
	    this.isComputed = true;
	  }

	  getPathDebugPoints() {
	    const points = [];
	    points.push({
	      type: PathVectorType.DebugPoint,
	      startPoint: this.lineStartPoint,
	      annotation: 'T4 RAD START'
	    }, {
	      type: PathVectorType.DebugPoint,
	      startPoint: this.lineEndPoint,
	      annotation: 'T4 RAD END'
	    });

	    if (this.hasArc) {
	      points.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.arcStartPoint,
	        annotation: 'T4 ARC START'
	      }, {
	        type: PathVectorType.DebugPoint,
	        startPoint: this.arcCentrePoint
	      }, {
	        type: PathVectorType.DebugPoint,
	        startPoint: this.arcEndPoint,
	        annotation: 'T4 ARC END'
	      });
	    }

	    return points;
	  }

	  get endsInCircularArc() {
	    return this.hasArc;
	  }

	  isAbeam(ppos) {
	    if (this.isNull) {
	      return false;
	    }

	    let dtg = 0;

	    if (this.state === DirectToFixTransitionGuidanceState.Straight) {
	      const straightDist = distanceTo(this.lineStartPoint, this.lineEndPoint);
	      const straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
	      dtg += straightDtg;

	      if (dtg >= straightDist) {
	        return false;
	      }
	    }

	    if (this.hasArc) {
	      if (this.state === DirectToFixTransitionGuidanceState.Turn) {
	        const arcDtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
	        dtg += arcDtg;
	      } else {
	        dtg += arcLength(this.radius, this.arcSweepAngle);
	      }
	    }

	    return dtg > 0;
	  }

	  get distance() {
	    if (this.isNull) {
	      return 0;
	    }

	    const straightDistance = distanceTo(this.lineStartPoint, this.lineEndPoint);

	    if (this.hasArc) {
	      return straightDistance + arcLength(this.radius, this.arcSweepAngle);
	    }

	    return straightDistance;
	  }

	  getTurningPoints() {
	    return [this.arcStartPoint, this.arcEndPoint];
	  }

	  getDistanceToGo(ppos) {
	    let straightDtg = 0;

	    if (this.state === DirectToFixTransitionGuidanceState.Straight) {
	      straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
	    }

	    if (!this.hasArc) {
	      return straightDtg;
	    }

	    return straightDtg + arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
	  }

	  getGuidanceParameters(ppos, trueTrack, tas) {
	    let dtg;
	    let params; // State machine & DTG

	    switch (this.state) {
	      case DirectToFixTransitionGuidanceState.Straight:
	        dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);

	        if (dtg <= 0 && this.hasArc) {
	          this.state = DirectToFixTransitionGuidanceState.Turn;
	        }

	        break;

	      case DirectToFixTransitionGuidanceState.Turn:
	        dtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
	        break;
	    } // Guidance


	    switch (this.state) {
	      case DirectToFixTransitionGuidanceState.Straight:
	        params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.lineEndPoint);
	        let bankNext = 0;

	        if (this.hasArc) {
	          bankNext = this.arcSweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, false);
	        }

	        const rad = Geometry.getRollAnticipationDistance(tas, 0, bankNext);

	        if (dtg <= rad) {
	          params.phiCommand = bankNext;
	        }

	        break;

	      case DirectToFixTransitionGuidanceState.Turn:
	        params = arcGuidance(ppos, trueTrack, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle); // TODO next leg RAD

	        break;
	    }

	    return params;
	  }

	  getNominalRollAngle(gs) {
	    const gsMs = gs * (463 / 900);
	    return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
	  }

	  get repr() {
	    return "DIRECT TO FIX(".concat(this.previousLeg.repr, " TO ").concat(this.nextLeg.repr, ")");
	  }

	}

	function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	class CALeg extends Leg {
	  constructor(course, altitude, metadata, segment, extraLength) {
	    super();
	    this.course = course;
	    this.altitude = altitude;
	    this.metadata = metadata;
	    this.extraLength = extraLength;

	    _defineProperty(this, "estimatedTermination", void 0);

	    _defineProperty(this, "computedPath", []);

	    _defineProperty(this, "start", void 0);

	    _defineProperty(this, "wasMovedByPpos", false);

	    this.segment = segment;
	  }

	  get terminationWaypoint() {
	    return this.estimatedTermination;
	  }

	  get ident() {
	    return Math.round(this.altitude).toString();
	  }

	  getPathStartPoint() {
	    var _this$inboundGuidable;

	    return (_this$inboundGuidable = this.inboundGuidable) === null || _this$inboundGuidable === void 0 ? void 0 : _this$inboundGuidable.getPathEndPoint();
	  }

	  getPathEndPoint() {
	    return this.estimatedTermination;
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  recomputeWithParameters(isActive, _tas, _gs, ppos, _trueTrack) {
	    // FIXME somehow after reloads the isRunway property is gone, so consider airports as runways for now
	    const afterRunway = this.inboundGuidable instanceof IFLeg && (this.inboundGuidable.fix.isRunway || this.inboundGuidable.fix.icao.startsWith('A')); // We assign / spread properties here to avoid copying references and causing bugs

	    if (isActive && !afterRunway) {
	      this.wasMovedByPpos = true;

	      if (!this.start) {
	        this.start = _objectSpread$2({}, ppos);
	      } else {
	        this.start.lat = ppos.lat;
	        this.start.long = ppos.long;
	      }

	      if (!this.estimatedTermination) {
	        this.recomputeEstimatedTermination();
	      }
	    } else if (!this.wasMovedByPpos) {
	      var _this$inboundGuidable2;

	      const newPreviousGuidableStart = (_this$inboundGuidable2 = this.inboundGuidable) === null || _this$inboundGuidable2 === void 0 ? void 0 : _this$inboundGuidable2.getPathEndPoint();

	      if (newPreviousGuidableStart) {
	        if (!this.start) {
	          this.start = _objectSpread$2({}, newPreviousGuidableStart);
	        } else {
	          this.start.lat = newPreviousGuidableStart.lat;
	          this.start.long = newPreviousGuidableStart.long;
	        }
	      }

	      this.recomputeEstimatedTermination();
	    }

	    this.computedPath = [{
	      type: PathVectorType.Line,
	      startPoint: this.start,
	      endPoint: this.getPathEndPoint()
	    }];

	    this.isComputed = true;
	  }

	  recomputeEstimatedTermination() {
	    const ESTIMATED_VS = 2000; // feet per minute

	    const ESTIMATED_KTS = 175; // NM per hour
	    // FIXME hax!

	    let originAltitude = 0;

	    if (this.inboundGuidable instanceof IFLeg && this.inboundGuidable.fix.icao.startsWith('A')) {
	      originAltitude = this.inboundGuidable.fix.infos.oneWayRunways[0].elevation * 3.28084;
	    }

	    const minutesToAltitude = (this.altitude - Math.max(0, originAltitude)) / ESTIMATED_VS; // minutes

	    let distanceToTermination = minutesToAltitude / 60 * ESTIMATED_KTS; // NM

	    if (!this.wasMovedByPpos && this.extraLength > 0) {
	      distanceToTermination += this.extraLength;
	    }

	    this.estimatedTermination = Avionics.Utils.bearingDistanceToCoordinates(this.course, distanceToTermination, this.start.lat, this.start.long);
	  }

	  get inboundCourse() {
	    return this.course;
	  }

	  get outboundCourse() {
	    return this.course;
	  }

	  getDistanceToGo(ppos) {
	    return courseToFixDistanceToGo(ppos, this.course, this.estimatedTermination);
	  }

	  getGuidanceParameters(ppos, trueTrack, _tas) {
	    // FIXME: should be just track guidance, no xtk
	    // (the start of the predicted path should also float with ppos once active, along with the transition to the leg)
	    // return {
	    //    law: ControlLaw.TRACK,
	    //    course: this.course,
	    // };
	    return courseToFixGuidance(ppos, trueTrack, this.course, this.estimatedTermination);
	  }

	  getNominalRollAngle(_gs) {
	    return undefined;
	  }

	  get distanceToTermination() {
	    const startPoint = this.getPathStartPoint();
	    return distanceTo(startPoint, this.estimatedTermination);
	  }

	  isAbeam(_ppos) {
	    return false;
	  }

	  get repr() {
	    return "CA(".concat(this.course.toFixed(1), "T) TO ").concat(Math.round(this.altitude), " FT");
	  }

	}

	class CRLeg extends Leg {
	  constructor(course, origin, radial, metadata, segment) {
	    super();
	    this.course = course;
	    this.origin = origin;
	    this.radial = radial;
	    this.metadata = metadata;

	    _defineProperty(this, "computedPath", []);

	    _defineProperty(this, "intercept", undefined);

	    this.segment = segment;
	  }

	  get terminationWaypoint() {
	    return this.intercept;
	  }

	  get ident() {
	    return this.origin.ident.substring(0, 3) + this.origin.theta.toFixed(0);
	  }

	  getPathStartPoint() {
	    if (this.inboundGuidable && this.inboundGuidable.isComputed) {
	      return this.inboundGuidable.getPathEndPoint();
	    }

	    throw new Error('[CRLeg] No computed inbound guidable.');
	  }

	  getPathEndPoint() {
	    return this.intercept;
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    this.intercept = Geo.doublePlaceBearingIntercept(this.getPathStartPoint(), this.origin.coordinates, this.course, this.radial);
	    const overshot = distanceTo(this.getPathStartPoint(), this.intercept) >= 5000;

	    if (this.intercept && !overshot) {
	      this.computedPath = [{
	        type: PathVectorType.Line,
	        startPoint: this.getPathStartPoint(),
	        endPoint: this.intercept
	      }];
	      this.isNull = false;
	      this.isComputed = true;
	    } else {
	      this.predictedPath.length = 0;
	      this.isNull = true;
	      this.isComputed = true;
	    }
	  }
	  /**
	   * Returns `true` if the inbound transition has overshot the leg
	   */


	  get overshot() {
	    const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
	    return side === PointSide.After;
	  }

	  get inboundCourse() {
	    return this.course;
	  }

	  get outboundCourse() {
	    return this.course;
	  }

	  get distanceToTermination() {
	    const startPoint = this.getPathStartPoint();
	    return distanceTo(startPoint, this.intercept);
	  }

	  getDistanceToGo(ppos) {
	    return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	  }

	  getGuidanceParameters(ppos, trueTrack, _tas) {
	    return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }

	  getPseudoWaypointLocation(_distanceBeforeTerminator) {
	    return undefined;
	  }

	  isAbeam(ppos) {
	    const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
	    return dtg >= 0 && dtg <= this.distance;
	  }

	  get repr() {
	    return "CR ".concat(this.course, "T to ").concat(this.origin.ident).concat(this.origin.theta);
	  }

	}

	/**
	 * Temporary - better solution is just to have an `InfiniteLine` vector...
	 */
	const VM_LEG_SIZE = 321; // TODO needs updated with wind prediction, and maybe local magvar if following for longer distances

	class VMLeg extends Leg {
	  constructor(heading, metadata, segment) {
	    super();
	    this.heading = heading;
	    this.metadata = metadata;

	    _defineProperty(this, "predictedPath", []);

	    _defineProperty(this, "displayedOnMap", false);

	    this.segment = segment;
	  }

	  get terminationWaypoint() {
	    return undefined;
	  }

	  get ident() {
	    return 'MANUAL';
	  }

	  getPathStartPoint() {
	    var _this$inboundGuidable;

	    return (_this$inboundGuidable = this.inboundGuidable) === null || _this$inboundGuidable === void 0 ? void 0 : _this$inboundGuidable.getPathEndPoint();
	  }

	  getPathEndPoint() {
	    return Avionics.Utils.bearingDistanceToCoordinates(this.heading, VM_LEG_SIZE, this.getPathStartPoint().lat, this.getPathStartPoint().long);
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    // FIXME course based on predicted wind
	    this.predictedPath.length = 0;
	    this.predictedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.getPathStartPoint(),
	      endPoint: this.getPathEndPoint()
	    });
	    this.isComputed = true;
	  }

	  get inboundCourse() {
	    // FIXME this is a bit naughty...
	    return this.heading;
	  }

	  get outboundCourse() {
	    // FIXME this is a bit naughty...
	    return this.heading;
	  }

	  get distance() {
	    return 0;
	  }

	  get distanceToTermination() {
	    return 1;
	  } // Can't get pseudo-waypoint location without a finite terminator


	  getPseudoWaypointLocation(_distanceBeforeTerminator) {
	    return undefined;
	  }

	  getGuidanceParameters(_ppos, _trueTrack) {
	    return {
	      law: ControlLaw.HEADING,
	      heading: this.heading
	    };
	  }

	  getNominalRollAngle(_gs) {
	    return 0;
	  }

	  getDistanceToGo(_ppos) {
	    return undefined;
	  }

	  isAbeam(_ppos) {
	    return true;
	  }

	  get disableAutomaticSequencing() {
	    return true;
	  }

	  get repr() {
	    return "VM(".concat(this.heading.toFixed(1), "T)");
	  }

	}

	class DFLeg extends XFLeg {
	  constructor(fix, metadata, segment) {
	    super(fix);
	    this.metadata = metadata;

	    _defineProperty(this, "computedPath", []);

	    _defineProperty(this, "start", void 0);

	    this.segment = segment;
	  }

	  getPathStartPoint() {
	    var _this$inboundGuidable, _this$inboundGuidable2;

	    return (_this$inboundGuidable = (_this$inboundGuidable2 = this.inboundGuidable) === null || _this$inboundGuidable2 === void 0 ? void 0 : _this$inboundGuidable2.getPathEndPoint()) !== null && _this$inboundGuidable !== void 0 ? _this$inboundGuidable : this.estimateStartPoint();
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  estimateStartPoint() {
	    let bearing = 0;

	    if (this.outboundGuidable instanceof Transition) {
	      bearing = this.outboundGuidable.nextLeg.inboundCourse + 180;
	    } else if (this.outboundGuidable instanceof Leg) {
	      bearing = this.outboundGuidable.inboundCourse + 180;
	    }

	    bearing = Avionics.Utils.clampAngle(bearing);
	    return Avionics.Utils.bearingDistanceToCoordinates(bearing, 2, this.fix.infos.coordinates.long, this.fix.infos.coordinates.long);
	  }

	  recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
	    var _this$inboundGuidable3, _this$inboundGuidable4;

	    const newStart = (_this$inboundGuidable3 = (_this$inboundGuidable4 = this.inboundGuidable) === null || _this$inboundGuidable4 === void 0 ? void 0 : _this$inboundGuidable4.getPathEndPoint()) !== null && _this$inboundGuidable3 !== void 0 ? _this$inboundGuidable3 : this.estimateStartPoint(); // Adjust the start point if we can

	    if (newStart) {
	      this.start = newStart;
	    }

	    this.computedPath = [{
	      type: PathVectorType.Line,
	      startPoint: this.start,
	      endPoint: this.getPathEndPoint()
	    }];

	    this.isComputed = true;
	  }

	  get inboundCourse() {
	    return bearingTo(this.start, this.fix.infos.coordinates);
	  }

	  get outboundCourse() {
	    return bearingTo(this.start, this.fix.infos.coordinates);
	  }

	  getDistanceToGo(ppos) {
	    return courseToFixDistanceToGo(ppos, this.outboundCourse, this.getPathEndPoint());
	  }

	  getGuidanceParameters(ppos, trueTrack, _tas) {
	    return fixToFixGuidance(ppos, trueTrack, this.start, this.fix.infos.coordinates);
	  }

	  getNominalRollAngle(_gs) {
	    return undefined;
	  }

	  isAbeam(_ppos) {
	    return false;
	  }

	  get repr() {
	    return "DF TO '".concat(this.fix.ident, "'");
	  }

	}

	class RFLeg extends XFLeg {
	  // termination fix of the previous leg
	  // to fix for the RF leg, most params referenced off this
	  // location of the centre fix of the arc
	  constructor(from, to, center, metadata, segment) {
	    super(to);
	    this.metadata = metadata;

	    _defineProperty(this, "from", void 0);

	    _defineProperty(this, "to", void 0);

	    _defineProperty(this, "center", void 0);

	    _defineProperty(this, "radius", void 0);

	    _defineProperty(this, "angle", void 0);

	    _defineProperty(this, "clockwise", void 0);

	    _defineProperty(this, "mDistance", void 0);

	    _defineProperty(this, "computedPath", []);

	    this.from = from;
	    this.to = to;
	    this.center = center;
	    this.radius = Avionics.Utils.computeGreatCircleDistance(this.center, this.to.infos.coordinates);
	    this.segment = segment;
	    const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates); // -90?

	    const bearingTo = Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates); // -90?

	    switch (to.turnDirection) {
	      case 1:
	        // left
	        this.clockwise = false;
	        this.angle = Avionics.Utils.clampAngle(bearingFrom - bearingTo);
	        break;

	      case 2:
	        // right
	        this.clockwise = true;
	        this.angle = Avionics.Utils.clampAngle(bearingTo - bearingFrom);
	        break;

	      case 0: // unknown

	      case 3: // either

	      default:
	        const angle = Avionics.Utils.diffAngle(bearingTo, bearingFrom);
	        this.clockwise = angle > 0;
	        this.angle = Math.abs(angle);
	        break;
	    }

	    this.mDistance = 2 * Math.PI * this.radius / 360 * this.angle;
	    this.computedPath = [{
	      type: PathVectorType.Arc,
	      startPoint: this.from.infos.coordinates,
	      centrePoint: this.center,
	      endPoint: this.to.infos.coordinates,
	      sweepAngle: this.clockwise ? this.angle : -this.angle
	    }];
	    this.isComputed = true;
	  }

	  getPathStartPoint() {
	    return this.from.infos.coordinates;
	  }

	  getPathEndPoint() {
	    return this.to.infos.coordinates;
	  }

	  get predictedPath() {
	    return this.computedPath;
	  }

	  get startsInCircularArc() {
	    return true;
	  }

	  get endsInCircularArc() {
	    return true;
	  }

	  get inboundCourse() {
	    return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates) + (this.clockwise ? 90 : -90));
	  }

	  get outboundCourse() {
	    return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates) + (this.clockwise ? 90 : -90));
	  }

	  get distance() {
	    return this.mDistance;
	  }

	  get distanceToTermination() {
	    return arcLength(this.radius, this.angle);
	  } // basically straight from type 1 transition... willl need refinement


	  getGuidanceParameters(ppos, trueTrack, _tas) {
	    // FIXME should be defined in terms of to fix
	    return arcGuidance(ppos, trueTrack, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
	  }

	  getNominalRollAngle(gs) {
	    const gsMs = gs * (463 / 900);
	    return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
	  }
	  /**
	   * Calculates directed DTG parameter
	   *
	   * @param ppos {LatLong} the current position of the aircraft
	   */


	  getDistanceToGo(ppos) {
	    // FIXME geometry should be defined in terms of to...
	    return arcDistanceToGo(ppos, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
	  }

	  isAbeam(ppos) {
	    const bearingPpos = Avionics.Utils.computeGreatCircleHeading(this.center, ppos);
	    const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates);
	    const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
	    return trackAngleError >= 0;
	  }

	  toString() {
	    return "<RFLeg radius=".concat(this.radius, " to=").concat(this.to, ">");
	  }

	  get repr() {
	    return "RF(".concat(this.radius.toFixed(1), "NM. ").concat(this.angle.toFixed(1), "\xB0) TO ").concat(this.to.ident);
	  }

	}

	var EntryType;

	(function (EntryType) {
	  EntryType[EntryType["Null"] = 0] = "Null";
	  EntryType[EntryType["Teardrop"] = 1] = "Teardrop";
	  EntryType[EntryType["Parallel"] = 2] = "Parallel";
	  EntryType[EntryType["DirectOutbound"] = 3] = "DirectOutbound";
	  EntryType[EntryType["DirectTurn"] = 4] = "DirectTurn";
	})(EntryType || (EntryType = {}));

	let EntryState;

	(function (EntryState) {
	  EntryState[EntryState["Turn1"] = 0] = "Turn1";
	  EntryState[EntryState["Straight1"] = 1] = "Straight1";
	  EntryState[EntryState["Turn2"] = 2] = "Turn2";
	  EntryState[EntryState["Capture"] = 3] = "Capture";
	  EntryState[EntryState["Done"] = 4] = "Done";
	})(EntryState || (EntryState = {}));

	class HoldEntryTransition extends Transition {
	  // hax
	  constructor(previousLeg, nextLeg) {

	    super(previousLeg, nextLeg);
	    this.previousLeg = previousLeg;
	    this.nextLeg = nextLeg;

	    _defineProperty(this, "entry", EntryType.Null);

	    _defineProperty(this, "computedPath", []);

	    _defineProperty(this, "turn1", {});

	    _defineProperty(this, "turn2", {});

	    _defineProperty(this, "turn3", {});

	    _defineProperty(this, "straightCourse", void 0);

	    _defineProperty(this, "state", EntryState.Turn1);

	    _defineProperty(this, "wasAbeam", false);

	    _defineProperty(this, "guidanceActive", false);

	    _defineProperty(this, "frozen", false);
	  }

	  get distance() {
	    return 0; // 0 so no PWPs
	  }

	  getDistanceToGo(_ppos) {
	    if (this.entry === EntryType.Null || this.state === EntryState.Done) {
	      return 0;
	    } // TODO


	    return 1;
	  }

	  setHxEntry() {
	    switch (this.entry) {
	      case EntryType.DirectTurn:
	      case EntryType.Parallel:
	      case EntryType.Teardrop:
	      case EntryType.Null:
	        this.nextLeg.setInitialState(HxLegGuidanceState.Arc1);
	        break;

	      case EntryType.DirectOutbound:
	        this.nextLeg.setInitialState(HxLegGuidanceState.Outbound);
	        break;
	    }
	  }

	  getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs) {
	    let dtg; // update state

	    switch (this.state) {
	      case EntryState.Turn1:
	        dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);

	        if (dtg <= 0) {
	          this.state = EntryState.Straight1;
	        }

	        break;

	      case EntryState.Straight1:
	        dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);

	        if (dtg <= 0) {
	          this.state = EntryState.Turn2;
	        }

	        break;

	      case EntryState.Turn2:
	        dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
	        const refFrameOffset = Avionics.Utils.diffAngle(0, this.outboundCourse);
	        const trackAngleError = this.turn2.sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - trueTrack) : Avionics.Utils.clampAngle(trueTrack - refFrameOffset);

	        if (trackAngleError < 130) {
	          this.state = EntryState.Capture;
	        }

	        break;

	      case EntryState.Capture:
	        dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);

	        if (dtg < 0.1) {
	          this.nextLeg.updatePrediction();
	          this.state = EntryState.Done;
	        }

	        break;
	    }

	    let bankNext = 0;
	    let params; // compute guidance

	    switch (this.state) {
	      case EntryState.Turn1:
	        params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
	        break;

	      case EntryState.Straight1:
	        params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
	        bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
	        break;

	      case EntryState.Turn2:
	        // force the initial part of the turn to ensure correct direction
	        const phiCommand = this.turn2.sweepAngle > 0 ? maxBank(tas, true
	        /* FIXME false */
	        ) : -maxBank(tas, true
	        /* FIXME false */
	        );
	        bankNext = phiCommand;
	        params = {
	          law: ControlLaw.LATERAL_PATH,
	          trackAngleError: 0,
	          phiCommand,
	          crossTrackError: 0
	        };
	        break;

	      case EntryState.Capture:
	        params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates); // TODO for HF get the following leg bank

	        const {
	          sweepAngle
	        } = this.nextLeg.geometry;
	        bankNext = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
	        break;

	      case EntryState.Done:
	        params = this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
	        bankNext = params.phiCommand;
	        break;
	    }

	    const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);

	    if (rad > 0 && dtg <= rad) {
	      params.phiCommand = bankNext;
	    }

	    return params;
	  }

	  getDirectTurnGuidanceParameters(ppos, trueTrack, tas, _gs) {
	    let dtg;

	    switch (this.state) {
	      case EntryState.Turn1:
	        dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);

	        if (dtg <= 0) {
	          this.state = EntryState.Straight1;
	        }

	        break;

	      case EntryState.Straight1:
	        dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);

	        if (dtg <= 0) {
	          this.state = EntryState.Turn2;
	        }

	        break;

	      case EntryState.Turn2:
	        dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);

	        if (dtg <= 0) {
	          this.state = EntryState.Capture;
	        }

	        break;

	      case EntryState.Capture:
	        dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);

	        if (dtg < 0.1) {
	          this.state = EntryState.Done;
	        }

	        break;
	    }

	    let params;
	    let bankNext;

	    switch (this.state) {
	      case EntryState.Turn1:
	        params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
	        bankNext = 0;
	        break;

	      case EntryState.Straight1:
	        params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
	        bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
	        break;

	      case EntryState.Turn2:
	        params = arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
	        bankNext = 0;
	        break;

	      case EntryState.Capture:
	        params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
	        bankNext = 0;
	        break;
	    }

	    const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);

	    if (rad > 0 && dtg <= rad) {
	      params.phiCommand = bankNext;
	    }

	    return params;
	  }
	  /**
	   *
	   * @todo guide inbound leg for parallel + teardrop?
	   */


	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    if (!this.guidanceActive) {
	      this.nextLeg.updatePrediction();
	      this.guidanceActive = true;
	    }

	    switch (this.entry) {
	      case EntryType.Parallel:
	      case EntryType.Teardrop:
	        return this.getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs);

	      case EntryType.DirectOutbound:
	        return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);

	      case EntryType.DirectTurn:
	        return this.getDirectTurnGuidanceParameters(ppos, trueTrack, tas, gs);
	    }

	    return undefined;
	  }

	  getNominalRollAngle(gs) {
	    if (this.entry === EntryType.Null) {
	      return this.nextLeg.getNominalRollAngle(gs);
	    }

	    if (Math.abs(this.turn1.sweepAngle) <= 3) {
	      return 0;
	    }

	    return this.turn1.sweepAngle > 0 ? maxBank(gs
	    /* FIXME tas */
	    , true) : -maxBank(gs
	    /* FIXME tas */
	    , true);
	  }

	  getTurningPoints() {
	    switch (this.entry) {
	      case EntryType.Parallel:
	      case EntryType.Teardrop:
	        return [this.nextLeg.fix.infos.coordinates, this.turn3.ftp];

	      case EntryType.DirectTurn:
	      case EntryType.DirectOutbound:
	        return [this.nextLeg.fix.infos.coordinates, this.turn1.ftp];

	      case EntryType.Null:
	      default:
	        return [this.nextLeg.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates];
	    }
	  }

	  isAbeam(ppos) {
	    // major hack
	    if (!this.wasAbeam && this.previousLeg.getDistanceToGo(ppos) <= 0) {
	      this.wasAbeam = true;
	      return true;
	    }

	    return this.wasAbeam && this.state !== EntryState.Done;
	  }

	  get startsInCircularArc() {
	    return true;
	  }

	  get endsInCircularArc() {
	    return true;
	  }

	  get inboundCourse() {
	    return this.previousLeg.outboundCourse;
	  }

	  get outboundCourse() {
	    return this.nextLeg.inboundCourse;
	  }

	  get predictedPath() {
	    if (this.entry === EntryType.Null) {
	      return [];
	    }

	    if (this.entry === EntryType.DirectOutbound) {
	      if (this.nextLeg instanceof HFLeg) {
	        return this.nextLeg.getHippodromePath();
	      }

	      return [];
	    }

	    return this.computedPath;
	  }

	  getPathDebugPoints() {
	    if (this.entry === EntryType.Null) {
	      return [];
	    }

	    const debugPoints = [{
	      type: PathVectorType.DebugPoint,
	      startPoint: this.turn1.arcCentre,
	      annotation: 'AC1'
	    }, {
	      type: PathVectorType.DebugPoint,
	      startPoint: this.turn1.ftp,
	      annotation: 'FTP1'
	    }];

	    if (this.entry === EntryType.Parallel || this.entry === EntryType.Teardrop) {
	      debugPoints.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.turn2.itp,
	        annotation: 'ITP2',
	        colour: DebugPointColour.Magenta
	      });
	      debugPoints.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.turn2.arcCentre,
	        annotation: 'AC2',
	        colour: DebugPointColour.Magenta
	      });
	      debugPoints.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.turn2.ftp,
	        annotation: 'FTP2',
	        colour: DebugPointColour.Magenta
	      });
	      debugPoints.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.turn3.itp,
	        annotation: 'ITP3',
	        colour: DebugPointColour.Yellow
	      });
	      debugPoints.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.turn3.arcCentre,
	        annotation: 'AC3',
	        colour: DebugPointColour.Yellow
	      });
	      debugPoints.push({
	        type: PathVectorType.DebugPoint,
	        startPoint: this.turn3.ftp,
	        annotation: 'FTP3',
	        colour: DebugPointColour.Yellow
	      });
	    }

	    return debugPoints;
	  }

	  computeNullEntry() {
	    this.entry = EntryType.Null;
	    this.computedPath.length = 0;
	  }

	  computeDirectOutboundEntry() {
	    this.entry = EntryType.DirectOutbound;
	    const {
	      radius: maxRadius
	    } = this.nextLeg.geometry;
	    const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
	    const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
	    const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
	    this.turn1.itp = this.nextLeg.fix.infos.coordinates;
	    this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + turnSign * 90, radius, this.turn1.itp.lat, this.turn1.itp.long);
	    this.turn1.sweepAngle = turnSign * 180 + trackChange;
	    const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
	    this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
	    this.computedPath.length = 0;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn1.itp,
	      endPoint: this.turn1.ftp,
	      centrePoint: this.turn1.arcCentre,
	      sweepAngle: this.turn1.sweepAngle
	    });
	  }

	  computeDirectTurnEntry() {
	    this.entry = EntryType.DirectTurn;
	    const {
	      fixB,
	      fixC,
	      arcCentreFix2,
	      sweepAngle,
	      radius: maxRadius
	    } = this.nextLeg.geometry;
	    const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
	    const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
	    const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
	    this.turn1.itp = this.nextLeg.fix.infos.coordinates;
	    this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + turnSign * 90, radius, this.turn1.itp.lat, this.turn1.itp.long);
	    this.turn1.sweepAngle = turnSign * 180 + trackChange;
	    const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
	    this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
	    this.computedPath.length = 0;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn1.itp,
	      endPoint: this.turn1.ftp,
	      centrePoint: this.turn1.arcCentre,
	      sweepAngle: this.turn1.sweepAngle
	    });
	    this.straightCourse = (this.outboundCourse + 180) % 360;
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.turn1.ftp,
	      endPoint: fixB
	    });
	    this.turn2.itp = fixB;
	    this.turn2.ftp = fixC;
	    this.turn2.sweepAngle = sweepAngle;
	    this.turn2.arcCentre = arcCentreFix2;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: fixB,
	      centrePoint: arcCentreFix2,
	      endPoint: fixC,
	      sweepAngle
	    });
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: fixC,
	      endPoint: this.nextLeg.fix.infos.coordinates
	    });
	  }
	  /**
	   * @todo extend outbound path to ensure capture before hold fix
	   */


	  computeTeardropEntry() {
	    this.entry = EntryType.Teardrop;
	    const {
	      radius,
	      legLength
	    } = this.nextLeg.geometry;
	    const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
	    this.straightCourse = Avionics.Utils.clampAngle(this.outboundCourse + 150 * turnSign);
	    this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.straightCourse);
	    const turn1Clockwise = this.turn1.sweepAngle >= 0;
	    this.turn1.itp = this.nextLeg.fix.infos.coordinates;
	    this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + (turn1Clockwise ? 90 : -90), radius, this.turn1.itp.lat, this.turn1.itp.long);
	    const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (turn1Clockwise ? -90 : 90));
	    this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
	    this.computedPath.length = 0;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn1.itp,
	      endPoint: this.turn1.ftp,
	      centrePoint: this.turn1.arcCentre,
	      sweepAngle: this.turn1.sweepAngle
	    });
	    const kekRads = Math.abs(Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180)) * Math.PI / 180;
	    let minStraightDistance = radius * 2 / Math.sqrt(3) * (0.1 + Math.SQRT2 - 1 / 2 - Math.abs(Math.sin(kekRads) - 1 / 2));
	    const nominalStraightDistance = 1.15 * legLength; // - Math.sin(Math.abs(this.turn1.sweepAngle * Math.PI / 180)) * radius;

	    let straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
	    let radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);

	    if (Math.SQRT2 - radii2Inbound > 0) {
	      const extraCapComponent = Math.SQRT2 - radii2Inbound;
	      minStraightDistance += radius * 2 / Math.sqrt(3) * extraCapComponent;
	      straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
	      radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
	    }

	    this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse, straightDistance, this.turn1.ftp.lat, this.turn1.ftp.long);
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.turn1.ftp,
	      endPoint: this.turn2.itp
	    });
	    this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 120, radius, this.turn2.itp.lat, this.turn2.itp.long);

	    if (radii2Inbound >= 2) {
	      // we are intercepting from the inside with room for 45 deg capture
	      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 75, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
	      this.turn2.sweepAngle = turnSign * 165;
	      const straightDist = (radii2Inbound - 2) * Math.SQRT2 * radius;
	      this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 165, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
	      this.turn3.sweepAngle = turnSign * 45;
	      this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse - turnSign * 105, radius, this.turn3.itp.lat, this.turn3.itp.long);
	      this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
	      this.computedPath.push({
	        type: PathVectorType.Line,
	        startPoint: this.turn2.ftp,
	        endPoint: this.turn3.itp
	      });
	    } else if (Math.SQRT2 - radii2Inbound < 0) {
	      // we are intercepting from the outside without enough room for 45 deg capture
	      const interceptAngle = Math.acos(radii2Inbound / 2) * 180 / Math.PI;
	      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * (120 + interceptAngle), radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
	      this.turn2.sweepAngle = turnSign * (210 + interceptAngle);
	      this.turn3.itp = this.turn2.ftp;
	      this.turn3.sweepAngle = -turnSign * interceptAngle;
	      this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * (120 + interceptAngle), radius, this.turn3.itp.lat, this.turn3.itp.long);
	      this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
	    } else {
	      // we are intercepting from the outside with room for 45 deg capture
	      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
	      this.turn2.sweepAngle = turnSign * 255;
	      const straightDist = Math.sqrt(2 * (Math.SQRT2 - radii2Inbound) ** 2) * radius;
	      this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.straightCourse + turnSign * 255, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
	      this.turn3.sweepAngle = -turnSign * 45;
	      this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, radius, this.turn3.itp.lat, this.turn3.itp.long);
	      this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
	      this.computedPath.push({
	        type: PathVectorType.Line,
	        startPoint: this.turn2.ftp,
	        endPoint: this.turn3.itp
	      });
	    }

	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn2.itp,
	      endPoint: this.turn2.ftp,
	      centrePoint: this.turn2.arcCentre,
	      sweepAngle: this.turn2.sweepAngle
	    });
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn3.itp,
	      endPoint: this.turn3.ftp,
	      centrePoint: this.turn3.arcCentre,
	      sweepAngle: this.turn3.sweepAngle
	    });
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.turn3.ftp,
	      endPoint: this.nextLeg.fix.infos.coordinates
	    });
	  }

	  computeParallelEntry() {
	    this.entry = EntryType.Parallel;
	    const {
	      radius,
	      legLength
	    } = this.nextLeg.geometry;
	    const turnSign = this.nextLeg.turnDirection === TurnDirection.Right ? +1 : -1;
	    this.turn1.itp = this.nextLeg.fix.infos.coordinates;
	    this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.inboundCourse + (this.nextLeg.turnDirection === TurnDirection.Right ? -90 : 90), radius, this.turn1.itp.lat, this.turn1.itp.long);
	    this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180);
	    const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (this.nextLeg.turnDirection === TurnDirection.Right ? 90 : -90));
	    this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
	    this.computedPath.length = 0;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn1.itp,
	      endPoint: this.turn1.ftp,
	      centrePoint: this.turn1.arcCentre,
	      sweepAngle: this.turn1.sweepAngle
	    });
	    const turn1Rads = Math.abs(this.turn1.sweepAngle) * Math.PI / 180;
	    const minStraightDistance = 0.1 + 2 * Math.cos(1 - Math.SQRT2 / 2 - Math.sin(turn1Rads)) * radius;
	    const nominalStraightDistance = 1.15 * legLength - radius * Math.sin(turn1Rads);
	    const straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
	    this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + 180, straightDistance, this.turn1.ftp.lat, this.turn1.ftp.long);
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.turn1.ftp,
	      endPoint: this.turn2.itp
	    });
	    this.straightCourse = Avionics.Utils.computeGreatCircleHeading(this.turn1.ftp, this.turn2.itp);
	    this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 90, radius, this.turn2.itp.lat, this.turn2.itp.long);
	    this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 45, radius, this.turn2.arcCentre.lat, this.turn2.arcCentre.long);
	    this.turn2.sweepAngle = turnSign * -225;
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn2.itp,
	      endPoint: this.turn2.ftp,
	      centrePoint: this.turn2.arcCentre,
	      sweepAngle: this.turn2.sweepAngle
	    });
	    const ftp2ToInboundAbeamRadii = Math.cos(turn1Rads) + Math.SQRT2 / 2;
	    const straightDist = Math.sqrt(2 * (ftp2ToInboundAbeamRadii - (1 - Math.SQRT2 / 2)) ** 2) * radius;
	    this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 45, straightDist, this.turn2.ftp.lat, this.turn2.ftp.long);
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.turn2.ftp,
	      endPoint: this.turn3.itp
	    });
	    this.turn3.sweepAngle = turnSign * 45;
	    this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse + turnSign * 45, radius, this.turn3.itp.lat, this.turn3.itp.long);
	    this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(this.outboundCourse - turnSign * 90, radius, this.turn3.arcCentre.lat, this.turn3.arcCentre.long);
	    this.computedPath.push({
	      type: PathVectorType.Arc,
	      startPoint: this.turn3.itp,
	      endPoint: this.turn3.ftp,
	      centrePoint: this.turn3.arcCentre,
	      sweepAngle: this.turn3.sweepAngle
	    });
	    this.computedPath.push({
	      type: PathVectorType.Line,
	      startPoint: this.turn3.ftp,
	      endPoint: this.nextLeg.fix.infos.coordinates
	    });
	  }

	  recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack) {
	    // TODO only HX leg drives this
	    const hxInbound = this.outboundCourse;
	    const entryAngle = Avionics.Utils.diffAngle(this.inboundCourse, hxInbound);

	    if (this.frozen) {
	      if (this.state === EntryState.Done) {
	        this.computedPath.length = 0;
	      }

	      return;
	    }

	    if (isActive && !this.frozen) {
	      this.frozen = true;
	    } // TODO freeze once we're active?
	    // TODO, should HA entry become null when the leg is no longer flown?
	    // might have bad implications for the next leg, and also for straying outside protected area
	    // related: if we still fly the entry... should we shorten the leg length to minimum?


	    if (!this.previousLeg || entryAngle >= -3 && entryAngle <= 3) {
	      this.computeNullEntry();
	      this.setHxEntry();
	      this.isNull = true;
	      return;
	    }

	    this.isNull = false; // parallel entry is always used when entering from opposite of hold course...
	    // we give a 3 degree tolerance to allow for mag var, calculation errors etc.

	    if (this.nextLeg.turnDirection === TurnDirection.Left) {
	      if (entryAngle > 110 && entryAngle < 177) {
	        this.computeTeardropEntry();
	      } else if (entryAngle >= 177 && entryAngle <= 180 || entryAngle > -180 && entryAngle < -70) {
	        this.computeParallelEntry();
	      } else if (entryAngle >= -70 && entryAngle < -3) {
	        this.computeDirectTurnEntry();
	      } else {
	        this.computeDirectOutboundEntry();
	      }
	    } else if (this.nextLeg.turnDirection === TurnDirection.Right) {
	      if (entryAngle > -177 && entryAngle < -110) {
	        this.computeTeardropEntry();
	      } else if (entryAngle > 70 && entryAngle <= 180 || entryAngle > -180 && entryAngle <= -177) {
	        this.computeParallelEntry();
	      } else if (entryAngle > 3 && entryAngle <= 70) {
	        this.computeDirectTurnEntry();
	      } else {
	        this.computeDirectOutboundEntry();
	      }
	    }


	    this.setHxEntry();
	  }

	  getPathStartPoint() {
	    return this.getTurningPoints()[0];
	  }

	  getPathEndPoint() {
	    return this.getTurningPoints()[1];
	  }

	  get repr() {
	    return "HOLD ENTRY(".concat(this.nextLeg.repr, ")");
	  }

	}

	// Copyright (c) 2021-2022 FlyByWire Simulations
	class TransitionPicker {
	  static forLegs(from, to) {
	    if (from instanceof AFLeg) {
	      return TransitionPicker.fromAF(from, to);
	    }

	    if (from instanceof CALeg) {
	      return TransitionPicker.fromCA(from, to);
	    }

	    if (from instanceof CFLeg) {
	      return TransitionPicker.fromCF(from, to);
	    }

	    if (from instanceof DFLeg) {
	      return TransitionPicker.fromDF(from, to);
	    }

	    if (from instanceof HALeg || from instanceof HFLeg || from instanceof HMLeg) {
	      return TransitionPicker.fromHX(from, to);
	    }

	    if (from instanceof PILeg) {
	      return TransitionPicker.fromPI(from, to);
	    }

	    if (from instanceof RFLeg) {
	      return TransitionPicker.fromRF(from, to);
	    }

	    if (from instanceof TFLeg) {
	      return TransitionPicker.fromTF(from, to);
	    }

	    if (from instanceof CILeg) {
	      return TransitionPicker.fromCI(from, to);
	    }

	    if (from instanceof CRLeg) {
	      return TransitionPicker.fromCR(from, to);
	    }

	    if (from instanceof VMLeg) {
	      return TransitionPicker.fromVM(from, to);
	    }

	    return null;
	  }

	  static fromCA(from, to) {
	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof TFLeg) {
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromAF(from, to) {
	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      // FIXME fixed radius / revert to path capture
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
	      return new HoldEntryTransition(from, to);
	    }

	    if (to instanceof TFLeg) {
	      return new DmeArcTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromCF(from, to) {
	    if (to instanceof AFLeg) {
	      return new DmeArcTransition(from, to);
	    }

	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      // FIXME fixed radius / revert to path capture
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
	      return new HoldEntryTransition(from, to);
	    }

	    if (to instanceof PILeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof TFLeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromCI(from, to) {
	    if (to instanceof AFLeg) {
	      return new DmeArcTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    return null;
	  }

	  static fromDF(from, to) {
	    if (to instanceof AFLeg) {
	      return new DmeArcTransition(from, to);
	    }

	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
	      return new HoldEntryTransition(from, to);
	    }

	    if (to instanceof PILeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof TFLeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromHX(from, to) {
	    if (to instanceof AFLeg) {
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof TFLeg) {
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromPI(from, to) {
	    if (!(to instanceof CFLeg)) {
	      console.error('PI -> !CF', from, to);
	    }

	    return null;
	  }

	  static fromRF(from, to) {
	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
	      return new HoldEntryTransition(from, to);
	    }

	    return null;
	  }

	  static fromTF(from, to) {
	    if (to instanceof AFLeg) {
	      return new DmeArcTransition(from, to);
	    }

	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      // FIXME / revert to fixed radius
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
	      return new HoldEntryTransition(from, to);
	    }

	    if (to instanceof PILeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof TFLeg) {
	      return new FixedRadiusTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromCR(from, to) {
	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CFLeg) {
	      // FIXME / revert to fixed radius
	      return new PathCaptureTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof VMLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	  static fromVM(from, to) {
	    if (to instanceof CALeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof DFLeg) {
	      return new DirectToFixTransition(from, to);
	    }

	    if (to instanceof CILeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    if (to instanceof CRLeg) {
	      return new CourseCaptureTransition(from, to);
	    }

	    return null;
	  }

	}

	function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	function isGuidableCapturingPath(guidable) {
	  return !(guidable instanceof CALeg || guidable instanceof CILeg || guidable instanceof CRLeg || guidable instanceof VMLeg || guidable instanceof CourseCaptureTransition);
	}

	class Geometry {
	  /**
	   * The list of transitions between legs.
	   * - entry n: transition after leg n
	   */

	  /**
	   * The list of legs in this geometry, possibly connected through transitions:
	   * - entry n: nth leg, before transition n
	   */
	  constructor(transitions, legs, temp) {
	    this.temp = temp;

	    _defineProperty(this, "transitions", void 0);

	    _defineProperty(this, "legs", void 0);

	    _defineProperty(this, "version", 0);

	    _defineProperty(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));

	    _defineProperty(this, "isComputed", false);

	    _defineProperty(this, "cachedVectors", []);

	    _defineProperty(this, "cachedVectorsVersion", 0);

	    this.transitions = transitions;
	    this.legs = legs;
	  }

	  getAllPathVectors(activeLegIndex) {
	    if (this.version === this.cachedVectorsVersion) {
	      return this.cachedVectors;
	    }

	    const transmitHoldEntry = !this.temp;
	    const ret = [];

	    for (const [index, leg] of this.legs.entries()) {
	      if (leg.isNull) {
	        continue;
	      } // TODO don't transmit any course reversals when this side range >= 160


	      const transmitCourseReversal = index === activeLegIndex || index === activeLegIndex + 1;

	      if (activeLegIndex !== undefined) {
	        if (isCourseReversalLeg(leg) && !transmitCourseReversal) {
	          continue;
	        }

	        if (index < activeLegIndex) {
	          continue;
	        }
	      }

	      const legInboundTransition = leg.inboundGuidable instanceof Transition ? leg.inboundGuidable : null;

	      if (legInboundTransition && !legInboundTransition.isNull && (!isHold(leg) || transmitHoldEntry)) {
	        ret.push(...legInboundTransition.predictedPath);
	      }

	      if (leg) {
	        ret.push(...leg.predictedPath);
	      }
	    }

	    this.cachedVectors = ret;
	    this.cachedVectorsVersion = this.version;
	    return ret;
	  }
	  /**
	   * Recomputes the guidable using new parameters
	   *
	   * @param tas             predicted true airspeed speed of the current leg (for a leg) or the next leg (for a transition) in knots
	   * @param gs              predicted ground speed of the current leg
	   * @param ppos            present position coordinates
	   * @param trueTrack       present true track
	   * @param activeLegIdx    current active leg index
	   * @param activeTransIdx  current active transition index
	   */


	  recomputeWithParameters(tas, gs, ppos, trueTrack, activeLegIdx, _activeTransIdx) {
	    this.version++;

	    for (let i = activeLegIdx !== null && activeLegIdx !== void 0 ? activeLegIdx : 0; this.legs.get(i) || this.legs.get(i + 1); i++) {
	      if (!this.legs.has(i)) {
	        continue;
	      }

	      const leg = this.legs.get(i);
	      const wasNull = leg.isNull;
	      this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs); // If a leg became null/not null, we immediately recompute it to calculate the new guidables and transitions

	      if (!wasNull && leg.isNull || wasNull && !leg.isNull) {
	        this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);
	      }
	    }
	  }

	  static getLegPredictedTas(leg, currentTas) {
	    var _leg$predictedTas;

	    return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_leg$predictedTas = leg.predictedTas) !== null && _leg$predictedTas !== void 0 ? _leg$predictedTas : currentTas);
	  }

	  static getLegPredictedGs(leg, currentGs) {
	    var _leg$predictedGs;

	    return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_leg$predictedGs = leg.predictedGs) !== null && _leg$predictedGs !== void 0 ? _leg$predictedGs : currentGs);
	  }

	  computeLeg(index, activeLegIdx, ppos, trueTrack, tas, gs) {
	    const prevLeg = this.legs.get(index - 1);
	    const leg = this.legs.get(index);
	    const nextLeg = this.legs.get(index + 1);
	    const nextNextLeg = this.legs.get(index + 2);
	    const inboundTransition = this.transitions.get(index - 1);
	    const outboundTransition = this.transitions.get(index);
	    const legPredictedTas = Geometry.getLegPredictedTas(leg, tas);
	    const legPredictedGs = Geometry.getLegPredictedGs(leg, gs); // If the leg is null, we compute the following:
	    //  - transition from prevLeg to nextLeg
	    //  - nextLeg
	    //  - transition from nextLeg to nextNextLeg (in order to compute nextLeg)

	    if (leg !== null && leg !== void 0 && leg.isNull) {
	      if (nextLeg) {
	        var _newInboundTransition, _newOutboundTransitio;

	        let newInboundTransition;

	        {
	          newInboundTransition = TransitionPicker.forLegs(prevLeg, nextLeg);
	        }

	        let newOutboundTransition;

	        if (nextNextLeg && LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1 || index + 1 - activeLegIdx < LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE) {
	          newOutboundTransition = TransitionPicker.forLegs(nextLeg, nextNextLeg);
	        }

	        if (newInboundTransition && prevLeg) {
	          const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
	          const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
	          newInboundTransition.setNeighboringGuidables(prevLeg, nextLeg);
	          newInboundTransition.recomputeWithParameters(activeLegIdx === index, prevLegPredictedLegTas, prevLegPredictedLegGs, ppos, trueTrack);
	        }

	        const nextLegPredictedLegTas = Geometry.getLegPredictedTas(nextLeg, tas);
	        const nextLegPredictedLegGs = Geometry.getLegPredictedGs(nextLeg, gs);
	        nextLeg.setNeighboringGuidables((_newInboundTransition = newInboundTransition) !== null && _newInboundTransition !== void 0 ? _newInboundTransition : prevLeg, (_newOutboundTransitio = newOutboundTransition) !== null && _newOutboundTransitio !== void 0 ? _newOutboundTransitio : nextNextLeg);
	        nextLeg.recomputeWithParameters(activeLegIdx === index, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);

	        if (newOutboundTransition) {
	          newOutboundTransition.setNeighboringGuidables(nextLeg, nextNextLeg);
	          newOutboundTransition.recomputeWithParameters(activeLegIdx === index + 1, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
	          nextLeg.recomputeWithParameters(activeLegIdx === index, nextLegPredictedLegTas, nextLegPredictedLegGs, ppos, trueTrack);
	        }
	      }
	    }

	    if (inboundTransition && prevLeg) {
	      const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
	      const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
	      inboundTransition.setNeighboringGuidables(prevLeg, leg);
	      inboundTransition.setNeighboringLegs(prevLeg, leg);
	      inboundTransition.recomputeWithParameters(activeLegIdx === index, prevLegPredictedLegTas, prevLegPredictedLegGs, ppos, trueTrack);
	    } // Compute leg and outbound if previous leg isn't null (we already computed 1 leg forward the previous iteration)


	    if (!(prevLeg && prevLeg.isNull)) {
	      leg.setNeighboringGuidables(inboundTransition !== null && inboundTransition !== void 0 ? inboundTransition : prevLeg, outboundTransition !== null && outboundTransition !== void 0 ? outboundTransition : nextLeg);
	      leg.recomputeWithParameters(activeLegIdx === index, legPredictedTas, legPredictedGs, ppos, trueTrack);

	      if (outboundTransition && nextLeg) {
	        outboundTransition.setNeighboringGuidables(leg, nextLeg);
	        outboundTransition.setNeighboringLegs(leg, nextLeg);
	        outboundTransition.recomputeWithParameters(activeLegIdx === index + 1, legPredictedTas, legPredictedGs, ppos, trueTrack); // Since the outbound transition can have TAD, we recompute the leg again to make sure the end point is at the right place for this cycle

	        leg.setNeighboringGuidables(inboundTransition !== null && inboundTransition !== void 0 ? inboundTransition : prevLeg, outboundTransition);
	        leg.recomputeWithParameters(activeLegIdx === index, legPredictedTas, legPredictedGs, ppos, trueTrack);
	      }
	    }
	  }
	  /**
	   * @param activeLegIdx
	   * @param ppos
	   * @param trueTrack
	   * @param gs
	   * @param tas
	   */


	  getGuidanceParameters(activeLegIdx, ppos, trueTrack, gs, tas) {
	    const activeLeg = this.legs.get(activeLegIdx);
	    const nextLeg = this.legs.get(activeLegIdx + 1); // TODO handle in guidance controller state

	    const autoSequencing = !(activeLeg !== null && activeLeg !== void 0 && activeLeg.disableAutomaticSequencing);
	    let activeGuidable = null;
	    let nextGuidable = null; // first, check if we're abeam with one of the transitions (start or end)

	    const fromTransition = this.transitions.get(activeLegIdx - 1);
	    const toTransition = this.transitions.get(activeLegIdx);

	    if (fromTransition && !fromTransition.isNull && fromTransition.isAbeam(ppos)) {
	      if (!fromTransition.isFrozen) {
	        fromTransition.freeze();
	      } // Since CA leg CourseCaptureTransition inbound starts at PPOS, we always consider the CA leg as the active guidable


	      if (fromTransition instanceof CourseCaptureTransition && activeLeg instanceof CALeg) {
	        activeGuidable = activeLeg;
	        nextGuidable = toTransition;
	      } else {
	        activeGuidable = fromTransition;
	        nextGuidable = activeLeg;
	      }
	    } else if (toTransition && !toTransition.isNull && autoSequencing) {
	      // TODO need to check that the previous leg is actually flown first...
	      if (toTransition.isAbeam(ppos)) {
	        if (toTransition instanceof FixedRadiusTransition && !toTransition.isFrozen) {
	          toTransition.freeze();
	        }

	        activeGuidable = toTransition;
	        nextGuidable = nextLeg;
	      } else if (activeLeg) {
	        activeGuidable = activeLeg;
	        nextGuidable = toTransition;
	      }
	    } else if (activeLeg) {
	      activeGuidable = activeLeg;

	      if (nextLeg && autoSequencing) {
	        nextGuidable = nextLeg;
	      }
	    } // figure out guidance params and roll anticipation


	    let guidanceParams;
	    let rad;
	    let dtg;

	    if (activeGuidable) {
	      const phiLimit = maxBank(tas, isGuidableCapturingPath(activeGuidable));
	      guidanceParams = _objectSpread$1(_objectSpread$1({}, activeGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs)), {}, {
	        phiLimit
	      });
	      dtg = activeGuidable.getDistanceToGo(ppos);

	      if (activeGuidable && nextGuidable) {
	        rad = this.getGuidableRollAnticipationDistance(gs, activeGuidable, nextGuidable);

	        if (rad > 0 && dtg <= rad) {
	          const nextGuidanceParams = nextGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs);

	          if (nextGuidanceParams.law === ControlLaw.LATERAL_PATH) {
	            var _nextGuidanceParams$p;

	            guidanceParams.phiCommand = (_nextGuidanceParams$p = nextGuidanceParams === null || nextGuidanceParams === void 0 ? void 0 : nextGuidanceParams.phiCommand) !== null && _nextGuidanceParams$p !== void 0 ? _nextGuidanceParams$p : 0;
	          }
	        }
	      }
	    }

	    return guidanceParams;
	  }

	  getGuidableRollAnticipationDistance(gs, from, to) {
	    if (!from.endsInCircularArc && !to.startsInCircularArc) {
	      return 0;
	    } // get nominal phi from previous and next leg


	    const phiNominalFrom = from.endsInCircularArc ? from.getNominalRollAngle(gs) : 0;
	    const phiNominalTo = to.startsInCircularArc ? to.getNominalRollAngle(gs) : 0; // TODO consider case where RAD > transition distance

	    return Geometry.getRollAnticipationDistance(gs, phiNominalFrom, phiNominalTo);
	  }

	  static getRollAnticipationDistance(gs, bankA, bankB) {
	    // calculate delta phi
	    const deltaPhi = Math.abs(bankA - bankB); // calculate RAD

	    const maxRollRate = 5; // deg / s, TODO picked off the wind

	    const k2 = 0.0038;
	    const rad = gs / 3600 * (Math.sqrt(1 + 2 * k2 * 9.81 * deltaPhi / maxRollRate) - 1) / (k2 * 9.81);
	    return rad;
	  }

	  getDistanceToGo(activeLegIdx, ppos) {
	    const activeLeg = this.legs.get(activeLegIdx);

	    if (activeLeg) {
	      return activeLeg.getDistanceToGo(ppos);
	    }

	    return null;
	  }

	  shouldSequenceLeg(activeLegIdx, ppos) {
	    const activeLeg = this.legs.get(activeLegIdx);
	    const inboundTransition = this.transitions.get(activeLegIdx - 1); // Restrict sequencing in cases where we are still in inbound transition. Make an exception for very short legs as the transition could be overshooting.

	    if (!(inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isNull) && inboundTransition !== null && inboundTransition !== void 0 && inboundTransition.isAbeam(ppos) && activeLeg.distance > 0.01) {
	      return false;
	    }

	    const dtg = activeLeg.getDistanceToGo(ppos);

	    if (dtg <= 0 || activeLeg.isNull) {
	      return true;
	    }

	    if (activeLeg) {
	      return activeLeg.getDistanceToGo(ppos) < 0.001;
	    }

	    return false;
	  }

	  onLegSequenced(_sequencedLeg, nextLeg, followingLeg) {
	    if (isCourseReversalLeg(nextLeg) || isCourseReversalLeg(followingLeg)) {
	      this.version++;
	    }
	  }

	  legsInSegment(segmentType) {
	    const newMap = new Map();

	    for (const entry of this.legs.entries()) {
	      if (entry[1].segment === segmentType) {
	        newMap.set(...entry);
	      }
	    }

	    return newMap;
	  }
	  /**
	   * Returns DTG for a complete leg path, taking into account transitions (including split FXR)
	   *
	   * @param ppos      present position
	   * @param leg       the leg guidable
	   * @param inbound   the inbound transition guidable, if present
	   * @param outbound  the outbound transition guidable, if present
	   */


	  static completeLegPathDistanceToGo(ppos, leg, inbound, outbound) {
	    const [, legPartLength, outboundTransLength] = Geometry.completeLegPathLengths(leg, inbound, outbound);

	    if (outbound && outbound.isAbeam(ppos)) {
	      return outbound.getDistanceToGo(ppos) - outbound.distance / 2; // Remove half of the transition length, since it is split (Type I)
	    }

	    if (inbound && inbound.isAbeam(ppos)) {
	      return inbound.getDistanceToGo(ppos) + legPartLength + outboundTransLength;
	    }

	    return leg.getDistanceToGo(ppos) - (outbound && outbound instanceof FixedRadiusTransition ? outbound.unflownDistance : 0) + outboundTransLength;
	  }
	  /**
	   * Returns lengths of the different segments of a leg, taking into account transitions (including split FXR)
	   *
	   * @param leg       the leg guidable
	   * @param inbound   the inbound transition guidable, if present
	   * @param outbound  the outbound transition guidable, if present
	   */


	  static completeLegPathLengths(leg, inbound, outbound) {
	    let inboundLength = 0;
	    let outboundLength = 0;

	    if (outbound) {
	      if (outbound instanceof FixedRadiusTransition && !outbound.isReverted) {
	        // Type I transitions are split between the prev and next legs
	        outboundLength = outbound.distance / 2;
	      }
	    }

	    if (inbound) {
	      if (inbound instanceof FixedRadiusTransition && !inbound.isReverted) {
	        // Type I transitions are split between the prev and next legs
	        inboundLength = inbound.distance / 2;
	      } else {
	        inboundLength = inbound.distance;
	      }
	    }

	    return [inboundLength, leg.distance, outboundLength];
	  }

	}

	let HxLegGuidanceState; // TODO make sure IMM EXIT works during teardrop/parallel (proceed to HF via that entry then sequence the HM immediately)
	// TODO move HMLeg specific logic to HMLeg

	(function (HxLegGuidanceState) {
	  HxLegGuidanceState[HxLegGuidanceState["Inbound"] = 0] = "Inbound";
	  HxLegGuidanceState[HxLegGuidanceState["Arc1"] = 1] = "Arc1";
	  HxLegGuidanceState[HxLegGuidanceState["Outbound"] = 2] = "Outbound";
	  HxLegGuidanceState[HxLegGuidanceState["Arc2"] = 3] = "Arc2";
	})(HxLegGuidanceState || (HxLegGuidanceState = {}));

	class HXLeg extends XFLeg {
	  // TODO consider different entries for initial state...
	  // TODO make protected when done with DebugHXLeg

	  /**
	   * Predicted tas for next prediction update
	   * Not including wind
	   */

	  /**
	   * Nominal TAS used for the current prediction
	   * Not including wind
	   */

	  /**
	   * Nominal ground speed used the current prediction
	   * including wind
	   */

	  /**
	   * Wind velocity along the inbound leg
	   */

	  /**
	   * Current predicted hippodrome geometry
	   */
	  constructor(fix, metadata, segment) {
	    super(fix);
	    this.metadata = metadata;
	    this.segment = segment;

	    _defineProperty(this, "state", HxLegGuidanceState.Inbound);

	    _defineProperty(this, "initialState", HxLegGuidanceState.Inbound);

	    _defineProperty(this, "termConditionMet", false);

	    _defineProperty(this, "nextPredictedTas", 180);

	    _defineProperty(this, "currentPredictedTas", 180);

	    _defineProperty(this, "currentPredictedGs", 180);

	    _defineProperty(this, "inboundWindSpeed", void 0);

	    _defineProperty(this, "geometry", void 0);

	    this.geometry = this.computeGeometry();
	  }

	  get inboundLegCourse() {
	    return this.fix.additionalData.course;
	  }

	  get outboundLegCourse() {
	    return (this.inboundLegCourse + 180) % 360;
	  }

	  get turnDirection() {
	    return this.fix.turnDirection;
	  }

	  get ident() {
	    return this.fix.ident;
	  }
	  /**
	   * Used by hold entry transition to set our initial state depending on entry type
	   * @param initialState
	   */


	  setInitialState(initialState) {
	    // TODO check if already active and deny...
	    this.state = initialState;
	    this.initialState = initialState;
	  }

	  get outboundStartPoint() {
	    const {
	      fixB
	    } = this.computeGeometry();
	    return fixB;
	  }

	  computeLegDistance() {
	    var _this$fix$legAltitude, _this$inboundWindSpee;

	    // is distance in NM?
	    if (this.fix.additionalData.distance !== undefined) {
	      return this.fix.additionalData.distance;
	    }

	    const alt = (_this$fix$legAltitude = this.fix.legAltitude1) !== null && _this$fix$legAltitude !== void 0 ? _this$fix$legAltitude : SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'); // distance is in time then...

	    const defaultMinutes = alt < 14000 ? 1 : 1.5;
	    const inboundGroundSpeed = this.currentPredictedTas + ((_this$inboundWindSpee = this.inboundWindSpeed) !== null && _this$inboundWindSpee !== void 0 ? _this$inboundWindSpee : 0);
	    return (this.fix.additionalData.distanceInMinutes !== undefined ? this.fix.additionalData.distanceInMinutes : defaultMinutes) * inboundGroundSpeed / 60;
	  }

	  computeGeometry() {
	    /*
	     * We define some fixes at the turning points around the hippodrome like so (mirror vertically for left turn):
	     *         A          B
	     *         *----------*
	     *       /              \
	     * arc1 |  *          *  | arc2
	     *       \              /
	     *         *<---------*
	     *      hold fix      C
	     */
	    const legLength = this.computeLegDistance();
	    const radius = this.radius;
	    const turnSign = this.turnDirection === TurnDirection.Left ? -1 : 1;
	    const fixA = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius * 2, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
	    const fixB = Avionics.Utils.bearingDistanceToCoordinates(this.outboundLegCourse, legLength, fixA.lat, fixA.long);
	    const fixC = Avionics.Utils.bearingDistanceToCoordinates(this.outboundLegCourse, legLength, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
	    const arcCentreFix1 = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius, this.fix.infos.coordinates.lat, this.fix.infos.coordinates.long);
	    const arcCentreFix2 = Avionics.Utils.bearingDistanceToCoordinates(this.inboundLegCourse + turnSign * 90, radius, fixC.lat, fixC.long);
	    return {
	      fixA,
	      fixB,
	      fixC,
	      arcCentreFix1,
	      arcCentreFix2,
	      sweepAngle: turnSign * 180,
	      legLength,
	      radius
	    };
	  }

	  get radius() {
	    const gsMs = this.currentPredictedGs / 1.94384;
	    const radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(this.currentPredictedTas, true) * Math.PI / 180)) / 1852;
	    return radius;
	  }

	  get terminationPoint() {
	    return this.fix.infos.coordinates;
	  }

	  get distance() {
	    return 0; // 0 so no PWPs
	  }

	  get inboundCourse() {
	    return this.inboundLegCourse;
	  }

	  get outboundCourse() {
	    return this.inboundLegCourse;
	  }

	  get startsInCircularArc() {
	    // this is intended to be used only for entry...
	    return this.state === HxLegGuidanceState.Arc1 || this.state === HxLegGuidanceState.Arc2;
	  }
	  /**
	   *
	   * @param tas
	   * @returns
	   */


	  getNominalRollAngle(gs) {
	    return this.endsInCircularArc ? maxBank(gs, true) : 0;
	  }

	  getDistanceToGoThisOrbit(ppos) {
	    const {
	      fixB,
	      arcCentreFix1,
	      arcCentreFix2,
	      sweepAngle
	    } = this.geometry;

	    switch (this.state) {
	      case HxLegGuidanceState.Inbound:
	        return courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);

	      case HxLegGuidanceState.Arc1:
	        return arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle) + this.computeLegDistance() * 2 + this.radius * Math.PI;

	      case HxLegGuidanceState.Outbound:
	        return courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB) + this.computeLegDistance() + this.radius * Math.PI;

	      case HxLegGuidanceState.Arc2:
	        return arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle) + this.computeLegDistance();
	      // no default
	    }

	    return 1;
	  }

	  getDistanceToGo(ppos) {
	    return this.getDistanceToGoThisOrbit(ppos);
	  }

	  getHippodromePath() {
	    const {
	      fixA,
	      fixB,
	      fixC,
	      arcCentreFix1,
	      arcCentreFix2,
	      sweepAngle
	    } = this.geometry;
	    return [{
	      type: PathVectorType.Arc,
	      startPoint: this.fix.infos.coordinates,
	      centrePoint: arcCentreFix1,
	      endPoint: fixA,
	      sweepAngle
	    }, {
	      type: PathVectorType.Line,
	      startPoint: fixA,
	      endPoint: fixB
	    }, {
	      type: PathVectorType.Arc,
	      startPoint: fixB,
	      centrePoint: arcCentreFix2,
	      endPoint: fixC,
	      sweepAngle
	    }, {
	      type: PathVectorType.Line,
	      startPoint: fixC,
	      endPoint: this.fix.infos.coordinates
	    }];
	  }

	  get predictedPath() {
	    return this.getHippodromePath();
	  }

	  updateState(ppos, tas, geometry) {
	    let dtg = 0; // TODO divide up into sectors and choose based on that?

	    switch (this.state) {
	      case HxLegGuidanceState.Inbound:
	        {
	          dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
	          break;
	        }

	      case HxLegGuidanceState.Arc1:
	        {
	          dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, geometry.arcCentreFix1, geometry.sweepAngle);
	          break;
	        }

	      case HxLegGuidanceState.Outbound:
	        {
	          dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, geometry.fixB);
	          break;
	        }

	      case HxLegGuidanceState.Arc2:
	        {
	          dtg = arcDistanceToGo(ppos, geometry.fixB, geometry.arcCentreFix2, geometry.sweepAngle);
	          break;
	        }

	      default:
	        throw new Error("Bad HxLeg state ".concat(this.state));
	    }

	    if (dtg <= 0) {
	      if (this.state === HxLegGuidanceState.Inbound) {
	        if (this.termConditionMet) {
	          return;
	        }

	        this.updatePrediction();
	      }

	      this.state = (this.state + 1) % (HxLegGuidanceState.Arc2 + 1);
	      console.log("HX switched to state ".concat(HxLegGuidanceState[this.state]));
	    }
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    const {
	      fixB,
	      arcCentreFix1,
	      arcCentreFix2,
	      sweepAngle,
	      legLength
	    } = this.geometry;
	    this.updateState(ppos, tas, this.geometry);
	    let params;
	    let dtg;
	    let nextPhi = 0;
	    let rad = 0;

	    switch (this.state) {
	      case HxLegGuidanceState.Inbound:
	        params = courseToFixGuidance(ppos, trueTrack, this.inboundLegCourse, this.fix.infos.coordinates);
	        dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
	        nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
	        rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
	        break;

	      case HxLegGuidanceState.Arc1:
	        params = arcGuidance(ppos, trueTrack, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
	        dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
	        rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);

	        if (legLength <= rad) {
	          nextPhi = params.phiCommand;
	        }

	        break;

	      case HxLegGuidanceState.Outbound:
	        params = courseToFixGuidance(ppos, trueTrack, this.outboundLegCourse, fixB);
	        dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB);
	        nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
	        rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
	        break;

	      case HxLegGuidanceState.Arc2:
	        params = arcGuidance(ppos, trueTrack, fixB, arcCentreFix2, sweepAngle);
	        dtg = arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle);
	        rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);

	        if (legLength <= rad) {
	          nextPhi = params.phiCommand;
	        }

	        break;

	      default:
	        throw new Error("Bad HxLeg state ".concat(this.state));
	    } // TODO HF/HA too


	    if (dtg <= rad && !(this.state === HxLegGuidanceState.Inbound && this.termConditionMet)) {
	      params.phiCommand = nextPhi;
	    }

	    return params;
	  }

	  recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack, _startAltitude, _verticalSpeed) {
	    if (!isActive) {
	      this.updatePrediction();
	    }
	  }

	  setPredictedTas(tas) {
	    this.nextPredictedTas = tas;
	  }
	  /**
	   * Should be called on each crossing of the hold fix
	   */


	  updatePrediction() {
	    const windDirection = SimVar.GetSimVarValue('AMBIENT WIND DIRECTION', 'Degrees');
	    const windSpeed = SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', 'Knots');
	    const windAngleToInbound = Math.abs(Avionics.Utils.diffAngle(reciprocal(windDirection), this.inboundLegCourse));
	    this.inboundWindSpeed = Math.cos(windAngleToInbound * Math.PI / 180) * windSpeed;
	    this.currentPredictedTas = this.nextPredictedTas;
	    this.currentPredictedGs = this.currentPredictedTas + windSpeed;
	    this.geometry = this.computeGeometry(); // TODO update entry transition too
	  } // TODO are we even using this? What exactly should it tell us?


	  isAbeam(_ppos) {
	    return false;
	  }

	  getPathStartPoint() {
	    return this.fix.infos.coordinates;
	  }

	  getPathEndPoint() {
	    // TODO consider early exit to CF on HF leg
	    return this.fix.infos.coordinates;
	  }

	}

	class HMLeg extends HXLeg {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "immExitLength", void 0);
	  }

	  /**
	   * Use for IMM EXIT set/reset function on the MCDU
	   * Note: if IMM EXIT is set before this leg is active it should be deleted from the f-pln instead
	   * @param
	   */
	  setImmediateExit(exit, ppos, tas) {
	    // TODO if we're still in the entry transition, HM becomes empty, but still fly the entry
	    const {
	      legLength,
	      fixA,
	      sweepAngle
	    } = this.geometry;

	    if (exit) {
	      switch (this.state) {
	        case HxLegGuidanceState.Arc1:
	          // let's do a circle
	          this.immExitLength = 0;
	          break;

	        case HxLegGuidanceState.Outbound:
	          const nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
	          const rad = Geometry.getRollAnticipationDistance(tas, 0, nextPhi);
	          this.immExitLength = Math.min(legLength, rad + courseToFixDistanceToGo(ppos, this.inboundLegCourse, fixA));
	          break;

	        case HxLegGuidanceState.Arc2:
	        case HxLegGuidanceState.Inbound:
	          // keep the normal leg distance as we can't shorten
	          this.immExitLength = legLength;
	          break;
	        // no default
	      }
	    } // hack to allow f-pln page to see state


	    this.fix.additionalData.immExit = exit;
	    this.termConditionMet = exit; // if resuming hold, the geometry will be recomputed on the next pass of the hold fix

	    if (exit) {
	      this.geometry = this.computeGeometry();
	    }
	  }

	  computeLegDistance() {
	    if (this.termConditionMet) {
	      return this.immExitLength;
	    }

	    return super.computeLegDistance();
	  }

	  get disableAutomaticSequencing() {
	    return !this.termConditionMet;
	  }

	  get repr() {
	    return "HM '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection]);
	  }

	} // TODO

	/*
	If the aircraft reaches or exceeds the altitude
	specified in the flight plan before the HA leg is active, the aircraft
	does not enter the hold
	*/

	class HALeg extends HXLeg {
	  constructor(to, metadata, segment) {
	    super(to, metadata, segment); // the term altitude is guaranteed to be at or above, and in field altitude1, by ARINC424 coding rules

	    this.to = to;
	    this.metadata = metadata;
	    this.segment = segment;

	    _defineProperty(this, "targetAltitude", void 0);

	    if (this.fix.legAltitudeDescription !== AltitudeDescriptor.AtOrAbove) {
	      console.warn("HALeg invalid altitude descriptor ".concat(this.fix.legAltitudeDescription, ", must be ").concat(AltitudeDescriptor.AtOrAbove));
	    }

	    this.targetAltitude = this.fix.legAltitude1;
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    if (SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') >= this.targetAltitude) {
	      this.termConditionMet = true;
	    }

	    return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
	  }

	  recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
	    if (SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet') >= this.targetAltitude) {
	      this.termConditionMet = true;
	    }

	    if (!isActive && this.termConditionMet) {
	      this.isNull = true;
	    }

	    this.setPredictedTas(tas);
	    super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
	  }

	  getDistanceToGo(ppos) {
	    if (this.isNull) {
	      return 0;
	    }

	    if (this.termConditionMet) {
	      return this.getDistanceToGoThisOrbit(ppos);
	    }

	    const {
	      legLength,
	      radius
	    } = this.geometry;
	    return legLength * 2 + radius * Math.PI * 2;
	  }

	  get disableAutomaticSequencing() {
	    return !this.termConditionMet;
	  }

	  get predictedPath() {
	    if (!this.isNull) {
	      return super.predictedPath;
	    }

	    return [];
	  }

	  get repr() {
	    return "HA '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection], " - ").concat(this.targetAltitude.toFixed(0));
	  }

	}
	class HFLeg extends HXLeg {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "entryTransition", void 0);
	  }

	  getGuidanceParameters(ppos, trueTrack, tas, gs) {
	    if (this.entryTransition) {
	      this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === EntryState.Capture || this.entryTransition.state === EntryState.Done;
	    }

	    return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
	  }

	  recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
	    if (this.inboundGuidable instanceof HoldEntryTransition) {
	      this.entryTransition = this.inboundGuidable;
	      this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === EntryState.Capture || this.entryTransition.state === EntryState.Done;
	    }

	    this.setPredictedTas(tas);
	    super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
	  }

	  getDistanceToGo(ppos) {
	    var _this$entryTransition, _this$entryTransition2;

	    return (_this$entryTransition = (_this$entryTransition2 = this.entryTransition) === null || _this$entryTransition2 === void 0 ? void 0 : _this$entryTransition2.getDistanceToGo(ppos)) !== null && _this$entryTransition !== void 0 ? _this$entryTransition : 0;
	  }

	  get predictedPath() {
	    return [];
	  }

	  get disableAutomaticSequencing() {
	    return false;
	  }

	  get repr() {
	    return "HF '".concat(this.fix.ident, "' ").concat(TurnDirection[this.turnDirection]);
	  }

	}

	//  Copyright (c) 2021 FlyByWire Simulations
	//  SPDX-License-Identifier: GPL-3.0

	/**
	 * Types that tie pseudo waypoints to sequencing actions
	 */
	let PseudoWaypointSequencingAction;

	(function (PseudoWaypointSequencingAction) {
	  PseudoWaypointSequencingAction[PseudoWaypointSequencingAction["TOD_REACHED"] = 0] = "TOD_REACHED";
	  PseudoWaypointSequencingAction[PseudoWaypointSequencingAction["APPROACH_PHASE_AUTO_ENGAGE"] = 1] = "APPROACH_PHASE_AUTO_ENGAGE";
	})(PseudoWaypointSequencingAction || (PseudoWaypointSequencingAction = {}));

	// Copyright (c) 2021-2022 FlyByWire Simulations
	// Copyright (c) 2021-2022 Synaptic Simulations
	//
	// SPDX-License-Identifier: GPL-3.0
	let VnavDescentMode;

	(function (VnavDescentMode) {
	  VnavDescentMode[VnavDescentMode["NORMAL"] = 0] = "NORMAL";
	  VnavDescentMode[VnavDescentMode["CDA"] = 1] = "CDA";
	  VnavDescentMode[VnavDescentMode["DPO"] = 2] = "DPO";
	})(VnavDescentMode || (VnavDescentMode = {}));

	({
	  /**
	   * VNAV descent calculation mode (NORMAL, CDA or DPO)
	   */
	  VNAV_DESCENT_MODE: VnavDescentMode.NORMAL,

	  /**
	   * Whether to emit CDA flap1/2 pseudo-waypoints (only if VNAV_DESCENT_MODE is CDA)
	   */
	  VNAV_EMIT_CDA_FLAP_PWP: false,
	  DEBUG_PROFILE: false,
	  VNAV_USE_LATCHED_DESCENT_MODE: false,

	  /**
	   * Percent N1 to add to the predicted idle N1. The real aircraft does also use a margin for this, but I don't know how much
	   */
	  IDLE_N1_MARGIN: 3
	});

	//  Copyright (c) 2021 FlyByWire Simulations
	//  SPDX-License-Identifier: GPL-3.0
	const rangeSettings = [10, 20, 40, 80, 160, 320];
	let Mode;

	(function (Mode) {
	  Mode[Mode["ROSE_ILS"] = 0] = "ROSE_ILS";
	  Mode[Mode["ROSE_VOR"] = 1] = "ROSE_VOR";
	  Mode[Mode["ROSE_NAV"] = 2] = "ROSE_NAV";
	  Mode[Mode["ARC"] = 3] = "ARC";
	  Mode[Mode["PLAN"] = 4] = "PLAN";
	})(Mode || (Mode = {}));

	let EfisOption;

	(function (EfisOption) {
	  EfisOption[EfisOption["None"] = 0] = "None";
	  EfisOption[EfisOption["Constraints"] = 1] = "Constraints";
	  EfisOption[EfisOption["VorDmes"] = 2] = "VorDmes";
	  EfisOption[EfisOption["Waypoints"] = 3] = "Waypoints";
	  EfisOption[EfisOption["Ndbs"] = 4] = "Ndbs";
	  EfisOption[EfisOption["Airports"] = 5] = "Airports";
	})(EfisOption || (EfisOption = {}));

	let NdSymbolTypeFlags;

	(function (NdSymbolTypeFlags) {
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Vor"] = 1] = "Vor";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["VorDme"] = 2] = "VorDme";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Ndb"] = 4] = "Ndb";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Waypoint"] = 8] = "Waypoint";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Airport"] = 16] = "Airport";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Runway"] = 32] = "Runway";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Tuned"] = 64] = "Tuned";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["ActiveLegTermination"] = 128] = "ActiveLegTermination";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["EfisOption"] = 256] = "EfisOption";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Dme"] = 512] = "Dme";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["Constraint"] = 1024] = "Constraint";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["FixInfo"] = 2048] = "FixInfo";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlan"] = 4096] = "FlightPlan";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlanVectorLine"] = 8192] = "FlightPlanVectorLine";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlanVectorArc"] = 16384] = "FlightPlanVectorArc";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["FlightPlanVectorDebugPoint"] = 32768] = "FlightPlanVectorDebugPoint";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["ActiveFlightPlanVector"] = 65536] = "ActiveFlightPlanVector";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["CourseReversalLeft"] = 131072] = "CourseReversalLeft";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["CourseReversalRight"] = 262144] = "CourseReversalRight";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpDecel"] = 524288] = "PwpDecel";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpTopOfDescent"] = 1048576] = "PwpTopOfDescent";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpSpeedChange"] = 2097152] = "PwpSpeedChange";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpClimbLevelOff"] = 4194304] = "PwpClimbLevelOff";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpDescentLevelOff"] = 8388608] = "PwpDescentLevelOff";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpStartOfClimb"] = 16777216] = "PwpStartOfClimb";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpInterceptProfile"] = 33554432] = "PwpInterceptProfile";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpTimeMarker"] = 67108864] = "PwpTimeMarker";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpCdaFlap1"] = 134217728] = "PwpCdaFlap1";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["PwpCdaFlap2"] = 268435456] = "PwpCdaFlap2";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["CyanColor"] = 536870912] = "CyanColor";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["AmberColor"] = 1073741824] = "AmberColor";
	  NdSymbolTypeFlags[NdSymbolTypeFlags["MagentaColor"] = -2147483648] = "MagentaColor";
	})(NdSymbolTypeFlags || (NdSymbolTypeFlags = {}));

	/**
	 * Possible flight plan vector groups to be transmitted to the ND.
	 *
	 * **NOTE:** this does not necessarily represent the current function of a transmitted flight plan. Those groups are sometimes used for other purposes than their name
	 * refers to, for example the DASHED flight plan being used to transmit the non-offset path of an active flight plan with an offset applied.
	 */
	let EfisVectorsGroup;

	(function (EfisVectorsGroup) {
	  EfisVectorsGroup[EfisVectorsGroup["ACTIVE"] = 0] = "ACTIVE";
	  EfisVectorsGroup[EfisVectorsGroup["DASHED"] = 1] = "DASHED";
	  EfisVectorsGroup[EfisVectorsGroup["OFFSET"] = 2] = "OFFSET";
	  EfisVectorsGroup[EfisVectorsGroup["TEMPORARY"] = 3] = "TEMPORARY";
	  EfisVectorsGroup[EfisVectorsGroup["SECONDARY"] = 4] = "SECONDARY";
	  EfisVectorsGroup[EfisVectorsGroup["SECONDARY_DASHED"] = 5] = "SECONDARY_DASHED";
	  EfisVectorsGroup[EfisVectorsGroup["MISSED"] = 6] = "MISSED";
	  EfisVectorsGroup[EfisVectorsGroup["ALTERNATE"] = 7] = "ALTERNATE";
	  EfisVectorsGroup[EfisVectorsGroup["ACTIVE_EOSID"] = 8] = "ACTIVE_EOSID";
	})(EfisVectorsGroup || (EfisVectorsGroup = {}));

	let FlapConf;

	(function (FlapConf) {
	  FlapConf[FlapConf["CLEAN"] = 0] = "CLEAN";
	  FlapConf[FlapConf["CONF_1"] = 1] = "CONF_1";
	  FlapConf[FlapConf["CONF_2"] = 2] = "CONF_2";
	  FlapConf[FlapConf["CONF_3"] = 3] = "CONF_3";
	  FlapConf[FlapConf["CONF_FULL"] = 4] = "CONF_FULL";
	})(FlapConf || (FlapConf = {}));

	let AccelFactorMode;

	(function (AccelFactorMode) {
	  AccelFactorMode[AccelFactorMode["CONSTANT_CAS"] = 0] = "CONSTANT_CAS";
	  AccelFactorMode[AccelFactorMode["CONSTANT_MACH"] = 1] = "CONSTANT_MACH";
	})(AccelFactorMode || (AccelFactorMode = {}));

	let VerticalWaypointType;

	(function (VerticalWaypointType) {
	  VerticalWaypointType[VerticalWaypointType["CRZ"] = 0] = "CRZ";
	  VerticalWaypointType[VerticalWaypointType["CLB"] = 1] = "CLB";
	  VerticalWaypointType[VerticalWaypointType["DES"] = 2] = "DES";
	})(VerticalWaypointType || (VerticalWaypointType = {}));

	class Common {
	  /**
	   * Calculates ISA temperature as a function of altitude
	   * @param alt in feet
	   * @param aboveTropo boolean
	   * @returns ISA temperature in celsius
	   */
	  static getIsaTemp(alt) {
	    let aboveTropo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (aboveTropo) {
	      return -56.5;
	    }

	    return 15 - 0.0019812 * alt;
	  }

	  static getTemp(alt) {
	    let isaDev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    let aboveTropo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    if (aboveTropo) {
	      return -56.5 + isaDev;
	    }

	    return 15 - 0.0019812 * alt + isaDev;
	  }
	  /**
	   * Get temperature ratio for a particular altitude (below tropopause)
	   * @param alt pressure altitude
	   * @param isaDev ISA deviation in celsius
	   * @param aboveTropo whether the aircraft is above the tropopause
	   * @returns temperature ratio
	   */


	  static getTheta(alt) {
	    let isaDev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    let aboveTropo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    if (aboveTropo) {
	      return (216.65 + isaDev) / 288.15;
	    }

	    return (288.15 - 0.0019812 * alt + isaDev) / 288.15;
	  }
	  /**
	   * Get temperature ratio for a particular altitude and mach.
	   * @param theta temperature ratio (from only altitude)
	   * @param mach mach
	   * @returns temperature ratio
	   */


	  static getTheta2(theta, mach) {
	    return theta * (1 + 0.2 * mach ** 2);
	  }
	  /**
	   * Get pressure ratio for a particular altitude
	   * @param alt pressure altitude
	   * @param aboveTropo whether the aircraft is above the tropopause
	   * @returns pressure ratio
	   */


	  static getDelta(alt) {
	    let aboveTropo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    if (aboveTropo && alt !== undefined) {
	      return 0.22336 * Math.exp((36089.24 - alt) / 20805.7);
	    }

	    return this.getTheta(alt, 0, aboveTropo) ** 5.25588;
	  }
	  /**
	   * Get pressure ratio for a particular theta and mach
	   * @param delta pressure ratio (from only theta)
	   * @param mach mach
	   * @returns pressure ratio
	   */


	  static getDelta2(delta, mach) {
	    return delta * (1 + 0.2 * mach ** 2) ** 3.5;
	  }
	  /**
	   * Get KTAS value from mach
	   * @param mach
	   * @param theta
	   * @returns speed in KTAS (knots true airspeed)
	   */


	  static machToTAS(mach, theta) {
	    return 661.4786 * mach * Math.sqrt(theta);
	  }

	  static machToEAS(mach, delta) {
	    return 661.4786 * mach * Math.sqrt(delta);
	  }

	  static CAStoMach(cas, delta) {
	    const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
	    const term2 = 1 / delta * (term1 ** 3.5 - 1);
	    const term3 = 5 * ((term2 + 1) ** (1 / 3.5) - 1);
	    return Math.sqrt(term3);
	  }

	  static machToCas(mach, delta) {
	    const term1 = (0.2 * mach ** 2 + 1) ** 3.5;
	    const term2 = (delta * (term1 - 1) + 1) ** (1 / 3.5) - 1;
	    return 1479.1 * Math.sqrt(term2);
	  }

	  static TAStoCAS(tas, theta, delta) {
	    const term1 = 1 + 1 / theta * (tas / 1479.1) ** 2;
	    const term2 = delta * (term1 ** 3.5 - 1) + 1;
	    const term3 = term2 ** (1 / 3.5) - 1;
	    return 1479.1 * Math.sqrt(term3);
	  }

	  static CAStoTAS(cas, theta, delta) {
	    const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
	    const term2 = 1 / delta * (term1 ** 3.5 - 1);
	    const term3 = theta * ((term2 + 1) ** (1 / 3.5) - 1);
	    return 1479.1 * Math.sqrt(term3);
	  }

	  static CAStoEAS(cas, delta) {
	    const term1 = 1 + 0.2 * (cas / 661.4786) ** 2;
	    const term2 = 1 / delta * (term1 ** 3.5 - 1);
	    const term3 = delta * ((term2 + 1) ** (1 / 3.5) - 1);
	    return 1479.1 * Math.sqrt(term3);
	  }

	  static getAccelFactorCAS(mach, aboveTropo, tempRatio) {
	    const phi = ((1 + 0.2 * mach ** 2) ** 3.5 - 1) / (0.7 * mach ** 2 * (1 + 0.2 * mach ** 2) ** 2.5);

	    if (aboveTropo) {
	      return 1 + 0.7 * mach ** 2 * phi;
	    }

	    return 1 + 0.7 * mach ** 2 * (phi - 0.190263 * tempRatio);
	  }

	  static getAccelFactorMach(mach, aboveTropo, tempRatio) {
	    if (aboveTropo) {
	      return 1;
	    }

	    return 1 - 0.13318 * mach ** 2 * tempRatio;
	  }
	  /**
	   * Placeholder
	   * @param mach
	   * @param temp
	   * @param stdTemp
	   * @param aboveTropo
	   * @param accelFactorMode
	   * @returns
	   */


	  static getAccelerationFactor(mach, altitude, isaDev, aboveTropo, accelFactorMode) {
	    // This is T_ISA / T, the ratio between ISA temperature at that altitude and the actual temperature at that altitude
	    const tempRatio = (273.15 + this.getIsaTemp(altitude, aboveTropo)) / (273.15 + this.getTemp(altitude, isaDev, aboveTropo));

	    if (accelFactorMode === AccelFactorMode.CONSTANT_CAS) {
	      return Common.getAccelFactorCAS(mach, aboveTropo, tempRatio);
	    }

	    return Common.getAccelFactorMach(mach, aboveTropo, tempRatio);
	  }

	  static interpolate(x, x0, x1, y0, y1) {
	    return (y0 * (x1 - x) + y1 * (x - x0)) / (x1 - x0);
	  }

	  static poundsToMetricTons(pounds) {
	    return pounds / 2204.6;
	  }

	}

	let ManagedSpeedType;

	(function (ManagedSpeedType) {
	  ManagedSpeedType[ManagedSpeedType["Climb"] = 0] = "Climb";
	  ManagedSpeedType[ManagedSpeedType["Cruise"] = 1] = "Cruise";
	  ManagedSpeedType[ManagedSpeedType["Descent"] = 2] = "Descent";
	})(ManagedSpeedType || (ManagedSpeedType = {}));

	class EngineModel {
	  // In pounds of force. Used as a multiplier for results of table 1506

	  /**
	   * Maximum N1 in CLB thrust
	   * @param i row index (tat) in steps of 4C
	   * @param j col index (pressure altitude)
	   * @returns Corrected N1 (CN1)
	   */

	  /**
	   * Table 1502 - CN2 vs CN1 @ Mach 0, 0.2, 0.9
	   * n2_to_n1_table
	   * @param i row index (n2)
	   * @param j 1 = Mach 0, 2 = Mach 0.2, 3 = Mach 0.9
	   * @returns Corrected N1 (CN1)
	   */

	  /**
	   * Table 1503 - Turbine LoMach (0) CN2 vs. Throttle @ IAP Ratio 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313
	   * mach_0_corrected_commanded_ne_table
	   * @param i row index (thrust lever position)
	   * @param j IAP ratio
	   * @returns Corrected N2 (CN2)
	   */

	  /**
	   * Table 1504 - Turbine HiMach (0.9) CN2 vs. Throttle @ IAP Ratio 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313
	   * mach_hi_corrected_commanded_ne_table
	   * @param i row index (thrust lever position)
	   * @param j IAP ratio
	   * @returns Corrected N2 (CN2)
	   */

	  /**
	   * Table 1506 - Corrected net Thrust vs CN1 @ Mach 0 to 0.9 in 0.1 steps
	   * n1_and_mach_on_thrust_table
	   * @param i row index (CN1)
	   * @param j mach
	   * @returns Corrected net thrust (pounds of force)
	   */

	  /**
	   * Placeholder
	   * @param table
	   * @param i
	   * @param j
	   * @returns
	   */
	  static tableInterpolation(table, i, j) {
	    const numRows = table.length;
	    const numCols = table[0].length; // Iterate through rows to find the upper bound to i

	    let r;

	    for (r = 1; r < numRows; r++) {
	      if (table[r][0] > i) {
	        break;
	      }
	    } // Get lower bound to i


	    const r1 = Math.max(1, r - 1);
	    const r2 = Math.min(numRows - 1, r); // Iterate through rows to find the upper bound to j

	    let c;

	    for (c = 1; c < numCols; c++) {
	      if (table[0][c] > j) {
	        break;
	      }
	    } // Get the lower bound to j


	    const c1 = Math.max(1, c - 1);
	    const c2 = Math.min(numCols - 1, c);
	    const interpolatedRowAtC1 = r1 === r2 ? table[r1][c1] : Common.interpolate(i, table[r1][0], table[r2][0], table[r1][c1], table[r2][c1]);
	    const interpolatedRowAtC2 = r1 === r2 ? table[r1][c2] : Common.interpolate(i, table[r1][0], table[r2][0], table[r1][c2], table[r2][c2]);

	    if (c1 === c2) {
	      return interpolatedRowAtC1;
	    }

	    return Common.interpolate(j, table[0][c1], table[0][c2], interpolatedRowAtC1, interpolatedRowAtC2);
	  }
	  /**
	   * Retrieve a bilinear interpolated row value from a table
	   * @param table
	   * @param j Value on column axis
	   * @param result Value normally returned as result
	   */


	  static reverseTableInterpolation(table, j, result) {
	    const numRows = table.length;
	    const numCols = table[0].length;
	    let c;

	    for (c = 1; c < numCols; c++) {
	      if (table[0][c] > j) {
	        break;
	      }
	    }

	    const c1 = Math.max(1, c - 1);
	    const c2 = Math.min(numCols - 1, c);
	    let r;

	    for (r = 1; r < numRows; r++) {
	      if (table[r][c1] > result) {
	        break;
	      }
	    }

	    const r1 = Math.max(1, r - 1);
	    const r2 = Math.min(numRows - 1, r);

	    for (r = 1; r < numRows; r++) {
	      if (table[r][c2] > result) {
	        break;
	      }
	    }

	    const r3 = Math.max(1, r - 1);
	    const r4 = Math.min(numRows - 1, r);
	    const interpolatedRowAtC1 = r1 === r2 ? table[r1][0] : Common.interpolate(result, table[r1][c1], table[r2][c1], table[r1][0], table[r2][0]);
	    const interpolatedRowAtC2 = r3 === r4 ? table[r3][0] : Common.interpolate(result, table[r3][c2], table[r4][c2], table[r3][0], table[r4][0]);
	    return Common.interpolate(j, table[0][c1], table[0][c2], interpolatedRowAtC1, interpolatedRowAtC2);
	  }
	  /**
	   * Placeholder
	   * @param cn1 corrected N1 %
	   * @param mach mach value
	   * @param alt altitude in feet
	   * @returns fuel flow, in pounds per hour (per engine)
	   */


	  static getCorrectedFuelFlow(cn1, mach, alt) {
	    const coefficients = [-639.6602981, 0.00000e+00, 1.03705e+02, -2.23264e+03, 5.70316e-03, -2.29404e+00, 1.08230e+02, 2.77667e-04, -6.17180e+02, -7.20713e-02, 2.19013e-07, 2.49418e-02, -7.31662e-01, -1.00003e-05, -3.79466e+01, 1.34552e-03, 5.72612e-09, -2.71950e+02, 8.58469e-02, -2.72912e-06, 2.02928e-11];
	    const flow = coefficients[0] + coefficients[1] + coefficients[2] * cn1 + coefficients[3] * mach + coefficients[4] * alt + coefficients[5] * cn1 ** 2 + coefficients[6] * cn1 * mach + coefficients[7] * cn1 * alt + coefficients[8] * mach ** 2 + coefficients[9] * mach * alt + coefficients[10] * alt ** 2 + coefficients[11] * cn1 ** 3 + coefficients[12] * cn1 ** 2 * mach + coefficients[13] * cn1 ** 2 * alt + coefficients[14] * cn1 * mach ** 2 + coefficients[15] * cn1 * mach * alt + coefficients[16] * cn1 * alt ** 2 + coefficients[17] * mach ** 3 + coefficients[18] * mach ** 2 * alt + coefficients[19] * mach * alt ** 2 + coefficients[20] * alt ** 3;
	    return flow;
	  } // static getCN1fromUncorrectedThrust(thrust: number)


	  static getCorrectedN1(n1, theta2) {
	    return n1 / Math.sqrt(theta2);
	  }

	  static getUncorrectedN1(cn1, theta2) {
	    return cn1 * Math.sqrt(theta2);
	  }

	  static getUncorrectedN2(cn2, theta2) {
	    return cn2 * Math.sqrt(theta2);
	  }

	  static getUncorrectedThrust(correctedThrust, delta2) {
	    return correctedThrust * delta2;
	  }

	  static getUncorrectedFuelFlow(correctedFuelFlow, delta2, theta2) {
	    return correctedFuelFlow * delta2 * Math.sqrt(theta2);
	  }

	  static getCorrectedThrust(uncorrectedThrust, delta2) {
	    return uncorrectedThrust / delta2;
	  }

	  static getIdleN1(altitude, mach) {
	    const delta = Common.getDelta(altitude);
	    const iap = 1 / delta;
	    const theta = Common.getTheta(altitude, 0);
	    const theta2 = Common.getTheta2(theta, mach);
	    const lowMachCn2 = EngineModel.tableInterpolation(EngineModel.table1503, 0, iap);
	    const highMachCn2 = EngineModel.tableInterpolation(EngineModel.table1504, 0, iap);
	    const cn2 = Common.interpolate(mach, 0, 0.9, lowMachCn2, highMachCn2);
	    const cn1 = EngineModel.tableInterpolation(EngineModel.table1502, cn2, mach);
	    const n1 = cn1 * Math.sqrt(theta2);
	    return n1;
	  }

	}

	_defineProperty(EngineModel, "maxThrust", 27120);

	_defineProperty(EngineModel, "maxClimbThrustTableLeap", [[0, 2000, 5000, 8000, 12000, 15000, 17000, 20000, 24000, 27000, 31000, 35000, 39000, 41500], [-54.0, 71.8, 73.6, 75.5, 76.8, 78.1, 78.9, 80.1, 81.5, 81.6, 83.0, 83.6, 83.7, 83.3], [-50.0, 72.5, 74.3, 76.2, 77.5, 78.8, 79.6, 80.9, 82.2, 82.4, 83.8, 84.4, 84.5, 84.0], [-46.0, 73.1, 75.0, 76.9, 78.2, 79.5, 80.3, 81.6, 83.0, 83.1, 84.5, 85.1, 85.3, 84.8], [-42.0, 73.8, 75.6, 77.6, 78.9, 80.2, 81.0, 82.3, 83.7, 83.8, 85.3, 85.9, 86.0, 85.5], [-38.0, 74.4, 76.3, 78.2, 79.6, 80.9, 81.7, 83.0, 84.4, 84.6, 86.0, 86.6, 86.7, 86.3], [-34.0, 75.0, 76.9, 78.9, 80.3, 81.6, 82.4, 83.7, 85.1, 85.3, 86.7, 87.3, 87.5, 87.0], [-30.0, 75.7, 77.6, 79.6, 80.9, 82.2, 83.1, 84.4, 85.8, 86.0, 87.5, 88.1, 88.2, 87.7], [-26.0, 76.3, 78.2, 80.2, 81.6, 82.9, 83.8, 85.1, 86.5, 86.7, 88.2, 88.8, 88.9, 88.4], [-22.0, 76.9, 78.8, 80.9, 82.2, 83.6, 84.4, 85.8, 87.2, 87.4, 88.9, 89.5, 89.6, 89.1], [-18.0, 77.5, 79.5, 81.5, 82.9, 84.2, 85.1, 86.5, 87.9, 88.1, 89.6, 90.2, 90.0, 89.5], [-14.0, 78.1, 80.1, 82.1, 83.5, 84.9, 85.8, 87.1, 88.6, 88.8, 90.3, 90.0, 89.2, 88.7], [-10.0, 78.7, 80.7, 82.8, 84.2, 85.6, 86.4, 87.8, 89.3, 89.5, 91.0, 89.2, 88.4, 87.9], [-6.0, 79.3, 81.3, 83.4, 84.8, 86.2, 87.1, 88.5, 90.0, 90.1, 91.1, 88.5, 87.7, 87.1], [-2.0, 79.9, 81.9, 84.0, 85.5, 86.8, 87.7, 89.1, 90.6, 90.8, 90.2, 87.7, 86.9, 86.4], [2.0, 80.5, 82.5, 84.6, 86.1, 87.5, 88.4, 89.8, 91.3, 90.3, 89.5, 87.0, 86.2, 85.6], [6.0, 81.1, 83.1, 85.3, 86.7, 88.1, 89.0, 90.4, 90.5, 89.5, 88.8, 86.3, 85.5, 84.9], [10.0, 81.6, 83.7, 85.9, 87.3, 88.7, 89.7, 90.0, 89.6, 88.7, 88.1, 85.6, 84.8, 84.2], [14.0, 82.2, 84.3, 86.5, 87.9, 89.4, 89.3, 89.1, 88.7, 87.9, 87.5, 84.8, 83.9, 83.3], [18.0, 82.8, 84.9, 87.1, 88.5, 88.6, 88.4, 88.3, 87.9, 87.2, 86.8, 86.8, 86.8, 86.8], [22.0, 83.4, 85.5, 86.9, 88.0, 87.8, 87.7, 87.5, 87.2, 86.5, 86.1, 86.1, 86.1, 86.1], [26.0, 83.9, 85.7, 86.2, 87.2, 87.1, 87.0, 86.8, 86.5, 85.8, 85.4, 85.4, 85.4, 85.4], [30.0, 84.5, 84.9, 85.4, 86.5, 86.4, 86.3, 86.1, 85.8, 85.1, 85.1, 85.1, 85.1, 85.1], [34.0, 83.8, 84.2, 84.7, 85.8, 85.7, 85.6, 85.5, 85.1, 85.1, 85.1, 85.1, 85.1, 85.1], [38.0, 83.0, 83.4, 83.9, 85.1, 85.0, 84.9, 84.8, 84.8, 84.8, 84.8, 84.8, 84.8, 84.8], [42.0, 82.2, 82.6, 83.1, 84.4, 84.4, 84.3, 84.3, 84.3, 84.3, 84.3, 84.3, 84.3, 84.3], [46.0, 81.4, 81.8, 82.4, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7, 83.7], [50.0, 80.6, 81.1, 81.6, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0, 83.0], [54.0, 79.9, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4, 80.4], [58.0, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2, 79.2]]);

	_defineProperty(EngineModel, "table1502", [[0, 0, 0.2, 0.9], [18.200000, 0.000000, 0.000000, 17.000000], [22.000000, 1.900000, 1.900000, 17.400000], [26.000000, 2.500000, 2.500000, 18.200000], [57.000000, 12.800000, 12.800000, 27.000000], [68.200000, 19.600000, 19.600000, 34.827774], [77.000000, 26.000000, 26.000000, 40.839552], [83.000000, 31.420240, 31.420240, 44.768766], [89.000000, 40.972041, 40.972041, 50.092140], [92.800000, 51.000000, 51.000000, 55.042000], [97.000000, 65.000000, 65.000000, 65.000000], [100.000000, 77.000000, 77.000000, 77.000000], [104.000000, 85.000000, 85.000000, 85.500000], [116.500000, 101.000000, 101.000000, 101.000000]]);

	_defineProperty(EngineModel, "table1503", [[0, 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313], [0.000000, 68.200000, 69.402657, 70.671269, 73.432244, 76.544349, 78.644882, 78.644882], [0.100000, 76.000000, 77.340205, 78.753906, 81.830654, 85.298688, 87.639458, 87.639458], [0.200000, 83.000000, 84.463645, 86.007556, 89.367688, 93.155146, 95.711513, 95.711513], [0.400000, 92.800000, 94.436461, 96.162664, 99.919535, 104.154188, 107.012390, 107.012390], [0.600000, 98.000000, 99.728159, 101.551090, 105.518475, 109.990414, 113.008774, 113.008774], [0.750000, 101.500000, 103.289879, 105.177914, 109.286991, 113.918643, 117.044802, 117.044802], [0.900000, 103.000000, 104.816330, 106.000000, 110.902070, 115.602170, 118.774528, 118.774528], [1.000000, 104.200000, 106.037491, 107.975750, 112.194133, 116.948991, 120.158309, 120.158309]]);

	_defineProperty(EngineModel, "table1504", [[0, 1.00000000, 1.20172257, 1.453783983, 2.175007333, 3.364755652, 4.47246108, 5.415178313], [0.000000, 63.267593, 64.383271, 65.560133, 68.121427, 71.008456, 72.957073, 72.957073], [0.100000, 70.503476, 71.746753, 73.058212, 75.912441, 79.129658, 81.301137, 81.301137], [0.200000, 76.997217, 78.355007, 79.787258, 82.904376, 86.417916, 88.789399, 88.789399], [0.400000, 86.088455, 87.606562, 89.207922, 92.693086, 96.621477, 99.272967, 99.272967], [0.600000, 90.912377, 92.515550, 94.206642, 97.887095, 102.035612, 104.835676, 104.835676], [0.750000, 94.159247, 95.819677, 97.571165, 101.383063, 105.679741, 108.579808, 108.579808], [0.900000, 95.550763, 97.235732, 98.333795, 102.881334, 107.241510, 110.184435, 110.184435], [1.000000, 104.200000, 106.037491, 107.975750, 112.194133, 116.948991, 120.158309, 120.158309]]);

	_defineProperty(EngineModel, "table1506", [[0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], [0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000], [20.000000, 0.091741, 0.057020, 0.031529, 0.014096, -0.017284, -0.037284, -0.057077, -0.205841, -0.315399, -0.488717], [25.000000, 0.142810, 0.072215, 0.038026, 0.020404, -0.009593, -0.026571, -0.024556, -0.151328, -0.266204, -0.439028], [30.000000, 0.189837, 0.082322, 0.04205, 0.026748, 0.017389, 0.003990, -0.026921, -0.056814, -0.081946, -0.369391], [35.000000, 0.262207, 0.126047, 0.077206, 0.045921, 0.024719, 0.006062, -0.0028121, -0.022800, -0.06972, -0.293631], [40.000000, 0.330230, 0.162757, 0.124088, 0.069579, 0.057905, 0.049621, 0.029790, 0.054284, 0.054218, -0.220630], [45.000000, 0.393293, 0.250096, 0.156707, 0.112419, 0.091418, 0.076757, 0.056090, 0.018509, -0.057520, -0.155120], [50.000000, 0.452337, 0.311066, 0.211353, 0.158174, 0.127429, 0.104915, 0.081171, 0.047419, -0.007399, -0.098474], [55.000000, 0.509468, 0.373568, 0.269961, 0.209106, 0.168650, 0.137223, 0.108383, 0.075660, 0.028704, -0.049469], [60.000000, 0.594614, 0.439955, 0.334629, 0.267477, 0.217773, 0.176899, 0.141404, 0.107148, 0.064556, -0.005036], [65.000000, 0.660035, 0.512604, 0.407151, 0.335055, 0.276928, 0.226669, 0.183627, 0.145850, 0.104441, 0.039012], [70.000000, 0.733601, 0.593506, 0.488571, 0.412623, 0.347163, 0.288210, 0.237559, 0.195142, 0.152485, 0.087269], [75.000000, 0.818693, 0.683880, 0.578756, 0.499514, 0.427939, 0.361604, 0.304241, 0.257197, 0.212005, 0.144042], [80.000000, 0.910344, 0.783795, 0.675982, 0.593166, 0.516644, 0.444822, 0.382689, 0.332384, 0.284867, 0.212679], [85.000000, 1.025165, 0.891823, 0.776548, 0.688692, 0.608128, 0.533210, 0.469351, 0.418690, 0.370870, 0.294907], [90.000000, 1.157049, 1.004695, 0.874400, 0.778466, 0.694251, 0.619011, 0.557581, 0.511153, 0.467149, 0.390203], [95.000000, 1.281333, 1.116993, 0.960774, 0.851733, 0.763455, 0.690890, 0.637136, 0.601322, 0.567588, 0.495167], [100.000000, 1.357935, 1.220844, 1.023864, 0.894234, 0.800352, 0.733488, 0.693684, 0.654691, 0.617963, 0.539115], [105.000000, 1.378826, 1.239626, 1.048498, 0.915750, 0.819609, 0.751137, 0.710375, 0.670444, 0.632832, 0.552086], [110.000000, 1.392754, 1.252148, 1.069322, 0.933937, 0.835886, 0.766054, 0.724483, 0.683759, 0.645400, 0.563051]]);

	class FlightModel {
	  // in knots/second
	  // in m/s^2
	  // in knots/second
	  // in m/s^2
	  // From https://github.com/flybywiresim/A318ceoCFM/pull/6903#issuecomment-1073168320

	  /**
	   * Get lift coefficient at given conditions
	   * @param weight in pounds
	   * @param mach self-explanatory
	   * @param delta pressure at the altitude divided by the pressure at sea level
	   * @param loadFactor g-Force
	   * @returns lift coefficient (Cl)
	   */
	  static getLiftCoefficient(weight, mach, delta) {
	    let loadFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
	    return weight * loadFactor / (1481.4 * mach ** 2 * delta * this.wingArea);
	  }

	  static getLiftCoefficientFromEAS(lift, eas) {
	    return 295.369 * lift / (eas ** 2 * this.wingArea);
	  }
	  /**
	   * Get drag coefficient at given conditions
	   * @param Cl coefficient of lift
	   * @param spdBrkDeflected whether speedbrake is deflected at half or not
	   * @param gearExtended whether gear is extended or not
	   * @param flapConf flap configuration
	   * @returns drag coefficient (Cd)
	   */


	  static getDragCoefficient(Cl) {
	    let spdBrkDeflected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    let gearExtended = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    let flapConf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : FlapConf.CLEAN;
	    // Values taken at mach 0
	    let baseDrag;

	    switch (flapConf) {
	      case FlapConf.CLEAN:
	        baseDrag = 0.0211 * Cl ** 3 + 0.0412 * Cl ** 2 - 0.015 * Cl + 0.0215;
	        break;

	      case FlapConf.CONF_1:
	        baseDrag = 0.0385 * Cl ** 3 + 0.004 * Cl ** 2 + 0.0044 * Cl + 0.0249;
	        break;

	      case FlapConf.CONF_2:
	        baseDrag = 0.0242 * Cl ** 3 + 0.0013 * Cl ** 2 + 0.003 * Cl + 0.0485;
	        break;

	      case FlapConf.CONF_3:
	        baseDrag = 0.0221 * Cl ** 3 - 0.0027 * Cl ** 2 + 0.0033 * Cl + 0.0584;
	        break;

	      case FlapConf.CONF_FULL:
	        baseDrag = 0.0143 * Cl ** 3 + 0.0027 * Cl ** 2 - 0.0038 * Cl + 0.0919;
	        break;
	    }

	    const spdBrkIncrement = spdBrkDeflected ? 0.01008 : 0;
	    const gearIncrement = gearExtended ? 0.03 : 0;
	    return baseDrag + spdBrkIncrement + gearIncrement;
	  }
	  /**
	   * Get drag at given conditions
	   * @param weight in pounds
	   * @param mach self-explanatory
	   * @param delta pressure at the altitude divided by the pressure at sea level
	   * @param spdBrkDeflected Whether speedbrake is deflected at half or not
	   * @param gearExtended whether gear is extended or not
	   * @param flapConf flap configuration
	   * @returns drag
	   */


	  static getDrag(weight, mach, delta, spdBrkDeflected, gearExtended, flapConf) {
	    const Cl = this.getLiftCoefficient(weight, mach, delta);
	    const Cd = this.getDragCoefficient(Cl, spdBrkDeflected, gearExtended, flapConf);
	    const deltaCd = this.getMachCorrection(mach, flapConf);
	    return 1481.4 * mach ** 2 * delta * this.wingArea * (Cd + deltaCd);
	  }

	  static getMachCorrection(mach, flapConf) {
	    if (flapConf !== FlapConf.CLEAN) {
	      return 0;
	    }

	    return this.interpolate(mach, this.machValues, this.dragCoefficientCorrections);
	  }
	  /**
	   * Interpolates in a list
	   * @param x The value to look up in in `xs`.
	   * @param xs The table of x values with known y values
	   * @param ys The y values corresponding to the x values in `xs`
	   */


	  static interpolate(x, xs, ys) {
	    if (x <= xs[0]) {
	      return ys[0];
	    }

	    for (let i = 0; i < xs.length - 1; i++) {
	      if (x > xs[i] && x <= xs[i + 1]) {
	        return Common.interpolate(x, xs[i], xs[i + 1], ys[i], ys[i + 1]);
	      }
	    }

	    return ys[ys.length - 1];
	  } // NEW

	  /**
	   * Returns the available climb or descent gradient.
	   *
	   * @param thrust the thrust in lbf
	   * @param drag
	   * @param weight in lbs
	   *
	   * @returns the available gradient in radians
	   */


	  static getAvailableGradient(thrust, drag, weight) {
	    return Math.asin((thrust - drag) / weight);
	  }
	  /**
	   * Returns an acceleration for a given available gradient, fpa and acceleration factor.
	   *
	   * @param availableGradient in radians
	   * @param fpa in radians
	   * @param accelFactor
	   *
	   * @returns the acceleration
	   */


	  static accelerationForGradient(availableGradient, fpa, accelFactor) {
	    return (Math.sin(availableGradient) - Math.sin(fpa)) * accelFactor;
	  }
	  /**
	   * Returns an fpa for a given available gradient, acceleration and acceleration factor.
	   *
	   * @param availableGradient in radians
	   * @param acceleration
	   * @param accelFactor
	   *
	   * @returns the fpa in radians
	   */


	  static fpaForGradient(availableGradient, acceleration, accelFactor) {
	    return Math.asin(Math.sin(availableGradient) - acceleration / accelFactor);
	  } // END NEW


	  static getConstantThrustPathAngle(thrust, weight, drag, accelFactor) {
	    return Math.asin((thrust - drag) / weight / accelFactor);
	  }

	  static getConstantThrustPathAngleFromCoefficients(thrust, weight, Cl, Cd, accelFactor) {
	    return Math.asin((thrust / weight - Cd / Cl) / accelFactor);
	  }

	  static getThrustFromConstantPathAngle(fpa, weight, drag, accelFactor) {
	    // fpa is in degrees
	    return weight * (accelFactor * Math.sin(fpa * MathUtils.DEGREES_TO_RADIANS)) + drag;
	  }

	  static getThrustFromConstantPathAngleCoefficients(fpa, weight, Cl, Cd, accelFactor) {
	    // fpa is in degrees
	    return weight * (accelFactor * Math.sin(fpa * MathUtils.DEGREES_TO_RADIANS) + Cd / Cl);
	  }

	  static getSpeedChangePathAngle(thrust, weight, drag) {
	    return Math.asin((thrust - drag) / weight - 1 / FlightModel.gravityConstMS2 * FlightModel.requiredAccelRateMS2);
	  }

	  static getSpeedChangePathAngleFromCoefficients(thrust, weight, Cl, Cd) {
	    return Math.asin(thrust / weight - Cd / Cl - 1 / FlightModel.gravityConstMS2 * FlightModel.requiredAccelRateMS2);
	  }

	  static getAccelRateFromIdleGeoPath(thrust, weight, drag, fpaDeg) {
	    // fpa is in degrees
	    const fpaRad = fpaDeg * MathUtils.DEGREES_TO_RADIANS;
	    return FlightModel.gravityConstKNS * ((thrust - drag) / weight - Math.sin(fpaRad));
	  }

	  static getAccelRateFromIdleGeoPathCoefficients(thrust, weight, Cl, Cd, fpaDeg) {
	    // fpa is in degrees
	    const fpaRad = fpaDeg * MathUtils.DEGREES_TO_RADIANS;
	    return FlightModel.gravityConstKNS * (thrust / weight - Cd / Cl - Math.sin(fpaRad));
	  }
	  /**
	   * Gets distance required to accelerate/decelerate
	   * @param thrust
	   * @param drag
	   * @param weight in pounds
	   * @param initialSpeed
	   * @param targetSpeed
	   * @param fpa flight path angle, default value 0 for level segments
	   * @param accelFactor acceleration factor, default value 0 for level segments
	   * @returns distance to accel/decel
	   */


	  static getAccelerationDistance(thrust, drag, weight, initialSpeed, targetSpeed) {
	    let fpa = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	    let accelFactor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
	    const sign = Math.sign(fpa);
	    const force = thrust - drag + sign * weight * Math.sin(fpa * (Math.PI / 180)) * accelFactor;
	    const accel = force / weight; // TODO: Check units

	    const timeToAccel = (targetSpeed - initialSpeed) / accel;
	    const distanceToAccel = initialSpeed * timeToAccel + 0.5 * accel * timeToAccel ** 2; // TODO: Check units

	    return distanceToAccel;
	  }

	  static getGreenDotSpeedCas(altitude, weight) {
	    return weight / 500 + 85 + Math.max(0, (altitude - 20000) / 1000);
	  }

	}

	_defineProperty(FlightModel, "Cd0", 0.01873);

	_defineProperty(FlightModel, "wingSpan", 117.454);

	_defineProperty(FlightModel, "wingArea", 1317.47);

	_defineProperty(FlightModel, "wingEffcyFactor", 0.70);

	_defineProperty(FlightModel, "requiredAccelRateKNS", 1.33);

	_defineProperty(FlightModel, "requiredAccelRateMS2", 0.684);

	_defineProperty(FlightModel, "gravityConstKNS", 19.0626);

	_defineProperty(FlightModel, "gravityConstMS2", 9.806665);

	_defineProperty(FlightModel, "machValues", [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85]);

	_defineProperty(FlightModel, "dragCoefficientCorrections", [0, 0.0002, 0.0003, 0.0004, 0.0008, 0.0015, 0.01]);

	let VnavStepError;

	(function (VnavStepError) {
	  VnavStepError[VnavStepError["AVAILABLE_GRADIENT_INSUFFICIENT"] = 0] = "AVAILABLE_GRADIENT_INSUFFICIENT";
	  VnavStepError[VnavStepError["TOO_LOW_DECELERATION"] = 1] = "TOO_LOW_DECELERATION";
	})(VnavStepError || (VnavStepError = {}));

	({
	  flapConfig: FlapConf.CLEAN,
	  speedbrakesExtended: false,
	  gearExtended: false
	});

	let VerticalCheckpointReason;

	(function (VerticalCheckpointReason) {
	  VerticalCheckpointReason["Liftoff"] = "Liftoff";
	  VerticalCheckpointReason["ThrustReductionAltitude"] = "ThrustReductionAltitude";
	  VerticalCheckpointReason["AccelerationAltitude"] = "AccelerationAltitude";
	  VerticalCheckpointReason["TopOfClimb"] = "TopOfClimb";
	  VerticalCheckpointReason["AtmosphericConditions"] = "AtmosphericConditions";
	  VerticalCheckpointReason["PresentPosition"] = "PresentPosition";
	  VerticalCheckpointReason["LevelOffForClimbConstraint"] = "LevelOffForClimbConstraint";
	  VerticalCheckpointReason["AltitudeConstraint"] = "AltitudeConstraint";
	  VerticalCheckpointReason["ContinueClimb"] = "ContinueClimb";
	  VerticalCheckpointReason["CrossingClimbSpeedLimit"] = "CrossingClimbSpeedLimit";
	  VerticalCheckpointReason["SpeedConstraint"] = "SpeedConstraint";
	  VerticalCheckpointReason["CrossingFcuAltitudeClimb"] = "FcuAltitudeClimb";
	  VerticalCheckpointReason["StepClimb"] = "StepClimb";
	  VerticalCheckpointReason["TopOfStepClimb"] = "TopOfStepClimb";
	  VerticalCheckpointReason["StepDescent"] = "StepDescent";
	  VerticalCheckpointReason["BottomOfStepDescent"] = "BottomOfStepDescent";
	  VerticalCheckpointReason["CrossingFcuAltitudeDescent"] = "FcuAltitudeDescent";
	  VerticalCheckpointReason["InterceptDescentProfileManaged"] = "InterceptDescentProfileManaged";
	  VerticalCheckpointReason["InterceptDescentProfileSelected"] = "InterceptDescentProfileSelected";
	  VerticalCheckpointReason["LevelOffForDescentConstraint"] = "LevelOffForDescentConstraint";
	  VerticalCheckpointReason["ContinueDescent"] = "ContinueDescent";
	  VerticalCheckpointReason["ContinueDescentArmed"] = "ContinueDescentArmed";
	  VerticalCheckpointReason["TopOfDescent"] = "TopOfDescent";
	  VerticalCheckpointReason["CrossingDescentSpeedLimit"] = "CrossingDescentSpeedLimit";
	  VerticalCheckpointReason["IdlePathAtmosphericConditions"] = "IdlePathAtmosphericConditions";
	  VerticalCheckpointReason["IdlePathEnd"] = "IdlePathEnd";
	  VerticalCheckpointReason["GeometricPathStart"] = "GeometricPathStart";
	  VerticalCheckpointReason["GeometricPathConstraint"] = "GeometricPathConstraint";
	  VerticalCheckpointReason["GeometricPathTooSteep"] = "GeometricPathTooSteep";
	  VerticalCheckpointReason["GeometricPathEnd"] = "GeometricPathEnd";
	  VerticalCheckpointReason["Decel"] = "Decel";
	  VerticalCheckpointReason["Flaps1"] = "Flaps1";
	  VerticalCheckpointReason["Flaps2"] = "Flaps2";
	  VerticalCheckpointReason["Flaps3"] = "Flaps3";
	  VerticalCheckpointReason["FlapsFull"] = "FlapsFull";
	  VerticalCheckpointReason["Landing"] = "Landing";
	})(VerticalCheckpointReason || (VerticalCheckpointReason = {}));

	let TimeUtils;

	(function (_TimeUtils) {
	  function addSeconds(a, b) {
	    return (a + b) % (3600 * 24);
	  }

	  _TimeUtils.addSeconds = addSeconds;

	  function formatSeconds(time) {
	    let colon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    const hh = Math.floor(time / 3600);
	    const mm = Math.floor(time % 3600 / 60);
	    return "".concat(hh.toString().padStart(2, '0')).concat(colon ? ':' : '').concat(mm.toString().padStart(2, '0'));
	  }

	  _TimeUtils.formatSeconds = formatSeconds;
	})(TimeUtils || (TimeUtils = {}));

	new Set([VerticalCheckpointReason.TopOfClimb, VerticalCheckpointReason.CrossingClimbSpeedLimit, VerticalCheckpointReason.StepClimb, VerticalCheckpointReason.StepDescent, // Descent
	VerticalCheckpointReason.TopOfDescent, VerticalCheckpointReason.CrossingDescentSpeedLimit, // Approach
	VerticalCheckpointReason.Decel, VerticalCheckpointReason.Flaps1, VerticalCheckpointReason.Flaps2]);

	new Set([VerticalCheckpointReason.TopOfClimb, VerticalCheckpointReason.LevelOffForClimbConstraint, VerticalCheckpointReason.ContinueClimb, VerticalCheckpointReason.CrossingFcuAltitudeClimb, VerticalCheckpointReason.TopOfDescent, VerticalCheckpointReason.CrossingFcuAltitudeDescent, VerticalCheckpointReason.ContinueDescent, VerticalCheckpointReason.ContinueDescentArmed, VerticalCheckpointReason.LevelOffForDescentConstraint, VerticalCheckpointReason.InterceptDescentProfileManaged, VerticalCheckpointReason.InterceptDescentProfileSelected, VerticalCheckpointReason.Decel, VerticalCheckpointReason.Flaps1, VerticalCheckpointReason.Flaps2]);

	[VerticalCheckpointReason.LevelOffForClimbConstraint, VerticalCheckpointReason.ContinueClimb, VerticalCheckpointReason.CrossingClimbSpeedLimit, VerticalCheckpointReason.CrossingFcuAltitudeClimb];
	new Set([VerticalCheckpointReason.Flaps1, VerticalCheckpointReason.Flaps2]);

	let TaskCategory;

	(function (TaskCategory) {
	  TaskCategory[TaskCategory["EfisVectors"] = 0] = "EfisVectors";
	})(TaskCategory || (TaskCategory = {}));

	class SimVarString {
	  /**
	   * Pack a string into numbers for use in a simvar
	   * ASCII chars from dec 32-63 can be encoded, 6-bit per char, 8 chars per simvar
	   * IMPORTANT: write the values as strings to the simvars or you will have precision errors
	   * @param value
	   * @param maxLength if specified enough simvars will be returned to fit this length,
	   * and the value will be trimmed to this length
	   * @returns an array of numbers ready to be written to simvars
	   */
	  static pack(value, maxLength) {
	    let word = -1;
	    const ret = [];

	    for (let i = 0; i < Math.min(maxLength, value.length); i++) {
	      const char = i % 8;

	      if (char === 0) {
	        word++;
	        ret[word] = 0;
	      }

	      let code = value.charCodeAt(i) - 31;

	      if (code < 1 || code > 63 || !Number.isFinite(code)) {
	        code = 0;
	      }

	      ret[word] += 2 ** (char * 6) * code;
	    }

	    if (maxLength && ret.length < Math.ceil(maxLength / 8)) {
	      ret.push(...new Array(Math.ceil(maxLength / 8) - ret.length).fill(0));
	    }

	    return ret;
	  }
	  /**
	   * Unpacks numeric values packed by @see packString
	   * @param values an array of numbers from the simvars
	   * @returns the unpacked string
	   */


	  static unpack(values) {
	    let ret = '';

	    for (let i = 0; i < values.length * 8; i++) {
	      const word = Math.floor(i / 8);
	      const char = i % 8;
	      const code = Math.floor(values[word] / 2 ** (char * 6)) & 0x3f;

	      if (code > 0) {
	        ret += String.fromCharCode(code + 31);
	      }
	    }

	    return ret;
	  }

	}

	class Arinc429WordSsmParseError extends Error {
	  constructor(ssm) {
	    super();
	    this.ssm = ssm;
	  }

	}
	class Arinc429Word {
	  constructor(word) {
	    _defineProperty(this, "ssm", void 0);

	    _defineProperty(this, "value", void 0);

	    Arinc429Word.f64View[0] = word;
	    const ssm = Arinc429Word.u32View[0];

	    if (ssm >= 0b00 && ssm <= 0b11) {
	      this.ssm = ssm;
	    } else {
	      throw new Arinc429WordSsmParseError(ssm);
	    }

	    this.value = Arinc429Word.f32View[1];
	  }

	  static empty() {
	    return new Arinc429Word(0);
	  }

	  static fromSimVarValue(name) {
	    return new Arinc429Word(SimVar.GetSimVarValue(name, 'number'));
	  }

	  isFailureWarning() {
	    return this.ssm === Arinc429Word.SignStatusMatrix.FailureWarning;
	  }

	  isNoComputedData() {
	    return this.ssm === Arinc429Word.SignStatusMatrix.NoComputedData;
	  }

	  isFunctionalTest() {
	    return this.ssm === Arinc429Word.SignStatusMatrix.FunctionalTest;
	  }

	  isNormalOperation() {
	    return this.ssm === Arinc429Word.SignStatusMatrix.NormalOperation;
	  }
	  /**
	   * Returns the value when normal operation, the supplied default value otherwise.
	   */


	  valueOr(defaultValue) {
	    return this.isNormalOperation() ? this.value : defaultValue;
	  }

	  getBitValue(bit) {
	    return (this.value >> bit - 1 & 1) !== 0;
	  }

	  getBitValueOr(bit, defaultValue) {
	    return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
	  }

	}

	_defineProperty(Arinc429Word, "SignStatusMatrix", Object.freeze({
	  FailureWarning: 0b00,
	  NoComputedData: 0b01,
	  FunctionalTest: 0b10,
	  NormalOperation: 0b11
	}));

	_defineProperty(Arinc429Word, "f64View", new Float64Array(1));

	_defineProperty(Arinc429Word, "u32View", new Uint32Array(Arinc429Word.f64View.buffer));

	_defineProperty(Arinc429Word, "f32View", new Float32Array(Arinc429Word.f64View.buffer));

	class GuidanceConstants {}

	_defineProperty(GuidanceConstants, "k2", 0.0045);

	_defineProperty(GuidanceConstants, "FORCED_TURN_TKAE_THRESHOLD", 150);

	/**
	 * Represents the current turn state of the LNAV driver
	 */
	let LnavTurnState;

	(function (LnavTurnState) {
	  LnavTurnState[LnavTurnState["Normal"] = 0] = "Normal";
	  LnavTurnState[LnavTurnState["ForceLeftTurn"] = 1] = "ForceLeftTurn";
	  LnavTurnState[LnavTurnState["ForceRightTurn"] = 2] = "ForceRightTurn";
	})(LnavTurnState || (LnavTurnState = {}));

	/// <reference path="../../../typings/fs-base-ui/html_ui/JS/common.d.ts" />

	/**
	 * NotiticationParams container for popups to package popup metadata
	 */

	/**
	 * PopUp utility class to create a pop-up UI element
	 *
	 * Usage:
	 * import { PopUp } from '@shared/popup';
	 * ...
	 * const popup = new PopUp();
	 * popup.showPopUp("CRITICAL SETTING CHANGED", "Your message here", "small", yesFunc, noFunc);
	 * popup.showInformation("CRITICAL MESSAGE", "Your message here", "small", yesFunc);
	 */
	class PopUp {
	  /**
	   * Creates a Popup
	   */
	  constructor() {
	    _defineProperty(this, "params", void 0);

	    _defineProperty(this, "popupListener", void 0);

	    const title = 'A32NX POPUP';
	    const time = new Date().getTime();
	    this.popupListener = undefined;
	    this.params = {
	      __Type: 'SNotificationParams',
	      buttons: [new NotificationButton('TT:MENU.YES', "A32NX_POP_".concat(title, "_").concat(time, "_YES")), new NotificationButton('TT:MENU.NO', "A32NX_POP_".concat(title, "_").concat(time, "_NO"))],
	      style: 'normal',
	      displayGlobalPopup: true,
	      contentData: 'Default Message',
	      contentUrl: '',
	      // i.e. "/templates/Controls/PopUp_EditPreset/PopUp_EditPreset.html";
	      contentTemplate: '',
	      // i.e. "popup-edit-preset";
	      id: "".concat(title, "_").concat(time),
	      title,
	      time
	    };
	  }
	  /**
	   * Pass Popup display data to Coherent
	   * @param params
	   */

	  /* eslint-disable no-underscore-dangle */


	  _showPopUp() {
	    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    Coherent.trigger('SHOW_POP_UP', params);
	  }
	  /**
	   * Show popup with given or already initiated parameters
	   * @param {string} title Title for popup - will show in menu bar
	   * @param {string} message Popup message
	   * @param {string} style Style/Type of popup. Valid types are small|normal|big|big-help
	   * @param {function} callbackYes Callback function -> YES button is clicked.
	   * @param {function} callbackNo Callback function -> NO button is clicked.
	   */


	  showPopUp(title, message, style, callbackYes, callbackNo) {
	    if (title) {
	      this.params.title = title;
	    }

	    if (message) {
	      this.params.contentData = message;
	    }

	    if (style) {
	      this.params.style = style;
	    }

	    if (callbackYes) {
	      const yes = typeof callbackYes === 'function' ? callbackYes : () => callbackYes;
	      Coherent.on("A32NX_POP_".concat(this.params.id, "_YES"), () => {
	        Coherent.off("A32NX_POP_".concat(this.params.id, "_YES"), null, null);
	        yes();
	      });
	    }

	    if (callbackNo) {
	      const no = typeof callbackNo === 'function' ? callbackNo : () => callbackNo;
	      Coherent.on("A32NX_POP_".concat(this.params.id, "_NO"), () => {
	        Coherent.off("A32NX_POP_".concat(this.params.id, "_NO"), null, null);
	        no();
	      });
	    }

	    if (!this.popupListener) {
	      this.popupListener = RegisterViewListener('JS_LISTENER_POPUP', this._showPopUp.bind(null, this.params));
	    } else {
	      this._showPopUp(this.params);
	    }
	  }
	  /**
	   * Show information with given or already initiated parameters
	   * @param {string} title Title for popup - will show in menu bar
	   * @param {string} message Popup message
	   * @param {string} style Style/Type of popup. Valid types are small|normal|big|big-help
	   * @param {function} callback Callback function -> OK button is clicked.
	   */


	  showInformation(title, message, style, callback) {
	    if (title) {
	      this.params.title = title;
	    }

	    if (message) {
	      this.params.contentData = message;
	    }

	    if (style) {
	      this.params.style = style;
	    }

	    if (callback) {
	      const yes = typeof callback === 'function' ? callback : () => callback;
	      Coherent.on("A32NX_POP_".concat(this.params.id, "_YES"), () => {
	        Coherent.off("A32NX_POP_".concat(this.params.id, "_YES"), null, null);
	        yes();
	      });
	    }

	    this.params.buttons = [new NotificationButton('TT:MENU.OK', "A32NX_POP_".concat(this.params.id, "_YES"))];

	    if (!this.popupListener) {
	      this.popupListener = RegisterViewListener('JS_LISTENER_POPUP', this._showPopUp.bind(null, this.params));
	    } else {
	      this._showPopUp(this.params);
	    }
	  }

	}

	var DescentVerticalGuidanceState$1;

	(function (DescentVerticalGuidanceState) {
	  DescentVerticalGuidanceState[DescentVerticalGuidanceState["InvalidProfile"] = 0] = "InvalidProfile";
	  DescentVerticalGuidanceState[DescentVerticalGuidanceState["ProvidingGuidance"] = 1] = "ProvidingGuidance";
	  DescentVerticalGuidanceState[DescentVerticalGuidanceState["Observing"] = 2] = "Observing";
	})(DescentVerticalGuidanceState$1 || (DescentVerticalGuidanceState$1 = {}));

	var DescentSpeedGuidanceState$1;

	(function (DescentSpeedGuidanceState) {
	  DescentSpeedGuidanceState[DescentSpeedGuidanceState["NotInDescentPhase"] = 0] = "NotInDescentPhase";
	  DescentSpeedGuidanceState[DescentSpeedGuidanceState["TargetOnly"] = 1] = "TargetOnly";
	  DescentSpeedGuidanceState[DescentSpeedGuidanceState["TargetAndMargins"] = 2] = "TargetAndMargins";
	})(DescentSpeedGuidanceState$1 || (DescentSpeedGuidanceState$1 = {}));

	var DescentVerticalGuidanceState;

	(function (DescentVerticalGuidanceState) {
	  DescentVerticalGuidanceState[DescentVerticalGuidanceState["InvalidProfile"] = 0] = "InvalidProfile";
	  DescentVerticalGuidanceState[DescentVerticalGuidanceState["ProvidingGuidance"] = 1] = "ProvidingGuidance";
	  DescentVerticalGuidanceState[DescentVerticalGuidanceState["Observing"] = 2] = "Observing";
	})(DescentVerticalGuidanceState || (DescentVerticalGuidanceState = {}));

	var DescentSpeedGuidanceState;

	(function (DescentSpeedGuidanceState) {
	  DescentSpeedGuidanceState[DescentSpeedGuidanceState["NotInDescentPhase"] = 0] = "NotInDescentPhase";
	  DescentSpeedGuidanceState[DescentSpeedGuidanceState["TargetOnly"] = 1] = "TargetOnly";
	  DescentSpeedGuidanceState[DescentSpeedGuidanceState["TargetAndMargins"] = 2] = "TargetAndMargins";
	})(DescentSpeedGuidanceState || (DescentSpeedGuidanceState = {}));

	let TuningMode;
	/**
	 * This is a placeholder for the new radio nav tuning logic... coming soon to an A32NX near you
	 */

	(function (TuningMode) {
	  TuningMode[TuningMode["Auto"] = 0] = "Auto";
	  TuningMode[TuningMode["Manual"] = 1] = "Manual";
	  TuningMode[TuningMode["Remote"] = 2] = "Remote";
	})(TuningMode || (TuningMode = {}));

	// Do not write any code which depends on it

	class NearbyFacilities {
	  // metres
	  constructor() {
	    _defineProperty(this, "nearbyAirports", new Map());

	    _defineProperty(this, "nearbyNdbNavaids", new Map());

	    _defineProperty(this, "nearbyVhfNavaids", new Map());

	    _defineProperty(this, "nearbyWaypoints", new Map());

	    _defineProperty(this, "version", 0);

	    _defineProperty(this, "listener", void 0);

	    _defineProperty(this, "initDone", false);

	    _defineProperty(this, "airportSessionId", void 0);

	    _defineProperty(this, "ndbSessionId", void 0);

	    _defineProperty(this, "vorSessionId", void 0);

	    _defineProperty(this, "waypointSessionId", void 0);

	    _defineProperty(this, "lastPpos", {
	      lat: 0,
	      long: 0
	    });

	    _defineProperty(this, "throttler", new UpdateThrottler(10000));

	    _defineProperty(this, "radius", 381 * 1852);

	    _defineProperty(this, "limit", 160);

	    this.listener = RegisterViewListener('JS_LISTENER_FACILITY', async () => {
	      this.listener.on('SendAirport', this.addAirport.bind(this));
	      this.listener.on('SendIntersection', this.addWaypoint.bind(this));
	      this.listener.on('SendNdb', this.addNdbNavaid.bind(this));
	      this.listener.on('SendVor', this.addVhfNavaid.bind(this));
	      this.listener.on('NearestSearchCompleted', this.onSearchCompleted.bind(this));
	      this.airportSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Airport);
	      this.ndbSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Ndb);
	      this.vorSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Vor);
	      this.waypointSessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', NearestSearchType.Intersection);
	      this.initDone = true;
	    });
	  }

	  init() {// Do nothing for now
	  }

	  async update(deltaTime) {
	    if (!this.initDone || this.throttler.canUpdate(deltaTime) === -1) {
	      return;
	    }

	    const ppos = {
	      lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
	      long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
	    };

	    if (Avionics.Utils.computeDistance(ppos, this.lastPpos) > 5) {
	      this.lastPpos = ppos;
	    }

	    Coherent.call('SEARCH_NEAREST', this.airportSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
	    Coherent.call('SEARCH_NEAREST', this.vorSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
	    Coherent.call('SEARCH_NEAREST', this.ndbSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
	    Coherent.call('SEARCH_NEAREST', this.waypointSessionId, this.lastPpos.lat, this.lastPpos.long, this.radius, this.limit);
	  }

	  onSearchCompleted(result) {
	    let nearestList;
	    let loadCall;

	    switch (result.sessionId) {
	      case this.airportSessionId:
	        nearestList = this.nearbyAirports;
	        loadCall = 'LOAD_AIRPORTS';
	        break;

	      case this.ndbSessionId:
	        nearestList = this.nearbyNdbNavaids;
	        loadCall = 'LOAD_NDBS';
	        break;

	      case this.vorSessionId:
	        nearestList = this.nearbyVhfNavaids;
	        loadCall = 'LOAD_VORS';
	        break;

	      case this.waypointSessionId:
	        nearestList = this.nearbyWaypoints;
	        loadCall = 'LOAD_INTERSECTIONS';
	        break;

	      default:
	        console.warn('Unknown session', result.sessionId);
	        return;
	    }

	    for (const icao of result.removed) {
	      delete nearestList[icao];
	      this.version++;
	    }

	    const loadIcaos = [];

	    for (const icao of result.added) {
	      if (nearestList.has(icao)) {
	        continue;
	      }

	      loadIcaos.push(icao);
	    }

	    if (loadIcaos.length > 0) {
	      Coherent.call(loadCall, loadIcaos);
	    }
	  }

	  addAirport(airport) {
	    this.nearbyAirports.set(airport.icao, airport);
	    this.version++;
	  }

	  addWaypoint(waypoint) {
	    this.nearbyWaypoints.set(waypoint.icao, waypoint);
	    this.version++;
	  }

	  addNdbNavaid(ndb) {
	    this.nearbyNdbNavaids.set(ndb.icao, ndb);
	    this.version++;
	  }

	  addVhfNavaid(vor) {
	    this.nearbyVhfNavaids.set(vor.icao, vor);
	    this.version++;
	  }

	}

	class EfisSymbols {
	  constructor(flightPlanManager, guidanceController) {
	    _defineProperty(this, "blockUpdate", false);

	    _defineProperty(this, "flightPlanManager", void 0);

	    _defineProperty(this, "guidanceController", void 0);

	    _defineProperty(this, "guidanceManager", void 0);

	    _defineProperty(this, "nearby", void 0);

	    _defineProperty(this, "syncer", new FlowEventSync());

	    _defineProperty(this, "lastMode", {
	      L: -1,
	      R: -1
	    });

	    _defineProperty(this, "lastRange", {
	      L: 0,
	      R: 0
	    });

	    _defineProperty(this, "lastEfisOption", {
	      L: 0,
	      R: 0
	    });

	    _defineProperty(this, "lastPlanCentre", undefined);

	    _defineProperty(this, "lastPpos", {
	      lat: 0,
	      long: 0
	    });

	    _defineProperty(this, "lastTrueHeading", -1);

	    _defineProperty(this, "lastNearbyFacilitiesVersion", void 0);

	    _defineProperty(this, "lastFpVersion", void 0);

	    _defineProperty(this, "lastVnavDriverVersion", -1);

	    this.flightPlanManager = flightPlanManager;
	    this.guidanceController = guidanceController;
	    this.guidanceManager = guidanceController.guidanceManager;
	    this.nearby = new NearbyFacilities();
	  }

	  init() {
	    this.nearby.init();
	  }

	  async update(deltaTime) {
	    var _this$flightPlanManag, _this$lastPlanCentre, _this$lastPlanCentre2;

	    this.nearby.update(deltaTime);

	    if (this.blockUpdate) {
	      return;
	    } // TODO use FMGC position


	    const ppos = {
	      lat: SimVar.GetSimVarValue('PLANE LATITUDE', 'degree latitude'),
	      long: SimVar.GetSimVarValue('PLANE LONGITUDE', 'degree longitude')
	    };
	    const trueHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
	    const pposChanged = Avionics.Utils.computeDistance(this.lastPpos, ppos) > 2;

	    if (pposChanged) {
	      this.lastPpos = ppos;
	    }

	    const trueHeadingChanged = Avionics.Utils.diffAngle(trueHeading, this.lastTrueHeading) > 2;

	    if (trueHeadingChanged) {
	      this.lastTrueHeading = trueHeading;
	    }

	    const nearbyFacilitiesChanged = this.nearby.version !== this.lastNearbyFacilitiesVersion;
	    this.lastNearbyFacilitiesVersion = this.nearby.version;
	    const fpChanged = this.lastFpVersion !== this.flightPlanManager.currentFlightPlanVersion;
	    this.lastFpVersion = this.flightPlanManager.currentFlightPlanVersion; // FIXME map reference point should be per side

	    const planCentreIndex = SimVar.GetSimVarValue('L:A32NX_SELECTED_WAYPOINT', 'number');
	    const planCentre = (_this$flightPlanManag = this.flightPlanManager.getWaypoint(planCentreIndex)) === null || _this$flightPlanManag === void 0 ? void 0 : _this$flightPlanManag.infos.coordinates;
	    const planCentreChanged = (planCentre === null || planCentre === void 0 ? void 0 : planCentre.lat) !== ((_this$lastPlanCentre = this.lastPlanCentre) === null || _this$lastPlanCentre === void 0 ? void 0 : _this$lastPlanCentre.lat) || (planCentre === null || planCentre === void 0 ? void 0 : planCentre.long) !== ((_this$lastPlanCentre2 = this.lastPlanCentre) === null || _this$lastPlanCentre2 === void 0 ? void 0 : _this$lastPlanCentre2.long);
	    this.lastPlanCentre = planCentre;
	    const vnavPredictionsChanged = this.lastVnavDriverVersion !== this.guidanceController.vnavDriver.version;
	    this.lastVnavDriverVersion = this.guidanceController.vnavDriver.version;
	    const activeFp = this.flightPlanManager.getCurrentFlightPlan(); // TODO temp f-pln

	    const hasSuitableRunway = airport => {
	      for (const runway of airport.runways) {
	        switch (runway.surface) {
	          case RunwaySurface.Asphalt:
	          case RunwaySurface.Bituminous:
	          case RunwaySurface.Concrete:
	          case RunwaySurface.Tarmac:
	            if (runway.length >= 1500 && runway.width >= 30) {
	              return true;
	            }

	            break;
	        }
	      }

	      return false;
	    };

	    for (const side of EfisSymbols.sides) {
	      var _this$guidanceControl;

	      const range = rangeSettings[SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_RANGE"), 'number')];
	      const mode = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_MODE"), 'number');
	      const efisOption = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(side, "_OPTION"), 'Enum');
	      const rangeChange = this.lastRange[side] !== range;
	      this.lastRange[side] = range;
	      const modeChange = this.lastMode[side] !== mode;
	      this.lastMode[side] = mode;
	      const efisOptionChange = this.lastEfisOption[side] !== efisOption;
	      this.lastEfisOption[side] = efisOption;
	      const nearbyOverlayChanged = efisOption !== EfisOption.Constraints && efisOption !== EfisOption.None && nearbyFacilitiesChanged;

	      if (!pposChanged && !trueHeadingChanged && !rangeChange && !modeChange && !efisOptionChange && !nearbyOverlayChanged && !fpChanged && !planCentreChanged && !vnavPredictionsChanged) {
	        continue;
	      }

	      if (mode === Mode.PLAN && !planCentre) {
	        this.syncer.sendEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), []);
	        return;
	      }

	      const [editAhead, editBehind, editBeside] = this.calculateEditArea(range, mode); // eslint-disable-next-line no-loop-func

	      const withinEditArea = ll => {
	        const dist = Avionics.Utils.computeGreatCircleDistance(mode === Mode.PLAN ? planCentre : ppos, ll);
	        let bearing = Avionics.Utils.computeGreatCircleHeading(mode === Mode.PLAN ? planCentre : ppos, ll);

	        if (mode !== Mode.PLAN) {
	          bearing = Avionics.Utils.clampAngle(bearing - trueHeading);
	        }

	        bearing = bearing * Math.PI / 180;
	        const dx = dist * Math.sin(bearing);
	        const dy = dist * Math.cos(bearing);
	        return Math.abs(dx) < editBeside && dy > -editBehind && dy < editAhead;
	      };

	      const symbols = []; // symbols most recently inserted always end up at the end of the array
	      // we reverse the array at the end to make sure symbols are drawn in the correct order
	      // eslint-disable-next-line no-loop-func

	      const upsertSymbol = symbol => {

	        const symbolIdx = symbols.findIndex(s => s.databaseId === symbol.databaseId);

	        if (symbolIdx !== -1) {
	          var _symbol$constraints, _symbol$direction, _symbol$length, _symbol$location;

	          const oldSymbol = symbols.splice(symbolIdx, 1)[0];
	          symbol.constraints = (_symbol$constraints = symbol.constraints) !== null && _symbol$constraints !== void 0 ? _symbol$constraints : oldSymbol.constraints;
	          symbol.direction = (_symbol$direction = symbol.direction) !== null && _symbol$direction !== void 0 ? _symbol$direction : oldSymbol.direction;
	          symbol.length = (_symbol$length = symbol.length) !== null && _symbol$length !== void 0 ? _symbol$length : oldSymbol.length;
	          symbol.location = (_symbol$location = symbol.location) !== null && _symbol$location !== void 0 ? _symbol$location : oldSymbol.location;
	          symbol.type |= oldSymbol.type;

	          if (oldSymbol.radials) {
	            if (symbol.radials) {
	              symbol.radials.push(...oldSymbol.radials);
	            } else {
	              symbol.radials = oldSymbol.radials;
	            }
	          }

	          if (oldSymbol.radii) {
	            if (symbol.radii) {
	              symbol.radii.push(...oldSymbol.radii);
	            } else {
	              symbol.radii = oldSymbol.radii;
	            }
	          }
	        }

	        symbols.push(symbol);
	      }; // TODO ADIRs aligned (except in plan mode...?)


	      if (efisOption === EfisOption.VorDmes) {
	        for (const vor of this.nearby.nearbyVhfNavaids.values()) {
	          if (vor.type !== VorType.VORDME && vor.type !== VorType.VOR && vor.type !== VorType.DME && vor.type !== VorType.VORTAC && vor.type !== VorType.TACAN) {
	            continue;
	          }

	          const ll = {
	            lat: vor.lat,
	            long: vor.lon
	          };

	          if (withinEditArea(ll)) {
	            upsertSymbol({
	              databaseId: vor.icao,
	              ident: vor.icao.substring(7, 12),
	              location: ll,
	              type: this.vorDmeTypeFlag(vor.type) | NdSymbolTypeFlags.EfisOption
	            });
	          }
	        }
	      } else if (efisOption === EfisOption.Ndbs) {
	        for (const ndb of this.nearby.nearbyNdbNavaids.values()) {
	          const ll = {
	            lat: ndb.lat,
	            long: ndb.lon
	          };

	          if (withinEditArea(ll)) {
	            upsertSymbol({
	              databaseId: ndb.icao,
	              ident: ndb.icao.substring(7, 12),
	              location: ll,
	              type: NdSymbolTypeFlags.Ndb | NdSymbolTypeFlags.EfisOption
	            });
	          }
	        }
	      } else if (efisOption === EfisOption.Airports) {
	        for (const ap of this.nearby.nearbyAirports.values()) {
	          const ll = {
	            lat: ap.lat,
	            long: ap.lon
	          };

	          if (withinEditArea(ll) && hasSuitableRunway(ap)) {
	            upsertSymbol({
	              databaseId: ap.icao,
	              ident: ap.icao.substring(7, 12),
	              location: ll,
	              type: NdSymbolTypeFlags.Airport | NdSymbolTypeFlags.EfisOption
	            });
	          }
	        }
	      } else if (efisOption === EfisOption.Waypoints) {
	        for (const wp of this.nearby.nearbyWaypoints.values()) {
	          const ll = {
	            lat: wp.lat,
	            long: wp.lon
	          };

	          if (withinEditArea(ll)) {
	            upsertSymbol({
	              databaseId: wp.icao,
	              ident: wp.icao.substring(7, 12),
	              location: ll,
	              type: NdSymbolTypeFlags.Waypoint | NdSymbolTypeFlags.EfisOption
	            });
	          }
	        }
	      }

	      for (let i = 0; i < 4; i++) {
	        const fixInfo = this.flightPlanManager.getFixInfo(i);
	        const refFix = fixInfo === null || fixInfo === void 0 ? void 0 : fixInfo.getRefFix();

	        if (refFix !== undefined) {
	          upsertSymbol({
	            databaseId: refFix.icao,
	            ident: refFix.ident,
	            location: refFix.infos.coordinates,
	            type: NdSymbolTypeFlags.FixInfo,
	            radials: fixInfo.getRadialTrueBearings(),
	            radii: [fixInfo.getRadiusValue()]
	          });
	        }
	      }

	      const formatConstraintAlt = function (alt, descent) {
	        var _activeFp$originTrans, _activeFp$destination;

	        let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	        const transAlt = (_activeFp$originTrans = activeFp === null || activeFp === void 0 ? void 0 : activeFp.originTransitionAltitudePilot) !== null && _activeFp$originTrans !== void 0 ? _activeFp$originTrans : activeFp === null || activeFp === void 0 ? void 0 : activeFp.originTransitionAltitudeDb;
	        const transFl = (_activeFp$destination = activeFp === null || activeFp === void 0 ? void 0 : activeFp.destinationTransitionLevelPilot) !== null && _activeFp$destination !== void 0 ? _activeFp$destination : activeFp === null || activeFp === void 0 ? void 0 : activeFp.destinationTransitionLevelDb;

	        if (descent) {
	          const fl = Math.round(alt / 100);

	          if (transFl && fl >= transFl) {
	            return "".concat(prefix, "FL").concat(fl);
	          }
	        } else if (transAlt && alt >= transAlt) {
	          return "".concat(prefix, "FL").concat(Math.round(alt / 100));
	        }

	        return "".concat(prefix).concat(Math.round(alt));
	      };

	      const formatConstraintSpeed = function (speed) {
	        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	        return "".concat(prefix).concat(Math.floor(speed), "KT");
	      };

	      for (const [index, leg] of this.guidanceController.activeGeometry.legs.entries()) {
	        if (!leg.isNull && leg.terminationWaypoint && leg.displayedOnMap) {
	          if (!(leg.terminationWaypoint instanceof WayPoint)) {
	            const isActive = index === this.guidanceController.activeLegIndex;
	            let type = NdSymbolTypeFlags.FlightPlan;

	            if (isActive) {
	              type |= NdSymbolTypeFlags.ActiveLegTermination;
	            }

	            const ident = leg.ident;
	            const cutIdent = leg.ident.substring(0, 4).padEnd(5, ' ');
	            const id = (Math.random() * 10000000).toString().substring(0, 5);
	            upsertSymbol({
	              databaseId: "X".concat(id).concat(cutIdent),
	              ident,
	              type,
	              location: leg.terminationWaypoint
	            });
	          }
	        }
	      }

	      const isInLatAutoControl = this.guidanceController.vnavDriver.isLatAutoControlActive();
	      const waypointPredictions = (_this$guidanceControl = this.guidanceController.vnavDriver.currentNavGeometryProfile) === null || _this$guidanceControl === void 0 ? void 0 : _this$guidanceControl.waypointPredictions;
	      const isSelectedVerticalModeActive = this.guidanceController.vnavDriver.isSelectedVerticalModeActive();
	      const flightPhase = getFlightPhaseManager().phase; // TODO don't send the waypoint before active once FP sequencing is properly implemented
	      // (currently sequences with guidance which is too early)
	      // eslint-disable-next-line no-lone-blocks

	      {
	        for (let i = activeFp.length - 1; i >= activeFp.activeWaypointIndex - 1 && i >= 0; i--) {
	          const wp = activeFp.getWaypoint(i); // Managed by legs
	          // FIXME these should integrate with the normal algorithms to pick up contraints, not be drawn in enroute ranges, etc.

	          const legType = wp.additionalData.legType;

	          if (legType === LegType.CA || legType === LegType.CR || legType === LegType.CI || legType === LegType.FM || legType === LegType.PI || legType === LegType.VA || legType === LegType.VI || legType === LegType.VM) {
	            continue;
	          }

	          if (wp.type === 'A') {
	            // we pick these up later
	            continue;
	          } // if range >= 160, don't include terminal waypoints, except at enroute boundary


	          if (range >= 160) {
	            const segment = activeFp.findSegmentByWaypointIndex(i);

	            if (segment.type === SegmentType.Departure) {
	              // keep the last waypoint from the SID as it is the enroute boundary
	              if (!activeFp.isLastWaypointInSegment(i)) {
	                continue;
	              }
	            } else if (segment.type !== SegmentType.Enroute) {
	              continue;
	            }
	          }

	          if (!withinEditArea(wp.infos.coordinates)) {
	            continue;
	          }

	          let type = NdSymbolTypeFlags.FlightPlan;
	          const constraints = [];
	          let direction;
	          const isCourseReversal = wp.additionalData.legType === LegType.HA || wp.additionalData.legType === LegType.HF || wp.additionalData.legType === LegType.HM || wp.additionalData.legType === LegType.PI;

	          if (i === activeFp.activeWaypointIndex) {
	            type |= NdSymbolTypeFlags.ActiveLegTermination;
	          } else if (isCourseReversal && i > activeFp.activeWaypointIndex + 1 && range <= 80 && !LnavConfig.DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS) {
	            if (wp.turnDirection === TurnDirection.Left) {
	              type |= NdSymbolTypeFlags.CourseReversalLeft;
	            } else {
	              type |= NdSymbolTypeFlags.CourseReversalRight;
	            }

	            direction = wp.additionalData.course;
	          }

	          const isBehindAircraft = i < activeFp.activeWaypointIndex;

	          if (isInLatAutoControl && !isBehindAircraft && wp.legAltitudeDescription > 0 && wp.legAltitudeDescription < 6) {
	            if (!isSelectedVerticalModeActive && shouldShowConstraintCircleInPhase(flightPhase, wp)) {
	              type |= NdSymbolTypeFlags.Constraint;
	              const predictionAtWaypoint = waypointPredictions.get(i);

	              if (predictionAtWaypoint !== null && predictionAtWaypoint !== void 0 && predictionAtWaypoint.isAltitudeConstraintMet) {
	                type |= NdSymbolTypeFlags.MagentaColor;
	              } else if (predictionAtWaypoint) {
	                type |= NdSymbolTypeFlags.AmberColor;
	              }
	            } else if (i === activeFp.activeWaypointIndex) {
	              type |= NdSymbolTypeFlags.Constraint;
	            }
	          }

	          if (!isBehindAircraft && efisOption === EfisOption.Constraints) {
	            const descent = wp.constraintType === WaypointConstraintType.DES;

	            switch (wp.legAltitudeDescription) {
	              case 1:
	                constraints.push(formatConstraintAlt(wp.legAltitude1, descent));
	                break;

	              case 2:
	                constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '+'));
	                break;

	              case 3:
	                constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '-'));
	                break;

	              case 4:
	                constraints.push(formatConstraintAlt(wp.legAltitude1, descent, '-'));
	                constraints.push(formatConstraintAlt(wp.legAltitude2, descent, '+'));
	                break;
	            }

	            if (wp.speedConstraint > 0) {
	              constraints.push(formatConstraintSpeed(wp.speedConstraint));
	            }
	          }

	          upsertSymbol({
	            databaseId: wp.icao,
	            ident: wp.ident,
	            location: wp.infos.coordinates,
	            type,
	            constraints: constraints.length > 0 ? constraints : undefined,
	            direction
	          });
	        }
	      }
	      const airports = [[activeFp.originAirfield, activeFp.getOriginRunway()], [activeFp.destinationAirfield, activeFp.getDestinationRunway()]];

	      for (const [airport, runway] of airports) {
	        if (!airport) {
	          continue;
	        }

	        if (runway) {
	          if (withinEditArea(runway.beginningCoordinates)) {
	            upsertSymbol({
	              databaseId: airport.icao,
	              ident: "".concat(airport.ident).concat(Avionics.Utils.formatRunway(runway.designation)),
	              location: runway.beginningCoordinates,
	              direction: runway.direction,
	              length: runway.length / 1852,
	              type: NdSymbolTypeFlags.Runway
	            });
	          }
	        } else if (withinEditArea(airport.infos.coordinates)) {
	          upsertSymbol({
	            databaseId: airport.icao,
	            ident: airport.ident,
	            location: airport.infos.coordinates,
	            type: NdSymbolTypeFlags.Airport
	          });
	        }
	      } // Pseudo waypoints


	      for (const pwp of this.guidanceController.currentPseudoWaypoints.filter(it => it && it.displayedOnNd)) {
	        upsertSymbol({
	          databaseId: "W      ".concat(pwp.ident),
	          ident: pwp.ident,
	          location: pwp.efisSymbolLla,
	          type: pwp.efisSymbolFlag,
	          distanceFromAirplane: pwp.distanceFromStart
	        });
	      }

	      const wordsPerSymbol = 6;
	      const maxSymbols = 640 / wordsPerSymbol;

	      if (symbols.length > maxSymbols) {
	        symbols.splice(0, symbols.length - maxSymbols);
	        this.guidanceController.efisStateForSide[side].dataLimitReached = true;
	      } else {
	        this.guidanceController.efisStateForSide[side].dataLimitReached = false;
	      }

	      this.syncer.sendEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), symbols); // make sure we don't run too often

	      this.blockUpdate = true;
	      setTimeout(() => {
	        this.blockUpdate = false;
	      }, 200);
	    }
	  }

	  generatePathVectorSymbol(vector) {
	    let typeVectorPart;

	    if (vector.type === PathVectorType.Line) {
	      typeVectorPart = NdSymbolTypeFlags.FlightPlanVectorLine;
	    } else if (vector.type === PathVectorType.Arc) {
	      typeVectorPart = NdSymbolTypeFlags.FlightPlanVectorArc;
	    } else if (vector.type === PathVectorType.DebugPoint) {
	      typeVectorPart = NdSymbolTypeFlags.FlightPlanVectorDebugPoint;
	    } // FIXME https://cdn.discordapp.com/attachments/845070631644430359/911876826169741342/brabs.gif


	    const id = Math.round(Math.random() * 10000).toString();
	    const symbol = {
	      databaseId: id,
	      ident: vector.type === PathVectorType.DebugPoint ? vector.annotation : id,
	      type: NdSymbolTypeFlags.ActiveFlightPlanVector | typeVectorPart,
	      location: vector.startPoint
	    };

	    if (vector.type === PathVectorType.Line) {
	      symbol.lineEnd = vector.endPoint;
	    }

	    if (vector.type === PathVectorType.Arc) {
	      symbol.arcEnd = vector.endPoint;
	      symbol.arcRadius = distanceTo(vector.startPoint, vector.centrePoint);
	      symbol.arcSweepAngle = vector.sweepAngle;
	    }

	    return symbol;
	  }

	  vorDmeTypeFlag(type) {
	    switch (type) {
	      case VorType.VORDME:
	      case VorType.VORTAC:
	        return NdSymbolTypeFlags.VorDme;

	      case VorType.VOR:
	        return NdSymbolTypeFlags.Vor;

	      case VorType.DME:
	      case VorType.TACAN:
	        return NdSymbolTypeFlags.Dme;

	      default:
	        return 0;
	    }
	  }

	  findPointFromEndOfPath(path, distanceFromEnd) {
	    let accumulator = 0; // FIXME take transitions into account on newer FMSs

	    for (const [, leg] of path.legs) {
	      accumulator += leg.distance;

	      if (accumulator > distanceFromEnd) {
	        const distanceFromEndOfLeg = distanceFromEnd - (accumulator - leg.distance);
	        return leg.getPseudoWaypointLocation(distanceFromEndOfLeg);
	      }
	    } // console.error(`[VNAV/findPointFromEndOfPath] ${distanceFromEnd.toFixed(2)}nm is larger than the total lateral path.`);


	    return undefined;
	  }

	  calculateEditArea(range, mode) {
	    switch (mode) {
	      case Mode.ARC:
	        if (range <= 10) {
	          return [10.5, 3.5, 8.3];
	        }

	        if (range <= 20) {
	          return [20.5, 7, 16.6];
	        }

	        if (range <= 40) {
	          return [40.5, 14, 33.2];
	        }

	        if (range <= 80) {
	          return [80.5, 28, 66.4];
	        }

	        if (range <= 160) {
	          return [160.5, 56, 132.8];
	        }

	        return [320.5, 112, 265.6];

	      case Mode.ROSE_NAV:
	        if (range <= 10) {
	          return [7.6, 7.1, 7.1];
	        }

	        if (range <= 20) {
	          return [14.7, 14.2, 14.2];
	        }

	        if (range <= 40) {
	          return [28.9, 28.4, 28.4];
	        }

	        if (range <= 80) {
	          return [57.3, 56.8, 56.8];
	        }

	        if (range <= 160) {
	          return [114.1, 113.6, 113.6];
	        }

	        return [227.7, 227.2, 227.2];

	      case Mode.PLAN:
	        if (range <= 10) {
	          return [7, 7, 7];
	        }

	        if (range <= 20) {
	          return [14, 14, 14];
	        }

	        if (range <= 40) {
	          return [28, 28, 28];
	        }

	        if (range <= 80) {
	          return [56, 56, 56];
	        }

	        if (range <= 160) {
	          return [112, 112, 112];
	        }

	        return [224, 224, 224];

	      default:
	        return [0, 0, 0];
	    }
	  }

	}

	_defineProperty(EfisSymbols, "sides", ['L', 'R']);

	const shouldShowConstraintCircleInPhase = (phase, waypoint) => (phase === FmgcFlightPhase.Takeoff || phase === FmgcFlightPhase.Climb) && waypoint.additionalData.constraintType === WaypointConstraintType.CLB || (phase === FmgcFlightPhase.Cruise || phase === FmgcFlightPhase.Descent || phase === FmgcFlightPhase.Approach) && waypoint.additionalData.constraintType === WaypointConstraintType.DES;

	class ReadySignal {
	  constructor() {
	    _defineProperty(this, "baseInstrument", null);

	    _defineProperty(this, "updateThrottler", new A32NX_Util.UpdateThrottler(1000));
	  }

	  init(baseInstrument, _flightPlanManager) {
	    this.baseInstrument = baseInstrument;
	  }

	  update(deltaTime) {
	    if (this.updateThrottler.canUpdate(deltaTime) !== -1 && this.baseInstrument.getGameState() === GameState.ingame && SimVar.GetSimVarValue('L:A32NX_IS_READY', 'number') !== 1) {
	      // set ready signal that JS code is initialized and flight is actually started
	      // -> user pressed 'READY TO FLY' button
	      SimVar.SetSimVarValue('L:A32NX_IS_READY', 'number', 1);
	    }
	  }

	}

	class EfisLabels {
	  constructor() {
	    _defineProperty(this, "lastTransitionAltitude", void 0);

	    _defineProperty(this, "lastTransitionLevel", void 0);

	    _defineProperty(this, "flightPlanManager", void 0);
	  }

	  init(_baseInstrument, flightPlanManager) {
	    this.flightPlanManager = flightPlanManager;
	  }

	  update(_deltaTime) {
	    const transitionAltitude = this.flightPlanManager.originTransitionAltitude;
	    const transitionLevel = this.flightPlanManager.destinationTransitionLevel; // FIXME ARINC429 when the PR adding a TS impl. lands...

	    if (transitionAltitude !== this.lastTransitionAltitude) {
	      SimVar.SetSimVarValue('L:AIRLINER_TRANS_ALT', 'Number', transitionAltitude !== null && transitionAltitude !== void 0 ? transitionAltitude : 0);
	      this.lastTransitionAltitude = transitionAltitude;
	    }

	    if (transitionLevel !== this.lastTransitionLevel) {
	      SimVar.SetSimVarValue('L:AIRLINER_APPR_TRANS_ALT', 'Number', (transitionLevel !== null && transitionLevel !== void 0 ? transitionLevel : 0) * 100);
	      this.lastTransitionLevel = transitionLevel;
	    }
	  }

	}

	/** See a320-coherent-triggers.md */
	const FMMessageTriggers = {
	  SEND_TO_MCDU: 'A32NX_FMGC_SEND_MESSAGE_TO_MCDU',
	  RECALL_FROM_MCDU_WITH_ID: 'A32NX_FMGC_RECALL_MESSAGE_FROM_MCDU_WITH_ID',
	  POP_FROM_STACK: 'A32NX_FMGC_POP_MESSAGE'
	};
	/* eslint-disable no-multi-spaces */

	let NdFmMessageFlag;
	/* eslint-enable no-multi-spaces */

	(function (NdFmMessageFlag) {
	  NdFmMessageFlag[NdFmMessageFlag["None"] = 0] = "None";
	  NdFmMessageFlag[NdFmMessageFlag["SelectTrueRef"] = 1] = "SelectTrueRef";
	  NdFmMessageFlag[NdFmMessageFlag["CheckNorthRef"] = 2] = "CheckNorthRef";
	  NdFmMessageFlag[NdFmMessageFlag["NavAccuracyDowngrade"] = 4] = "NavAccuracyDowngrade";
	  NdFmMessageFlag[NdFmMessageFlag["NavAccuracyUpgradeNoGps"] = 8] = "NavAccuracyUpgradeNoGps";
	  NdFmMessageFlag[NdFmMessageFlag["SpecifiedVorDmeUnavailble"] = 16] = "SpecifiedVorDmeUnavailble";
	  NdFmMessageFlag[NdFmMessageFlag["NavAccuracyUpgradeGps"] = 32] = "NavAccuracyUpgradeGps";
	  NdFmMessageFlag[NdFmMessageFlag["GpsPrimary"] = 64] = "GpsPrimary";
	  NdFmMessageFlag[NdFmMessageFlag["MapPartlyDisplayed"] = 128] = "MapPartlyDisplayed";
	  NdFmMessageFlag[NdFmMessageFlag["SetOffsideRangeMode"] = 256] = "SetOffsideRangeMode";
	  NdFmMessageFlag[NdFmMessageFlag["OffsideFmControl"] = 512] = "OffsideFmControl";
	  NdFmMessageFlag[NdFmMessageFlag["OffsideFmWxrControl"] = 1024] = "OffsideFmWxrControl";
	  NdFmMessageFlag[NdFmMessageFlag["OffsideWxrControl"] = 2048] = "OffsideWxrControl";
	  NdFmMessageFlag[NdFmMessageFlag["GpsPrimaryLost"] = 4096] = "GpsPrimaryLost";
	  NdFmMessageFlag[NdFmMessageFlag["RtaMissed"] = 8192] = "RtaMissed";
	  NdFmMessageFlag[NdFmMessageFlag["BackupNav"] = 16384] = "BackupNav";
	})(NdFmMessageFlag || (NdFmMessageFlag = {}));

	const FMMessageTypes = {
	  SelectTrueRef: {
	    id: 1,
	    ndFlag: NdFmMessageFlag.SelectTrueRef,
	    text: 'SELECT TRUE REF',
	    color: 'Amber',
	    ndPriority: 1,
	    clearable: true
	  },
	  CheckNorthRef: {
	    id: 2,
	    ndFlag: NdFmMessageFlag.CheckNorthRef,
	    text: 'CHECK NORTH REF',
	    color: 'Amber',
	    ndPriority: 1,
	    clearable: true
	  },
	  NavAccuracyDowngrade: {
	    id: 3,
	    ndFlag: NdFmMessageFlag.NavAccuracyDowngrade,
	    text: 'NAV ACCUR DOWNGRAD',
	    color: 'Amber',
	    ndPriority: 1,
	    clearable: true
	  },
	  NavAccuracyUpgradeNoGps: {
	    id: 4,
	    ndFlag: NdFmMessageFlag.NavAccuracyUpgradeNoGps,
	    text: 'NAV ACCUR UPGRAD',
	    color: 'Amber',
	    ndPriority: 1,
	    clearable: true
	  },
	  SpecifiedVorDmeUnavailble: {
	    id: 5,
	    ndFlag: NdFmMessageFlag.SpecifiedVorDmeUnavailble,
	    text: 'SPECIF VOR/D UNAVAIL',
	    color: 'Amber',
	    ndPriority: 1,
	    clearable: true
	  },
	  NavAccuracyUpgradeGps: {
	    id: 6,
	    ndFlag: NdFmMessageFlag.NavAccuracyUpgradeGps,
	    text: 'NAV ACCUR UPGRAD',
	    color: 'White',
	    ndPriority: 1,
	    clearable: true
	  },
	  GpsPrimary: {
	    id: 7,
	    ndFlag: NdFmMessageFlag.GpsPrimary,
	    text: 'GPS PRIMARY',
	    color: 'White',
	    ndPriority: 1,
	    clearable: true
	  },
	  MapPartlyDisplayed: {
	    id: 8,
	    ndFlag: NdFmMessageFlag.MapPartlyDisplayed,
	    efisText: 'MAP PARTLY DISPLAYED',
	    color: 'Amber',
	    ndPriority: 2
	  },
	  SetOffsideRangeMode: {
	    id: 9,
	    ndFlag: NdFmMessageFlag.SetOffsideRangeMode,
	    text: 'SET OFFSIDE RNG/MODE',
	    color: 'Amber',
	    ndPriority: 3
	  },
	  OffsideFmControl: {
	    id: 10,
	    ndFlag: NdFmMessageFlag.OffsideFmControl,
	    text: 'OFFSIDE FM CONTROL',
	    color: 'Amber',
	    ndPriority: 4
	  },
	  OffsideFmWxrControl: {
	    id: 11,
	    ndFlag: NdFmMessageFlag.OffsideFmWxrControl,
	    text: 'OFFSIDE FM/WXR CONTROL',
	    color: 'Amber',
	    ndPriority: 5
	  },
	  OffsideWxrControl: {
	    id: 12,
	    ndFlag: NdFmMessageFlag.OffsideWxrControl,
	    text: 'OFFSIDE WXR CONTROL',
	    color: 'Amber',
	    ndPriority: 6
	  },
	  GpsPrimaryLost: {
	    id: 13,
	    ndFlag: NdFmMessageFlag.GpsPrimaryLost,
	    text: 'GPS PRIMARY LOST',
	    color: 'Amber',
	    ndPriority: 7
	  },
	  RtaMissed: {
	    id: 14,
	    ndFlag: NdFmMessageFlag.RtaMissed,
	    text: 'RTA MISSED',
	    color: 'Amber',
	    ndPriority: 8
	  },
	  BackupNav: {
	    id: 15,
	    ndFlag: NdFmMessageFlag.BackupNav,
	    text: 'BACK UP NAV',
	    color: 'Amber',
	    ndPriority: 9
	  },
	  TurnAreaExceedance: {
	    id: 16,
	    text: 'TURN AREA EXCEEDANCE',
	    color: 'Amber'
	  },
	  TdReached: {
	    id: 17,
	    text: 'T/D REACHED',
	    color: 'White',
	    clearable: true
	  },
	  StepAhead: {
	    id: 18,
	    text: 'STEP AHEAD',
	    color: 'White',
	    clearable: true
	  },
	  StepDeleted: {
	    id: 19,
	    text: 'STEP DELETED',
	    color: 'White',
	    clearable: true
	  }
	};

	class TurnAreaExceedance {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.TurnAreaExceedance);

	    _defineProperty(this, "efisSide", void 0);

	    _defineProperty(this, "trigRising", new Trigger(true));

	    _defineProperty(this, "trigFalling", new Trigger(true));

	    _defineProperty(this, "guidanceController", void 0);

	    _defineProperty(this, "navigation", void 0);
	  }

	  init(baseInstrument) {
	    this.guidanceController = baseInstrument.guidanceController;
	    this.navigation = baseInstrument.navigation;
	  }

	  process(deltaTime) {
	    var _this$guidanceControl;

	    const gs = this.navigation.groundSpeed;
	    const dtg = (_this$guidanceControl = this.guidanceController.activeLegDtg) !== null && _this$guidanceControl !== void 0 ? _this$guidanceControl : Infinity;
	    const ttg = gs > 10 ? 3600 * dtg / gs : Infinity;
	    const nextLeg = this.guidanceController.activeGeometry.legs.get(this.guidanceController.activeLegIndex + 1); // if within 1.5 min of PI and it's path goes outside the coded distance limit

	    const turnAreaExceeded = ttg <= 90 && nextLeg instanceof PILeg && nextLeg.turnAreaExceeded;
	    this.trigRising.input = turnAreaExceeded;
	    this.trigRising.update(deltaTime);
	    this.trigFalling.input = !turnAreaExceeded;
	    this.trigFalling.update(deltaTime);

	    if (this.trigRising.output) {
	      return FMMessageUpdate.SEND;
	    }

	    if (this.trigFalling.output) {
	      return FMMessageUpdate.RECALL;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	class TurnAreaExceedanceLeft extends TurnAreaExceedance {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "efisSide", 'L');
	  }

	}
	class TurnAreaExceedanceRight extends TurnAreaExceedance {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "efisSide", 'R');
	  }

	}

	class TdReached {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.TdReached);

	    _defineProperty(this, "lastState", false);
	  }

	  process(_) {
	    const newState = SimVar.GetSimVarValue('L:A32NX_PFD_MSG_TD_REACHED', 'Bool') === 1;

	    if (newState !== this.lastState) {
	      this.lastState = newState;
	      return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	class StepAhead {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.StepAhead);

	    _defineProperty(this, "guidanceController", void 0);

	    _defineProperty(this, "lastState", false);
	  }

	  init(baseInstrument) {
	    this.guidanceController = baseInstrument.guidanceController;
	  }

	  process(_) {
	    const fpm = this.guidanceController.flightPlanManager;
	    const distanceToEnd = this.guidanceController.vnavDriver.distanceToEnd;

	    if (!this.guidanceController.vnavDriver.currentNavGeometryProfile.isReadyToDisplay || distanceToEnd <= 0) {
	      return FMMessageUpdate.NO_ACTION;
	    }

	    let newState = false;

	    for (let i = fpm.getActiveWaypointIndex(); i < fpm.getWaypointsCount(); i++) {
	      const waypoint = fpm.getWaypoint(i);

	      if (!waypoint || !waypoint.additionalData.cruiseStep) {
	        continue;
	      }

	      if (distanceToEnd - waypoint.additionalData.distanceToEnd < 20) {
	        newState = true;
	      }
	    }

	    if (newState !== this.lastState) {
	      this.lastState = newState;
	      return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	class StepDeleted {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.StepDeleted);
	  }

	  process(_) {
	    const newState = SimVar.GetSimVarValue('L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED', 'Bool') === 1;

	    if (newState) {
	      SimVar.SetSimVarValue('L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED', 'boolean', false);
	      return FMMessageUpdate.SEND;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	class GpsPrimary {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.GpsPrimary);

	    _defineProperty(this, "lastState", false);
	  }

	  process(_) {
	    const newState = SimVar.GetSimVarValue('L:A32NX_ADIRS_USES_GPS_AS_PRIMARY', 'Bool') === 1;

	    if (newState !== this.lastState) {
	      this.lastState = newState;
	      return newState ? FMMessageUpdate.SEND : FMMessageUpdate.RECALL;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	/**
	 * Since this happens when the simvar goes to zero, we need to use some CONF nodes to make sure we do not count the initial
	 * first-frame value, as the ADIRS module might not have run yet.
	 */

	class GpsPrimaryLost {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.GpsPrimaryLost);

	    _defineProperty(this, "confLost", new ConfirmationNode(1000));

	    _defineProperty(this, "trigLost", new Trigger(true));

	    _defineProperty(this, "confRegained", new ConfirmationNode(1000));

	    _defineProperty(this, "trigRegained", new Trigger(true));
	  }

	  process(deltaTime) {
	    const lostNow = SimVar.GetSimVarValue('L:A32NX_ADIRS_USES_GPS_AS_PRIMARY', 'Bool') === 0;
	    this.confLost.input = lostNow;
	    this.confLost.update(deltaTime);
	    this.trigLost.input = this.confLost.output;
	    this.trigLost.update(deltaTime);
	    this.confRegained.input = !lostNow;
	    this.confRegained.update(deltaTime);
	    this.trigRegained.input = this.confRegained.output;
	    this.trigRegained.update(deltaTime);

	    if (this.trigLost.output) {
	      return FMMessageUpdate.SEND;
	    }

	    if (this.trigRegained.output) {
	      return FMMessageUpdate.RECALL;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	class MapPartlyDisplayed {
	  constructor() {
	    _defineProperty(this, "message", FMMessageTypes.MapPartlyDisplayed);

	    _defineProperty(this, "efisSide", void 0);

	    _defineProperty(this, "trigRising", new Trigger(true));

	    _defineProperty(this, "trigFalling", new Trigger(true));
	  }

	  process(deltaTime) {
	    const partlyDisplayed = SimVar.GetSimVarValue("L:A32NX_EFIS_".concat(this.efisSide, "_MAP_PARTLY_DISPLAYED"), 'boolean');
	    this.trigRising.input = partlyDisplayed === 1;
	    this.trigRising.update(deltaTime);
	    this.trigFalling.input = partlyDisplayed === 0;
	    this.trigFalling.update(deltaTime);

	    if (this.trigRising.output) {
	      return FMMessageUpdate.SEND;
	    }

	    if (this.trigFalling.output) {
	      return FMMessageUpdate.RECALL;
	    }

	    return FMMessageUpdate.NO_ACTION;
	  }

	}

	class MapPartlyDisplayedLeft extends MapPartlyDisplayed {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "efisSide", 'L');
	  }

	}
	class MapPartlyDisplayedRight extends MapPartlyDisplayed {
	  constructor() {
	    super(...arguments);

	    _defineProperty(this, "efisSide", 'R');
	  }

	}

	/**
	 * This class manages Type II messages sent from the FMGC.
	 *
	 * Since many of those are also sent to the EFIS, this class sets a bitfield signalling the active messages to the DMCs
	 *
	 * At the moment, other Type II messages which are not displayed on the EFIS are declared in the old JavaScript CDU/"FMC".
	 *
	 * **Note:** The plan is eventually to move them here as well - but since they can be triggered manually on pilot output as well, and it
	 * is not currently convenient to use this class from the JS CDU, we will not do that at the moment
	 *
	 * -Benjamin
	 */

	class FmsMessages {
	  constructor() {
	    _defineProperty(this, "listener", RegisterViewListener('JS_LISTENER_SIMVARS', null, true));

	    _defineProperty(this, "baseInstrument", void 0);

	    _defineProperty(this, "ndMessageFlags", {
	      L: 0,
	      R: 0
	    });

	    _defineProperty(this, "messageSelectors", [new GpsPrimary(), new GpsPrimaryLost(), new MapPartlyDisplayedLeft(), new MapPartlyDisplayedRight(), new TurnAreaExceedanceLeft(), new TurnAreaExceedanceRight(), new TdReached(), new StepAhead(), new StepDeleted()]);
	  }

	  init(baseInstrument, _flightPlanManager) {
	    this.baseInstrument = baseInstrument;

	    for (const selector of this.messageSelectors) {
	      if (selector.init) {
	        selector.init(this.baseInstrument);
	      }
	    }
	  }

	  update(deltaTime) {
	    let didMutateNd = false;

	    for (const selector of this.messageSelectors) {
	      const newState = selector.process(deltaTime);
	      const message = selector.message;

	      switch (newState) {
	        case FMMessageUpdate.SEND:
	          if (message.text) {
	            this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
	          }

	          if (message.ndFlag > 0) {
	            if (selector.efisSide) {
	              this.ndMessageFlags[selector.efisSide] |= message.ndFlag;
	            } else {
	              for (const side in this.ndMessageFlags) {
	                if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
	                  this.ndMessageFlags[side] |= message.ndFlag;
	                }
	              }
	            }

	            didMutateNd = true;
	          }

	          break;

	        case FMMessageUpdate.RECALL:
	          if (message.text) {
	            this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id
	          }

	          if (message.ndFlag > 0) {
	            if (selector.efisSide) {
	              this.ndMessageFlags[selector.efisSide] &= ~message.ndFlag;
	            } else {
	              for (const side in this.ndMessageFlags) {
	                if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
	                  this.ndMessageFlags[side] &= ~message.ndFlag;
	                }
	              }
	            }

	            didMutateNd = true;
	          }

	          break;

	        case FMMessageUpdate.NO_ACTION:
	          break;

	        default:
	          throw new Error('Invalid FM message update state');
	      }
	    }

	    if (didMutateNd) {
	      for (const side in this.ndMessageFlags) {
	        if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
	          SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
	        }
	      }
	    }
	  }

	  send(messageClass) {
	    const message = this.messageSelectors.find(it => it instanceof messageClass).message;
	    this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);

	    if (message.ndFlag) {
	      for (const side in this.ndMessageFlags) {
	        if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
	          this.ndMessageFlags[side] |= message.ndFlag;
	          SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
	        }
	      }
	    }
	  }

	  recall(messageClass) {
	    const message = this.messageSelectors.find(it => it instanceof messageClass).message;
	    this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id

	    if (message.ndFlag) {
	      for (const side in this.ndMessageFlags) {
	        if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
	          this.ndMessageFlags[side] &= ~message.ndFlag;
	          SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
	        }
	      }
	    }
	  }

	  recallId(id) {
	    const message = this.messageSelectors.find(it => it.message.id === id).message;
	    this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text); // TODO id

	    if (message.ndFlag) {
	      for (const side in this.ndMessageFlags) {
	        if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
	          this.ndMessageFlags[side] &= ~message.ndFlag;
	          SimVar.SetSimVarValue("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', this.ndMessageFlags[side]);
	        }
	      }
	    }
	  }

	}
	/**
	 * Type II message update state.
	 *
	 * Used when a message selector implements the {@link FMMessageSelector.process `process`} method.
	 */

	let FMMessageUpdate;
	/**
	 * Defines a selector for a Type II message.
	 */

	(function (FMMessageUpdate) {
	  FMMessageUpdate[FMMessageUpdate["NO_ACTION"] = 0] = "NO_ACTION";
	  FMMessageUpdate[FMMessageUpdate["SEND"] = 1] = "SEND";
	  FMMessageUpdate[FMMessageUpdate["RECALL"] = 2] = "RECALL";
	})(FMMessageUpdate || (FMMessageUpdate = {}));

	const fmsMessages = new FmsMessages();
	[fmsMessages, new EfisLabels(), new ReadySignal()];

	({
	  [FlightArea.Takeoff]: 1,
	  [FlightArea.Terminal]: 1,
	  [FlightArea.Enroute]: 2,
	  [FlightArea.Oceanic]: 2,
	  [FlightArea.VorApproach]: 0.5,
	  [FlightArea.GpsApproach]: 0.3,
	  [FlightArea.PrecisionApproach]: 0.5,
	  [FlightArea.NonPrecisionApproach]: 0.5
	});

	const parseApproachName = name => {
	  // L(eft), C(entre), R(ight), T(true North) are the possible runway designators (ARINC424)
	  // If there are multiple procedures for the same type of approach, an alphanumeric suffix is added to their names (last subpattern)
	  // We are a little more lenient than ARINC424 in an effort to match non-perfect navdata, so we allow dashes, spaces, or nothing before the suffix
	  const match = name.trim().match(/^(ILS|LOC|RNAV|NDB|VOR|GPS) (RW)?([0-9]{1,2}[LCRT]?)([\s-]*([A-Z0-9]))?$/);

	  if (!match) {
	    return undefined;
	  }

	  return {
	    type: match[1],
	    runway: match[3],
	    designator: match[5]
	  };
	};
	/**
	 *
	 * @param name approach name from the nav database
	 * @returns max 9 digit name in the format <approach type><runway with leading zero><option -designator><spaces if needed>
	 */

	const normaliseApproachName = name => {
	  const appr = parseApproachName(name);

	  if (!appr) {
	    return name;
	  }

	  const suffix = appr.designator ? "-".concat(appr.designator) : '';
	  return "".concat(appr.type.replace('RNAV', 'RNV')).concat(Avionics.Utils.formatRunway(appr.runway)).concat(suffix);
	};

	const FlightPlanContext = /*#__PURE__*/react.createContext(undefined);
	const FlightPlanProvider = _ref => {
	  let {
	    children
	  } = _ref;
	  const [flightPlanManager] = react.useState(() => new FlightPlanManager(getRootElement()));
	  return /*#__PURE__*/jsxRuntime.jsx(FlightPlanContext.Provider, {
	    value: {
	      flightPlanManager
	    },
	    children: children
	  });
	};

	const useArinc429Var = function (name) {
	  let maxStaleness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  const [value] = useSimVar(name, 'number', maxStaleness);

	  try {
	    return new Arinc429Word(value);
	  } catch (e) {
	    if (e instanceof Arinc429WordSsmParseError) {
	      throw new Error("SimVar \"".concat(name, "\" has an ARINC 429 SSM value ").concat(e.ssm, ", which is outside of the valid range."));
	    }

	    throw e;
	  }
	};

	const Layer = _ref => {
	  let {
	    x = 0,
	    y = 0,
	    id,
	    className,
	    children
	  } = _ref;
	  return /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "translate(".concat(x, ", ").concat(y, ")"),
	    id: id,
	    className: className,
	    children: children
	  });
	};
	/**
	 * Gets the smallest angle between two angles
	 * @param angle1 First angle in degrees
	 * @param angle2 Second angle in degrees
	 * @returns {number} Smallest angle between angle1 and angle2 in degrees
	 */

	const getSmallestAngle = (angle1, angle2) => {
	  let smallestAngle = angle1 - angle2;

	  if (smallestAngle > 180) {
	    smallestAngle -= 360;
	  } else if (smallestAngle < -180) {
	    smallestAngle += 360;
	  }

	  return smallestAngle;
	};
	const isCaptainSide = displayIndex => displayIndex === 1;
	const getSupplier = (displayIndex, knobValue) => {
	  const adirs3ToCaptain = 0;
	  const adirs3ToFO = 2;

	  if (isCaptainSide(displayIndex)) {
	    return knobValue === adirs3ToCaptain ? 3 : 1;
	  }

	  return knobValue === adirs3ToFO ? 3 : 2;
	};

	var scheduler_production_min = createCommonjsModule(function (module, exports) {

	  var f, g, h, k;

	  if ("object" === typeof performance && "function" === typeof performance.now) {
	    var l = performance;

	    exports.unstable_now = function () {
	      return l.now();
	    };
	  } else {
	    var p = Date,
	        q = p.now();

	    exports.unstable_now = function () {
	      return p.now() - q;
	    };
	  }

	  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
	    var t = null,
	        u = null,
	        w = function () {
	      if (null !== t) try {
	        var a = exports.unstable_now();
	        t(!0, a);
	        t = null;
	      } catch (b) {
	        throw setTimeout(w, 0), b;
	      }
	    };

	    f = function (a) {
	      null !== t ? setTimeout(f, 0, a) : (t = a, setTimeout(w, 0));
	    };

	    g = function (a, b) {
	      u = setTimeout(a, b);
	    };

	    h = function () {
	      clearTimeout(u);
	    };

	    exports.unstable_shouldYield = function () {
	      return !1;
	    };

	    k = exports.unstable_forceFrameRate = function () {};
	  } else {
	    var x = window.setTimeout,
	        y = window.clearTimeout;

	    if ("undefined" !== typeof console) {
	      var z = window.cancelAnimationFrame;
	      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
	      "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
	    }

	    var A = !1,
	        B = null,
	        C = -1,
	        D = 5,
	        E = 0;

	    exports.unstable_shouldYield = function () {
	      return exports.unstable_now() >= E;
	    };

	    k = function () {};

	    exports.unstable_forceFrameRate = function (a) {
	      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1E3 / a) : 5;
	    };

	    var F = new MessageChannel(),
	        G = F.port2;

	    F.port1.onmessage = function () {
	      if (null !== B) {
	        var a = exports.unstable_now();
	        E = a + D;

	        try {
	          B(!0, a) ? G.postMessage(null) : (A = !1, B = null);
	        } catch (b) {
	          throw G.postMessage(null), b;
	        }
	      } else A = !1;
	    };

	    f = function (a) {
	      B = a;
	      A || (A = !0, G.postMessage(null));
	    };

	    g = function (a, b) {
	      C = x(function () {
	        a(exports.unstable_now());
	      }, b);
	    };

	    h = function () {
	      y(C);
	      C = -1;
	    };
	  }

	  function H(a, b) {
	    var c = a.length;
	    a.push(b);

	    a: for (;;) {
	      var d = c - 1 >>> 1,
	          e = a[d];
	      if (void 0 !== e && 0 < I(e, b)) a[d] = b, a[c] = e, c = d;else break a;
	    }
	  }

	  function J(a) {
	    a = a[0];
	    return void 0 === a ? null : a;
	  }

	  function K(a) {
	    var b = a[0];

	    if (void 0 !== b) {
	      var c = a.pop();

	      if (c !== b) {
	        a[0] = c;

	        a: for (var d = 0, e = a.length; d < e;) {
	          var m = 2 * (d + 1) - 1,
	              n = a[m],
	              v = m + 1,
	              r = a[v];
	          if (void 0 !== n && 0 > I(n, c)) void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (void 0 !== r && 0 > I(r, c)) a[d] = r, a[v] = c, d = v;else break a;
	        }
	      }

	      return b;
	    }

	    return null;
	  }

	  function I(a, b) {
	    var c = a.sortIndex - b.sortIndex;
	    return 0 !== c ? c : a.id - b.id;
	  }

	  var L = [],
	      M = [],
	      N = 1,
	      O = null,
	      P = 3,
	      Q = !1,
	      R = !1,
	      S = !1;

	  function T(a) {
	    for (var b = J(M); null !== b;) {
	      if (null === b.callback) K(M);else if (b.startTime <= a) K(M), b.sortIndex = b.expirationTime, H(L, b);else break;
	      b = J(M);
	    }
	  }

	  function U(a) {
	    S = !1;
	    T(a);
	    if (!R) if (null !== J(L)) R = !0, f(V);else {
	      var b = J(M);
	      null !== b && g(U, b.startTime - a);
	    }
	  }

	  function V(a, b) {
	    R = !1;
	    S && (S = !1, h());
	    Q = !0;
	    var c = P;

	    try {
	      T(b);

	      for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield());) {
	        var d = O.callback;

	        if ("function" === typeof d) {
	          O.callback = null;
	          P = O.priorityLevel;
	          var e = d(O.expirationTime <= b);
	          b = exports.unstable_now();
	          "function" === typeof e ? O.callback = e : O === J(L) && K(L);
	          T(b);
	        } else K(L);

	        O = J(L);
	      }

	      if (null !== O) var m = !0;else {
	        var n = J(M);
	        null !== n && g(U, n.startTime - b);
	        m = !1;
	      }
	      return m;
	    } finally {
	      O = null, P = c, Q = !1;
	    }
	  }

	  var W = k;
	  exports.unstable_IdlePriority = 5;
	  exports.unstable_ImmediatePriority = 1;
	  exports.unstable_LowPriority = 4;
	  exports.unstable_NormalPriority = 3;
	  exports.unstable_Profiling = null;
	  exports.unstable_UserBlockingPriority = 2;

	  exports.unstable_cancelCallback = function (a) {
	    a.callback = null;
	  };

	  exports.unstable_continueExecution = function () {
	    R || Q || (R = !0, f(V));
	  };

	  exports.unstable_getCurrentPriorityLevel = function () {
	    return P;
	  };

	  exports.unstable_getFirstCallbackNode = function () {
	    return J(L);
	  };

	  exports.unstable_next = function (a) {
	    switch (P) {
	      case 1:
	      case 2:
	      case 3:
	        var b = 3;
	        break;

	      default:
	        b = P;
	    }

	    var c = P;
	    P = b;

	    try {
	      return a();
	    } finally {
	      P = c;
	    }
	  };

	  exports.unstable_pauseExecution = function () {};

	  exports.unstable_requestPaint = W;

	  exports.unstable_runWithPriority = function (a, b) {
	    switch (a) {
	      case 1:
	      case 2:
	      case 3:
	      case 4:
	      case 5:
	        break;

	      default:
	        a = 3;
	    }

	    var c = P;
	    P = a;

	    try {
	      return b();
	    } finally {
	      P = c;
	    }
	  };

	  exports.unstable_scheduleCallback = function (a, b, c) {
	    var d = exports.unstable_now();
	    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;

	    switch (a) {
	      case 1:
	        var e = -1;
	        break;

	      case 2:
	        e = 250;
	        break;

	      case 5:
	        e = 1073741823;
	        break;

	      case 4:
	        e = 1E4;
	        break;

	      default:
	        e = 5E3;
	    }

	    e = c + e;
	    a = {
	      id: N++,
	      callback: b,
	      priorityLevel: a,
	      startTime: c,
	      expirationTime: e,
	      sortIndex: -1
	    };
	    c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = !0, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = !0, f(V)));
	    return a;
	  };

	  exports.unstable_wrapCallback = function (a) {
	    var b = P;
	    return function () {
	      var c = P;
	      P = b;

	      try {
	        return a.apply(this, arguments);
	      } finally {
	        P = c;
	      }
	    };
	  };
	});

	createCommonjsModule(function (module, exports) {
	});

	var scheduler = createCommonjsModule(function (module) {

	  {
	    module.exports = scheduler_production_min;
	  }
	});

	function y(a) {
	  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

	  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}

	if (!react) throw Error(y(227));
	var ba = new Set(),
	    ca = {};

	function da(a, b) {
	  ea(a, b);
	  ea(a + "Capture", b);
	}

	function ea(a, b) {
	  ca[a] = b;

	  for (a = 0; a < b.length; a++) ba.add(b[a]);
	}

	var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
	    ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
	    ia = Object.prototype.hasOwnProperty,
	    ja = {},
	    ka = {};

	function la(a) {
	  if (ia.call(ka, a)) return !0;
	  if (ia.call(ja, a)) return !1;
	  if (ha.test(a)) return ka[a] = !0;
	  ja[a] = !0;
	  return !1;
	}

	function ma(a, b, c, d) {
	  if (null !== c && 0 === c.type) return !1;

	  switch (typeof b) {
	    case "function":
	    case "symbol":
	      return !0;

	    case "boolean":
	      if (d) return !1;
	      if (null !== c) return !c.acceptsBooleans;
	      a = a.toLowerCase().slice(0, 5);
	      return "data-" !== a && "aria-" !== a;

	    default:
	      return !1;
	  }
	}

	function na(a, b, c, d) {
	  if (null === b || "undefined" === typeof b || ma(a, b, c, d)) return !0;
	  if (d) return !1;
	  if (null !== c) switch (c.type) {
	    case 3:
	      return !b;

	    case 4:
	      return !1 === b;

	    case 5:
	      return isNaN(b);

	    case 6:
	      return isNaN(b) || 1 > b;
	  }
	  return !1;
	}

	function B(a, b, c, d, e, f, g) {
	  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
	  this.attributeName = d;
	  this.attributeNamespace = e;
	  this.mustUseProperty = c;
	  this.propertyName = a;
	  this.type = b;
	  this.sanitizeURL = f;
	  this.removeEmptyString = g;
	}

	var D = {};
	"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
	  D[a] = new B(a, 0, !1, a, null, !1, !1);
	});
	[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
	  var b = a[0];
	  D[b] = new B(b, 1, !1, a[1], null, !1, !1);
	});
	["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
	  D[a] = new B(a, 2, !1, a.toLowerCase(), null, !1, !1);
	});
	["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
	  D[a] = new B(a, 2, !1, a, null, !1, !1);
	});
	"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
	  D[a] = new B(a, 3, !1, a.toLowerCase(), null, !1, !1);
	});
	["checked", "multiple", "muted", "selected"].forEach(function (a) {
	  D[a] = new B(a, 3, !0, a, null, !1, !1);
	});
	["capture", "download"].forEach(function (a) {
	  D[a] = new B(a, 4, !1, a, null, !1, !1);
	});
	["cols", "rows", "size", "span"].forEach(function (a) {
	  D[a] = new B(a, 6, !1, a, null, !1, !1);
	});
	["rowSpan", "start"].forEach(function (a) {
	  D[a] = new B(a, 5, !1, a.toLowerCase(), null, !1, !1);
	});
	var oa = /[\-:]([a-z])/g;

	function pa(a) {
	  return a[1].toUpperCase();
	}

	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
	  var b = a.replace(oa, pa);
	  D[b] = new B(b, 1, !1, a, null, !1, !1);
	});
	"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
	  var b = a.replace(oa, pa);
	  D[b] = new B(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
	});
	["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
	  var b = a.replace(oa, pa);
	  D[b] = new B(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
	});
	["tabIndex", "crossOrigin"].forEach(function (a) {
	  D[a] = new B(a, 1, !1, a.toLowerCase(), null, !1, !1);
	});
	D.xlinkHref = new B("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
	["src", "href", "action", "formAction"].forEach(function (a) {
	  D[a] = new B(a, 1, !1, a.toLowerCase(), null, !0, !0);
	});

	function qa(a, b, c, d) {
	  var e = D.hasOwnProperty(b) ? D[b] : null;
	  var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0;
	  f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
	}

	var ra = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
	    sa = 60103,
	    ta = 60106,
	    ua = 60107,
	    wa = 60108,
	    xa = 60114,
	    ya = 60109,
	    za = 60110,
	    Aa = 60112,
	    Ba = 60113,
	    Ca = 60120,
	    Da = 60115,
	    Ea = 60116,
	    Fa = 60121,
	    Ga = 60128,
	    Ha = 60129,
	    Ia = 60130,
	    Ja = 60131;

	if ("function" === typeof Symbol && Symbol.for) {
	  var E = Symbol.for;
	  sa = E("react.element");
	  ta = E("react.portal");
	  ua = E("react.fragment");
	  wa = E("react.strict_mode");
	  xa = E("react.profiler");
	  ya = E("react.provider");
	  za = E("react.context");
	  Aa = E("react.forward_ref");
	  Ba = E("react.suspense");
	  Ca = E("react.suspense_list");
	  Da = E("react.memo");
	  Ea = E("react.lazy");
	  Fa = E("react.block");
	  E("react.scope");
	  Ga = E("react.opaque.id");
	  Ha = E("react.debug_trace_mode");
	  Ia = E("react.offscreen");
	  Ja = E("react.legacy_hidden");
	}

	var Ka = "function" === typeof Symbol && Symbol.iterator;

	function La(a) {
	  if (null === a || "object" !== typeof a) return null;
	  a = Ka && a[Ka] || a["@@iterator"];
	  return "function" === typeof a ? a : null;
	}

	var Ma;

	function Na(a) {
	  if (void 0 === Ma) try {
	    throw Error();
	  } catch (c) {
	    var b = c.stack.trim().match(/\n( *(at )?)/);
	    Ma = b && b[1] || "";
	  }
	  return "\n" + Ma + a;
	}

	var Oa = !1;

	function Pa(a, b) {
	  if (!a || Oa) return "";
	  Oa = !0;
	  var c = Error.prepareStackTrace;
	  Error.prepareStackTrace = void 0;

	  try {
	    if (b) {
	      if (b = function () {
	        throw Error();
	      }, Object.defineProperty(b.prototype, "props", {
	        set: function () {
	          throw Error();
	        }
	      }), "object" === typeof Reflect && Reflect.construct) {
	        try {
	          Reflect.construct(b, []);
	        } catch (k) {
	          var d = k;
	        }

	        Reflect.construct(a, [], b);
	      } else {
	        try {
	          b.call();
	        } catch (k) {
	          d = k;
	        }

	        a.call(b.prototype);
	      }
	    } else {
	      try {
	        throw Error();
	      } catch (k) {
	        d = k;
	      }

	      a();
	    }
	  } catch (k) {
	    if (k && d && "string" === typeof k.stack) {
	      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;

	      for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
	        if (1 !== g || 1 !== h) {
	          do if (g--, h--, 0 > h || e[g] !== f[h]) return "\n" + e[g].replace(" at new ", " at "); while (1 <= g && 0 <= h);
	        }

	        break;
	      }
	    }
	  } finally {
	    Oa = !1, Error.prepareStackTrace = c;
	  }

	  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
	}

	function Qa(a) {
	  switch (a.tag) {
	    case 5:
	      return Na(a.type);

	    case 16:
	      return Na("Lazy");

	    case 13:
	      return Na("Suspense");

	    case 19:
	      return Na("SuspenseList");

	    case 0:
	    case 2:
	    case 15:
	      return a = Pa(a.type, !1), a;

	    case 11:
	      return a = Pa(a.type.render, !1), a;

	    case 22:
	      return a = Pa(a.type._render, !1), a;

	    case 1:
	      return a = Pa(a.type, !0), a;

	    default:
	      return "";
	  }
	}

	function Ra(a) {
	  if (null == a) return null;
	  if ("function" === typeof a) return a.displayName || a.name || null;
	  if ("string" === typeof a) return a;

	  switch (a) {
	    case ua:
	      return "Fragment";

	    case ta:
	      return "Portal";

	    case xa:
	      return "Profiler";

	    case wa:
	      return "StrictMode";

	    case Ba:
	      return "Suspense";

	    case Ca:
	      return "SuspenseList";
	  }

	  if ("object" === typeof a) switch (a.$$typeof) {
	    case za:
	      return (a.displayName || "Context") + ".Consumer";

	    case ya:
	      return (a._context.displayName || "Context") + ".Provider";

	    case Aa:
	      var b = a.render;
	      b = b.displayName || b.name || "";
	      return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");

	    case Da:
	      return Ra(a.type);

	    case Fa:
	      return Ra(a._render);

	    case Ea:
	      b = a._payload;
	      a = a._init;

	      try {
	        return Ra(a(b));
	      } catch (c) {}

	  }
	  return null;
	}

	function Sa(a) {
	  switch (typeof a) {
	    case "boolean":
	    case "number":
	    case "object":
	    case "string":
	    case "undefined":
	      return a;

	    default:
	      return "";
	  }
	}

	function Ta(a) {
	  var b = a.type;
	  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
	}

	function Ua(a) {
	  var b = Ta(a) ? "checked" : "value",
	      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
	      d = "" + a[b];

	  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
	    var e = c.get,
	        f = c.set;
	    Object.defineProperty(a, b, {
	      configurable: !0,
	      get: function () {
	        return e.call(this);
	      },
	      set: function (a) {
	        d = "" + a;
	        f.call(this, a);
	      }
	    });
	    Object.defineProperty(a, b, {
	      enumerable: c.enumerable
	    });
	    return {
	      getValue: function () {
	        return d;
	      },
	      setValue: function (a) {
	        d = "" + a;
	      },
	      stopTracking: function () {
	        a._valueTracker = null;
	        delete a[b];
	      }
	    };
	  }
	}

	function Va(a) {
	  a._valueTracker || (a._valueTracker = Ua(a));
	}

	function Wa(a) {
	  if (!a) return !1;
	  var b = a._valueTracker;
	  if (!b) return !0;
	  var c = b.getValue();
	  var d = "";
	  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
	  a = d;
	  return a !== c ? (b.setValue(a), !0) : !1;
	}

	function Xa(a) {
	  a = a || ("undefined" !== typeof document ? document : void 0);
	  if ("undefined" === typeof a) return null;

	  try {
	    return a.activeElement || a.body;
	  } catch (b) {
	    return a.body;
	  }
	}

	function Ya(a, b) {
	  var c = b.checked;
	  return objectAssign({}, b, {
	    defaultChecked: void 0,
	    defaultValue: void 0,
	    value: void 0,
	    checked: null != c ? c : a._wrapperState.initialChecked
	  });
	}

	function Za(a, b) {
	  var c = null == b.defaultValue ? "" : b.defaultValue,
	      d = null != b.checked ? b.checked : b.defaultChecked;
	  c = Sa(null != b.value ? b.value : c);
	  a._wrapperState = {
	    initialChecked: d,
	    initialValue: c,
	    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
	  };
	}

	function $a(a, b) {
	  b = b.checked;
	  null != b && qa(a, "checked", b, !1);
	}

	function ab(a, b) {
	  $a(a, b);
	  var c = Sa(b.value),
	      d = b.type;
	  if (null != c) {
	    if ("number" === d) {
	      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
	    } else a.value !== "" + c && (a.value = "" + c);
	  } else if ("submit" === d || "reset" === d) {
	    a.removeAttribute("value");
	    return;
	  }
	  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
	  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
	}

	function cb(a, b, c) {
	  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
	    var d = b.type;
	    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
	    b = "" + a._wrapperState.initialValue;
	    c || b === a.value || (a.value = b);
	    a.defaultValue = b;
	  }

	  c = a.name;
	  "" !== c && (a.name = "");
	  a.defaultChecked = !!a._wrapperState.initialChecked;
	  "" !== c && (a.name = c);
	}

	function bb(a, b, c) {
	  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
	}

	function db(a) {
	  var b = "";
	  react.Children.forEach(a, function (a) {
	    null != a && (b += a);
	  });
	  return b;
	}

	function eb(a, b) {
	  a = objectAssign({
	    children: void 0
	  }, b);
	  if (b = db(b.children)) a.children = b;
	  return a;
	}

	function fb(a, b, c, d) {
	  a = a.options;

	  if (b) {
	    b = {};

	    for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;

	    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
	  } else {
	    c = "" + Sa(c);
	    b = null;

	    for (e = 0; e < a.length; e++) {
	      if (a[e].value === c) {
	        a[e].selected = !0;
	        d && (a[e].defaultSelected = !0);
	        return;
	      }

	      null !== b || a[e].disabled || (b = a[e]);
	    }

	    null !== b && (b.selected = !0);
	  }
	}

	function gb(a, b) {
	  if (null != b.dangerouslySetInnerHTML) throw Error(y(91));
	  return objectAssign({}, b, {
	    value: void 0,
	    defaultValue: void 0,
	    children: "" + a._wrapperState.initialValue
	  });
	}

	function hb(a, b) {
	  var c = b.value;

	  if (null == c) {
	    c = b.children;
	    b = b.defaultValue;

	    if (null != c) {
	      if (null != b) throw Error(y(92));

	      if (Array.isArray(c)) {
	        if (!(1 >= c.length)) throw Error(y(93));
	        c = c[0];
	      }

	      b = c;
	    }

	    null == b && (b = "");
	    c = b;
	  }

	  a._wrapperState = {
	    initialValue: Sa(c)
	  };
	}

	function ib(a, b) {
	  var c = Sa(b.value),
	      d = Sa(b.defaultValue);
	  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
	  null != d && (a.defaultValue = "" + d);
	}

	function jb(a) {
	  var b = a.textContent;
	  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
	}

	var kb = {
	  html: "http://www.w3.org/1999/xhtml",
	  mathml: "http://www.w3.org/1998/Math/MathML",
	  svg: "http://www.w3.org/2000/svg"
	};

	function lb(a) {
	  switch (a) {
	    case "svg":
	      return "http://www.w3.org/2000/svg";

	    case "math":
	      return "http://www.w3.org/1998/Math/MathML";

	    default:
	      return "http://www.w3.org/1999/xhtml";
	  }
	}

	function mb(a, b) {
	  return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
	}

	var nb,
	    ob = function (a) {
	  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
	    MSApp.execUnsafeLocalFunction(function () {
	      return a(b, c, d, e);
	    });
	  } : a;
	}(function (a, b) {
	  if (a.namespaceURI !== kb.svg || "innerHTML" in a) a.innerHTML = b;else {
	    nb = nb || document.createElement("div");
	    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";

	    for (b = nb.firstChild; a.firstChild;) a.removeChild(a.firstChild);

	    for (; b.firstChild;) a.appendChild(b.firstChild);
	  }
	});

	function pb(a, b) {
	  if (b) {
	    var c = a.firstChild;

	    if (c && c === a.lastChild && 3 === c.nodeType) {
	      c.nodeValue = b;
	      return;
	    }
	  }

	  a.textContent = b;
	}

	var qb = {
	  animationIterationCount: !0,
	  borderImageOutset: !0,
	  borderImageSlice: !0,
	  borderImageWidth: !0,
	  boxFlex: !0,
	  boxFlexGroup: !0,
	  boxOrdinalGroup: !0,
	  columnCount: !0,
	  columns: !0,
	  flex: !0,
	  flexGrow: !0,
	  flexPositive: !0,
	  flexShrink: !0,
	  flexNegative: !0,
	  flexOrder: !0,
	  gridArea: !0,
	  gridRow: !0,
	  gridRowEnd: !0,
	  gridRowSpan: !0,
	  gridRowStart: !0,
	  gridColumn: !0,
	  gridColumnEnd: !0,
	  gridColumnSpan: !0,
	  gridColumnStart: !0,
	  fontWeight: !0,
	  lineClamp: !0,
	  lineHeight: !0,
	  opacity: !0,
	  order: !0,
	  orphans: !0,
	  tabSize: !0,
	  widows: !0,
	  zIndex: !0,
	  zoom: !0,
	  fillOpacity: !0,
	  floodOpacity: !0,
	  stopOpacity: !0,
	  strokeDasharray: !0,
	  strokeDashoffset: !0,
	  strokeMiterlimit: !0,
	  strokeOpacity: !0,
	  strokeWidth: !0
	},
	    rb = ["Webkit", "ms", "Moz", "O"];
	Object.keys(qb).forEach(function (a) {
	  rb.forEach(function (b) {
	    b = b + a.charAt(0).toUpperCase() + a.substring(1);
	    qb[b] = qb[a];
	  });
	});

	function sb(a, b, c) {
	  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
	}

	function tb(a, b) {
	  a = a.style;

	  for (var c in b) if (b.hasOwnProperty(c)) {
	    var d = 0 === c.indexOf("--"),
	        e = sb(c, b[c], d);
	    "float" === c && (c = "cssFloat");
	    d ? a.setProperty(c, e) : a[c] = e;
	  }
	}

	var ub = objectAssign({
	  menuitem: !0
	}, {
	  area: !0,
	  base: !0,
	  br: !0,
	  col: !0,
	  embed: !0,
	  hr: !0,
	  img: !0,
	  input: !0,
	  keygen: !0,
	  link: !0,
	  meta: !0,
	  param: !0,
	  source: !0,
	  track: !0,
	  wbr: !0
	});

	function vb(a, b) {
	  if (b) {
	    if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(y(137, a));

	    if (null != b.dangerouslySetInnerHTML) {
	      if (null != b.children) throw Error(y(60));
	      if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML)) throw Error(y(61));
	    }

	    if (null != b.style && "object" !== typeof b.style) throw Error(y(62));
	  }
	}

	function wb(a, b) {
	  if (-1 === a.indexOf("-")) return "string" === typeof b.is;

	  switch (a) {
	    case "annotation-xml":
	    case "color-profile":
	    case "font-face":
	    case "font-face-src":
	    case "font-face-uri":
	    case "font-face-format":
	    case "font-face-name":
	    case "missing-glyph":
	      return !1;

	    default:
	      return !0;
	  }
	}

	function xb(a) {
	  a = a.target || a.srcElement || window;
	  a.correspondingUseElement && (a = a.correspondingUseElement);
	  return 3 === a.nodeType ? a.parentNode : a;
	}

	var yb = null,
	    zb = null,
	    Ab = null;

	function Bb(a) {
	  if (a = Cb(a)) {
	    if ("function" !== typeof yb) throw Error(y(280));
	    var b = a.stateNode;
	    b && (b = Db(b), yb(a.stateNode, a.type, b));
	  }
	}

	function Eb(a) {
	  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
	}

	function Fb() {
	  if (zb) {
	    var a = zb,
	        b = Ab;
	    Ab = zb = null;
	    Bb(a);
	    if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
	  }
	}

	function Gb(a, b) {
	  return a(b);
	}

	function Hb(a, b, c, d, e) {
	  return a(b, c, d, e);
	}

	function Ib() {}

	var Jb = Gb,
	    Kb = !1,
	    Lb = !1;

	function Mb() {
	  if (null !== zb || null !== Ab) Ib(), Fb();
	}

	function Nb(a, b, c) {
	  if (Lb) return a(b, c);
	  Lb = !0;

	  try {
	    return Jb(a, b, c);
	  } finally {
	    Lb = !1, Mb();
	  }
	}

	function Ob(a, b) {
	  var c = a.stateNode;
	  if (null === c) return null;
	  var d = Db(c);
	  if (null === d) return null;
	  c = d[b];

	  a: switch (b) {
	    case "onClick":
	    case "onClickCapture":
	    case "onDoubleClick":
	    case "onDoubleClickCapture":
	    case "onMouseDown":
	    case "onMouseDownCapture":
	    case "onMouseMove":
	    case "onMouseMoveCapture":
	    case "onMouseUp":
	    case "onMouseUpCapture":
	    case "onMouseEnter":
	      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
	      a = !d;
	      break a;

	    default:
	      a = !1;
	  }

	  if (a) return null;
	  if (c && "function" !== typeof c) throw Error(y(231, b, typeof c));
	  return c;
	}

	var Pb = !1;
	if (fa) try {
	  var Qb = {};
	  Object.defineProperty(Qb, "passive", {
	    get: function () {
	      Pb = !0;
	    }
	  });
	  window.addEventListener("test", Qb, Qb);
	  window.removeEventListener("test", Qb, Qb);
	} catch (a) {
	  Pb = !1;
	}

	function Rb(a, b, c, d, e, f, g, h, k) {
	  var l = Array.prototype.slice.call(arguments, 3);

	  try {
	    b.apply(c, l);
	  } catch (n) {
	    this.onError(n);
	  }
	}

	var Sb = !1,
	    Tb = null,
	    Ub = !1,
	    Vb = null,
	    Wb = {
	  onError: function (a) {
	    Sb = !0;
	    Tb = a;
	  }
	};

	function Xb(a, b, c, d, e, f, g, h, k) {
	  Sb = !1;
	  Tb = null;
	  Rb.apply(Wb, arguments);
	}

	function Yb(a, b, c, d, e, f, g, h, k) {
	  Xb.apply(this, arguments);

	  if (Sb) {
	    if (Sb) {
	      var l = Tb;
	      Sb = !1;
	      Tb = null;
	    } else throw Error(y(198));

	    Ub || (Ub = !0, Vb = l);
	  }
	}

	function Zb(a) {
	  var b = a,
	      c = a;
	  if (a.alternate) for (; b.return;) b = b.return;else {
	    a = b;

	    do b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return; while (a);
	  }
	  return 3 === b.tag ? c : null;
	}

	function $b(a) {
	  if (13 === a.tag) {
	    var b = a.memoizedState;
	    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
	    if (null !== b) return b.dehydrated;
	  }

	  return null;
	}

	function ac(a) {
	  if (Zb(a) !== a) throw Error(y(188));
	}

	function bc(a) {
	  var b = a.alternate;

	  if (!b) {
	    b = Zb(a);
	    if (null === b) throw Error(y(188));
	    return b !== a ? null : a;
	  }

	  for (var c = a, d = b;;) {
	    var e = c.return;
	    if (null === e) break;
	    var f = e.alternate;

	    if (null === f) {
	      d = e.return;

	      if (null !== d) {
	        c = d;
	        continue;
	      }

	      break;
	    }

	    if (e.child === f.child) {
	      for (f = e.child; f;) {
	        if (f === c) return ac(e), a;
	        if (f === d) return ac(e), b;
	        f = f.sibling;
	      }

	      throw Error(y(188));
	    }

	    if (c.return !== d.return) c = e, d = f;else {
	      for (var g = !1, h = e.child; h;) {
	        if (h === c) {
	          g = !0;
	          c = e;
	          d = f;
	          break;
	        }

	        if (h === d) {
	          g = !0;
	          d = e;
	          c = f;
	          break;
	        }

	        h = h.sibling;
	      }

	      if (!g) {
	        for (h = f.child; h;) {
	          if (h === c) {
	            g = !0;
	            c = f;
	            d = e;
	            break;
	          }

	          if (h === d) {
	            g = !0;
	            d = f;
	            c = e;
	            break;
	          }

	          h = h.sibling;
	        }

	        if (!g) throw Error(y(189));
	      }
	    }
	    if (c.alternate !== d) throw Error(y(190));
	  }

	  if (3 !== c.tag) throw Error(y(188));
	  return c.stateNode.current === c ? a : b;
	}

	function cc(a) {
	  a = bc(a);
	  if (!a) return null;

	  for (var b = a;;) {
	    if (5 === b.tag || 6 === b.tag) return b;
	    if (b.child) b.child.return = b, b = b.child;else {
	      if (b === a) break;

	      for (; !b.sibling;) {
	        if (!b.return || b.return === a) return null;
	        b = b.return;
	      }

	      b.sibling.return = b.return;
	      b = b.sibling;
	    }
	  }

	  return null;
	}

	function dc(a, b) {
	  for (var c = a.alternate; null !== b;) {
	    if (b === a || b === c) return !0;
	    b = b.return;
	  }

	  return !1;
	}

	var ec,
	    fc,
	    gc,
	    hc,
	    ic = !1,
	    jc = [],
	    kc = null,
	    lc = null,
	    mc = null,
	    nc = new Map(),
	    oc = new Map(),
	    pc = [],
	    qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

	function rc(a, b, c, d, e) {
	  return {
	    blockedOn: a,
	    domEventName: b,
	    eventSystemFlags: c | 16,
	    nativeEvent: e,
	    targetContainers: [d]
	  };
	}

	function sc(a, b) {
	  switch (a) {
	    case "focusin":
	    case "focusout":
	      kc = null;
	      break;

	    case "dragenter":
	    case "dragleave":
	      lc = null;
	      break;

	    case "mouseover":
	    case "mouseout":
	      mc = null;
	      break;

	    case "pointerover":
	    case "pointerout":
	      nc.delete(b.pointerId);
	      break;

	    case "gotpointercapture":
	    case "lostpointercapture":
	      oc.delete(b.pointerId);
	  }
	}

	function tc(a, b, c, d, e, f) {
	  if (null === a || a.nativeEvent !== f) return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
	  a.eventSystemFlags |= d;
	  b = a.targetContainers;
	  null !== e && -1 === b.indexOf(e) && b.push(e);
	  return a;
	}

	function uc(a, b, c, d, e) {
	  switch (b) {
	    case "focusin":
	      return kc = tc(kc, a, b, c, d, e), !0;

	    case "dragenter":
	      return lc = tc(lc, a, b, c, d, e), !0;

	    case "mouseover":
	      return mc = tc(mc, a, b, c, d, e), !0;

	    case "pointerover":
	      var f = e.pointerId;
	      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
	      return !0;

	    case "gotpointercapture":
	      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), !0;
	  }

	  return !1;
	}

	function vc(a) {
	  var b = wc(a.target);

	  if (null !== b) {
	    var c = Zb(b);
	    if (null !== c) if (b = c.tag, 13 === b) {
	      if (b = $b(c), null !== b) {
	        a.blockedOn = b;
	        hc(a.lanePriority, function () {
	          scheduler.unstable_runWithPriority(a.priority, function () {
	            gc(c);
	          });
	        });
	        return;
	      }
	    } else if (3 === b && c.stateNode.hydrate) {
	      a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
	      return;
	    }
	  }

	  a.blockedOn = null;
	}

	function xc(a) {
	  if (null !== a.blockedOn) return !1;

	  for (var b = a.targetContainers; 0 < b.length;) {
	    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
	    if (null !== c) return b = Cb(c), null !== b && fc(b), a.blockedOn = c, !1;
	    b.shift();
	  }

	  return !0;
	}

	function zc(a, b, c) {
	  xc(a) && c.delete(b);
	}

	function Ac() {
	  for (ic = !1; 0 < jc.length;) {
	    var a = jc[0];

	    if (null !== a.blockedOn) {
	      a = Cb(a.blockedOn);
	      null !== a && ec(a);
	      break;
	    }

	    for (var b = a.targetContainers; 0 < b.length;) {
	      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);

	      if (null !== c) {
	        a.blockedOn = c;
	        break;
	      }

	      b.shift();
	    }

	    null === a.blockedOn && jc.shift();
	  }

	  null !== kc && xc(kc) && (kc = null);
	  null !== lc && xc(lc) && (lc = null);
	  null !== mc && xc(mc) && (mc = null);
	  nc.forEach(zc);
	  oc.forEach(zc);
	}

	function Bc(a, b) {
	  a.blockedOn === b && (a.blockedOn = null, ic || (ic = !0, scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, Ac)));
	}

	function Cc(a) {
	  function b(b) {
	    return Bc(b, a);
	  }

	  if (0 < jc.length) {
	    Bc(jc[0], a);

	    for (var c = 1; c < jc.length; c++) {
	      var d = jc[c];
	      d.blockedOn === a && (d.blockedOn = null);
	    }
	  }

	  null !== kc && Bc(kc, a);
	  null !== lc && Bc(lc, a);
	  null !== mc && Bc(mc, a);
	  nc.forEach(b);
	  oc.forEach(b);

	  for (c = 0; c < pc.length; c++) d = pc[c], d.blockedOn === a && (d.blockedOn = null);

	  for (; 0 < pc.length && (c = pc[0], null === c.blockedOn);) vc(c), null === c.blockedOn && pc.shift();
	}

	function Dc(a, b) {
	  var c = {};
	  c[a.toLowerCase()] = b.toLowerCase();
	  c["Webkit" + a] = "webkit" + b;
	  c["Moz" + a] = "moz" + b;
	  return c;
	}

	var Ec = {
	  animationend: Dc("Animation", "AnimationEnd"),
	  animationiteration: Dc("Animation", "AnimationIteration"),
	  animationstart: Dc("Animation", "AnimationStart"),
	  transitionend: Dc("Transition", "TransitionEnd")
	},
	    Fc = {},
	    Gc = {};
	fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);

	function Hc(a) {
	  if (Fc[a]) return Fc[a];
	  if (!Ec[a]) return a;
	  var b = Ec[a],
	      c;

	  for (c in b) if (b.hasOwnProperty(c) && c in Gc) return Fc[a] = b[c];

	  return a;
	}

	var Ic = Hc("animationend"),
	    Jc = Hc("animationiteration"),
	    Kc = Hc("animationstart"),
	    Lc = Hc("transitionend"),
	    Mc = new Map(),
	    Nc = new Map(),
	    Oc = ["abort", "abort", Ic, "animationEnd", Jc, "animationIteration", Kc, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Lc, "transitionEnd", "waiting", "waiting"];

	function Pc(a, b) {
	  for (var c = 0; c < a.length; c += 2) {
	    var d = a[c],
	        e = a[c + 1];
	    e = "on" + (e[0].toUpperCase() + e.slice(1));
	    Nc.set(d, b);
	    Mc.set(d, e);
	    da(e, [d]);
	  }
	}

	var Qc = scheduler.unstable_now;
	Qc();
	var F = 8;

	function Rc(a) {
	  if (0 !== (1 & a)) return F = 15, 1;
	  if (0 !== (2 & a)) return F = 14, 2;
	  if (0 !== (4 & a)) return F = 13, 4;
	  var b = 24 & a;
	  if (0 !== b) return F = 12, b;
	  if (0 !== (a & 32)) return F = 11, 32;
	  b = 192 & a;
	  if (0 !== b) return F = 10, b;
	  if (0 !== (a & 256)) return F = 9, 256;
	  b = 3584 & a;
	  if (0 !== b) return F = 8, b;
	  if (0 !== (a & 4096)) return F = 7, 4096;
	  b = 4186112 & a;
	  if (0 !== b) return F = 6, b;
	  b = 62914560 & a;
	  if (0 !== b) return F = 5, b;
	  if (a & 67108864) return F = 4, 67108864;
	  if (0 !== (a & 134217728)) return F = 3, 134217728;
	  b = 805306368 & a;
	  if (0 !== b) return F = 2, b;
	  if (0 !== (1073741824 & a)) return F = 1, 1073741824;
	  F = 8;
	  return a;
	}

	function Sc(a) {
	  switch (a) {
	    case 99:
	      return 15;

	    case 98:
	      return 10;

	    case 97:
	    case 96:
	      return 8;

	    case 95:
	      return 2;

	    default:
	      return 0;
	  }
	}

	function Tc(a) {
	  switch (a) {
	    case 15:
	    case 14:
	      return 99;

	    case 13:
	    case 12:
	    case 11:
	    case 10:
	      return 98;

	    case 9:
	    case 8:
	    case 7:
	    case 6:
	    case 4:
	    case 5:
	      return 97;

	    case 3:
	    case 2:
	    case 1:
	      return 95;

	    case 0:
	      return 90;

	    default:
	      throw Error(y(358, a));
	  }
	}

	function Uc(a, b) {
	  var c = a.pendingLanes;
	  if (0 === c) return F = 0;
	  var d = 0,
	      e = 0,
	      f = a.expiredLanes,
	      g = a.suspendedLanes,
	      h = a.pingedLanes;
	  if (0 !== f) d = f, e = F = 15;else if (f = c & 134217727, 0 !== f) {
	    var k = f & ~g;
	    0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
	  } else f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);
	  if (0 === d) return 0;
	  d = 31 - Vc(d);
	  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;

	  if (0 !== b && b !== d && 0 === (b & g)) {
	    Rc(b);
	    if (e <= F) return b;
	    F = e;
	  }

	  b = a.entangledLanes;
	  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
	  return d;
	}

	function Wc(a) {
	  a = a.pendingLanes & -1073741825;
	  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
	}

	function Xc(a, b) {
	  switch (a) {
	    case 15:
	      return 1;

	    case 14:
	      return 2;

	    case 12:
	      return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;

	    case 10:
	      return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;

	    case 8:
	      return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;

	    case 2:
	      return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
	  }

	  throw Error(y(358, a));
	}

	function Yc(a) {
	  return a & -a;
	}

	function Zc(a) {
	  for (var b = [], c = 0; 31 > c; c++) b.push(a);

	  return b;
	}

	function $c(a, b, c) {
	  a.pendingLanes |= b;
	  var d = b - 1;
	  a.suspendedLanes &= d;
	  a.pingedLanes &= d;
	  a = a.eventTimes;
	  b = 31 - Vc(b);
	  a[b] = c;
	}

	var Vc = Math.clz32 ? Math.clz32 : ad,
	    bd = Math.log,
	    cd = Math.LN2;

	function ad(a) {
	  return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
	}

	var dd = scheduler.unstable_UserBlockingPriority,
	    ed = scheduler.unstable_runWithPriority,
	    fd = !0;

	function gd(a, b, c, d) {
	  Kb || Ib();
	  var e = hd,
	      f = Kb;
	  Kb = !0;

	  try {
	    Hb(e, a, b, c, d);
	  } finally {
	    (Kb = f) || Mb();
	  }
	}

	function id(a, b, c, d) {
	  ed(dd, hd.bind(null, a, b, c, d));
	}

	function hd(a, b, c, d) {
	  if (fd) {
	    var e;
	    if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a)) a = rc(null, a, b, c, d), jc.push(a);else {
	      var f = yc(a, b, c, d);
	      if (null === f) e && sc(a, d);else {
	        if (e) {
	          if (-1 < qc.indexOf(a)) {
	            a = rc(f, a, b, c, d);
	            jc.push(a);
	            return;
	          }

	          if (uc(f, a, b, c, d)) return;
	          sc(a, d);
	        }

	        jd(a, b, d, null, c);
	      }
	    }
	  }
	}

	function yc(a, b, c, d) {
	  var e = xb(d);
	  e = wc(e);

	  if (null !== e) {
	    var f = Zb(e);
	    if (null === f) e = null;else {
	      var g = f.tag;

	      if (13 === g) {
	        e = $b(f);
	        if (null !== e) return e;
	        e = null;
	      } else if (3 === g) {
	        if (f.stateNode.hydrate) return 3 === f.tag ? f.stateNode.containerInfo : null;
	        e = null;
	      } else f !== e && (e = null);
	    }
	  }

	  jd(a, b, d, e, c);
	  return null;
	}

	var kd = null,
	    ld = null,
	    md = null;

	function nd() {
	  if (md) return md;
	  var a,
	      b = ld,
	      c = b.length,
	      d,
	      e = "value" in kd ? kd.value : kd.textContent,
	      f = e.length;

	  for (a = 0; a < c && b[a] === e[a]; a++);

	  var g = c - a;

	  for (d = 1; d <= g && b[c - d] === e[f - d]; d++);

	  return md = e.slice(a, 1 < d ? 1 - d : void 0);
	}

	function od(a) {
	  var b = a.keyCode;
	  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
	  10 === a && (a = 13);
	  return 32 <= a || 13 === a ? a : 0;
	}

	function pd() {
	  return !0;
	}

	function qd() {
	  return !1;
	}

	function rd(a) {
	  function b(b, d, e, f, g) {
	    this._reactName = b;
	    this._targetInst = e;
	    this.type = d;
	    this.nativeEvent = f;
	    this.target = g;
	    this.currentTarget = null;

	    for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);

	    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
	    this.isPropagationStopped = qd;
	    return this;
	  }

	  objectAssign(b.prototype, {
	    preventDefault: function () {
	      this.defaultPrevented = !0;
	      var a = this.nativeEvent;
	      a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
	    },
	    stopPropagation: function () {
	      var a = this.nativeEvent;
	      a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
	    },
	    persist: function () {},
	    isPersistent: pd
	  });
	  return b;
	}

	var sd = {
	  eventPhase: 0,
	  bubbles: 0,
	  cancelable: 0,
	  timeStamp: function (a) {
	    return a.timeStamp || Date.now();
	  },
	  defaultPrevented: 0,
	  isTrusted: 0
	},
	    td = rd(sd),
	    ud = objectAssign({}, sd, {
	  view: 0,
	  detail: 0
	}),
	    vd = rd(ud),
	    wd,
	    xd,
	    yd,
	    Ad = objectAssign({}, ud, {
	  screenX: 0,
	  screenY: 0,
	  clientX: 0,
	  clientY: 0,
	  pageX: 0,
	  pageY: 0,
	  ctrlKey: 0,
	  shiftKey: 0,
	  altKey: 0,
	  metaKey: 0,
	  getModifierState: zd,
	  button: 0,
	  buttons: 0,
	  relatedTarget: function (a) {
	    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
	  },
	  movementX: function (a) {
	    if ("movementX" in a) return a.movementX;
	    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
	    return wd;
	  },
	  movementY: function (a) {
	    return "movementY" in a ? a.movementY : xd;
	  }
	}),
	    Bd = rd(Ad),
	    Cd = objectAssign({}, Ad, {
	  dataTransfer: 0
	}),
	    Dd = rd(Cd),
	    Ed = objectAssign({}, ud, {
	  relatedTarget: 0
	}),
	    Fd = rd(Ed),
	    Gd = objectAssign({}, sd, {
	  animationName: 0,
	  elapsedTime: 0,
	  pseudoElement: 0
	}),
	    Hd = rd(Gd),
	    Id = objectAssign({}, sd, {
	  clipboardData: function (a) {
	    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
	  }
	}),
	    Jd = rd(Id),
	    Kd = objectAssign({}, sd, {
	  data: 0
	}),
	    Ld = rd(Kd),
	    Md = {
	  Esc: "Escape",
	  Spacebar: " ",
	  Left: "ArrowLeft",
	  Up: "ArrowUp",
	  Right: "ArrowRight",
	  Down: "ArrowDown",
	  Del: "Delete",
	  Win: "OS",
	  Menu: "ContextMenu",
	  Apps: "ContextMenu",
	  Scroll: "ScrollLock",
	  MozPrintableKey: "Unidentified"
	},
	    Nd = {
	  8: "Backspace",
	  9: "Tab",
	  12: "Clear",
	  13: "Enter",
	  16: "Shift",
	  17: "Control",
	  18: "Alt",
	  19: "Pause",
	  20: "CapsLock",
	  27: "Escape",
	  32: " ",
	  33: "PageUp",
	  34: "PageDown",
	  35: "End",
	  36: "Home",
	  37: "ArrowLeft",
	  38: "ArrowUp",
	  39: "ArrowRight",
	  40: "ArrowDown",
	  45: "Insert",
	  46: "Delete",
	  112: "F1",
	  113: "F2",
	  114: "F3",
	  115: "F4",
	  116: "F5",
	  117: "F6",
	  118: "F7",
	  119: "F8",
	  120: "F9",
	  121: "F10",
	  122: "F11",
	  123: "F12",
	  144: "NumLock",
	  145: "ScrollLock",
	  224: "Meta"
	},
	    Od = {
	  Alt: "altKey",
	  Control: "ctrlKey",
	  Meta: "metaKey",
	  Shift: "shiftKey"
	};

	function Pd(a) {
	  var b = this.nativeEvent;
	  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
	}

	function zd() {
	  return Pd;
	}

	var Qd = objectAssign({}, ud, {
	  key: function (a) {
	    if (a.key) {
	      var b = Md[a.key] || a.key;
	      if ("Unidentified" !== b) return b;
	    }

	    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
	  },
	  code: 0,
	  location: 0,
	  ctrlKey: 0,
	  shiftKey: 0,
	  altKey: 0,
	  metaKey: 0,
	  repeat: 0,
	  locale: 0,
	  getModifierState: zd,
	  charCode: function (a) {
	    return "keypress" === a.type ? od(a) : 0;
	  },
	  keyCode: function (a) {
	    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
	  },
	  which: function (a) {
	    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
	  }
	}),
	    Rd = rd(Qd),
	    Sd = objectAssign({}, Ad, {
	  pointerId: 0,
	  width: 0,
	  height: 0,
	  pressure: 0,
	  tangentialPressure: 0,
	  tiltX: 0,
	  tiltY: 0,
	  twist: 0,
	  pointerType: 0,
	  isPrimary: 0
	}),
	    Td = rd(Sd),
	    Ud = objectAssign({}, ud, {
	  touches: 0,
	  targetTouches: 0,
	  changedTouches: 0,
	  altKey: 0,
	  metaKey: 0,
	  ctrlKey: 0,
	  shiftKey: 0,
	  getModifierState: zd
	}),
	    Vd = rd(Ud),
	    Wd = objectAssign({}, sd, {
	  propertyName: 0,
	  elapsedTime: 0,
	  pseudoElement: 0
	}),
	    Xd = rd(Wd),
	    Yd = objectAssign({}, Ad, {
	  deltaX: function (a) {
	    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
	  },
	  deltaY: function (a) {
	    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
	  },
	  deltaZ: 0,
	  deltaMode: 0
	}),
	    Zd = rd(Yd),
	    $d = [9, 13, 27, 32],
	    ae = fa && "CompositionEvent" in window,
	    be = null;
	fa && "documentMode" in document && (be = document.documentMode);
	var ce = fa && "TextEvent" in window && !be,
	    de = fa && (!ae || be && 8 < be && 11 >= be),
	    ee = String.fromCharCode(32),
	    fe = !1;

	function ge(a, b) {
	  switch (a) {
	    case "keyup":
	      return -1 !== $d.indexOf(b.keyCode);

	    case "keydown":
	      return 229 !== b.keyCode;

	    case "keypress":
	    case "mousedown":
	    case "focusout":
	      return !0;

	    default:
	      return !1;
	  }
	}

	function he(a) {
	  a = a.detail;
	  return "object" === typeof a && "data" in a ? a.data : null;
	}

	var ie = !1;

	function je(a, b) {
	  switch (a) {
	    case "compositionend":
	      return he(b);

	    case "keypress":
	      if (32 !== b.which) return null;
	      fe = !0;
	      return ee;

	    case "textInput":
	      return a = b.data, a === ee && fe ? null : a;

	    default:
	      return null;
	  }
	}

	function ke(a, b) {
	  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;

	  switch (a) {
	    case "paste":
	      return null;

	    case "keypress":
	      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
	        if (b.char && 1 < b.char.length) return b.char;
	        if (b.which) return String.fromCharCode(b.which);
	      }

	      return null;

	    case "compositionend":
	      return de && "ko" !== b.locale ? null : b.data;

	    default:
	      return null;
	  }
	}

	var le = {
	  color: !0,
	  date: !0,
	  datetime: !0,
	  "datetime-local": !0,
	  email: !0,
	  month: !0,
	  number: !0,
	  password: !0,
	  range: !0,
	  search: !0,
	  tel: !0,
	  text: !0,
	  time: !0,
	  url: !0,
	  week: !0
	};

	function me(a) {
	  var b = a && a.nodeName && a.nodeName.toLowerCase();
	  return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
	}

	function ne(a, b, c, d) {
	  Eb(d);
	  b = oe(b, "onChange");
	  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
	    event: c,
	    listeners: b
	  }));
	}

	var pe = null,
	    qe = null;

	function re(a) {
	  se(a, 0);
	}

	function te(a) {
	  var b = ue(a);
	  if (Wa(b)) return a;
	}

	function ve(a, b) {
	  if ("change" === a) return b;
	}

	var we = !1;

	if (fa) {
	  var xe;

	  if (fa) {
	    var ye = ("oninput" in document);

	    if (!ye) {
	      var ze = document.createElement("div");
	      ze.setAttribute("oninput", "return;");
	      ye = "function" === typeof ze.oninput;
	    }

	    xe = ye;
	  } else xe = !1;

	  we = xe && (!document.documentMode || 9 < document.documentMode);
	}

	function Ae() {
	  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
	}

	function Be(a) {
	  if ("value" === a.propertyName && te(qe)) {
	    var b = [];
	    ne(b, qe, a, xb(a));
	    a = re;
	    if (Kb) a(b);else {
	      Kb = !0;

	      try {
	        Gb(a, b);
	      } finally {
	        Kb = !1, Mb();
	      }
	    }
	  }
	}

	function Ce(a, b, c) {
	  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
	}

	function De(a) {
	  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
	}

	function Ee(a, b) {
	  if ("click" === a) return te(b);
	}

	function Fe(a, b) {
	  if ("input" === a || "change" === a) return te(b);
	}

	function Ge(a, b) {
	  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
	}

	var He = "function" === typeof Object.is ? Object.is : Ge,
	    Ie = Object.prototype.hasOwnProperty;

	function Je(a, b) {
	  if (He(a, b)) return !0;
	  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
	  var c = Object.keys(a),
	      d = Object.keys(b);
	  if (c.length !== d.length) return !1;

	  for (d = 0; d < c.length; d++) if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]])) return !1;

	  return !0;
	}

	function Ke(a) {
	  for (; a && a.firstChild;) a = a.firstChild;

	  return a;
	}

	function Le(a, b) {
	  var c = Ke(a);
	  a = 0;

	  for (var d; c;) {
	    if (3 === c.nodeType) {
	      d = a + c.textContent.length;
	      if (a <= b && d >= b) return {
	        node: c,
	        offset: b - a
	      };
	      a = d;
	    }

	    a: {
	      for (; c;) {
	        if (c.nextSibling) {
	          c = c.nextSibling;
	          break a;
	        }

	        c = c.parentNode;
	      }

	      c = void 0;
	    }

	    c = Ke(c);
	  }
	}

	function Me(a, b) {
	  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
	}

	function Ne() {
	  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
	    try {
	      var c = "string" === typeof b.contentWindow.location.href;
	    } catch (d) {
	      c = !1;
	    }

	    if (c) a = b.contentWindow;else break;
	    b = Xa(a.document);
	  }

	  return b;
	}

	function Oe(a) {
	  var b = a && a.nodeName && a.nodeName.toLowerCase();
	  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
	}

	var Pe = fa && "documentMode" in document && 11 >= document.documentMode,
	    Qe = null,
	    Re = null,
	    Se = null,
	    Te = !1;

	function Ue(a, b, c) {
	  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
	  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = {
	    start: d.selectionStart,
	    end: d.selectionEnd
	  } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
	    anchorNode: d.anchorNode,
	    anchorOffset: d.anchorOffset,
	    focusNode: d.focusNode,
	    focusOffset: d.focusOffset
	  }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
	    event: b,
	    listeners: d
	  }), b.target = Qe)));
	}

	Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
	Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
	Pc(Oc, 2);

	for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++) Nc.set(Ve[We], 0);

	ea("onMouseEnter", ["mouseout", "mouseover"]);
	ea("onMouseLeave", ["mouseout", "mouseover"]);
	ea("onPointerEnter", ["pointerout", "pointerover"]);
	ea("onPointerLeave", ["pointerout", "pointerover"]);
	da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
	da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
	da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
	da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
	da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
	da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
	var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
	    Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));

	function Ze(a, b, c) {
	  var d = a.type || "unknown-event";
	  a.currentTarget = c;
	  Yb(d, b, void 0, a);
	  a.currentTarget = null;
	}

	function se(a, b) {
	  b = 0 !== (b & 4);

	  for (var c = 0; c < a.length; c++) {
	    var d = a[c],
	        e = d.event;
	    d = d.listeners;

	    a: {
	      var f = void 0;
	      if (b) for (var g = d.length - 1; 0 <= g; g--) {
	        var h = d[g],
	            k = h.instance,
	            l = h.currentTarget;
	        h = h.listener;
	        if (k !== f && e.isPropagationStopped()) break a;
	        Ze(e, h, l);
	        f = k;
	      } else for (g = 0; g < d.length; g++) {
	        h = d[g];
	        k = h.instance;
	        l = h.currentTarget;
	        h = h.listener;
	        if (k !== f && e.isPropagationStopped()) break a;
	        Ze(e, h, l);
	        f = k;
	      }
	    }
	  }

	  if (Ub) throw a = Vb, Ub = !1, Vb = null, a;
	}

	function G(a, b) {
	  var c = $e(b),
	      d = a + "__bubble";
	  c.has(d) || (af(b, a, 2, !1), c.add(d));
	}

	var bf = "_reactListening" + Math.random().toString(36).slice(2);

	function cf(a) {
	  a[bf] || (a[bf] = !0, ba.forEach(function (b) {
	    Ye.has(b) || df(b, !1, a, null);
	    df(b, !0, a, null);
	  }));
	}

	function df(a, b, c, d) {
	  var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
	      f = c;
	  "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);

	  if (null !== d && !b && Ye.has(a)) {
	    if ("scroll" !== a) return;
	    e |= 2;
	    f = d;
	  }

	  var g = $e(f),
	      h = a + "__" + (b ? "capture" : "bubble");
	  g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
	}

	function af(a, b, c, d) {
	  var e = Nc.get(b);

	  switch (void 0 === e ? 2 : e) {
	    case 0:
	      e = gd;
	      break;

	    case 1:
	      e = id;
	      break;

	    default:
	      e = hd;
	  }

	  c = e.bind(null, b, c, a);
	  e = void 0;
	  !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
	  d ? void 0 !== e ? a.addEventListener(b, c, {
	    capture: !0,
	    passive: e
	  }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
	    passive: e
	  }) : a.addEventListener(b, c, !1);
	}

	function jd(a, b, c, d, e) {
	  var f = d;
	  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
	    if (null === d) return;
	    var g = d.tag;

	    if (3 === g || 4 === g) {
	      var h = d.stateNode.containerInfo;
	      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
	      if (4 === g) for (g = d.return; null !== g;) {
	        var k = g.tag;
	        if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
	        g = g.return;
	      }

	      for (; null !== h;) {
	        g = wc(h);
	        if (null === g) return;
	        k = g.tag;

	        if (5 === k || 6 === k) {
	          d = f = g;
	          continue a;
	        }

	        h = h.parentNode;
	      }
	    }

	    d = d.return;
	  }
	  Nb(function () {
	    var d = f,
	        e = xb(c),
	        g = [];

	    a: {
	      var h = Mc.get(a);

	      if (void 0 !== h) {
	        var k = td,
	            x = a;

	        switch (a) {
	          case "keypress":
	            if (0 === od(c)) break a;

	          case "keydown":
	          case "keyup":
	            k = Rd;
	            break;

	          case "focusin":
	            x = "focus";
	            k = Fd;
	            break;

	          case "focusout":
	            x = "blur";
	            k = Fd;
	            break;

	          case "beforeblur":
	          case "afterblur":
	            k = Fd;
	            break;

	          case "click":
	            if (2 === c.button) break a;

	          case "auxclick":
	          case "dblclick":
	          case "mousedown":
	          case "mousemove":
	          case "mouseup":
	          case "mouseout":
	          case "mouseover":
	          case "contextmenu":
	            k = Bd;
	            break;

	          case "drag":
	          case "dragend":
	          case "dragenter":
	          case "dragexit":
	          case "dragleave":
	          case "dragover":
	          case "dragstart":
	          case "drop":
	            k = Dd;
	            break;

	          case "touchcancel":
	          case "touchend":
	          case "touchmove":
	          case "touchstart":
	            k = Vd;
	            break;

	          case Ic:
	          case Jc:
	          case Kc:
	            k = Hd;
	            break;

	          case Lc:
	            k = Xd;
	            break;

	          case "scroll":
	            k = vd;
	            break;

	          case "wheel":
	            k = Zd;
	            break;

	          case "copy":
	          case "cut":
	          case "paste":
	            k = Jd;
	            break;

	          case "gotpointercapture":
	          case "lostpointercapture":
	          case "pointercancel":
	          case "pointerdown":
	          case "pointermove":
	          case "pointerout":
	          case "pointerover":
	          case "pointerup":
	            k = Td;
	        }

	        var w = 0 !== (b & 4),
	            z = !w && "scroll" === a,
	            u = w ? null !== h ? h + "Capture" : null : h;
	        w = [];

	        for (var t = d, q; null !== t;) {
	          q = t;
	          var v = q.stateNode;
	          5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));
	          if (z) break;
	          t = t.return;
	        }

	        0 < w.length && (h = new k(h, x, null, c, e), g.push({
	          event: h,
	          listeners: w
	        }));
	      }
	    }

	    if (0 === (b & 7)) {
	      a: {
	        h = "mouseover" === a || "pointerover" === a;
	        k = "mouseout" === a || "pointerout" === a;
	        if (h && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff])) break a;

	        if (k || h) {
	          h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;

	          if (k) {
	            if (x = c.relatedTarget || c.toElement, k = d, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag)) x = null;
	          } else k = null, x = d;

	          if (k !== x) {
	            w = Bd;
	            v = "onMouseLeave";
	            u = "onMouseEnter";
	            t = "mouse";
	            if ("pointerout" === a || "pointerover" === a) w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
	            z = null == k ? h : ue(k);
	            q = null == x ? h : ue(x);
	            h = new w(v, t + "leave", k, c, e);
	            h.target = z;
	            h.relatedTarget = q;
	            v = null;
	            wc(e) === d && (w = new w(u, t + "enter", x, c, e), w.target = q, w.relatedTarget = z, v = w);
	            z = v;
	            if (k && x) b: {
	              w = k;
	              u = x;
	              t = 0;

	              for (q = w; q; q = gf(q)) t++;

	              q = 0;

	              for (v = u; v; v = gf(v)) q++;

	              for (; 0 < t - q;) w = gf(w), t--;

	              for (; 0 < q - t;) u = gf(u), q--;

	              for (; t--;) {
	                if (w === u || null !== u && w === u.alternate) break b;
	                w = gf(w);
	                u = gf(u);
	              }

	              w = null;
	            } else w = null;
	            null !== k && hf(g, h, k, w, !1);
	            null !== x && null !== z && hf(g, z, x, w, !0);
	          }
	        }
	      }

	      a: {
	        h = d ? ue(d) : window;
	        k = h.nodeName && h.nodeName.toLowerCase();
	        if ("select" === k || "input" === k && "file" === h.type) var J = ve;else if (me(h)) {
	          if (we) J = Fe;else {
	            J = De;
	            var K = Ce;
	          }
	        } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (J = Ee);

	        if (J && (J = J(a, d))) {
	          ne(g, J, c, e);
	          break a;
	        }

	        K && K(a, h, d);
	        "focusout" === a && (K = h._wrapperState) && K.controlled && "number" === h.type && bb(h, "number", h.value);
	      }

	      K = d ? ue(d) : window;

	      switch (a) {
	        case "focusin":
	          if (me(K) || "true" === K.contentEditable) Qe = K, Re = d, Se = null;
	          break;

	        case "focusout":
	          Se = Re = Qe = null;
	          break;

	        case "mousedown":
	          Te = !0;
	          break;

	        case "contextmenu":
	        case "mouseup":
	        case "dragend":
	          Te = !1;
	          Ue(g, c, e);
	          break;

	        case "selectionchange":
	          if (Pe) break;

	        case "keydown":
	        case "keyup":
	          Ue(g, c, e);
	      }

	      var Q;
	      if (ae) b: {
	        switch (a) {
	          case "compositionstart":
	            var L = "onCompositionStart";
	            break b;

	          case "compositionend":
	            L = "onCompositionEnd";
	            break b;

	          case "compositionupdate":
	            L = "onCompositionUpdate";
	            break b;
	        }

	        L = void 0;
	      } else ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");
	      L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), K = oe(d, L), 0 < K.length && (L = new Ld(L, a, null, c, e), g.push({
	        event: L,
	        listeners: K
	      }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));
	      if (Q = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
	        event: e,
	        listeners: d
	      }), e.data = Q);
	    }

	    se(g, b);
	  });
	}

	function ef(a, b, c) {
	  return {
	    instance: a,
	    listener: b,
	    currentTarget: c
	  };
	}

	function oe(a, b) {
	  for (var c = b + "Capture", d = []; null !== a;) {
	    var e = a,
	        f = e.stateNode;
	    5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
	    a = a.return;
	  }

	  return d;
	}

	function gf(a) {
	  if (null === a) return null;

	  do a = a.return; while (a && 5 !== a.tag);

	  return a ? a : null;
	}

	function hf(a, b, c, d, e) {
	  for (var f = b._reactName, g = []; null !== c && c !== d;) {
	    var h = c,
	        k = h.alternate,
	        l = h.stateNode;
	    if (null !== k && k === d) break;
	    5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
	    c = c.return;
	  }

	  0 !== g.length && a.push({
	    event: b,
	    listeners: g
	  });
	}

	function jf() {}

	var kf = null,
	    lf = null;

	function mf(a, b) {
	  switch (a) {
	    case "button":
	    case "input":
	    case "select":
	    case "textarea":
	      return !!b.autoFocus;
	  }

	  return !1;
	}

	function nf(a, b) {
	  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
	}

	var of = "function" === typeof setTimeout ? setTimeout : void 0,
	    pf = "function" === typeof clearTimeout ? clearTimeout : void 0;

	function qf(a) {
	  1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
	}

	function rf(a) {
	  for (; null != a; a = a.nextSibling) {
	    var b = a.nodeType;
	    if (1 === b || 3 === b) break;
	  }

	  return a;
	}

	function sf(a) {
	  a = a.previousSibling;

	  for (var b = 0; a;) {
	    if (8 === a.nodeType) {
	      var c = a.data;

	      if ("$" === c || "$!" === c || "$?" === c) {
	        if (0 === b) return a;
	        b--;
	      } else "/$" === c && b++;
	    }

	    a = a.previousSibling;
	  }

	  return null;
	}

	var tf = 0;

	function uf(a) {
	  return {
	    $$typeof: Ga,
	    toString: a,
	    valueOf: a
	  };
	}

	var vf = Math.random().toString(36).slice(2),
	    wf = "__reactFiber$" + vf,
	    xf = "__reactProps$" + vf,
	    ff = "__reactContainer$" + vf,
	    yf = "__reactEvents$" + vf;

	function wc(a) {
	  var b = a[wf];
	  if (b) return b;

	  for (var c = a.parentNode; c;) {
	    if (b = c[ff] || c[wf]) {
	      c = b.alternate;
	      if (null !== b.child || null !== c && null !== c.child) for (a = sf(a); null !== a;) {
	        if (c = a[wf]) return c;
	        a = sf(a);
	      }
	      return b;
	    }

	    a = c;
	    c = a.parentNode;
	  }

	  return null;
	}

	function Cb(a) {
	  a = a[wf] || a[ff];
	  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
	}

	function ue(a) {
	  if (5 === a.tag || 6 === a.tag) return a.stateNode;
	  throw Error(y(33));
	}

	function Db(a) {
	  return a[xf] || null;
	}

	function $e(a) {
	  var b = a[yf];
	  void 0 === b && (b = a[yf] = new Set());
	  return b;
	}

	var zf = [],
	    Af = -1;

	function Bf(a) {
	  return {
	    current: a
	  };
	}

	function H(a) {
	  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
	}

	function I(a, b) {
	  Af++;
	  zf[Af] = a.current;
	  a.current = b;
	}

	var Cf = {},
	    M = Bf(Cf),
	    N = Bf(!1),
	    Df = Cf;

	function Ef(a, b) {
	  var c = a.type.contextTypes;
	  if (!c) return Cf;
	  var d = a.stateNode;
	  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
	  var e = {},
	      f;

	  for (f in c) e[f] = b[f];

	  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
	  return e;
	}

	function Ff(a) {
	  a = a.childContextTypes;
	  return null !== a && void 0 !== a;
	}

	function Gf() {
	  H(N);
	  H(M);
	}

	function Hf(a, b, c) {
	  if (M.current !== Cf) throw Error(y(168));
	  I(M, b);
	  I(N, c);
	}

	function If(a, b, c) {
	  var d = a.stateNode;
	  a = b.childContextTypes;
	  if ("function" !== typeof d.getChildContext) return c;
	  d = d.getChildContext();

	  for (var e in d) if (!(e in a)) throw Error(y(108, Ra(b) || "Unknown", e));

	  return objectAssign({}, c, d);
	}

	function Jf(a) {
	  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
	  Df = M.current;
	  I(M, a);
	  I(N, N.current);
	  return !0;
	}

	function Kf(a, b, c) {
	  var d = a.stateNode;
	  if (!d) throw Error(y(169));
	  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
	  I(N, c);
	}

	var Lf = null,
	    Mf = null,
	    Nf = scheduler.unstable_runWithPriority,
	    Of = scheduler.unstable_scheduleCallback,
	    Pf = scheduler.unstable_cancelCallback,
	    Qf = scheduler.unstable_shouldYield,
	    Rf = scheduler.unstable_requestPaint,
	    Sf = scheduler.unstable_now,
	    Tf = scheduler.unstable_getCurrentPriorityLevel,
	    Uf = scheduler.unstable_ImmediatePriority,
	    Vf = scheduler.unstable_UserBlockingPriority,
	    Wf = scheduler.unstable_NormalPriority,
	    Xf = scheduler.unstable_LowPriority,
	    Yf = scheduler.unstable_IdlePriority,
	    Zf = {},
	    $f = void 0 !== Rf ? Rf : function () {},
	    ag = null,
	    bg = null,
	    cg = !1,
	    dg = Sf(),
	    O = 1E4 > dg ? Sf : function () {
	  return Sf() - dg;
	};

	function eg() {
	  switch (Tf()) {
	    case Uf:
	      return 99;

	    case Vf:
	      return 98;

	    case Wf:
	      return 97;

	    case Xf:
	      return 96;

	    case Yf:
	      return 95;

	    default:
	      throw Error(y(332));
	  }
	}

	function fg(a) {
	  switch (a) {
	    case 99:
	      return Uf;

	    case 98:
	      return Vf;

	    case 97:
	      return Wf;

	    case 96:
	      return Xf;

	    case 95:
	      return Yf;

	    default:
	      throw Error(y(332));
	  }
	}

	function gg(a, b) {
	  a = fg(a);
	  return Nf(a, b);
	}

	function hg(a, b, c) {
	  a = fg(a);
	  return Of(a, b, c);
	}

	function ig() {
	  if (null !== bg) {
	    var a = bg;
	    bg = null;
	    Pf(a);
	  }

	  jg();
	}

	function jg() {
	  if (!cg && null !== ag) {
	    cg = !0;
	    var a = 0;

	    try {
	      var b = ag;
	      gg(99, function () {
	        for (; a < b.length; a++) {
	          var c = b[a];

	          do c = c(!0); while (null !== c);
	        }
	      });
	      ag = null;
	    } catch (c) {
	      throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
	    } finally {
	      cg = !1;
	    }
	  }
	}

	var kg = ra.ReactCurrentBatchConfig;

	function lg(a, b) {
	  if (a && a.defaultProps) {
	    b = objectAssign({}, b);
	    a = a.defaultProps;

	    for (var c in a) void 0 === b[c] && (b[c] = a[c]);

	    return b;
	  }

	  return b;
	}

	var mg = Bf(null),
	    ng = null,
	    og = null,
	    pg = null;

	function qg() {
	  pg = og = ng = null;
	}

	function rg(a) {
	  var b = mg.current;
	  H(mg);
	  a.type._context._currentValue = b;
	}

	function sg(a, b) {
	  for (; null !== a;) {
	    var c = a.alternate;
	    if ((a.childLanes & b) === b) {
	      if (null === c || (c.childLanes & b) === b) break;else c.childLanes |= b;
	    } else a.childLanes |= b, null !== c && (c.childLanes |= b);
	    a = a.return;
	  }
	}

	function tg(a, b) {
	  ng = a;
	  pg = og = null;
	  a = a.dependencies;
	  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = !0), a.firstContext = null);
	}

	function vg(a, b) {
	  if (pg !== a && !1 !== b && 0 !== b) {
	    if ("number" !== typeof b || 1073741823 === b) pg = a, b = 1073741823;
	    b = {
	      context: a,
	      observedBits: b,
	      next: null
	    };

	    if (null === og) {
	      if (null === ng) throw Error(y(308));
	      og = b;
	      ng.dependencies = {
	        lanes: 0,
	        firstContext: b,
	        responders: null
	      };
	    } else og = og.next = b;
	  }

	  return a._currentValue;
	}

	var wg = !1;

	function xg(a) {
	  a.updateQueue = {
	    baseState: a.memoizedState,
	    firstBaseUpdate: null,
	    lastBaseUpdate: null,
	    shared: {
	      pending: null
	    },
	    effects: null
	  };
	}

	function yg(a, b) {
	  a = a.updateQueue;
	  b.updateQueue === a && (b.updateQueue = {
	    baseState: a.baseState,
	    firstBaseUpdate: a.firstBaseUpdate,
	    lastBaseUpdate: a.lastBaseUpdate,
	    shared: a.shared,
	    effects: a.effects
	  });
	}

	function zg(a, b) {
	  return {
	    eventTime: a,
	    lane: b,
	    tag: 0,
	    payload: null,
	    callback: null,
	    next: null
	  };
	}

	function Ag(a, b) {
	  a = a.updateQueue;

	  if (null !== a) {
	    a = a.shared;
	    var c = a.pending;
	    null === c ? b.next = b : (b.next = c.next, c.next = b);
	    a.pending = b;
	  }
	}

	function Bg(a, b) {
	  var c = a.updateQueue,
	      d = a.alternate;

	  if (null !== d && (d = d.updateQueue, c === d)) {
	    var e = null,
	        f = null;
	    c = c.firstBaseUpdate;

	    if (null !== c) {
	      do {
	        var g = {
	          eventTime: c.eventTime,
	          lane: c.lane,
	          tag: c.tag,
	          payload: c.payload,
	          callback: c.callback,
	          next: null
	        };
	        null === f ? e = f = g : f = f.next = g;
	        c = c.next;
	      } while (null !== c);

	      null === f ? e = f = b : f = f.next = b;
	    } else e = f = b;

	    c = {
	      baseState: d.baseState,
	      firstBaseUpdate: e,
	      lastBaseUpdate: f,
	      shared: d.shared,
	      effects: d.effects
	    };
	    a.updateQueue = c;
	    return;
	  }

	  a = c.lastBaseUpdate;
	  null === a ? c.firstBaseUpdate = b : a.next = b;
	  c.lastBaseUpdate = b;
	}

	function Cg(a, b, c, d) {
	  var e = a.updateQueue;
	  wg = !1;
	  var f = e.firstBaseUpdate,
	      g = e.lastBaseUpdate,
	      h = e.shared.pending;

	  if (null !== h) {
	    e.shared.pending = null;
	    var k = h,
	        l = k.next;
	    k.next = null;
	    null === g ? f = l : g.next = l;
	    g = k;
	    var n = a.alternate;

	    if (null !== n) {
	      n = n.updateQueue;
	      var A = n.lastBaseUpdate;
	      A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
	    }
	  }

	  if (null !== f) {
	    A = e.baseState;
	    g = 0;
	    n = l = k = null;

	    do {
	      h = f.lane;
	      var p = f.eventTime;

	      if ((d & h) === h) {
	        null !== n && (n = n.next = {
	          eventTime: p,
	          lane: 0,
	          tag: f.tag,
	          payload: f.payload,
	          callback: f.callback,
	          next: null
	        });

	        a: {
	          var C = a,
	              x = f;
	          h = b;
	          p = c;

	          switch (x.tag) {
	            case 1:
	              C = x.payload;

	              if ("function" === typeof C) {
	                A = C.call(p, A, h);
	                break a;
	              }

	              A = C;
	              break a;

	            case 3:
	              C.flags = C.flags & -4097 | 64;

	            case 0:
	              C = x.payload;
	              h = "function" === typeof C ? C.call(p, A, h) : C;
	              if (null === h || void 0 === h) break a;
	              A = objectAssign({}, A, h);
	              break a;

	            case 2:
	              wg = !0;
	          }
	        }

	        null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
	      } else p = {
	        eventTime: p,
	        lane: h,
	        tag: f.tag,
	        payload: f.payload,
	        callback: f.callback,
	        next: null
	      }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;

	      f = f.next;
	      if (null === f) if (h = e.shared.pending, null === h) break;else f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
	    } while (1);

	    null === n && (k = A);
	    e.baseState = k;
	    e.firstBaseUpdate = l;
	    e.lastBaseUpdate = n;
	    Dg |= g;
	    a.lanes = g;
	    a.memoizedState = A;
	  }
	}

	function Eg(a, b, c) {
	  a = b.effects;
	  b.effects = null;
	  if (null !== a) for (b = 0; b < a.length; b++) {
	    var d = a[b],
	        e = d.callback;

	    if (null !== e) {
	      d.callback = null;
	      d = c;
	      if ("function" !== typeof e) throw Error(y(191, e));
	      e.call(d);
	    }
	  }
	}

	var Fg = new react.Component().refs;

	function Gg(a, b, c, d) {
	  b = a.memoizedState;
	  c = c(d, b);
	  c = null === c || void 0 === c ? b : objectAssign({}, b, c);
	  a.memoizedState = c;
	  0 === a.lanes && (a.updateQueue.baseState = c);
	}

	var Kg = {
	  isMounted: function (a) {
	    return (a = a._reactInternals) ? Zb(a) === a : !1;
	  },
	  enqueueSetState: function (a, b, c) {
	    a = a._reactInternals;
	    var d = Hg(),
	        e = Ig(a),
	        f = zg(d, e);
	    f.payload = b;
	    void 0 !== c && null !== c && (f.callback = c);
	    Ag(a, f);
	    Jg(a, e, d);
	  },
	  enqueueReplaceState: function (a, b, c) {
	    a = a._reactInternals;
	    var d = Hg(),
	        e = Ig(a),
	        f = zg(d, e);
	    f.tag = 1;
	    f.payload = b;
	    void 0 !== c && null !== c && (f.callback = c);
	    Ag(a, f);
	    Jg(a, e, d);
	  },
	  enqueueForceUpdate: function (a, b) {
	    a = a._reactInternals;
	    var c = Hg(),
	        d = Ig(a),
	        e = zg(c, d);
	    e.tag = 2;
	    void 0 !== b && null !== b && (e.callback = b);
	    Ag(a, e);
	    Jg(a, d, c);
	  }
	};

	function Lg(a, b, c, d, e, f, g) {
	  a = a.stateNode;
	  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : !0;
	}

	function Mg(a, b, c) {
	  var d = !1,
	      e = Cf;
	  var f = b.contextType;
	  "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
	  b = new b(c, f);
	  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
	  b.updater = Kg;
	  a.stateNode = b;
	  b._reactInternals = a;
	  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
	  return b;
	}

	function Ng(a, b, c, d) {
	  a = b.state;
	  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
	  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
	  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
	}

	function Og(a, b, c, d) {
	  var e = a.stateNode;
	  e.props = c;
	  e.state = a.memoizedState;
	  e.refs = Fg;
	  xg(a);
	  var f = b.contextType;
	  "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
	  Cg(a, c, e, d);
	  e.state = a.memoizedState;
	  f = b.getDerivedStateFromProps;
	  "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
	  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
	  "function" === typeof e.componentDidMount && (a.flags |= 4);
	}

	var Pg = Array.isArray;

	function Qg(a, b, c) {
	  a = c.ref;

	  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
	    if (c._owner) {
	      c = c._owner;

	      if (c) {
	        if (1 !== c.tag) throw Error(y(309));
	        var d = c.stateNode;
	      }

	      if (!d) throw Error(y(147, a));
	      var e = "" + a;
	      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;

	      b = function (a) {
	        var b = d.refs;
	        b === Fg && (b = d.refs = {});
	        null === a ? delete b[e] : b[e] = a;
	      };

	      b._stringRef = e;
	      return b;
	    }

	    if ("string" !== typeof a) throw Error(y(284));
	    if (!c._owner) throw Error(y(290, a));
	  }

	  return a;
	}

	function Rg(a, b) {
	  if ("textarea" !== a.type) throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
	}

	function Sg(a) {
	  function b(b, c) {
	    if (a) {
	      var d = b.lastEffect;
	      null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
	      c.nextEffect = null;
	      c.flags = 8;
	    }
	  }

	  function c(c, d) {
	    if (!a) return null;

	    for (; null !== d;) b(c, d), d = d.sibling;

	    return null;
	  }

	  function d(a, b) {
	    for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;

	    return a;
	  }

	  function e(a, b) {
	    a = Tg(a, b);
	    a.index = 0;
	    a.sibling = null;
	    return a;
	  }

	  function f(b, c, d) {
	    b.index = d;
	    if (!a) return c;
	    d = b.alternate;
	    if (null !== d) return d = d.index, d < c ? (b.flags = 2, c) : d;
	    b.flags = 2;
	    return c;
	  }

	  function g(b) {
	    a && null === b.alternate && (b.flags = 2);
	    return b;
	  }

	  function h(a, b, c, d) {
	    if (null === b || 6 !== b.tag) return b = Ug(c, a.mode, d), b.return = a, b;
	    b = e(b, c);
	    b.return = a;
	    return b;
	  }

	  function k(a, b, c, d) {
	    if (null !== b && b.elementType === c.type) return d = e(b, c.props), d.ref = Qg(a, b, c), d.return = a, d;
	    d = Vg(c.type, c.key, c.props, null, a.mode, d);
	    d.ref = Qg(a, b, c);
	    d.return = a;
	    return d;
	  }

	  function l(a, b, c, d) {
	    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Wg(c, a.mode, d), b.return = a, b;
	    b = e(b, c.children || []);
	    b.return = a;
	    return b;
	  }

	  function n(a, b, c, d, f) {
	    if (null === b || 7 !== b.tag) return b = Xg(c, a.mode, d, f), b.return = a, b;
	    b = e(b, c);
	    b.return = a;
	    return b;
	  }

	  function A(a, b, c) {
	    if ("string" === typeof b || "number" === typeof b) return b = Ug("" + b, a.mode, c), b.return = a, b;

	    if ("object" === typeof b && null !== b) {
	      switch (b.$$typeof) {
	        case sa:
	          return c = Vg(b.type, b.key, b.props, null, a.mode, c), c.ref = Qg(a, null, b), c.return = a, c;

	        case ta:
	          return b = Wg(b, a.mode, c), b.return = a, b;
	      }

	      if (Pg(b) || La(b)) return b = Xg(b, a.mode, c, null), b.return = a, b;
	      Rg(a, b);
	    }

	    return null;
	  }

	  function p(a, b, c, d) {
	    var e = null !== b ? b.key : null;
	    if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);

	    if ("object" === typeof c && null !== c) {
	      switch (c.$$typeof) {
	        case sa:
	          return c.key === e ? c.type === ua ? n(a, b, c.props.children, d, e) : k(a, b, c, d) : null;

	        case ta:
	          return c.key === e ? l(a, b, c, d) : null;
	      }

	      if (Pg(c) || La(c)) return null !== e ? null : n(a, b, c, d, null);
	      Rg(a, c);
	    }

	    return null;
	  }

	  function C(a, b, c, d, e) {
	    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);

	    if ("object" === typeof d && null !== d) {
	      switch (d.$$typeof) {
	        case sa:
	          return a = a.get(null === d.key ? c : d.key) || null, d.type === ua ? n(b, a, d.props.children, e, d.key) : k(b, a, d, e);

	        case ta:
	          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
	      }

	      if (Pg(d) || La(d)) return a = a.get(c) || null, n(b, a, d, e, null);
	      Rg(b, d);
	    }

	    return null;
	  }

	  function x(e, g, h, k) {
	    for (var l = null, t = null, u = g, z = g = 0, q = null; null !== u && z < h.length; z++) {
	      u.index > z ? (q = u, u = null) : q = u.sibling;
	      var n = p(e, u, h[z], k);

	      if (null === n) {
	        null === u && (u = q);
	        break;
	      }

	      a && u && null === n.alternate && b(e, u);
	      g = f(n, g, z);
	      null === t ? l = n : t.sibling = n;
	      t = n;
	      u = q;
	    }

	    if (z === h.length) return c(e, u), l;

	    if (null === u) {
	      for (; z < h.length; z++) u = A(e, h[z], k), null !== u && (g = f(u, g, z), null === t ? l = u : t.sibling = u, t = u);

	      return l;
	    }

	    for (u = d(e, u); z < h.length; z++) q = C(u, e, z, h[z], k), null !== q && (a && null !== q.alternate && u.delete(null === q.key ? z : q.key), g = f(q, g, z), null === t ? l = q : t.sibling = q, t = q);

	    a && u.forEach(function (a) {
	      return b(e, a);
	    });
	    return l;
	  }

	  function w(e, g, h, k) {
	    var l = La(h);
	    if ("function" !== typeof l) throw Error(y(150));
	    h = l.call(h);
	    if (null == h) throw Error(y(151));

	    for (var t = l = null, u = g, z = g = 0, q = null, n = h.next(); null !== u && !n.done; z++, n = h.next()) {
	      u.index > z ? (q = u, u = null) : q = u.sibling;
	      var w = p(e, u, n.value, k);

	      if (null === w) {
	        null === u && (u = q);
	        break;
	      }

	      a && u && null === w.alternate && b(e, u);
	      g = f(w, g, z);
	      null === t ? l = w : t.sibling = w;
	      t = w;
	      u = q;
	    }

	    if (n.done) return c(e, u), l;

	    if (null === u) {
	      for (; !n.done; z++, n = h.next()) n = A(e, n.value, k), null !== n && (g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);

	      return l;
	    }

	    for (u = d(e, u); !n.done; z++, n = h.next()) n = C(u, e, z, n.value, k), null !== n && (a && null !== n.alternate && u.delete(null === n.key ? z : n.key), g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);

	    a && u.forEach(function (a) {
	      return b(e, a);
	    });
	    return l;
	  }

	  return function (a, d, f, h) {
	    var k = "object" === typeof f && null !== f && f.type === ua && null === f.key;
	    k && (f = f.props.children);
	    var l = "object" === typeof f && null !== f;
	    if (l) switch (f.$$typeof) {
	      case sa:
	        a: {
	          l = f.key;

	          for (k = d; null !== k;) {
	            if (k.key === l) {
	              switch (k.tag) {
	                case 7:
	                  if (f.type === ua) {
	                    c(a, k.sibling);
	                    d = e(k, f.props.children);
	                    d.return = a;
	                    a = d;
	                    break a;
	                  }

	                  break;

	                default:
	                  if (k.elementType === f.type) {
	                    c(a, k.sibling);
	                    d = e(k, f.props);
	                    d.ref = Qg(a, k, f);
	                    d.return = a;
	                    a = d;
	                    break a;
	                  }

	              }

	              c(a, k);
	              break;
	            } else b(a, k);

	            k = k.sibling;
	          }

	          f.type === ua ? (d = Xg(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Vg(f.type, f.key, f.props, null, a.mode, h), h.ref = Qg(a, d, f), h.return = a, a = h);
	        }

	        return g(a);

	      case ta:
	        a: {
	          for (k = f.key; null !== d;) {
	            if (d.key === k) {
	              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
	                c(a, d.sibling);
	                d = e(d, f.children || []);
	                d.return = a;
	                a = d;
	                break a;
	              } else {
	                c(a, d);
	                break;
	              }
	            } else b(a, d);
	            d = d.sibling;
	          }

	          d = Wg(f, a.mode, h);
	          d.return = a;
	          a = d;
	        }

	        return g(a);
	    }
	    if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Ug(f, a.mode, h), d.return = a, a = d), g(a);
	    if (Pg(f)) return x(a, d, f, h);
	    if (La(f)) return w(a, d, f, h);
	    l && Rg(a, f);
	    if ("undefined" === typeof f && !k) switch (a.tag) {
	      case 1:
	      case 22:
	      case 0:
	      case 11:
	      case 15:
	        throw Error(y(152, Ra(a.type) || "Component"));
	    }
	    return c(a, d);
	  };
	}

	var Yg = Sg(!0),
	    Zg = Sg(!1),
	    $g = {},
	    ah = Bf($g),
	    bh = Bf($g),
	    ch = Bf($g);

	function dh(a) {
	  if (a === $g) throw Error(y(174));
	  return a;
	}

	function eh(a, b) {
	  I(ch, b);
	  I(bh, a);
	  I(ah, $g);
	  a = b.nodeType;

	  switch (a) {
	    case 9:
	    case 11:
	      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
	      break;

	    default:
	      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
	  }

	  H(ah);
	  I(ah, b);
	}

	function fh() {
	  H(ah);
	  H(bh);
	  H(ch);
	}

	function gh(a) {
	  dh(ch.current);
	  var b = dh(ah.current);
	  var c = mb(b, a.type);
	  b !== c && (I(bh, a), I(ah, c));
	}

	function hh(a) {
	  bh.current === a && (H(ah), H(bh));
	}

	var P = Bf(0);

	function ih(a) {
	  for (var b = a; null !== b;) {
	    if (13 === b.tag) {
	      var c = b.memoizedState;
	      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
	    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
	      if (0 !== (b.flags & 64)) return b;
	    } else if (null !== b.child) {
	      b.child.return = b;
	      b = b.child;
	      continue;
	    }

	    if (b === a) break;

	    for (; null === b.sibling;) {
	      if (null === b.return || b.return === a) return null;
	      b = b.return;
	    }

	    b.sibling.return = b.return;
	    b = b.sibling;
	  }

	  return null;
	}

	var jh = null,
	    kh = null,
	    lh = !1;

	function mh(a, b) {
	  var c = nh(5, null, null, 0);
	  c.elementType = "DELETED";
	  c.type = "DELETED";
	  c.stateNode = b;
	  c.return = a;
	  c.flags = 8;
	  null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
	}

	function oh(a, b) {
	  switch (a.tag) {
	    case 5:
	      var c = a.type;
	      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
	      return null !== b ? (a.stateNode = b, !0) : !1;

	    case 6:
	      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, !0) : !1;

	    case 13:
	      return !1;

	    default:
	      return !1;
	  }
	}

	function ph(a) {
	  if (lh) {
	    var b = kh;

	    if (b) {
	      var c = b;

	      if (!oh(a, b)) {
	        b = rf(c.nextSibling);

	        if (!b || !oh(a, b)) {
	          a.flags = a.flags & -1025 | 2;
	          lh = !1;
	          jh = a;
	          return;
	        }

	        mh(jh, c);
	      }

	      jh = a;
	      kh = rf(b.firstChild);
	    } else a.flags = a.flags & -1025 | 2, lh = !1, jh = a;
	  }
	}

	function qh(a) {
	  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;

	  jh = a;
	}

	function rh(a) {
	  if (a !== jh) return !1;
	  if (!lh) return qh(a), lh = !0, !1;
	  var b = a.type;
	  if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps)) for (b = kh; b;) mh(a, b), b = rf(b.nextSibling);
	  qh(a);

	  if (13 === a.tag) {
	    a = a.memoizedState;
	    a = null !== a ? a.dehydrated : null;
	    if (!a) throw Error(y(317));

	    a: {
	      a = a.nextSibling;

	      for (b = 0; a;) {
	        if (8 === a.nodeType) {
	          var c = a.data;

	          if ("/$" === c) {
	            if (0 === b) {
	              kh = rf(a.nextSibling);
	              break a;
	            }

	            b--;
	          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
	        }

	        a = a.nextSibling;
	      }

	      kh = null;
	    }
	  } else kh = jh ? rf(a.stateNode.nextSibling) : null;

	  return !0;
	}

	function sh() {
	  kh = jh = null;
	  lh = !1;
	}

	var th = [];

	function uh() {
	  for (var a = 0; a < th.length; a++) th[a]._workInProgressVersionPrimary = null;

	  th.length = 0;
	}

	var vh = ra.ReactCurrentDispatcher,
	    wh = ra.ReactCurrentBatchConfig,
	    xh = 0,
	    R = null,
	    S = null,
	    T = null,
	    yh = !1,
	    zh = !1;

	function Ah() {
	  throw Error(y(321));
	}

	function Bh(a, b) {
	  if (null === b) return !1;

	  for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return !1;

	  return !0;
	}

	function Ch(a, b, c, d, e, f) {
	  xh = f;
	  R = b;
	  b.memoizedState = null;
	  b.updateQueue = null;
	  b.lanes = 0;
	  vh.current = null === a || null === a.memoizedState ? Dh : Eh;
	  a = c(d, e);

	  if (zh) {
	    f = 0;

	    do {
	      zh = !1;
	      if (!(25 > f)) throw Error(y(301));
	      f += 1;
	      T = S = null;
	      b.updateQueue = null;
	      vh.current = Fh;
	      a = c(d, e);
	    } while (zh);
	  }

	  vh.current = Gh;
	  b = null !== S && null !== S.next;
	  xh = 0;
	  T = S = R = null;
	  yh = !1;
	  if (b) throw Error(y(300));
	  return a;
	}

	function Hh() {
	  var a = {
	    memoizedState: null,
	    baseState: null,
	    baseQueue: null,
	    queue: null,
	    next: null
	  };
	  null === T ? R.memoizedState = T = a : T = T.next = a;
	  return T;
	}

	function Ih() {
	  if (null === S) {
	    var a = R.alternate;
	    a = null !== a ? a.memoizedState : null;
	  } else a = S.next;

	  var b = null === T ? R.memoizedState : T.next;
	  if (null !== b) T = b, S = a;else {
	    if (null === a) throw Error(y(310));
	    S = a;
	    a = {
	      memoizedState: S.memoizedState,
	      baseState: S.baseState,
	      baseQueue: S.baseQueue,
	      queue: S.queue,
	      next: null
	    };
	    null === T ? R.memoizedState = T = a : T = T.next = a;
	  }
	  return T;
	}

	function Jh(a, b) {
	  return "function" === typeof b ? b(a) : b;
	}

	function Kh(a) {
	  var b = Ih(),
	      c = b.queue;
	  if (null === c) throw Error(y(311));
	  c.lastRenderedReducer = a;
	  var d = S,
	      e = d.baseQueue,
	      f = c.pending;

	  if (null !== f) {
	    if (null !== e) {
	      var g = e.next;
	      e.next = f.next;
	      f.next = g;
	    }

	    d.baseQueue = e = f;
	    c.pending = null;
	  }

	  if (null !== e) {
	    e = e.next;
	    d = d.baseState;
	    var h = g = f = null,
	        k = e;

	    do {
	      var l = k.lane;
	      if ((xh & l) === l) null !== h && (h = h.next = {
	        lane: 0,
	        action: k.action,
	        eagerReducer: k.eagerReducer,
	        eagerState: k.eagerState,
	        next: null
	      }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);else {
	        var n = {
	          lane: l,
	          action: k.action,
	          eagerReducer: k.eagerReducer,
	          eagerState: k.eagerState,
	          next: null
	        };
	        null === h ? (g = h = n, f = d) : h = h.next = n;
	        R.lanes |= l;
	        Dg |= l;
	      }
	      k = k.next;
	    } while (null !== k && k !== e);

	    null === h ? f = d : h.next = g;
	    He(d, b.memoizedState) || (ug = !0);
	    b.memoizedState = d;
	    b.baseState = f;
	    b.baseQueue = h;
	    c.lastRenderedState = d;
	  }

	  return [b.memoizedState, c.dispatch];
	}

	function Lh(a) {
	  var b = Ih(),
	      c = b.queue;
	  if (null === c) throw Error(y(311));
	  c.lastRenderedReducer = a;
	  var d = c.dispatch,
	      e = c.pending,
	      f = b.memoizedState;

	  if (null !== e) {
	    c.pending = null;
	    var g = e = e.next;

	    do f = a(f, g.action), g = g.next; while (g !== e);

	    He(f, b.memoizedState) || (ug = !0);
	    b.memoizedState = f;
	    null === b.baseQueue && (b.baseState = f);
	    c.lastRenderedState = f;
	  }

	  return [f, d];
	}

	function Mh(a, b, c) {
	  var d = b._getVersion;
	  d = d(b._source);
	  var e = b._workInProgressVersionPrimary;
	  if (null !== e) a = e === d;else if (a = a.mutableReadLanes, a = (xh & a) === a) b._workInProgressVersionPrimary = d, th.push(b);
	  if (a) return c(b._source);
	  th.push(b);
	  throw Error(y(350));
	}

	function Nh(a, b, c, d) {
	  var e = U;
	  if (null === e) throw Error(y(349));
	  var f = b._getVersion,
	      g = f(b._source),
	      h = vh.current,
	      k = h.useState(function () {
	    return Mh(e, b, c);
	  }),
	      l = k[1],
	      n = k[0];
	  k = T;
	  var A = a.memoizedState,
	      p = A.refs,
	      C = p.getSnapshot,
	      x = A.source;
	  A = A.subscribe;
	  var w = R;
	  a.memoizedState = {
	    refs: p,
	    source: b,
	    subscribe: d
	  };
	  h.useEffect(function () {
	    p.getSnapshot = c;
	    p.setSnapshot = l;
	    var a = f(b._source);

	    if (!He(g, a)) {
	      a = c(b._source);
	      He(n, a) || (l(a), a = Ig(w), e.mutableReadLanes |= a & e.pendingLanes);
	      a = e.mutableReadLanes;
	      e.entangledLanes |= a;

	      for (var d = e.entanglements, h = a; 0 < h;) {
	        var k = 31 - Vc(h),
	            v = 1 << k;
	        d[k] |= a;
	        h &= ~v;
	      }
	    }
	  }, [c, b, d]);
	  h.useEffect(function () {
	    return d(b._source, function () {
	      var a = p.getSnapshot,
	          c = p.setSnapshot;

	      try {
	        c(a(b._source));
	        var d = Ig(w);
	        e.mutableReadLanes |= d & e.pendingLanes;
	      } catch (q) {
	        c(function () {
	          throw q;
	        });
	      }
	    });
	  }, [b, d]);
	  He(C, c) && He(x, b) && He(A, d) || (a = {
	    pending: null,
	    dispatch: null,
	    lastRenderedReducer: Jh,
	    lastRenderedState: n
	  }, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
	  return n;
	}

	function Ph(a, b, c) {
	  var d = Ih();
	  return Nh(d, a, b, c);
	}

	function Qh(a) {
	  var b = Hh();
	  "function" === typeof a && (a = a());
	  b.memoizedState = b.baseState = a;
	  a = b.queue = {
	    pending: null,
	    dispatch: null,
	    lastRenderedReducer: Jh,
	    lastRenderedState: a
	  };
	  a = a.dispatch = Oh.bind(null, R, a);
	  return [b.memoizedState, a];
	}

	function Rh(a, b, c, d) {
	  a = {
	    tag: a,
	    create: b,
	    destroy: c,
	    deps: d,
	    next: null
	  };
	  b = R.updateQueue;
	  null === b ? (b = {
	    lastEffect: null
	  }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
	  return a;
	}

	function Sh(a) {
	  var b = Hh();
	  a = {
	    current: a
	  };
	  return b.memoizedState = a;
	}

	function Th() {
	  return Ih().memoizedState;
	}

	function Uh(a, b, c, d) {
	  var e = Hh();
	  R.flags |= a;
	  e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
	}

	function Vh(a, b, c, d) {
	  var e = Ih();
	  d = void 0 === d ? null : d;
	  var f = void 0;

	  if (null !== S) {
	    var g = S.memoizedState;
	    f = g.destroy;

	    if (null !== d && Bh(d, g.deps)) {
	      Rh(b, c, f, d);
	      return;
	    }
	  }

	  R.flags |= a;
	  e.memoizedState = Rh(1 | b, c, f, d);
	}

	function Wh(a, b) {
	  return Uh(516, 4, a, b);
	}

	function Xh(a, b) {
	  return Vh(516, 4, a, b);
	}

	function Yh(a, b) {
	  return Vh(4, 2, a, b);
	}

	function Zh(a, b) {
	  if ("function" === typeof b) return a = a(), b(a), function () {
	    b(null);
	  };
	  if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
	    b.current = null;
	  };
	}

	function $h(a, b, c) {
	  c = null !== c && void 0 !== c ? c.concat([a]) : null;
	  return Vh(4, 2, Zh.bind(null, b, a), c);
	}

	function ai() {}

	function bi(a, b) {
	  var c = Ih();
	  b = void 0 === b ? null : b;
	  var d = c.memoizedState;
	  if (null !== d && null !== b && Bh(b, d[1])) return d[0];
	  c.memoizedState = [a, b];
	  return a;
	}

	function ci(a, b) {
	  var c = Ih();
	  b = void 0 === b ? null : b;
	  var d = c.memoizedState;
	  if (null !== d && null !== b && Bh(b, d[1])) return d[0];
	  a = a();
	  c.memoizedState = [a, b];
	  return a;
	}

	function di(a, b) {
	  var c = eg();
	  gg(98 > c ? 98 : c, function () {
	    a(!0);
	  });
	  gg(97 < c ? 97 : c, function () {
	    var c = wh.transition;
	    wh.transition = 1;

	    try {
	      a(!1), b();
	    } finally {
	      wh.transition = c;
	    }
	  });
	}

	function Oh(a, b, c) {
	  var d = Hg(),
	      e = Ig(a),
	      f = {
	    lane: e,
	    action: c,
	    eagerReducer: null,
	    eagerState: null,
	    next: null
	  },
	      g = b.pending;
	  null === g ? f.next = f : (f.next = g.next, g.next = f);
	  b.pending = f;
	  g = a.alternate;
	  if (a === R || null !== g && g === R) zh = yh = !0;else {
	    if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g)) try {
	      var h = b.lastRenderedState,
	          k = g(h, c);
	      f.eagerReducer = g;
	      f.eagerState = k;
	      if (He(k, h)) return;
	    } catch (l) {} finally {}
	    Jg(a, e, d);
	  }
	}

	var Gh = {
	  readContext: vg,
	  useCallback: Ah,
	  useContext: Ah,
	  useEffect: Ah,
	  useImperativeHandle: Ah,
	  useLayoutEffect: Ah,
	  useMemo: Ah,
	  useReducer: Ah,
	  useRef: Ah,
	  useState: Ah,
	  useDebugValue: Ah,
	  useDeferredValue: Ah,
	  useTransition: Ah,
	  useMutableSource: Ah,
	  useOpaqueIdentifier: Ah,
	  unstable_isNewReconciler: !1
	},
	    Dh = {
	  readContext: vg,
	  useCallback: function (a, b) {
	    Hh().memoizedState = [a, void 0 === b ? null : b];
	    return a;
	  },
	  useContext: vg,
	  useEffect: Wh,
	  useImperativeHandle: function (a, b, c) {
	    c = null !== c && void 0 !== c ? c.concat([a]) : null;
	    return Uh(4, 2, Zh.bind(null, b, a), c);
	  },
	  useLayoutEffect: function (a, b) {
	    return Uh(4, 2, a, b);
	  },
	  useMemo: function (a, b) {
	    var c = Hh();
	    b = void 0 === b ? null : b;
	    a = a();
	    c.memoizedState = [a, b];
	    return a;
	  },
	  useReducer: function (a, b, c) {
	    var d = Hh();
	    b = void 0 !== c ? c(b) : b;
	    d.memoizedState = d.baseState = b;
	    a = d.queue = {
	      pending: null,
	      dispatch: null,
	      lastRenderedReducer: a,
	      lastRenderedState: b
	    };
	    a = a.dispatch = Oh.bind(null, R, a);
	    return [d.memoizedState, a];
	  },
	  useRef: Sh,
	  useState: Qh,
	  useDebugValue: ai,
	  useDeferredValue: function (a) {
	    var b = Qh(a),
	        c = b[0],
	        d = b[1];
	    Wh(function () {
	      var b = wh.transition;
	      wh.transition = 1;

	      try {
	        d(a);
	      } finally {
	        wh.transition = b;
	      }
	    }, [a]);
	    return c;
	  },
	  useTransition: function () {
	    var a = Qh(!1),
	        b = a[0];
	    a = di.bind(null, a[1]);
	    Sh(a);
	    return [a, b];
	  },
	  useMutableSource: function (a, b, c) {
	    var d = Hh();
	    d.memoizedState = {
	      refs: {
	        getSnapshot: b,
	        setSnapshot: null
	      },
	      source: a,
	      subscribe: c
	    };
	    return Nh(d, a, b, c);
	  },
	  useOpaqueIdentifier: function () {
	    if (lh) {
	      var a = !1,
	          b = uf(function () {
	        a || (a = !0, c("r:" + (tf++).toString(36)));
	        throw Error(y(355));
	      }),
	          c = Qh(b)[1];
	      0 === (R.mode & 2) && (R.flags |= 516, Rh(5, function () {
	        c("r:" + (tf++).toString(36));
	      }, void 0, null));
	      return b;
	    }

	    b = "r:" + (tf++).toString(36);
	    Qh(b);
	    return b;
	  },
	  unstable_isNewReconciler: !1
	},
	    Eh = {
	  readContext: vg,
	  useCallback: bi,
	  useContext: vg,
	  useEffect: Xh,
	  useImperativeHandle: $h,
	  useLayoutEffect: Yh,
	  useMemo: ci,
	  useReducer: Kh,
	  useRef: Th,
	  useState: function () {
	    return Kh(Jh);
	  },
	  useDebugValue: ai,
	  useDeferredValue: function (a) {
	    var b = Kh(Jh),
	        c = b[0],
	        d = b[1];
	    Xh(function () {
	      var b = wh.transition;
	      wh.transition = 1;

	      try {
	        d(a);
	      } finally {
	        wh.transition = b;
	      }
	    }, [a]);
	    return c;
	  },
	  useTransition: function () {
	    var a = Kh(Jh)[0];
	    return [Th().current, a];
	  },
	  useMutableSource: Ph,
	  useOpaqueIdentifier: function () {
	    return Kh(Jh)[0];
	  },
	  unstable_isNewReconciler: !1
	},
	    Fh = {
	  readContext: vg,
	  useCallback: bi,
	  useContext: vg,
	  useEffect: Xh,
	  useImperativeHandle: $h,
	  useLayoutEffect: Yh,
	  useMemo: ci,
	  useReducer: Lh,
	  useRef: Th,
	  useState: function () {
	    return Lh(Jh);
	  },
	  useDebugValue: ai,
	  useDeferredValue: function (a) {
	    var b = Lh(Jh),
	        c = b[0],
	        d = b[1];
	    Xh(function () {
	      var b = wh.transition;
	      wh.transition = 1;

	      try {
	        d(a);
	      } finally {
	        wh.transition = b;
	      }
	    }, [a]);
	    return c;
	  },
	  useTransition: function () {
	    var a = Lh(Jh)[0];
	    return [Th().current, a];
	  },
	  useMutableSource: Ph,
	  useOpaqueIdentifier: function () {
	    return Lh(Jh)[0];
	  },
	  unstable_isNewReconciler: !1
	},
	    ei = ra.ReactCurrentOwner,
	    ug = !1;

	function fi(a, b, c, d) {
	  b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
	}

	function gi(a, b, c, d, e) {
	  c = c.render;
	  var f = b.ref;
	  tg(b, e);
	  d = Ch(a, b, c, d, f, e);
	  if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
	  b.flags |= 1;
	  fi(a, b, d, e);
	  return b.child;
	}

	function ii(a, b, c, d, e, f) {
	  if (null === a) {
	    var g = c.type;
	    if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
	    a = Vg(c.type, null, d, b, b.mode, f);
	    a.ref = b.ref;
	    a.return = b;
	    return b.child = a;
	  }

	  g = a.child;
	  if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref)) return hi(a, b, f);
	  b.flags |= 1;
	  a = Tg(g, d);
	  a.ref = b.ref;
	  a.return = b;
	  return b.child = a;
	}

	function ki(a, b, c, d, e, f) {
	  if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref) if (ug = !1, 0 !== (f & e)) 0 !== (a.flags & 16384) && (ug = !0);else return b.lanes = a.lanes, hi(a, b, f);
	  return li(a, b, c, d, f);
	}

	function mi(a, b, c) {
	  var d = b.pendingProps,
	      e = d.children,
	      f = null !== a ? a.memoizedState : null;
	  if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode) {
	    if (0 === (b.mode & 4)) b.memoizedState = {
	      baseLanes: 0
	    }, ni(b, c);else if (0 !== (c & 1073741824)) b.memoizedState = {
	      baseLanes: 0
	    }, ni(b, null !== f ? f.baseLanes : c);else return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
	      baseLanes: a
	    }, ni(b, a), null;
	  } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
	  fi(a, b, e, c);
	  return b.child;
	}

	function oi(a, b) {
	  var c = b.ref;
	  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 128;
	}

	function li(a, b, c, d, e) {
	  var f = Ff(c) ? Df : M.current;
	  f = Ef(b, f);
	  tg(b, e);
	  c = Ch(a, b, c, d, f, e);
	  if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
	  b.flags |= 1;
	  fi(a, b, c, e);
	  return b.child;
	}

	function pi(a, b, c, d, e) {
	  if (Ff(c)) {
	    var f = !0;
	    Jf(b);
	  } else f = !1;

	  tg(b, e);
	  if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = !0;else if (null === a) {
	    var g = b.stateNode,
	        h = b.memoizedProps;
	    g.props = h;
	    var k = g.context,
	        l = c.contextType;
	    "object" === typeof l && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));
	    var n = c.getDerivedStateFromProps,
	        A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;
	    A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);
	    wg = !1;
	    var p = b.memoizedState;
	    g.state = p;
	    Cg(b, d, g, e);
	    k = b.memoizedState;
	    h !== d || p !== k || N.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = !1);
	  } else {
	    g = b.stateNode;
	    yg(a, b);
	    h = b.memoizedProps;
	    l = b.type === b.elementType ? h : lg(b.type, h);
	    g.props = l;
	    A = b.pendingProps;
	    p = g.context;
	    k = c.contextType;
	    "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
	    var C = c.getDerivedStateFromProps;
	    (n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);
	    wg = !1;
	    p = b.memoizedState;
	    g.state = p;
	    Cg(b, d, g, e);
	    var x = b.memoizedState;
	    h !== A || p !== x || N.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = !1);
	  }
	  return qi(a, b, c, d, f, e);
	}

	function qi(a, b, c, d, e, f) {
	  oi(a, b);
	  var g = 0 !== (b.flags & 64);
	  if (!d && !g) return e && Kf(b, c, !1), hi(a, b, f);
	  d = b.stateNode;
	  ei.current = b;
	  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
	  b.flags |= 1;
	  null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
	  b.memoizedState = d.state;
	  e && Kf(b, c, !0);
	  return b.child;
	}

	function ri(a) {
	  var b = a.stateNode;
	  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, !1);
	  eh(a, b.containerInfo);
	}

	var si = {
	  dehydrated: null,
	  retryLane: 0
	};

	function ti(a, b, c) {
	  var d = b.pendingProps,
	      e = P.current,
	      f = !1,
	      g;
	  (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
	  g ? (f = !0, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || !0 === d.unstable_avoidThisFallback || (e |= 1);
	  I(P, e & 1);

	  if (null === a) {
	    void 0 !== d.fallback && ph(b);
	    a = d.children;
	    e = d.fallback;
	    if (f) return a = ui(b, a, e, c), b.child.memoizedState = {
	      baseLanes: c
	    }, b.memoizedState = si, a;
	    if ("number" === typeof d.unstable_expectedLoadTime) return a = ui(b, a, e, c), b.child.memoizedState = {
	      baseLanes: c
	    }, b.memoizedState = si, b.lanes = 33554432, a;
	    c = vi({
	      mode: "visible",
	      children: a
	    }, b.mode, c, null);
	    c.return = b;
	    return b.child = c;
	  }

	  if (null !== a.memoizedState) {
	    if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? {
	      baseLanes: c
	    } : {
	      baseLanes: e.baseLanes | c
	    }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
	    c = xi(a, b, d.children, c);
	    b.memoizedState = null;
	    return c;
	  }

	  if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? {
	    baseLanes: c
	  } : {
	    baseLanes: e.baseLanes | c
	  }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
	  c = xi(a, b, d.children, c);
	  b.memoizedState = null;
	  return c;
	}

	function ui(a, b, c, d) {
	  var e = a.mode,
	      f = a.child;
	  b = {
	    mode: "hidden",
	    children: b
	  };
	  0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
	  c = Xg(c, e, d, null);
	  f.return = a;
	  c.return = a;
	  f.sibling = c;
	  a.child = f;
	  return c;
	}

	function xi(a, b, c, d) {
	  var e = a.child;
	  a = e.sibling;
	  c = Tg(e, {
	    mode: "visible",
	    children: c
	  });
	  0 === (b.mode & 2) && (c.lanes = d);
	  c.return = b;
	  c.sibling = null;
	  null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
	  return b.child = c;
	}

	function wi(a, b, c, d, e) {
	  var f = b.mode,
	      g = a.child;
	  a = g.sibling;
	  var h = {
	    mode: "hidden",
	    children: c
	  };
	  0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
	  null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
	  d.return = b;
	  c.return = b;
	  c.sibling = d;
	  b.child = c;
	  return d;
	}

	function yi(a, b) {
	  a.lanes |= b;
	  var c = a.alternate;
	  null !== c && (c.lanes |= b);
	  sg(a.return, b);
	}

	function zi(a, b, c, d, e, f) {
	  var g = a.memoizedState;
	  null === g ? a.memoizedState = {
	    isBackwards: b,
	    rendering: null,
	    renderingStartTime: 0,
	    last: d,
	    tail: c,
	    tailMode: e,
	    lastEffect: f
	  } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
	}

	function Ai(a, b, c) {
	  var d = b.pendingProps,
	      e = d.revealOrder,
	      f = d.tail;
	  fi(a, b, d.children, c);
	  d = P.current;
	  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 64;else {
	    if (null !== a && 0 !== (a.flags & 64)) a: for (a = b.child; null !== a;) {
	      if (13 === a.tag) null !== a.memoizedState && yi(a, c);else if (19 === a.tag) yi(a, c);else if (null !== a.child) {
	        a.child.return = a;
	        a = a.child;
	        continue;
	      }
	      if (a === b) break a;

	      for (; null === a.sibling;) {
	        if (null === a.return || a.return === b) break a;
	        a = a.return;
	      }

	      a.sibling.return = a.return;
	      a = a.sibling;
	    }
	    d &= 1;
	  }
	  I(P, d);
	  if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {
	    case "forwards":
	      c = b.child;

	      for (e = null; null !== c;) a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;

	      c = e;
	      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
	      zi(b, !1, e, c, f, b.lastEffect);
	      break;

	    case "backwards":
	      c = null;
	      e = b.child;

	      for (b.child = null; null !== e;) {
	        a = e.alternate;

	        if (null !== a && null === ih(a)) {
	          b.child = e;
	          break;
	        }

	        a = e.sibling;
	        e.sibling = c;
	        c = e;
	        e = a;
	      }

	      zi(b, !0, c, null, f, b.lastEffect);
	      break;

	    case "together":
	      zi(b, !1, null, null, void 0, b.lastEffect);
	      break;

	    default:
	      b.memoizedState = null;
	  }
	  return b.child;
	}

	function hi(a, b, c) {
	  null !== a && (b.dependencies = a.dependencies);
	  Dg |= b.lanes;

	  if (0 !== (c & b.childLanes)) {
	    if (null !== a && b.child !== a.child) throw Error(y(153));

	    if (null !== b.child) {
	      a = b.child;
	      c = Tg(a, a.pendingProps);
	      b.child = c;

	      for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;

	      c.sibling = null;
	    }

	    return b.child;
	  }

	  return null;
	}

	var Bi, Ci, Di, Ei;

	Bi = function (a, b) {
	  for (var c = b.child; null !== c;) {
	    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
	      c.child.return = c;
	      c = c.child;
	      continue;
	    }
	    if (c === b) break;

	    for (; null === c.sibling;) {
	      if (null === c.return || c.return === b) return;
	      c = c.return;
	    }

	    c.sibling.return = c.return;
	    c = c.sibling;
	  }
	};

	Ci = function () {};

	Di = function (a, b, c, d) {
	  var e = a.memoizedProps;

	  if (e !== d) {
	    a = b.stateNode;
	    dh(ah.current);
	    var f = null;

	    switch (c) {
	      case "input":
	        e = Ya(a, e);
	        d = Ya(a, d);
	        f = [];
	        break;

	      case "option":
	        e = eb(a, e);
	        d = eb(a, d);
	        f = [];
	        break;

	      case "select":
	        e = objectAssign({}, e, {
	          value: void 0
	        });
	        d = objectAssign({}, d, {
	          value: void 0
	        });
	        f = [];
	        break;

	      case "textarea":
	        e = gb(a, e);
	        d = gb(a, d);
	        f = [];
	        break;

	      default:
	        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
	    }

	    vb(c, d);
	    var g;
	    c = null;

	    for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
	      var h = e[l];

	      for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
	    } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));

	    for (l in d) {
	      var k = d[l];
	      h = null != e ? e[l] : void 0;
	      if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
	        if (h) {
	          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");

	          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
	        } else c || (f || (f = []), f.push(l, c)), c = k;
	      } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
	    }

	    c && (f = f || []).push("style", c);
	    var l = f;
	    if (b.updateQueue = l) b.flags |= 4;
	  }
	};

	Ei = function (a, b, c, d) {
	  c !== d && (b.flags |= 4);
	};

	function Fi(a, b) {
	  if (!lh) switch (a.tailMode) {
	    case "hidden":
	      b = a.tail;

	      for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;

	      null === c ? a.tail = null : c.sibling = null;
	      break;

	    case "collapsed":
	      c = a.tail;

	      for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;

	      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
	  }
	}

	function Gi(a, b, c) {
	  var d = b.pendingProps;

	  switch (b.tag) {
	    case 2:
	    case 16:
	    case 15:
	    case 0:
	    case 11:
	    case 7:
	    case 8:
	    case 12:
	    case 9:
	    case 14:
	      return null;

	    case 1:
	      return Ff(b.type) && Gf(), null;

	    case 3:
	      fh();
	      H(N);
	      H(M);
	      uh();
	      d = b.stateNode;
	      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
	      if (null === a || null === a.child) rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
	      Ci(b);
	      return null;

	    case 5:
	      hh(b);
	      var e = dh(ch.current);
	      c = b.type;
	      if (null !== a && null != b.stateNode) Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);else {
	        if (!d) {
	          if (null === b.stateNode) throw Error(y(166));
	          return null;
	        }

	        a = dh(ah.current);

	        if (rh(b)) {
	          d = b.stateNode;
	          c = b.type;
	          var f = b.memoizedProps;
	          d[wf] = b;
	          d[xf] = f;

	          switch (c) {
	            case "dialog":
	              G("cancel", d);
	              G("close", d);
	              break;

	            case "iframe":
	            case "object":
	            case "embed":
	              G("load", d);
	              break;

	            case "video":
	            case "audio":
	              for (a = 0; a < Xe.length; a++) G(Xe[a], d);

	              break;

	            case "source":
	              G("error", d);
	              break;

	            case "img":
	            case "image":
	            case "link":
	              G("error", d);
	              G("load", d);
	              break;

	            case "details":
	              G("toggle", d);
	              break;

	            case "input":
	              Za(d, f);
	              G("invalid", d);
	              break;

	            case "select":
	              d._wrapperState = {
	                wasMultiple: !!f.multiple
	              };
	              G("invalid", d);
	              break;

	            case "textarea":
	              hb(d, f), G("invalid", d);
	          }

	          vb(c, f);
	          a = null;

	          for (var g in f) f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));

	          switch (c) {
	            case "input":
	              Va(d);
	              cb(d, f, !0);
	              break;

	            case "textarea":
	              Va(d);
	              jb(d);
	              break;

	            case "select":
	            case "option":
	              break;

	            default:
	              "function" === typeof f.onClick && (d.onclick = jf);
	          }

	          d = a;
	          b.updateQueue = d;
	          null !== d && (b.flags |= 4);
	        } else {
	          g = 9 === e.nodeType ? e : e.ownerDocument;
	          a === kb.html && (a = lb(c));
	          a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
	            is: d.is
	          }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
	          a[wf] = b;
	          a[xf] = d;
	          Bi(a, b, !1, !1);
	          b.stateNode = a;
	          g = wb(c, d);

	          switch (c) {
	            case "dialog":
	              G("cancel", a);
	              G("close", a);
	              e = d;
	              break;

	            case "iframe":
	            case "object":
	            case "embed":
	              G("load", a);
	              e = d;
	              break;

	            case "video":
	            case "audio":
	              for (e = 0; e < Xe.length; e++) G(Xe[e], a);

	              e = d;
	              break;

	            case "source":
	              G("error", a);
	              e = d;
	              break;

	            case "img":
	            case "image":
	            case "link":
	              G("error", a);
	              G("load", a);
	              e = d;
	              break;

	            case "details":
	              G("toggle", a);
	              e = d;
	              break;

	            case "input":
	              Za(a, d);
	              e = Ya(a, d);
	              G("invalid", a);
	              break;

	            case "option":
	              e = eb(a, d);
	              break;

	            case "select":
	              a._wrapperState = {
	                wasMultiple: !!d.multiple
	              };
	              e = objectAssign({}, d, {
	                value: void 0
	              });
	              G("invalid", a);
	              break;

	            case "textarea":
	              hb(a, d);
	              e = gb(a, d);
	              G("invalid", a);
	              break;

	            default:
	              e = d;
	          }

	          vb(c, e);
	          var h = e;

	          for (f in h) if (h.hasOwnProperty(f)) {
	            var k = h[f];
	            "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
	          }

	          switch (c) {
	            case "input":
	              Va(a);
	              cb(a, d, !1);
	              break;

	            case "textarea":
	              Va(a);
	              jb(a);
	              break;

	            case "option":
	              null != d.value && a.setAttribute("value", "" + Sa(d.value));
	              break;

	            case "select":
	              a.multiple = !!d.multiple;
	              f = d.value;
	              null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
	              break;

	            default:
	              "function" === typeof e.onClick && (a.onclick = jf);
	          }

	          mf(c, d) && (b.flags |= 4);
	        }

	        null !== b.ref && (b.flags |= 128);
	      }
	      return null;

	    case 6:
	      if (a && null != b.stateNode) Ei(a, b, a.memoizedProps, d);else {
	        if ("string" !== typeof d && null === b.stateNode) throw Error(y(166));
	        c = dh(ch.current);
	        dh(ah.current);
	        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
	      }
	      return null;

	    case 13:
	      H(P);
	      d = b.memoizedState;
	      if (0 !== (b.flags & 64)) return b.lanes = c, b;
	      d = null !== d;
	      c = !1;
	      null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
	      if (d && !c && 0 !== (b.mode & 2)) if (null === a && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1)) 0 === V && (V = 3);else {
	        if (0 === V || 3 === V) V = 4;
	        null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
	      }
	      if (d || c) b.flags |= 4;
	      return null;

	    case 4:
	      return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;

	    case 10:
	      return rg(b), null;

	    case 17:
	      return Ff(b.type) && Gf(), null;

	    case 19:
	      H(P);
	      d = b.memoizedState;
	      if (null === d) return null;
	      f = 0 !== (b.flags & 64);
	      g = d.rendering;
	      if (null === g) {
	        if (f) Fi(d, !1);else {
	          if (0 !== V || null !== a && 0 !== (a.flags & 64)) for (a = b.child; null !== a;) {
	            g = ih(a);

	            if (null !== g) {
	              b.flags |= 64;
	              Fi(d, !1);
	              f = g.updateQueue;
	              null !== f && (b.updateQueue = f, b.flags |= 4);
	              null === d.lastEffect && (b.firstEffect = null);
	              b.lastEffect = d.lastEffect;
	              d = c;

	              for (c = b.child; null !== c;) f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
	                lanes: a.lanes,
	                firstContext: a.firstContext
	              }), c = c.sibling;

	              I(P, P.current & 1 | 2);
	              return b.child;
	            }

	            a = a.sibling;
	          }
	          null !== d.tail && O() > Ji && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
	        }
	      } else {
	        if (!f) if (a = ih(g), null !== a) {
	          if (b.flags |= 64, f = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, !0), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh) return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
	        } else 2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
	        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
	      }
	      return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;

	    case 23:
	    case 24:
	      return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
	  }

	  throw Error(y(156, b.tag));
	}

	function Li(a) {
	  switch (a.tag) {
	    case 1:
	      Ff(a.type) && Gf();
	      var b = a.flags;
	      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;

	    case 3:
	      fh();
	      H(N);
	      H(M);
	      uh();
	      b = a.flags;
	      if (0 !== (b & 64)) throw Error(y(285));
	      a.flags = b & -4097 | 64;
	      return a;

	    case 5:
	      return hh(a), null;

	    case 13:
	      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;

	    case 19:
	      return H(P), null;

	    case 4:
	      return fh(), null;

	    case 10:
	      return rg(a), null;

	    case 23:
	    case 24:
	      return Ki(), null;

	    default:
	      return null;
	  }
	}

	function Mi(a, b) {
	  try {
	    var c = "",
	        d = b;

	    do c += Qa(d), d = d.return; while (d);

	    var e = c;
	  } catch (f) {
	    e = "\nError generating stack: " + f.message + "\n" + f.stack;
	  }

	  return {
	    value: a,
	    source: b,
	    stack: e
	  };
	}

	function Ni(a, b) {
	  try {
	    console.error(b.value);
	  } catch (c) {
	    setTimeout(function () {
	      throw c;
	    });
	  }
	}

	var Oi = "function" === typeof WeakMap ? WeakMap : Map;

	function Pi(a, b, c) {
	  c = zg(-1, c);
	  c.tag = 3;
	  c.payload = {
	    element: null
	  };
	  var d = b.value;

	  c.callback = function () {
	    Qi || (Qi = !0, Ri = d);
	    Ni(a, b);
	  };

	  return c;
	}

	function Si(a, b, c) {
	  c = zg(-1, c);
	  c.tag = 3;
	  var d = a.type.getDerivedStateFromError;

	  if ("function" === typeof d) {
	    var e = b.value;

	    c.payload = function () {
	      Ni(a, b);
	      return d(e);
	    };
	  }

	  var f = a.stateNode;
	  null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
	    "function" !== typeof d && (null === Ti ? Ti = new Set([this]) : Ti.add(this), Ni(a, b));
	    var c = b.stack;
	    this.componentDidCatch(b.value, {
	      componentStack: null !== c ? c : ""
	    });
	  });
	  return c;
	}

	var Ui = "function" === typeof WeakSet ? WeakSet : Set;

	function Vi(a) {
	  var b = a.ref;
	  if (null !== b) if ("function" === typeof b) try {
	    b(null);
	  } catch (c) {
	    Wi(a, c);
	  } else b.current = null;
	}

	function Xi(a, b) {
	  switch (b.tag) {
	    case 0:
	    case 11:
	    case 15:
	    case 22:
	      return;

	    case 1:
	      if (b.flags & 256 && null !== a) {
	        var c = a.memoizedProps,
	            d = a.memoizedState;
	        a = b.stateNode;
	        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
	        a.__reactInternalSnapshotBeforeUpdate = b;
	      }

	      return;

	    case 3:
	      b.flags & 256 && qf(b.stateNode.containerInfo);
	      return;

	    case 5:
	    case 6:
	    case 4:
	    case 17:
	      return;
	  }

	  throw Error(y(163));
	}

	function Yi(a, b, c) {
	  switch (c.tag) {
	    case 0:
	    case 11:
	    case 15:
	    case 22:
	      b = c.updateQueue;
	      b = null !== b ? b.lastEffect : null;

	      if (null !== b) {
	        a = b = b.next;

	        do {
	          if (3 === (a.tag & 3)) {
	            var d = a.create;
	            a.destroy = d();
	          }

	          a = a.next;
	        } while (a !== b);
	      }

	      b = c.updateQueue;
	      b = null !== b ? b.lastEffect : null;

	      if (null !== b) {
	        a = b = b.next;

	        do {
	          var e = a;
	          d = e.next;
	          e = e.tag;
	          0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
	          a = d;
	        } while (a !== b);
	      }

	      return;

	    case 1:
	      a = c.stateNode;
	      c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
	      b = c.updateQueue;
	      null !== b && Eg(c, b, a);
	      return;

	    case 3:
	      b = c.updateQueue;

	      if (null !== b) {
	        a = null;
	        if (null !== c.child) switch (c.child.tag) {
	          case 5:
	            a = c.child.stateNode;
	            break;

	          case 1:
	            a = c.child.stateNode;
	        }
	        Eg(c, b, a);
	      }

	      return;

	    case 5:
	      a = c.stateNode;
	      null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
	      return;

	    case 6:
	      return;

	    case 4:
	      return;

	    case 12:
	      return;

	    case 13:
	      null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
	      return;

	    case 19:
	    case 17:
	    case 20:
	    case 21:
	    case 23:
	    case 24:
	      return;
	  }

	  throw Error(y(163));
	}

	function aj(a, b) {
	  for (var c = a;;) {
	    if (5 === c.tag) {
	      var d = c.stateNode;
	      if (b) d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";else {
	        d = c.stateNode;
	        var e = c.memoizedProps.style;
	        e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
	        d.style.display = sb("display", e);
	      }
	    } else if (6 === c.tag) c.stateNode.nodeValue = b ? "" : c.memoizedProps;else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
	      c.child.return = c;
	      c = c.child;
	      continue;
	    }

	    if (c === a) break;

	    for (; null === c.sibling;) {
	      if (null === c.return || c.return === a) return;
	      c = c.return;
	    }

	    c.sibling.return = c.return;
	    c = c.sibling;
	  }
	}

	function bj(a, b) {
	  if (Mf && "function" === typeof Mf.onCommitFiberUnmount) try {
	    Mf.onCommitFiberUnmount(Lf, b);
	  } catch (f) {}

	  switch (b.tag) {
	    case 0:
	    case 11:
	    case 14:
	    case 15:
	    case 22:
	      a = b.updateQueue;

	      if (null !== a && (a = a.lastEffect, null !== a)) {
	        var c = a = a.next;

	        do {
	          var d = c,
	              e = d.destroy;
	          d = d.tag;
	          if (void 0 !== e) if (0 !== (d & 4)) Zi(b, c);else {
	            d = b;

	            try {
	              e();
	            } catch (f) {
	              Wi(d, f);
	            }
	          }
	          c = c.next;
	        } while (c !== a);
	      }

	      break;

	    case 1:
	      Vi(b);
	      a = b.stateNode;
	      if ("function" === typeof a.componentWillUnmount) try {
	        a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
	      } catch (f) {
	        Wi(b, f);
	      }
	      break;

	    case 5:
	      Vi(b);
	      break;

	    case 4:
	      cj(a, b);
	  }
	}

	function dj(a) {
	  a.alternate = null;
	  a.child = null;
	  a.dependencies = null;
	  a.firstEffect = null;
	  a.lastEffect = null;
	  a.memoizedProps = null;
	  a.memoizedState = null;
	  a.pendingProps = null;
	  a.return = null;
	  a.updateQueue = null;
	}

	function ej(a) {
	  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
	}

	function fj(a) {
	  a: {
	    for (var b = a.return; null !== b;) {
	      if (ej(b)) break a;
	      b = b.return;
	    }

	    throw Error(y(160));
	  }

	  var c = b;
	  b = c.stateNode;

	  switch (c.tag) {
	    case 5:
	      var d = !1;
	      break;

	    case 3:
	      b = b.containerInfo;
	      d = !0;
	      break;

	    case 4:
	      b = b.containerInfo;
	      d = !0;
	      break;

	    default:
	      throw Error(y(161));
	  }

	  c.flags & 16 && (pb(b, ""), c.flags &= -17);

	  a: b: for (c = a;;) {
	    for (; null === c.sibling;) {
	      if (null === c.return || ej(c.return)) {
	        c = null;
	        break a;
	      }

	      c = c.return;
	    }

	    c.sibling.return = c.return;

	    for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {
	      if (c.flags & 2) continue b;
	      if (null === c.child || 4 === c.tag) continue b;else c.child.return = c, c = c.child;
	    }

	    if (!(c.flags & 2)) {
	      c = c.stateNode;
	      break a;
	    }
	  }

	  d ? gj(a, c, b) : hj(a, c, b);
	}

	function gj(a, b, c) {
	  var d = a.tag,
	      e = 5 === d || 6 === d;
	  if (e) a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));else if (4 !== d && (a = a.child, null !== a)) for (gj(a, b, c), a = a.sibling; null !== a;) gj(a, b, c), a = a.sibling;
	}

	function hj(a, b, c) {
	  var d = a.tag,
	      e = 5 === d || 6 === d;
	  if (e) a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (hj(a, b, c), a = a.sibling; null !== a;) hj(a, b, c), a = a.sibling;
	}

	function cj(a, b) {
	  for (var c = b, d = !1, e, f;;) {
	    if (!d) {
	      d = c.return;

	      a: for (;;) {
	        if (null === d) throw Error(y(160));
	        e = d.stateNode;

	        switch (d.tag) {
	          case 5:
	            f = !1;
	            break a;

	          case 3:
	            e = e.containerInfo;
	            f = !0;
	            break a;

	          case 4:
	            e = e.containerInfo;
	            f = !0;
	            break a;
	        }

	        d = d.return;
	      }

	      d = !0;
	    }

	    if (5 === c.tag || 6 === c.tag) {
	      a: for (var g = a, h = c, k = h;;) if (bj(g, k), null !== k.child && 4 !== k.tag) k.child.return = k, k = k.child;else {
	        if (k === h) break a;

	        for (; null === k.sibling;) {
	          if (null === k.return || k.return === h) break a;
	          k = k.return;
	        }

	        k.sibling.return = k.return;
	        k = k.sibling;
	      }

	      f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
	    } else if (4 === c.tag) {
	      if (null !== c.child) {
	        e = c.stateNode.containerInfo;
	        f = !0;
	        c.child.return = c;
	        c = c.child;
	        continue;
	      }
	    } else if (bj(a, c), null !== c.child) {
	      c.child.return = c;
	      c = c.child;
	      continue;
	    }

	    if (c === b) break;

	    for (; null === c.sibling;) {
	      if (null === c.return || c.return === b) return;
	      c = c.return;
	      4 === c.tag && (d = !1);
	    }

	    c.sibling.return = c.return;
	    c = c.sibling;
	  }
	}

	function ij(a, b) {
	  switch (b.tag) {
	    case 0:
	    case 11:
	    case 14:
	    case 15:
	    case 22:
	      var c = b.updateQueue;
	      c = null !== c ? c.lastEffect : null;

	      if (null !== c) {
	        var d = c = c.next;

	        do 3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next; while (d !== c);
	      }

	      return;

	    case 1:
	      return;

	    case 5:
	      c = b.stateNode;

	      if (null != c) {
	        d = b.memoizedProps;
	        var e = null !== a ? a.memoizedProps : d;
	        a = b.type;
	        var f = b.updateQueue;
	        b.updateQueue = null;

	        if (null !== f) {
	          c[xf] = d;
	          "input" === a && "radio" === d.type && null != d.name && $a(c, d);
	          wb(a, e);
	          b = wb(a, d);

	          for (e = 0; e < f.length; e += 2) {
	            var g = f[e],
	                h = f[e + 1];
	            "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
	          }

	          switch (a) {
	            case "input":
	              ab(c, d);
	              break;

	            case "textarea":
	              ib(c, d);
	              break;

	            case "select":
	              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, !1) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, !0) : fb(c, !!d.multiple, d.multiple ? [] : "", !1));
	          }
	        }
	      }

	      return;

	    case 6:
	      if (null === b.stateNode) throw Error(y(162));
	      b.stateNode.nodeValue = b.memoizedProps;
	      return;

	    case 3:
	      c = b.stateNode;
	      c.hydrate && (c.hydrate = !1, Cc(c.containerInfo));
	      return;

	    case 12:
	      return;

	    case 13:
	      null !== b.memoizedState && (jj = O(), aj(b.child, !0));
	      kj(b);
	      return;

	    case 19:
	      kj(b);
	      return;

	    case 17:
	      return;

	    case 23:
	    case 24:
	      aj(b, null !== b.memoizedState);
	      return;
	  }

	  throw Error(y(163));
	}

	function kj(a) {
	  var b = a.updateQueue;

	  if (null !== b) {
	    a.updateQueue = null;
	    var c = a.stateNode;
	    null === c && (c = a.stateNode = new Ui());
	    b.forEach(function (b) {
	      var d = lj.bind(null, a, b);
	      c.has(b) || (c.add(b), b.then(d, d));
	    });
	  }
	}

	function mj(a, b) {
	  return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : !1;
	}

	var nj = Math.ceil,
	    oj = ra.ReactCurrentDispatcher,
	    pj = ra.ReactCurrentOwner,
	    X = 0,
	    U = null,
	    Y = null,
	    W = 0,
	    qj = 0,
	    rj = Bf(0),
	    V = 0,
	    sj = null,
	    tj = 0,
	    Dg = 0,
	    Hi = 0,
	    uj = 0,
	    vj = null,
	    jj = 0,
	    Ji = Infinity;

	function wj() {
	  Ji = O() + 500;
	}

	var Z = null,
	    Qi = !1,
	    Ri = null,
	    Ti = null,
	    xj = !1,
	    yj = null,
	    zj = 90,
	    Aj = [],
	    Bj = [],
	    Cj = null,
	    Dj = 0,
	    Ej = null,
	    Fj = -1,
	    Gj = 0,
	    Hj = 0,
	    Ij = null,
	    Jj = !1;

	function Hg() {
	  return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
	}

	function Ig(a) {
	  a = a.mode;
	  if (0 === (a & 2)) return 1;
	  if (0 === (a & 4)) return 99 === eg() ? 1 : 2;
	  0 === Gj && (Gj = tj);

	  if (0 !== kg.transition) {
	    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
	    a = Gj;
	    var b = 4186112 & ~Hj;
	    b &= -b;
	    0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
	    return b;
	  }

	  a = eg();
	  0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
	  return a;
	}

	function Jg(a, b, c) {
	  if (50 < Dj) throw Dj = 0, Ej = null, Error(y(185));
	  a = Kj(a, b);
	  if (null === a) return null;
	  $c(a, b, c);
	  a === U && (Hi |= b, 4 === V && Ii(a, W));
	  var d = eg();
	  1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c));
	  vj = a;
	}

	function Kj(a, b) {
	  a.lanes |= b;
	  var c = a.alternate;
	  null !== c && (c.lanes |= b);
	  c = a;

	  for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;

	  return 3 === c.tag ? c.stateNode : null;
	}

	function Mj(a, b) {
	  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g;) {
	    var h = 31 - Vc(g),
	        k = 1 << h,
	        l = f[h];

	    if (-1 === l) {
	      if (0 === (k & d) || 0 !== (k & e)) {
	        l = b;
	        Rc(k);
	        var n = F;
	        f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5E3 : -1;
	      }
	    } else l <= b && (a.expiredLanes |= k);

	    g &= ~k;
	  }

	  d = Uc(a, a === U ? W : 0);
	  b = F;
	  if (0 === d) null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);else {
	    if (null !== c) {
	      if (a.callbackPriority === b) return;
	      c !== Zf && Pf(c);
	    }

	    15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
	    a.callbackPriority = b;
	    a.callbackNode = c;
	  }
	}

	function Nj(a) {
	  Fj = -1;
	  Hj = Gj = 0;
	  if (0 !== (X & 48)) throw Error(y(327));
	  var b = a.callbackNode;
	  if (Oj() && a.callbackNode !== b) return null;
	  var c = Uc(a, a === U ? W : 0);
	  if (0 === c) return null;
	  var d = c;
	  var e = X;
	  X |= 16;
	  var f = Pj();
	  if (U !== a || W !== d) wj(), Qj(a, d);

	  do try {
	    Rj();
	    break;
	  } catch (h) {
	    Sj(a, h);
	  } while (1);

	  qg();
	  oj.current = f;
	  X = e;
	  null !== Y ? d = 0 : (U = null, W = 0, d = V);
	  if (0 !== (tj & Hi)) Qj(a, 0);else if (0 !== d) {
	    2 === d && (X |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
	    if (1 === d) throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
	    a.finishedWork = a.current.alternate;
	    a.finishedLanes = c;

	    switch (d) {
	      case 0:
	      case 1:
	        throw Error(y(345));

	      case 2:
	        Uj(a);
	        break;

	      case 3:
	        Ii(a, c);

	        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
	          if (0 !== Uc(a, 0)) break;
	          e = a.suspendedLanes;

	          if ((e & c) !== c) {
	            Hg();
	            a.pingedLanes |= a.suspendedLanes & e;
	            break;
	          }

	          a.timeoutHandle = of(Uj.bind(null, a), d);
	          break;
	        }

	        Uj(a);
	        break;

	      case 4:
	        Ii(a, c);
	        if ((c & 4186112) === c) break;
	        d = a.eventTimes;

	        for (e = -1; 0 < c;) {
	          var g = 31 - Vc(c);
	          f = 1 << g;
	          g = d[g];
	          g > e && (e = g);
	          c &= ~f;
	        }

	        c = e;
	        c = O() - c;
	        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3E3 > c ? 3E3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;

	        if (10 < c) {
	          a.timeoutHandle = of(Uj.bind(null, a), c);
	          break;
	        }

	        Uj(a);
	        break;

	      case 5:
	        Uj(a);
	        break;

	      default:
	        throw Error(y(329));
	    }
	  }
	  Mj(a, O());
	  return a.callbackNode === b ? Nj.bind(null, a) : null;
	}

	function Ii(a, b) {
	  b &= ~uj;
	  b &= ~Hi;
	  a.suspendedLanes |= b;
	  a.pingedLanes &= ~b;

	  for (a = a.expirationTimes; 0 < b;) {
	    var c = 31 - Vc(b),
	        d = 1 << c;
	    a[c] = -1;
	    b &= ~d;
	  }
	}

	function Lj(a) {
	  if (0 !== (X & 48)) throw Error(y(327));
	  Oj();

	  if (a === U && 0 !== (a.expiredLanes & W)) {
	    var b = W;
	    var c = Tj(a, b);
	    0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
	  } else b = Uc(a, 0), c = Tj(a, b);

	  0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
	  if (1 === c) throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
	  a.finishedWork = a.current.alternate;
	  a.finishedLanes = b;
	  Uj(a);
	  Mj(a, O());
	  return null;
	}

	function Vj() {
	  if (null !== Cj) {
	    var a = Cj;
	    Cj = null;
	    a.forEach(function (a) {
	      a.expiredLanes |= 24 & a.pendingLanes;
	      Mj(a, O());
	    });
	  }

	  ig();
	}

	function Wj(a, b) {
	  var c = X;
	  X |= 1;

	  try {
	    return a(b);
	  } finally {
	    X = c, 0 === X && (wj(), ig());
	  }
	}

	function Xj(a, b) {
	  var c = X;
	  X &= -2;
	  X |= 8;

	  try {
	    return a(b);
	  } finally {
	    X = c, 0 === X && (wj(), ig());
	  }
	}

	function ni(a, b) {
	  I(rj, qj);
	  qj |= b;
	  tj |= b;
	}

	function Ki() {
	  qj = rj.current;
	  H(rj);
	}

	function Qj(a, b) {
	  a.finishedWork = null;
	  a.finishedLanes = 0;
	  var c = a.timeoutHandle;
	  -1 !== c && (a.timeoutHandle = -1, pf(c));
	  if (null !== Y) for (c = Y.return; null !== c;) {
	    var d = c;

	    switch (d.tag) {
	      case 1:
	        d = d.type.childContextTypes;
	        null !== d && void 0 !== d && Gf();
	        break;

	      case 3:
	        fh();
	        H(N);
	        H(M);
	        uh();
	        break;

	      case 5:
	        hh(d);
	        break;

	      case 4:
	        fh();
	        break;

	      case 13:
	        H(P);
	        break;

	      case 19:
	        H(P);
	        break;

	      case 10:
	        rg(d);
	        break;

	      case 23:
	      case 24:
	        Ki();
	    }

	    c = c.return;
	  }
	  U = a;
	  Y = Tg(a.current, null);
	  W = qj = tj = b;
	  V = 0;
	  sj = null;
	  uj = Hi = Dg = 0;
	}

	function Sj(a, b) {
	  do {
	    var c = Y;

	    try {
	      qg();
	      vh.current = Gh;

	      if (yh) {
	        for (var d = R.memoizedState; null !== d;) {
	          var e = d.queue;
	          null !== e && (e.pending = null);
	          d = d.next;
	        }

	        yh = !1;
	      }

	      xh = 0;
	      T = S = R = null;
	      zh = !1;
	      pj.current = null;

	      if (null === c || null === c.return) {
	        V = 1;
	        sj = b;
	        Y = null;
	        break;
	      }

	      a: {
	        var f = a,
	            g = c.return,
	            h = c,
	            k = b;
	        b = W;
	        h.flags |= 2048;
	        h.firstEffect = h.lastEffect = null;

	        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
	          var l = k;

	          if (0 === (h.mode & 2)) {
	            var n = h.alternate;
	            n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
	          }

	          var A = 0 !== (P.current & 1),
	              p = g;

	          do {
	            var C;

	            if (C = 13 === p.tag) {
	              var x = p.memoizedState;
	              if (null !== x) C = null !== x.dehydrated ? !0 : !1;else {
	                var w = p.memoizedProps;
	                C = void 0 === w.fallback ? !1 : !0 !== w.unstable_avoidThisFallback ? !0 : A ? !1 : !0;
	              }
	            }

	            if (C) {
	              var z = p.updateQueue;

	              if (null === z) {
	                var u = new Set();
	                u.add(l);
	                p.updateQueue = u;
	              } else z.add(l);

	              if (0 === (p.mode & 2)) {
	                p.flags |= 64;
	                h.flags |= 16384;
	                h.flags &= -2981;
	                if (1 === h.tag) if (null === h.alternate) h.tag = 17;else {
	                  var t = zg(-1, 1);
	                  t.tag = 2;
	                  Ag(h, t);
	                }
	                h.lanes |= 1;
	                break a;
	              }

	              k = void 0;
	              h = b;
	              var q = f.pingCache;
	              null === q ? (q = f.pingCache = new Oi(), k = new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = new Set(), q.set(l, k)));

	              if (!k.has(h)) {
	                k.add(h);
	                var v = Yj.bind(null, f, l, h);
	                l.then(v, v);
	              }

	              p.flags |= 4096;
	              p.lanes = b;
	              break a;
	            }

	            p = p.return;
	          } while (null !== p);

	          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
	        }

	        5 !== V && (V = 2);
	        k = Mi(k, h);
	        p = g;

	        do {
	          switch (p.tag) {
	            case 3:
	              f = k;
	              p.flags |= 4096;
	              b &= -b;
	              p.lanes |= b;
	              var J = Pi(p, f, b);
	              Bg(p, J);
	              break a;

	            case 1:
	              f = k;
	              var K = p.type,
	                  Q = p.stateNode;

	              if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
	                p.flags |= 4096;
	                b &= -b;
	                p.lanes |= b;
	                var L = Si(p, f, b);
	                Bg(p, L);
	                break a;
	              }

	          }

	          p = p.return;
	        } while (null !== p);
	      }

	      Zj(c);
	    } catch (va) {
	      b = va;
	      Y === c && null !== c && (Y = c = c.return);
	      continue;
	    }

	    break;
	  } while (1);
	}

	function Pj() {
	  var a = oj.current;
	  oj.current = Gh;
	  return null === a ? Gh : a;
	}

	function Tj(a, b) {
	  var c = X;
	  X |= 16;
	  var d = Pj();
	  U === a && W === b || Qj(a, b);

	  do try {
	    ak();
	    break;
	  } catch (e) {
	    Sj(a, e);
	  } while (1);

	  qg();
	  X = c;
	  oj.current = d;
	  if (null !== Y) throw Error(y(261));
	  U = null;
	  W = 0;
	  return V;
	}

	function ak() {
	  for (; null !== Y;) bk(Y);
	}

	function Rj() {
	  for (; null !== Y && !Qf();) bk(Y);
	}

	function bk(a) {
	  var b = ck(a.alternate, a, qj);
	  a.memoizedProps = a.pendingProps;
	  null === b ? Zj(a) : Y = b;
	  pj.current = null;
	}

	function Zj(a) {
	  var b = a;

	  do {
	    var c = b.alternate;
	    a = b.return;

	    if (0 === (b.flags & 2048)) {
	      c = Gi(c, b, qj);

	      if (null !== c) {
	        Y = c;
	        return;
	      }

	      c = b;

	      if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
	        for (var d = 0, e = c.child; null !== e;) d |= e.lanes | e.childLanes, e = e.sibling;

	        c.childLanes = d;
	      }

	      null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
	    } else {
	      c = Li(b);

	      if (null !== c) {
	        c.flags &= 2047;
	        Y = c;
	        return;
	      }

	      null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
	    }

	    b = b.sibling;

	    if (null !== b) {
	      Y = b;
	      return;
	    }

	    Y = b = a;
	  } while (null !== b);

	  0 === V && (V = 5);
	}

	function Uj(a) {
	  var b = eg();
	  gg(99, dk.bind(null, a, b));
	  return null;
	}

	function dk(a, b) {
	  do Oj(); while (null !== yj);

	  if (0 !== (X & 48)) throw Error(y(327));
	  var c = a.finishedWork;
	  if (null === c) return null;
	  a.finishedWork = null;
	  a.finishedLanes = 0;
	  if (c === a.current) throw Error(y(177));
	  a.callbackNode = null;
	  var d = c.lanes | c.childLanes,
	      e = d,
	      f = a.pendingLanes & ~e;
	  a.pendingLanes = e;
	  a.suspendedLanes = 0;
	  a.pingedLanes = 0;
	  a.expiredLanes &= e;
	  a.mutableReadLanes &= e;
	  a.entangledLanes &= e;
	  e = a.entanglements;

	  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f;) {
	    var k = 31 - Vc(f),
	        l = 1 << k;
	    e[k] = 0;
	    g[k] = -1;
	    h[k] = -1;
	    f &= ~l;
	  }

	  null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
	  a === U && (Y = U = null, W = 0);
	  1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;

	  if (null !== d) {
	    e = X;
	    X |= 32;
	    pj.current = null;
	    kf = fd;
	    g = Ne();

	    if (Oe(g)) {
	      if ("selectionStart" in g) h = {
	        start: g.selectionStart,
	        end: g.selectionEnd
	      };else a: if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
	        h = l.anchorNode;
	        f = l.anchorOffset;
	        k = l.focusNode;
	        l = l.focusOffset;

	        try {
	          h.nodeType, k.nodeType;
	        } catch (va) {
	          h = null;
	          break a;
	        }

	        var n = 0,
	            A = -1,
	            p = -1,
	            C = 0,
	            x = 0,
	            w = g,
	            z = null;

	        b: for (;;) {
	          for (var u;;) {
	            w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);
	            w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);
	            3 === w.nodeType && (n += w.nodeValue.length);
	            if (null === (u = w.firstChild)) break;
	            z = w;
	            w = u;
	          }

	          for (;;) {
	            if (w === g) break b;
	            z === h && ++C === f && (A = n);
	            z === k && ++x === l && (p = n);
	            if (null !== (u = w.nextSibling)) break;
	            w = z;
	            z = w.parentNode;
	          }

	          w = u;
	        }

	        h = -1 === A || -1 === p ? null : {
	          start: A,
	          end: p
	        };
	      } else h = null;
	      h = h || {
	        start: 0,
	        end: 0
	      };
	    } else h = null;

	    lf = {
	      focusedElem: g,
	      selectionRange: h
	    };
	    fd = !1;
	    Ij = null;
	    Jj = !1;
	    Z = d;

	    do try {
	      ek();
	    } catch (va) {
	      if (null === Z) throw Error(y(330));
	      Wi(Z, va);
	      Z = Z.nextEffect;
	    } while (null !== Z);

	    Ij = null;
	    Z = d;

	    do try {
	      for (g = a; null !== Z;) {
	        var t = Z.flags;
	        t & 16 && pb(Z.stateNode, "");

	        if (t & 128) {
	          var q = Z.alternate;

	          if (null !== q) {
	            var v = q.ref;
	            null !== v && ("function" === typeof v ? v(null) : v.current = null);
	          }
	        }

	        switch (t & 1038) {
	          case 2:
	            fj(Z);
	            Z.flags &= -3;
	            break;

	          case 6:
	            fj(Z);
	            Z.flags &= -3;
	            ij(Z.alternate, Z);
	            break;

	          case 1024:
	            Z.flags &= -1025;
	            break;

	          case 1028:
	            Z.flags &= -1025;
	            ij(Z.alternate, Z);
	            break;

	          case 4:
	            ij(Z.alternate, Z);
	            break;

	          case 8:
	            h = Z;
	            cj(g, h);
	            var J = h.alternate;
	            dj(h);
	            null !== J && dj(J);
	        }

	        Z = Z.nextEffect;
	      }
	    } catch (va) {
	      if (null === Z) throw Error(y(330));
	      Wi(Z, va);
	      Z = Z.nextEffect;
	    } while (null !== Z);

	    v = lf;
	    q = Ne();
	    t = v.focusedElem;
	    g = v.selectionRange;

	    if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
	      null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
	      q = [];

	      for (v = t; v = v.parentNode;) 1 === v.nodeType && q.push({
	        element: v,
	        left: v.scrollLeft,
	        top: v.scrollTop
	      });

	      "function" === typeof t.focus && t.focus();

	      for (t = 0; t < q.length; t++) v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
	    }

	    fd = !!kf;
	    lf = kf = null;
	    a.current = c;
	    Z = d;

	    do try {
	      for (t = a; null !== Z;) {
	        var K = Z.flags;
	        K & 36 && Yi(t, Z.alternate, Z);

	        if (K & 128) {
	          q = void 0;
	          var Q = Z.ref;

	          if (null !== Q) {
	            var L = Z.stateNode;

	            switch (Z.tag) {
	              case 5:
	                q = L;
	                break;

	              default:
	                q = L;
	            }

	            "function" === typeof Q ? Q(q) : Q.current = q;
	          }
	        }

	        Z = Z.nextEffect;
	      }
	    } catch (va) {
	      if (null === Z) throw Error(y(330));
	      Wi(Z, va);
	      Z = Z.nextEffect;
	    } while (null !== Z);

	    Z = null;
	    $f();
	    X = e;
	  } else a.current = c;

	  if (xj) xj = !1, yj = a, zj = b;else for (Z = d; null !== Z;) b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
	  d = a.pendingLanes;
	  0 === d && (Ti = null);
	  1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
	  c = c.stateNode;
	  if (Mf && "function" === typeof Mf.onCommitFiberRoot) try {
	    Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
	  } catch (va) {}
	  Mj(a, O());
	  if (Qi) throw Qi = !1, a = Ri, Ri = null, a;
	  if (0 !== (X & 8)) return null;
	  ig();
	  return null;
	}

	function ek() {
	  for (; null !== Z;) {
	    var a = Z.alternate;
	    Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = !0) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = !0));
	    var b = Z.flags;
	    0 !== (b & 256) && Xi(a, Z);
	    0 === (b & 512) || xj || (xj = !0, hg(97, function () {
	      Oj();
	      return null;
	    }));
	    Z = Z.nextEffect;
	  }
	}

	function Oj() {
	  if (90 !== zj) {
	    var a = 97 < zj ? 97 : zj;
	    zj = 90;
	    return gg(a, fk);
	  }

	  return !1;
	}

	function $i(a, b) {
	  Aj.push(b, a);
	  xj || (xj = !0, hg(97, function () {
	    Oj();
	    return null;
	  }));
	}

	function Zi(a, b) {
	  Bj.push(b, a);
	  xj || (xj = !0, hg(97, function () {
	    Oj();
	    return null;
	  }));
	}

	function fk() {
	  if (null === yj) return !1;
	  var a = yj;
	  yj = null;
	  if (0 !== (X & 48)) throw Error(y(331));
	  var b = X;
	  X |= 32;
	  var c = Bj;
	  Bj = [];

	  for (var d = 0; d < c.length; d += 2) {
	    var e = c[d],
	        f = c[d + 1],
	        g = e.destroy;
	    e.destroy = void 0;
	    if ("function" === typeof g) try {
	      g();
	    } catch (k) {
	      if (null === f) throw Error(y(330));
	      Wi(f, k);
	    }
	  }

	  c = Aj;
	  Aj = [];

	  for (d = 0; d < c.length; d += 2) {
	    e = c[d];
	    f = c[d + 1];

	    try {
	      var h = e.create;
	      e.destroy = h();
	    } catch (k) {
	      if (null === f) throw Error(y(330));
	      Wi(f, k);
	    }
	  }

	  for (h = a.current.firstEffect; null !== h;) a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;

	  X = b;
	  ig();
	  return !0;
	}

	function gk(a, b, c) {
	  b = Mi(c, b);
	  b = Pi(a, b, 1);
	  Ag(a, b);
	  b = Hg();
	  a = Kj(a, 1);
	  null !== a && ($c(a, 1, b), Mj(a, b));
	}

	function Wi(a, b) {
	  if (3 === a.tag) gk(a, a, b);else for (var c = a.return; null !== c;) {
	    if (3 === c.tag) {
	      gk(c, a, b);
	      break;
	    } else if (1 === c.tag) {
	      var d = c.stateNode;

	      if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
	        a = Mi(b, a);
	        var e = Si(c, a, 1);
	        Ag(c, e);
	        e = Hg();
	        c = Kj(c, 1);
	        if (null !== c) $c(c, 1, e), Mj(c, e);else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) try {
	          d.componentDidCatch(b, a);
	        } catch (f) {}
	        break;
	      }
	    }

	    c = c.return;
	  }
	}

	function Yj(a, b, c) {
	  var d = a.pingCache;
	  null !== d && d.delete(b);
	  b = Hg();
	  a.pingedLanes |= a.suspendedLanes & c;
	  U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
	  Mj(a, b);
	}

	function lj(a, b) {
	  var c = a.stateNode;
	  null !== c && c.delete(b);
	  b = 0;
	  0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
	  c = Hg();
	  a = Kj(a, b);
	  null !== a && ($c(a, b, c), Mj(a, c));
	}

	var ck;

	ck = function (a, b, c) {
	  var d = b.lanes;
	  if (null !== a) {
	    if (a.memoizedProps !== b.pendingProps || N.current) ug = !0;else if (0 !== (c & d)) ug = 0 !== (a.flags & 16384) ? !0 : !1;else {
	      ug = !1;

	      switch (b.tag) {
	        case 3:
	          ri(b);
	          sh();
	          break;

	        case 5:
	          gh(b);
	          break;

	        case 1:
	          Ff(b.type) && Jf(b);
	          break;

	        case 4:
	          eh(b, b.stateNode.containerInfo);
	          break;

	        case 10:
	          d = b.memoizedProps.value;
	          var e = b.type._context;
	          I(mg, e._currentValue);
	          e._currentValue = d;
	          break;

	        case 13:
	          if (null !== b.memoizedState) {
	            if (0 !== (c & b.child.childLanes)) return ti(a, b, c);
	            I(P, P.current & 1);
	            b = hi(a, b, c);
	            return null !== b ? b.sibling : null;
	          }

	          I(P, P.current & 1);
	          break;

	        case 19:
	          d = 0 !== (c & b.childLanes);

	          if (0 !== (a.flags & 64)) {
	            if (d) return Ai(a, b, c);
	            b.flags |= 64;
	          }

	          e = b.memoizedState;
	          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
	          I(P, P.current);
	          if (d) break;else return null;

	        case 23:
	        case 24:
	          return b.lanes = 0, mi(a, b, c);
	      }

	      return hi(a, b, c);
	    }
	  } else ug = !1;
	  b.lanes = 0;

	  switch (b.tag) {
	    case 2:
	      d = b.type;
	      null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
	      a = b.pendingProps;
	      e = Ef(b, M.current);
	      tg(b, c);
	      e = Ch(null, b, d, a, e, c);
	      b.flags |= 1;

	      if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
	        b.tag = 1;
	        b.memoizedState = null;
	        b.updateQueue = null;

	        if (Ff(d)) {
	          var f = !0;
	          Jf(b);
	        } else f = !1;

	        b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
	        xg(b);
	        var g = d.getDerivedStateFromProps;
	        "function" === typeof g && Gg(b, d, g, a);
	        e.updater = Kg;
	        b.stateNode = e;
	        e._reactInternals = b;
	        Og(b, d, a, c);
	        b = qi(null, b, d, !0, f, c);
	      } else b.tag = 0, fi(null, b, e, c), b = b.child;

	      return b;

	    case 16:
	      e = b.elementType;

	      a: {
	        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
	        a = b.pendingProps;
	        f = e._init;
	        e = f(e._payload);
	        b.type = e;
	        f = b.tag = hk(e);
	        a = lg(e, a);

	        switch (f) {
	          case 0:
	            b = li(null, b, e, a, c);
	            break a;

	          case 1:
	            b = pi(null, b, e, a, c);
	            break a;

	          case 11:
	            b = gi(null, b, e, a, c);
	            break a;

	          case 14:
	            b = ii(null, b, e, lg(e.type, a), d, c);
	            break a;
	        }

	        throw Error(y(306, e, ""));
	      }

	      return b;

	    case 0:
	      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);

	    case 1:
	      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);

	    case 3:
	      ri(b);
	      d = b.updateQueue;
	      if (null === a || null === d) throw Error(y(282));
	      d = b.pendingProps;
	      e = b.memoizedState;
	      e = null !== e ? e.element : null;
	      yg(a, b);
	      Cg(b, d, null, c);
	      d = b.memoizedState.element;
	      if (d === e) sh(), b = hi(a, b, c);else {
	        e = b.stateNode;
	        if (f = e.hydrate) kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = !0;

	        if (f) {
	          a = e.mutableSourceEagerHydrationData;
	          if (null != a) for (e = 0; e < a.length; e += 2) f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
	          c = Zg(b, null, d, c);

	          for (b.child = c; c;) c.flags = c.flags & -3 | 1024, c = c.sibling;
	        } else fi(a, b, d, c), sh();

	        b = b.child;
	      }
	      return b;

	    case 5:
	      return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;

	    case 6:
	      return null === a && ph(b), null;

	    case 13:
	      return ti(a, b, c);

	    case 4:
	      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;

	    case 11:
	      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);

	    case 7:
	      return fi(a, b, b.pendingProps, c), b.child;

	    case 8:
	      return fi(a, b, b.pendingProps.children, c), b.child;

	    case 12:
	      return fi(a, b, b.pendingProps.children, c), b.child;

	    case 10:
	      a: {
	        d = b.type._context;
	        e = b.pendingProps;
	        g = b.memoizedProps;
	        f = e.value;
	        var h = b.type._context;
	        I(mg, h._currentValue);
	        h._currentValue = f;
	        if (null !== g) if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
	          if (g.children === e.children && !N.current) {
	            b = hi(a, b, c);
	            break a;
	          }
	        } else for (h = b.child, null !== h && (h.return = b); null !== h;) {
	          var k = h.dependencies;

	          if (null !== k) {
	            g = h.child;

	            for (var l = k.firstContext; null !== l;) {
	              if (l.context === d && 0 !== (l.observedBits & f)) {
	                1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
	                h.lanes |= c;
	                l = h.alternate;
	                null !== l && (l.lanes |= c);
	                sg(h.return, c);
	                k.lanes |= c;
	                break;
	              }

	              l = l.next;
	            }
	          } else g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;

	          if (null !== g) g.return = h;else for (g = h; null !== g;) {
	            if (g === b) {
	              g = null;
	              break;
	            }

	            h = g.sibling;

	            if (null !== h) {
	              h.return = g.return;
	              g = h;
	              break;
	            }

	            g = g.return;
	          }
	          h = g;
	        }
	        fi(a, b, e.children, c);
	        b = b.child;
	      }

	      return b;

	    case 9:
	      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;

	    case 14:
	      return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);

	    case 15:
	      return ki(a, b, b.type, b.pendingProps, d, c);

	    case 17:
	      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = !0, Jf(b)) : a = !1, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, !0, a, c);

	    case 19:
	      return Ai(a, b, c);

	    case 23:
	      return mi(a, b, c);

	    case 24:
	      return mi(a, b, c);
	  }

	  throw Error(y(156, b.tag));
	};

	function ik(a, b, c, d) {
	  this.tag = a;
	  this.key = c;
	  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
	  this.index = 0;
	  this.ref = null;
	  this.pendingProps = b;
	  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
	  this.mode = d;
	  this.flags = 0;
	  this.lastEffect = this.firstEffect = this.nextEffect = null;
	  this.childLanes = this.lanes = 0;
	  this.alternate = null;
	}

	function nh(a, b, c, d) {
	  return new ik(a, b, c, d);
	}

	function ji(a) {
	  a = a.prototype;
	  return !(!a || !a.isReactComponent);
	}

	function hk(a) {
	  if ("function" === typeof a) return ji(a) ? 1 : 0;

	  if (void 0 !== a && null !== a) {
	    a = a.$$typeof;
	    if (a === Aa) return 11;
	    if (a === Da) return 14;
	  }

	  return 2;
	}

	function Tg(a, b) {
	  var c = a.alternate;
	  null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
	  c.childLanes = a.childLanes;
	  c.lanes = a.lanes;
	  c.child = a.child;
	  c.memoizedProps = a.memoizedProps;
	  c.memoizedState = a.memoizedState;
	  c.updateQueue = a.updateQueue;
	  b = a.dependencies;
	  c.dependencies = null === b ? null : {
	    lanes: b.lanes,
	    firstContext: b.firstContext
	  };
	  c.sibling = a.sibling;
	  c.index = a.index;
	  c.ref = a.ref;
	  return c;
	}

	function Vg(a, b, c, d, e, f) {
	  var g = 2;
	  d = a;
	  if ("function" === typeof a) ji(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
	    case ua:
	      return Xg(c.children, e, f, b);

	    case Ha:
	      g = 8;
	      e |= 16;
	      break;

	    case wa:
	      g = 8;
	      e |= 1;
	      break;

	    case xa:
	      return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;

	    case Ba:
	      return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;

	    case Ca:
	      return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;

	    case Ia:
	      return vi(c, e, f, b);

	    case Ja:
	      return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;

	    default:
	      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
	        case ya:
	          g = 10;
	          break a;

	        case za:
	          g = 9;
	          break a;

	        case Aa:
	          g = 11;
	          break a;

	        case Da:
	          g = 14;
	          break a;

	        case Ea:
	          g = 16;
	          d = null;
	          break a;

	        case Fa:
	          g = 22;
	          break a;
	      }
	      throw Error(y(130, null == a ? a : typeof a, ""));
	  }
	  b = nh(g, c, b, e);
	  b.elementType = a;
	  b.type = d;
	  b.lanes = f;
	  return b;
	}

	function Xg(a, b, c, d) {
	  a = nh(7, a, d, b);
	  a.lanes = c;
	  return a;
	}

	function vi(a, b, c, d) {
	  a = nh(23, a, d, b);
	  a.elementType = Ia;
	  a.lanes = c;
	  return a;
	}

	function Ug(a, b, c) {
	  a = nh(6, a, null, b);
	  a.lanes = c;
	  return a;
	}

	function Wg(a, b, c) {
	  b = nh(4, null !== a.children ? a.children : [], a.key, b);
	  b.lanes = c;
	  b.stateNode = {
	    containerInfo: a.containerInfo,
	    pendingChildren: null,
	    implementation: a.implementation
	  };
	  return b;
	}

	function jk(a, b, c) {
	  this.tag = b;
	  this.containerInfo = a;
	  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
	  this.timeoutHandle = -1;
	  this.pendingContext = this.context = null;
	  this.hydrate = c;
	  this.callbackNode = null;
	  this.callbackPriority = 0;
	  this.eventTimes = Zc(0);
	  this.expirationTimes = Zc(-1);
	  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
	  this.entanglements = Zc(0);
	  this.mutableSourceEagerHydrationData = null;
	}

	function kk(a, b, c) {
	  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
	  return {
	    $$typeof: ta,
	    key: null == d ? null : "" + d,
	    children: a,
	    containerInfo: b,
	    implementation: c
	  };
	}

	function lk(a, b, c, d) {
	  var e = b.current,
	      f = Hg(),
	      g = Ig(e);

	  a: if (c) {
	    c = c._reactInternals;

	    b: {
	      if (Zb(c) !== c || 1 !== c.tag) throw Error(y(170));
	      var h = c;

	      do {
	        switch (h.tag) {
	          case 3:
	            h = h.stateNode.context;
	            break b;

	          case 1:
	            if (Ff(h.type)) {
	              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
	              break b;
	            }

	        }

	        h = h.return;
	      } while (null !== h);

	      throw Error(y(171));
	    }

	    if (1 === c.tag) {
	      var k = c.type;

	      if (Ff(k)) {
	        c = If(c, k, h);
	        break a;
	      }
	    }

	    c = h;
	  } else c = Cf;

	  null === b.context ? b.context = c : b.pendingContext = c;
	  b = zg(f, g);
	  b.payload = {
	    element: a
	  };
	  d = void 0 === d ? null : d;
	  null !== d && (b.callback = d);
	  Ag(e, b);
	  Jg(e, g, f);
	  return g;
	}

	function mk(a) {
	  a = a.current;
	  if (!a.child) return null;

	  switch (a.child.tag) {
	    case 5:
	      return a.child.stateNode;

	    default:
	      return a.child.stateNode;
	  }
	}

	function nk(a, b) {
	  a = a.memoizedState;

	  if (null !== a && null !== a.dehydrated) {
	    var c = a.retryLane;
	    a.retryLane = 0 !== c && c < b ? c : b;
	  }
	}

	function ok(a, b) {
	  nk(a, b);
	  (a = a.alternate) && nk(a, b);
	}

	function pk() {
	  return null;
	}

	function qk(a, b, c) {
	  var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
	  c = new jk(a, b, null != c && !0 === c.hydrate);
	  b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
	  c.current = b;
	  b.stateNode = c;
	  xg(b);
	  a[ff] = c.current;
	  cf(8 === a.nodeType ? a.parentNode : a);
	  if (d) for (a = 0; a < d.length; a++) {
	    b = d[a];
	    var e = b._getVersion;
	    e = e(b._source);
	    null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
	  }
	  this._internalRoot = c;
	}

	qk.prototype.render = function (a) {
	  lk(a, this._internalRoot, null, null);
	};

	qk.prototype.unmount = function () {
	  var a = this._internalRoot,
	      b = a.containerInfo;
	  lk(null, a, null, function () {
	    b[ff] = null;
	  });
	};

	function rk(a) {
	  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
	}

	function sk(a, b) {
	  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
	  if (!b) for (var c; c = a.lastChild;) a.removeChild(c);
	  return new qk(a, 0, b ? {
	    hydrate: !0
	  } : void 0);
	}

	function tk(a, b, c, d, e) {
	  var f = c._reactRootContainer;

	  if (f) {
	    var g = f._internalRoot;

	    if ("function" === typeof e) {
	      var h = e;

	      e = function () {
	        var a = mk(g);
	        h.call(a);
	      };
	    }

	    lk(b, g, a, e);
	  } else {
	    f = c._reactRootContainer = sk(c, d);
	    g = f._internalRoot;

	    if ("function" === typeof e) {
	      var k = e;

	      e = function () {
	        var a = mk(g);
	        k.call(a);
	      };
	    }

	    Xj(function () {
	      lk(b, g, a, e);
	    });
	  }

	  return mk(g);
	}

	ec = function (a) {
	  if (13 === a.tag) {
	    var b = Hg();
	    Jg(a, 4, b);
	    ok(a, 4);
	  }
	};

	fc = function (a) {
	  if (13 === a.tag) {
	    var b = Hg();
	    Jg(a, 67108864, b);
	    ok(a, 67108864);
	  }
	};

	gc = function (a) {
	  if (13 === a.tag) {
	    var b = Hg(),
	        c = Ig(a);
	    Jg(a, c, b);
	    ok(a, c);
	  }
	};

	hc = function (a, b) {
	  return b();
	};

	yb = function (a, b, c) {
	  switch (b) {
	    case "input":
	      ab(a, c);
	      b = c.name;

	      if ("radio" === c.type && null != b) {
	        for (c = a; c.parentNode;) c = c.parentNode;

	        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');

	        for (b = 0; b < c.length; b++) {
	          var d = c[b];

	          if (d !== a && d.form === a.form) {
	            var e = Db(d);
	            if (!e) throw Error(y(90));
	            Wa(d);
	            ab(d, e);
	          }
	        }
	      }

	      break;

	    case "textarea":
	      ib(a, c);
	      break;

	    case "select":
	      b = c.value, null != b && fb(a, !!c.multiple, b, !1);
	  }
	};

	Gb = Wj;

	Hb = function (a, b, c, d, e) {
	  var f = X;
	  X |= 4;

	  try {
	    return gg(98, a.bind(null, b, c, d, e));
	  } finally {
	    X = f, 0 === X && (wj(), ig());
	  }
	};

	Ib = function () {
	  0 === (X & 49) && (Vj(), Oj());
	};

	Jb = function (a, b) {
	  var c = X;
	  X |= 2;

	  try {
	    return a(b);
	  } finally {
	    X = c, 0 === X && (wj(), ig());
	  }
	};

	function uk(a, b) {
	  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
	  if (!rk(b)) throw Error(y(200));
	  return kk(a, b, null, c);
	}

	var vk = {
	  Events: [Cb, ue, Db, Eb, Fb, Oj, {
	    current: !1
	  }]
	},
	    wk = {
	  findFiberByHostInstance: wc,
	  bundleType: 0,
	  version: "17.0.2",
	  rendererPackageName: "react-dom"
	};
	var xk = {
	  bundleType: wk.bundleType,
	  version: wk.version,
	  rendererPackageName: wk.rendererPackageName,
	  rendererConfig: wk.rendererConfig,
	  overrideHookState: null,
	  overrideHookStateDeletePath: null,
	  overrideHookStateRenamePath: null,
	  overrideProps: null,
	  overridePropsDeletePath: null,
	  overridePropsRenamePath: null,
	  setSuspenseHandler: null,
	  scheduleUpdate: null,
	  currentDispatcherRef: ra.ReactCurrentDispatcher,
	  findHostInstanceByFiber: function (a) {
	    a = cc(a);
	    return null === a ? null : a.stateNode;
	  },
	  findFiberByHostInstance: wk.findFiberByHostInstance || pk,
	  findHostInstancesForRefresh: null,
	  scheduleRefresh: null,
	  scheduleRoot: null,
	  setRefreshHandler: null,
	  getCurrentFiber: null
	};

	if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
	  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
	  if (!yk.isDisabled && yk.supportsFiber) try {
	    Lf = yk.inject(xk), Mf = yk;
	  } catch (a) {}
	}

	var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
	var createPortal = uk;

	var findDOMNode = function (a) {
	  if (null == a) return null;
	  if (1 === a.nodeType) return a;
	  var b = a._reactInternals;

	  if (void 0 === b) {
	    if ("function" === typeof a.render) throw Error(y(188));
	    throw Error(y(268, Object.keys(a)));
	  }

	  a = cc(b);
	  a = null === a ? null : a.stateNode;
	  return a;
	};

	var flushSync = function (a, b) {
	  var c = X;
	  if (0 !== (c & 48)) return a(b);
	  X |= 1;

	  try {
	    if (a) return gg(99, a.bind(null, b));
	  } finally {
	    X = c, ig();
	  }
	};

	var hydrate = function (a, b, c) {
	  if (!rk(b)) throw Error(y(200));
	  return tk(null, a, b, !0, c);
	};

	var render$1 = function (a, b, c) {
	  if (!rk(b)) throw Error(y(200));
	  return tk(null, a, b, !1, c);
	};

	var unmountComponentAtNode = function (a) {
	  if (!rk(a)) throw Error(y(40));
	  return a._reactRootContainer ? (Xj(function () {
	    tk(null, null, a, !1, function () {
	      a._reactRootContainer = null;
	      a[ff] = null;
	    });
	  }), !0) : !1;
	};

	var unstable_batchedUpdates = Wj;

	var unstable_createPortal = function (a, b) {
	  return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
	};

	var unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
	  if (!rk(c)) throw Error(y(200));
	  if (null == a || void 0 === a._reactInternals) throw Error(y(38));
	  return tk(a, b, c, !1, d);
	};

	var version = "17.0.2";
	var reactDom_production_min = {
	  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
	  createPortal: createPortal,
	  findDOMNode: findDOMNode,
	  flushSync: flushSync,
	  hydrate: hydrate,
	  render: render$1,
	  unmountComponentAtNode: unmountComponentAtNode,
	  unstable_batchedUpdates: unstable_batchedUpdates,
	  unstable_createPortal: unstable_createPortal,
	  unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,
	  version: version
	};

	/** @license React v0.20.2
	 * scheduler-tracing.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var b = 0;
	var __interactionsRef = null;
	var __subscriberRef = null;

	var unstable_clear = function (a) {
	  return a();
	};

	var unstable_getCurrent = function () {
	  return null;
	};

	var unstable_getThreadID = function () {
	  return ++b;
	};

	var unstable_subscribe = function () {};

	var unstable_trace = function (a, d, c) {
	  return c();
	};

	var unstable_unsubscribe = function () {};

	var unstable_wrap = function (a) {
	  return a;
	};

	var schedulerTracing_production_min = {
	  __interactionsRef: __interactionsRef,
	  __subscriberRef: __subscriberRef,
	  unstable_clear: unstable_clear,
	  unstable_getCurrent: unstable_getCurrent,
	  unstable_getThreadID: unstable_getThreadID,
	  unstable_subscribe: unstable_subscribe,
	  unstable_trace: unstable_trace,
	  unstable_unsubscribe: unstable_unsubscribe,
	  unstable_wrap: unstable_wrap
	};

	createCommonjsModule(function (module, exports) {
	});

	createCommonjsModule(function (module) {

	  {
	    module.exports = schedulerTracing_production_min;
	  }
	});

	createCommonjsModule(function (module, exports) {
	});

	var reactDom = createCommonjsModule(function (module) {

	  function checkDCE() {
	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
	      return;
	    }

	    try {
	      // Verify that the code above has been dead code eliminated (DCE'd).
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	    } catch (err) {
	      // DevTools shouldn't crash React, no matter what.
	      // We should still report in case we break this code.
	      console.error(err);
	    }
	  }

	  {
	    // DCE check should happen before ReactDOM bundle executes so that
	    // DevTools can report bad minification during injection.
	    checkDCE();
	    module.exports = reactDom_production_min;
	  }
	});

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	/* global Reflect, Promise */
	var extendStatics$2 = function (d, b) {
	  extendStatics$2 = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	  };

	  return extendStatics$2(d, b);
	};

	function __extends$2(d, b) {
	  extendStatics$2(d, b);

	  function __() {
	    this.constructor = d;
	  }

	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	var __assign$4 = function () {
	  __assign$4 = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$4.apply(this, arguments);
	};
	function __read$5(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread$5() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$5(arguments[i]));

	  return ar;
	}

	/**
	 * TODO(v7): Remove this enum and replace with SeverityLevel
	 */
	var Severity;

	(function (Severity) {
	  /** JSDoc */
	  Severity["Fatal"] = "fatal";
	  /** JSDoc */

	  Severity["Error"] = "error";
	  /** JSDoc */

	  Severity["Warning"] = "warning";
	  /** JSDoc */

	  Severity["Log"] = "log";
	  /** JSDoc */

	  Severity["Info"] = "info";
	  /** JSDoc */

	  Severity["Debug"] = "debug";
	  /** JSDoc */

	  Severity["Critical"] = "critical";
	})(Severity || (Severity = {})); // TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	function __read$4(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread$4() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$4(arguments[i]));

	  return ar;
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	var __assign$3 = function () {
	  __assign$3 = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$3.apply(this, arguments);
	};
	function __read$3(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread$3() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$3(arguments[i]));

	  return ar;
	}

	/**
	 * Consumes the promise and logs the error when it rejects.
	 * @param promise A promise to forget.
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function forget(promise) {
	  void promise.then(null, function (e) {
	    // TODO: Use a better logging mechanism
	    // eslint-disable-next-line no-console
	    console.error(e);
	  });
	}

	/*
	 * This module exists for optimizations in the build process through rollup and terser.  We define some global
	 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
	 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
	 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
	 * `logger` and preventing node-related code from appearing in browser bundles.
	 *
	 * Attention:
	 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
	 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
	 * having issues tree-shaking these constants across package boundaries.
	 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
	 * users to be able to shake away expressions that it guards.
	 */

	/**
	 * Figures out if we're building a browser bundle.
	 *
	 * @returns true if this is a browser bundle build.
	 */
	function isBrowserBundle() {
	  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
	}

	/**
	 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
	 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
	 */
	/**
	 * Checks whether we're in the Node.js or Browser environment
	 *
	 * @returns Answer to given question
	 */

	function isNodeEnv() {
	  // explicitly check for browser bundles as those can be optimized statically
	  // by terser/rollup.
	  return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
	}
	/**
	 * Requires a module which is protected against bundler minification.
	 *
	 * @param request The module path to resolve
	 */
	// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

	function dynamicRequire(mod, request) {
	  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	  return mod.require(request);
	}

	/**
	 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
	 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
	 */
	var fallbackGlobalObject = {};
	/**
	 * Safely get global scope object
	 *
	 * @returns Global scope object
	 */

	function getGlobalObject() {
	  return isNodeEnv() ? global : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
	  ? window // eslint-disable-line no-restricted-globals
	  : typeof self !== 'undefined' ? self : fallbackGlobalObject;
	}
	/**
	 * Returns a global singleton contained in the global `__SENTRY__` object.
	 *
	 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
	 * function and added to the `__SENTRY__` object.
	 *
	 * @param name name of the global singleton on __SENTRY__
	 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
	 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
	 * @returns the singleton
	 */

	function getGlobalSingleton(name, creator, obj) {
	  var global = obj || getGlobalObject();

	  var __SENTRY__ = global.__SENTRY__ = global.__SENTRY__ || {};

	  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
	  return singleton;
	}

	/* eslint-disable @typescript-eslint/no-explicit-any */

	/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
	// eslint-disable-next-line @typescript-eslint/unbound-method
	var objectToString = Object.prototype.toString;
	/**
	 * Checks whether given value's type is one of a few Error or Error-like
	 * {@link isError}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isError(wat) {
	  switch (objectToString.call(wat)) {
	    case '[object Error]':
	    case '[object Exception]':
	    case '[object DOMException]':
	      return true;

	    default:
	      return isInstanceOf(wat, Error);
	  }
	}

	function isBuiltin(wat, ty) {
	  return objectToString.call(wat) === "[object " + ty + "]";
	}
	/**
	 * Checks whether given value's type is ErrorEvent
	 * {@link isErrorEvent}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */


	function isErrorEvent(wat) {
	  return isBuiltin(wat, 'ErrorEvent');
	}
	/**
	 * Checks whether given value's type is DOMError
	 * {@link isDOMError}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isDOMError(wat) {
	  return isBuiltin(wat, 'DOMError');
	}
	/**
	 * Checks whether given value's type is DOMException
	 * {@link isDOMException}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isDOMException(wat) {
	  return isBuiltin(wat, 'DOMException');
	}
	/**
	 * Checks whether given value's type is a string
	 * {@link isString}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isString(wat) {
	  return isBuiltin(wat, 'String');
	}
	/**
	 * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
	 * {@link isPrimitive}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isPrimitive(wat) {
	  return wat === null || typeof wat !== 'object' && typeof wat !== 'function';
	}
	/**
	 * Checks whether given value's type is an object literal
	 * {@link isPlainObject}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isPlainObject(wat) {
	  return isBuiltin(wat, 'Object');
	}
	/**
	 * Checks whether given value's type is an Event instance
	 * {@link isEvent}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isEvent(wat) {
	  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
	}
	/**
	 * Checks whether given value's type is an Element instance
	 * {@link isElement}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isElement(wat) {
	  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
	}
	/**
	 * Checks whether given value's type is an regexp
	 * {@link isRegExp}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isRegExp(wat) {
	  return isBuiltin(wat, 'RegExp');
	}
	/**
	 * Checks whether given value has a then function.
	 * @param wat A value to be checked.
	 */

	function isThenable(wat) {
	  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	  return Boolean(wat && wat.then && typeof wat.then === 'function');
	}
	/**
	 * Checks whether given value's type is a SyntheticEvent
	 * {@link isSyntheticEvent}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isSyntheticEvent(wat) {
	  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
	}
	/**
	 * Checks whether given value is NaN
	 * {@link isNaN}.
	 *
	 * @param wat A value to be checked.
	 * @returns A boolean representing the result.
	 */

	function isNaN$1(wat) {
	  return typeof wat === 'number' && wat !== wat;
	}
	/**
	 * Checks whether given value's type is an instance of provided constructor.
	 * {@link isInstanceOf}.
	 *
	 * @param wat A value to be checked.
	 * @param base A constructor to be used in a check.
	 * @returns A boolean representing the result.
	 */

	function isInstanceOf(wat, base) {
	  try {
	    return wat instanceof base;
	  } catch (_e) {
	    return false;
	  }
	}

	/**
	 * Given a child DOM element, returns a query-selector statement describing that
	 * and its ancestors
	 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
	 * @returns generated DOM path
	 */

	function htmlTreeAsString(elem, keyAttrs) {
	  // try/catch both:
	  // - accessing event.target (see getsentry/raven-js#838, #768)
	  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
	  // - can throw an exception in some circumstances.
	  try {
	    var currentElem = elem;
	    var MAX_TRAVERSE_HEIGHT = 5;
	    var MAX_OUTPUT_LEN = 80;
	    var out = [];
	    var height = 0;
	    var len = 0;
	    var separator = ' > ';
	    var sepLength = separator.length;
	    var nextStr = void 0; // eslint-disable-next-line no-plusplus

	    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
	      nextStr = _htmlElementAsString(currentElem, keyAttrs); // bail out if
	      // - nextStr is the 'html' element
	      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
	      //   (ignore this limit if we are on the first iteration)

	      if (nextStr === 'html' || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
	        break;
	      }

	      out.push(nextStr);
	      len += nextStr.length;
	      currentElem = currentElem.parentNode;
	    }

	    return out.reverse().join(separator);
	  } catch (_oO) {
	    return '<unknown>';
	  }
	}
	/**
	 * Returns a simple, query-selector representation of a DOM element
	 * e.g. [HTMLElement] => input#foo.btn[name=baz]
	 * @returns generated DOM path
	 */

	function _htmlElementAsString(el, keyAttrs) {
	  var elem = el;
	  var out = [];
	  var className;
	  var classes;
	  var key;
	  var attr;
	  var i;

	  if (!elem || !elem.tagName) {
	    return '';
	  }

	  out.push(elem.tagName.toLowerCase()); // Pairs of attribute keys defined in `serializeAttribute` and their values on element.

	  var keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter(function (keyAttr) {
	    return elem.getAttribute(keyAttr);
	  }).map(function (keyAttr) {
	    return [keyAttr, elem.getAttribute(keyAttr)];
	  }) : null;

	  if (keyAttrPairs && keyAttrPairs.length) {
	    keyAttrPairs.forEach(function (keyAttrPair) {
	      out.push("[" + keyAttrPair[0] + "=\"" + keyAttrPair[1] + "\"]");
	    });
	  } else {
	    if (elem.id) {
	      out.push("#" + elem.id);
	    } // eslint-disable-next-line prefer-const


	    className = elem.className;

	    if (className && isString(className)) {
	      classes = className.split(/\s+/);

	      for (i = 0; i < classes.length; i++) {
	        out.push("." + classes[i]);
	      }
	    }
	  }

	  var allowedAttrs = ['type', 'name', 'title', 'alt'];

	  for (i = 0; i < allowedAttrs.length; i++) {
	    key = allowedAttrs[i];
	    attr = elem.getAttribute(key);

	    if (attr) {
	      out.push("[" + key + "=\"" + attr + "\"]");
	    }
	  }

	  return out.join('');
	}
	/**
	 * A safe form of location.href
	 */


	function getLocationHref() {
	  var global = getGlobalObject();

	  try {
	    return global.document.location.href;
	  } catch (oO) {
	    return '';
	  }
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	/* global Reflect, Promise */
	var extendStatics$1 = function (d, b) {
	  extendStatics$1 = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	  };

	  return extendStatics$1(d, b);
	};

	function __extends$1(d, b) {
	  extendStatics$1(d, b);

	  function __() {
	    this.constructor = d;
	  }

	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	var __assign$2 = function () {
	  __assign$2 = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$2.apply(this, arguments);
	};
	function __values$2(o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	      m = s && o[s],
	      i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function () {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	function __read$2(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread$2() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$2(arguments[i]));

	  return ar;
	}

	var setPrototypeOf = Object.setPrototypeOf || ({
	  __proto__: []
	} instanceof Array ? setProtoOf : mixinProperties);
	/**
	 * setPrototypeOf polyfill using __proto__
	 */
	// eslint-disable-next-line @typescript-eslint/ban-types

	function setProtoOf(obj, proto) {
	  // @ts-ignore __proto__ does not exist on obj
	  obj.__proto__ = proto;
	  return obj;
	}
	/**
	 * setPrototypeOf polyfill using mixin
	 */
	// eslint-disable-next-line @typescript-eslint/ban-types


	function mixinProperties(obj, proto) {
	  for (var prop in proto) {
	    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
	      // @ts-ignore typescript complains about indexing so we remove
	      obj[prop] = proto[prop];
	    }
	  }

	  return obj;
	}

	/** An error emitted by Sentry SDKs and related utilities. */

	var SentryError =
	/** @class */
	function (_super) {
	  __extends$1(SentryError, _super);

	  function SentryError(message) {
	    var _newTarget = this.constructor;

	    var _this = _super.call(this, message) || this;

	    _this.message = message;
	    _this.name = _newTarget.prototype.constructor.name;
	    setPrototypeOf(_this, _newTarget.prototype);
	    return _this;
	  }

	  return SentryError;
	}(Error);

	/*
	 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
	 * for users.
	 *
	 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
	 * because some build tools have trouble tree-shaking imported guards.
	 *
	 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
	 *
	 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
	 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
	 * replaced.
	 */

	/** Flag that is true for debug builds, false otherwise. */
	var IS_DEBUG_BUILD$4 = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

	/** Regular expression used to parse a Dsn. */

	var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;

	function isValidProtocol(protocol) {
	  return protocol === 'http' || protocol === 'https';
	}
	/**
	 * Renders the string representation of this Dsn.
	 *
	 * By default, this will render the public representation without the password
	 * component. To get the deprecated private representation, set `withPassword`
	 * to true.
	 *
	 * @param withPassword When set to true, the password will be included.
	 */


	function dsnToString(dsn, withPassword) {
	  if (withPassword === void 0) {
	    withPassword = false;
	  }

	  var host = dsn.host,
	      path = dsn.path,
	      pass = dsn.pass,
	      port = dsn.port,
	      projectId = dsn.projectId,
	      protocol = dsn.protocol,
	      publicKey = dsn.publicKey;
	  return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : '') + ("@" + host + (port ? ":" + port : '') + "/" + (path ? path + "/" : path) + projectId);
	}

	function dsnFromString(str) {
	  var match = DSN_REGEX.exec(str);

	  if (!match) {
	    throw new SentryError("Invalid Sentry Dsn: " + str);
	  }

	  var _a = __read$2(match.slice(1), 6),
	      protocol = _a[0],
	      publicKey = _a[1],
	      _b = _a[2],
	      pass = _b === void 0 ? '' : _b,
	      host = _a[3],
	      _c = _a[4],
	      port = _c === void 0 ? '' : _c,
	      lastPath = _a[5];

	  var path = '';
	  var projectId = lastPath;
	  var split = projectId.split('/');

	  if (split.length > 1) {
	    path = split.slice(0, -1).join('/');
	    projectId = split.pop();
	  }

	  if (projectId) {
	    var projectMatch = projectId.match(/^\d+/);

	    if (projectMatch) {
	      projectId = projectMatch[0];
	    }
	  }

	  return dsnFromComponents({
	    host: host,
	    pass: pass,
	    path: path,
	    projectId: projectId,
	    port: port,
	    protocol: protocol,
	    publicKey: publicKey
	  });
	}

	function dsnFromComponents(components) {
	  // TODO this is for backwards compatibility, and can be removed in a future version
	  if ('user' in components && !('publicKey' in components)) {
	    components.publicKey = components.user;
	  }

	  return {
	    user: components.publicKey || '',
	    protocol: components.protocol,
	    publicKey: components.publicKey || '',
	    pass: components.pass || '',
	    host: components.host,
	    port: components.port || '',
	    path: components.path || '',
	    projectId: components.projectId
	  };
	}

	function validateDsn(dsn) {
	  if (!IS_DEBUG_BUILD$4) {
	    return;
	  }

	  var port = dsn.port,
	      projectId = dsn.projectId,
	      protocol = dsn.protocol;
	  var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
	  requiredComponents.forEach(function (component) {
	    if (!dsn[component]) {
	      throw new SentryError("Invalid Sentry Dsn: " + component + " missing");
	    }
	  });

	  if (!projectId.match(/^\d+$/)) {
	    throw new SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
	  }

	  if (!isValidProtocol(protocol)) {
	    throw new SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
	  }

	  if (port && isNaN(parseInt(port, 10))) {
	    throw new SentryError("Invalid Sentry Dsn: Invalid port " + port);
	  }

	  return true;
	}
	/** The Sentry Dsn, identifying a Sentry instance and project. */


	function makeDsn(from) {
	  var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
	  validateDsn(components);
	  return components;
	}

	var SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];

	var global$a = getGlobalObject();
	/** Prefix for logging strings */

	var PREFIX = 'Sentry Logger ';
	var CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
	/**
	 * Temporarily disable sentry console instrumentations.
	 *
	 * @param callback The function to run against the original `console` messages
	 * @returns The results of the callback
	 */

	function consoleSandbox(callback) {
	  var global = getGlobalObject();

	  if (!('console' in global)) {
	    return callback();
	  }

	  var originalConsole = global.console;
	  var wrappedLevels = {}; // Restore all wrapped console methods

	  CONSOLE_LEVELS.forEach(function (level) {
	    // TODO(v7): Remove this check as it's only needed for Node 6
	    var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;

	    if (level in global.console && originalWrappedFunc) {
	      wrappedLevels[level] = originalConsole[level];
	      originalConsole[level] = originalWrappedFunc;
	    }
	  });

	  try {
	    return callback();
	  } finally {
	    // Revert restoration to wrapped state
	    Object.keys(wrappedLevels).forEach(function (level) {
	      originalConsole[level] = wrappedLevels[level];
	    });
	  }
	}

	function makeLogger() {
	  var enabled = false;
	  var logger = {
	    enable: function () {
	      enabled = true;
	    },
	    disable: function () {
	      enabled = false;
	    }
	  };

	  if (IS_DEBUG_BUILD$4) {
	    CONSOLE_LEVELS.forEach(function (name) {
	      // eslint-disable-next-line @typescript-eslint/no-explicit-any
	      logger[name] = function () {
	        var args = [];

	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }

	        if (enabled) {
	          consoleSandbox(function () {
	            var _a;

	            (_a = global$a.console)[name].apply(_a, __spread$2([PREFIX + "[" + name + "]:"], args));
	          });
	        }
	      };
	    });
	  } else {
	    CONSOLE_LEVELS.forEach(function (name) {
	      logger[name] = function () {
	        return undefined;
	      };
	    });
	  }

	  return logger;
	} // Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used


	var logger;

	if (IS_DEBUG_BUILD$4) {
	  logger = getGlobalSingleton('logger', makeLogger);
	} else {
	  logger = makeLogger();
	}

	/**
	 * Truncates given string to the maximum characters count
	 *
	 * @param str An object that contains serializable values
	 * @param max Maximum number of characters in truncated string (0 = unlimited)
	 * @returns string Encoded
	 */

	function truncate(str, max) {
	  if (max === void 0) {
	    max = 0;
	  }

	  if (typeof str !== 'string' || max === 0) {
	    return str;
	  }

	  return str.length <= max ? str : str.substr(0, max) + "...";
	}
	/**
	 * Join values in array
	 * @param input array of values to be joined together
	 * @param delimiter string to be placed in-between values
	 * @returns Joined values
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any

	function safeJoin(input, delimiter) {
	  if (!Array.isArray(input)) {
	    return '';
	  }

	  var output = []; // eslint-disable-next-line @typescript-eslint/prefer-for-of

	  for (var i = 0; i < input.length; i++) {
	    var value = input[i];

	    try {
	      output.push(String(value));
	    } catch (e) {
	      output.push('[value cannot be serialized]');
	    }
	  }

	  return output.join(delimiter);
	}
	/**
	 * Checks if the value matches a regex or includes the string
	 * @param value The string value to be checked against
	 * @param pattern Either a regex or a string that must be contained in value
	 */

	function isMatchingPattern(value, pattern) {
	  if (!isString(value)) {
	    return false;
	  }

	  if (isRegExp(pattern)) {
	    return pattern.test(value);
	  }

	  if (typeof pattern === 'string') {
	    return value.indexOf(pattern) !== -1;
	  }

	  return false;
	}

	/**
	 * Replace a method in an object with a wrapped version of itself.
	 *
	 * @param source An object that contains a method to be wrapped.
	 * @param name The name of the method to be wrapped.
	 * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
	 * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
	 * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
	 * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
	 * @returns void
	 */

	function fill(source, name, replacementFactory) {
	  if (!(name in source)) {
	    return;
	  }

	  var original = source[name];
	  var wrapped = replacementFactory(original); // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
	  // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"

	  if (typeof wrapped === 'function') {
	    try {
	      markFunctionWrapped(wrapped, original);
	    } catch (_Oo) {// This can throw if multiple fill happens on a global object like XMLHttpRequest
	      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
	    }
	  }

	  source[name] = wrapped;
	}
	/**
	 * Defines a non-enumerable property on the given object.
	 *
	 * @param obj The object on which to set the property
	 * @param name The name of the property to be set
	 * @param value The value to which to set the property
	 */

	function addNonEnumerableProperty(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
	    value: value,
	    writable: true,
	    configurable: true
	  });
	}
	/**
	 * Remembers the original function on the wrapped function and
	 * patches up the prototype.
	 *
	 * @param wrapped the wrapper function
	 * @param original the original function that gets wrapped
	 */

	function markFunctionWrapped(wrapped, original) {
	  var proto = original.prototype || {};
	  wrapped.prototype = original.prototype = proto;
	  addNonEnumerableProperty(wrapped, '__sentry_original__', original);
	}
	/**
	 * This extracts the original function if available.  See
	 * `markFunctionWrapped` for more information.
	 *
	 * @param func the function to unwrap
	 * @returns the unwrapped version of the function if available.
	 */

	function getOriginalFunction(func) {
	  return func.__sentry_original__;
	}
	/**
	 * Encodes given object into url-friendly format
	 *
	 * @param object An object that contains serializable values
	 * @returns string Encoded
	 */

	function urlEncode(object) {
	  return Object.keys(object).map(function (key) {
	    return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
	  }).join('&');
	}
	/**
	 * Transforms any object into an object literal with all its attributes
	 * attached to it.
	 *
	 * @param value Initial source that we have to transform in order for it to be usable by the serializer
	 */

	function convertToPlainObject(value) {
	  var newObj = value;

	  if (isError(value)) {
	    newObj = __assign$2({
	      message: value.message,
	      name: value.name,
	      stack: value.stack
	    }, getOwnProperties(value));
	  } else if (isEvent(value)) {
	    var event_1 = value;
	    newObj = __assign$2({
	      type: event_1.type,
	      target: serializeEventTarget(event_1.target),
	      currentTarget: serializeEventTarget(event_1.currentTarget)
	    }, getOwnProperties(event_1));

	    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {
	      newObj.detail = event_1.detail;
	    }
	  }

	  return newObj;
	}
	/** Creates a string representation of the target of an `Event` object */

	function serializeEventTarget(target) {
	  try {
	    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
	  } catch (_oO) {
	    return '<unknown>';
	  }
	}
	/** Filters out all but an object's own properties */


	function getOwnProperties(obj) {
	  var extractedProps = {};

	  for (var property in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, property)) {
	      extractedProps[property] = obj[property];
	    }
	  }

	  return extractedProps;
	}
	/**
	 * Given any captured exception, extract its keys and create a sorted
	 * and truncated list that will be used inside the event message.
	 * eg. `Non-error exception captured with keys: foo, bar, baz`
	 */
	// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


	function extractExceptionKeysForMessage(exception, maxLength) {
	  if (maxLength === void 0) {
	    maxLength = 40;
	  }

	  var keys = Object.keys(convertToPlainObject(exception));
	  keys.sort();

	  if (!keys.length) {
	    return '[object has no keys]';
	  }

	  if (keys[0].length >= maxLength) {
	    return truncate(keys[0], maxLength);
	  }

	  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
	    var serialized = keys.slice(0, includedKeys).join(', ');

	    if (serialized.length > maxLength) {
	      continue;
	    }

	    if (includedKeys === keys.length) {
	      return serialized;
	    }

	    return truncate(serialized, maxLength);
	  }

	  return '';
	}
	/**
	 * Given any object, return the new object with removed keys that value was `undefined`.
	 * Works recursively on objects and arrays.
	 */

	function dropUndefinedKeys(val) {
	  var e_1, _a;

	  if (isPlainObject(val)) {
	    var rv = {};

	    try {
	      for (var _b = __values$2(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
	        var key = _c.value;

	        if (typeof val[key] !== 'undefined') {
	          rv[key] = dropUndefinedKeys(val[key]);
	        }
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }

	    return rv;
	  }

	  if (Array.isArray(val)) {
	    return val.map(dropUndefinedKeys);
	  }

	  return val;
	}

	var STACKTRACE_LIMIT = 50;
	/**
	 * Creates a stack parser with the supplied line parsers
	 *
	 * StackFrames are returned in the correct order for Sentry Exception
	 * frames and with Sentry SDK internal frames removed from the top and bottom
	 *
	 */

	function createStackParser() {
	  var parsers = [];

	  for (var _i = 0; _i < arguments.length; _i++) {
	    parsers[_i] = arguments[_i];
	  }

	  var sortedParsers = parsers.sort(function (a, b) {
	    return a[0] - b[0];
	  }).map(function (p) {
	    return p[1];
	  });
	  return function (stack, skipFirst) {
	    var e_1, _a, e_2, _b;

	    if (skipFirst === void 0) {
	      skipFirst = 0;
	    }

	    var frames = [];

	    try {
	      for (var _c = __values$2(stack.split('\n').slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
	        var line = _d.value;

	        try {
	          for (var sortedParsers_1 = (e_2 = void 0, __values$2(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
	            var parser = sortedParsers_1_1.value;
	            var frame = parser(line);

	            if (frame) {
	              frames.push(frame);
	              break;
	            }
	          }
	        } catch (e_2_1) {
	          e_2 = {
	            error: e_2_1
	          };
	        } finally {
	          try {
	            if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return)) _b.call(sortedParsers_1);
	          } finally {
	            if (e_2) throw e_2.error;
	          }
	        }
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }

	    return stripSentryFramesAndReverse(frames);
	  };
	}
	/**
	 * @hidden
	 */

	function stripSentryFramesAndReverse(stack) {
	  if (!stack.length) {
	    return [];
	  }

	  var localStack = stack;
	  var firstFrameFunction = localStack[0].function || '';
	  var lastFrameFunction = localStack[localStack.length - 1].function || ''; // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)

	  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
	    localStack = localStack.slice(1);
	  } // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)


	  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
	    localStack = localStack.slice(0, -1);
	  } // The frame where the crash happened, should be the last entry in the array


	  return localStack.slice(0, STACKTRACE_LIMIT).map(function (frame) {
	    return __assign$2(__assign$2({}, frame), {
	      filename: frame.filename || localStack[0].filename,
	      function: frame.function || '?'
	    });
	  }).reverse();
	}
	var defaultFunctionName = '<anonymous>';
	/**
	 * Safely extract function name from itself
	 */

	function getFunctionName(fn) {
	  try {
	    if (!fn || typeof fn !== 'function') {
	      return defaultFunctionName;
	    }

	    return fn.name || defaultFunctionName;
	  } catch (e) {
	    // Just accessing custom props in some Selenium environments
	    // can cause a "Permission denied" exception (see raven-js#495).
	    return defaultFunctionName;
	  }
	}

	/**
	 * Tells whether current environment supports Fetch API
	 * {@link supportsFetch}.
	 *
	 * @returns Answer to the given question.
	 */

	function supportsFetch() {
	  if (!('fetch' in getGlobalObject())) {
	    return false;
	  }

	  try {
	    new Headers();
	    new Request('');
	    new Response();
	    return true;
	  } catch (e) {
	    return false;
	  }
	}
	/**
	 * isNativeFetch checks if the given function is a native implementation of fetch()
	 */
	// eslint-disable-next-line @typescript-eslint/ban-types

	function isNativeFetch(func) {
	  return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
	}
	/**
	 * Tells whether current environment supports Fetch API natively
	 * {@link supportsNativeFetch}.
	 *
	 * @returns true if `window.fetch` is natively implemented, false otherwise
	 */

	function supportsNativeFetch() {
	  if (!supportsFetch()) {
	    return false;
	  }

	  var global = getGlobalObject(); // Fast path to avoid DOM I/O
	  // eslint-disable-next-line @typescript-eslint/unbound-method

	  if (isNativeFetch(global.fetch)) {
	    return true;
	  } // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
	  // so create a "pure" iframe to see if that has native fetch


	  var result = false;
	  var doc = global.document; // eslint-disable-next-line deprecation/deprecation

	  if (doc && typeof doc.createElement === 'function') {
	    try {
	      var sandbox = doc.createElement('iframe');
	      sandbox.hidden = true;
	      doc.head.appendChild(sandbox);

	      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        result = isNativeFetch(sandbox.contentWindow.fetch);
	      }

	      doc.head.removeChild(sandbox);
	    } catch (err) {
	      IS_DEBUG_BUILD$4 && logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
	    }
	  }

	  return result;
	}
	/**
	 * Tells whether current environment supports Referrer Policy API
	 * {@link supportsReferrerPolicy}.
	 *
	 * @returns Answer to the given question.
	 */

	function supportsReferrerPolicy() {
	  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
	  // (see https://caniuse.com/#feat=referrer-policy),
	  // it doesn't. And it throws an exception instead of ignoring this parameter...
	  // REF: https://github.com/getsentry/raven-js/issues/1233
	  if (!supportsFetch()) {
	    return false;
	  }

	  try {
	    new Request('_', {
	      referrerPolicy: 'origin'
	    });
	    return true;
	  } catch (e) {
	    return false;
	  }
	}
	/**
	 * Tells whether current environment supports History API
	 * {@link supportsHistory}.
	 *
	 * @returns Answer to the given question.
	 */

	function supportsHistory() {
	  // NOTE: in Chrome App environment, touching history.pushState, *even inside
	  //       a try/catch block*, will cause Chrome to output an error to console.error
	  // borrowed from: https://github.com/angular/angular.js/pull/13945/files
	  var global = getGlobalObject();
	  /* eslint-disable @typescript-eslint/no-unsafe-member-access */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any

	  var chrome = global.chrome;
	  var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
	  /* eslint-enable @typescript-eslint/no-unsafe-member-access */

	  var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;
	  return !isChromePackagedApp && hasHistoryApi;
	}

	var global$9 = getGlobalObject();
	/**
	 * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
	 *  - Console API
	 *  - Fetch API
	 *  - XHR API
	 *  - History API
	 *  - DOM API (click/typing)
	 *  - Error API
	 *  - UnhandledRejection API
	 */

	var handlers = {};
	var instrumented = {};
	/** Instruments given API */

	function instrument(type) {
	  if (instrumented[type]) {
	    return;
	  }

	  instrumented[type] = true;

	  switch (type) {
	    case 'console':
	      instrumentConsole();
	      break;

	    case 'dom':
	      instrumentDOM();
	      break;

	    case 'xhr':
	      instrumentXHR();
	      break;

	    case 'fetch':
	      instrumentFetch();
	      break;

	    case 'history':
	      instrumentHistory();
	      break;

	    case 'error':
	      instrumentError();
	      break;

	    case 'unhandledrejection':
	      instrumentUnhandledRejection();
	      break;

	    default:
	      IS_DEBUG_BUILD$4 && logger.warn('unknown instrumentation type:', type);
	      return;
	  }
	}
	/**
	 * Add handler that will be called when given type of instrumentation triggers.
	 * Use at your own risk, this might break without changelog notice, only used internally.
	 * @hidden
	 */


	function addInstrumentationHandler(type, callback) {
	  handlers[type] = handlers[type] || [];
	  handlers[type].push(callback);
	  instrument(type);
	}
	/** JSDoc */

	function triggerHandlers(type, data) {
	  var e_1, _a;

	  if (!type || !handlers[type]) {
	    return;
	  }

	  try {
	    for (var _b = __values$2(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
	      var handler = _c.value;

	      try {
	        handler(data);
	      } catch (e) {
	        IS_DEBUG_BUILD$4 && logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError:", e);
	      }
	    }
	  } catch (e_1_1) {
	    e_1 = {
	      error: e_1_1
	    };
	  } finally {
	    try {
	      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	    } finally {
	      if (e_1) throw e_1.error;
	    }
	  }
	}
	/** JSDoc */


	function instrumentConsole() {
	  if (!('console' in global$9)) {
	    return;
	  }

	  CONSOLE_LEVELS.forEach(function (level) {
	    if (!(level in global$9.console)) {
	      return;
	    }

	    fill(global$9.console, level, function (originalConsoleMethod) {
	      return function () {
	        var args = [];

	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }

	        triggerHandlers('console', {
	          args: args,
	          level: level
	        }); // this fails for some browsers. :(

	        if (originalConsoleMethod) {
	          originalConsoleMethod.apply(global$9.console, args);
	        }
	      };
	    });
	  });
	}
	/** JSDoc */


	function instrumentFetch() {
	  if (!supportsNativeFetch()) {
	    return;
	  }

	  fill(global$9, 'fetch', function (originalFetch) {
	    return function () {
	      var args = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }

	      var handlerData = {
	        args: args,
	        fetchData: {
	          method: getFetchMethod(args),
	          url: getFetchUrl(args)
	        },
	        startTimestamp: Date.now()
	      };
	      triggerHandlers('fetch', __assign$2({}, handlerData)); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

	      return originalFetch.apply(global$9, args).then(function (response) {
	        triggerHandlers('fetch', __assign$2(__assign$2({}, handlerData), {
	          endTimestamp: Date.now(),
	          response: response
	        }));
	        return response;
	      }, function (error) {
	        triggerHandlers('fetch', __assign$2(__assign$2({}, handlerData), {
	          endTimestamp: Date.now(),
	          error: error
	        })); // NOTE: If you are a Sentry user, and you are seeing this stack frame,
	        //       it means the sentry.javascript SDK caught an error invoking your application code.
	        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.

	        throw error;
	      });
	    };
	  });
	}
	/* eslint-disable @typescript-eslint/no-unsafe-member-access */

	/** Extract `method` from fetch call arguments */


	function getFetchMethod(fetchArgs) {
	  if (fetchArgs === void 0) {
	    fetchArgs = [];
	  }

	  if ('Request' in global$9 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
	    return String(fetchArgs[0].method).toUpperCase();
	  }

	  if (fetchArgs[1] && fetchArgs[1].method) {
	    return String(fetchArgs[1].method).toUpperCase();
	  }

	  return 'GET';
	}
	/** Extract `url` from fetch call arguments */


	function getFetchUrl(fetchArgs) {
	  if (fetchArgs === void 0) {
	    fetchArgs = [];
	  }

	  if (typeof fetchArgs[0] === 'string') {
	    return fetchArgs[0];
	  }

	  if ('Request' in global$9 && isInstanceOf(fetchArgs[0], Request)) {
	    return fetchArgs[0].url;
	  }

	  return String(fetchArgs[0]);
	}
	/* eslint-enable @typescript-eslint/no-unsafe-member-access */

	/** JSDoc */


	function instrumentXHR() {
	  if (!('XMLHttpRequest' in global$9)) {
	    return;
	  }

	  var xhrproto = XMLHttpRequest.prototype;
	  fill(xhrproto, 'open', function (originalOpen) {
	    return function () {
	      var args = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      } // eslint-disable-next-line @typescript-eslint/no-this-alias


	      var xhr = this;
	      var url = args[1];
	      var xhrInfo = xhr.__sentry_xhr__ = {
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        method: isString(args[0]) ? args[0].toUpperCase() : args[0],
	        url: args[1]
	      }; // if Sentry key appears in URL, don't capture it as a request
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

	      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
	        xhr.__sentry_own_request__ = true;
	      }

	      var onreadystatechangeHandler = function () {
	        if (xhr.readyState === 4) {
	          try {
	            // touching statusCode in some platforms throws
	            // an exception
	            xhrInfo.status_code = xhr.status;
	          } catch (e) {
	            /* do nothing */
	          }

	          triggerHandlers('xhr', {
	            args: args,
	            endTimestamp: Date.now(),
	            startTimestamp: Date.now(),
	            xhr: xhr
	          });
	        }
	      };

	      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
	        fill(xhr, 'onreadystatechange', function (original) {
	          return function () {
	            var readyStateArgs = [];

	            for (var _i = 0; _i < arguments.length; _i++) {
	              readyStateArgs[_i] = arguments[_i];
	            }

	            onreadystatechangeHandler();
	            return original.apply(xhr, readyStateArgs);
	          };
	        });
	      } else {
	        xhr.addEventListener('readystatechange', onreadystatechangeHandler);
	      }

	      return originalOpen.apply(xhr, args);
	    };
	  });
	  fill(xhrproto, 'send', function (originalSend) {
	    return function () {
	      var args = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }

	      if (this.__sentry_xhr__ && args[0] !== undefined) {
	        this.__sentry_xhr__.body = args[0];
	      }

	      triggerHandlers('xhr', {
	        args: args,
	        startTimestamp: Date.now(),
	        xhr: this
	      });
	      return originalSend.apply(this, args);
	    };
	  });
	}

	var lastHref;
	/** JSDoc */

	function instrumentHistory() {
	  if (!supportsHistory()) {
	    return;
	  }

	  var oldOnPopState = global$9.onpopstate;

	  global$9.onpopstate = function () {
	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var to = global$9.location.href; // keep track of the current URL state, as we always receive only the updated state

	    var from = lastHref;
	    lastHref = to;
	    triggerHandlers('history', {
	      from: from,
	      to: to
	    });

	    if (oldOnPopState) {
	      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
	      // https://github.com/getsentry/sentry-javascript/issues/3344
	      // https://github.com/bugsnag/bugsnag-js/issues/469
	      try {
	        return oldOnPopState.apply(this, args);
	      } catch (_oO) {// no-empty
	      }
	    }
	  };
	  /** @hidden */


	  function historyReplacementFunction(originalHistoryFunction) {
	    return function () {
	      var args = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }

	      var url = args.length > 2 ? args[2] : undefined;

	      if (url) {
	        // coerce to string (this is what pushState does)
	        var from = lastHref;
	        var to = String(url); // keep track of the current URL state, as we always receive only the updated state

	        lastHref = to;
	        triggerHandlers('history', {
	          from: from,
	          to: to
	        });
	      }

	      return originalHistoryFunction.apply(this, args);
	    };
	  }

	  fill(global$9.history, 'pushState', historyReplacementFunction);
	  fill(global$9.history, 'replaceState', historyReplacementFunction);
	}

	var debounceDuration = 1000;
	var debounceTimerID;
	var lastCapturedEvent;
	/**
	 * Decide whether the current event should finish the debounce of previously captured one.
	 * @param previous previously captured event
	 * @param current event to be captured
	 */

	function shouldShortcircuitPreviousDebounce(previous, current) {
	  // If there was no previous event, it should always be swapped for the new one.
	  if (!previous) {
	    return true;
	  } // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.


	  if (previous.type !== current.type) {
	    return true;
	  }

	  try {
	    // If both events have the same type, it's still possible that actions were performed on different targets.
	    // e.g. 2 clicks on different buttons.
	    if (previous.target !== current.target) {
	      return true;
	    }
	  } catch (e) {// just accessing `target` property can throw an exception in some rare circumstances
	    // see: https://github.com/getsentry/sentry-javascript/issues/838
	  } // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
	  // to which an event listener was attached), we treat them as the same action, as we want to capture
	  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.


	  return false;
	}
	/**
	 * Decide whether an event should be captured.
	 * @param event event to be captured
	 */


	function shouldSkipDOMEvent(event) {
	  // We are only interested in filtering `keypress` events for now.
	  if (event.type !== 'keypress') {
	    return false;
	  }

	  try {
	    var target = event.target;

	    if (!target || !target.tagName) {
	      return true;
	    } // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
	    // e.g.tabbing through elements, hotkeys, etc.


	    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
	      return false;
	    }
	  } catch (e) {// just accessing `target` property can throw an exception in some rare circumstances
	    // see: https://github.com/getsentry/sentry-javascript/issues/838
	  }

	  return true;
	}
	/**
	 * Wraps addEventListener to capture UI breadcrumbs
	 * @param handler function that will be triggered
	 * @param globalListener indicates whether event was captured by the global event listener
	 * @returns wrapped breadcrumb events handler
	 * @hidden
	 */


	function makeDOMEventHandler(handler, globalListener) {
	  if (globalListener === void 0) {
	    globalListener = false;
	  }

	  return function (event) {
	    // It's possible this handler might trigger multiple times for the same
	    // event (e.g. event propagation through node ancestors).
	    // Ignore if we've already captured that event.
	    if (!event || lastCapturedEvent === event) {
	      return;
	    } // We always want to skip _some_ events.


	    if (shouldSkipDOMEvent(event)) {
	      return;
	    }

	    var name = event.type === 'keypress' ? 'input' : event.type; // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.

	    if (debounceTimerID === undefined) {
	      handler({
	        event: event,
	        name: name,
	        global: globalListener
	      });
	      lastCapturedEvent = event;
	    } // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
	    // If that's the case, emit the previous event and store locally the newly-captured DOM event.
	    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
	      handler({
	        event: event,
	        name: name,
	        global: globalListener
	      });
	      lastCapturedEvent = event;
	    } // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.


	    clearTimeout(debounceTimerID);
	    debounceTimerID = global$9.setTimeout(function () {
	      debounceTimerID = undefined;
	    }, debounceDuration);
	  };
	}
	/** JSDoc */


	function instrumentDOM() {
	  if (!('document' in global$9)) {
	    return;
	  } // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
	  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
	  // we instrument `addEventListener` so that we don't end up attaching this handler twice.


	  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
	  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
	  global$9.document.addEventListener('click', globalDOMEventHandler, false);
	  global$9.document.addEventListener('keypress', globalDOMEventHandler, false); // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
	  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
	  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
	  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
	  // guaranteed to fire at least once.)

	  ['EventTarget', 'Node'].forEach(function (target) {
	    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	    var proto = global$9[target] && global$9[target].prototype; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins

	    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
	      return;
	    }

	    fill(proto, 'addEventListener', function (originalAddEventListener) {
	      return function (type, listener, options) {
	        if (type === 'click' || type == 'keypress') {
	          try {
	            var el = this;
	            var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
	            var handlerForType = handlers_1[type] = handlers_1[type] || {
	              refCount: 0
	            };

	            if (!handlerForType.handler) {
	              var handler = makeDOMEventHandler(triggerDOMHandler);
	              handlerForType.handler = handler;
	              originalAddEventListener.call(this, type, handler, options);
	            }

	            handlerForType.refCount += 1;
	          } catch (e) {// Accessing dom properties is always fragile.
	            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
	          }
	        }

	        return originalAddEventListener.call(this, type, listener, options);
	      };
	    });
	    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
	      return function (type, listener, options) {
	        if (type === 'click' || type == 'keypress') {
	          try {
	            var el = this;
	            var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
	            var handlerForType = handlers_2[type];

	            if (handlerForType) {
	              handlerForType.refCount -= 1; // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.

	              if (handlerForType.refCount <= 0) {
	                originalRemoveEventListener.call(this, type, handlerForType.handler, options);
	                handlerForType.handler = undefined;
	                delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
	              } // If there are no longer any custom handlers of any type on this element, cleanup everything.


	              if (Object.keys(handlers_2).length === 0) {
	                delete el.__sentry_instrumentation_handlers__;
	              }
	            }
	          } catch (e) {// Accessing dom properties is always fragile.
	            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
	          }
	        }

	        return originalRemoveEventListener.call(this, type, listener, options);
	      };
	    });
	  });
	}

	var _oldOnErrorHandler = null;
	/** JSDoc */

	function instrumentError() {
	  _oldOnErrorHandler = global$9.onerror;

	  global$9.onerror = function (msg, url, line, column, error) {
	    triggerHandlers('error', {
	      column: column,
	      error: error,
	      line: line,
	      msg: msg,
	      url: url
	    });

	    if (_oldOnErrorHandler) {
	      // eslint-disable-next-line prefer-rest-params
	      return _oldOnErrorHandler.apply(this, arguments);
	    }

	    return false;
	  };
	}

	var _oldOnUnhandledRejectionHandler = null;
	/** JSDoc */

	function instrumentUnhandledRejection() {
	  _oldOnUnhandledRejectionHandler = global$9.onunhandledrejection;

	  global$9.onunhandledrejection = function (e) {
	    triggerHandlers('unhandledrejection', e);

	    if (_oldOnUnhandledRejectionHandler) {
	      // eslint-disable-next-line prefer-rest-params
	      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
	    }

	    return true;
	  };
	}

	/* eslint-disable @typescript-eslint/no-unsafe-member-access */

	/* eslint-disable @typescript-eslint/no-explicit-any */

	/**
	 * Helper to decycle json objects
	 */
	function memoBuilder() {
	  var hasWeakSet = typeof WeakSet === 'function';
	  var inner = hasWeakSet ? new WeakSet() : [];

	  function memoize(obj) {
	    if (hasWeakSet) {
	      if (inner.has(obj)) {
	        return true;
	      }

	      inner.add(obj);
	      return false;
	    } // eslint-disable-next-line @typescript-eslint/prefer-for-of


	    for (var i = 0; i < inner.length; i++) {
	      var value = inner[i];

	      if (value === obj) {
	        return true;
	      }
	    }

	    inner.push(obj);
	    return false;
	  }

	  function unmemoize(obj) {
	    if (hasWeakSet) {
	      inner.delete(obj);
	    } else {
	      for (var i = 0; i < inner.length; i++) {
	        if (inner[i] === obj) {
	          inner.splice(i, 1);
	          break;
	        }
	      }
	    }
	  }

	  return [memoize, unmemoize];
	}

	/**
	 * UUID4 generator
	 *
	 * @returns string Generated UUID4.
	 */

	function uuid4() {
	  var global = getGlobalObject();
	  var crypto = global.crypto || global.msCrypto;

	  if (!(crypto === void 0) && crypto.getRandomValues) {
	    // Use window.crypto API if available
	    var arr = new Uint16Array(8);
	    crypto.getRandomValues(arr); // set 4 in byte 7
	    // eslint-disable-next-line no-bitwise

	    arr[3] = arr[3] & 0xfff | 0x4000; // set 2 most significant bits of byte 9 to '10'
	    // eslint-disable-next-line no-bitwise

	    arr[4] = arr[4] & 0x3fff | 0x8000;

	    var pad = function (num) {
	      var v = num.toString(16);

	      while (v.length < 4) {
	        v = "0" + v;
	      }

	      return v;
	    };

	    return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
	  } // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523


	  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    // eslint-disable-next-line no-bitwise
	    var r = Math.random() * 16 | 0; // eslint-disable-next-line no-bitwise

	    var v = c === 'x' ? r : r & 0x3 | 0x8;
	    return v.toString(16);
	  });
	}
	/**
	 * Parses string form of URL into an object
	 * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
	 * // intentionally using regex and not <a/> href parsing trick because React Native and other
	 * // environments where DOM might not be available
	 * @returns parsed URL object
	 */

	function parseUrl(url) {
	  if (!url) {
	    return {};
	  }

	  var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

	  if (!match) {
	    return {};
	  } // coerce to undefined values to empty string so we don't get 'undefined'


	  var query = match[6] || '';
	  var fragment = match[8] || '';
	  return {
	    host: match[4],
	    path: match[5],
	    protocol: match[2],
	    relative: match[5] + query + fragment
	  };
	}

	function getFirstException(event) {
	  return event.exception && event.exception.values ? event.exception.values[0] : undefined;
	}
	/**
	 * Extracts either message or type+value from an event that can be used for user-facing logs
	 * @returns event's description
	 */


	function getEventDescription(event) {
	  var message = event.message,
	      eventId = event.event_id;

	  if (message) {
	    return message;
	  }

	  var firstException = getFirstException(event);

	  if (firstException) {
	    if (firstException.type && firstException.value) {
	      return firstException.type + ": " + firstException.value;
	    }

	    return firstException.type || firstException.value || eventId || '<unknown>';
	  }

	  return eventId || '<unknown>';
	}
	/**
	 * Adds exception values, type and value to an synthetic Exception.
	 * @param event The event to modify.
	 * @param value Value of the exception.
	 * @param type Type of the exception.
	 * @hidden
	 */

	function addExceptionTypeValue(event, value, type) {
	  var exception = event.exception = event.exception || {};
	  var values = exception.values = exception.values || [];
	  var firstException = values[0] = values[0] || {};

	  if (!firstException.value) {
	    firstException.value = value || '';
	  }

	  if (!firstException.type) {
	    firstException.type = type || 'Error';
	  }
	}
	/**
	 * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
	 *
	 * @param event The event to modify.
	 * @param newMechanism Mechanism data to add to the event.
	 * @hidden
	 */

	function addExceptionMechanism(event, newMechanism) {
	  var firstException = getFirstException(event);

	  if (!firstException) {
	    return;
	  }

	  var defaultMechanism = {
	    type: 'generic',
	    handled: true
	  };
	  var currentMechanism = firstException.mechanism;
	  firstException.mechanism = __assign$2(__assign$2(__assign$2({}, defaultMechanism), currentMechanism), newMechanism);

	  if (newMechanism && 'data' in newMechanism) {
	    var mergedData = __assign$2(__assign$2({}, currentMechanism && currentMechanism.data), newMechanism.data);

	    firstException.mechanism.data = mergedData;
	  }
	} // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
	/**
	 * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
	 * in question), and marks it captured if not.
	 *
	 * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
	 * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
	 * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
	 * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
	 * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
	 * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
	 * see it.
	 *
	 * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
	 * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
	 * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
	 * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
	 * must be done before the exception captured.
	 *
	 * @param A thrown exception to check or flag as having been seen
	 * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
	 */

	function checkOrSetAlreadyCaught(exception) {
	  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	  if (exception && exception.__sentry_captured__) {
	    return true;
	  }

	  try {
	    // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
	    // `ExtraErrorData` integration
	    addNonEnumerableProperty(exception, '__sentry_captured__', true);
	  } catch (err) {// `exception` is a primitive, so we can't mark it seen
	  }

	  return false;
	}

	/**
	 * Recursively normalizes the given object.
	 *
	 * - Creates a copy to prevent original input mutation
	 * - Skips non-enumerable properties
	 * - When stringifying, calls `toJSON` if implemented
	 * - Removes circular references
	 * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
	 * - Translates known global objects/classes to a string representations
	 * - Takes care of `Error` object serialization
	 * - Optionally limits depth of final output
	 * - Optionally limits number of properties/elements included in any single object/array
	 *
	 * @param input The object to be normalized.
	 * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
	 * @param maxProperties The max number of elements or properties to be included in any single array or
	 * object in the normallized output..
	 * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
	 */

	function normalize(input, depth, maxProperties) {
	  if (depth === void 0) {
	    depth = +Infinity;
	  }

	  if (maxProperties === void 0) {
	    maxProperties = +Infinity;
	  }

	  try {
	    // since we're at the outermost level, there is no key
	    return visit('', input, depth, maxProperties);
	  } catch (err) {
	    return {
	      ERROR: "**non-serializable** (" + err + ")"
	    };
	  }
	}
	/** JSDoc */

	function normalizeToSize(object, // Default Node.js REPL depth
	depth, // 100kB, as 200kB is max payload size, so half sounds reasonable
	maxSize) {
	  if (depth === void 0) {
	    depth = 3;
	  }

	  if (maxSize === void 0) {
	    maxSize = 100 * 1024;
	  }

	  var normalized = normalize(object, depth);

	  if (jsonSize(normalized) > maxSize) {
	    return normalizeToSize(object, depth - 1, maxSize);
	  }

	  return normalized;
	}
	/**
	 * Visits a node to perform normalization on it
	 *
	 * @param key The key corresponding to the given node
	 * @param value The node to be visited
	 * @param depth Optional number indicating the maximum recursion depth
	 * @param maxProperties Optional maximum number of properties/elements included in any single object/array
	 * @param memo Optional Memo class handling decycling
	 */

	function visit(key, value, depth, maxProperties, memo) {
	  if (depth === void 0) {
	    depth = +Infinity;
	  }

	  if (maxProperties === void 0) {
	    maxProperties = +Infinity;
	  }

	  if (memo === void 0) {
	    memo = memoBuilder();
	  }

	  var _a = __read$2(memo, 2),
	      memoize = _a[0],
	      unmemoize = _a[1]; // If the value has a `toJSON` method, see if we can bail and let it do the work


	  var valueWithToJSON = value;

	  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
	    try {
	      return valueWithToJSON.toJSON();
	    } catch (err) {// pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
	    }
	  } // Get the simple cases out of the way first


	  if (value === null || ['number', 'boolean', 'string'].includes(typeof value) && !isNaN$1(value)) {
	    return value;
	  }

	  var stringified = stringifyValue(key, value); // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
	  // Everything else will have already been serialized, so if we don't see that pattern, we're done.

	  if (!stringified.startsWith('[object ')) {
	    return stringified;
	  } // We're also done if we've reached the max depth


	  if (depth === 0) {
	    // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
	    return stringified.replace('object ', '');
	  } // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.


	  if (memoize(value)) {
	    return '[Circular ~]';
	  } // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
	  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
	  // property/entry, and keep track of the number of items we add to it.


	  var normalized = Array.isArray(value) ? [] : {};
	  var numAdded = 0; // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
	  // properties are non-enumerable and otherwise would get missed.

	  var visitable = isError(value) || isEvent(value) ? convertToPlainObject(value) : value;

	  for (var visitKey in visitable) {
	    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
	    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
	      continue;
	    }

	    if (numAdded >= maxProperties) {
	      normalized[visitKey] = '[MaxProperties ~]';
	      break;
	    } // Recursively visit all the child nodes


	    var visitValue = visitable[visitKey];
	    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);
	    numAdded += 1;
	  } // Once we've visited all the branches, remove the parent from memo storage


	  unmemoize(value); // Return accumulated values

	  return normalized;
	} // TODO remove this in v7 (this means the method will no longer be exported, under any name)
	/**
	 * Stringify the given value. Handles various known special values and types.
	 *
	 * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
	 * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
	 *
	 * @param value The value to stringify
	 * @returns A stringified representation of the given value
	 */

	function stringifyValue(key, // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
	// our internal use, it'll do
	value) {
	  try {
	    if (key === 'domain' && value && typeof value === 'object' && value._events) {
	      return '[Domain]';
	    }

	    if (key === 'domainEmitter') {
	      return '[DomainEmitter]';
	    } // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
	    // which won't throw if they are not present.


	    if (typeof global !== 'undefined' && value === global) {
	      return '[Global]';
	    } // eslint-disable-next-line no-restricted-globals


	    if (typeof window !== 'undefined' && value === window) {
	      return '[Window]';
	    } // eslint-disable-next-line no-restricted-globals


	    if (typeof document !== 'undefined' && value === document) {
	      return '[Document]';
	    } // React's SyntheticEvent thingy


	    if (isSyntheticEvent(value)) {
	      return '[SyntheticEvent]';
	    }

	    if (typeof value === 'number' && value !== value) {
	      return '[NaN]';
	    } // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)


	    if (value === void 0) {
	      return '[undefined]';
	    }

	    if (typeof value === 'function') {
	      return "[Function: " + getFunctionName(value) + "]";
	    }

	    if (typeof value === 'symbol') {
	      return "[" + String(value) + "]";
	    } // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion


	    if (typeof value === 'bigint') {
	      return "[BigInt: " + String(value) + "]";
	    } // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
	    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
	    // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
	    // we can make sure that only plain objects come out that way.


	    return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
	  } catch (err) {
	    return "**non-serializable** (" + err + ")";
	  }
	}
	/** Calculates bytes size of input string */


	function utf8Length(value) {
	  // eslint-disable-next-line no-bitwise
	  return ~-encodeURI(value).split(/%..|./).length;
	}
	/** Calculates bytes size of input object */


	function jsonSize(value) {
	  return utf8Length(JSON.stringify(value));
	}

	/* eslint-disable @typescript-eslint/explicit-function-return-type */
	/**
	 * Creates a resolved sync promise.
	 *
	 * @param value the value to resolve the promise with
	 * @returns the resolved sync promise
	 */

	function resolvedSyncPromise(value) {
	  return new SyncPromise(function (resolve) {
	    resolve(value);
	  });
	}
	/**
	 * Creates a rejected sync promise.
	 *
	 * @param value the value to reject the promise with
	 * @returns the rejected sync promise
	 */

	function rejectedSyncPromise(reason) {
	  return new SyncPromise(function (_, reject) {
	    reject(reason);
	  });
	}
	/**
	 * Thenable class that behaves like a Promise and follows it's interface
	 * but is not async internally
	 */

	var SyncPromise =
	/** @class */
	function () {
	  function SyncPromise(executor) {
	    var _this = this;

	    this._state = 0
	    /* PENDING */
	    ;
	    this._handlers = [];
	    /** JSDoc */

	    this._resolve = function (value) {
	      _this._setResult(1
	      /* RESOLVED */
	      , value);
	    };
	    /** JSDoc */


	    this._reject = function (reason) {
	      _this._setResult(2
	      /* REJECTED */
	      , reason);
	    };
	    /** JSDoc */


	    this._setResult = function (state, value) {
	      if (_this._state !== 0
	      /* PENDING */
	      ) {
	        return;
	      }

	      if (isThenable(value)) {
	        void value.then(_this._resolve, _this._reject);
	        return;
	      }

	      _this._state = state;
	      _this._value = value;

	      _this._executeHandlers();
	    };
	    /** JSDoc */


	    this._executeHandlers = function () {
	      if (_this._state === 0
	      /* PENDING */
	      ) {
	        return;
	      }

	      var cachedHandlers = _this._handlers.slice();

	      _this._handlers = [];
	      cachedHandlers.forEach(function (handler) {
	        if (handler[0]) {
	          return;
	        }

	        if (_this._state === 1
	        /* RESOLVED */
	        ) {
	          // eslint-disable-next-line @typescript-eslint/no-floating-promises
	          handler[1](_this._value);
	        }

	        if (_this._state === 2
	        /* REJECTED */
	        ) {
	          handler[2](_this._value);
	        }

	        handler[0] = true;
	      });
	    };

	    try {
	      executor(this._resolve, this._reject);
	    } catch (e) {
	      this._reject(e);
	    }
	  }
	  /** JSDoc */


	  SyncPromise.prototype.then = function (onfulfilled, onrejected) {
	    var _this = this;

	    return new SyncPromise(function (resolve, reject) {
	      _this._handlers.push([false, function (result) {
	        if (!onfulfilled) {
	          // TODO: \_()_/
	          // TODO: FIXME
	          resolve(result);
	        } else {
	          try {
	            resolve(onfulfilled(result));
	          } catch (e) {
	            reject(e);
	          }
	        }
	      }, function (reason) {
	        if (!onrejected) {
	          reject(reason);
	        } else {
	          try {
	            resolve(onrejected(reason));
	          } catch (e) {
	            reject(e);
	          }
	        }
	      }]);

	      _this._executeHandlers();
	    });
	  };
	  /** JSDoc */


	  SyncPromise.prototype.catch = function (onrejected) {
	    return this.then(function (val) {
	      return val;
	    }, onrejected);
	  };
	  /** JSDoc */


	  SyncPromise.prototype.finally = function (onfinally) {
	    var _this = this;

	    return new SyncPromise(function (resolve, reject) {
	      var val;
	      var isRejected;
	      return _this.then(function (value) {
	        isRejected = false;
	        val = value;

	        if (onfinally) {
	          onfinally();
	        }
	      }, function (reason) {
	        isRejected = true;
	        val = reason;

	        if (onfinally) {
	          onfinally();
	        }
	      }).then(function () {
	        if (isRejected) {
	          reject(val);
	          return;
	        }

	        resolve(val);
	      });
	    });
	  };

	  return SyncPromise;
	}();

	/**
	 * Creates an new PromiseBuffer object with the specified limit
	 * @param limit max number of promises that can be stored in the buffer
	 */

	function makePromiseBuffer(limit) {
	  var buffer = [];

	  function isReady() {
	    return limit === undefined || buffer.length < limit;
	  }
	  /**
	   * Remove a promise from the queue.
	   *
	   * @param task Can be any PromiseLike<T>
	   * @returns Removed promise.
	   */


	  function remove(task) {
	    return buffer.splice(buffer.indexOf(task), 1)[0];
	  }
	  /**
	   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
	   *
	   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
	   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
	   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
	   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
	   *        limit check.
	   * @returns The original promise.
	   */


	  function add(taskProducer) {
	    if (!isReady()) {
	      return rejectedSyncPromise(new SentryError('Not adding Promise due to buffer limit reached.'));
	    } // start the task and add its promise to the queue


	    var task = taskProducer();

	    if (buffer.indexOf(task) === -1) {
	      buffer.push(task);
	    }

	    void task.then(function () {
	      return remove(task);
	    }) // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
	    // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
	    // have promises, so TS has to polyfill when down-compiling.)
	    .then(null, function () {
	      return remove(task).then(null, function () {// We have to add another catch here because `remove()` starts a new promise chain.
	      });
	    });
	    return task;
	  }
	  /**
	   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
	   *
	   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
	   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
	   * `true`.
	   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
	   * `false` otherwise
	   */


	  function drain(timeout) {
	    return new SyncPromise(function (resolve, reject) {
	      var counter = buffer.length;

	      if (!counter) {
	        return resolve(true);
	      } // wait for `timeout` ms and then resolve to `false` (if not cancelled first)


	      var capturedSetTimeout = setTimeout(function () {
	        if (timeout && timeout > 0) {
	          resolve(false);
	        }
	      }, timeout); // if all promises resolve in time, cancel the timer and resolve to `true`

	      buffer.forEach(function (item) {
	        void resolvedSyncPromise(item).then(function () {
	          // eslint-disable-next-line no-plusplus
	          if (! --counter) {
	            clearTimeout(capturedSetTimeout);
	            resolve(true);
	          }
	        }, reject);
	      });
	    });
	  }

	  return {
	    $: buffer,
	    add: add,
	    drain: drain
	  };
	}

	function isSupportedSeverity(level) {
	  return SeverityLevels.indexOf(level) !== -1;
	}
	/**
	 * Converts a string-based level into a {@link Severity}.
	 *
	 * @param level string representation of Severity
	 * @returns Severity
	 */


	function severityFromString(level) {
	  if (level === 'warn') return Severity.Warning;

	  if (isSupportedSeverity(level)) {
	    return level;
	  }

	  return Severity.Log;
	}

	/**
	 * Converts an HTTP status code to sentry status {@link EventStatus}.
	 *
	 * @param code number HTTP status code
	 * @returns EventStatus
	 */
	function eventStatusFromHttpCode(code) {
	  if (code >= 200 && code < 300) {
	    return 'success';
	  }

	  if (code === 429) {
	    return 'rate_limit';
	  }

	  if (code >= 400 && code < 500) {
	    return 'invalid';
	  }

	  if (code >= 500) {
	    return 'failed';
	  }

	  return 'unknown';
	}

	/**
	 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
	 *
	 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
	 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
	 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
	 */

	var dateTimestampSource = {
	  nowSeconds: function () {
	    return Date.now() / 1000;
	  }
	};
	/**
	 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
	 * support the API.
	 *
	 * Wrapping the native API works around differences in behavior from different browsers.
	 */

	function getBrowserPerformance() {
	  var performance = getGlobalObject().performance;

	  if (!performance || !performance.now) {
	    return undefined;
	  } // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
	  //
	  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
	  // performance.now() gives a date arbitrarily in the past.
	  //
	  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
	  // undefined.
	  //
	  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
	  // interact with data coming out of performance entries.
	  //
	  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
	  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
	  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
	  // observed skews that can be as long as days, weeks or months.
	  //
	  // See https://github.com/getsentry/sentry-javascript/issues/2590.
	  //
	  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
	  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
	  // transactions of long-lived web pages.


	  var timeOrigin = Date.now() - performance.now();
	  return {
	    now: function () {
	      return performance.now();
	    },
	    timeOrigin: timeOrigin
	  };
	}
	/**
	 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
	 * implement the API.
	 */


	function getNodePerformance() {
	  try {
	    var perfHooks = dynamicRequire(module, 'perf_hooks');
	    return perfHooks.performance;
	  } catch (_) {
	    return undefined;
	  }
	}
	/**
	 * The Performance API implementation for the current platform, if available.
	 */


	var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
	var timestampSource = platformPerformance === undefined ? dateTimestampSource : {
	  nowSeconds: function () {
	    return (platformPerformance.timeOrigin + platformPerformance.now()) / 1000;
	  }
	};
	/**
	 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
	 */

	var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
	/**
	 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
	 * availability of the Performance API.
	 *
	 * See `usingPerformanceAPI` to test whether the Performance API is used.
	 *
	 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
	 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
	 * skew can grow to arbitrary amounts like days, weeks or months.
	 * See https://github.com/getsentry/sentry-javascript/issues/2590.
	 */

	var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource); // Re-exported with an old name for backwards-compatibility.

	var timestampWithMs = timestampInSeconds;
	/**
	 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
	 * performance API is available.
	 */

	var browserPerformanceTimeOrigin = function () {
	  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
	  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
	  // data as reliable if they are within a reasonable threshold of the current time.
	  var performance = getGlobalObject().performance;

	  if (!performance || !performance.now) {
	    return undefined;
	  }

	  var threshold = 3600 * 1000;
	  var performanceNow = performance.now();
	  var dateNow = Date.now(); // if timeOrigin isn't available set delta to threshold so it isn't used

	  var timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;
	  var timeOriginIsReliable = timeOriginDelta < threshold; // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
	  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
	  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
	  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
	  // Date API.
	  // eslint-disable-next-line deprecation/deprecation

	  var navigationStart = performance.timing && performance.timing.navigationStart;
	  var hasNavigationStart = typeof navigationStart === 'number'; // if navigationStart isn't available set delta to threshold so it isn't used

	  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
	  var navigationStartIsReliable = navigationStartDelta < threshold;

	  if (timeOriginIsReliable || navigationStartIsReliable) {
	    // Use the more reliable time origin
	    if (timeOriginDelta <= navigationStartDelta) {
	      return performance.timeOrigin;
	    } else {
	      return navigationStart;
	    }
	  } // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
	  return dateNow;
	}();

	var TRACEPARENT_REGEXP = new RegExp('^[ \\t]*' + // whitespace
	'([0-9a-f]{32})?' + // trace_id
	'-?([0-9a-f]{16})?' + // span_id
	'-?([01])?' + // sampled
	'[ \\t]*$');
	/**
	 * Extract transaction context data from a `sentry-trace` header.
	 *
	 * @param traceparent Traceparent string
	 *
	 * @returns Object containing data from the header, or undefined if traceparent string is malformed
	 */

	function extractTraceparentData(traceparent) {
	  var matches = traceparent.match(TRACEPARENT_REGEXP);

	  if (matches) {
	    var parentSampled = void 0;

	    if (matches[3] === '1') {
	      parentSampled = true;
	    } else if (matches[3] === '0') {
	      parentSampled = false;
	    }

	    return {
	      traceId: matches[1],
	      parentSampled: parentSampled,
	      parentSpanId: matches[2]
	    };
	  }

	  return undefined;
	}

	/**
	 * Creates an envelope.
	 * Make sure to always explicitly provide the generic to this function
	 * so that the envelope types resolve correctly.
	 */

	function createEnvelope(headers, items) {
	  if (items === void 0) {
	    items = [];
	  }

	  return [headers, items];
	}
	/**
	 * Get the type of the envelope. Grabs the type from the first envelope item.
	 */

	function getEnvelopeType(envelope) {
	  var _a = __read$2(envelope, 2),
	      _b = __read$2(_a[1], 1),
	      _c = __read$2(_b[0], 1),
	      firstItemHeader = _c[0];

	  return firstItemHeader.type;
	}
	/**
	 * Serializes an envelope into a string.
	 */

	function serializeEnvelope(envelope) {
	  var _a = __read$2(envelope, 2),
	      headers = _a[0],
	      items = _a[1];

	  var serializedHeaders = JSON.stringify(headers); // Have to cast items to any here since Envelope is a union type
	  // Fixed in Typescript 4.2
	  // TODO: Remove any[] cast when we upgrade to TS 4.2
	  // https://github.com/microsoft/TypeScript/issues/36390
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any

	  return items.reduce(function (acc, item) {
	    var _a = __read$2(item, 2),
	        itemHeaders = _a[0],
	        payload = _a[1]; // We do not serialize payloads that are primitives


	    var serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
	    return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
	  }, serializedHeaders);
	}

	/**
	 * Creates client report envelope
	 * @param discarded_events An array of discard events
	 * @param dsn A DSN that can be set on the header. Optional.
	 */

	function createClientReportEnvelope(discarded_events, dsn, timestamp) {
	  var clientReportItem = [{
	    type: 'client_report'
	  }, {
	    timestamp: timestamp || dateTimestampInSeconds(),
	    discarded_events: discarded_events
	  }];
	  return createEnvelope(dsn ? {
	    dsn: dsn
	  } : {}, [clientReportItem]);
	}

	var DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds

	/**
	 * Extracts Retry-After value from the request header or returns default value
	 * @param header string representation of 'Retry-After' header
	 * @param now current unix timestamp
	 *
	 */

	function parseRetryAfterHeader(header, now) {
	  if (now === void 0) {
	    now = Date.now();
	  }

	  var headerDelay = parseInt("" + header, 10);

	  if (!isNaN(headerDelay)) {
	    return headerDelay * 1000;
	  }

	  var headerDate = Date.parse("" + header);

	  if (!isNaN(headerDate)) {
	    return headerDate - now;
	  }

	  return DEFAULT_RETRY_AFTER;
	}
	/**
	 * Gets the time that given category is disabled until for rate limiting
	 */

	function disabledUntil(limits, category) {
	  return limits[category] || limits.all || 0;
	}
	/**
	 * Checks if a category is rate limited
	 */

	function isRateLimited(limits, category, now) {
	  if (now === void 0) {
	    now = Date.now();
	  }

	  return disabledUntil(limits, category) > now;
	}
	/**
	 * Update ratelimits from incoming headers.
	 * Returns true if headers contains a non-empty rate limiting header.
	 */

	function updateRateLimits(limits, headers, now) {
	  var e_1, _a, e_2, _b;

	  if (now === void 0) {
	    now = Date.now();
	  }

	  var updatedRateLimits = __assign$2({}, limits); // "The name is case-insensitive."
	  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get


	  var rateLimitHeader = headers['x-sentry-rate-limits'];
	  var retryAfterHeader = headers['retry-after'];

	  if (rateLimitHeader) {
	    try {
	      /**
	       * rate limit headers are of the form
	       *     <header>,<header>,..
	       * where each <header> is of the form
	       *     <retry_after>: <categories>: <scope>: <reason_code>
	       * where
	       *     <retry_after> is a delay in seconds
	       *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
	       *         <category>;<category>;...
	       *     <scope> is what's being limited (org, project, or key) - ignored by SDK
	       *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
	       */
	      for (var _c = __values$2(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
	        var limit = _d.value;
	        var parameters = limit.split(':', 2);
	        var headerDelay = parseInt(parameters[0], 10);
	        var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default

	        if (!parameters[1]) {
	          updatedRateLimits.all = now + delay;
	        } else {
	          try {
	            for (var _e = (e_2 = void 0, __values$2(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {
	              var category = _f.value;
	              updatedRateLimits[category] = now + delay;
	            }
	          } catch (e_2_1) {
	            e_2 = {
	              error: e_2_1
	            };
	          } finally {
	            try {
	              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	            } finally {
	              if (e_2) throw e_2.error;
	            }
	          }
	        }
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }
	  } else if (retryAfterHeader) {
	    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
	  }

	  return updatedRateLimits;
	}

	/**
	 * Absolute maximum number of breadcrumbs added to an event.
	 * The `maxBreadcrumbs` option cannot be higher than this value.
	 */

	var MAX_BREADCRUMBS = 100;
	/**
	 * Holds additional event information. {@link Scope.applyToEvent} will be
	 * called by the client before an event will be sent.
	 */

	var Scope =
	/** @class */
	function () {
	  function Scope() {
	    /** Flag if notifying is happening. */
	    this._notifyingListeners = false;
	    /** Callback for client to receive scope changes. */

	    this._scopeListeners = [];
	    /** Callback list that will be called after {@link applyToEvent}. */

	    this._eventProcessors = [];
	    /** Array of breadcrumbs. */

	    this._breadcrumbs = [];
	    /** User */

	    this._user = {};
	    /** Tags */

	    this._tags = {};
	    /** Extra */

	    this._extra = {};
	    /** Contexts */

	    this._contexts = {};
	    /**
	     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
	     * sent to Sentry
	     */

	    this._sdkProcessingMetadata = {};
	  }
	  /**
	   * Inherit values from the parent scope.
	   * @param scope to clone.
	   */


	  Scope.clone = function (scope) {
	    var newScope = new Scope();

	    if (scope) {
	      newScope._breadcrumbs = __spread$3(scope._breadcrumbs);
	      newScope._tags = __assign$3({}, scope._tags);
	      newScope._extra = __assign$3({}, scope._extra);
	      newScope._contexts = __assign$3({}, scope._contexts);
	      newScope._user = scope._user;
	      newScope._level = scope._level;
	      newScope._span = scope._span;
	      newScope._session = scope._session;
	      newScope._transactionName = scope._transactionName;
	      newScope._fingerprint = scope._fingerprint;
	      newScope._eventProcessors = __spread$3(scope._eventProcessors);
	      newScope._requestSession = scope._requestSession;
	    }

	    return newScope;
	  };
	  /**
	   * Add internal on change listener. Used for sub SDKs that need to store the scope.
	   * @hidden
	   */


	  Scope.prototype.addScopeListener = function (callback) {
	    this._scopeListeners.push(callback);
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.addEventProcessor = function (callback) {
	    this._eventProcessors.push(callback);

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setUser = function (user) {
	    this._user = user || {};

	    if (this._session) {
	      this._session.update({
	        user: user
	      });
	    }

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.getUser = function () {
	    return this._user;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.getRequestSession = function () {
	    return this._requestSession;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setRequestSession = function (requestSession) {
	    this._requestSession = requestSession;
	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setTags = function (tags) {
	    this._tags = __assign$3(__assign$3({}, this._tags), tags);

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setTag = function (key, value) {
	    var _a;

	    this._tags = __assign$3(__assign$3({}, this._tags), (_a = {}, _a[key] = value, _a));

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setExtras = function (extras) {
	    this._extra = __assign$3(__assign$3({}, this._extra), extras);

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setExtra = function (key, extra) {
	    var _a;

	    this._extra = __assign$3(__assign$3({}, this._extra), (_a = {}, _a[key] = extra, _a));

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setFingerprint = function (fingerprint) {
	    this._fingerprint = fingerprint;

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setLevel = function (level) {
	    this._level = level;

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setTransactionName = function (name) {
	    this._transactionName = name;

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * Can be removed in major version.
	   * @deprecated in favor of {@link this.setTransactionName}
	   */


	  Scope.prototype.setTransaction = function (name) {
	    return this.setTransactionName(name);
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setContext = function (key, context) {
	    var _a;

	    if (context === null) {
	      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
	      delete this._contexts[key];
	    } else {
	      this._contexts = __assign$3(__assign$3({}, this._contexts), (_a = {}, _a[key] = context, _a));
	    }

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setSpan = function (span) {
	    this._span = span;

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.getSpan = function () {
	    return this._span;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.getTransaction = function () {
	    // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
	    // have a pointer to the currently-active transaction.
	    var span = this.getSpan();
	    return span && span.transaction;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.setSession = function (session) {
	    if (!session) {
	      delete this._session;
	    } else {
	      this._session = session;
	    }

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.getSession = function () {
	    return this._session;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.update = function (captureContext) {
	    if (!captureContext) {
	      return this;
	    }

	    if (typeof captureContext === 'function') {
	      var updatedScope = captureContext(this);
	      return updatedScope instanceof Scope ? updatedScope : this;
	    }

	    if (captureContext instanceof Scope) {
	      this._tags = __assign$3(__assign$3({}, this._tags), captureContext._tags);
	      this._extra = __assign$3(__assign$3({}, this._extra), captureContext._extra);
	      this._contexts = __assign$3(__assign$3({}, this._contexts), captureContext._contexts);

	      if (captureContext._user && Object.keys(captureContext._user).length) {
	        this._user = captureContext._user;
	      }

	      if (captureContext._level) {
	        this._level = captureContext._level;
	      }

	      if (captureContext._fingerprint) {
	        this._fingerprint = captureContext._fingerprint;
	      }

	      if (captureContext._requestSession) {
	        this._requestSession = captureContext._requestSession;
	      }
	    } else if (isPlainObject(captureContext)) {
	      // eslint-disable-next-line no-param-reassign
	      captureContext = captureContext;
	      this._tags = __assign$3(__assign$3({}, this._tags), captureContext.tags);
	      this._extra = __assign$3(__assign$3({}, this._extra), captureContext.extra);
	      this._contexts = __assign$3(__assign$3({}, this._contexts), captureContext.contexts);

	      if (captureContext.user) {
	        this._user = captureContext.user;
	      }

	      if (captureContext.level) {
	        this._level = captureContext.level;
	      }

	      if (captureContext.fingerprint) {
	        this._fingerprint = captureContext.fingerprint;
	      }

	      if (captureContext.requestSession) {
	        this._requestSession = captureContext.requestSession;
	      }
	    }

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.clear = function () {
	    this._breadcrumbs = [];
	    this._tags = {};
	    this._extra = {};
	    this._user = {};
	    this._contexts = {};
	    this._level = undefined;
	    this._transactionName = undefined;
	    this._fingerprint = undefined;
	    this._requestSession = undefined;
	    this._span = undefined;
	    this._session = undefined;

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
	    var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS; // No data has been changed, so don't notify scope listeners

	    if (maxCrumbs <= 0) {
	      return this;
	    }

	    var mergedBreadcrumb = __assign$3({
	      timestamp: dateTimestampInSeconds()
	    }, breadcrumb);

	    this._breadcrumbs = __spread$3(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Scope.prototype.clearBreadcrumbs = function () {
	    this._breadcrumbs = [];

	    this._notifyScopeListeners();

	    return this;
	  };
	  /**
	   * Applies the current context and fingerprint to the event.
	   * Note that breadcrumbs will be added by the client.
	   * Also if the event has already breadcrumbs on it, we do not merge them.
	   * @param event Event
	   * @param hint May contain additional information about the original exception.
	   * @hidden
	   */


	  Scope.prototype.applyToEvent = function (event, hint) {
	    if (this._extra && Object.keys(this._extra).length) {
	      event.extra = __assign$3(__assign$3({}, this._extra), event.extra);
	    }

	    if (this._tags && Object.keys(this._tags).length) {
	      event.tags = __assign$3(__assign$3({}, this._tags), event.tags);
	    }

	    if (this._user && Object.keys(this._user).length) {
	      event.user = __assign$3(__assign$3({}, this._user), event.user);
	    }

	    if (this._contexts && Object.keys(this._contexts).length) {
	      event.contexts = __assign$3(__assign$3({}, this._contexts), event.contexts);
	    }

	    if (this._level) {
	      event.level = this._level;
	    }

	    if (this._transactionName) {
	      event.transaction = this._transactionName;
	    } // We want to set the trace context for normal events only if there isn't already
	    // a trace context on the event. There is a product feature in place where we link
	    // errors with transaction and it relies on that.


	    if (this._span) {
	      event.contexts = __assign$3({
	        trace: this._span.getTraceContext()
	      }, event.contexts);
	      var transactionName = this._span.transaction && this._span.transaction.name;

	      if (transactionName) {
	        event.tags = __assign$3({
	          transaction: transactionName
	        }, event.tags);
	      }
	    }

	    this._applyFingerprint(event);

	    event.breadcrumbs = __spread$3(event.breadcrumbs || [], this._breadcrumbs);
	    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
	    event.sdkProcessingMetadata = this._sdkProcessingMetadata;
	    return this._notifyEventProcessors(__spread$3(getGlobalEventProcessors(), this._eventProcessors), event, hint);
	  };
	  /**
	   * Add data which will be accessible during event processing but won't get sent to Sentry
	   */


	  Scope.prototype.setSDKProcessingMetadata = function (newData) {
	    this._sdkProcessingMetadata = __assign$3(__assign$3({}, this._sdkProcessingMetadata), newData);
	    return this;
	  };
	  /**
	   * This will be called after {@link applyToEvent} is finished.
	   */


	  Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
	    var _this = this;

	    if (index === void 0) {
	      index = 0;
	    }

	    return new SyncPromise(function (resolve, reject) {
	      var processor = processors[index];

	      if (event === null || typeof processor !== 'function') {
	        resolve(event);
	      } else {
	        var result = processor(__assign$3({}, event), hint);

	        if (isThenable(result)) {
	          void result.then(function (final) {
	            return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
	          }).then(null, reject);
	        } else {
	          void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
	        }
	      }
	    });
	  };
	  /**
	   * This will be called on every set call.
	   */


	  Scope.prototype._notifyScopeListeners = function () {
	    var _this = this; // We need this check for this._notifyingListeners to be able to work on scope during updates
	    // If this check is not here we'll produce endless recursion when something is done with the scope
	    // during the callback.


	    if (!this._notifyingListeners) {
	      this._notifyingListeners = true;

	      this._scopeListeners.forEach(function (callback) {
	        callback(_this);
	      });

	      this._notifyingListeners = false;
	    }
	  };
	  /**
	   * Applies fingerprint from the scope to the event if there's one,
	   * uses message if there's one instead or get rid of empty fingerprint
	   */


	  Scope.prototype._applyFingerprint = function (event) {
	    // Make sure it's an array first and we actually have something in place
	    event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : []; // If we have something on the scope, then merge it with event

	    if (this._fingerprint) {
	      event.fingerprint = event.fingerprint.concat(this._fingerprint);
	    } // If we have no data at all, remove empty array default


	    if (event.fingerprint && !event.fingerprint.length) {
	      delete event.fingerprint;
	    }
	  };

	  return Scope;
	}();
	/**
	 * Returns the global event processors.
	 */

	function getGlobalEventProcessors() {
	  return getGlobalSingleton('globalEventProcessors', function () {
	    return [];
	  });
	}
	/**
	 * Add a EventProcessor to be kept globally.
	 * @param callback EventProcessor to add
	 */


	function addGlobalEventProcessor(callback) {
	  getGlobalEventProcessors().push(callback);
	}

	/**
	 * @inheritdoc
	 */

	var Session =
	/** @class */
	function () {
	  function Session(context) {
	    this.errors = 0;
	    this.sid = uuid4();
	    this.duration = 0;
	    this.status = 'ok';
	    this.init = true;
	    this.ignoreDuration = false; // Both timestamp and started are in seconds since the UNIX epoch.

	    var startingTime = timestampInSeconds();
	    this.timestamp = startingTime;
	    this.started = startingTime;

	    if (context) {
	      this.update(context);
	    }
	  }
	  /** JSDoc */
	  // eslint-disable-next-line complexity


	  Session.prototype.update = function (context) {
	    if (context === void 0) {
	      context = {};
	    }

	    if (context.user) {
	      if (!this.ipAddress && context.user.ip_address) {
	        this.ipAddress = context.user.ip_address;
	      }

	      if (!this.did && !context.did) {
	        this.did = context.user.id || context.user.email || context.user.username;
	      }
	    }

	    this.timestamp = context.timestamp || timestampInSeconds();

	    if (context.ignoreDuration) {
	      this.ignoreDuration = context.ignoreDuration;
	    }

	    if (context.sid) {
	      // Good enough uuid validation.  Kamil
	      this.sid = context.sid.length === 32 ? context.sid : uuid4();
	    }

	    if (context.init !== undefined) {
	      this.init = context.init;
	    }

	    if (!this.did && context.did) {
	      this.did = "" + context.did;
	    }

	    if (typeof context.started === 'number') {
	      this.started = context.started;
	    }

	    if (this.ignoreDuration) {
	      this.duration = undefined;
	    } else if (typeof context.duration === 'number') {
	      this.duration = context.duration;
	    } else {
	      var duration = this.timestamp - this.started;
	      this.duration = duration >= 0 ? duration : 0;
	    }

	    if (context.release) {
	      this.release = context.release;
	    }

	    if (context.environment) {
	      this.environment = context.environment;
	    }

	    if (!this.ipAddress && context.ipAddress) {
	      this.ipAddress = context.ipAddress;
	    }

	    if (!this.userAgent && context.userAgent) {
	      this.userAgent = context.userAgent;
	    }

	    if (typeof context.errors === 'number') {
	      this.errors = context.errors;
	    }

	    if (context.status) {
	      this.status = context.status;
	    }
	  };
	  /** JSDoc */


	  Session.prototype.close = function (status) {
	    if (status) {
	      this.update({
	        status: status
	      });
	    } else if (this.status === 'ok') {
	      this.update({
	        status: 'exited'
	      });
	    } else {
	      this.update();
	    }
	  };
	  /** JSDoc */


	  Session.prototype.toJSON = function () {
	    return dropUndefinedKeys({
	      sid: "" + this.sid,
	      init: this.init,
	      // Make sure that sec is converted to ms for date constructor
	      started: new Date(this.started * 1000).toISOString(),
	      timestamp: new Date(this.timestamp * 1000).toISOString(),
	      status: this.status,
	      errors: this.errors,
	      did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
	      duration: this.duration,
	      attrs: {
	        release: this.release,
	        environment: this.environment,
	        ip_address: this.ipAddress,
	        user_agent: this.userAgent
	      }
	    });
	  };

	  return Session;
	}();

	/*
	 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
	 * for users.
	 *
	 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
	 * because some build tools have trouble tree-shaking imported guards.
	 *
	 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
	 *
	 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
	 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
	 * replaced.
	 */

	/** Flag that is true for debug builds, false otherwise. */
	var IS_DEBUG_BUILD$3 = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

	/**
	 * API compatibility version of this hub.
	 *
	 * WARNING: This number should only be increased when the global interface
	 * changes and new methods are introduced.
	 *
	 * @hidden
	 */

	var API_VERSION = 4;
	/**
	 * Default maximum number of breadcrumbs added to an event. Can be overwritten
	 * with {@link Options.maxBreadcrumbs}.
	 */

	var DEFAULT_BREADCRUMBS = 100;
	/**
	 * @inheritDoc
	 */

	var Hub =
	/** @class */
	function () {
	  /**
	   * Creates a new instance of the hub, will push one {@link Layer} into the
	   * internal stack on creation.
	   *
	   * @param client bound to the hub.
	   * @param scope bound to the hub.
	   * @param version number, higher number means higher priority.
	   */
	  function Hub(client, scope, _version) {
	    if (scope === void 0) {
	      scope = new Scope();
	    }

	    if (_version === void 0) {
	      _version = API_VERSION;
	    }

	    this._version = _version;
	    /** Is a {@link Layer}[] containing the client and scope */

	    this._stack = [{}];
	    this.getStackTop().scope = scope;

	    if (client) {
	      this.bindClient(client);
	    }
	  }
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.isOlderThan = function (version) {
	    return this._version < version;
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.bindClient = function (client) {
	    var top = this.getStackTop();
	    top.client = client;

	    if (client && client.setupIntegrations) {
	      client.setupIntegrations();
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.pushScope = function () {
	    // We want to clone the content of prev scope
	    var scope = Scope.clone(this.getScope());
	    this.getStack().push({
	      client: this.getClient(),
	      scope: scope
	    });
	    return scope;
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.popScope = function () {
	    if (this.getStack().length <= 1) return false;
	    return !!this.getStack().pop();
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.withScope = function (callback) {
	    var scope = this.pushScope();

	    try {
	      callback(scope);
	    } finally {
	      this.popScope();
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.getClient = function () {
	    return this.getStackTop().client;
	  };
	  /** Returns the scope of the top stack. */


	  Hub.prototype.getScope = function () {
	    return this.getStackTop().scope;
	  };
	  /** Returns the scope stack for domains or the process. */


	  Hub.prototype.getStack = function () {
	    return this._stack;
	  };
	  /** Returns the topmost scope layer in the order domain > local > process. */


	  Hub.prototype.getStackTop = function () {
	    return this._stack[this._stack.length - 1];
	  };
	  /**
	   * @inheritDoc
	   */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


	  Hub.prototype.captureException = function (exception, hint) {
	    var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
	    var finalHint = hint; // If there's no explicit hint provided, mimic the same thing that would happen
	    // in the minimal itself to create a consistent behavior.
	    // We don't do this in the client, as it's the lowest level API, and doing this,
	    // would prevent user from having full control over direct calls.

	    if (!hint) {
	      var syntheticException = void 0;

	      try {
	        throw new Error('Sentry syntheticException');
	      } catch (exception) {
	        syntheticException = exception;
	      }

	      finalHint = {
	        originalException: exception,
	        syntheticException: syntheticException
	      };
	    }

	    this._invokeClient('captureException', exception, __assign$3(__assign$3({}, finalHint), {
	      event_id: eventId
	    }));

	    return eventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.captureMessage = function (message, level, hint) {
	    var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
	    var finalHint = hint; // If there's no explicit hint provided, mimic the same thing that would happen
	    // in the minimal itself to create a consistent behavior.
	    // We don't do this in the client, as it's the lowest level API, and doing this,
	    // would prevent user from having full control over direct calls.

	    if (!hint) {
	      var syntheticException = void 0;

	      try {
	        throw new Error(message);
	      } catch (exception) {
	        syntheticException = exception;
	      }

	      finalHint = {
	        originalException: message,
	        syntheticException: syntheticException
	      };
	    }

	    this._invokeClient('captureMessage', message, level, __assign$3(__assign$3({}, finalHint), {
	      event_id: eventId
	    }));

	    return eventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.captureEvent = function (event, hint) {
	    var eventId = hint && hint.event_id ? hint.event_id : uuid4();

	    if (event.type !== 'transaction') {
	      this._lastEventId = eventId;
	    }

	    this._invokeClient('captureEvent', event, __assign$3(__assign$3({}, hint), {
	      event_id: eventId
	    }));

	    return eventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.lastEventId = function () {
	    return this._lastEventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
	    var _a = this.getStackTop(),
	        scope = _a.scope,
	        client = _a.client;

	    if (!scope || !client) return; // eslint-disable-next-line @typescript-eslint/unbound-method

	    var _b = client.getOptions && client.getOptions() || {},
	        _c = _b.beforeBreadcrumb,
	        beforeBreadcrumb = _c === void 0 ? null : _c,
	        _d = _b.maxBreadcrumbs,
	        maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;

	    if (maxBreadcrumbs <= 0) return;
	    var timestamp = dateTimestampInSeconds();

	    var mergedBreadcrumb = __assign$3({
	      timestamp: timestamp
	    }, breadcrumb);

	    var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(function () {
	      return beforeBreadcrumb(mergedBreadcrumb, hint);
	    }) : mergedBreadcrumb;
	    if (finalBreadcrumb === null) return;
	    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.setUser = function (user) {
	    var scope = this.getScope();
	    if (scope) scope.setUser(user);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.setTags = function (tags) {
	    var scope = this.getScope();
	    if (scope) scope.setTags(tags);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.setExtras = function (extras) {
	    var scope = this.getScope();
	    if (scope) scope.setExtras(extras);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.setTag = function (key, value) {
	    var scope = this.getScope();
	    if (scope) scope.setTag(key, value);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.setExtra = function (key, extra) {
	    var scope = this.getScope();
	    if (scope) scope.setExtra(key, extra);
	  };
	  /**
	   * @inheritDoc
	   */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any


	  Hub.prototype.setContext = function (name, context) {
	    var scope = this.getScope();
	    if (scope) scope.setContext(name, context);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.configureScope = function (callback) {
	    var _a = this.getStackTop(),
	        scope = _a.scope,
	        client = _a.client;

	    if (scope && client) {
	      callback(scope);
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.run = function (callback) {
	    var oldHub = makeMain(this);

	    try {
	      callback(this);
	    } finally {
	      makeMain(oldHub);
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.getIntegration = function (integration) {
	    var client = this.getClient();
	    if (!client) return null;

	    try {
	      return client.getIntegration(integration);
	    } catch (_oO) {
	      IS_DEBUG_BUILD$3 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
	      return null;
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.startSpan = function (context) {
	    return this._callExtensionMethod('startSpan', context);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.startTransaction = function (context, customSamplingContext) {
	    return this._callExtensionMethod('startTransaction', context, customSamplingContext);
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.traceHeaders = function () {
	    return this._callExtensionMethod('traceHeaders');
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.captureSession = function (endSession) {
	    if (endSession === void 0) {
	      endSession = false;
	    } // both send the update and pull the session from the scope


	    if (endSession) {
	      return this.endSession();
	    } // only send the update


	    this._sendSessionUpdate();
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.endSession = function () {
	    var layer = this.getStackTop();
	    var scope = layer && layer.scope;
	    var session = scope && scope.getSession();

	    if (session) {
	      session.close();
	    }

	    this._sendSessionUpdate(); // the session is over; take it off of the scope


	    if (scope) {
	      scope.setSession();
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Hub.prototype.startSession = function (context) {
	    var _a = this.getStackTop(),
	        scope = _a.scope,
	        client = _a.client;

	    var _b = client && client.getOptions() || {},
	        release = _b.release,
	        environment = _b.environment; // Will fetch userAgent if called from browser sdk


	    var global = getGlobalObject();
	    var userAgent = (global.navigator || {}).userAgent;
	    var session = new Session(__assign$3(__assign$3(__assign$3({
	      release: release,
	      environment: environment
	    }, scope && {
	      user: scope.getUser()
	    }), userAgent && {
	      userAgent: userAgent
	    }), context));

	    if (scope) {
	      // End existing session if there's one
	      var currentSession = scope.getSession && scope.getSession();

	      if (currentSession && currentSession.status === 'ok') {
	        currentSession.update({
	          status: 'exited'
	        });
	      }

	      this.endSession(); // Afterwards we set the new session on the scope

	      scope.setSession(session);
	    }

	    return session;
	  };
	  /**
	   * Sends the current Session on the scope
	   */


	  Hub.prototype._sendSessionUpdate = function () {
	    var _a = this.getStackTop(),
	        scope = _a.scope,
	        client = _a.client;

	    if (!scope) return;
	    var session = scope.getSession && scope.getSession();

	    if (session) {
	      if (client && client.captureSession) {
	        client.captureSession(session);
	      }
	    }
	  };
	  /**
	   * Internal helper function to call a method on the top client if it exists.
	   *
	   * @param method The method to call on the client.
	   * @param args Arguments to pass to the client function.
	   */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any


	  Hub.prototype._invokeClient = function (method) {
	    var _a;

	    var args = [];

	    for (var _i = 1; _i < arguments.length; _i++) {
	      args[_i - 1] = arguments[_i];
	    }

	    var _b = this.getStackTop(),
	        scope = _b.scope,
	        client = _b.client;

	    if (client && client[method]) {
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
	      (_a = client)[method].apply(_a, __spread$3(args, [scope]));
	    }
	  };
	  /**
	   * Calls global extension method and binding current instance to the function call
	   */
	  // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any


	  Hub.prototype._callExtensionMethod = function (method) {
	    var args = [];

	    for (var _i = 1; _i < arguments.length; _i++) {
	      args[_i - 1] = arguments[_i];
	    }

	    var carrier = getMainCarrier();
	    var sentry = carrier.__SENTRY__;

	    if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
	      return sentry.extensions[method].apply(this, args);
	    }

	    IS_DEBUG_BUILD$3 && logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
	  };

	  return Hub;
	}();
	/**
	 * Returns the global shim registry.
	 *
	 * FIXME: This function is problematic, because despite always returning a valid Carrier,
	 * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
	 * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
	 **/

	function getMainCarrier() {
	  var carrier = getGlobalObject();
	  carrier.__SENTRY__ = carrier.__SENTRY__ || {
	    extensions: {},
	    hub: undefined
	  };
	  return carrier;
	}
	/**
	 * Replaces the current main hub with the passed one on the global object
	 *
	 * @returns The old replaced hub
	 */

	function makeMain(hub) {
	  var registry = getMainCarrier();
	  var oldHub = getHubFromCarrier(registry);
	  setHubOnCarrier(registry, hub);
	  return oldHub;
	}
	/**
	 * Returns the default hub instance.
	 *
	 * If a hub is already registered in the global carrier but this module
	 * contains a more recent version, it replaces the registered version.
	 * Otherwise, the currently registered hub will be returned.
	 */

	function getCurrentHub() {
	  // Get main carrier (global for every environment)
	  var registry = getMainCarrier(); // If there's no hub, or its an old API, assign a new one

	  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
	    setHubOnCarrier(registry, new Hub());
	  } // Prefer domains over global if they are there (applicable only to Node environment)


	  if (isNodeEnv()) {
	    return getHubFromActiveDomain(registry);
	  } // Return hub that lives on a global object


	  return getHubFromCarrier(registry);
	}
	/**
	 * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
	 * @returns discovered hub
	 */

	function getHubFromActiveDomain(registry) {
	  try {
	    var sentry = getMainCarrier().__SENTRY__;

	    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active; // If there's no active domain, just return global hub

	    if (!activeDomain) {
	      return getHubFromCarrier(registry);
	    } // If there's no hub on current domain, or it's an old API, assign a new one


	    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
	      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
	      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
	    } // Return hub that lives on a domain


	    return getHubFromCarrier(activeDomain);
	  } catch (_Oo) {
	    // Return hub that lives on a global object
	    return getHubFromCarrier(registry);
	  }
	}
	/**
	 * This will tell whether a carrier has a hub on it or not
	 * @param carrier object
	 */


	function hasHubOnCarrier(carrier) {
	  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
	}
	/**
	 * This will create a new {@link Hub} and add to the passed object on
	 * __SENTRY__.hub.
	 * @param carrier object
	 * @hidden
	 */


	function getHubFromCarrier(carrier) {
	  return getGlobalSingleton('hub', function () {
	    return new Hub();
	  }, carrier);
	}
	/**
	 * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
	 * @param carrier object
	 * @param hub Hub
	 * @returns A boolean indicating success or failure
	 */

	function setHubOnCarrier(carrier, hub) {
	  if (!carrier) return false;

	  var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};

	  __SENTRY__.hub = hub;
	  return true;
	}

	/**
	 * This calls a function on the current hub.
	 * @param method function to call on hub.
	 * @param args to pass to function.
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any

	function callOnHub(method) {
	  var args = [];

	  for (var _i = 1; _i < arguments.length; _i++) {
	    args[_i - 1] = arguments[_i];
	  }

	  var hub = getCurrentHub();

	  if (hub && hub[method]) {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    return hub[method].apply(hub, __spread$4(args));
	  }

	  throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
	}
	/**
	 * Captures an exception event and sends it to Sentry.
	 *
	 * @param exception An exception-like object.
	 * @returns The generated eventId.
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


	function captureException(exception, captureContext) {
	  var syntheticException = new Error('Sentry syntheticException');
	  return callOnHub('captureException', exception, {
	    captureContext: captureContext,
	    originalException: exception,
	    syntheticException: syntheticException
	  });
	}
	/**
	 * Set key:value that will be sent as tags data with the event.
	 *
	 * Can also be used to unset a tag, by passing `undefined`.
	 *
	 * @param key String key of tag
	 * @param value Value of tag
	 */

	function setTag(key, value) {
	  callOnHub('setTag', key, value);
	}
	/**
	 * Creates a new scope with and executes the given operation within.
	 * The scope is automatically removed once the operation
	 * finishes or throws.
	 *
	 * This is essentially a convenience function for:
	 *
	 *     pushScope();
	 *     callback();
	 *     popScope();
	 *
	 * @param callback that will be enclosed into push/popScope.
	 */

	function withScope(callback) {
	  callOnHub('withScope', callback);
	}

	var SENTRY_API_VERSION = '7';
	/** Initializes API Details */

	function initAPIDetails(dsn, metadata, tunnel) {
	  return {
	    initDsn: dsn,
	    metadata: metadata || {},
	    dsn: makeDsn(dsn),
	    tunnel: tunnel
	  };
	}
	/** Returns the prefix to construct Sentry ingestion API endpoints. */

	function getBaseApiEndpoint(dsn) {
	  var protocol = dsn.protocol ? dsn.protocol + ":" : '';
	  var port = dsn.port ? ":" + dsn.port : '';
	  return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : '') + "/api/";
	}
	/** Returns the ingest API endpoint for target. */


	function _getIngestEndpoint(dsn, target) {
	  return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
	}
	/** Returns a URL-encoded string with auth config suitable for a query string. */


	function _encodedAuth(dsn) {
	  return urlEncode({
	    // We send only the minimum set of required information. See
	    // https://github.com/getsentry/sentry-javascript/issues/2572.
	    sentry_key: dsn.publicKey,
	    sentry_version: SENTRY_API_VERSION
	  });
	}
	/** Returns the store endpoint URL. */


	function getStoreEndpoint(dsn) {
	  return _getIngestEndpoint(dsn, 'store');
	}
	/**
	 * Returns the store endpoint URL with auth in the query string.
	 *
	 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
	 */


	function getStoreEndpointWithUrlEncodedAuth(dsn) {
	  return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
	}
	/** Returns the envelope endpoint URL. */

	function _getEnvelopeEndpoint(dsn) {
	  return _getIngestEndpoint(dsn, 'envelope');
	}
	/**
	 * Returns the envelope endpoint URL with auth in the query string.
	 *
	 * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
	 */


	function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
	  return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
	}
	/** Returns the url to the report dialog endpoint. */

	function getReportDialogEndpoint(dsnLike, dialogOptions) {
	  var dsn = makeDsn(dsnLike);
	  var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
	  var encodedOptions = "dsn=" + dsnToString(dsn);

	  for (var key in dialogOptions) {
	    if (key === 'dsn') {
	      continue;
	    }

	    if (key === 'user') {
	      if (!dialogOptions.user) {
	        continue;
	      }

	      if (dialogOptions.user.name) {
	        encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
	      }

	      if (dialogOptions.user.email) {
	        encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
	      }
	    } else {
	      encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
	    }
	  }

	  return endpoint + "?" + encodedOptions;
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	var __assign$1 = function () {
	  __assign$1 = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign$1.apply(this, arguments);
	};
	function __values$1(o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	      m = s && o[s],
	      i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function () {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	function __read$1(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread$1() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));

	  return ar;
	}

	/*
	 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
	 * for users.
	 *
	 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
	 * because some build tools have trouble tree-shaking imported guards.
	 *
	 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
	 *
	 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
	 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
	 * replaced.
	 */

	/** Flag that is true for debug builds, false otherwise. */
	var IS_DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

	var installedIntegrations = [];
	/**
	 * @private
	 */

	function filterDuplicates(integrations) {
	  return integrations.reduce(function (acc, integrations) {
	    if (acc.every(function (accIntegration) {
	      return integrations.name !== accIntegration.name;
	    })) {
	      acc.push(integrations);
	    }

	    return acc;
	  }, []);
	}
	/** Gets integration to install */


	function getIntegrationsToSetup(options) {
	  var defaultIntegrations = options.defaultIntegrations && __spread$1(options.defaultIntegrations) || [];
	  var userIntegrations = options.integrations;

	  var integrations = __spread$1(filterDuplicates(defaultIntegrations));

	  if (Array.isArray(userIntegrations)) {
	    // Filter out integrations that are also included in user options
	    integrations = __spread$1(integrations.filter(function (integrations) {
	      return userIntegrations.every(function (userIntegration) {
	        return userIntegration.name !== integrations.name;
	      });
	    }), filterDuplicates(userIntegrations));
	  } else if (typeof userIntegrations === 'function') {
	    integrations = userIntegrations(integrations);
	    integrations = Array.isArray(integrations) ? integrations : [integrations];
	  } // Make sure that if present, `Debug` integration will always run last


	  var integrationsNames = integrations.map(function (i) {
	    return i.name;
	  });
	  var alwaysLastToRun = 'Debug';

	  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
	    integrations.push.apply(integrations, __spread$1(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
	  }

	  return integrations;
	}
	/** Setup given integration */

	function setupIntegration(integration) {
	  if (installedIntegrations.indexOf(integration.name) !== -1) {
	    return;
	  }

	  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
	  installedIntegrations.push(integration.name);
	  IS_DEBUG_BUILD$2 && logger.log("Integration installed: " + integration.name);
	}
	/**
	 * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
	 * integrations are added unless they were already provided before.
	 * @param integrations array of integration instances
	 * @param withDefault should enable default integrations
	 */

	function setupIntegrations(options) {
	  var integrations = {};
	  getIntegrationsToSetup(options).forEach(function (integration) {
	    integrations[integration.name] = integration;
	    setupIntegration(integration);
	  }); // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`
	  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be
	  // considered a member of the index the way the actual integrations are

	  addNonEnumerableProperty(integrations, 'initialized', true);
	  return integrations;
	}

	var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
	/**
	 * Base implementation for all JavaScript SDK clients.
	 *
	 * Call the constructor with the corresponding backend constructor and options
	 * specific to the client subclass. To access these options later, use
	 * {@link Client.getOptions}. Also, the Backend instance is available via
	 * {@link Client.getBackend}.
	 *
	 * If a Dsn is specified in the options, it will be parsed and stored. Use
	 * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
	 * invalid, the constructor will throw a {@link SentryException}. Note that
	 * without a valid Dsn, the SDK will not send any events to Sentry.
	 *
	 * Before sending an event via the backend, it is passed through
	 * {@link BaseClient._prepareEvent} to add SDK information and scope data
	 * (breadcrumbs and context). To add more custom information, override this
	 * method and extend the resulting prepared event.
	 *
	 * To issue automatically created events (e.g. via instrumentation), use
	 * {@link Client.captureEvent}. It will prepare the event and pass it through
	 * the callback lifecycle. To issue auto-breadcrumbs, use
	 * {@link Client.addBreadcrumb}.
	 *
	 * @example
	 * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
	 *   public constructor(options: NodeOptions) {
	 *     super(NodeBackend, options);
	 *   }
	 *
	 *   // ...
	 * }
	 */

	var BaseClient =
	/** @class */
	function () {
	  /**
	   * Initializes this client instance.
	   *
	   * @param backendClass A constructor function to create the backend.
	   * @param options Options for the client.
	   */
	  function BaseClient(backendClass, options) {
	    /** Array of used integrations. */
	    this._integrations = {};
	    /** Number of calls being processed */

	    this._numProcessing = 0;
	    this._backend = new backendClass(options);
	    this._options = options;

	    if (options.dsn) {
	      this._dsn = makeDsn(options.dsn);
	    }
	  }
	  /**
	   * @inheritDoc
	   */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


	  BaseClient.prototype.captureException = function (exception, hint, scope) {
	    var _this = this; // ensure we haven't captured this very object before


	    if (checkOrSetAlreadyCaught(exception)) {
	      IS_DEBUG_BUILD$2 && logger.log(ALREADY_SEEN_ERROR);
	      return;
	    }

	    var eventId = hint && hint.event_id;

	    this._process(this._getBackend().eventFromException(exception, hint).then(function (event) {
	      return _this._captureEvent(event, hint, scope);
	    }).then(function (result) {
	      eventId = result;
	    }));

	    return eventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.captureMessage = function (message, level, hint, scope) {
	    var _this = this;

	    var eventId = hint && hint.event_id;
	    var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);

	    this._process(promisedEvent.then(function (event) {
	      return _this._captureEvent(event, hint, scope);
	    }).then(function (result) {
	      eventId = result;
	    }));

	    return eventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.captureEvent = function (event, hint, scope) {
	    // ensure we haven't captured this very object before
	    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
	      IS_DEBUG_BUILD$2 && logger.log(ALREADY_SEEN_ERROR);
	      return;
	    }

	    var eventId = hint && hint.event_id;

	    this._process(this._captureEvent(event, hint, scope).then(function (result) {
	      eventId = result;
	    }));

	    return eventId;
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.captureSession = function (session) {
	    if (!this._isEnabled()) {
	      IS_DEBUG_BUILD$2 && logger.warn('SDK not enabled, will not capture session.');
	      return;
	    }

	    if (!(typeof session.release === 'string')) {
	      IS_DEBUG_BUILD$2 && logger.warn('Discarded session because of missing or non-string release');
	    } else {
	      this._sendSession(session); // After sending, we set init false to indicate it's not the first occurrence


	      session.update({
	        init: false
	      });
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.getDsn = function () {
	    return this._dsn;
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.getOptions = function () {
	    return this._options;
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.getTransport = function () {
	    return this._getBackend().getTransport();
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.flush = function (timeout) {
	    var _this = this;

	    return this._isClientDoneProcessing(timeout).then(function (clientFinished) {
	      return _this.getTransport().close(timeout).then(function (transportFlushed) {
	        return clientFinished && transportFlushed;
	      });
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.close = function (timeout) {
	    var _this = this;

	    return this.flush(timeout).then(function (result) {
	      _this.getOptions().enabled = false;
	      return result;
	    });
	  };
	  /**
	   * Sets up the integrations
	   */


	  BaseClient.prototype.setupIntegrations = function () {
	    if (this._isEnabled() && !this._integrations.initialized) {
	      this._integrations = setupIntegrations(this._options);
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseClient.prototype.getIntegration = function (integration) {
	    try {
	      return this._integrations[integration.id] || null;
	    } catch (_oO) {
	      IS_DEBUG_BUILD$2 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
	      return null;
	    }
	  };
	  /** Updates existing session based on the provided event */


	  BaseClient.prototype._updateSessionFromEvent = function (session, event) {
	    var e_1, _a;

	    var crashed = false;
	    var errored = false;
	    var exceptions = event.exception && event.exception.values;

	    if (exceptions) {
	      errored = true;

	      try {
	        for (var exceptions_1 = __values$1(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
	          var ex = exceptions_1_1.value;
	          var mechanism = ex.mechanism;

	          if (mechanism && mechanism.handled === false) {
	            crashed = true;
	            break;
	          }
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	    } // A session is updated and that session update is sent in only one of the two following scenarios:
	    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
	    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update


	    var sessionNonTerminal = session.status === 'ok';
	    var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;

	    if (shouldUpdateAndSend) {
	      session.update(__assign$1(__assign$1({}, crashed && {
	        status: 'crashed'
	      }), {
	        errors: session.errors || Number(errored || crashed)
	      }));
	      this.captureSession(session);
	    }
	  };
	  /** Deliver captured session to Sentry */


	  BaseClient.prototype._sendSession = function (session) {
	    this._getBackend().sendSession(session);
	  };
	  /**
	   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
	   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
	   *
	   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
	   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
	   * `true`.
	   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
	   * `false` otherwise
	   */


	  BaseClient.prototype._isClientDoneProcessing = function (timeout) {
	    var _this = this;

	    return new SyncPromise(function (resolve) {
	      var ticked = 0;
	      var tick = 1;
	      var interval = setInterval(function () {
	        if (_this._numProcessing == 0) {
	          clearInterval(interval);
	          resolve(true);
	        } else {
	          ticked += tick;

	          if (timeout && ticked >= timeout) {
	            clearInterval(interval);
	            resolve(false);
	          }
	        }
	      }, tick);
	    });
	  };
	  /** Returns the current backend. */


	  BaseClient.prototype._getBackend = function () {
	    return this._backend;
	  };
	  /** Determines whether this SDK is enabled and a valid Dsn is present. */


	  BaseClient.prototype._isEnabled = function () {
	    return this.getOptions().enabled !== false && this._dsn !== undefined;
	  };
	  /**
	   * Adds common information to events.
	   *
	   * The information includes release and environment from `options`,
	   * breadcrumbs and context (extra, tags and user) from the scope.
	   *
	   * Information that is already present in the event is never overwritten. For
	   * nested objects, such as the context, keys are merged.
	   *
	   * @param event The original event.
	   * @param hint May contain additional information about the original exception.
	   * @param scope A scope containing event metadata.
	   * @returns A new event with more information.
	   */


	  BaseClient.prototype._prepareEvent = function (event, scope, hint) {
	    var _this = this;

	    var _a = this.getOptions(),
	        _b = _a.normalizeDepth,
	        normalizeDepth = _b === void 0 ? 3 : _b,
	        _c = _a.normalizeMaxBreadth,
	        normalizeMaxBreadth = _c === void 0 ? 1000 : _c;

	    var prepared = __assign$1(__assign$1({}, event), {
	      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),
	      timestamp: event.timestamp || dateTimestampInSeconds()
	    });

	    this._applyClientOptions(prepared);

	    this._applyIntegrationsMetadata(prepared); // If we have scope given to us, use it as the base for further modifications.
	    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.


	    var finalScope = scope;

	    if (hint && hint.captureContext) {
	      finalScope = Scope.clone(finalScope).update(hint.captureContext);
	    } // We prepare the result here with a resolved Event.


	    var result = resolvedSyncPromise(prepared); // This should be the last thing called, since we want that
	    // {@link Hub.addEventProcessor} gets the finished prepared event.

	    if (finalScope) {
	      // In case we have a hub we reassign it.
	      result = finalScope.applyToEvent(prepared, hint);
	    }

	    return result.then(function (evt) {
	      if (evt) {
	        // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809
	        // it is only attached as extra data to the event if the event somehow skips being normalized
	        evt.sdkProcessingMetadata = __assign$1(__assign$1({}, evt.sdkProcessingMetadata), {
	          normalizeDepth: normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")"
	        });
	      }

	      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
	        return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
	      }

	      return evt;
	    });
	  };
	  /**
	   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
	   * Normalized keys:
	   * - `breadcrumbs.data`
	   * - `user`
	   * - `contexts`
	   * - `extra`
	   * @param event Event
	   * @returns Normalized event
	   */


	  BaseClient.prototype._normalizeEvent = function (event, depth, maxBreadth) {
	    if (!event) {
	      return null;
	    }

	    var normalized = __assign$1(__assign$1(__assign$1(__assign$1(__assign$1({}, event), event.breadcrumbs && {
	      breadcrumbs: event.breadcrumbs.map(function (b) {
	        return __assign$1(__assign$1({}, b), b.data && {
	          data: normalize(b.data, depth, maxBreadth)
	        });
	      })
	    }), event.user && {
	      user: normalize(event.user, depth, maxBreadth)
	    }), event.contexts && {
	      contexts: normalize(event.contexts, depth, maxBreadth)
	    }), event.extra && {
	      extra: normalize(event.extra, depth, maxBreadth)
	    }); // event.contexts.trace stores information about a Transaction. Similarly,
	    // event.spans[] stores information about child Spans. Given that a
	    // Transaction is conceptually a Span, normalization should apply to both
	    // Transactions and Spans consistently.
	    // For now the decision is to skip normalization of Transactions and Spans,
	    // so this block overwrites the normalized event to add back the original
	    // Transaction information prior to normalization.


	    if (event.contexts && event.contexts.trace) {
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	      normalized.contexts.trace = event.contexts.trace;
	    }

	    normalized.sdkProcessingMetadata = __assign$1(__assign$1({}, normalized.sdkProcessingMetadata), {
	      baseClientNormalized: true
	    });
	    return normalized;
	  };
	  /**
	   *  Enhances event using the client configuration.
	   *  It takes care of all "static" values like environment, release and `dist`,
	   *  as well as truncating overly long values.
	   * @param event event instance to be enhanced
	   */


	  BaseClient.prototype._applyClientOptions = function (event) {
	    var options = this.getOptions();
	    var environment = options.environment,
	        release = options.release,
	        dist = options.dist,
	        _a = options.maxValueLength,
	        maxValueLength = _a === void 0 ? 250 : _a;

	    if (!('environment' in event)) {
	      event.environment = 'environment' in options ? environment : 'production';
	    }

	    if (event.release === undefined && release !== undefined) {
	      event.release = release;
	    }

	    if (event.dist === undefined && dist !== undefined) {
	      event.dist = dist;
	    }

	    if (event.message) {
	      event.message = truncate(event.message, maxValueLength);
	    }

	    var exception = event.exception && event.exception.values && event.exception.values[0];

	    if (exception && exception.value) {
	      exception.value = truncate(exception.value, maxValueLength);
	    }

	    var request = event.request;

	    if (request && request.url) {
	      request.url = truncate(request.url, maxValueLength);
	    }
	  };
	  /**
	   * This function adds all used integrations to the SDK info in the event.
	   * @param event The event that will be filled with all integrations.
	   */


	  BaseClient.prototype._applyIntegrationsMetadata = function (event) {
	    var integrationsArray = Object.keys(this._integrations);

	    if (integrationsArray.length > 0) {
	      event.sdk = event.sdk || {};
	      event.sdk.integrations = __spread$1(event.sdk.integrations || [], integrationsArray);
	    }
	  };
	  /**
	   * Tells the backend to send this event
	   * @param event The Sentry event to send
	   */


	  BaseClient.prototype._sendEvent = function (event) {
	    this._getBackend().sendEvent(event);
	  };
	  /**
	   * Processes the event and logs an error in case of rejection
	   * @param event
	   * @param hint
	   * @param scope
	   */


	  BaseClient.prototype._captureEvent = function (event, hint, scope) {
	    return this._processEvent(event, hint, scope).then(function (finalEvent) {
	      return finalEvent.event_id;
	    }, function (reason) {
	      IS_DEBUG_BUILD$2 && logger.error(reason);
	      return undefined;
	    });
	  };
	  /**
	   * Processes an event (either error or message) and sends it to Sentry.
	   *
	   * This also adds breadcrumbs and context information to the event. However,
	   * platform specific meta data (such as the User's IP address) must be added
	   * by the SDK implementor.
	   *
	   *
	   * @param event The event to send to Sentry.
	   * @param hint May contain additional information about the original exception.
	   * @param scope A scope containing event metadata.
	   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
	   */


	  BaseClient.prototype._processEvent = function (event, hint, scope) {
	    var _this = this; // eslint-disable-next-line @typescript-eslint/unbound-method


	    var _a = this.getOptions(),
	        beforeSend = _a.beforeSend,
	        sampleRate = _a.sampleRate;

	    var transport = this.getTransport();

	    function recordLostEvent(outcome, category) {
	      if (transport.recordLostEvent) {
	        transport.recordLostEvent(outcome, category);
	      }
	    }

	    if (!this._isEnabled()) {
	      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.'));
	    }

	    var isTransaction = event.type === 'transaction'; // 1.0 === 100% events are sent
	    // 0.0 === 0% events are sent
	    // Sampling for transaction happens somewhere else

	    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
	      recordLostEvent('sample_rate', 'event');
	      return rejectedSyncPromise(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
	    }

	    return this._prepareEvent(event, scope, hint).then(function (prepared) {
	      if (prepared === null) {
	        recordLostEvent('event_processor', event.type || 'event');
	        throw new SentryError('An event processor returned null, will not send event.');
	      }

	      var isInternalException = hint && hint.data && hint.data.__sentry__ === true;

	      if (isInternalException || isTransaction || !beforeSend) {
	        return prepared;
	      }

	      var beforeSendResult = beforeSend(prepared, hint);
	      return _ensureBeforeSendRv(beforeSendResult);
	    }).then(function (processedEvent) {
	      if (processedEvent === null) {
	        recordLostEvent('before_send', event.type || 'event');
	        throw new SentryError('`beforeSend` returned `null`, will not send event.');
	      }

	      var session = scope && scope.getSession && scope.getSession();

	      if (!isTransaction && session) {
	        _this._updateSessionFromEvent(session, processedEvent);
	      }

	      _this._sendEvent(processedEvent);

	      return processedEvent;
	    }).then(null, function (reason) {
	      if (reason instanceof SentryError) {
	        throw reason;
	      }

	      _this.captureException(reason, {
	        data: {
	          __sentry__: true
	        },
	        originalException: reason
	      });

	      throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
	    });
	  };
	  /**
	   * Occupies the client with processing and event
	   */


	  BaseClient.prototype._process = function (promise) {
	    var _this = this;

	    this._numProcessing += 1;
	    void promise.then(function (value) {
	      _this._numProcessing -= 1;
	      return value;
	    }, function (reason) {
	      _this._numProcessing -= 1;
	      return reason;
	    });
	  };

	  return BaseClient;
	}();
	/**
	 * Verifies that return value of configured `beforeSend` is of expected type.
	 */

	function _ensureBeforeSendRv(rv) {
	  var nullErr = '`beforeSend` method has to return `null` or a valid event.';

	  if (isThenable(rv)) {
	    return rv.then(function (event) {
	      if (!(isPlainObject(event) || event === null)) {
	        throw new SentryError(nullErr);
	      }

	      return event;
	    }, function (e) {
	      throw new SentryError("beforeSend rejected with " + e);
	    });
	  } else if (!(isPlainObject(rv) || rv === null)) {
	    throw new SentryError(nullErr);
	  }

	  return rv;
	}

	/** Extract sdk info from from the API metadata */

	function getSdkMetadataForEnvelopeHeader(api) {
	  if (!api.metadata || !api.metadata.sdk) {
	    return;
	  }

	  var _a = api.metadata.sdk,
	      name = _a.name,
	      version = _a.version;
	  return {
	    name: name,
	    version: version
	  };
	}
	/**
	 * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
	 * Merge with existing data if any.
	 **/


	function enhanceEventWithSdkInfo(event, sdkInfo) {
	  if (!sdkInfo) {
	    return event;
	  }

	  event.sdk = event.sdk || {};
	  event.sdk.name = event.sdk.name || sdkInfo.name;
	  event.sdk.version = event.sdk.version || sdkInfo.version;
	  event.sdk.integrations = __spread$1(event.sdk.integrations || [], sdkInfo.integrations || []);
	  event.sdk.packages = __spread$1(event.sdk.packages || [], sdkInfo.packages || []);
	  return event;
	}
	/** Creates an envelope from a Session */


	function createSessionEnvelope(session, api) {
	  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);

	  var envelopeHeaders = __assign$1(__assign$1({
	    sent_at: new Date().toISOString()
	  }, sdkInfo && {
	    sdk: sdkInfo
	  }), !!api.tunnel && {
	    dsn: dsnToString(api.dsn)
	  }); // I know this is hacky but we don't want to add `sessions` to request type since it's never rate limited


	  var type = 'aggregates' in session ? 'sessions' : 'session'; // TODO (v7) Have to cast type because envelope items do not accept a `SentryRequestType`

	  var envelopeItem = [{
	    type: type
	  }, session];
	  var envelope = createEnvelope(envelopeHeaders, [envelopeItem]);
	  return [envelope, type];
	}
	/** Creates a SentryRequest from a Session. */

	function sessionToSentryRequest(session, api) {
	  var _a = __read$1(createSessionEnvelope(session, api), 2),
	      envelope = _a[0],
	      type = _a[1];

	  return {
	    body: serializeEnvelope(envelope),
	    type: type,
	    url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
	  };
	}
	/**
	 * Create an Envelope from an event. Note that this is duplicated from below,
	 * but on purpose as this will be refactored in v7.
	 */

	function createEventEnvelope(event, api) {
	  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
	  var eventType = event.type || 'event';
	  var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;

	  var _a = transactionSampling || {},
	      samplingMethod = _a.method,
	      sampleRate = _a.rate; // TODO: Below is a temporary hack in order to debug a serialization error - see
	  // https://github.com/getsentry/sentry-javascript/issues/2809,
	  // https://github.com/getsentry/sentry-javascript/pull/4425, and
	  // https://github.com/getsentry/sentry-javascript/pull/4574.
	  //
	  // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
	  // throw a circular reference error.
	  //
	  // When it's time to remove it:
	  // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
	  //    `sdkProcessingMetadata`
	  // 2. Restore the original version of the request body, which is commented out
	  // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
	  //    baseClient tests in this package


	  enhanceEventWithSdkInfo(event, api.metadata.sdk);
	  event.tags = event.tags || {};
	  event.extra = event.extra || {}; // In theory, all events should be marked as having gone through normalization and so
	  // we should never set this tag/extra data

	  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
	    event.tags.skippedNormalization = true;
	    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
	  } // prevent this data from being sent to sentry
	  // TODO: This is NOT part of the hack - DO NOT DELETE


	  delete event.sdkProcessingMetadata;

	  var envelopeHeaders = __assign$1(__assign$1({
	    event_id: event.event_id,
	    sent_at: new Date().toISOString()
	  }, sdkInfo && {
	    sdk: sdkInfo
	  }), !!api.tunnel && {
	    dsn: dsnToString(api.dsn)
	  });

	  var eventItem = [{
	    type: eventType,
	    sample_rates: [{
	      id: samplingMethod,
	      rate: sampleRate
	    }]
	  }, event];
	  return createEnvelope(envelopeHeaders, [eventItem]);
	}
	/** Creates a SentryRequest from an event. */

	function eventToSentryRequest(event, api) {
	  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
	  var eventType = event.type || 'event';
	  var useEnvelope = eventType === 'transaction' || !!api.tunnel;
	  var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;

	  var _a = transactionSampling || {},
	      samplingMethod = _a.method,
	      sampleRate = _a.rate; // TODO: Below is a temporary hack in order to debug a serialization error - see
	  // https://github.com/getsentry/sentry-javascript/issues/2809,
	  // https://github.com/getsentry/sentry-javascript/pull/4425, and
	  // https://github.com/getsentry/sentry-javascript/pull/4574.
	  //
	  // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
	  // throw a circular reference error.
	  //
	  // When it's time to remove it:
	  // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
	  //    `sdkProcessingMetadata`
	  // 2. Restore the original version of the request body, which is commented out
	  // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
	  //    baseClient tests in this package


	  enhanceEventWithSdkInfo(event, api.metadata.sdk);
	  event.tags = event.tags || {};
	  event.extra = event.extra || {}; // In theory, all events should be marked as having gone through normalization and so
	  // we should never set this tag/extra data

	  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
	    event.tags.skippedNormalization = true;
	    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
	  } // prevent this data from being sent to sentry
	  // TODO: This is NOT part of the hack - DO NOT DELETE


	  delete event.sdkProcessingMetadata;
	  var body;

	  try {
	    // 99.9% of events should get through just fine - no change in behavior for them
	    body = JSON.stringify(event);
	  } catch (err) {
	    // Record data about the error without replacing original event data, then force renormalization
	    event.tags.JSONStringifyError = true;
	    event.extra.JSONStringifyError = err;

	    try {
	      body = JSON.stringify(normalize(event));
	    } catch (newErr) {
	      // At this point even renormalization hasn't worked, meaning something about the event data has gone very wrong.
	      // Time to cut our losses and record only the new error. With luck, even in the problematic cases we're trying to
	      // debug with this hack, we won't ever land here.
	      var innerErr = newErr;
	      body = JSON.stringify({
	        message: 'JSON.stringify error after renormalization',
	        // setting `extra: { innerErr }` here for some reason results in an empty object, so unpack manually
	        extra: {
	          message: innerErr.message,
	          stack: innerErr.stack
	        }
	      });
	    }
	  }

	  var req = {
	    // this is the relevant line of code before the hack was added, to make it easy to undo said hack once we've solved
	    // the mystery
	    // body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
	    body: body,
	    type: eventType,
	    url: useEnvelope ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel) : getStoreEndpointWithUrlEncodedAuth(api.dsn)
	  }; // https://develop.sentry.dev/sdk/envelopes/
	  // Since we don't need to manipulate envelopes nor store them, there is no
	  // exported concept of an Envelope with operations including serialization and
	  // deserialization. Instead, we only implement a minimal subset of the spec to
	  // serialize events inline here.

	  if (useEnvelope) {
	    var envelopeHeaders = __assign$1(__assign$1({
	      event_id: event.event_id,
	      sent_at: new Date().toISOString()
	    }, sdkInfo && {
	      sdk: sdkInfo
	    }), !!api.tunnel && {
	      dsn: dsnToString(api.dsn)
	    });

	    var eventItem = [{
	      type: eventType,
	      sample_rates: [{
	        id: samplingMethod,
	        rate: sampleRate
	      }]
	    }, req.body];
	    var envelope = createEnvelope(envelopeHeaders, [eventItem]);
	    req.body = serializeEnvelope(envelope);
	  }

	  return req;
	}

	/** Noop transport */

	var NoopTransport =
	/** @class */
	function () {
	  function NoopTransport() {}
	  /**
	   * @inheritDoc
	   */


	  NoopTransport.prototype.sendEvent = function (_) {
	    return resolvedSyncPromise({
	      reason: 'NoopTransport: Event has been skipped because no Dsn is configured.',
	      status: 'skipped'
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  NoopTransport.prototype.close = function (_) {
	    return resolvedSyncPromise(true);
	  };

	  return NoopTransport;
	}();

	/**
	 * This is the base implemention of a Backend.
	 * @hidden
	 */

	var BaseBackend =
	/** @class */
	function () {
	  /** Creates a new backend instance. */
	  function BaseBackend(options) {
	    this._options = options;

	    if (!this._options.dsn) {
	      IS_DEBUG_BUILD$2 && logger.warn('No DSN provided, backend will not do anything.');
	    }

	    this._transport = this._setupTransport();
	  }
	  /**
	   * @inheritDoc
	   */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


	  BaseBackend.prototype.eventFromException = function (_exception, _hint) {
	    throw new SentryError('Backend has to implement `eventFromException` method');
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseBackend.prototype.eventFromMessage = function (_message, _level, _hint) {
	    throw new SentryError('Backend has to implement `eventFromMessage` method');
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseBackend.prototype.sendEvent = function (event) {
	    // TODO(v7): Remove the if-else
	    if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
	      var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
	      var env = createEventEnvelope(event, api);
	      void this._newTransport.send(env).then(null, function (reason) {
	        IS_DEBUG_BUILD$2 && logger.error('Error while sending event:', reason);
	      });
	    } else {
	      void this._transport.sendEvent(event).then(null, function (reason) {
	        IS_DEBUG_BUILD$2 && logger.error('Error while sending event:', reason);
	      });
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseBackend.prototype.sendSession = function (session) {
	    if (!this._transport.sendSession) {
	      IS_DEBUG_BUILD$2 && logger.warn("Dropping session because custom transport doesn't implement sendSession");
	      return;
	    } // TODO(v7): Remove the if-else


	    if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
	      var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);

	      var _a = __read$1(createSessionEnvelope(session, api), 1),
	          env = _a[0];

	      void this._newTransport.send(env).then(null, function (reason) {
	        IS_DEBUG_BUILD$2 && logger.error('Error while sending session:', reason);
	      });
	    } else {
	      void this._transport.sendSession(session).then(null, function (reason) {
	        IS_DEBUG_BUILD$2 && logger.error('Error while sending session:', reason);
	      });
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseBackend.prototype.getTransport = function () {
	    return this._transport;
	  };
	  /**
	   * Sets up the transport so it can be used later to send requests.
	   */


	  BaseBackend.prototype._setupTransport = function () {
	    return new NoopTransport();
	  };

	  return BaseBackend;
	}();

	/**
	 * Internal function to create a new SDK client instance. The client is
	 * installed and then bound to the current scope.
	 *
	 * @param clientClass The client class to instantiate.
	 * @param options Options to pass to the client.
	 */

	function initAndBind(clientClass, options) {
	  if (options.debug === true) {
	    if (IS_DEBUG_BUILD$2) {
	      logger.enable();
	    } else {
	      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
	      // eslint-disable-next-line no-console
	      console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
	    }
	  }

	  var hub = getCurrentHub();
	  var scope = hub.getScope();

	  if (scope) {
	    scope.update(options.initialScope);
	  }

	  var client = new clientClass(options);
	  hub.bindClient(client);
	}

	var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
	/**
	 * Creates a `NewTransport`
	 *
	 * @param options
	 * @param makeRequest
	 */

	function createTransport(options, makeRequest, buffer) {
	  if (buffer === void 0) {
	    buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);
	  }

	  var rateLimits = {};

	  var flush = function (timeout) {
	    return buffer.drain(timeout);
	  };

	  function send(envelope) {
	    var envCategory = getEnvelopeType(envelope);
	    var category = envCategory === 'event' ? 'error' : envCategory;
	    var request = {
	      category: category,
	      body: serializeEnvelope(envelope)
	    }; // Don't add to buffer if transport is already rate-limited

	    if (isRateLimited(rateLimits, category)) {
	      return rejectedSyncPromise({
	        status: 'rate_limit',
	        reason: getRateLimitReason(rateLimits, category)
	      });
	    }

	    var requestTask = function () {
	      return makeRequest(request).then(function (_a) {
	        var body = _a.body,
	            headers = _a.headers,
	            reason = _a.reason,
	            statusCode = _a.statusCode;
	        var status = eventStatusFromHttpCode(statusCode);

	        if (headers) {
	          rateLimits = updateRateLimits(rateLimits, headers);
	        }

	        if (status === 'success') {
	          return resolvedSyncPromise({
	            status: status,
	            reason: reason
	          });
	        }

	        return rejectedSyncPromise({
	          status: status,
	          reason: reason || body || (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error')
	        });
	      });
	    };

	    return buffer.add(requestTask);
	  }

	  return {
	    send: send,
	    flush: flush
	  };
	}

	function getRateLimitReason(rateLimits, category) {
	  return "Too many " + category + " requests, backing off until: " + new Date(disabledUntil(rateLimits, category)).toISOString();
	}

	var SDK_VERSION = '6.19.6';

	var originalFunctionToString;
	/** Patch toString calls to return proper name for wrapped functions */

	var FunctionToString =
	/** @class */
	function () {
	  function FunctionToString() {
	    /**
	     * @inheritDoc
	     */
	    this.name = FunctionToString.id;
	  }
	  /**
	   * @inheritDoc
	   */


	  FunctionToString.prototype.setupOnce = function () {
	    // eslint-disable-next-line @typescript-eslint/unbound-method
	    originalFunctionToString = Function.prototype.toString; // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    Function.prototype.toString = function () {
	      var args = [];

	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }

	      var context = getOriginalFunction(this) || this;
	      return originalFunctionToString.apply(context, args);
	    };
	  };
	  /**
	   * @inheritDoc
	   */


	  FunctionToString.id = 'FunctionToString';
	  return FunctionToString;
	}();

	// this is the result of a script being pulled in from an external domain and CORS.

	var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
	/** Inbound filters configurable by the user */

	var InboundFilters =
	/** @class */
	function () {
	  function InboundFilters(_options) {
	    if (_options === void 0) {
	      _options = {};
	    }

	    this._options = _options;
	    /**
	     * @inheritDoc
	     */

	    this.name = InboundFilters.id;
	  }
	  /**
	   * @inheritDoc
	   */


	  InboundFilters.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
	    addGlobalEventProcessor(function (event) {
	      var hub = getCurrentHub();

	      if (hub) {
	        var self_1 = hub.getIntegration(InboundFilters);

	        if (self_1) {
	          var client = hub.getClient();
	          var clientOptions = client ? client.getOptions() : {};

	          var options = _mergeOptions(self_1._options, clientOptions);

	          return _shouldDropEvent$1(event, options) ? null : event;
	        }
	      }

	      return event;
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  InboundFilters.id = 'InboundFilters';
	  return InboundFilters;
	}();
	/** JSDoc */

	function _mergeOptions(internalOptions, clientOptions) {
	  if (internalOptions === void 0) {
	    internalOptions = {};
	  }

	  if (clientOptions === void 0) {
	    clientOptions = {};
	  }

	  return {
	    allowUrls: __spread$1(internalOptions.whitelistUrls || [], internalOptions.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
	    denyUrls: __spread$1(internalOptions.blacklistUrls || [], internalOptions.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
	    ignoreErrors: __spread$1(internalOptions.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
	    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true
	  };
	}
	/** JSDoc */

	function _shouldDropEvent$1(event, options) {
	  if (options.ignoreInternal && _isSentryError(event)) {
	    IS_DEBUG_BUILD$2 && logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
	    return true;
	  }

	  if (_isIgnoredError(event, options.ignoreErrors)) {
	    IS_DEBUG_BUILD$2 && logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
	    return true;
	  }

	  if (_isDeniedUrl(event, options.denyUrls)) {
	    IS_DEBUG_BUILD$2 && logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
	    return true;
	  }

	  if (!_isAllowedUrl(event, options.allowUrls)) {
	    IS_DEBUG_BUILD$2 && logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
	    return true;
	  }

	  return false;
	}

	function _isIgnoredError(event, ignoreErrors) {
	  if (!ignoreErrors || !ignoreErrors.length) {
	    return false;
	  }

	  return _getPossibleEventMessages(event).some(function (message) {
	    return ignoreErrors.some(function (pattern) {
	      return isMatchingPattern(message, pattern);
	    });
	  });
	}

	function _isDeniedUrl(event, denyUrls) {
	  // TODO: Use Glob instead?
	  if (!denyUrls || !denyUrls.length) {
	    return false;
	  }

	  var url = _getEventFilterUrl(event);

	  return !url ? false : denyUrls.some(function (pattern) {
	    return isMatchingPattern(url, pattern);
	  });
	}

	function _isAllowedUrl(event, allowUrls) {
	  // TODO: Use Glob instead?
	  if (!allowUrls || !allowUrls.length) {
	    return true;
	  }

	  var url = _getEventFilterUrl(event);

	  return !url ? true : allowUrls.some(function (pattern) {
	    return isMatchingPattern(url, pattern);
	  });
	}

	function _getPossibleEventMessages(event) {
	  if (event.message) {
	    return [event.message];
	  }

	  if (event.exception) {
	    try {
	      var _a = event.exception.values && event.exception.values[0] || {},
	          _b = _a.type,
	          type = _b === void 0 ? '' : _b,
	          _c = _a.value,
	          value = _c === void 0 ? '' : _c;

	      return ["" + value, type + ": " + value];
	    } catch (oO) {
	      IS_DEBUG_BUILD$2 && logger.error("Cannot extract message for event " + getEventDescription(event));
	      return [];
	    }
	  }

	  return [];
	}

	function _isSentryError(event) {
	  try {
	    // @ts-ignore can't be a sentry error if undefined
	    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	    return event.exception.values[0].type === 'SentryError';
	  } catch (e) {// ignore
	  }

	  return false;
	}

	function _getLastValidUrl(frames) {
	  if (frames === void 0) {
	    frames = [];
	  }

	  for (var i = frames.length - 1; i >= 0; i--) {
	    var frame = frames[i];

	    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
	      return frame.filename || null;
	    }
	  }

	  return null;
	}

	function _getEventFilterUrl(event) {
	  try {
	    if (event.stacktrace) {
	      return _getLastValidUrl(event.stacktrace.frames);
	    }

	    var frames_1;

	    try {
	      // @ts-ignore we only care about frames if the whole thing here is defined
	      frames_1 = event.exception.values[0].stacktrace.frames;
	    } catch (e) {// ignore
	    }

	    return frames_1 ? _getLastValidUrl(frames_1) : null;
	  } catch (oO) {
	    IS_DEBUG_BUILD$2 && logger.error("Cannot extract url for event " + getEventDescription(event));
	    return null;
	  }
	}

	var UNKNOWN_FUNCTION = '?';
	var OPERA10_PRIORITY = 10;
	var OPERA11_PRIORITY = 20;
	var CHROME_PRIORITY = 30;
	var WINJS_PRIORITY = 40;
	var GECKO_PRIORITY = 50;

	function createFrame(filename, func, lineno, colno) {
	  var frame = {
	    filename: filename,
	    function: func,
	    // All browser frames are considered in_app
	    in_app: true
	  };

	  if (lineno !== undefined) {
	    frame.lineno = lineno;
	  }

	  if (colno !== undefined) {
	    frame.colno = colno;
	  }

	  return frame;
	} // Chromium based browsers: Chrome, Brave, new Opera, new Edge


	var chromeRegex = /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
	var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;

	var chrome = function (line) {
	  var parts = chromeRegex.exec(line);

	  if (parts) {
	    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

	    if (isEval) {
	      var subMatch = chromeEvalRegex.exec(parts[2]);

	      if (subMatch) {
	        // throw out eval line/column and use top-most line/column number
	        parts[2] = subMatch[1]; // url

	        parts[3] = subMatch[2]; // line

	        parts[4] = subMatch[3]; // column
	      }
	    } // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now
	    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)


	    var _a = __read$5(extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]), 2),
	        func = _a[0],
	        filename = _a[1];

	    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);
	  }

	  return;
	};

	var chromeStackParser = [CHROME_PRIORITY, chrome]; // gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
	// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
	// We need this specific case for now because we want no other regex to match.

	var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
	var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

	var gecko = function (line) {
	  var _a;

	  var parts = geckoREgex.exec(line);

	  if (parts) {
	    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;

	    if (isEval) {
	      var subMatch = geckoEvalRegex.exec(parts[3]);

	      if (subMatch) {
	        // throw out eval line/column and use top-most line number
	        parts[1] = parts[1] || 'eval';
	        parts[3] = subMatch[1];
	        parts[4] = subMatch[2];
	        parts[5] = ''; // no column when eval
	      }
	    }

	    var filename = parts[3];
	    var func = parts[1] || UNKNOWN_FUNCTION;
	    _a = __read$5(extractSafariExtensionDetails(func, filename), 2), func = _a[0], filename = _a[1];
	    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);
	  }

	  return;
	};

	var geckoStackParser = [GECKO_PRIORITY, gecko];
	var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

	var winjs = function (line) {
	  var parts = winjsRegex.exec(line);
	  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined) : undefined;
	};

	var winjsStackParser = [WINJS_PRIORITY, winjs];
	var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;

	var opera10 = function (line) {
	  var parts = opera10Regex.exec(line);
	  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;
	};

	var opera10StackParser = [OPERA10_PRIORITY, opera10];
	var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;

	var opera11 = function (line) {
	  var parts = opera11Regex.exec(line);
	  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;
	};

	var opera11StackParser = [OPERA11_PRIORITY, opera11];
	/**
	 * Safari web extensions, starting version unknown, can produce "frames-only" stacktraces.
	 * What it means, is that instead of format like:
	 *
	 * Error: wat
	 *   at function@url:row:col
	 *   at function@url:row:col
	 *   at function@url:row:col
	 *
	 * it produces something like:
	 *
	 *   function@url:row:col
	 *   function@url:row:col
	 *   function@url:row:col
	 *
	 * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.
	 * This function is extracted so that we can use it in both places without duplicating the logic.
	 * Unfortunately "just" changing RegExp is too complicated now and making it pass all tests
	 * and fix this case seems like an impossible, or at least way too time-consuming task.
	 */

	var extractSafariExtensionDetails = function (func, filename) {
	  var isSafariExtension = func.indexOf('safari-extension') !== -1;
	  var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;
	  return isSafariExtension || isSafariWebExtension ? [func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION, isSafariExtension ? "safari-extension:" + filename : "safari-web-extension:" + filename] : [func, filename];
	};

	/**
	 * This function creates an exception from an TraceKitStackTrace
	 * @param stacktrace TraceKitStackTrace that will be converted to an exception
	 * @hidden
	 */

	function exceptionFromError(ex) {
	  // Get the frames first since Opera can lose the stack if we touch anything else first
	  var frames = parseStackFrames(ex);
	  var exception = {
	    type: ex && ex.name,
	    value: extractMessage(ex)
	  };

	  if (frames.length) {
	    exception.stacktrace = {
	      frames: frames
	    };
	  }

	  if (exception.type === undefined && exception.value === '') {
	    exception.value = 'Unrecoverable error caught';
	  }

	  return exception;
	}
	/**
	 * @hidden
	 */

	function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {
	  var event = {
	    exception: {
	      values: [{
	        type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',
	        value: "Non-Error " + (isUnhandledRejection ? 'promise rejection' : 'exception') + " captured with keys: " + extractExceptionKeysForMessage(exception)
	      }]
	    },
	    extra: {
	      __serialized__: normalizeToSize(exception)
	    }
	  };

	  if (syntheticException) {
	    var frames_1 = parseStackFrames(syntheticException);

	    if (frames_1.length) {
	      event.stacktrace = {
	        frames: frames_1
	      };
	    }
	  }

	  return event;
	}
	/**
	 * @hidden
	 */

	function eventFromError(ex) {
	  return {
	    exception: {
	      values: [exceptionFromError(ex)]
	    }
	  };
	}
	/** Parses stack frames from an error */

	function parseStackFrames(ex) {
	  // Access and store the stacktrace property before doing ANYTHING
	  // else to it because Opera is not very good at providing it
	  // reliably in other circumstances.
	  var stacktrace = ex.stacktrace || ex.stack || '';
	  var popSize = getPopSize(ex);

	  try {
	    return createStackParser(opera10StackParser, opera11StackParser, chromeStackParser, winjsStackParser, geckoStackParser)(stacktrace, popSize);
	  } catch (e) {// no-empty
	  }

	  return [];
	} // Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108

	var reactMinifiedRegexp = /Minified React error #\d+;/i;

	function getPopSize(ex) {
	  if (ex) {
	    if (typeof ex.framesToPop === 'number') {
	      return ex.framesToPop;
	    }

	    if (reactMinifiedRegexp.test(ex.message)) {
	      return 1;
	    }
	  }

	  return 0;
	}
	/**
	 * There are cases where stacktrace.message is an Event object
	 * https://github.com/getsentry/sentry-javascript/issues/1949
	 * In this specific case we try to extract stacktrace.message.error.message
	 */


	function extractMessage(ex) {
	  var message = ex && ex.message;

	  if (!message) {
	    return 'No error message';
	  }

	  if (message.error && typeof message.error.message === 'string') {
	    return message.error.message;
	  }

	  return message;
	}
	/**
	 * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
	 * @hidden
	 */


	function eventFromException(exception, hint, attachStacktrace) {
	  var syntheticException = hint && hint.syntheticException || undefined;
	  var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);
	  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }

	  event.level = Severity.Error;

	  if (hint && hint.event_id) {
	    event.event_id = hint.event_id;
	  }

	  return resolvedSyncPromise(event);
	}
	/**
	 * Builds and Event from a Message
	 * @hidden
	 */

	function eventFromMessage(message, level, hint, attachStacktrace) {
	  if (level === void 0) {
	    level = Severity.Info;
	  }

	  var syntheticException = hint && hint.syntheticException || undefined;
	  var event = eventFromString(message, syntheticException, attachStacktrace);
	  event.level = level;

	  if (hint && hint.event_id) {
	    event.event_id = hint.event_id;
	  }

	  return resolvedSyncPromise(event);
	}
	/**
	 * @hidden
	 */

	function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {
	  var event;

	  if (isErrorEvent(exception) && exception.error) {
	    // If it is an ErrorEvent with `error` property, extract it to get actual Error
	    var errorEvent = exception;
	    return eventFromError(errorEvent.error);
	  } // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name
	  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be
	  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.
	  //
	  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
	  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
	  // https://webidl.spec.whatwg.org/#es-DOMException-specialness


	  if (isDOMError(exception) || isDOMException(exception)) {
	    var domException = exception;

	    if ('stack' in exception) {
	      event = eventFromError(exception);
	    } else {
	      var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');
	      var message = domException.message ? name_1 + ": " + domException.message : name_1;
	      event = eventFromString(message, syntheticException, attachStacktrace);
	      addExceptionTypeValue(event, message);
	    }

	    if ('code' in domException) {
	      event.tags = __assign$4(__assign$4({}, event.tags), {
	        'DOMException.code': "" + domException.code
	      });
	    }

	    return event;
	  }

	  if (isError(exception)) {
	    // we have a real Error object, do nothing
	    return eventFromError(exception);
	  }

	  if (isPlainObject(exception) || isEvent(exception)) {
	    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize
	    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new
	    // group on any key/value change.
	    var objectException = exception;
	    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);
	    addExceptionMechanism(event, {
	      synthetic: true
	    });
	    return event;
	  } // If none of previous checks were valid, then it means that it's not:
	  // - an instance of DOMError
	  // - an instance of DOMException
	  // - an instance of Event
	  // - an instance of Error
	  // - a valid ErrorEvent (one with an error property)
	  // - a plain Object
	  //
	  // So bail out and capture it as a simple message:


	  event = eventFromString(exception, syntheticException, attachStacktrace);
	  addExceptionTypeValue(event, "" + exception, undefined);
	  addExceptionMechanism(event, {
	    synthetic: true
	  });
	  return event;
	}
	/**
	 * @hidden
	 */

	function eventFromString(input, syntheticException, attachStacktrace) {
	  var event = {
	    message: input
	  };

	  if (attachStacktrace && syntheticException) {
	    var frames_2 = parseStackFrames(syntheticException);

	    if (frames_2.length) {
	      event.stacktrace = {
	        frames: frames_2
	      };
	    }
	  }

	  return event;
	}

	/*
	 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
	 * for users.
	 *
	 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
	 * because some build tools have trouble tree-shaking imported guards.
	 *
	 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
	 *
	 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
	 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
	 * replaced.
	 */

	/** Flag that is true for debug builds, false otherwise. */
	var IS_DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

	var global$8 = getGlobalObject();
	var cachedFetchImpl;
	/**
	 * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.
	 * Whenever someone wraps the Fetch API and returns the wrong promise chain,
	 * this chain becomes orphaned and there is no possible way to capture it's rejections
	 * other than allowing it bubble up to this very handler. eg.
	 *
	 * const f = window.fetch;
	 * window.fetch = function () {
	 *   const p = f.apply(this, arguments);
	 *
	 *   p.then(function() {
	 *     console.log('hi.');
	 *   });
	 *
	 *   return p;
	 * }
	 *
	 * `p.then(function () { ... })` is producing a completely separate promise chain,
	 * however, what's returned is `p` - the result of original `fetch` call.
	 *
	 * This mean, that whenever we use the Fetch API to send our own requests, _and_
	 * some ad-blocker blocks it, this orphaned chain will _always_ reject,
	 * effectively causing another event to be captured.
	 * This makes a whole process become an infinite loop, which we need to somehow
	 * deal with, and break it in one way or another.
	 *
	 * To deal with this issue, we are making sure that we _always_ use the real
	 * browser Fetch API, instead of relying on what `window.fetch` exposes.
	 * The only downside to this would be missing our own requests as breadcrumbs,
	 * but because we are already not doing this, it should be just fine.
	 *
	 * Possible failed fetch error messages per-browser:
	 *
	 * Chrome:  Failed to fetch
	 * Edge:    Failed to Fetch
	 * Firefox: NetworkError when attempting to fetch resource
	 * Safari:  resource blocked by content blocker
	 */

	function getNativeFetchImplementation() {
	  if (cachedFetchImpl) {
	    return cachedFetchImpl;
	  }
	  /* eslint-disable @typescript-eslint/unbound-method */
	  // Fast path to avoid DOM I/O


	  if (isNativeFetch(global$8.fetch)) {
	    return cachedFetchImpl = global$8.fetch.bind(global$8);
	  }

	  var document = global$8.document;
	  var fetchImpl = global$8.fetch; // eslint-disable-next-line deprecation/deprecation

	  if (document && typeof document.createElement === 'function') {
	    try {
	      var sandbox = document.createElement('iframe');
	      sandbox.hidden = true;
	      document.head.appendChild(sandbox);
	      var contentWindow = sandbox.contentWindow;

	      if (contentWindow && contentWindow.fetch) {
	        fetchImpl = contentWindow.fetch;
	      }

	      document.head.removeChild(sandbox);
	    } catch (e) {
	      IS_DEBUG_BUILD$1 && logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);
	    }
	  }

	  return cachedFetchImpl = fetchImpl.bind(global$8);
	  /* eslint-enable @typescript-eslint/unbound-method */
	}
	/**
	 * Sends sdk client report using sendBeacon or fetch as a fallback if available
	 *
	 * @param url report endpoint
	 * @param body report payload
	 */

	function sendReport(url, body) {
	  var isRealNavigator = Object.prototype.toString.call(global$8 && global$8.navigator) === '[object Navigator]';
	  var hasSendBeacon = isRealNavigator && typeof global$8.navigator.sendBeacon === 'function';

	  if (hasSendBeacon) {
	    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch
	    var sendBeacon = global$8.navigator.sendBeacon.bind(global$8.navigator);
	    return sendBeacon(url, body);
	  }

	  if (supportsFetch()) {
	    var fetch_1 = getNativeFetchImplementation();
	    return forget(fetch_1(url, {
	      body: body,
	      method: 'POST',
	      credentials: 'omit',
	      keepalive: true
	    }));
	  }
	}

	function requestTypeToCategory(ty) {
	  var tyStr = ty;
	  return tyStr === 'event' ? 'error' : tyStr;
	}

	var global$7 = getGlobalObject();
	/** Base Transport class implementation */

	var BaseTransport =
	/** @class */
	function () {
	  function BaseTransport(options) {
	    var _this = this;

	    this.options = options;
	    /** A simple buffer holding all requests. */

	    this._buffer = makePromiseBuffer(30);
	    /** Locks transport after receiving rate limits in a response */

	    this._rateLimits = {};
	    this._outcomes = {};
	    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel); // eslint-disable-next-line deprecation/deprecation

	    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);

	    if (this.options.sendClientReports && global$7.document) {
	      global$7.document.addEventListener('visibilitychange', function () {
	        if (global$7.document.visibilityState === 'hidden') {
	          _this._flushOutcomes();
	        }
	      });
	    }
	  }
	  /**
	   * @inheritDoc
	   */


	  BaseTransport.prototype.sendEvent = function (event) {
	    return this._sendRequest(eventToSentryRequest(event, this._api), event);
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseTransport.prototype.sendSession = function (session) {
	    return this._sendRequest(sessionToSentryRequest(session, this._api), session);
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseTransport.prototype.close = function (timeout) {
	    return this._buffer.drain(timeout);
	  };
	  /**
	   * @inheritDoc
	   */


	  BaseTransport.prototype.recordLostEvent = function (reason, category) {
	    var _a;

	    if (!this.options.sendClientReports) {
	      return;
	    } // We want to track each category (event, transaction, session) separately
	    // but still keep the distinction between different type of outcomes.
	    // We could use nested maps, but it's much easier to read and type this way.
	    // A correct type for map-based implementation if we want to go that route
	    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`


	    var key = requestTypeToCategory(category) + ":" + reason;
	    IS_DEBUG_BUILD$1 && logger.log("Adding outcome: " + key);
	    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;
	  };
	  /**
	   * Send outcomes as an envelope
	   */


	  BaseTransport.prototype._flushOutcomes = function () {
	    if (!this.options.sendClientReports) {
	      return;
	    }

	    var outcomes = this._outcomes;
	    this._outcomes = {}; // Nothing to send

	    if (!Object.keys(outcomes).length) {
	      IS_DEBUG_BUILD$1 && logger.log('No outcomes to flush');
	      return;
	    }

	    IS_DEBUG_BUILD$1 && logger.log("Flushing outcomes:\n" + JSON.stringify(outcomes, null, 2));
	    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);
	    var discardedEvents = Object.keys(outcomes).map(function (key) {
	      var _a = __read$5(key.split(':'), 2),
	          category = _a[0],
	          reason = _a[1];

	      return {
	        reason: reason,
	        category: category,
	        quantity: outcomes[key]
	      }; // TODO: Improve types on discarded_events to get rid of cast
	    });
	    var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));

	    try {
	      sendReport(url, serializeEnvelope(envelope));
	    } catch (e) {
	      IS_DEBUG_BUILD$1 && logger.error(e);
	    }
	  };
	  /**
	   * Handle Sentry repsonse for promise-based transports.
	   */


	  BaseTransport.prototype._handleResponse = function (_a) {
	    var requestType = _a.requestType,
	        response = _a.response,
	        headers = _a.headers,
	        resolve = _a.resolve,
	        reject = _a.reject;
	    var status = eventStatusFromHttpCode(response.status);
	    this._rateLimits = updateRateLimits(this._rateLimits, headers); // eslint-disable-next-line deprecation/deprecation

	    if (this._isRateLimited(requestType)) {
	      IS_DEBUG_BUILD$1 && // eslint-disable-next-line deprecation/deprecation
	      logger.warn("Too many " + requestType + " requests, backing off until: " + this._disabledUntil(requestType));
	    }

	    if (status === 'success') {
	      resolve({
	        status: status
	      });
	      return;
	    }

	    reject(response);
	  };
	  /**
	   * Gets the time that given category is disabled until for rate limiting
	   *
	   * @deprecated Please use `disabledUntil` from @sentry/utils
	   */


	  BaseTransport.prototype._disabledUntil = function (requestType) {
	    var category = requestTypeToCategory(requestType);
	    return new Date(disabledUntil(this._rateLimits, category));
	  };
	  /**
	   * Checks if a category is rate limited
	   *
	   * @deprecated Please use `isRateLimited` from @sentry/utils
	   */


	  BaseTransport.prototype._isRateLimited = function (requestType) {
	    var category = requestTypeToCategory(requestType);
	    return isRateLimited(this._rateLimits, category);
	  };

	  return BaseTransport;
	}();

	/** `fetch` based transport */

	var FetchTransport =
	/** @class */
	function (_super) {
	  __extends$2(FetchTransport, _super);

	  function FetchTransport(options, fetchImpl) {
	    if (fetchImpl === void 0) {
	      fetchImpl = getNativeFetchImplementation();
	    }

	    var _this = _super.call(this, options) || this;

	    _this._fetch = fetchImpl;
	    return _this;
	  }
	  /**
	   * @param sentryRequest Prepared SentryRequest to be delivered
	   * @param originalPayload Original payload used to create SentryRequest
	   */


	  FetchTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {
	    var _this = this; // eslint-disable-next-line deprecation/deprecation


	    if (this._isRateLimited(sentryRequest.type)) {
	      this.recordLostEvent('ratelimit_backoff', sentryRequest.type);
	      return Promise.reject({
	        event: originalPayload,
	        type: sentryRequest.type,
	        // eslint-disable-next-line deprecation/deprecation
	        reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
	        status: 429
	      });
	    }

	    var options = {
	      body: sentryRequest.body,
	      method: 'POST',
	      // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
	      // (see https://caniuse.com/#feat=referrer-policy),
	      // it doesn't. And it throws an exception instead of ignoring this parameter...
	      // REF: https://github.com/getsentry/raven-js/issues/1233
	      referrerPolicy: supportsReferrerPolicy() ? 'origin' : ''
	    };

	    if (this.options.fetchParameters !== undefined) {
	      Object.assign(options, this.options.fetchParameters);
	    }

	    if (this.options.headers !== undefined) {
	      options.headers = this.options.headers;
	    }

	    return this._buffer.add(function () {
	      return new SyncPromise(function (resolve, reject) {
	        void _this._fetch(sentryRequest.url, options).then(function (response) {
	          var headers = {
	            'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
	            'retry-after': response.headers.get('Retry-After')
	          };

	          _this._handleResponse({
	            requestType: sentryRequest.type,
	            response: response,
	            headers: headers,
	            resolve: resolve,
	            reject: reject
	          });
	        }).catch(reject);
	      });
	    }).then(undefined, function (reason) {
	      // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.
	      if (reason instanceof SentryError) {
	        _this.recordLostEvent('queue_overflow', sentryRequest.type);
	      } else {
	        _this.recordLostEvent('network_error', sentryRequest.type);
	      }

	      throw reason;
	    });
	  };

	  return FetchTransport;
	}(BaseTransport);

	/** `XHR` based transport */

	var XHRTransport =
	/** @class */
	function (_super) {
	  __extends$2(XHRTransport, _super);

	  function XHRTransport() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	  /**
	   * @param sentryRequest Prepared SentryRequest to be delivered
	   * @param originalPayload Original payload used to create SentryRequest
	   */


	  XHRTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {
	    var _this = this; // eslint-disable-next-line deprecation/deprecation


	    if (this._isRateLimited(sentryRequest.type)) {
	      this.recordLostEvent('ratelimit_backoff', sentryRequest.type);
	      return Promise.reject({
	        event: originalPayload,
	        type: sentryRequest.type,
	        // eslint-disable-next-line deprecation/deprecation
	        reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
	        status: 429
	      });
	    }

	    return this._buffer.add(function () {
	      return new SyncPromise(function (resolve, reject) {
	        var request = new XMLHttpRequest();

	        request.onreadystatechange = function () {
	          if (request.readyState === 4) {
	            var headers = {
	              'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),
	              'retry-after': request.getResponseHeader('Retry-After')
	            };

	            _this._handleResponse({
	              requestType: sentryRequest.type,
	              response: request,
	              headers: headers,
	              resolve: resolve,
	              reject: reject
	            });
	          }
	        };

	        request.open('POST', sentryRequest.url);

	        for (var header in _this.options.headers) {
	          if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {
	            request.setRequestHeader(header, _this.options.headers[header]);
	          }
	        }

	        request.send(sentryRequest.body);
	      });
	    }).then(undefined, function (reason) {
	      // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.
	      if (reason instanceof SentryError) {
	        _this.recordLostEvent('queue_overflow', sentryRequest.type);
	      } else {
	        _this.recordLostEvent('network_error', sentryRequest.type);
	      }

	      throw reason;
	    });
	  };

	  return XHRTransport;
	}(BaseTransport);

	/**
	 * Creates a Transport that uses the Fetch API to send events to Sentry.
	 */

	function makeNewFetchTransport(options, nativeFetch) {
	  if (nativeFetch === void 0) {
	    nativeFetch = getNativeFetchImplementation();
	  }

	  function makeRequest(request) {
	    var requestOptions = __assign$4({
	      body: request.body,
	      method: 'POST',
	      referrerPolicy: 'origin'
	    }, options.requestOptions);

	    return nativeFetch(options.url, requestOptions).then(function (response) {
	      return response.text().then(function (body) {
	        return {
	          body: body,
	          headers: {
	            'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
	            'retry-after': response.headers.get('Retry-After')
	          },
	          reason: response.statusText,
	          statusCode: response.status
	        };
	      });
	    });
	  }

	  return createTransport({
	    bufferSize: options.bufferSize
	  }, makeRequest);
	}

	/**
	 * The DONE ready state for XmlHttpRequest
	 *
	 * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined
	 * (e.g. during testing, it is `undefined`)
	 *
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}
	 */

	var XHR_READYSTATE_DONE = 4;
	/**
	 * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.
	 */

	function makeNewXHRTransport(options) {
	  function makeRequest(request) {
	    return new SyncPromise(function (resolve, _reject) {
	      var xhr = new XMLHttpRequest();

	      xhr.onreadystatechange = function () {
	        if (xhr.readyState === XHR_READYSTATE_DONE) {
	          var response = {
	            body: xhr.response,
	            headers: {
	              'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),
	              'retry-after': xhr.getResponseHeader('Retry-After')
	            },
	            reason: xhr.statusText,
	            statusCode: xhr.status
	          };
	          resolve(response);
	        }
	      };

	      xhr.open('POST', options.url);

	      for (var header in options.headers) {
	        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
	          xhr.setRequestHeader(header, options.headers[header]);
	        }
	      }

	      xhr.send(request.body);
	    });
	  }

	  return createTransport({
	    bufferSize: options.bufferSize
	  }, makeRequest);
	}

	/**
	 * The Sentry Browser SDK Backend.
	 * @hidden
	 */

	var BrowserBackend =
	/** @class */
	function (_super) {
	  __extends$2(BrowserBackend, _super);

	  function BrowserBackend() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	  /**
	   * @inheritDoc
	   */


	  BrowserBackend.prototype.eventFromException = function (exception, hint) {
	    return eventFromException(exception, hint, this._options.attachStacktrace);
	  };
	  /**
	   * @inheritDoc
	   */


	  BrowserBackend.prototype.eventFromMessage = function (message, level, hint) {
	    if (level === void 0) {
	      level = Severity.Info;
	    }

	    return eventFromMessage(message, level, hint, this._options.attachStacktrace);
	  };
	  /**
	   * @inheritDoc
	   */


	  BrowserBackend.prototype._setupTransport = function () {
	    if (!this._options.dsn) {
	      // We return the noop transport here in case there is no Dsn.
	      return _super.prototype._setupTransport.call(this);
	    }

	    var transportOptions = __assign$4(__assign$4({}, this._options.transportOptions), {
	      dsn: this._options.dsn,
	      tunnel: this._options.tunnel,
	      sendClientReports: this._options.sendClientReports,
	      _metadata: this._options._metadata
	    });

	    var api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
	    var url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);

	    if (this._options.transport) {
	      return new this._options.transport(transportOptions);
	    }

	    if (supportsFetch()) {
	      var requestOptions = __assign$4({}, transportOptions.fetchParameters);

	      this._newTransport = makeNewFetchTransport({
	        requestOptions: requestOptions,
	        url: url
	      });
	      return new FetchTransport(transportOptions);
	    }

	    this._newTransport = makeNewXHRTransport({
	      url: url,
	      headers: transportOptions.headers
	    });
	    return new XHRTransport(transportOptions);
	  };

	  return BrowserBackend;
	}(BaseBackend);

	var global$6 = getGlobalObject();
	var ignoreOnError = 0;
	/**
	 * @hidden
	 */

	function shouldIgnoreOnError() {
	  return ignoreOnError > 0;
	}
	/**
	 * @hidden
	 */

	function ignoreNextOnError() {
	  // onerror should trigger before setTimeout
	  ignoreOnError += 1;
	  setTimeout(function () {
	    ignoreOnError -= 1;
	  });
	}
	/**
	 * Instruments the given function and sends an event to Sentry every time the
	 * function throws an exception.
	 *
	 * @param fn A function to wrap.
	 * @returns The wrapped function.
	 * @hidden
	 */

	function wrap(fn, options, before) {
	  // for future readers what this does is wrap a function and then create
	  // a bi-directional wrapping between them.
	  //
	  // example: wrapped = wrap(original);
	  //  original.__sentry_wrapped__ -> wrapped
	  //  wrapped.__sentry_original__ -> original
	  if (options === void 0) {
	    options = {};
	  }

	  if (typeof fn !== 'function') {
	    return fn;
	  }

	  try {
	    // if we're dealing with a function that was previously wrapped, return
	    // the original wrapper.
	    var wrapper = fn.__sentry_wrapped__;

	    if (wrapper) {
	      return wrapper;
	    } // We don't wanna wrap it twice


	    if (getOriginalFunction(fn)) {
	      return fn;
	    }
	  } catch (e) {
	    // Just accessing custom props in some Selenium environments
	    // can cause a "Permission denied" exception (see raven-js#495).
	    // Bail on wrapping and return the function as-is (defers to window.onerror).
	    return fn;
	  }
	  /* eslint-disable prefer-rest-params */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any


	  var sentryWrapped = function () {
	    var args = Array.prototype.slice.call(arguments);

	    try {
	      if (before && typeof before === 'function') {
	        before.apply(this, arguments);
	      } // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access


	      var wrappedArguments = args.map(function (arg) {
	        return wrap(arg, options);
	      }); // Attempt to invoke user-land function
	      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
	      //       means the sentry.javascript SDK caught an error invoking your application code. This
	      //       is expected behavior and NOT indicative of a bug with sentry.javascript.

	      return fn.apply(this, wrappedArguments);
	    } catch (ex) {
	      ignoreNextOnError();
	      withScope(function (scope) {
	        scope.addEventProcessor(function (event) {
	          if (options.mechanism) {
	            addExceptionTypeValue(event, undefined, undefined);
	            addExceptionMechanism(event, options.mechanism);
	          }

	          event.extra = __assign$4(__assign$4({}, event.extra), {
	            arguments: args
	          });
	          return event;
	        });
	        captureException(ex);
	      });
	      throw ex;
	    }
	  };
	  /* eslint-enable prefer-rest-params */
	  // Accessing some objects may throw
	  // ref: https://github.com/getsentry/sentry-javascript/issues/1168


	  try {
	    for (var property in fn) {
	      if (Object.prototype.hasOwnProperty.call(fn, property)) {
	        sentryWrapped[property] = fn[property];
	      }
	    }
	  } catch (_oO) {} // eslint-disable-line no-empty
	  // Signal that this function has been wrapped/filled already
	  // for both debugging and to prevent it to being wrapped/filled twice


	  markFunctionWrapped(sentryWrapped, fn);
	  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped); // Restore original function name (not all browsers allow that)

	  try {
	    var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name');

	    if (descriptor.configurable) {
	      Object.defineProperty(sentryWrapped, 'name', {
	        get: function () {
	          return fn.name;
	        }
	      });
	    } // eslint-disable-next-line no-empty

	  } catch (_oO) {}

	  return sentryWrapped;
	}
	/**
	 * Injects the Report Dialog script
	 * @hidden
	 */

	function injectReportDialog(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  if (!global$6.document) {
	    return;
	  }

	  if (!options.eventId) {
	    IS_DEBUG_BUILD$1 && logger.error('Missing eventId option in showReportDialog call');
	    return;
	  }

	  if (!options.dsn) {
	    IS_DEBUG_BUILD$1 && logger.error('Missing dsn option in showReportDialog call');
	    return;
	  }

	  var script = global$6.document.createElement('script');
	  script.async = true;
	  script.src = getReportDialogEndpoint(options.dsn, options);

	  if (options.onLoad) {
	    // eslint-disable-next-line @typescript-eslint/unbound-method
	    script.onload = options.onLoad;
	  }

	  var injectionPoint = global$6.document.head || global$6.document.body;

	  if (injectionPoint) {
	    injectionPoint.appendChild(script);
	  }
	}

	/** Global handlers */

	var GlobalHandlers =
	/** @class */
	function () {
	  /** JSDoc */
	  function GlobalHandlers(options) {
	    /**
	     * @inheritDoc
	     */
	    this.name = GlobalHandlers.id;
	    /**
	     * Stores references functions to installing handlers. Will set to undefined
	     * after they have been run so that they are not used twice.
	     */

	    this._installFunc = {
	      onerror: _installGlobalOnErrorHandler,
	      onunhandledrejection: _installGlobalOnUnhandledRejectionHandler
	    };
	    this._options = __assign$4({
	      onerror: true,
	      onunhandledrejection: true
	    }, options);
	  }
	  /**
	   * @inheritDoc
	   */


	  GlobalHandlers.prototype.setupOnce = function () {
	    Error.stackTraceLimit = 50;
	    var options = this._options; // We can disable guard-for-in as we construct the options object above + do checks against
	    // `this._installFunc` for the property.
	    // eslint-disable-next-line guard-for-in

	    for (var key in options) {
	      var installFunc = this._installFunc[key];

	      if (installFunc && options[key]) {
	        globalHandlerLog(key);
	        installFunc();
	        this._installFunc[key] = undefined;
	      }
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  GlobalHandlers.id = 'GlobalHandlers';
	  return GlobalHandlers;
	}();
	/** JSDoc */

	function _installGlobalOnErrorHandler() {
	  addInstrumentationHandler('error', // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  function (data) {
	    var _a = __read$5(getHubAndAttachStacktrace(), 2),
	        hub = _a[0],
	        attachStacktrace = _a[1];

	    if (!hub.getIntegration(GlobalHandlers)) {
	      return;
	    }

	    var msg = data.msg,
	        url = data.url,
	        line = data.line,
	        column = data.column,
	        error = data.error;

	    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
	      return;
	    }

	    var event = error === undefined && isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(error || msg, undefined, attachStacktrace, false), url, line, column);
	    event.level = Severity.Error;
	    addMechanismAndCapture(hub, error, event, 'onerror');
	  });
	}
	/** JSDoc */


	function _installGlobalOnUnhandledRejectionHandler() {
	  addInstrumentationHandler('unhandledrejection', // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  function (e) {
	    var _a = __read$5(getHubAndAttachStacktrace(), 2),
	        hub = _a[0],
	        attachStacktrace = _a[1];

	    if (!hub.getIntegration(GlobalHandlers)) {
	      return;
	    }

	    var error = e; // dig the object of the rejection out of known event types

	    try {
	      // PromiseRejectionEvents store the object of the rejection under 'reason'
	      // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
	      if ('reason' in e) {
	        error = e.reason;
	      } // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
	      // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
	      // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
	      // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
	      // https://github.com/getsentry/sentry-javascript/issues/2380
	      else if ('detail' in e && 'reason' in e.detail) {
	        error = e.detail.reason;
	      }
	    } catch (_oO) {// no-empty
	    }

	    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
	      return true;
	    }

	    var event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(error, undefined, attachStacktrace, true);
	    event.level = Severity.Error;
	    addMechanismAndCapture(hub, error, event, 'onunhandledrejection');
	    return;
	  });
	}
	/**
	 * Create an event from a promise rejection where the `reason` is a primitive.
	 *
	 * @param reason: The `reason` property of the promise rejection
	 * @returns An Event object with an appropriate `exception` value
	 */


	function _eventFromRejectionWithPrimitive(reason) {
	  return {
	    exception: {
	      values: [{
	        type: 'UnhandledRejection',
	        // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
	        value: "Non-Error promise rejection captured with value: " + String(reason)
	      }]
	    }
	  };
	}
	/**
	 * This function creates a stack from an old, error-less onerror handler.
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _eventFromIncompleteOnError(msg, url, line, column) {
	  var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i; // If 'message' is ErrorEvent, get real message from inside

	  var message = isErrorEvent(msg) ? msg.message : msg;
	  var name = 'Error';
	  var groups = message.match(ERROR_TYPES_RE);

	  if (groups) {
	    name = groups[1];
	    message = groups[2];
	  }

	  var event = {
	    exception: {
	      values: [{
	        type: name,
	        value: message
	      }]
	    }
	  };
	  return _enhanceEventWithInitialFrame(event, url, line, column);
	}
	/** JSDoc */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _enhanceEventWithInitialFrame(event, url, line, column) {
	  // event.exception
	  var e = event.exception = event.exception || {}; // event.exception.values

	  var ev = e.values = e.values || []; // event.exception.values[0]

	  var ev0 = ev[0] = ev[0] || {}; // event.exception.values[0].stacktrace

	  var ev0s = ev0.stacktrace = ev0.stacktrace || {}; // event.exception.values[0].stacktrace.frames

	  var ev0sf = ev0s.frames = ev0s.frames || [];
	  var colno = isNaN(parseInt(column, 10)) ? undefined : column;
	  var lineno = isNaN(parseInt(line, 10)) ? undefined : line;
	  var filename = isString(url) && url.length > 0 ? url : getLocationHref(); // event.exception.values[0].stacktrace.frames

	  if (ev0sf.length === 0) {
	    ev0sf.push({
	      colno: colno,
	      filename: filename,
	      function: '?',
	      in_app: true,
	      lineno: lineno
	    });
	  }

	  return event;
	}

	function globalHandlerLog(type) {
	  IS_DEBUG_BUILD$1 && logger.log("Global Handler attached: " + type);
	}

	function addMechanismAndCapture(hub, error, event, type) {
	  addExceptionMechanism(event, {
	    handled: false,
	    type: type
	  });
	  hub.captureEvent(event, {
	    originalException: error
	  });
	}

	function getHubAndAttachStacktrace() {
	  var hub = getCurrentHub();
	  var client = hub.getClient();
	  var attachStacktrace = client && client.getOptions().attachStacktrace;
	  return [hub, attachStacktrace];
	}

	var DEFAULT_EVENT_TARGET = ['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'];
	/** Wrap timer functions and event targets to catch errors and provide better meta data */

	var TryCatch =
	/** @class */
	function () {
	  /**
	   * @inheritDoc
	   */
	  function TryCatch(options) {
	    /**
	     * @inheritDoc
	     */
	    this.name = TryCatch.id;
	    this._options = __assign$4({
	      XMLHttpRequest: true,
	      eventTarget: true,
	      requestAnimationFrame: true,
	      setInterval: true,
	      setTimeout: true
	    }, options);
	  }
	  /**
	   * Wrap timer functions and event targets to catch errors
	   * and provide better metadata.
	   */


	  TryCatch.prototype.setupOnce = function () {
	    var global = getGlobalObject();

	    if (this._options.setTimeout) {
	      fill(global, 'setTimeout', _wrapTimeFunction);
	    }

	    if (this._options.setInterval) {
	      fill(global, 'setInterval', _wrapTimeFunction);
	    }

	    if (this._options.requestAnimationFrame) {
	      fill(global, 'requestAnimationFrame', _wrapRAF);
	    }

	    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {
	      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);
	    }

	    var eventTargetOption = this._options.eventTarget;

	    if (eventTargetOption) {
	      var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
	      eventTarget.forEach(_wrapEventTarget);
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  TryCatch.id = 'TryCatch';
	  return TryCatch;
	}();
	/** JSDoc */

	function _wrapTimeFunction(original) {
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  return function () {
	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }

	    var originalCallback = args[0];
	    args[0] = wrap(originalCallback, {
	      mechanism: {
	        data: {
	          function: getFunctionName(original)
	        },
	        handled: true,
	        type: 'instrument'
	      }
	    });
	    return original.apply(this, args);
	  };
	}
	/** JSDoc */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _wrapRAF(original) {
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  return function (callback) {
	    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	    return original.apply(this, [wrap(callback, {
	      mechanism: {
	        data: {
	          function: 'requestAnimationFrame',
	          handler: getFunctionName(original)
	        },
	        handled: true,
	        type: 'instrument'
	      }
	    })]);
	  };
	}
	/** JSDoc */


	function _wrapXHR(originalSend) {
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  return function () {
	    var args = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    } // eslint-disable-next-line @typescript-eslint/no-this-alias


	    var xhr = this;
	    var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
	    xmlHttpRequestProps.forEach(function (prop) {
	      if (prop in xhr && typeof xhr[prop] === 'function') {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        fill(xhr, prop, function (original) {
	          var wrapOptions = {
	            mechanism: {
	              data: {
	                function: prop,
	                handler: getFunctionName(original)
	              },
	              handled: true,
	              type: 'instrument'
	            }
	          }; // If Instrument integration has been called before TryCatch, get the name of original function

	          var originalFunction = getOriginalFunction(original);

	          if (originalFunction) {
	            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
	          } // Otherwise wrap directly


	          return wrap(original, wrapOptions);
	        });
	      }
	    });
	    return originalSend.apply(this, args);
	  };
	}
	/** JSDoc */


	function _wrapEventTarget(target) {
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  var global = getGlobalObject(); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

	  var proto = global[target] && global[target].prototype; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins

	  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
	    return;
	  }

	  fill(proto, 'addEventListener', function (original) {
	    return function (eventName, fn, options) {
	      try {
	        if (typeof fn.handleEvent === 'function') {
	          fn.handleEvent = wrap(fn.handleEvent.bind(fn), {
	            mechanism: {
	              data: {
	                function: 'handleEvent',
	                handler: getFunctionName(fn),
	                target: target
	              },
	              handled: true,
	              type: 'instrument'
	            }
	          });
	        }
	      } catch (err) {// can sometimes get 'Permission denied to access property "handle Event'
	      }

	      return original.apply(this, [eventName, // eslint-disable-next-line @typescript-eslint/no-explicit-any
	      wrap(fn, {
	        mechanism: {
	          data: {
	            function: 'addEventListener',
	            handler: getFunctionName(fn),
	            target: target
	          },
	          handled: true,
	          type: 'instrument'
	        }
	      }), options]);
	    };
	  });
	  fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
	    return function (eventName, fn, options) {
	      /**
	       * There are 2 possible scenarios here:
	       *
	       * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified
	       * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function
	       * as a pass-through, and call original `removeEventListener` with it.
	       *
	       * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using
	       * our wrapped version of `addEventListener`, which internally calls `wrap` helper.
	       * This helper "wraps" whole callback inside a try/catch statement, and attached appropriate metadata to it,
	       * in order for us to make a distinction between wrapped/non-wrapped functions possible.
	       * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.
	       *
	       * When someone adds a handler prior to initialization, and then do it again, but after,
	       * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible
	       * to get rid of the initial handler and it'd stick there forever.
	       */
	      var wrappedEventHandler = fn;

	      try {
	        var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;

	        if (originalEventHandler) {
	          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
	        }
	      } catch (e) {// ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
	      }

	      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
	    };
	  });
	}

	/**
	 * Default Breadcrumbs instrumentations
	 * TODO: Deprecated - with v6, this will be renamed to `Instrument`
	 */

	var Breadcrumbs =
	/** @class */
	function () {
	  /**
	   * @inheritDoc
	   */
	  function Breadcrumbs(options) {
	    /**
	     * @inheritDoc
	     */
	    this.name = Breadcrumbs.id;
	    this._options = __assign$4({
	      console: true,
	      dom: true,
	      fetch: true,
	      history: true,
	      sentry: true,
	      xhr: true
	    }, options);
	  }
	  /**
	   * Create a breadcrumb of `sentry` from the events themselves
	   */


	  Breadcrumbs.prototype.addSentryBreadcrumb = function (event) {
	    if (!this._options.sentry) {
	      return;
	    }

	    getCurrentHub().addBreadcrumb({
	      category: "sentry." + (event.type === 'transaction' ? 'transaction' : 'event'),
	      event_id: event.event_id,
	      level: event.level,
	      message: getEventDescription(event)
	    }, {
	      event: event
	    });
	  };
	  /**
	   * Instrument browser built-ins w/ breadcrumb capturing
	   *  - Console API
	   *  - DOM API (click/typing)
	   *  - XMLHttpRequest API
	   *  - Fetch API
	   *  - History API
	   */


	  Breadcrumbs.prototype.setupOnce = function () {
	    if (this._options.console) {
	      addInstrumentationHandler('console', _consoleBreadcrumb);
	    }

	    if (this._options.dom) {
	      addInstrumentationHandler('dom', _domBreadcrumb(this._options.dom));
	    }

	    if (this._options.xhr) {
	      addInstrumentationHandler('xhr', _xhrBreadcrumb);
	    }

	    if (this._options.fetch) {
	      addInstrumentationHandler('fetch', _fetchBreadcrumb);
	    }

	    if (this._options.history) {
	      addInstrumentationHandler('history', _historyBreadcrumb);
	    }
	  };
	  /**
	   * @inheritDoc
	   */


	  Breadcrumbs.id = 'Breadcrumbs';
	  return Breadcrumbs;
	}();
	/**
	 * A HOC that creaes a function that creates breadcrumbs from DOM API calls.
	 * This is a HOC so that we get access to dom options in the closure.
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any

	function _domBreadcrumb(dom) {
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  function _innerDomBreadcrumb(handlerData) {
	    var target;
	    var keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;

	    if (typeof keyAttrs === 'string') {
	      keyAttrs = [keyAttrs];
	    } // Accessing event.target can throw (see getsentry/raven-js#838, #768)


	    try {
	      target = handlerData.event.target ? htmlTreeAsString(handlerData.event.target, keyAttrs) : htmlTreeAsString(handlerData.event, keyAttrs);
	    } catch (e) {
	      target = '<unknown>';
	    }

	    if (target.length === 0) {
	      return;
	    }

	    getCurrentHub().addBreadcrumb({
	      category: "ui." + handlerData.name,
	      message: target
	    }, {
	      event: handlerData.event,
	      name: handlerData.name,
	      global: handlerData.global
	    });
	  }

	  return _innerDomBreadcrumb;
	}
	/**
	 * Creates breadcrumbs from console API calls
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _consoleBreadcrumb(handlerData) {
	  var breadcrumb = {
	    category: 'console',
	    data: {
	      arguments: handlerData.args,
	      logger: 'console'
	    },
	    level: severityFromString(handlerData.level),
	    message: safeJoin(handlerData.args, ' ')
	  };

	  if (handlerData.level === 'assert') {
	    if (handlerData.args[0] === false) {
	      breadcrumb.message = "Assertion failed: " + (safeJoin(handlerData.args.slice(1), ' ') || 'console.assert');
	      breadcrumb.data.arguments = handlerData.args.slice(1);
	    } else {
	      // Don't capture a breadcrumb for passed assertions
	      return;
	    }
	  }

	  getCurrentHub().addBreadcrumb(breadcrumb, {
	    input: handlerData.args,
	    level: handlerData.level
	  });
	}
	/**
	 * Creates breadcrumbs from XHR API calls
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _xhrBreadcrumb(handlerData) {
	  if (handlerData.endTimestamp) {
	    // We only capture complete, non-sentry requests
	    if (handlerData.xhr.__sentry_own_request__) {
	      return;
	    }

	    var _a = handlerData.xhr.__sentry_xhr__ || {},
	        method = _a.method,
	        url = _a.url,
	        status_code = _a.status_code,
	        body = _a.body;

	    getCurrentHub().addBreadcrumb({
	      category: 'xhr',
	      data: {
	        method: method,
	        url: url,
	        status_code: status_code
	      },
	      type: 'http'
	    }, {
	      xhr: handlerData.xhr,
	      input: body
	    });
	    return;
	  }
	}
	/**
	 * Creates breadcrumbs from fetch API calls
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _fetchBreadcrumb(handlerData) {
	  // We only capture complete fetch requests
	  if (!handlerData.endTimestamp) {
	    return;
	  }

	  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {
	    // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)
	    return;
	  }

	  if (handlerData.error) {
	    getCurrentHub().addBreadcrumb({
	      category: 'fetch',
	      data: handlerData.fetchData,
	      level: Severity.Error,
	      type: 'http'
	    }, {
	      data: handlerData.error,
	      input: handlerData.args
	    });
	  } else {
	    getCurrentHub().addBreadcrumb({
	      category: 'fetch',
	      data: __assign$4(__assign$4({}, handlerData.fetchData), {
	        status_code: handlerData.response.status
	      }),
	      type: 'http'
	    }, {
	      input: handlerData.args,
	      response: handlerData.response
	    });
	  }
	}
	/**
	 * Creates breadcrumbs from history API calls
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	function _historyBreadcrumb(handlerData) {
	  var global = getGlobalObject();
	  var from = handlerData.from;
	  var to = handlerData.to;
	  var parsedLoc = parseUrl(global.location.href);
	  var parsedFrom = parseUrl(from);
	  var parsedTo = parseUrl(to); // Initial pushState doesn't provide `from` information

	  if (!parsedFrom.path) {
	    parsedFrom = parsedLoc;
	  } // Use only the path component of the URL if the URL matches the current
	  // document (almost all the time when using pushState)


	  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
	    to = parsedTo.relative;
	  }

	  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
	    from = parsedFrom.relative;
	  }

	  getCurrentHub().addBreadcrumb({
	    category: 'navigation',
	    data: {
	      from: from,
	      to: to
	    }
	  });
	}

	var DEFAULT_KEY = 'cause';
	var DEFAULT_LIMIT = 5;
	/** Adds SDK info to an event. */

	var LinkedErrors =
	/** @class */
	function () {
	  /**
	   * @inheritDoc
	   */
	  function LinkedErrors(options) {
	    if (options === void 0) {
	      options = {};
	    }
	    /**
	     * @inheritDoc
	     */


	    this.name = LinkedErrors.id;
	    this._key = options.key || DEFAULT_KEY;
	    this._limit = options.limit || DEFAULT_LIMIT;
	  }
	  /**
	   * @inheritDoc
	   */


	  LinkedErrors.prototype.setupOnce = function () {
	    addGlobalEventProcessor(function (event, hint) {
	      var self = getCurrentHub().getIntegration(LinkedErrors);
	      return self ? _handler(self._key, self._limit, event, hint) : event;
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  LinkedErrors.id = 'LinkedErrors';
	  return LinkedErrors;
	}();
	/**
	 * @inheritDoc
	 */

	function _handler(key, limit, event, hint) {
	  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
	    return event;
	  }

	  var linkedErrors = _walkErrorTree(limit, hint.originalException, key);

	  event.exception.values = __spread$5(linkedErrors, event.exception.values);
	  return event;
	}
	/**
	 * JSDOC
	 */

	function _walkErrorTree(limit, error, key, stack) {
	  if (stack === void 0) {
	    stack = [];
	  }

	  if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
	    return stack;
	  }

	  var exception = exceptionFromError(error[key]);
	  return _walkErrorTree(limit, error[key], key, __spread$5([exception], stack));
	}

	var global$5 = getGlobalObject();
	/** UserAgent */

	var UserAgent =
	/** @class */
	function () {
	  function UserAgent() {
	    /**
	     * @inheritDoc
	     */
	    this.name = UserAgent.id;
	  }
	  /**
	   * @inheritDoc
	   */


	  UserAgent.prototype.setupOnce = function () {
	    addGlobalEventProcessor(function (event) {
	      if (getCurrentHub().getIntegration(UserAgent)) {
	        // if none of the information we want exists, don't bother
	        if (!global$5.navigator && !global$5.location && !global$5.document) {
	          return event;
	        } // grab as much info as exists and add it to the event


	        var url = event.request && event.request.url || global$5.location && global$5.location.href;
	        var referrer = (global$5.document || {}).referrer;
	        var userAgent = (global$5.navigator || {}).userAgent;

	        var headers = __assign$4(__assign$4(__assign$4({}, event.request && event.request.headers), referrer && {
	          Referer: referrer
	        }), userAgent && {
	          'User-Agent': userAgent
	        });

	        var request = __assign$4(__assign$4({}, url && {
	          url: url
	        }), {
	          headers: headers
	        });

	        return __assign$4(__assign$4({}, event), {
	          request: request
	        });
	      }

	      return event;
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  UserAgent.id = 'UserAgent';
	  return UserAgent;
	}();

	/** Deduplication filter */

	var Dedupe =
	/** @class */
	function () {
	  function Dedupe() {
	    /**
	     * @inheritDoc
	     */
	    this.name = Dedupe.id;
	  }
	  /**
	   * @inheritDoc
	   */


	  Dedupe.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
	    addGlobalEventProcessor(function (currentEvent) {
	      var self = getCurrentHub().getIntegration(Dedupe);

	      if (self) {
	        // Juuust in case something goes wrong
	        try {
	          if (_shouldDropEvent(currentEvent, self._previousEvent)) {
	            IS_DEBUG_BUILD$1 && logger.warn('Event dropped due to being a duplicate of previously captured event.');
	            return null;
	          }
	        } catch (_oO) {
	          return self._previousEvent = currentEvent;
	        }

	        return self._previousEvent = currentEvent;
	      }

	      return currentEvent;
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  Dedupe.id = 'Dedupe';
	  return Dedupe;
	}();
	/** JSDoc */

	function _shouldDropEvent(currentEvent, previousEvent) {
	  if (!previousEvent) {
	    return false;
	  }

	  if (_isSameMessageEvent(currentEvent, previousEvent)) {
	    return true;
	  }

	  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
	    return true;
	  }

	  return false;
	}
	/** JSDoc */


	function _isSameMessageEvent(currentEvent, previousEvent) {
	  var currentMessage = currentEvent.message;
	  var previousMessage = previousEvent.message; // If neither event has a message property, they were both exceptions, so bail out

	  if (!currentMessage && !previousMessage) {
	    return false;
	  } // If only one event has a stacktrace, but not the other one, they are not the same


	  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
	    return false;
	  }

	  if (currentMessage !== previousMessage) {
	    return false;
	  }

	  if (!_isSameFingerprint(currentEvent, previousEvent)) {
	    return false;
	  }

	  if (!_isSameStacktrace(currentEvent, previousEvent)) {
	    return false;
	  }

	  return true;
	}
	/** JSDoc */


	function _isSameExceptionEvent(currentEvent, previousEvent) {
	  var previousException = _getExceptionFromEvent(previousEvent);

	  var currentException = _getExceptionFromEvent(currentEvent);

	  if (!previousException || !currentException) {
	    return false;
	  }

	  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
	    return false;
	  }

	  if (!_isSameFingerprint(currentEvent, previousEvent)) {
	    return false;
	  }

	  if (!_isSameStacktrace(currentEvent, previousEvent)) {
	    return false;
	  }

	  return true;
	}
	/** JSDoc */


	function _isSameStacktrace(currentEvent, previousEvent) {
	  var currentFrames = _getFramesFromEvent(currentEvent);

	  var previousFrames = _getFramesFromEvent(previousEvent); // If neither event has a stacktrace, they are assumed to be the same


	  if (!currentFrames && !previousFrames) {
	    return true;
	  } // If only one event has a stacktrace, but not the other one, they are not the same


	  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
	    return false;
	  }

	  currentFrames = currentFrames;
	  previousFrames = previousFrames; // If number of frames differ, they are not the same

	  if (previousFrames.length !== currentFrames.length) {
	    return false;
	  } // Otherwise, compare the two


	  for (var i = 0; i < previousFrames.length; i++) {
	    var frameA = previousFrames[i];
	    var frameB = currentFrames[i];

	    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
	      return false;
	    }
	  }

	  return true;
	}
	/** JSDoc */


	function _isSameFingerprint(currentEvent, previousEvent) {
	  var currentFingerprint = currentEvent.fingerprint;
	  var previousFingerprint = previousEvent.fingerprint; // If neither event has a fingerprint, they are assumed to be the same

	  if (!currentFingerprint && !previousFingerprint) {
	    return true;
	  } // If only one event has a fingerprint, but not the other one, they are not the same


	  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
	    return false;
	  }

	  currentFingerprint = currentFingerprint;
	  previousFingerprint = previousFingerprint; // Otherwise, compare the two

	  try {
	    return !!(currentFingerprint.join('') === previousFingerprint.join(''));
	  } catch (_oO) {
	    return false;
	  }
	}
	/** JSDoc */


	function _getExceptionFromEvent(event) {
	  return event.exception && event.exception.values && event.exception.values[0];
	}
	/** JSDoc */


	function _getFramesFromEvent(event) {
	  var exception = event.exception;

	  if (exception) {
	    try {
	      // @ts-ignore Object could be undefined
	      return exception.values[0].stacktrace.frames;
	    } catch (_oO) {
	      return undefined;
	    }
	  } else if (event.stacktrace) {
	    return event.stacktrace.frames;
	  }

	  return undefined;
	}

	/**
	 * The Sentry Browser SDK Client.
	 *
	 * @see BrowserOptions for documentation on configuration options.
	 * @see SentryClient for usage documentation.
	 */

	var BrowserClient =
	/** @class */
	function (_super) {
	  __extends$2(BrowserClient, _super);
	  /**
	   * Creates a new Browser SDK instance.
	   *
	   * @param options Configuration options for this SDK.
	   */


	  function BrowserClient(options) {
	    if (options === void 0) {
	      options = {};
	    }

	    var _this = this;

	    options._metadata = options._metadata || {};
	    options._metadata.sdk = options._metadata.sdk || {
	      name: 'sentry.javascript.browser',
	      packages: [{
	        name: 'npm:@sentry/browser',
	        version: SDK_VERSION
	      }],
	      version: SDK_VERSION
	    };
	    _this = _super.call(this, BrowserBackend, options) || this;
	    return _this;
	  }
	  /**
	   * Show a report dialog to the user to send feedback to a specific event.
	   *
	   * @param options Set individual options for the dialog
	   */


	  BrowserClient.prototype.showReportDialog = function (options) {
	    if (options === void 0) {
	      options = {};
	    } // doesn't work without a document (React Native)


	    var document = getGlobalObject().document;

	    if (!document) {
	      return;
	    }

	    if (!this._isEnabled()) {
	      IS_DEBUG_BUILD$1 && logger.error('Trying to call showReportDialog with Sentry Client disabled');
	      return;
	    }

	    injectReportDialog(__assign$4(__assign$4({}, options), {
	      dsn: options.dsn || this.getDsn()
	    }));
	  };
	  /**
	   * @inheritDoc
	   */


	  BrowserClient.prototype._prepareEvent = function (event, scope, hint) {
	    event.platform = event.platform || 'javascript';
	    return _super.prototype._prepareEvent.call(this, event, scope, hint);
	  };
	  /**
	   * @inheritDoc
	   */


	  BrowserClient.prototype._sendEvent = function (event) {
	    var integration = this.getIntegration(Breadcrumbs);

	    if (integration) {
	      integration.addSentryBreadcrumb(event);
	    }

	    _super.prototype._sendEvent.call(this, event);
	  };

	  return BrowserClient;
	}(BaseClient);

	var defaultIntegrations = [new InboundFilters(), new FunctionToString(), new TryCatch(), new Breadcrumbs(), new GlobalHandlers(), new LinkedErrors(), new Dedupe(), new UserAgent()];
	/**
	 * The Sentry Browser SDK Client.
	 *
	 * To use this SDK, call the {@link init} function as early as possible when
	 * loading the web page. To set context information or send manual events, use
	 * the provided methods.
	 *
	 * @example
	 *
	 * ```
	 *
	 * import { init } from '@sentry/browser';
	 *
	 * init({
	 *   dsn: '__DSN__',
	 *   // ...
	 * });
	 * ```
	 *
	 * @example
	 * ```
	 *
	 * import { configureScope } from '@sentry/browser';
	 * configureScope((scope: Scope) => {
	 *   scope.setExtra({ battery: 0.7 });
	 *   scope.setTag({ user_mode: 'admin' });
	 *   scope.setUser({ id: '4711' });
	 * });
	 * ```
	 *
	 * @example
	 * ```
	 *
	 * import { addBreadcrumb } from '@sentry/browser';
	 * addBreadcrumb({
	 *   message: 'My Breadcrumb',
	 *   // ...
	 * });
	 * ```
	 *
	 * @example
	 *
	 * ```
	 *
	 * import * as Sentry from '@sentry/browser';
	 * Sentry.captureMessage('Hello, world!');
	 * Sentry.captureException(new Error('Good bye'));
	 * Sentry.captureEvent({
	 *   message: 'Manual',
	 *   stacktrace: [
	 *     // ...
	 *   ],
	 * });
	 * ```
	 *
	 * @see {@link BrowserOptions} for documentation on configuration options.
	 */

	function init(options) {
	  if (options === void 0) {
	    options = {};
	  }

	  if (options.defaultIntegrations === undefined) {
	    options.defaultIntegrations = defaultIntegrations;
	  }

	  if (options.release === undefined) {
	    var window_1 = getGlobalObject(); // This supports the variable that sentry-webpack-plugin injects

	    if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
	      options.release = window_1.SENTRY_RELEASE.id;
	    }
	  }

	  if (options.autoSessionTracking === undefined) {
	    options.autoSessionTracking = true;
	  }

	  if (options.sendClientReports === undefined) {
	    options.sendClientReports = true;
	  }

	  initAndBind(BrowserClient, options);

	  if (options.autoSessionTracking) {
	    startSessionTracking();
	  }
	}
	/**
	 * Call `close()` on the current client, if there is one. See {@link Client.close}.
	 *
	 * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
	 * parameter will cause the client to wait until all events are sent before disabling itself.
	 * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
	 * doesn't (or if there's no client defined).
	 */

	function close(timeout) {
	  var client = getCurrentHub().getClient();

	  if (client) {
	    return client.close(timeout);
	  }

	  IS_DEBUG_BUILD$1 && logger.warn('Cannot flush events and disable SDK. No client defined.');
	  return resolvedSyncPromise(false);
	}

	function startSessionOnHub(hub) {
	  hub.startSession({
	    ignoreDuration: true
	  });
	  hub.captureSession();
	}
	/**
	 * Enable automatic Session Tracking for the initial page load.
	 */


	function startSessionTracking() {
	  var window = getGlobalObject();
	  var document = window.document;

	  if (typeof document === 'undefined') {
	    IS_DEBUG_BUILD$1 && logger.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');
	    return;
	  }

	  var hub = getCurrentHub(); // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and
	  // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are
	  // pinned at the same version in package.json, but there are edge cases where it's possible. See
	  // https://github.com/getsentry/sentry-javascript/issues/3207 and
	  // https://github.com/getsentry/sentry-javascript/issues/3234 and
	  // https://github.com/getsentry/sentry-javascript/issues/3278.

	  if (!hub.captureSession) {
	    return;
	  } // The session duration for browser sessions does not track a meaningful
	  // concept that can be used as a metric.
	  // Automatically captured sessions are akin to page views, and thus we
	  // discard their duration.


	  startSessionOnHub(hub); // We want to create a session for every navigation as well

	  addInstrumentationHandler('history', function (_a) {
	    var from = _a.from,
	        to = _a.to; // Don't create an additional session for the initial route or if the location did not change

	    if (!(from === undefined || from === to)) {
	      startSessionOnHub(getCurrentHub());
	    }
	  });
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	/* global Reflect, Promise */
	var extendStatics = function (d, b) {
	  extendStatics = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	  };

	  return extendStatics(d, b);
	};

	function __extends(d, b) {
	  extendStatics(d, b);

	  function __() {
	    this.constructor = d;
	  }

	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	var __assign = function () {
	  __assign = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];

	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }

	    return t;
	  };

	  return __assign.apply(this, arguments);
	};
	function __rest(s, e) {
	  var t = {};

	  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

	  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	  }
	  return t;
	}
	function __values(o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	      m = s && o[s],
	      i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function () {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	function __read(o, n) {
	  var m = typeof Symbol === "function" && o[Symbol.iterator];
	  if (!m) return o;
	  var i = m.call(o),
	      r,
	      ar = [],
	      e;

	  try {
	    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	  } catch (error) {
	    e = {
	      error: error
	    };
	  } finally {
	    try {
	      if (r && !r.done && (m = i["return"])) m.call(i);
	    } finally {
	      if (e) throw e.error;
	    }
	  }

	  return ar;
	}
	function __spread() {
	  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

	  return ar;
	}

	/*
	 * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
	 * for users.
	 *
	 * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
	 * because some build tools have trouble tree-shaking imported guards.
	 *
	 * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
	 *
	 * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
	 * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
	 * replaced.
	 */

	/** Flag that is true for debug builds, false otherwise. */
	var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

	/**
	 * Determines if tracing is currently enabled.
	 *
	 * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.
	 */

	function hasTracingEnabled(maybeOptions) {
	  var client = getCurrentHub().getClient();
	  var options = maybeOptions || client && client.getOptions();
	  return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);
	}
	/** Grabs active transaction off scope, if any */

	function getActiveTransaction(maybeHub) {
	  var hub = maybeHub || getCurrentHub();
	  var scope = hub.getScope();
	  return scope && scope.getTransaction();
	}
	/**
	 * Converts from milliseconds to seconds
	 * @param time time in ms
	 */

	function msToSec(time) {
	  return time / 1000;
	}
	/**
	 * Converts from seconds to milliseconds
	 * @param time time in seconds
	 */

	function secToMs(time) {
	  return time * 1000;
	} // so it can be used in manual instrumentation without necessitating a hard dependency on @sentry/utils

	// Store finish reasons in tuple to save on bundle size
	// Readonly type should enforce that this is not mutated.
	var FINISH_REASON_TAG = 'finishReason';
	var IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden'];

	/**
	 * Keeps track of finished spans for a given transaction
	 * @internal
	 * @hideconstructor
	 * @hidden
	 */

	var SpanRecorder =
	/** @class */
	function () {
	  function SpanRecorder(maxlen) {
	    if (maxlen === void 0) {
	      maxlen = 1000;
	    }

	    this.spans = [];
	    this._maxlen = maxlen;
	  }
	  /**
	   * This is just so that we don't run out of memory while recording a lot
	   * of spans. At some point we just stop and flush out the start of the
	   * trace tree (i.e.the first n spans with the smallest
	   * start_timestamp).
	   */


	  SpanRecorder.prototype.add = function (span) {
	    if (this.spans.length > this._maxlen) {
	      span.spanRecorder = undefined;
	    } else {
	      this.spans.push(span);
	    }
	  };

	  return SpanRecorder;
	}();
	/**
	 * Span contains all data about a span
	 */

	var Span =
	/** @class */
	function () {
	  /**
	   * You should never call the constructor manually, always use `Sentry.startTransaction()`
	   * or call `startChild()` on an existing span.
	   * @internal
	   * @hideconstructor
	   * @hidden
	   */
	  function Span(spanContext) {
	    /**
	     * @inheritDoc
	     */
	    this.traceId = uuid4();
	    /**
	     * @inheritDoc
	     */

	    this.spanId = uuid4().substring(16);
	    /**
	     * Timestamp in seconds when the span was created.
	     */

	    this.startTimestamp = timestampWithMs();
	    /**
	     * @inheritDoc
	     */

	    this.tags = {};
	    /**
	     * @inheritDoc
	     */
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    this.data = {};

	    if (!spanContext) {
	      return this;
	    }

	    if (spanContext.traceId) {
	      this.traceId = spanContext.traceId;
	    }

	    if (spanContext.spanId) {
	      this.spanId = spanContext.spanId;
	    }

	    if (spanContext.parentSpanId) {
	      this.parentSpanId = spanContext.parentSpanId;
	    } // We want to include booleans as well here


	    if ('sampled' in spanContext) {
	      this.sampled = spanContext.sampled;
	    }

	    if (spanContext.op) {
	      this.op = spanContext.op;
	    }

	    if (spanContext.description) {
	      this.description = spanContext.description;
	    }

	    if (spanContext.data) {
	      this.data = spanContext.data;
	    }

	    if (spanContext.tags) {
	      this.tags = spanContext.tags;
	    }

	    if (spanContext.status) {
	      this.status = spanContext.status;
	    }

	    if (spanContext.startTimestamp) {
	      this.startTimestamp = spanContext.startTimestamp;
	    }

	    if (spanContext.endTimestamp) {
	      this.endTimestamp = spanContext.endTimestamp;
	    }
	  }
	  /**
	   * @inheritDoc
	   * @deprecated
	   */


	  Span.prototype.child = function (spanContext) {
	    return this.startChild(spanContext);
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.startChild = function (spanContext) {
	    var childSpan = new Span(__assign(__assign({}, spanContext), {
	      parentSpanId: this.spanId,
	      sampled: this.sampled,
	      traceId: this.traceId
	    }));
	    childSpan.spanRecorder = this.spanRecorder;

	    if (childSpan.spanRecorder) {
	      childSpan.spanRecorder.add(childSpan);
	    }

	    childSpan.transaction = this.transaction;
	    return childSpan;
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.setTag = function (key, value) {
	    var _a;

	    this.tags = __assign(__assign({}, this.tags), (_a = {}, _a[key] = value, _a));
	    return this;
	  };
	  /**
	   * @inheritDoc
	   */
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types


	  Span.prototype.setData = function (key, value) {
	    var _a;

	    this.data = __assign(__assign({}, this.data), (_a = {}, _a[key] = value, _a));
	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.setStatus = function (value) {
	    this.status = value;
	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.setHttpStatus = function (httpStatus) {
	    this.setTag('http.status_code', String(httpStatus));
	    var spanStatus = spanStatusfromHttpCode(httpStatus);

	    if (spanStatus !== 'unknown_error') {
	      this.setStatus(spanStatus);
	    }

	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.isSuccess = function () {
	    return this.status === 'ok';
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.finish = function (endTimestamp) {
	    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.toTraceparent = function () {
	    var sampledString = '';

	    if (this.sampled !== undefined) {
	      sampledString = this.sampled ? '-1' : '-0';
	    }

	    return this.traceId + "-" + this.spanId + sampledString;
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.toContext = function () {
	    return dropUndefinedKeys({
	      data: this.data,
	      description: this.description,
	      endTimestamp: this.endTimestamp,
	      op: this.op,
	      parentSpanId: this.parentSpanId,
	      sampled: this.sampled,
	      spanId: this.spanId,
	      startTimestamp: this.startTimestamp,
	      status: this.status,
	      tags: this.tags,
	      traceId: this.traceId
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.updateWithContext = function (spanContext) {
	    var _a, _b, _c, _d, _e;

	    this.data = (_a = spanContext.data, _a !== null && _a !== void 0 ? _a : {});
	    this.description = spanContext.description;
	    this.endTimestamp = spanContext.endTimestamp;
	    this.op = spanContext.op;
	    this.parentSpanId = spanContext.parentSpanId;
	    this.sampled = spanContext.sampled;
	    this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
	    this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
	    this.status = spanContext.status;
	    this.tags = (_d = spanContext.tags, _d !== null && _d !== void 0 ? _d : {});
	    this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
	    return this;
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.getTraceContext = function () {
	    return dropUndefinedKeys({
	      data: Object.keys(this.data).length > 0 ? this.data : undefined,
	      description: this.description,
	      op: this.op,
	      parent_span_id: this.parentSpanId,
	      span_id: this.spanId,
	      status: this.status,
	      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
	      trace_id: this.traceId
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  Span.prototype.toJSON = function () {
	    return dropUndefinedKeys({
	      data: Object.keys(this.data).length > 0 ? this.data : undefined,
	      description: this.description,
	      op: this.op,
	      parent_span_id: this.parentSpanId,
	      span_id: this.spanId,
	      start_timestamp: this.startTimestamp,
	      status: this.status,
	      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
	      timestamp: this.endTimestamp,
	      trace_id: this.traceId
	    });
	  };

	  return Span;
	}();
	/**
	 * Converts a HTTP status code into a {@link SpanStatusType}.
	 *
	 * @param httpStatus The HTTP response status code.
	 * @returns The span status or unknown_error.
	 */

	function spanStatusfromHttpCode(httpStatus) {
	  if (httpStatus < 400 && httpStatus >= 100) {
	    return 'ok';
	  }

	  if (httpStatus >= 400 && httpStatus < 500) {
	    switch (httpStatus) {
	      case 401:
	        return 'unauthenticated';

	      case 403:
	        return 'permission_denied';

	      case 404:
	        return 'not_found';

	      case 409:
	        return 'already_exists';

	      case 413:
	        return 'failed_precondition';

	      case 429:
	        return 'resource_exhausted';

	      default:
	        return 'invalid_argument';
	    }
	  }

	  if (httpStatus >= 500 && httpStatus < 600) {
	    switch (httpStatus) {
	      case 501:
	        return 'unimplemented';

	      case 503:
	        return 'unavailable';

	      case 504:
	        return 'deadline_exceeded';

	      default:
	        return 'internal_error';
	    }
	  }

	  return 'unknown_error';
	}

	/** JSDoc */

	var Transaction =
	/** @class */
	function (_super) {
	  __extends(Transaction, _super);
	  /**
	   * This constructor should never be called manually. Those instrumenting tracing should use
	   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
	   * @internal
	   * @hideconstructor
	   * @hidden
	   */


	  function Transaction(transactionContext, hub) {
	    var _this = _super.call(this, transactionContext) || this;

	    _this._measurements = {};
	    /**
	     * The reference to the current hub.
	     */

	    _this._hub = getCurrentHub();

	    if (isInstanceOf(hub, Hub)) {
	      _this._hub = hub;
	    }

	    _this.name = transactionContext.name || '';
	    _this.metadata = transactionContext.metadata || {};
	    _this._trimEnd = transactionContext.trimEnd; // this is because transactions are also spans, and spans have a transaction pointer

	    _this.transaction = _this;
	    return _this;
	  }
	  /**
	   * JSDoc
	   */


	  Transaction.prototype.setName = function (name) {
	    this.name = name;
	  };
	  /**
	   * Attaches SpanRecorder to the span itself
	   * @param maxlen maximum number of spans that can be recorded
	   */


	  Transaction.prototype.initSpanRecorder = function (maxlen) {
	    if (maxlen === void 0) {
	      maxlen = 1000;
	    }

	    if (!this.spanRecorder) {
	      this.spanRecorder = new SpanRecorder(maxlen);
	    }

	    this.spanRecorder.add(this);
	  };
	  /**
	   * Set observed measurements for this transaction.
	   * @hidden
	   */


	  Transaction.prototype.setMeasurements = function (measurements) {
	    this._measurements = __assign({}, measurements);
	  };
	  /**
	   * Set metadata for this transaction.
	   * @hidden
	   */


	  Transaction.prototype.setMetadata = function (newMetadata) {
	    this.metadata = __assign(__assign({}, this.metadata), newMetadata);
	  };
	  /**
	   * @inheritDoc
	   */


	  Transaction.prototype.finish = function (endTimestamp) {
	    var _this = this; // This transaction is already finished, so we should not flush it again.


	    if (this.endTimestamp !== undefined) {
	      return undefined;
	    }

	    if (!this.name) {
	      IS_DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');
	      this.name = '<unlabeled transaction>';
	    } // just sets the end timestamp


	    _super.prototype.finish.call(this, endTimestamp);

	    if (this.sampled !== true) {
	      // At this point if `sampled !== true` we want to discard the transaction.
	      IS_DEBUG_BUILD && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');

	      var client = this._hub.getClient();

	      var transport = client && client.getTransport && client.getTransport();

	      if (transport && transport.recordLostEvent) {
	        transport.recordLostEvent('sample_rate', 'transaction');
	      }

	      return undefined;
	    }

	    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) {
	      return s !== _this && s.endTimestamp;
	    }) : [];

	    if (this._trimEnd && finishedSpans.length > 0) {
	      this.endTimestamp = finishedSpans.reduce(function (prev, current) {
	        if (prev.endTimestamp && current.endTimestamp) {
	          return prev.endTimestamp > current.endTimestamp ? prev : current;
	        }

	        return prev;
	      }).endTimestamp;
	    }

	    var transaction = {
	      contexts: {
	        trace: this.getTraceContext()
	      },
	      spans: finishedSpans,
	      start_timestamp: this.startTimestamp,
	      tags: this.tags,
	      timestamp: this.endTimestamp,
	      transaction: this.name,
	      type: 'transaction',
	      sdkProcessingMetadata: this.metadata
	    };
	    var hasMeasurements = Object.keys(this._measurements).length > 0;

	    if (hasMeasurements) {
	      IS_DEBUG_BUILD && logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));
	      transaction.measurements = this._measurements;
	    }

	    IS_DEBUG_BUILD && logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
	    return this._hub.captureEvent(transaction);
	  };
	  /**
	   * @inheritDoc
	   */


	  Transaction.prototype.toContext = function () {
	    var spanContext = _super.prototype.toContext.call(this);

	    return dropUndefinedKeys(__assign(__assign({}, spanContext), {
	      name: this.name,
	      trimEnd: this._trimEnd
	    }));
	  };
	  /**
	   * @inheritDoc
	   */


	  Transaction.prototype.updateWithContext = function (transactionContext) {
	    var _a;

	    _super.prototype.updateWithContext.call(this, transactionContext);

	    this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : '');
	    this._trimEnd = transactionContext.trimEnd;
	    return this;
	  };

	  return Transaction;
	}(Span);

	var DEFAULT_IDLE_TIMEOUT = 1000;
	var HEARTBEAT_INTERVAL = 5000;
	/**
	 * @inheritDoc
	 */

	var IdleTransactionSpanRecorder =
	/** @class */
	function (_super) {
	  __extends(IdleTransactionSpanRecorder, _super);

	  function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {
	    if (transactionSpanId === void 0) {
	      transactionSpanId = '';
	    }

	    var _this = _super.call(this, maxlen) || this;

	    _this._pushActivity = _pushActivity;
	    _this._popActivity = _popActivity;
	    _this.transactionSpanId = transactionSpanId;
	    return _this;
	  }
	  /**
	   * @inheritDoc
	   */


	  IdleTransactionSpanRecorder.prototype.add = function (span) {
	    var _this = this; // We should make sure we do not push and pop activities for
	    // the transaction that this span recorder belongs to.


	    if (span.spanId !== this.transactionSpanId) {
	      // We patch span.finish() to pop an activity after setting an endTimestamp.
	      span.finish = function (endTimestamp) {
	        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();

	        _this._popActivity(span.spanId);
	      }; // We should only push new activities if the span does not have an end timestamp.


	      if (span.endTimestamp === undefined) {
	        this._pushActivity(span.spanId);
	      }
	    }

	    _super.prototype.add.call(this, span);
	  };

	  return IdleTransactionSpanRecorder;
	}(SpanRecorder);
	/**
	 * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.
	 * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will
	 * put itself on the scope on creation.
	 */

	var IdleTransaction =
	/** @class */
	function (_super) {
	  __extends(IdleTransaction, _super);

	  function IdleTransaction(transactionContext, _idleHub,
	  /**
	   * The time to wait in ms until the idle transaction will be finished.
	   * @default 1000
	   */
	  _idleTimeout, // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends
	  _onScope) {
	    if (_idleTimeout === void 0) {
	      _idleTimeout = DEFAULT_IDLE_TIMEOUT;
	    }

	    if (_onScope === void 0) {
	      _onScope = false;
	    }

	    var _this = _super.call(this, transactionContext, _idleHub) || this;

	    _this._idleHub = _idleHub;
	    _this._idleTimeout = _idleTimeout;
	    _this._onScope = _onScope; // Activities store a list of active spans

	    _this.activities = {}; // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.

	    _this._heartbeatCounter = 0; // We should not use heartbeat if we finished a transaction

	    _this._finished = false;
	    _this._beforeFinishCallbacks = [];

	    if (_idleHub && _onScope) {
	      // There should only be one active transaction on the scope
	      clearActiveTransaction(_idleHub); // We set the transaction here on the scope so error events pick up the trace
	      // context and attach it to the error.

	      IS_DEBUG_BUILD && logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);

	      _idleHub.configureScope(function (scope) {
	        return scope.setSpan(_this);
	      });
	    }

	    _this._initTimeout = setTimeout(function () {
	      if (!_this._finished) {
	        _this.finish();
	      }
	    }, _this._idleTimeout);
	    return _this;
	  }
	  /** {@inheritDoc} */


	  IdleTransaction.prototype.finish = function (endTimestamp) {
	    var e_1, _a;

	    var _this = this;

	    if (endTimestamp === void 0) {
	      endTimestamp = timestampWithMs();
	    }

	    this._finished = true;
	    this.activities = {};

	    if (this.spanRecorder) {
	      IS_DEBUG_BUILD && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);

	      try {
	        for (var _b = __values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
	          var callback = _c.value;
	          callback(this, endTimestamp);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }

	      this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {
	        // If we are dealing with the transaction itself, we just return it
	        if (span.spanId === _this.spanId) {
	          return true;
	        } // We cancel all pending spans with status "cancelled" to indicate the idle transaction was finished early


	        if (!span.endTimestamp) {
	          span.endTimestamp = endTimestamp;
	          span.setStatus('cancelled');
	          IS_DEBUG_BUILD && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));
	        }

	        var keepSpan = span.startTimestamp < endTimestamp;

	        if (!keepSpan) {
	          IS_DEBUG_BUILD && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));
	        }

	        return keepSpan;
	      });
	      IS_DEBUG_BUILD && logger.log('[Tracing] flushing IdleTransaction');
	    } else {
	      IS_DEBUG_BUILD && logger.log('[Tracing] No active IdleTransaction');
	    } // if `this._onScope` is `true`, the transaction put itself on the scope when it started


	    if (this._onScope) {
	      clearActiveTransaction(this._idleHub);
	    }

	    return _super.prototype.finish.call(this, endTimestamp);
	  };
	  /**
	   * Register a callback function that gets excecuted before the transaction finishes.
	   * Useful for cleanup or if you want to add any additional spans based on current context.
	   *
	   * This is exposed because users have no other way of running something before an idle transaction
	   * finishes.
	   */


	  IdleTransaction.prototype.registerBeforeFinishCallback = function (callback) {
	    this._beforeFinishCallbacks.push(callback);
	  };
	  /**
	   * @inheritDoc
	   */


	  IdleTransaction.prototype.initSpanRecorder = function (maxlen) {
	    var _this = this;

	    if (!this.spanRecorder) {
	      var pushActivity = function (id) {
	        if (_this._finished) {
	          return;
	        }

	        _this._pushActivity(id);
	      };

	      var popActivity = function (id) {
	        if (_this._finished) {
	          return;
	        }

	        _this._popActivity(id);
	      };

	      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen); // Start heartbeat so that transactions do not run forever.

	      IS_DEBUG_BUILD && logger.log('Starting heartbeat');

	      this._pingHeartbeat();
	    }

	    this.spanRecorder.add(this);
	  };
	  /**
	   * Start tracking a specific activity.
	   * @param spanId The span id that represents the activity
	   */


	  IdleTransaction.prototype._pushActivity = function (spanId) {
	    if (this._initTimeout) {
	      clearTimeout(this._initTimeout);
	      this._initTimeout = undefined;
	    }

	    IS_DEBUG_BUILD && logger.log("[Tracing] pushActivity: " + spanId);
	    this.activities[spanId] = true;
	    IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);
	  };
	  /**
	   * Remove an activity from usage
	   * @param spanId The span id that represents the activity
	   */


	  IdleTransaction.prototype._popActivity = function (spanId) {
	    var _this = this;

	    if (this.activities[spanId]) {
	      IS_DEBUG_BUILD && logger.log("[Tracing] popActivity " + spanId); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete

	      delete this.activities[spanId];
	      IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);
	    }

	    if (Object.keys(this.activities).length === 0) {
	      var timeout = this._idleTimeout; // We need to add the timeout here to have the real endtimestamp of the transaction
	      // Remember timestampWithMs is in seconds, timeout is in ms

	      var end_1 = timestampWithMs() + timeout / 1000;
	      setTimeout(function () {
	        if (!_this._finished) {
	          _this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);

	          _this.finish(end_1);
	        }
	      }, timeout);
	    }
	  };
	  /**
	   * Checks when entries of this.activities are not changing for 3 beats.
	   * If this occurs we finish the transaction.
	   */


	  IdleTransaction.prototype._beat = function () {
	    // We should not be running heartbeat if the idle transaction is finished.
	    if (this._finished) {
	      return;
	    }

	    var heartbeatString = Object.keys(this.activities).join('');

	    if (heartbeatString === this._prevHeartbeatString) {
	      this._heartbeatCounter += 1;
	    } else {
	      this._heartbeatCounter = 1;
	    }

	    this._prevHeartbeatString = heartbeatString;

	    if (this._heartbeatCounter >= 3) {
	      IS_DEBUG_BUILD && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');
	      this.setStatus('deadline_exceeded');
	      this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);
	      this.finish();
	    } else {
	      this._pingHeartbeat();
	    }
	  };
	  /**
	   * Pings the heartbeat
	   */


	  IdleTransaction.prototype._pingHeartbeat = function () {
	    var _this = this;

	    IS_DEBUG_BUILD && logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
	    setTimeout(function () {
	      _this._beat();
	    }, HEARTBEAT_INTERVAL);
	  };

	  return IdleTransaction;
	}(Transaction);
	/**
	 * Reset transaction on scope to `undefined`
	 */

	function clearActiveTransaction(hub) {
	  if (hub) {
	    var scope = hub.getScope();

	    if (scope) {
	      var transaction = scope.getTransaction();

	      if (transaction) {
	        scope.setSpan(undefined);
	      }
	    }
	  }
	}

	/**
	 * Makes a sampling decision for the given transaction and stores it on the transaction.
	 *
	 * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be
	 * sent to Sentry.
	 *
	 * @param transaction: The transaction needing a sampling decision
	 * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`
	 * @param samplingContext: Default and user-provided data which may be used to help make the decision
	 *
	 * @returns The given transaction with its `sampled` value set
	 */


	function sample(transaction, options, samplingContext) {
	  // nothing to do if tracing is not enabled
	  if (!hasTracingEnabled(options)) {
	    transaction.sampled = false;
	    return transaction;
	  } // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that


	  if (transaction.sampled !== undefined) {
	    transaction.setMetadata({
	      transactionSampling: {
	        method: 'explicitly_set'
	      }
	    });
	    return transaction;
	  } // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should
	  // work; prefer the hook if so


	  var sampleRate;

	  if (typeof options.tracesSampler === 'function') {
	    sampleRate = options.tracesSampler(samplingContext);
	    transaction.setMetadata({
	      transactionSampling: {
	        method: 'client_sampler',
	        // cast to number in case it's a boolean
	        rate: Number(sampleRate)
	      }
	    });
	  } else if (samplingContext.parentSampled !== undefined) {
	    sampleRate = samplingContext.parentSampled;
	    transaction.setMetadata({
	      transactionSampling: {
	        method: 'inheritance'
	      }
	    });
	  } else {
	    sampleRate = options.tracesSampleRate;
	    transaction.setMetadata({
	      transactionSampling: {
	        method: 'client_rate',
	        // cast to number in case it's a boolean
	        rate: Number(sampleRate)
	      }
	    });
	  } // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The
	  // only valid values are booleans or numbers between 0 and 1.)


	  if (!isValidSampleRate(sampleRate)) {
	    IS_DEBUG_BUILD && logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');
	    transaction.sampled = false;
	    return transaction;
	  } // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped


	  if (!sampleRate) {
	    IS_DEBUG_BUILD && logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === 'function' ? 'tracesSampler returned 0 or false' : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'));
	    transaction.sampled = false;
	    return transaction;
	  } // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is
	  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.


	  transaction.sampled = Math.random() < sampleRate; // if we're not going to keep it, we're done

	  if (!transaction.sampled) {
	    IS_DEBUG_BUILD && logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
	    return transaction;
	  }

	  IS_DEBUG_BUILD && logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
	  return transaction;
	}
	/**
	 * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).
	 */


	function isValidSampleRate(rate) {
	  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck
	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  if (isNaN$1(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {
	    IS_DEBUG_BUILD && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
	    return false;
	  } // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false


	  if (rate < 0 || rate > 1) {
	    IS_DEBUG_BUILD && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
	    return false;
	  }

	  return true;
	}
	/**
	 * Create new idle transaction.
	 */


	function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
	  var client = hub.getClient();
	  var options = client && client.getOptions() || {};
	  var transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);
	  transaction = sample(transaction, options, __assign({
	    parentSampled: transactionContext.parentSampled,
	    transactionContext: transactionContext
	  }, customSamplingContext));

	  if (transaction.sampled) {
	    transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
	  }

	  return transaction;
	}

	var global$4 = getGlobalObject();
	/**
	 * Add a listener that cancels and finishes a transaction when the global
	 * document is hidden.
	 */

	function registerBackgroundTabDetection() {
	  if (global$4 && global$4.document) {
	    global$4.document.addEventListener('visibilitychange', function () {
	      var activeTransaction = getActiveTransaction();

	      if (global$4.document.hidden && activeTransaction) {
	        var statusType = 'cancelled';
	        IS_DEBUG_BUILD && logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op); // We should not set status if it is already set, this prevent important statuses like
	        // error or data loss from being overwritten on transaction.

	        if (!activeTransaction.status) {
	          activeTransaction.setStatus(statusType);
	        }

	        activeTransaction.setTag('visibilitychange', 'document.hidden');
	        activeTransaction.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[2]);
	        activeTransaction.finish();
	      }
	    });
	  } else {
	    IS_DEBUG_BUILD && logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');
	  }
	}

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var bindReporter = function (callback, metric, reportAllChanges) {
	  var prevValue;
	  return function (forceReport) {
	    if (metric.value >= 0) {
	      if (forceReport || reportAllChanges) {
	        metric.delta = metric.value - (prevValue || 0); // Report the metric if there's a non-zero delta or if no previous
	        // value exists (which can happen in the case of the document becoming
	        // hidden when the metric value is 0).
	        // See: https://github.com/GoogleChrome/web-vitals/issues/14

	        if (metric.delta || prevValue === undefined) {
	          prevValue = metric.value;
	          callback(metric);
	        }
	      }
	    }
	  };
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * Performantly generate a unique, 30-char string by combining a version
	 * number, the current timestamp with a 13-digit number integer.
	 * @return {string}
	 */
	var generateUniqueID = function () {
	  return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var initMetric = function (name, value) {
	  return {
	    name: name,
	    value: value !== null && value !== void 0 ? value : -1,
	    delta: 0,
	    entries: [],
	    id: generateUniqueID()
	  };
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	/**
	 * Takes a performance entry type and a callback function, and creates a
	 * `PerformanceObserver` instance that will observe the specified entry type
	 * with buffering enabled and call the callback _for each entry_.
	 *
	 * This function also feature-detects entry support and wraps the logic in a
	 * try/catch to avoid errors in unsupporting browsers.
	 */
	var observe = function (type, callback) {
	  try {
	    if (PerformanceObserver.supportedEntryTypes.includes(type)) {
	      // More extensive feature detect needed for Firefox due to:
	      // https://github.com/GoogleChrome/web-vitals/issues/142
	      if (type === 'first-input' && !('PerformanceEventTiming' in self)) {
	        return;
	      }

	      var po = new PerformanceObserver(function (l) {
	        return l.getEntries().map(callback);
	      });
	      po.observe({
	        type: type,
	        buffered: true
	      });
	      return po;
	    }
	  } catch (e) {// Do nothing.
	  }

	  return;
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var onHidden = function (cb, once) {
	  var onHiddenOrPageHide = function (event) {
	    if (event.type === 'pagehide' || getGlobalObject().document.visibilityState === 'hidden') {
	      cb(event);

	      if (once) {
	        removeEventListener('visibilitychange', onHiddenOrPageHide, true);
	        removeEventListener('pagehide', onHiddenOrPageHide, true);
	      }
	    }
	  };

	  addEventListener('visibilitychange', onHiddenOrPageHide, true); // Some browsers have buggy implementations of visibilitychange,
	  // so we use pagehide in addition, just to be safe.

	  addEventListener('pagehide', onHiddenOrPageHide, true);
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var getCLS = function (onReport, reportAllChanges) {
	  var metric = initMetric('CLS', 0);
	  var report;
	  var sessionValue = 0;
	  var sessionEntries = [];

	  var entryHandler = function (entry) {
	    // Only count layout shifts without recent user input.
	    // TODO: Figure out why entry can be undefined
	    if (entry && !entry.hadRecentInput) {
	      var firstSessionEntry = sessionEntries[0];
	      var lastSessionEntry = sessionEntries[sessionEntries.length - 1]; // If the entry occurred less than 1 second after the previous entry and
	      // less than 5 seconds after the first entry in the session, include the
	      // entry in the current session. Otherwise, start a new session.

	      if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1000 && entry.startTime - firstSessionEntry.startTime < 5000) {
	        sessionValue += entry.value;
	        sessionEntries.push(entry);
	      } else {
	        sessionValue = entry.value;
	        sessionEntries = [entry];
	      } // If the current session value is larger than the current CLS value,
	      // update CLS and the entries contributing to it.


	      if (sessionValue > metric.value) {
	        metric.value = sessionValue;
	        metric.entries = sessionEntries;

	        if (report) {
	          report();
	        }
	      }
	    }
	  };

	  var po = observe('layout-shift', entryHandler);

	  if (po) {
	    report = bindReporter(onReport, metric, reportAllChanges);
	    onHidden(function () {
	      po.takeRecords().map(entryHandler);
	      report(true);
	    });
	  }
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var firstHiddenTime = -1;

	var initHiddenTime = function () {
	  return getGlobalObject().document.visibilityState === 'hidden' ? 0 : Infinity;
	};

	var trackChanges = function () {
	  // Update the time if/when the document becomes hidden.
	  onHidden(function (_a) {
	    var timeStamp = _a.timeStamp;
	    firstHiddenTime = timeStamp;
	  }, true);
	};

	var getVisibilityWatcher = function () {
	  if (firstHiddenTime < 0) {
	    // If the document is hidden when this code runs, assume it was hidden
	    // since navigation start. This isn't a perfect heuristic, but it's the
	    // best we can do until an API is available to support querying past
	    // visibilityState.
	    firstHiddenTime = initHiddenTime();
	    trackChanges();
	  }

	  return {
	    get firstHiddenTime() {
	      return firstHiddenTime;
	    }

	  };
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var getFID = function (onReport, reportAllChanges) {
	  var visibilityWatcher = getVisibilityWatcher();
	  var metric = initMetric('FID');
	  var report;

	  var entryHandler = function (entry) {
	    // Only report if the page wasn't hidden prior to the first input.
	    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
	      metric.value = entry.processingStart - entry.startTime;
	      metric.entries.push(entry);
	      report(true);
	    }
	  };

	  var po = observe('first-input', entryHandler);

	  if (po) {
	    report = bindReporter(onReport, metric, reportAllChanges);
	    onHidden(function () {
	      po.takeRecords().map(entryHandler);
	      po.disconnect();
	    }, true);
	  }
	};

	/*
	 * Copyright 2020 Google LLC
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var reportedMetricIDs = {};
	var getLCP = function (onReport, reportAllChanges) {
	  var visibilityWatcher = getVisibilityWatcher();
	  var metric = initMetric('LCP');
	  var report;

	  var entryHandler = function (entry) {
	    // The startTime attribute returns the value of the renderTime if it is not 0,
	    // and the value of the loadTime otherwise.
	    var value = entry.startTime; // If the page was hidden prior to paint time of the entry,
	    // ignore it and mark the metric as final, otherwise add the entry.

	    if (value < visibilityWatcher.firstHiddenTime) {
	      metric.value = value;
	      metric.entries.push(entry);
	    }

	    if (report) {
	      report();
	    }
	  };

	  var po = observe('largest-contentful-paint', entryHandler);

	  if (po) {
	    report = bindReporter(onReport, metric, reportAllChanges);

	    var stopListening_1 = function () {
	      if (!reportedMetricIDs[metric.id]) {
	        po.takeRecords().map(entryHandler);
	        po.disconnect();
	        reportedMetricIDs[metric.id] = true;
	        report(true);
	      }
	    }; // Stop listening after input. Note: while scrolling is an input that
	    // stop LCP observation, it's unreliable since it can be programmatically
	    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75


	    ['keydown', 'click'].forEach(function (type) {
	      addEventListener(type, stopListening_1, {
	        once: true,
	        capture: true
	      });
	    });
	    onHidden(stopListening_1, true);
	  }
	};

	var global$3 = getGlobalObject();
	/** Class tracking metrics  */

	var MetricsInstrumentation =
	/** @class */
	function () {
	  function MetricsInstrumentation(_reportAllChanges) {
	    if (_reportAllChanges === void 0) {
	      _reportAllChanges = false;
	    }

	    this._reportAllChanges = _reportAllChanges;
	    this._measurements = {};
	    this._performanceCursor = 0;

	    if (!isNodeEnv() && global$3 && global$3.performance && global$3.document) {
	      if (global$3.performance.mark) {
	        global$3.performance.mark('sentry-tracing-init');
	      }

	      this._trackCLS();

	      this._trackLCP();

	      this._trackFID();
	    }
	  }
	  /** Add performance related spans to a transaction */


	  MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {
	    var _this = this;

	    if (!global$3 || !global$3.performance || !global$3.performance.getEntries || !browserPerformanceTimeOrigin) {
	      // Gatekeeper if performance API not available
	      return;
	    }

	    IS_DEBUG_BUILD && logger.log('[Tracing] Adding & adjusting spans using Performance API');
	    var timeOrigin = msToSec(browserPerformanceTimeOrigin);
	    var responseStartTimestamp;
	    var requestStartTimestamp;
	    global$3.performance.getEntries().slice(this._performanceCursor).forEach(function (entry) {
	      var startTime = msToSec(entry.startTime);
	      var duration = msToSec(entry.duration);

	      if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
	        return;
	      }

	      switch (entry.entryType) {
	        case 'navigation':
	          {
	            addNavigationSpans(transaction, entry, timeOrigin);
	            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
	            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
	            break;
	          }

	        case 'mark':
	        case 'paint':
	        case 'measure':
	          {
	            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin); // capture web vitals

	            var firstHidden = getVisibilityWatcher(); // Only report if the page wasn't hidden prior to the web vital.

	            var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;

	            if (entry.name === 'first-paint' && shouldRecord) {
	              IS_DEBUG_BUILD && logger.log('[Measurements] Adding FP');
	              _this._measurements['fp'] = {
	                value: entry.startTime
	              };
	              _this._measurements['mark.fp'] = {
	                value: startTimestamp
	              };
	            }

	            if (entry.name === 'first-contentful-paint' && shouldRecord) {
	              IS_DEBUG_BUILD && logger.log('[Measurements] Adding FCP');
	              _this._measurements['fcp'] = {
	                value: entry.startTime
	              };
	              _this._measurements['mark.fcp'] = {
	                value: startTimestamp
	              };
	            }

	            break;
	          }

	        case 'resource':
	          {
	            var resourceName = entry.name.replace(global$3.location.origin, '');
	            addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
	            break;
	          }

	      }
	    });
	    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);

	    this._trackNavigator(transaction); // Measurements are only available for pageload transactions


	    if (transaction.op === 'pageload') {
	      // normalize applicable web vital values to be relative to transaction.startTimestamp
	      var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin); // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the
	      // start of the response in milliseconds

	      if (typeof responseStartTimestamp === 'number') {
	        IS_DEBUG_BUILD && logger.log('[Measurements] Adding TTFB');
	        this._measurements['ttfb'] = {
	          value: (responseStartTimestamp - transaction.startTimestamp) * 1000
	        };

	        if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {
	          // Capture the time spent making the request and receiving the first byte of the response.
	          // This is the time between the start of the request and the start of the response in milliseconds.
	          this._measurements['ttfb.requestTime'] = {
	            value: (responseStartTimestamp - requestStartTimestamp) * 1000
	          };
	        }
	      }

	      ['fcp', 'fp', 'lcp'].forEach(function (name) {
	        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
	          return;
	        } // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.
	        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need
	        // to be adjusted to be relative to transaction.startTimestamp.


	        var oldValue = _this._measurements[name].value;
	        var measurementTimestamp = timeOrigin_1 + msToSec(oldValue); // normalizedValue should be in milliseconds

	        var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);
	        var delta = normalizedValue - oldValue;
	        IS_DEBUG_BUILD && logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
	        _this._measurements[name].value = normalizedValue;
	      });

	      if (this._measurements['mark.fid'] && this._measurements['fid']) {
	        // create span for FID
	        _startChild(transaction, {
	          description: 'first input delay',
	          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),
	          op: 'web.vitals',
	          startTimestamp: this._measurements['mark.fid'].value
	        });
	      } // If FCP is not recorded we should not record the cls value
	      // according to the new definition of CLS.


	      if (!('fcp' in this._measurements)) {
	        delete this._measurements.cls;
	      }

	      transaction.setMeasurements(this._measurements);
	      tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
	      transaction.setTag('sentry_reportAllChanges', this._reportAllChanges);
	    }
	  };
	  /**
	   * Capture the information of the user agent.
	   */


	  MetricsInstrumentation.prototype._trackNavigator = function (transaction) {
	    var navigator = global$3.navigator;

	    if (!navigator) {
	      return;
	    } // track network connectivity


	    var connection = navigator.connection;

	    if (connection) {
	      if (connection.effectiveType) {
	        transaction.setTag('effectiveConnectionType', connection.effectiveType);
	      }

	      if (connection.type) {
	        transaction.setTag('connectionType', connection.type);
	      }

	      if (isMeasurementValue(connection.rtt)) {
	        this._measurements['connection.rtt'] = {
	          value: connection.rtt
	        };
	      }

	      if (isMeasurementValue(connection.downlink)) {
	        this._measurements['connection.downlink'] = {
	          value: connection.downlink
	        };
	      }
	    }

	    if (isMeasurementValue(navigator.deviceMemory)) {
	      transaction.setTag('deviceMemory', String(navigator.deviceMemory));
	    }

	    if (isMeasurementValue(navigator.hardwareConcurrency)) {
	      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));
	    }
	  };
	  /** Starts tracking the Cumulative Layout Shift on the current page. */


	  MetricsInstrumentation.prototype._trackCLS = function () {
	    var _this = this; // See:
	    // https://web.dev/evolving-cls/
	    // https://web.dev/cls-web-tooling/


	    getCLS(function (metric) {
	      var entry = metric.entries.pop();

	      if (!entry) {
	        return;
	      }

	      IS_DEBUG_BUILD && logger.log('[Measurements] Adding CLS');
	      _this._measurements['cls'] = {
	        value: metric.value
	      };
	      _this._clsEntry = entry;
	    });
	  };
	  /** Starts tracking the Largest Contentful Paint on the current page. */


	  MetricsInstrumentation.prototype._trackLCP = function () {
	    var _this = this;

	    getLCP(function (metric) {
	      var entry = metric.entries.pop();

	      if (!entry) {
	        return;
	      }

	      var timeOrigin = msToSec(browserPerformanceTimeOrigin);
	      var startTime = msToSec(entry.startTime);
	      IS_DEBUG_BUILD && logger.log('[Measurements] Adding LCP');
	      _this._measurements['lcp'] = {
	        value: metric.value
	      };
	      _this._measurements['mark.lcp'] = {
	        value: timeOrigin + startTime
	      };
	      _this._lcpEntry = entry;
	    }, this._reportAllChanges);
	  };
	  /** Starts tracking the First Input Delay on the current page. */


	  MetricsInstrumentation.prototype._trackFID = function () {
	    var _this = this;

	    getFID(function (metric) {
	      var entry = metric.entries.pop();

	      if (!entry) {
	        return;
	      }

	      var timeOrigin = msToSec(browserPerformanceTimeOrigin);
	      var startTime = msToSec(entry.startTime);
	      IS_DEBUG_BUILD && logger.log('[Measurements] Adding FID');
	      _this._measurements['fid'] = {
	        value: metric.value
	      };
	      _this._measurements['mark.fid'] = {
	        value: timeOrigin + startTime
	      };
	    });
	  };

	  return MetricsInstrumentation;
	}();
	/** Instrument navigation entries */

	function addNavigationSpans(transaction, entry, timeOrigin) {
	  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(function (event) {
	    addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
	  });
	  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');
	  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');
	  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');
	  addRequest(transaction, entry, timeOrigin);
	}
	/** Create measure related spans */


	function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
	  var measureStartTimestamp = timeOrigin + startTime;
	  var measureEndTimestamp = measureStartTimestamp + duration;

	  _startChild(transaction, {
	    description: entry.name,
	    endTimestamp: measureEndTimestamp,
	    op: entry.entryType,
	    startTimestamp: measureStartTimestamp
	  });

	  return measureStartTimestamp;
	}
	/** Create resource-related spans */


	function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
	  // we already instrument based on fetch and xhr, so we don't need to
	  // duplicate spans here.
	  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
	    return;
	  }

	  var data = {};

	  if ('transferSize' in entry) {
	    data['Transfer Size'] = entry.transferSize;
	  }

	  if ('encodedBodySize' in entry) {
	    data['Encoded Body Size'] = entry.encodedBodySize;
	  }

	  if ('decodedBodySize' in entry) {
	    data['Decoded Body Size'] = entry.decodedBodySize;
	  }

	  var startTimestamp = timeOrigin + startTime;
	  var endTimestamp = startTimestamp + duration;

	  _startChild(transaction, {
	    description: resourceName,
	    endTimestamp: endTimestamp,
	    op: entry.initiatorType ? "resource." + entry.initiatorType : 'resource',
	    startTimestamp: startTimestamp,
	    data: data
	  });
	}
	/** Create performance navigation related spans */

	function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
	  var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
	  var start = entry[event + "Start"];

	  if (!start || !end) {
	    return;
	  }

	  _startChild(transaction, {
	    op: 'browser',
	    description: description !== null && description !== void 0 ? description : event,
	    startTimestamp: timeOrigin + msToSec(start),
	    endTimestamp: timeOrigin + msToSec(end)
	  });
	}
	/** Create request and response related spans */


	function addRequest(transaction, entry, timeOrigin) {
	  _startChild(transaction, {
	    op: 'browser',
	    description: 'request',
	    startTimestamp: timeOrigin + msToSec(entry.requestStart),
	    endTimestamp: timeOrigin + msToSec(entry.responseEnd)
	  });

	  _startChild(transaction, {
	    op: 'browser',
	    description: 'response',
	    startTimestamp: timeOrigin + msToSec(entry.responseStart),
	    endTimestamp: timeOrigin + msToSec(entry.responseEnd)
	  });
	}
	/**
	 * Helper function to start child on transactions. This function will make sure that the transaction will
	 * use the start timestamp of the created child span if it is earlier than the transactions actual
	 * start timestamp.
	 */


	function _startChild(transaction, _a) {
	  var startTimestamp = _a.startTimestamp,
	      ctx = __rest(_a, ["startTimestamp"]);

	  if (startTimestamp && transaction.startTimestamp > startTimestamp) {
	    transaction.startTimestamp = startTimestamp;
	  }

	  return transaction.startChild(__assign({
	    startTimestamp: startTimestamp
	  }, ctx));
	}
	/**
	 * Checks if a given value is a valid measurement value.
	 */

	function isMeasurementValue(value) {
	  return typeof value === 'number' && isFinite(value);
	}
	/** Add LCP / CLS data to transaction to allow debugging */


	function tagMetricInfo(transaction, lcpEntry, clsEntry) {
	  if (lcpEntry) {
	    IS_DEBUG_BUILD && logger.log('[Measurements] Adding LCP Data'); // Capture Properties of the LCP element that contributes to the LCP.

	    if (lcpEntry.element) {
	      transaction.setTag('lcp.element', htmlTreeAsString(lcpEntry.element));
	    }

	    if (lcpEntry.id) {
	      transaction.setTag('lcp.id', lcpEntry.id);
	    }

	    if (lcpEntry.url) {
	      // Trim URL to the first 200 characters.
	      transaction.setTag('lcp.url', lcpEntry.url.trim().slice(0, 200));
	    }

	    transaction.setTag('lcp.size', lcpEntry.size);
	  } // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift


	  if (clsEntry && clsEntry.sources) {
	    IS_DEBUG_BUILD && logger.log('[Measurements] Adding CLS Data');
	    clsEntry.sources.forEach(function (source, index) {
	      return transaction.setTag("cls.source." + (index + 1), htmlTreeAsString(source.node));
	    });
	  }
	}

	var DEFAULT_TRACING_ORIGINS = ['localhost', /^\//];
	var defaultRequestInstrumentationOptions = {
	  traceFetch: true,
	  traceXHR: true,
	  tracingOrigins: DEFAULT_TRACING_ORIGINS
	};
	/** Registers span creators for xhr and fetch requests  */

	function instrumentOutgoingRequests(_options) {
	  // eslint-disable-next-line @typescript-eslint/unbound-method
	  var _a = __assign(__assign({}, defaultRequestInstrumentationOptions), _options),
	      traceFetch = _a.traceFetch,
	      traceXHR = _a.traceXHR,
	      tracingOrigins = _a.tracingOrigins,
	      shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest; // We should cache url -> decision so that we don't have to compute
	  // regexp everytime we create a request.


	  var urlMap = {};

	  var defaultShouldCreateSpan = function (url) {
	    if (urlMap[url]) {
	      return urlMap[url];
	    }

	    var origins = tracingOrigins;
	    urlMap[url] = origins.some(function (origin) {
	      return isMatchingPattern(url, origin);
	    }) && !isMatchingPattern(url, 'sentry_key');
	    return urlMap[url];
	  }; // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves
	  // That's why we filter out already unwanted Spans from tracingOrigins


	  var shouldCreateSpan = defaultShouldCreateSpan;

	  if (typeof shouldCreateSpanForRequest === 'function') {
	    shouldCreateSpan = function (url) {
	      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
	    };
	  }

	  var spans = {};

	  if (traceFetch) {
	    addInstrumentationHandler('fetch', function (handlerData) {
	      fetchCallback(handlerData, shouldCreateSpan, spans);
	    });
	  }

	  if (traceXHR) {
	    addInstrumentationHandler('xhr', function (handlerData) {
	      xhrCallback(handlerData, shouldCreateSpan, spans);
	    });
	  }
	}
	/**
	 * Create and track fetch request spans
	 */

	function fetchCallback(handlerData, shouldCreateSpan, spans) {
	  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
	    return;
	  }

	  if (handlerData.endTimestamp) {
	    var spanId = handlerData.fetchData.__span;
	    if (!spanId) return;
	    var span = spans[spanId];

	    if (span) {
	      if (handlerData.response) {
	        // TODO (kmclb) remove this once types PR goes through
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        span.setHttpStatus(handlerData.response.status);
	      } else if (handlerData.error) {
	        span.setStatus('internal_error');
	      }

	      span.finish(); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete

	      delete spans[spanId];
	    }

	    return;
	  }

	  var activeTransaction = getActiveTransaction();

	  if (activeTransaction) {
	    var span = activeTransaction.startChild({
	      data: __assign(__assign({}, handlerData.fetchData), {
	        type: 'fetch'
	      }),
	      description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
	      op: 'http.client'
	    });
	    handlerData.fetchData.__span = span.spanId;
	    spans[span.spanId] = span;
	    var request = handlerData.args[0] = handlerData.args[0]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    var options = handlerData.args[1] = handlerData.args[1] || {};
	    var headers = options.headers;

	    if (isInstanceOf(request, Request)) {
	      headers = request.headers;
	    }

	    if (headers) {
	      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	      if (typeof headers.append === 'function') {
	        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	        headers.append('sentry-trace', span.toTraceparent());
	      } else if (Array.isArray(headers)) {
	        headers = __spread(headers, [['sentry-trace', span.toTraceparent()]]);
	      } else {
	        headers = __assign(__assign({}, headers), {
	          'sentry-trace': span.toTraceparent()
	        });
	      }
	    } else {
	      headers = {
	        'sentry-trace': span.toTraceparent()
	      };
	    }

	    options.headers = headers;
	  }
	}
	/**
	 * Create and track xhr request spans
	 */

	function xhrCallback(handlerData, shouldCreateSpan, spans) {
	  if (!hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
	    return;
	  }

	  var xhr = handlerData.xhr.__sentry_xhr__; // check first if the request has finished and is tracked by an existing span which should now end

	  if (handlerData.endTimestamp) {
	    var spanId = handlerData.xhr.__sentry_xhr_span_id__;
	    if (!spanId) return;
	    var span = spans[spanId];

	    if (span) {
	      span.setHttpStatus(xhr.status_code);
	      span.finish(); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete

	      delete spans[spanId];
	    }

	    return;
	  } // if not, create a new span to track it


	  var activeTransaction = getActiveTransaction();

	  if (activeTransaction) {
	    var span = activeTransaction.startChild({
	      data: __assign(__assign({}, xhr.data), {
	        type: 'xhr',
	        method: xhr.method,
	        url: xhr.url
	      }),
	      description: xhr.method + " " + xhr.url,
	      op: 'http.client'
	    });
	    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
	    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;

	    if (handlerData.xhr.setRequestHeader) {
	      try {
	        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());
	      } catch (_) {// Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.
	      }
	    }
	  }
	}

	var global$2 = getGlobalObject();
	/**
	 * Default function implementing pageload and navigation transactions
	 */

	function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
	  if (startTransactionOnPageLoad === void 0) {
	    startTransactionOnPageLoad = true;
	  }

	  if (startTransactionOnLocationChange === void 0) {
	    startTransactionOnLocationChange = true;
	  }

	  if (!global$2 || !global$2.location) {
	    IS_DEBUG_BUILD && logger.warn('Could not initialize routing instrumentation due to invalid location');
	    return;
	  }

	  var startingUrl = global$2.location.href;
	  var activeTransaction;

	  if (startTransactionOnPageLoad) {
	    activeTransaction = customStartTransaction({
	      name: global$2.location.pathname,
	      op: 'pageload'
	    });
	  }

	  if (startTransactionOnLocationChange) {
	    addInstrumentationHandler('history', function (_a) {
	      var to = _a.to,
	          from = _a.from;
	      /**
	       * This early return is there to account for some cases where a navigation transaction starts right after
	       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't
	       * create an uneccessary navigation transaction.
	       *
	       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also
	       * only be caused in certain development environments where the usage of a hot module reloader is causing
	       * errors.
	       */

	      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
	        startingUrl = undefined;
	        return;
	      }

	      if (from !== to) {
	        startingUrl = undefined;

	        if (activeTransaction) {
	          IS_DEBUG_BUILD && logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op); // If there's an open transaction on the scope, we need to finish it before creating an new one.

	          activeTransaction.finish();
	        }

	        activeTransaction = customStartTransaction({
	          name: global$2.location.pathname,
	          op: 'navigation'
	        });
	      }
	    });
	  }
	}

	var DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;

	var DEFAULT_BROWSER_TRACING_OPTIONS = __assign({
	  idleTimeout: DEFAULT_IDLE_TIMEOUT,
	  markBackgroundTransactions: true,
	  maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS,
	  routingInstrumentation: instrumentRoutingWithDefaults,
	  startTransactionOnLocationChange: true,
	  startTransactionOnPageLoad: true
	}, defaultRequestInstrumentationOptions);
	/**
	 * The Browser Tracing integration automatically instruments browser pageload/navigation
	 * actions as transactions, and captures requests, metrics and errors as spans.
	 *
	 * The integration can be configured with a variety of options, and can be extended to use
	 * any routing library. This integration uses {@see IdleTransaction} to create transactions.
	 */


	var BrowserTracing =
	/** @class */
	function () {
	  function BrowserTracing(_options) {
	    /**
	     * @inheritDoc
	     */
	    this.name = BrowserTracing.id;
	    /** Store configured idle timeout so that it can be added as a tag to transactions */

	    this._configuredIdleTimeout = undefined;
	    var tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins; // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances

	    if (_options) {
	      this._configuredIdleTimeout = _options.idleTimeout;

	      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
	        tracingOrigins = _options.tracingOrigins;
	      } else {
	        IS_DEBUG_BUILD && (this._emitOptionsWarning = true);
	      }
	    }

	    this.options = __assign(__assign(__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), {
	      tracingOrigins: tracingOrigins
	    });
	    var _metricOptions = this.options._metricOptions;
	    this._metrics = new MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
	  }
	  /**
	   * @inheritDoc
	   */


	  BrowserTracing.prototype.setupOnce = function (_, getCurrentHub) {
	    var _this = this;

	    this._getCurrentHub = getCurrentHub;

	    if (this._emitOptionsWarning) {
	      IS_DEBUG_BUILD && logger.warn('[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.');
	      IS_DEBUG_BUILD && logger.warn("[Tracing] We added a reasonable default for you: " + defaultRequestInstrumentationOptions.tracingOrigins);
	    } // eslint-disable-next-line @typescript-eslint/unbound-method


	    var _a = this.options,
	        instrumentRouting = _a.routingInstrumentation,
	        startTransactionOnLocationChange = _a.startTransactionOnLocationChange,
	        startTransactionOnPageLoad = _a.startTransactionOnPageLoad,
	        markBackgroundTransactions = _a.markBackgroundTransactions,
	        traceFetch = _a.traceFetch,
	        traceXHR = _a.traceXHR,
	        tracingOrigins = _a.tracingOrigins,
	        shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
	    instrumentRouting(function (context) {
	      return _this._createRouteTransaction(context);
	    }, startTransactionOnPageLoad, startTransactionOnLocationChange);

	    if (markBackgroundTransactions) {
	      registerBackgroundTabDetection();
	    }

	    instrumentOutgoingRequests({
	      traceFetch: traceFetch,
	      traceXHR: traceXHR,
	      tracingOrigins: tracingOrigins,
	      shouldCreateSpanForRequest: shouldCreateSpanForRequest
	    });
	  };
	  /** Create routing idle transaction. */


	  BrowserTracing.prototype._createRouteTransaction = function (context) {
	    var _this = this;

	    if (!this._getCurrentHub) {
	      IS_DEBUG_BUILD && logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
	      return undefined;
	    } // eslint-disable-next-line @typescript-eslint/unbound-method


	    var _a = this.options,
	        beforeNavigate = _a.beforeNavigate,
	        idleTimeout = _a.idleTimeout,
	        maxTransactionDuration = _a.maxTransactionDuration;
	    var parentContextFromHeader = context.op === 'pageload' ? getHeaderContext() : undefined;

	    var expandedContext = __assign(__assign(__assign({}, context), parentContextFromHeader), {
	      trimEnd: true
	    });

	    var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext; // For backwards compatibility reasons, beforeNavigate can return undefined to "drop" the transaction (prevent it
	    // from being sent to Sentry).

	    var finalContext = modifiedContext === undefined ? __assign(__assign({}, expandedContext), {
	      sampled: false
	    }) : modifiedContext;

	    if (finalContext.sampled === false) {
	      IS_DEBUG_BUILD && logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
	    }

	    IS_DEBUG_BUILD && logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");

	    var hub = this._getCurrentHub();

	    var location = getGlobalObject().location;
	    var idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, true, {
	      location: location
	    });
	    idleTransaction.registerBeforeFinishCallback(function (transaction, endTimestamp) {
	      _this._metrics.addPerformanceEntries(transaction);

	      adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);
	    });
	    idleTransaction.setTag('idleTimeout', this._configuredIdleTimeout);
	    return idleTransaction;
	  };
	  /**
	   * @inheritDoc
	   */


	  BrowserTracing.id = 'BrowserTracing';
	  return BrowserTracing;
	}();
	/**
	 * Gets transaction context from a sentry-trace meta.
	 *
	 * @returns Transaction context data from the header or undefined if there's no header or the header is malformed
	 */

	function getHeaderContext() {
	  var header = getMetaContent('sentry-trace');

	  if (header) {
	    return extractTraceparentData(header);
	  }

	  return undefined;
	}
	/** Returns the value of a meta tag */

	function getMetaContent(metaName) {
	  var el = getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
	  return el ? el.getAttribute('content') : null;
	}
	/** Adjusts transaction value based on max transaction duration */

	function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
	  var diff = endTimestamp - transaction.startTimestamp;
	  var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);

	  if (isOutdatedTransaction) {
	    transaction.setStatus('deadline_exceeded');
	    transaction.setTag('maxTransactionDurationExceeded', 'true');
	  }
	}

	var global$1 = getGlobalObject();
	/** Send Console API calls as Sentry Events */

	var CaptureConsole =
	/** @class */
	function () {
	  /**
	   * @inheritDoc
	   */
	  function CaptureConsole(options) {
	    if (options === void 0) {
	      options = {};
	    }
	    /**
	     * @inheritDoc
	     */


	    this.name = CaptureConsole.id;
	    /**
	     * @inheritDoc
	     */

	    this._levels = CONSOLE_LEVELS;

	    if (options.levels) {
	      this._levels = options.levels;
	    }
	  }
	  /**
	   * @inheritDoc
	   */


	  CaptureConsole.prototype.setupOnce = function (_, getCurrentHub) {
	    if (!('console' in global$1)) {
	      return;
	    }

	    this._levels.forEach(function (level) {
	      if (!(level in global$1.console)) {
	        return;
	      } // eslint-disable-next-line @typescript-eslint/no-explicit-any


	      fill(global$1.console, level, function (originalConsoleMethod) {
	        return function () {
	          var args = [];

	          for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	          }

	          var hub = getCurrentHub();

	          if (hub.getIntegration(CaptureConsole)) {
	            hub.withScope(function (scope) {
	              scope.setLevel(severityFromString(level));
	              scope.setExtra('arguments', args);
	              scope.addEventProcessor(function (event) {
	                event.logger = 'console';
	                return event;
	              });
	              var message = safeJoin(args, ' ');

	              if (level === 'assert') {
	                if (args[0] === false) {
	                  message = "Assertion failed: " + (safeJoin(args.slice(1), ' ') || 'console.assert');
	                  scope.setExtra('arguments', args.slice(1));
	                  hub.captureMessage(message);
	                }
	              } else if (level === 'error' && args[0] instanceof Error) {
	                hub.captureException(args[0]);
	              } else {
	                hub.captureMessage(message);
	              }
	            });
	          } // this fails for some browsers. :(


	          if (originalConsoleMethod) {
	            originalConsoleMethod.apply(global$1.console, args);
	          }
	        };
	      });
	    });
	  };
	  /**
	   * @inheritDoc
	   */


	  CaptureConsole.id = 'CaptureConsole';
	  return CaptureConsole;
	}();

	/* eslint-disable no-console */
	const SENTRY_CONSENT_KEY = 'SENTRY_CONSENT';
	let SentryConsentState;

	(function (SentryConsentState) {
	  SentryConsentState["Unknown"] = "Unknown";
	  SentryConsentState["Given"] = "Given";
	  SentryConsentState["Refused"] = "Refused";
	})(SentryConsentState || (SentryConsentState = {}));

	/**
	 * FBW sentry.io client for aircraft use
	 */
	class FbwAircraftSentryClient {
	  /**
	   * Method called when a panel is initialized. If root client, runs the normal flow (ask for consent if state is unknown). Otherwise,
	   * wait for `DataStore` property changes.
	   *
	   * @param config a {@link FbwAircraftSentryClientConfiguration} object
	   *
	   * @returns a `Promise<boolean>` that indicates the result of the initial configuration
	   */
	  onInstrumentLoaded(config) {
	    if (!config.dsn) {
	      console.log('[SentryClient] No DSN defined. Will not try to initialize');
	      return Promise.resolve(false);
	    }

	    this.runClientSubscription(config);

	    if (config.root) {
	      console.log('[SentryClient] Starting as root client');
	      return this.runRootClientFlow(config);
	    }

	    return Promise.resolve(false);
	  }
	  /**
	   * Runs the client subscription (subscribes to the NXDataStore property and controls the client accordingly)
	   *
	   * @param config a {@link FbwAircraftSentryClientConfiguration} object
	   */


	  async runClientSubscription(config) {
	    NXDataStore.getAndSubscribe(SENTRY_CONSENT_KEY, (key, value) => {
	      if (value === SentryConsentState.Given) {
	        console.log('[SentryClient] Synchronised consent state is Given. Initializing sentry');
	        FbwAircraftSentryClient.attemptInitializeSentry(config);
	      }

	      if (value === SentryConsentState.Refused) {
	        console.log('[SentryClient] Synchronised consent state is Refused. Shutting down the client');
	        FbwAircraftSentryClient.closeSentry();
	      }
	    });
	  }
	  /**
	   * Runs the root client flow, checking if consent state is known, asking for it otherwise, then initializing appropriately
	   *
	   * @param config a {@link FbwAircraftSentryClientConfiguration} object
	   *
	   * @returns a `Promise<boolean>` that indicates the result of the root client flow
	   */


	  async runRootClientFlow(config) {
	    const consentValue = NXDataStore.get(SENTRY_CONSENT_KEY, SentryConsentState.Unknown);

	    switch (consentValue) {
	      case SentryConsentState.Given:
	        console.log('[SentryClient] Consent state is Given. Initializing sentry');
	        return FbwAircraftSentryClient.attemptInitializeSentry(config);

	      case SentryConsentState.Unknown:
	        console.log('[SentryClient] Consent state is Unknown. Asking for consent'); // It seems that for some people, spawning the popup / writing to NXDataStore can cause a CTD if the flight is not fully loaded.
	        // So instead, we wait for a bit after the FlightStart event to show it and gather consent.

	        return new Promise((resolve, reject) => {
	          const instrument = document.querySelector('vcockpit-panel > *');

	          if (instrument) {
	            instrument.addEventListener('FlightStart', () => {
	              // ...and give ourselves some breathing room
	              setTimeout(() => {
	                resolve(FbwAircraftSentryClient.requestConsent().then(didConsent => {
	                  if (didConsent) {
	                    NXDataStore.set(SENTRY_CONSENT_KEY, SentryConsentState.Given);
	                    console.log('[SentryClient] User requested consent state Given. Initializing sentry');
	                    return FbwAircraftSentryClient.attemptInitializeSentry(config);
	                  }

	                  NXDataStore.set(SENTRY_CONSENT_KEY, SentryConsentState.Refused);
	                  console.log('[SentryClient] User requested consent state Refused. Doing nothing');
	                  return false;
	                }).catch(() => false));
	              }, 1000);
	            });
	          } else {
	            reject(new Error('[SentryClient] Could not find an instrument element to hook onto'));
	          }
	        });

	      case SentryConsentState.Refused:
	        console.log('[SentryClient] Consent state is Refused. Doing nothing');
	        break;

	      default:
	        console.log('[SentryClient] Consent state is corrupted. Doing nothing');
	        break;
	    }

	    return false;
	  }
	  /**
	   * Displays an MSFS popup request consent for error reporting
	   *
	   * @returns a `Promise<boolean` indicating the consent state
	   */


	  static async requestConsent() {
	    const popup = new PopUp();
	    return new Promise(resolve => {
	      popup.showPopUp('A32NX - ERROR REPORTING', 'Are you willing to help FlyByWire Simulations by enabling anonymous reporting of errors that may occur in the future? ' + 'This is 100% optional and we will never collect your personal data, but it will help us diagnose issues quickly.', 'normal', () => resolve(true), () => resolve(false));
	    });
	  }
	  /**
	   * Attempts to initialise the Sentry client, assuming consent is given
	   *
	   * @param config a {@link FbwAircraftSentryClientConfiguration} object
	   *
	   * @returns a `Promise<boolean>` indicating whether the client was successfully initialised
	   */


	  static async attemptInitializeSentry(config) {
	    return FbwAircraftSentryClient.initializeSentry(config).then(() => true).catch(e => {
	      console.error('[SentryClient] Error while initializing sentry');
	      console.error(e);
	      return false;
	    });
	  }
	  /**
	   * Closes the Sentry client
	   */


	  static closeSentry() {
	    close();
	    console.log('[SentryClient] Sentry closed');
	  }
	  /**
	   * Initialises the Sentry client, assuming consent is given
	   *
	   * @param config a {@link FbwAircraftSentryClientConfiguration} object
	   */


	  static async initializeSentry(config) {
	    let release = 'unknown';

	    try {
	      const manifest = await (await fetch("/VFS/".concat(config.buildInfoFilePrefix, "_build_info.json"))).json();
	      release = manifest.pretty_release_name;
	    } catch (e) {
	      console.warn("[SentryClient] Could not load ".concat(config.buildInfoFilePrefix, "_build_info.json. Using 'unknown' as release name"));
	    }

	    const integrations = [new CaptureConsole({
	      levels: ['error']
	    })];

	    if (config.enableTracing) {
	      integrations.push(new BrowserTracing());
	    }

	    init({
	      dsn: config.dsn,
	      release,
	      integrations,
	      sampleRate: 0.1
	    });
	    console.log('[SentryClient] Sentry initialized');
	    NXDataStore.getAndSubscribe('A32NX_SENTRY_SESSION_ID', (_, value) => {
	      if (value) {
	        setTag('session_id', value);
	        console.log('[SentryClient] Sentry tag "session_id" set to', value);
	      }
	    });
	  }

	}

	/**
	 * Use the given React element to render the instrument using React.
	 */
	const render = function (Slot) {
	  let enableSentryTracing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  let sentryRootClient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  const doRender = () => {
	    new FbwAircraftSentryClient().onInstrumentLoaded({
	      dsn: "https://abd67c4440a644b3aaaf44838e565bea@o1135700.ingest.sentry.io/6185355",
	      buildInfoFilePrefix: 'a32nx',
	      enableTracing: enableSentryTracing,
	      root: sentryRootClient
	    });
	    reactDom.render(Slot, getRenderTarget());
	  };

	  {
	    doRender();
	  }
	};
	/**
	 * Computes time delta out of absolute env time and previous
	 * time debounced on time shift.
	 */

	const debouncedTimeDelta = (absTimeSeconds, prevTimeSeconds) => {
	  const diff = Math.max(absTimeSeconds - prevTimeSeconds, 0); // 60s detects forward time-shift

	  return diff < 60 ? diff : 0;
	};

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

	/**
	 * Receives and draws EFIS vectors for a certain vector group (flight plan)
	 */
	const FlightPlanVectors = /*#__PURE__*/react.memo(_ref => {
	  let {
	    x,
	    y,
	    mapParams,
	    side,
	    group
	  } = _ref;
	  const [vectors, setVectors] = react.useState([]);
	  const lineStyle = vectorsGroupLineStyle(group);
	  useFlowSyncEvent("A32NX_EFIS_VECTORS_".concat(side, "_").concat(EfisVectorsGroup[group]), react.useCallback((_topic, data) => {
	    if (data) {
	      setVectors(data);
	    }
	  }, [group]));
	  return /*#__PURE__*/jsxRuntime.jsx(Layer, {
	    x: x,
	    y: y,
	    children: vectors.filter(vector => isVectorValid(vector)).map((vector, index) => {
	      var _vector$colour;

	      switch (vector.type) {
	        case PathVectorType.Line:
	          const [sx, sy] = mapParams.coordinatesToXYy(vector.startPoint);
	          const [ex, ey] = mapParams.coordinatesToXYy(vector.endPoint);
	          return /*#__PURE__*/jsxRuntime.jsx("line", _objectSpread(_objectSpread({}, lineStyle), {}, {
	            fill: "none",
	            strokeWidth: 2,
	            x1: sx,
	            y1: sy,
	            x2: ex,
	            y2: ey
	          }));

	        case PathVectorType.Arc:
	          const [ix, iy] = mapParams.coordinatesToXYy(vector.startPoint);
	          const [fx, fy] = mapParams.coordinatesToXYy(vector.endPoint); // TODO msfs-geo when it has planar calcs

	          const radius = Avionics.Utils.computeDistance(vector.centrePoint, vector.endPoint) * mapParams.nmToPx;
	          return /*#__PURE__*/jsxRuntime.jsx("path", _objectSpread(_objectSpread({}, lineStyle), {}, {
	            fill: "none",
	            strokeWidth: 2,
	            d: "M ".concat(ix, " ").concat(iy, " A ").concat(radius, " ").concat(radius, " 0 ").concat(Math.abs(vector.sweepAngle) > 180 ? 1 : 0, " ").concat(vector.sweepAngle > 0 ? 1 : 0, " ").concat(fx, " ").concat(fy)
	          }));

	        case PathVectorType.DebugPoint:
	          const [x, y] = mapParams.coordinatesToXYy(vector.startPoint);
	          const offset = index % 2 === 0;
	          const colour = DebugPointColour[(_vector$colour = vector.colour) !== null && _vector$colour !== void 0 ? _vector$colour : DebugPointColour.Cyan];
	          return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	            children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	              stroke: colour,
	              fill: "none",
	              strokeWidth: 1.5,
	              d: "M ".concat(x, " ").concat(y, " h -7 h 14 m -7 -7 v 14")
	            }), /*#__PURE__*/jsxRuntime.jsx("text", {
	              x: x + (offset ? -15 : 15),
	              y: y + 5,
	              fontSize: 13,
	              textAnchor: offset ? 'end' : 'start',
	              fill: colour,
	              children: vector.annotation
	            })]
	          });

	        default:
	          return null;
	      }
	    })
	  });
	});

	function isVectorValid(vector) {
	  if (!vector) {
	    return false;
	  }

	  if (vector.type === null || vector.type === undefined) {
	    return false;
	  }

	  switch (vector.type) {
	    case PathVectorType.Line:
	      return !!vector.startPoint;

	    case PathVectorType.Arc:
	      return !!vector.startPoint && !!vector.centrePoint && !!vector.endPoint;

	    case PathVectorType.DebugPoint:
	      return !!vector.startPoint;

	    default:
	      return false;
	  }
	}

	function vectorsGroupLineStyle(group) {
	  switch (group) {
	    case EfisVectorsGroup.ACTIVE:
	      return {
	        stroke: '#0f0'
	      };

	    case EfisVectorsGroup.DASHED:
	    case EfisVectorsGroup.OFFSET:
	      return {
	        stroke: '#0f0',
	        strokeDasharray: '15 12'
	      };

	    case EfisVectorsGroup.TEMPORARY:
	      return {
	        stroke: '#ff0',
	        strokeDasharray: '15 12'
	      };

	    case EfisVectorsGroup.SECONDARY:
	      return {
	        stroke: '#888'
	      };

	    case EfisVectorsGroup.SECONDARY_DASHED:
	      return {
	        stroke: '#888',
	        strokeDasharray: '15 12'
	      };

	    case EfisVectorsGroup.MISSED:
	      return {
	        stroke: '#0ff'
	      };

	    case EfisVectorsGroup.ALTERNATE:
	      return {
	        stroke: '#0ff',
	        strokeDasharray: '15 12'
	      };

	    case EfisVectorsGroup.ACTIVE_EOSID:
	      return {
	        stroke: '#ff0'
	      };

	    default:
	      return {
	        stroke: '#f00'
	      };
	  }
	}

	//  Copyright (c) 2021 FlyByWire Simulations
	let FlightPlanType;

	(function (FlightPlanType) {
	  FlightPlanType[FlightPlanType["Nav"] = 0] = "Nav";
	  FlightPlanType[FlightPlanType["Dashed"] = 1] = "Dashed";
	  FlightPlanType[FlightPlanType["Temp"] = 2] = "Temp";
	})(FlightPlanType || (FlightPlanType = {}));

	const FlightPlan = /*#__PURE__*/react.memo(_ref => {
	  let {
	    x = 0,
	    y = 0,
	    side,
	    range,
	    symbols,
	    mapParams
	  } = _ref;

	  if (!mapParams.valid) {
	    return null;
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: x,
	    y: y,
	    children: [symbols.filter(symbol => (symbol.type & NdSymbolTypeFlags.Constraint) > 0).map(symbol => {
	      const position = mapParams.coordinatesToXYy(symbol.location);
	      return /*#__PURE__*/jsxRuntime.jsx(ConstraintMarker, {
	        x: Number(MathUtils.fastToFixed(position[0], 1)),
	        y: Number(MathUtils.fastToFixed(position[1], 1)),
	        type: symbol.type
	      }, symbol.databaseId);
	    }), Object.keys(EfisVectorsGroup).filter(it => !Number.isNaN(parseInt(it))).map(group => /*#__PURE__*/jsxRuntime.jsx(FlightPlanVectors, {
	      x: 0,
	      y: 0,
	      mapParams: mapParams,
	      mapParamsVersion: mapParams.version,
	      side: side,
	      group: parseInt(group)
	    }, EfisVectorsGroup[group])), symbols.map(symbol => {
	      if (!symbol.location) {
	        return false;
	      }

	      const position = mapParams.coordinatesToXYy(symbol.location);
	      let endPosition;

	      if (symbol.type & NdSymbolTypeFlags.FlightPlanVectorLine) {
	        endPosition = mapParams.coordinatesToXYy(symbol.lineEnd);
	      } else if (symbol.type & NdSymbolTypeFlags.FlightPlanVectorArc) {
	        endPosition = mapParams.coordinatesToXYy(symbol.arcEnd);
	      }

	      const radius = symbol.arcRadius ? mapParams.nmToPx * symbol.arcRadius : undefined;
	      const deltaX = endPosition ? endPosition[0] - position[0] : undefined;
	      const deltaY = endPosition ? endPosition[1] - position[1] : undefined;
	      return /*#__PURE__*/jsxRuntime.jsx(SymbolMarker, {
	        ident: symbol.ident,
	        x: Number(MathUtils.fastToFixed(position[0], 1)),
	        y: Number(MathUtils.fastToFixed(position[1], 1)),
	        endX: deltaX !== undefined ? Number(MathUtils.fastToFixed(deltaX, 1)) : undefined,
	        endY: deltaY !== undefined ? Number(MathUtils.fastToFixed(deltaY, 1)) : undefined,
	        type: symbol.type,
	        length: symbol.length,
	        direction: symbol.direction,
	        constraints: symbol.constraints,
	        radials: symbol.radials,
	        radii: symbol.radii,
	        arcSweep: symbol.arcSweepAngle,
	        arcRadius: radius,
	        mapParams: mapParams,
	        ndRange: range
	      }, symbol.databaseId);
	    })]
	  });
	});

	const VorMarker = _ref2 => {
	  let {
	    colour
	  } = _ref2;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: 15,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: 15,
	      y1: 0,
	      y2: 0,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: 15,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: 15,
	      y1: 0,
	      y2: 0,
	      className: colour,
	      strokeWidth: 2
	    })]
	  });
	};

	const VorDmeMarker = _ref3 => {
	  let {
	    colour
	  } = _ref3;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	      r: 7,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: -7,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: 15,
	      y2: 7,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: -7,
	      y1: 0,
	      y2: 0,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 15,
	      x2: 7,
	      y1: 0,
	      y2: 0,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	      r: 7,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: -7,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: 15,
	      y2: 7,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: -7,
	      y1: 0,
	      y2: 0,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 15,
	      x2: 7,
	      y1: 0,
	      y2: 0,
	      className: colour,
	      strokeWidth: 2
	    })]
	  });
	};

	const DmeMarker = _ref4 => {
	  let {
	    colour
	  } = _ref4;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	      r: 7,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	      r: 7,
	      className: colour,
	      strokeWidth: 2
	    })]
	  });
	};

	const NdbMarker = _ref5 => {
	  let {
	    colour
	  } = _ref5;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M-10,10 L0,-10 L10,10 L-10,10",
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M-10,10 L0,-10 L10,10 L-10,10",
	      className: colour,
	      strokeWidth: 2
	    })]
	  });
	};

	const WaypointMarker = _ref6 => {
	  let {
	    colour
	  } = _ref6;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: -4.5,
	      y: -4.5,
	      width: 9,
	      height: 9,
	      className: "shadow",
	      strokeWidth: 2.5,
	      transform: "rotate(45 0 0)"
	    }), /*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: -4.5,
	      y: -4.5,
	      width: 9,
	      height: 9,
	      className: colour,
	      strokeWidth: 2,
	      transform: "rotate(45 0 0)"
	    })]
	  });
	};

	const AirportMarker = _ref7 => {
	  let {
	    colour
	  } = _ref7;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: 15,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: 15,
	      className: "shadow",
	      strokeWidth: 2.5,
	      transform: "rotate(45)"
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: 15,
	      y1: 0,
	      y2: 0,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: 15,
	      y1: 0,
	      y2: 0,
	      className: "shadow",
	      strokeWidth: 2.5,
	      transform: "rotate(45)"
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: 15,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 0,
	      x2: 0,
	      y1: -15,
	      y2: 15,
	      className: colour,
	      strokeWidth: 2,
	      transform: "rotate(45)"
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: 15,
	      y1: 0,
	      y2: 0,
	      className: colour,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -15,
	      x2: 15,
	      y1: 0,
	      y2: 0,
	      className: colour,
	      strokeWidth: 2,
	      transform: "rotate(45)"
	    })]
	  });
	};

	const RunwayIdent = _ref8 => {
	  let {
	    ident,
	    rotation
	  } = _ref8;
	  const airportIdent = ident.substring(0, 4);
	  const runwayIdent = ident.substring(4);
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(-rotation, " 40 -20)"),
	    children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 40,
	      y: -30,
	      fontSize: 20,
	      className: "shadow",
	      textAnchor: "middle",
	      alignmentBaseline: "central",
	      children: airportIdent
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 40,
	      y: -10,
	      fontSize: 20,
	      className: "shadow",
	      textAnchor: "middle",
	      alignmentBaseline: "central",
	      children: runwayIdent.padEnd(4, '\xa0')
	    })]
	  });
	};

	const RunwayMarkerClose = /*#__PURE__*/react.memo(_ref9 => {
	  let {
	    ident,
	    mapParams,
	    direction,
	    lengthPx
	  } = _ref9;
	  useSimVar('PLANE HEADING DEGREES TRUE', 'number');
	  const rotation = mapParams.rotation(direction);
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(rotation, ")"),
	    className: "White",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -5,
	      x2: -5,
	      y1: 0,
	      y2: -lengthPx,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 5,
	      x2: 5,
	      y1: 0,
	      y2: -lengthPx,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: -5,
	      x2: -5,
	      y1: 0,
	      y2: -lengthPx,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 5,
	      x2: 5,
	      y1: 0,
	      y2: -lengthPx,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx(RunwayIdent, {
	      ident: ident,
	      rotation: rotation
	    })]
	  });
	});
	const RunwayMarkerFar = /*#__PURE__*/react.memo(_ref10 => {
	  let {
	    ident,
	    mapParams,
	    direction
	  } = _ref10;
	  useSimVar('PLANE HEADING DEGREES TRUE', 'number');
	  const rotation = mapParams.rotation(direction);
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(rotation, ")"),
	    className: "White",
	    children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: -5,
	      y: -12.5,
	      width: 10,
	      height: 25,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: -5,
	      y: -12.5,
	      width: 10,
	      height: 25,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx(RunwayIdent, {
	      ident: ident,
	      rotation: rotation
	    })]
	  });
	});
	const CourseReversalMarker = /*#__PURE__*/react.memo(_ref11 => {
	  let {
	    mapParams,
	    left,
	    direction
	  } = _ref11;
	  useSimVar('PLANE HEADING DEGREES TRUE', 'number');
	  const rotation = mapParams.rotation(direction);
	  const arcEnd = left ? -42 : 42;
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(rotation, ")"),
	    className: "White",
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M0,0 a21,21 0 0 ".concat(left ? 0 : 1, " ").concat(arcEnd, ",0"),
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: arcEnd,
	      x2: arcEnd - 4,
	      y1: 0,
	      y2: -4,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: arcEnd,
	      x2: arcEnd + 4,
	      y1: 0,
	      y2: -4,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M0,0 a21,21 0 0 ".concat(left ? 0 : 1, " ").concat(arcEnd, ",0"),
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: arcEnd,
	      x2: arcEnd - 4,
	      y1: 0,
	      y2: -4,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: arcEnd,
	      x2: arcEnd + 4,
	      y1: 0,
	      y2: -4,
	      strokeWidth: 2
	    })]
	  });
	});
	const SymbolMarker = /*#__PURE__*/react.memo(_ref12 => {
	  let {
	    ident,
	    x,
	    y,
	    endX,
	    endY,
	    arcRadius,
	    arcSweep,
	    type,
	    constraints,
	    length,
	    direction,
	    radials,
	    radii,
	    mapParams,
	    ndRange
	  } = _ref12;
	  let colour = 'White';
	  let shadow = true; // todo airport as well if in flightplan

	  if (type & NdSymbolTypeFlags.Runway) {
	    colour = 'White';
	  } else if (type & NdSymbolTypeFlags.ActiveLegTermination) {
	    colour = 'White';
	  } else if (type & NdSymbolTypeFlags.Tuned) {
	    colour = 'Cyan';
	  } else if (type & (NdSymbolTypeFlags.FlightPlan | NdSymbolTypeFlags.ActiveFlightPlanVector | NdSymbolTypeFlags.FixInfo)) {
	    colour = 'Green';
	  } else if (type & NdSymbolTypeFlags.EfisOption) {
	    colour = 'Magenta';
	    shadow = false;
	  }

	  const elements = []; // FIX INFO

	  if (type & NdSymbolTypeFlags.FixInfo) {
	    if (radii !== undefined) {
	      for (const radius of radii) {
	        const radiusPx = radius * mapParams.nmToPx;
	        elements.push( /*#__PURE__*/jsxRuntime.jsx("path", {
	          d: "m-".concat(radiusPx, ",0 a").concat(radiusPx, ",").concat(radiusPx, " 0 1,0 ").concat(radiusPx * 2, ",0 a").concat(radiusPx, ",").concat(radiusPx, " 0 1,0 -").concat(radiusPx * 2, ",0"),
	          strokeWidth: 2.5,
	          className: "shadow",
	          strokeDasharray: "15 10"
	        }));
	        elements.push( /*#__PURE__*/jsxRuntime.jsx("path", {
	          d: "m-".concat(radiusPx, ",0 a").concat(radiusPx, ",").concat(radiusPx, " 0 1,0 ").concat(radiusPx * 2, ",0 a").concat(radiusPx, ",").concat(radiusPx, " 0 1,0 -").concat(radiusPx * 2, ",0"),
	          strokeWidth: 2,
	          className: "Cyan",
	          strokeDasharray: "15 10"
	        }));
	      }
	    }

	    if (radials !== undefined) {
	      for (const bearing of radials) {
	        const rotation = mapParams.rotation(bearing) * Math.PI / 180; // TODO how long should a piece of string be?

	        const x2 = Math.sin(rotation) * 9000;
	        const y2 = -Math.cos(rotation) * 9000;
	        elements.push( /*#__PURE__*/jsxRuntime.jsx("line", {
	          x2: x2,
	          y2: y2,
	          strokeWidth: 2.5,
	          className: "shadow",
	          strokeDasharray: "15 10"
	        }));
	        elements.push( /*#__PURE__*/jsxRuntime.jsx("line", {
	          x2: x2,
	          y2: y2,
	          strokeWidth: 2,
	          className: "Cyan",
	          strokeDasharray: "15 10"
	        }));
	      }
	    }
	  }

	  if (constraints) {
	    let constraintY = 17;
	    elements.push(...constraints.map(t => /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 13.5,
	      y: constraintY += 17,
	      className: "shadow Magenta",
	      fontSize: 20,
	      children: t
	    })));
	  }

	  if (type & (NdSymbolTypeFlags.CourseReversalLeft | NdSymbolTypeFlags.CourseReversalRight)) {
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(CourseReversalMarker, {
	      mapParams: mapParams,
	      left: (type & NdSymbolTypeFlags.CourseReversalLeft) > 0,
	      direction: direction
	    }));
	  }

	  let showIdent = false;
	  let identYOffset = 0;

	  if (type & NdSymbolTypeFlags.VorDme) {
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(VorDmeMarker, {
	      colour: colour
	    }));
	    showIdent = true;
	  } else if (type & NdSymbolTypeFlags.Vor) {
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(VorMarker, {
	      colour: colour
	    }));
	    showIdent = true;
	  } else if (type & NdSymbolTypeFlags.Dme) {
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(DmeMarker, {
	      colour: colour
	    }));
	    showIdent = true;
	  } else if (type & NdSymbolTypeFlags.Ndb) {
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(NdbMarker, {
	      colour: colour
	    }));
	    showIdent = true;
	  } else if (type & NdSymbolTypeFlags.Runway) {
	    if (ndRange > 80) {
	      elements.push( /*#__PURE__*/jsxRuntime.jsx(RunwayMarkerFar, {
	        ident: ident,
	        mapParams: mapParams,
	        direction: direction
	      }));
	    } else {
	      elements.push( /*#__PURE__*/jsxRuntime.jsx(RunwayMarkerClose, {
	        ident: ident,
	        mapParams: mapParams,
	        direction: direction,
	        lengthPx: mapParams.nmToPx * length
	      }));
	    }
	  } else if (type & NdSymbolTypeFlags.Airport) {
	    showIdent = true;
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(AirportMarker, {
	      colour: colour
	    }));
	  } else if (type & (NdSymbolTypeFlags.Waypoint | NdSymbolTypeFlags.FlightPlan | NdSymbolTypeFlags.FixInfo)) {
	    showIdent = true;
	    elements.push( /*#__PURE__*/jsxRuntime.jsx(WaypointMarker, {
	      colour: colour
	    }));
	  } else if (type & NdSymbolTypeFlags.FlightPlanVectorLine) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M 0 0 l ".concat(endX, " ").concat(endY),
	      className: colour,
	      strokeWidth: 2
	    }));
	  } else if (type & NdSymbolTypeFlags.FlightPlanVectorArc) {
	    showIdent = false;

	    if (!arcRadius) {
	      return null;
	    }

	    const pathRadius = arcRadius.toFixed(2);
	    elements.push( /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M 0 0 A ".concat(pathRadius, " ").concat(pathRadius, " 0 ").concat(Math.abs(arcSweep) >= 180 ? 1 : 0, " ").concat(arcSweep > 0 ? 1 : 0, " ").concat(endX, " ").concat(endY),
	      className: colour,
	      strokeWidth: 2
	    }));
	  } else if (type & NdSymbolTypeFlags.FlightPlanVectorDebugPoint) {
	    showIdent = true;
	    identYOffset = -25;
	    elements.push( /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M 0 0 l -20 0 h 40 m -20 20 v -40",
	      className: colour,
	      strokeWidth: 2
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpTopOfDescent) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 0 0 h 22.2 l 19.8 16.2 m -6 0 h 6 v -6",
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 0 0 h 22.2 l 19.8 16.2 m -6 0 h 6 v -6",
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpCdaFlap1) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 0,
	        r: 13,
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 0,
	        r: 13,
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 2.5,
	        y: 2,
	        className: "shadow ".concat(typeFlagToColor(type)),
	        textAnchor: "middle",
	        dominantBaseline: "middle",
	        fontSize: 21,
	        children: "1"
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpCdaFlap2) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 0,
	        r: 13,
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 0,
	        r: 13,
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 1,
	        y: 2,
	        className: "shadow ".concat(typeFlagToColor(type)),
	        textAnchor: "middle",
	        dominantBaseline: "middle",
	        fontSize: 21,
	        children: "2"
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpDecel) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 0,
	        r: 13,
	        strokeWidth: 1.6,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 0,
	        r: 13,
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 1.5,
	        y: 2,
	        className: "".concat(typeFlagToColor(type), " shadow"),
	        strokeWidth: 1,
	        textAnchor: "middle",
	        dominantBaseline: "middle",
	        fontSize: 22,
	        children: "D"
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpClimbLevelOff) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M -42 16.2 l 19.8 -16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2",
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M -42 16.2 l 19.8 -16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2",
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpDescentLevelOff) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M -42 -16.2 l 19.8 16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2",
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M -42 -16.2 l 19.8 16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2",
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpStartOfClimb) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 0 0 h 22.2 l 19.8 -16.2 m -6 0 h 6 v 6",
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 0 0 h 22.2 l 19.8 -16.2 m -6 0 h 6 v 6",
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpInterceptProfile) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M -38, 0 l 14, -17 v 34 l 14 -17 h10 m -5 -5 l 5 5 l -5 5",
	        strokeWidth: 1.8,
	        className: "shadow"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M -38, 0 l 14, -17 v 34 l 14 -17 h10 m -5 -5 l 5 5 l -5 5",
	        strokeWidth: 1.5,
	        className: typeFlagToColor(type)
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpTimeMarker) {
	    colour = 'Green';
	    showIdent = true;
	    elements.push( /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        r: 12,
	        className: "shadow",
	        strokeWidth: 2.5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        r: 12,
	        className: "Green",
	        strokeWidth: 2
	      })]
	    }));
	  } else if (type & NdSymbolTypeFlags.PwpSpeedChange) {
	    showIdent = false;
	    elements.push( /*#__PURE__*/jsxRuntime.jsx("circle", {
	      cx: 0,
	      cy: 0,
	      r: 8,
	      className: "".concat(typeFlagToColor(type), " Fill")
	    }));
	  }

	  if (showIdent) {
	    elements.push( /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 13.5,
	      y: 17 + identYOffset,
	      fontSize: 20,
	      className: "".concat(colour).concat(shadow ? ' shadow' : ''),
	      children: ident
	    }));
	  }

	  return /*#__PURE__*/jsxRuntime.jsx(Layer, {
	    x: x,
	    y: y,
	    children: elements
	  });
	});
	const ConstraintMarker = /*#__PURE__*/react.memo(_ref13 => {
	  let {
	    x,
	    y,
	    type
	  } = _ref13;
	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: x,
	    y: y,
	    children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	      r: 14,
	      className: "shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	      r: 14,
	      className: typeFlagToColor(type),
	      strokeWidth: 2
	    })]
	  });
	});

	const typeFlagToColor = typeFlag => {
	  if (typeFlag & NdSymbolTypeFlags.CyanColor) {
	    return 'Cyan';
	  }

	  if (typeFlag & NdSymbolTypeFlags.MagentaColor) {
	    return 'Magenta';
	  }

	  if (typeFlag & NdSymbolTypeFlags.AmberColor) {
	    return 'Amber';
	  }

	  return 'White';
	};

	class MapParameters {
	  constructor() {
	    _defineProperty(this, "centerCoordinates", void 0);

	    _defineProperty(this, "mapUpTrueDeg", void 0);

	    _defineProperty(this, "nmToPx", void 0);

	    _defineProperty(this, "mToPx", void 0);

	    _defineProperty(this, "nmRadius", void 0);

	    _defineProperty(this, "version", 0);

	    _defineProperty(this, "valid", false);
	  }

	  compute(centerCoordinates, nmRadius, pxRadius, mapUpTrueDeg) {
	    this.version++;
	    this.valid = Number.isFinite(centerCoordinates.lat) && Number.isFinite(centerCoordinates.long) && Number.isFinite(pxRadius) && Number.isFinite(mapUpTrueDeg);
	    this.mapUpTrueDeg = mapUpTrueDeg;
	    this.centerCoordinates = centerCoordinates;
	    this.nmToPx = pxRadius / nmRadius;
	    this.mToPx = this.nmToPx / 1852;
	    this.nmRadius = nmRadius;
	  }

	  coordinatesToXYy(coordinates) {
	    const bearing = Avionics.Utils.computeGreatCircleHeading(this.centerCoordinates, coordinates) - this.mapUpTrueDeg - 90;
	    const distance = Avionics.Utils.computeGreatCircleDistance(this.centerCoordinates, coordinates);
	    const xNm = distance * Math.cos(bearing * Math.PI / 180);
	    const yNm = distance * Math.sin(bearing * Math.PI / 180);
	    return [xNm * this.nmToPx, yNm * this.nmToPx];
	  }
	  /**
	   * Rotates a true bearing into the map orientation
	   * @param trueBearing
	   * @returns rotation to be applied
	   */


	  rotation(trueBearing) {
	    return trueBearing - this.mapUpTrueDeg;
	  }

	}

	let NavAidMode;

	(function (NavAidMode) {
	  NavAidMode[NavAidMode["Off"] = 0] = "Off";
	  NavAidMode[NavAidMode["ADF"] = 1] = "ADF";
	  NavAidMode[NavAidMode["VOR"] = 2] = "VOR";
	})(NavAidMode || (NavAidMode = {}));

	const TuningModeIndicator = _ref => {
	  let {
	    index
	  } = _ref;
	  const [tuningMode] = useSimVar('L:A32NX_FMGC_RADIONAV_TUNING_MODE', 'enum');
	  return tuningMode !== TuningMode.Auto && /*#__PURE__*/jsxRuntime.jsx("text", {
	    x: index === 1 ? 138 : 616,
	    y: 720,
	    fontSize: 20,
	    textDecoration: "underline",
	    fill: "#ffffff",
	    children: tuningMode === TuningMode.Manual ? 'M' : 'R'
	  }) || null;
	};

	const VorInfo$1 = _ref2 => {
	  let {
	    index
	  } = _ref2;
	  const [vorIdent] = useSimVar("NAV IDENT:".concat(index), 'string');
	  const [vorFrequency] = useSimVar("NAV ACTIVE FREQUENCY:".concat(index), 'megahertz');
	  const [vorHasDme] = useSimVar("NAV HAS DME:".concat(index), 'bool');
	  const [dmeDistance] = useSimVar("NAV DME:".concat(index), 'nautical miles');
	  const [vorAvailable] = useSimVar("NAV HAS NAV:".concat(index), 'boolean');
	  const x = index === 1 ? 37 : 668;

	  const bigLittle = (value, digits) => {
	    const [intPart, decimalPart] = value.toFixed(digits).split('.', 2);
	    return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [intPart, /*#__PURE__*/jsxRuntime.jsxs("tspan", {
	        fontSize: 20,
	        children: [".", decimalPart]
	      })]
	    });
	  }; // FIXME: Use actual JSX syntax for this


	  const freqText = bigLittle(vorFrequency, 2);
	  let dmeText = '---';

	  if (vorHasDme && dmeDistance > 0) {
	    if (dmeDistance > 20) {
	      dmeText = dmeDistance.toFixed(0);
	    } else {
	      dmeText = bigLittle(dmeDistance, 1);
	    }
	  }

	  const path = index === 1 ? 'M25,675 L25,680 L37,696 L13,696 L25,680 M25,696 L25,719' : 'M749,719 L749,696 L755,696 L743,680 L731,696 L737,696 L737,719 M743,680 L743,675';
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    className: "GtLayer",
	    children: [vorAvailable && /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: path,
	      strokeWidth: 2,
	      className: "White",
	      strokeLinejoin: "round",
	      strokeLinecap: "round"
	    }), /*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: x,
	      y: 692,
	      fontSize: 24,
	      className: "White",
	      children: ["VOR", index]
	    }), (vorAvailable || vorHasDme) && vorFrequency > 1 && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: x,
	      y: 722,
	      fontSize: 24,
	      className: "White",
	      children: vorIdent
	    }), !(vorAvailable || vorHasDme) && vorFrequency > 1 && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: index === 2 ? x - 26 : x,
	      y: 722,
	      fontSize: 24,
	      className: "White",
	      children: freqText
	    }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	      transform: "translate(".concat(index === 1 ? -16 : 0, ")"),
	      children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	        x: dmeDistance > 20 ? x + 46 : x + 58,
	        y: 759,
	        fontSize: 24,
	        fill: "#00ff00",
	        textAnchor: "end",
	        children: dmeText
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: x + 66,
	        y: 759,
	        fontSize: 20,
	        fill: "#00ffff",
	        children: "NM"
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx(TuningModeIndicator, {
	      index: index
	    })]
	  });
	};

	const AdfInfo = _ref3 => {
	  let {
	    index
	  } = _ref3;
	  const [adfIdent] = useSimVar("ADF IDENT:".concat(index), 'string');
	  const [adfFrequency] = useSimVar("ADF ACTIVE FREQUENCY:".concat(index), 'kilohertz');
	  const [adfAvailable] = useSimVar("ADF SIGNAL:".concat(index), 'boolean');
	  const x = index === 1 ? 37 : 668;
	  const path = index === 1 ? 'M31,686 L25,680 L19,686 M25,680 L25,719' : 'M749,719 L749,696 L743,690 L737,696 L737,719 M743,690 L743,675';
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    className: "GtLayer",
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: path,
	      strokeWidth: 2,
	      className: "Green",
	      strokeLinejoin: "round",
	      strokeLinecap: "round"
	    }), /*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: x,
	      y: 692,
	      fontSize: 24,
	      className: "Green",
	      children: ["ADF", index]
	    }), adfAvailable && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: x,
	      y: 722,
	      fontSize: 24,
	      className: "Green",
	      children: adfIdent
	    }), !adfAvailable && adfFrequency > 0 && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: x,
	      y: 722,
	      fontSize: 24,
	      className: "Green",
	      children: Math.floor(adfFrequency).toFixed(0)
	    }), /*#__PURE__*/jsxRuntime.jsx(TuningModeIndicator, {
	      index: index
	    })]
	  });
	};

	const RadioNavInfo = _ref4 => {
	  let {
	    index,
	    side
	  } = _ref4;
	  const [mode] = useSimVar("L:A32NX_EFIS_".concat(side, "_NAVAID_").concat(index, "_MODE"), 'enum');

	  if (mode === NavAidMode.VOR) {
	    return /*#__PURE__*/jsxRuntime.jsx(VorInfo$1, {
	      index: index
	    });
	  }

	  if (mode === NavAidMode.ADF) {
	    return /*#__PURE__*/jsxRuntime.jsx(AdfInfo, {
	      index: index
	    });
	  }

	  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
	};

	const AdfNeedle = _ref => {
	  let {
	    index,
	    displayMode,
	    centreHeight
	  } = _ref;
	  const [relativeBearing] = useSimVar("ADF RADIAL:".concat(index), 'degrees');
	  const [available] = useSimVar("ADF SIGNAL:".concat(index), 'number');
	  let paths;

	  switch (displayMode) {
	    case Mode.ARC:
	      paths = ['M384,251 L384,128 M370,179 L384,155 L398,179 M384,1112 L384,989 M370,1085 L384,1061 L398,1085', 'M370,251 L370,219 L384,195 L398,219 L398,251 M384,195 L384,128 M384,1112 L384,1023 M370,989 L370,1040 L384,1023 L398,1040 L398,989'];
	      break;

	    case Mode.ROSE_ILS:
	    case Mode.ROSE_VOR:
	    case Mode.ROSE_NAV:
	      paths = ['M384,257 L384,134 M370,185 L384,161 L398,185 M384,634 L384,511 M370,607 L384,583 L398,607', 'M370,257 L370,225 L384,201 L398,225 L398,257 M384,201 L384,134 M384,634 L384,545 M370,511 L370,562 L384,545 L398,562 L398,511'];
	      break;

	    default:
	      console.error("RadioNeedle: invalid display mode: ".concat(displayMode));
	      return null;
	  }

	  return available && /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(relativeBearing, " 384 ").concat(centreHeight, ")"),
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: paths[index - 1],
	      strokeWidth: 3.7,
	      className: "shadow rounded"
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: paths[index - 1],
	      strokeWidth: 3.2,
	      className: "Green rounded"
	    })]
	  });
	};

	const VorNeedle = _ref2 => {
	  let {
	    index,
	    displayMode,
	    centreHeight
	  } = _ref2;
	  const [relativeBearing] = useSimVar("NAV RELATIVE BEARING TO STATION:".concat(index), 'degrees');
	  const [available] = useSimVar("NAV HAS NAV:".concat(index), 'number');
	  let paths;

	  switch (displayMode) {
	    case Mode.ARC:
	      paths = ['M384,251 L384,179 M384,128 L384,155 L370,179 L398,179 L384,155 M384,1112 L384,1085 M384,989 L384,1061 L370,1085 L398,1085 L384,1061', 'M377,251 L377,219 L370,219 L384,195 L398,219 L391,219 L391,251 M384,195 L384,128 M384,1112 L384,1045 M377,989 L377,1045 L391,1045 L391,989'];
	      break;

	    case Mode.ROSE_ILS:
	    case Mode.ROSE_VOR:
	    case Mode.ROSE_NAV:
	      paths = ['M384,257 L384,185 M384,134 L384,161 L370,185 L398,185 L384,161 M384,634 L384,607 M384,511 L384,583 L370,607 L398,607 L384,583', 'M377,257 L377,225 L370,225 L384,201 L398,225 L391,225 L391,256 M384,201 L384,134 M384,634 L384,567 M377,511 L377,567 L391,567 L391,511'];
	      break;

	    default:
	      console.error("RadioNeedle: invalid display mode: ".concat(displayMode));
	      return null;
	  }

	  return available && /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(relativeBearing, " 384 ").concat(centreHeight, ")"),
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: paths[index - 1],
	      strokeWidth: 3.7,
	      className: "shadow rounded"
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: paths[index - 1],
	      strokeWidth: 3.2,
	      className: "White rounded"
	    })]
	  });
	};

	const RadioNeedle = _ref3 => {
	  let {
	    index,
	    side,
	    displayMode,
	    centreHeight
	  } = _ref3;
	  const [mode] = useSimVar("L:A32NX_EFIS_".concat(side, "_NAVAID_").concat(index, "_MODE"), 'enum');

	  switch (mode) {
	    case NavAidMode.ADF:
	      return /*#__PURE__*/jsxRuntime.jsx(AdfNeedle, {
	        index: index,
	        displayMode: displayMode,
	        centreHeight: centreHeight
	      });

	    case NavAidMode.VOR:
	      return /*#__PURE__*/jsxRuntime.jsx(VorNeedle, {
	        index: index,
	        displayMode: displayMode,
	        centreHeight: centreHeight
	      });

	    case NavAidMode.Off:
	    default:
	      return null;
	  }
	};

	const ToWaypointIndicator = /*#__PURE__*/react.memo(_ref => {
	  let {
	    side
	  } = _ref;
	  // TODO replace with appropriate ARINC 429 labels
	  const [ident, setIdent] = react.useState(null);
	  const [ident0] = useSimVar("L:A32NX_EFIS_".concat(side, "_TO_WPT_IDENT_0"), 'number', 500);
	  const [ident1] = useSimVar("L:A32NX_EFIS_".concat(side, "_TO_WPT_IDENT_1"), 'number', 500);
	  const [bearing] = useSimVar("L:A32NX_EFIS_".concat(side, "_TO_WPT_BEARING"), 'Degrees');
	  const [distance] = useSimVar("L:A32NX_EFIS_".concat(side, "_TO_WPT_DISTANCE"), 'Number');
	  const [eta] = useSimVar("L:A32NX_EFIS_".concat(side, "_TO_WPT_ETA"), 'Seconds');
	  react.useEffect(() => {
	    // EIS2 can only display 9 characters for the ident
	    setIdent(SimVarString.unpack([ident0, ident1]));
	  }, [ident0, ident1]);
	  let distanceFixed;
	  let distanceIntegralPart;
	  let distanceDecimalPart;
	  /*
	   * distance < 20nm: XX.Y NM
	   * distance > 20nm: XXXX NM
	   */

	  if (!distance) {
	    distanceFixed = '';
	    distanceIntegralPart = '';
	    distanceDecimalPart = '';
	  } else if (distance < 20) {
	    distanceFixed = distance.toFixed(1);
	    [distanceIntegralPart, distanceDecimalPart] = distanceFixed.split('.');
	  } else {
	    distanceFixed = Math.round(Math.min(9999, distance));
	  }

	  const hh = Math.floor(eta / 3600);
	  const mm = Math.floor(eta % 3600 / 60);
	  const utc = "".concat(hh.toString().padStart(2, '0'), ":").concat(mm.toString().padStart(2, '0'));
	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 690,
	    y: 28,
	    children: [ident && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: -9,
	      y: 0,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: ident
	    }), bearing && bearing !== -1 && Number.isFinite(bearing) && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 54,
	        y: 0,
	        fontSize: 25,
	        className: "Green",
	        textAnchor: "end",
	        children: Math.round(bearing).toString().padStart(3, '0')
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 73,
	        y: 2,
	        fontSize: 25,
	        className: "Cyan",
	        textAnchor: "end",
	        children: "\xB0"
	      })]
	    }), distance && distance !== -1 && Number.isFinite(distance) && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [distance < 20 ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	        children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	          x: 8,
	          y: 30,
	          fontSize: 24,
	          className: "Green",
	          textAnchor: "end",
	          children: distanceIntegralPart
	        }), /*#__PURE__*/jsxRuntime.jsx("text", {
	          x: 8,
	          y: 30,
	          fontSize: 23,
	          className: "Green",
	          textAnchor: "start",
	          children: "."
	        }), /*#__PURE__*/jsxRuntime.jsx("text", {
	          x: 22,
	          y: 30,
	          fontSize: 19,
	          className: "Green",
	          textAnchor: "start",
	          children: distanceDecimalPart
	        })]
	      }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
	        children: /*#__PURE__*/jsxRuntime.jsx("text", {
	          x: 34,
	          y: 30,
	          fontSize: 24,
	          className: "Green",
	          textAnchor: "end",
	          children: distanceFixed
	        })
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 72,
	        y: 30,
	        fontSize: 18,
	        className: "Cyan",
	        textAnchor: "end",
	        children: "NM"
	      })]
	    }), eta !== -1 && utc && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 72,
	      y: 62,
	      fontSize: 25,
	      className: "Green",
	      textAnchor: "end",
	      children: utc
	    })]
	  });
	});

	const ApproachMessage = _ref => {
	  let {
	    side
	  } = _ref;
	  const [apprMsg0] = useSimVar("L:A32NX_EFIS_".concat(side, "_APPR_MSG_0"), 'number', 5000);
	  const [apprMsg1] = useSimVar("L:A32NX_EFIS_".concat(side, "_APPR_MSG_1"), 'number', 5000);
	  const apprMsg = SimVarString.unpack([apprMsg0, apprMsg1]);

	  if (apprMsg.length < 1) {
	    return null;
	  }

	  return /*#__PURE__*/jsxRuntime.jsx(Layer, {
	    x: 384,
	    y: 28,
	    children: /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 0,
	      y: 0,
	      fontSize: 25,
	      className: "Green",
	      textAnchor: "middle",
	      children: apprMsg
	    })
	  });
	};

	const CrossTrack = _ref => {
	  let {
	    x,
	    y,
	    isPlanMode,
	    side
	  } = _ref;
	  const [crossTrackError] = useSimVar('L:A32NX_FG_CROSS_TRACK_ERROR', 'nautical miles', 250);
	  const [rnp] = useSimVar("L:A32NX_FMGC_".concat(side, "_RNP"), 'number');
	  let crossTrackText = '';
	  let crossTrackAnchor = 'start';
	  let crossTrackX = x;
	  const crossTrackAbs = Math.min(99.9, Math.abs(crossTrackError));

	  if (rnp > 0 && rnp <= 0.3 + Number.EPSILON && crossTrackAbs >= 0.02 - Number.EPSILON && crossTrackAbs < 0.3 + Number.EPSILON) {
	    crossTrackText = crossTrackAbs.toFixed(2);
	  } else if (crossTrackAbs >= 0.1) {
	    crossTrackText = crossTrackAbs.toFixed(1);
	  }

	  if (crossTrackText.length > 0) {
	    if (crossTrackError < 0) {
	      crossTrackText += 'R';
	      crossTrackAnchor = 'start';
	      crossTrackX = x + 34;
	    } else {
	      crossTrackText += 'L';
	      crossTrackAnchor = 'end';
	      crossTrackX = x - 38;
	    }
	  }

	  return /*#__PURE__*/jsxRuntime.jsx("text", {
	    x: isPlanMode ? x : crossTrackX,
	    y: y,
	    textAnchor: isPlanMode ? 'start' : crossTrackAnchor,
	    fontSize: 24,
	    className: "Green shadow",
	    children: crossTrackText
	  });
	};

	const TrackLine = /*#__PURE__*/react.memo(_ref => {
	  let {
	    x,
	    y,
	    heading,
	    track,
	    mapParams,
	    groundSpeed,
	    symbols,
	    ndRange
	  } = _ref;
	  const rotate = MathUtils.diffAngle(heading, track);
	  const [lastUpdateTime, setLastUpdateTime] = react.useState(Date.now());
	  react.useEffect(() => {
	    setLastUpdateTime(Date.now());
	  }, [symbols]);
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(rotate, " ").concat(x, " ").concat(y, ")"),
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 149,
	      x2: x,
	      y2: y,
	      className: "rounded shadow",
	      strokeWidth: 3.0
	    }), /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 149,
	      x2: x,
	      y2: y,
	      className: "rounded Green",
	      strokeWidth: 2.5
	    }), symbols.map(symbol => {
	      // We only want to place the symbol on the track line if it does not have a location on the flight plan.
	      if (!symbol.distanceFromAirplane || symbol.location) {
	        return false;
	      }

	      const dy = (symbol.distanceFromAirplane - groundSpeed * (Date.now() - lastUpdateTime) / 1000 / 60 / 60) * mapParams.nmToPx;
	      return /*#__PURE__*/jsxRuntime.jsx(SymbolMarker, {
	        x: x,
	        y: y - dy,
	        type: symbol.type,
	        mapParams: mapParams,
	        ident: symbol.ident,
	        ndRange: ndRange
	      });
	    })]
	  });
	});

	/* eslint-disable camelcase */
	const REFRESH_RATE = 1000; // Time between refreshes in ms

	const TRACKING_MAX = 40; // # max contacts tracked - AMM 34-43-00:6a

	const DISPLAY_MAX = 8; // # max contacts tracked - usually configurable by PIN program

	const MEMORY_MAX = 200; // Max history before culling

	const MIN_VS = -6000;
	const MAX_VS = 6000;
	const INHIBIT_CLB_RA = 39000; // for all climb RA's

	const INHIBIT_INC_DES_RA_AGL = 1450; // for increase descent RA's

	const INHIBIT_ALL_DES_RA_AGL = 1200; // 1200 takeoff, 1000 approach

	const INHIBIT_ALL_RA = 1000; // 1100 in climb, 900 in descent

	const REALLY_BIG_NUMBER = 1000000;
	const INITIAL_DELAY = 5; // in seconds

	const FOLLOWUP_DELAY = 2.5; // in deconds

	const INITIAL_ACCEL = 8.04; // 0.25G in f/s^2

	const FOLLOWUP_ACCEL = 10.62; // 0.33G in f/s^2

	const TA_EXPIRATION_DELAY = 4; // in seconds

	const MIN_RA_DURATION = 5; // in seconds

	const VOL_BOOST = 1.25; // multiplier

	const CLOSURE_RATE_THRESH = -40; // in knots

	let TcasThreat;

	(function (TcasThreat) {
	  TcasThreat[TcasThreat["THREAT"] = 0] = "THREAT";
	  TcasThreat[TcasThreat["ALL"] = 1] = "ALL";
	  TcasThreat[TcasThreat["ABOVE"] = 2] = "ABOVE";
	  TcasThreat[TcasThreat["BELOW"] = 3] = "BELOW";
	})(TcasThreat || (TcasThreat = {}));

	let TcasState;

	(function (TcasState) {
	  TcasState[TcasState["NONE"] = 0] = "NONE";
	  TcasState[TcasState["TA"] = 1] = "TA";
	  TcasState[TcasState["RA"] = 2] = "RA";
	})(TcasState || (TcasState = {}));

	let TcasMode;

	(function (TcasMode) {
	  TcasMode[TcasMode["STBY"] = 0] = "STBY";
	  TcasMode[TcasMode["TA"] = 1] = "TA";
	  TcasMode[TcasMode["TARA"] = 2] = "TARA";
	})(TcasMode || (TcasMode = {}));

	let XpdrMode;

	(function (XpdrMode) {
	  XpdrMode[XpdrMode["STBY"] = 1] = "STBY";
	  XpdrMode[XpdrMode["ON"] = 3] = "ON";
	  XpdrMode[XpdrMode["ALT"] = 4] = "ALT";
	})(XpdrMode || (XpdrMode = {}));

	let TaRaIndex;

	(function (TaRaIndex) {
	  TaRaIndex[TaRaIndex["TA"] = 0] = "TA";
	  TaRaIndex[TaRaIndex["RA"] = 1] = "RA";
	})(TaRaIndex || (TaRaIndex = {}));

	let TaRaIntrusion;

	(function (TaRaIntrusion) {
	  TaRaIntrusion[TaRaIntrusion["TRAFFIC"] = 0] = "TRAFFIC";
	  TaRaIntrusion[TaRaIntrusion["PROXIMITY"] = 1] = "PROXIMITY";
	  TaRaIntrusion[TaRaIntrusion["TA"] = 2] = "TA";
	  TaRaIntrusion[TaRaIntrusion["RA"] = 3] = "RA";
	})(TaRaIntrusion || (TaRaIntrusion = {}));

	let Intrude;

	(function (Intrude) {
	  Intrude[Intrude["RANGE"] = 0] = "RANGE";
	  Intrude[Intrude["ALT"] = 1] = "ALT";
	  Intrude[Intrude["SPEED"] = 2] = "SPEED";
	})(Intrude || (Intrude = {}));

	let RaSense;

	(function (RaSense) {
	  RaSense[RaSense["UP"] = 0] = "UP";
	  RaSense[RaSense["DOWN"] = 1] = "DOWN";
	})(RaSense || (RaSense = {}));

	let RaType;

	(function (RaType) {
	  RaType[RaType["CORRECT"] = 0] = "CORRECT";
	  RaType[RaType["PREVENT"] = 1] = "PREVENT";
	})(RaType || (RaType = {}));

	let Limits;

	(function (Limits) {
	  Limits[Limits["MIN"] = 0] = "MIN";
	  Limits[Limits["MAX"] = 1] = "MAX";
	})(Limits || (Limits = {}));

	let Inhibit;

	(function (Inhibit) {
	  Inhibit[Inhibit["NONE"] = 0] = "NONE";
	  Inhibit[Inhibit["ALL_RA_AURAL_TA"] = 1] = "ALL_RA_AURAL_TA";
	  Inhibit[Inhibit["ALL_RA"] = 2] = "ALL_RA";
	  Inhibit[Inhibit["ALL_CLIMB_RA"] = 3] = "ALL_CLIMB_RA";
	  Inhibit[Inhibit["ALL_DESC_RA"] = 4] = "ALL_DESC_RA";
	  Inhibit[Inhibit["ALL_INCR_DESC_RA"] = 5] = "ALL_INCR_DESC_RA";
	})(Inhibit || (Inhibit = {}));

	const THREAT = {
	  [TcasThreat.THREAT]: [-2700, 2700],
	  [TcasThreat.ALL]: [-2700, 2700],
	  [TcasThreat.ABOVE]: [-2700, 9900],
	  [TcasThreat.BELOW]: [-9900, 2700]
	}; // Altitude -> Sensitivity

	const SENSE = {
	  3: [1000, 2350],
	  4: [2350, 5000],
	  5: [5000, 10000],
	  6: [10000, 20000],
	  7: [20000, 47000]
	}; // TCAS Range Limit

	const RANGE = {
	  // 34-43-00 6:2339
	  forward: [60, 100],
	  // 60-100 Nm Forwards
	  side: 30,
	  // 30 Nm side
	  back: 20,
	  // 20Nm behind
	  alt: 9900
	}; // Sensitivity to TAU limit

	const TAU = {
	  1: [-1, -1],
	  2: [20, -1],
	  3: [25, 15],
	  4: [30, 20],
	  5: [40, 25],
	  6: [45, 30],
	  7: [48, 35],
	  8: [48, 35]
	}; // Incremental Range Protection Volume

	const DMOD = {
	  1: [-1, -1],
	  2: [0.3, -1],
	  3: [0.33, 0.2],
	  4: [0.48, 0.35],
	  5: [0.75, 0.55],
	  6: [1, 0.8],
	  7: [1.3, 1.1],
	  8: [1.3, 1.1]
	}; // Detection Alt Threshold

	const ZTHR = {
	  1: [-1, -1],
	  2: [850, -1],
	  3: [850, 300],
	  4: [850, 300],
	  5: [850, 350],
	  6: [850, 400],
	  7: [850, 600],
	  8: [1200, 700]
	}; // Time Variable Alt Tau Threshold

	const TVTHR = {
	  1: -1,
	  2: -1,
	  3: 15,
	  4: 18,
	  5: 20,
	  6: 22,
	  7: 25,
	  8: 25
	}; // Positive Advisory Altitude Threshold

	const ALIM = {
	  1: -1,
	  2: -1,
	  3: 300,
	  4: 300,
	  5: 350,
	  6: 400,
	  7: 600,
	  8: 700
	}; // Limit closure acceleration (workaround/unrealistic)
	// TODO FIXME: Replace with HMD accel filter?

	const ACCEL = {
	  1: [900, 900],
	  2: [1000, 1000],
	  3: [1100, 1200],
	  4: [1200, 1300],
	  5: [1300, 1400],
	  6: [2000, 2200],
	  7: [2100, 2300],
	  8: [2200, 2500]
	}; // many lengths are approximate until we can get them accuratly (when boris re-makes them and we have the sources)

	const SOUNDS = {
	  pull_up: {
	    name: 'aural_pullup_new',
	    length: 0.9
	  },
	  sink_rate: {
	    name: 'aural_sink_rate_new',
	    length: 0.9
	  },
	  dont_sink: {
	    name: 'aural_dontsink_new',
	    length: 0.9
	  },
	  too_low_gear: {
	    name: 'aural_too_low_gear',
	    length: 0.8
	  },
	  too_low_flaps: {
	    name: 'aural_too_low_flaps',
	    length: 0.8
	  },
	  too_low_terrain: {
	    name: 'aural_too_low_terrain',
	    length: 0.9
	  },
	  minimums: {
	    name: 'aural_minimumnew',
	    length: 0.67
	  },
	  hundred_above: {
	    name: 'aural_100above',
	    length: 0.72
	  },
	  retard: {
	    name: 'new_retard',
	    length: 0.9
	  },
	  alt_2500: {
	    name: 'new_2500',
	    length: 1.1
	  },
	  alt_1000: {
	    name: 'new_1000',
	    length: 0.9
	  },
	  alt_500: {
	    name: 'new_500',
	    length: 0.6
	  },
	  alt_400: {
	    name: 'new_400',
	    length: 0.6
	  },
	  alt_300: {
	    name: 'new_300',
	    length: 0.6
	  },
	  alt_200: {
	    name: 'new_200',
	    length: 0.6
	  },
	  alt_100: {
	    name: 'new_100',
	    length: 0.6
	  },
	  alt_50: {
	    name: 'new_50',
	    length: 0.4
	  },
	  alt_40: {
	    name: 'new_40',
	    length: 0.4
	  },
	  alt_30: {
	    name: 'new_30',
	    length: 0.4
	  },
	  alt_20: {
	    name: 'new_20',
	    length: 0.4
	  },
	  alt_10: {
	    name: 'new_10',
	    length: 0.3
	  },
	  alt_5: {
	    name: 'new_5',
	    length: 0.3
	  },
	  climb_climb: {
	    name: 'climb_climb',
	    length: 1.6
	  },
	  climb_crossing_climb: {
	    name: 'climb_crossing_climb',
	    length: 1.7
	  },
	  increase_climb: {
	    name: 'increase_climb',
	    length: 1.2
	  },
	  climb_climb_now: {
	    name: 'climb_climb_now',
	    length: 1.9
	  },
	  clear_of_conflict: {
	    name: 'clear_of_conflict',
	    length: 1.5
	  },
	  descend_descend: {
	    name: 'descend_descend',
	    length: 2.1
	  },
	  descend_crossing_descend: {
	    name: 'descend_crossing_descend',
	    length: 1.9
	  },
	  increase_descent: {
	    name: 'increase_descent',
	    length: 1.3
	  },
	  descend_descend_now: {
	    name: 'descend_descend_now',
	    length: 2.2
	  },
	  monitor_vs: {
	    name: 'monitor_vs',
	    length: 1.7
	  },
	  maint_vs_maint: {
	    name: 'maint_vs_maint',
	    length: 3.2
	  },
	  maint_vs_crossing_maint: {
	    name: 'maint_vs_crossing_maint',
	    length: 3.2
	  },
	  level_off_level_off: {
	    name: 'level_off_level_off',
	    length: 2.3
	  },
	  traffic_traffic: {
	    name: 'traffic_traffic',
	    length: 1.5
	  }
	};
	const CALLOUTS = {
	  climb: {
	    id: 0,
	    repeat: false,
	    sound: SOUNDS.climb_climb
	  },
	  climb_cross: {
	    id: 1,
	    repeat: true,
	    sound: SOUNDS.climb_crossing_climb
	  },
	  climb_increase: {
	    id: 2,
	    repeat: true,
	    sound: SOUNDS.increase_climb
	  },
	  climb_now: {
	    id: 3,
	    repeat: true,
	    sound: SOUNDS.climb_climb_now
	  },
	  clear_of_conflict: {
	    id: 4,
	    repeat: false,
	    sound: SOUNDS.clear_of_conflict
	  },
	  descend: {
	    id: 5,
	    repeat: false,
	    sound: SOUNDS.descend_descend
	  },
	  descend_cross: {
	    id: 6,
	    repeat: true,
	    sound: SOUNDS.descend_crossing_descend
	  },
	  descend_increase: {
	    id: 7,
	    repeat: true,
	    sound: SOUNDS.increase_descent
	  },
	  descend_now: {
	    id: 8,
	    repeat: true,
	    sound: SOUNDS.descend_descend_now
	  },
	  monitor_vs: {
	    id: 9,
	    repeat: false,
	    sound: SOUNDS.monitor_vs
	  },
	  maintain_vs: {
	    id: 10,
	    repeat: false,
	    sound: SOUNDS.maint_vs_maint
	  },
	  maintain_vs_cross: {
	    id: 11,
	    repeat: false,
	    sound: SOUNDS.maint_vs_crossing_maint
	  },
	  level_off: {
	    id: 12,
	    repeat: false,
	    sound: SOUNDS.level_off_level_off
	  },
	  traffic: {
	    id: 13,
	    repeat: false,
	    sound: SOUNDS.traffic_traffic
	  }
	};
	const RA_VARIANTS = {
	  // PREVENTIVE RA's
	  monitor_vs_climb_0: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.UP,
	    type: RaType.PREVENT,
	    vs: {
	      green: [0, MAX_VS],
	      red: [MIN_VS, 0]
	    }
	  },
	  monitor_vs_climb_500: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.UP,
	    type: RaType.PREVENT,
	    vs: {
	      green: [-500, MAX_VS],
	      red: [MIN_VS, -500]
	    }
	  },
	  monitor_vs_climb_1000: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.UP,
	    type: RaType.PREVENT,
	    vs: {
	      green: [-1000, MAX_VS],
	      red: [MIN_VS, -1000]
	    }
	  },
	  monitor_vs_climb_2000: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.UP,
	    type: RaType.PREVENT,
	    vs: {
	      green: [-2000, MAX_VS],
	      red: [MIN_VS, -2000]
	    }
	  },
	  monitor_vs_descend_0: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.DOWN,
	    type: RaType.PREVENT,
	    vs: {
	      green: [MIN_VS, 0],
	      red: [0, MAX_VS]
	    }
	  },
	  monitor_vs_descend_500: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.DOWN,
	    type: RaType.PREVENT,
	    vs: {
	      green: [MIN_VS, 500],
	      red: [500, MAX_VS]
	    }
	  },
	  monitor_vs_descend_1000: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.DOWN,
	    type: RaType.PREVENT,
	    vs: {
	      green: [MIN_VS, 1000],
	      red: [1000, MAX_VS]
	    }
	  },
	  monitor_vs_descend_2000: {
	    callout: CALLOUTS.monitor_vs,
	    sense: RaSense.DOWN,
	    type: RaType.PREVENT,
	    vs: {
	      green: [MIN_VS, 2000],
	      red: [2000, MAX_VS]
	    }
	  },
	  // CORRECTIVE RA's
	  // CLIMB
	  climb: {
	    callout: CALLOUTS.climb,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [1500, 2000],
	      red: [MIN_VS, 1500]
	    }
	  },
	  climb_cross: {
	    callout: CALLOUTS.climb_cross,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [1500, 2000],
	      red: [MIN_VS, 1500]
	    }
	  },
	  climb_increase: {
	    callout: CALLOUTS.climb_increase,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [2500, 4400],
	      red: [MIN_VS, 2500]
	    }
	  },
	  climb_now: {
	    callout: CALLOUTS.climb_now,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [1500, 2000],
	      red: [MIN_VS, 1500]
	    }
	  },
	  // CORRECTIVE RA's
	  // DESCEND
	  descend: {
	    callout: CALLOUTS.descend,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-2000, -1500],
	      red: [-1500, MAX_VS]
	    }
	  },
	  descend_cross: {
	    callout: CALLOUTS.descend_cross,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-2000, -1500],
	      red: [-1500, MAX_VS]
	    }
	  },
	  descend_increase: {
	    callout: CALLOUTS.descend_increase,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-4400, -2500],
	      red: [-2500, MAX_VS]
	    }
	  },
	  descend_now: {
	    callout: CALLOUTS.descend_now,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-2000, -1500],
	      red: [-1500, MAX_VS]
	    }
	  },
	  // CORRECTIVE RA's
	  // LEVEL OFF
	  // level_off_250_both: {
	  //     // Currently not used
	  //     // Will be used when support for multi-threat RA's,
	  //     // from both above and below, will be added
	  //     callout: CALLOUTS.level_off,
	  //     sense: RaSense.UP,
	  //     type: RaType.CORRECT,
	  //     vs: {
	  //         green: [-250, 250],
	  //         red: [
	  //             [MIN_VS, -250],
	  //             [250, MAX_VS]
	  //         ]
	  //     }
	  // },
	  level_off_300_below: {
	    callout: CALLOUTS.level_off,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-400, 0],
	      red: [0, MAX_VS]
	    }
	  },
	  level_off_300_above: {
	    callout: CALLOUTS.level_off,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [0, 400],
	      red: [MIN_VS, 0]
	    }
	  },
	  // CORRECTIVE RA's
	  // MAINTAIN VS, CLIMB
	  climb_maintain_vs: {
	    callout: CALLOUTS.maintain_vs,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [1500, 4400],
	      red: [MIN_VS, 1500]
	    }
	  },
	  climb_maintain_vs_crossing: {
	    callout: CALLOUTS.maintain_vs,
	    sense: RaSense.UP,
	    type: RaType.CORRECT,
	    vs: {
	      green: [1500, 4400],
	      red: [MIN_VS, 1500]
	    }
	  },
	  // CORRECTIVE RA's
	  // MAINTAIN VS, DESCEND
	  descend_maintain_vs: {
	    callout: CALLOUTS.maintain_vs,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-4400, -1500],
	      red: [-1500, MAX_VS]
	    }
	  },
	  descend_maintain_vs_crossing: {
	    callout: CALLOUTS.maintain_vs,
	    sense: RaSense.DOWN,
	    type: RaType.CORRECT,
	    vs: {
	      green: [-4400, -1500],
	      red: [-1500, MAX_VS]
	    }
	  }
	};
	const TCAS_CONST = {
	  REFRESH_RATE,
	  TRACKING_MAX,
	  DISPLAY_MAX,
	  MEMORY_MAX,
	  MIN_VS,
	  INHIBIT_CLB_RA,
	  // for all climb RA's
	  INHIBIT_INC_DES_RA_AGL,
	  // for increase descent RA's
	  INHIBIT_ALL_DES_RA_AGL,
	  // 1200 takeoff, 1000 approach
	  INHIBIT_ALL_RA,
	  // 1100 in climb, 900 in descent
	  REALLY_BIG_NUMBER,
	  INITIAL_DELAY,
	  // in seconds
	  FOLLOWUP_DELAY,
	  // in deconds
	  INITIAL_ACCEL,
	  // 0.25G in f/s^2
	  FOLLOWUP_ACCEL,
	  // 0.33G in f/s^2
	  TA_EXPIRATION_DELAY,
	  // in seconds
	  MIN_RA_DURATION,
	  // in seconds
	  VOL_BOOST,
	  // multiplier
	  CLOSURE_RATE_THRESH,
	  // in knots
	  THREAT,
	  SENSE,
	  RANGE,
	  TAU,
	  DMOD,
	  ZTHR,
	  TVTHR,
	  ALIM,
	  ACCEL,
	  SOUNDS,
	  CALLOUTS,
	  RA_VARIANTS
	};

	/**
	 * This hook allows to read and set a persistent storage property.
	 * Overloads are provided to absolve callers with defaults from dealing with possibly undefined
	 */

	function usePersistentProperty(propertyName, defaultValue) {
	  const [propertyValue, rawPropertySetter] = react.useState(() => NXDataStore.get(propertyName, defaultValue));
	  react.useEffect(() => {
	    const unsubscribe = NXDataStore.subscribe(propertyName, (key, value) => rawPropertySetter(value));
	    return () => {
	      unsubscribe();
	    };
	  }, []);

	  const propertySetter = value => {
	    NXDataStore.set(propertyName, value);
	    rawPropertySetter(value);
	  };

	  return [propertyValue, propertySetter];
	}

	/* eslint-disable camelcase */
	const TCAS_MASK_ARC = [// ARC
	[-384, -310], [-384, 0], [-264, 0], [-210, 59], [-210, 143], [210, 143], [210, 0], [267, -61], [384, -61], [384, -310], [340, -355], [300, -390], [240, -431.5], [180, -460], [100, -482], [0, -492], [-100, -482], [-180, -460], [-240, -431.5], [-300, -390], [-340, -355], [-384, -310]];
	const TCAS_MASK_ROSE = [// ROSE NAV
	[-340, -227], [-103, -227], [-50, -244], [0, -250], [50, -244], [103, -227], [340, -227], [340, 180], [267, 180], [210, 241], [210, 383], [-210, 383], [-210, 300], [-264, 241], [-340, 241], [-340, -227]];

	const useAirTraffic = (mapParams, mode) => {
	  const [airTraffic, setAirTraffic] = react.useState([]);
	  const tcasMask = mode === Mode.ARC ? TCAS_MASK_ARC : TCAS_MASK_ROSE;
	  useFlowSyncEvent('A32NX_TCAS_TRAFFIC', (_topic, data) => {
	    if (data) {
	      setAirTraffic(trafficToDisplay(data, mapParams, tcasMask));
	    }
	  });
	  react.useEffect(() => {
	    setAirTraffic(trafficToDisplay(airTraffic, mapParams, tcasMask));
	  }, [mapParams === null || mapParams === void 0 ? void 0 : mapParams.nmRadius, mode]);
	  return airTraffic;
	};

	const trafficToDisplay = (airTraffic, mapParams, tcasMask) => airTraffic.map(traffic => {
	  const latLong = {
	    lat: traffic.lat,
	    long: traffic.lon
	  };
	  let [x, y] = mapParams.coordinatesToXYy(latLong);
	  const bitfield = traffic.bitfield;
	  const vertSpeed = Math.round(bitfield / 10);
	  const intrusionLevel = Math.abs(bitfield % 10); // TODO FIXME: Full time option installed: For all ranges except in ZOOM ranges, NDRange > 9NM

	  if (!MathUtils.pointInPolygon(x, y, tcasMask)) {
	    if (intrusionLevel < TaRaIntrusion.TA) {
	      traffic.alive = false;
	      return traffic;
	    }

	    const ret = MathUtils.intersectWithPolygon(x, y, 0, 0, tcasMask);
	    if (ret) [x, y] = ret;
	  }

	  traffic.alive = true;
	  traffic.vertSpeed = vertSpeed;
	  traffic.posX = x;
	  traffic.posY = y;
	  traffic.intrusionLevel = intrusionLevel;
	  return traffic;
	});

	const Traffic = _ref => {
	  let {
	    mapParams,
	    mode
	  } = _ref;
	  const airTraffic = useAirTraffic(mapParams, mode);
	  const [debug] = usePersistentProperty('TCAS_DEBUG', '0');
	  const [sensitivity] = useSimVar('L:A32NX_TCAS_SENSITIVITY', 'number', 200);
	  const x = 361.5;
	  const y = mode === Mode.ARC ? 606.5 : 368;

	  if (debug !== '0') {
	    const dmodRa = mapParams.nmToPx * TCAS_CONST.DMOD[sensitivity || 1][TaRaIndex.RA];
	    const dmodTa = mapParams.nmToPx * TCAS_CONST.DMOD[sensitivity || 1][TaRaIndex.TA];
	    return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	      x: x,
	      y: y,
	      children: [dmodTa >= 0 && /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 22.5, 16 m -".concat(dmodTa, ", 0 a ").concat(dmodTa, ",").concat(dmodTa, " 0 1,0 ").concat(dmodTa * 2, ",0 a ").concat(dmodTa, ",").concat(dmodTa, " 0 1,0 -").concat(dmodTa * 2, ",0"),
	        strokeWidth: 2,
	        className: "Amber",
	        strokeDasharray: "5 2.5"
	      }), dmodRa >= 0 && /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 22.5, 16 m -".concat(dmodRa, ", 0 a ").concat(dmodRa, ",").concat(dmodRa, " 0 1,0 ").concat(dmodRa * 2, ",0 a ").concat(dmodRa, ",").concat(dmodRa, " 0 1,0 -").concat(dmodRa * 2, ",0"),
	        strokeWidth: 2,
	        className: "Red",
	        strokeDasharray: "6 3"
	      }), /*#__PURE__*/jsxRuntime.jsxs("text", {
	        x: 290,
	        y: -200,
	        fill: "#ffffff",
	        fontSize: "12px",
	        height: 1.25,
	        strokeWidth: 0.3,
	        textAnchor: "middle",
	        xmlSpace: "preserve",
	        children: [/*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ffffff",
	          children: "SENSITIVITY: ".concat(sensitivity)
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          x: 290,
	          dy: 15,
	          fill: "#ffffff",
	          children: 'DMOD: '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#e38c56",
	          children: dmodTa.toFixed(3)
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ffffff",
	          children: ' | '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ff0000",
	          children: dmodRa.toFixed(3)
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          x: 290,
	          dy: 15,
	          fill: "#ffffff",
	          children: 'TAU THR: '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#e38c56",
	          children: TCAS_CONST.TAU[sensitivity || 1][TaRaIndex.TA]
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ffffff",
	          children: ' | '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ff0000",
	          children: TCAS_CONST.TAU[sensitivity || 1][TaRaIndex.RA]
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          x: 290,
	          dy: 15,
	          fill: "#ffffff",
	          children: 'Z THR: '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#e38c56",
	          children: TCAS_CONST.ZTHR[sensitivity || 1][TaRaIndex.TA]
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ffffff",
	          children: ' | '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ff0000",
	          children: TCAS_CONST.ZTHR[sensitivity || 1][TaRaIndex.RA]
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          x: 290,
	          dy: 15,
	          fill: "#ffffff",
	          children: 'ALIM: '
	        }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	          fill: "#ff0000",
	          children: TCAS_CONST.ALIM[sensitivity]
	        })]
	      }), airTraffic.map(tf => {
	        var _tf$raTau, _tf$taTau, _tf$vTau, _tf$closureAccel, _tf$closureRate;

	        return tf.alive ? /*#__PURE__*/jsxRuntime.jsx(TrafficIndicatorDebug, {
	          x: tf.posX,
	          y: tf.posY,
	          relativeAlt: tf.relativeAlt,
	          vertSpeed: tf.vertSpeed,
	          intrusionLevel: tf.intrusionLevel,
	          ID: tf.ID,
	          hidden: tf.hidden,
	          seen: tf.seen,
	          raTau: tf.raTau && tf.raTau < 200 ? (_tf$raTau = tf.raTau) === null || _tf$raTau === void 0 ? void 0 : _tf$raTau.toFixed(0) : undefined,
	          taTau: tf.taTau && tf.taTau < 200 ? (_tf$taTau = tf.taTau) === null || _tf$taTau === void 0 ? void 0 : _tf$taTau.toFixed(0) : undefined,
	          vTau: tf.vTau && tf.vTau < 200 ? (_tf$vTau = tf.vTau) === null || _tf$vTau === void 0 ? void 0 : _tf$vTau.toFixed(0) : undefined,
	          closureAccel: (_tf$closureAccel = tf.closureAccel) === null || _tf$closureAccel === void 0 ? void 0 : _tf$closureAccel.toFixed(1),
	          closureRate: (_tf$closureRate = tf.closureRate) === null || _tf$closureRate === void 0 ? void 0 : _tf$closureRate.toFixed(1)
	        }, tf.ID) : null;
	      })]
	    });
	  }

	  return /*#__PURE__*/jsxRuntime.jsx(Layer, {
	    x: x,
	    y: y,
	    children: airTraffic.map(tf => tf.alive ? /*#__PURE__*/jsxRuntime.jsx(TrafficIndicator, {
	      x: tf.posX,
	      y: tf.posY,
	      relativeAlt: tf.relativeAlt,
	      vertSpeed: tf.vertSpeed,
	      intrusionLevel: tf.intrusionLevel
	    }, tf.ID) : null)
	  });
	};
	const TrafficIndicator = /*#__PURE__*/react.memo(_ref2 => {
	  let {
	    x,
	    y,
	    relativeAlt,
	    vertSpeed,
	    intrusionLevel
	  } = _ref2;
	  let color = '#ffffff';

	  switch (intrusionLevel) {
	    case TaRaIntrusion.TA:
	      color = '#e38c56';
	      break;

	    case TaRaIntrusion.RA:
	      color = '#ff0000';
	      break;
	  } // Place relative altitude above/below


	  const relAltY = relativeAlt > 0 ? 7 : 43.5;
	  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
	    children: /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	      x: x,
	      y: y,
	      children: [intrusionLevel === TaRaIntrusion.TRAFFIC && /*#__PURE__*/jsxRuntime.jsx("image", {
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_NORMAL.svg"
	      }), intrusionLevel === TaRaIntrusion.PROXIMITY && /*#__PURE__*/jsxRuntime.jsx("image", {
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_PROXIMITY.svg"
	      }), intrusionLevel === TaRaIntrusion.TA && /*#__PURE__*/jsxRuntime.jsx("image", {
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_TA.svg"
	      }), intrusionLevel === TaRaIntrusion.RA && /*#__PURE__*/jsxRuntime.jsx("image", {
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_RA.svg"
	      }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	        children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	          x: 30,
	          y: relAltY,
	          fill: color,
	          height: 1.25,
	          paintOrder: "stroke",
	          stroke: "#040405",
	          strokeWidth: 1,
	          textAnchor: "end",
	          xmlSpace: "preserve",
	          children: /*#__PURE__*/jsxRuntime.jsx("tspan", {
	            x: 17.25,
	            y: relAltY,
	            fill: color,
	            fontSize: "20px",
	            paintOrder: "stroke",
	            stroke: "#040405",
	            strokeWidth: 1,
	            textAnchor: "middle",
	            children: "".concat(relativeAlt > 0 ? '+' : '-').concat(Math.abs(relativeAlt) < 10 ? '0' : '').concat(Math.abs(relativeAlt))
	          })
	        }), vertSpeed <= -500 && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	          children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            fill: "none",
	            strokeWidth: 3,
	            d: "M35,21V9.7"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            fill: "none",
	            stroke: color,
	            strokeWidth: 1.6,
	            d: "M35,21V9.7"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            fill: color,
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z"
	          })]
	        }), vertSpeed >= 500 && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	          children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            fill: "none",
	            strokeWidth: 3,
	            d: "M35,14.2v11.3"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            fill: "none",
	            stroke: color,
	            strokeWidth: 1.6,
	            d: "M35,14.2v11.3"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            fill: color,
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z"
	          })]
	        })]
	      })]
	    })
	  });
	});
	const TrafficIndicatorDebug = /*#__PURE__*/react.memo(_ref3 => {
	  let {
	    x,
	    y,
	    relativeAlt,
	    vertSpeed,
	    intrusionLevel,
	    ID,
	    hidden,
	    seen,
	    raTau,
	    taTau,
	    vTau,
	    closureRate,
	    closureAccel
	  } = _ref3;
	  let color = '#ffffff';

	  switch (intrusionLevel) {
	    case TaRaIntrusion.TA:
	      color = '#e38c56';
	      break;

	    case TaRaIntrusion.RA:
	      color = '#ff0000';
	      break;
	  } // Place relative altitude above/below


	  const relAltY = relativeAlt > 0 ? 7 : 43.5;
	  const debugY1 = relativeAlt > 0 ? 38 : -1;
	  const debugY2 = relativeAlt > 0 ? 50 : -13;
	  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
	    children: /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	      x: x,
	      y: y,
	      children: [intrusionLevel === TaRaIntrusion.TRAFFIC && /*#__PURE__*/jsxRuntime.jsx("image", {
	        opacity: hidden ? 0.125 : 1.0,
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_NORMAL.svg"
	      }), intrusionLevel === TaRaIntrusion.PROXIMITY && /*#__PURE__*/jsxRuntime.jsx("image", {
	        opacity: hidden ? 0.125 : 1.0,
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_PROXIMITY.svg"
	      }), intrusionLevel === TaRaIntrusion.TA && /*#__PURE__*/jsxRuntime.jsx("image", {
	        opacity: hidden ? 0.125 : 1.0,
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_TA.svg"
	      }), intrusionLevel === TaRaIntrusion.RA && /*#__PURE__*/jsxRuntime.jsx("image", {
	        opacity: hidden ? 0.125 : 1.0,
	        x: 0,
	        y: 0,
	        width: 45,
	        height: 32,
	        xlinkHref: "/Images/ND/TRAFFIC_RA.svg"
	      }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	        children: [/*#__PURE__*/jsxRuntime.jsxs("text", {
	          x: 30,
	          y: relAltY,
	          fillOpacity: hidden ? 0.125 : 1,
	          fill: color,
	          height: 1.25,
	          strokeWidth: 0.3,
	          textAnchor: "end",
	          xmlSpace: "preserve",
	          children: [/*#__PURE__*/jsxRuntime.jsx("tspan", {
	            x: 17.25,
	            y: relAltY,
	            fill: color,
	            fontSize: "20px",
	            strokeWidth: 0.3,
	            textAnchor: "middle",
	            children: "".concat(relativeAlt > 0 ? '+' : '-').concat(Math.abs(relativeAlt) < 10 ? '0' : '').concat(Math.abs(relativeAlt))
	          }), !hidden && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	            children: [/*#__PURE__*/jsxRuntime.jsx("tspan", {
	              x: 17.25,
	              y: debugY1,
	              fillOpacity: 0.6,
	              fill: color,
	              fontSize: "8px",
	              strokeWidth: 0.2,
	              textAnchor: "middle",
	              children: "".concat(ID, " [").concat(closureRate, "|").concat(closureAccel, "] <").concat(seen, ">")
	            }), /*#__PURE__*/jsxRuntime.jsx("tspan", {
	              x: 17.25,
	              y: debugY2,
	              fill: color,
	              fontSize: "12px",
	              strokeWidth: 0.2,
	              textAnchor: "middle",
	              children: "R ".concat(raTau || '-', " V ").concat(vTau || '-', " T ").concat(taTau || '-')
	            })]
	          })]
	        }), vertSpeed <= -500 && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	          children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            fill: "none",
	            strokeWidth: 3,
	            d: "M35,21V9.7"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            opacity: hidden ? 0.125 : 1,
	            fill: "none",
	            stroke: color,
	            strokeWidth: 1.6,
	            d: "M35,21V9.7"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            opacity: hidden ? 0.125 : 1,
	            fill: color,
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z"
	          })]
	        }), vertSpeed >= 500 && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	          children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            fill: "none",
	            strokeWidth: 3,
	            d: "M35,14.2v11.3"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            className: "shadow",
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            opacity: hidden ? 0.125 : 1,
	            fill: "none",
	            stroke: color,
	            strokeWidth: 1.6,
	            d: "M35,14.2v11.3"
	          }), /*#__PURE__*/jsxRuntime.jsx("path", {
	            opacity: hidden ? 0.125 : 1,
	            fill: color,
	            stroke: "none",
	            fillRule: "evenodd",
	            d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z"
	          })]
	        })]
	      })]
	    })
	  });
	});

	const getSimBridgeUrl = () => "http://localhost:".concat(NXDataStore.get('CONFIG_SIMBRIDGE_PORT', '8380'));

	class Terrain {
	  static async mapdataAvailable() {
	    return fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/available")).then(response => {
	      Terrain.endpointsAvailable = response.ok;
	      return response.ok;
	    }).catch(_ex => {
	      Terrain.endpointsAvailable = false;
	      return false;
	    });
	  }

	  static async setCurrentPosition(latitude, longitude, heading, altitude, verticalSpeed) {
	    if (Terrain.endpointsAvailable) {
	      fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/position"), {
	        method: 'PATCH',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify({
	          latitude,
	          longitude,
	          heading,
	          altitude,
	          verticalSpeed
	        })
	      });
	    } else {
	      throw new Error('Endpoints unavailable');
	    }
	  }

	  static async setDisplaySettings(side, settings) {
	    if (Terrain.endpointsAvailable) {
	      fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/displaysettings?display=").concat(side), {
	        method: 'PUT',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify(settings)
	      });
	    } else {
	      throw new Error('Endpoints unavailable');
	    }
	  }

	  static async ndMapAvailable(side, timestamp) {
	    if (Terrain.endpointsAvailable) {
	      return fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/ndMapAvailable?display=").concat(side, "&timestamp=").concat(timestamp)).then(response => {
	        if (response.ok) {
	          return response.text().then(text => text === 'true');
	        }

	        return false;
	      });
	    }

	    throw new Error('Endpoints unavailable');
	  }

	  static async ndTransitionMaps(side, timestamp) {
	    if (Terrain.endpointsAvailable) {
	      return fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/ndmaps?display=").concat(side, "&timestamp=").concat(timestamp), {
	        method: 'GET',
	        headers: {
	          Accept: 'application/json'
	        }
	      }).then(response => response.json().then(imageBase64 => imageBase64));
	    }

	    throw new Error('Endpoints unavailable');
	  }

	  static async ndTerrainRange(side, timestamp) {
	    if (Terrain.endpointsAvailable) {
	      return fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/terrainRange?display=").concat(side, "&timestamp=").concat(timestamp), {
	        method: 'GET',
	        headers: {
	          Accept: 'application/json'
	        }
	      }).then(response => response.json().then(data => data));
	    }

	    throw new Error('Endpoints unavailable');
	  }

	  static async renderNdMap(side) {
	    if (Terrain.endpointsAvailable) {
	      return fetch("".concat(getSimBridgeUrl(), "/api/v1/terrain/renderMap?display=").concat(side)).then(response => response.text().then(text => parseInt(text)));
	    }

	    throw new Error('Endpoints unavailable');
	  }

	}

	_defineProperty(Terrain, "endpointsAvailable", false);

	const MAP_TRANSITION_FRAMERATE = 15;
	const MAP_TRANSITION_DURATION = 1.5;
	const RERENDER_TIMEOUT = 500;
	const METRES_TO_NAUTICAL_MILES = 1852;
	const TerrainMapProvider = _ref => {
	  let {
	    side
	  } = _ref;
	  const arincLat = useArinc429Var('L:A32NX_ADIRS_IR_1_LATITUDE', 1000);
	  const arincLong = useArinc429Var('L:A32NX_ADIRS_IR_1_LONGITUDE', 1000);
	  const [verticalSpeed] = useSimVar('VERTICAL SPEED', 'feet per second', 1000);
	  const [trueHeading] = useSimVar('PLANE HEADING DEGREES TRUE', 'degrees', 1000);
	  const [altitude] = useSimVar('PLANE ALTITUDE', 'feet', 1000);
	  const [timer, setTimer] = react.useState(500);
	  useUpdate(deltaTime => {
	    if (timer !== undefined) {
	      if (timer > 0) {
	        setTimer(Math.max(timer - deltaTime, 0));
	      } else if (arincLat.isNormalOperation() && arincLong.isNormalOperation()) {
	        setTimer(undefined);
	        Terrain.mapdataAvailable().then(available => {
	          if (available === true && side === 'L') {
	            Terrain.setCurrentPosition(arincLat.value, arincLong.value, trueHeading, Math.round(altitude), Math.round(verticalSpeed * 60.0)).catch(_ex => {});
	          }

	          setTimer(500);
	        }).catch(e => {
	          console.error(e);
	        });
	      }
	    }
	  });
	  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
	};

	const TerrainMapTransition = _ref2 => {
	  let {
	    x,
	    y,
	    width,
	    height,
	    mapdata,
	    onFinished
	  } = _ref2;
	  const frameBuffer = [react.useState({
	    opacity: 0.01,
	    index: 0
	  }), react.useState({
	    opacity: 0.01,
	    index: 0
	  }), react.useState({
	    opacity: 0.01,
	    index: 0
	  })];
	  const [frameTimer, setFrameTimer] = react.useState(undefined);
	  const [currentFrame, setCurrentFrame] = react.useState(0);
	  const frameTimerRef = react.useRef();
	  const currentFrameRef = react.useRef();
	  currentFrameRef.current = currentFrame;
	  frameTimerRef.current = frameTimer;

	  if (frameTimerRef.current === undefined) {
	    setFrameTimer(setInterval(() => {
	      if (currentFrameRef.current !== undefined && frameTimerRef.current !== undefined) {
	        if (currentFrameRef.current >= mapdata.length - 1) {
	          clearInterval(frameTimerRef.current);
	          onFinished();
	        } else {
	          for (let i = 0; i < frameBuffer.length; ++i) {
	            frameBuffer[(currentFrameRef.current + i) % frameBuffer.length][1]({
	              opacity: i === 0 ? 1 : 0.01,
	              index: currentFrameRef.current + i
	            });
	          }

	          setCurrentFrame(currentFrameRef.current + 1);
	        }
	      }
	    }, Math.round(1000 / MAP_TRANSITION_FRAMERATE)));
	  }

	  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
	    children: frameBuffer.map(frame => frame[0].index < mapdata.length && mapdata[frame[0].index] !== undefined ? /*#__PURE__*/jsxRuntime.jsx("image", {
	      x: x,
	      y: y,
	      width: width,
	      height: height,
	      opacity: frame[0].opacity,
	      xlinkHref: "data:image/png;base64,".concat(mapdata[frame[0].index])
	    }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {}))
	  });
	};

	class MapVisualizationData {
	  constructor() {
	    _defineProperty(this, "TerrainMapBuffer", [{
	      opacity: 0.01,
	      data: ''
	    }, {
	      opacity: 0.01,
	      data: ''
	    }]);

	    _defineProperty(this, "MapTransitionData", []);

	    _defineProperty(this, "RerenderTimeout", undefined);

	    _defineProperty(this, "NextMinimumElevation", {
	      altitude: Infinity,
	      color: 'rgb(0, 0, 0)'
	    });

	    _defineProperty(this, "NextMaximumElevation", {
	      altitude: Infinity,
	      color: 'rgb(0, 0, 0)'
	    });

	    _defineProperty(this, "MinimumElevation", {
	      altitude: Infinity,
	      color: 'rgb(0, 0, 0)'
	    });

	    _defineProperty(this, "MaximumElevation", {
	      altitude: Infinity,
	      color: 'rgb(0, 0, 0)'
	    });

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    if (args.length !== 0 && args[0] instanceof MapVisualizationData) {
	      this.TerrainMapBuffer = args[0].TerrainMapBuffer;
	      this.MapTransitionData = args[0].MapTransitionData;
	      this.RerenderTimeout = args[0].RerenderTimeout;
	      this.NextMinimumElevation = args[0].NextMinimumElevation;
	      this.NextMaximumElevation = args[0].NextMaximumElevation;
	      this.MinimumElevation = args[0].MinimumElevation;
	      this.MaximumElevation = args[0].MaximumElevation;
	    }
	  }

	}

	const TerrainMap = _ref3 => {
	  let {
	    potentiometerIndex,
	    x,
	    y,
	    width,
	    height,
	    side,
	    clipName
	  } = _ref3;
	  const [mapVisualization, setMapVisualization] = react.useState(new MapVisualizationData());
	  const [potentiometer] = useSimVar("LIGHT POTENTIOMETER:".concat(potentiometerIndex), 'percent over 100', 200);
	  const [terrOnNdActive] = useSimVar("L:A32NX_EFIS_TERR_".concat(side, "_ACTIVE"), 'boolean', 100);
	  const [rangeIndex] = useSimVar("L:A32NX_EFIS_".concat(side, "_ND_RANGE"), 'number', 100);
	  const [modeIndex] = useSimVar("L:A32NX_EFIS_".concat(side, "_ND_MODE"), 'number', 100);
	  const [gearMode] = useSimVar('GEAR POSITION:0', 'Enum', 100);
	  const mapVisualizationRef = react.useRef();
	  mapVisualizationRef.current = mapVisualization;

	  const syncWithRenderer = timestamp => {
	    // wait until the rendering is done
	    setTimeout(() => {
	      Terrain.ndMapAvailable(side, timestamp).then(available => {
	        if (!available) {
	          if (terrOnNdActive) {
	            syncWithRenderer(timestamp);
	          }
	        } else {
	          Terrain.ndTransitionMaps(side, timestamp).then(imagesBase64 => {
	            Terrain.ndTerrainRange(side, timestamp).then(data => {
	              if ('minElevation' in data && data.minElevation !== Infinity && 'maxElevation' in data && data.maxElevation !== Infinity) {
	                let minimumColor = 'rgb(0, 255, 0)';

	                if (data.minElevationIsWarning) {
	                  minimumColor = 'rgb(255, 255, 0)';
	                } else if (data.minElevationIsCaution) {
	                  minimumColor = 'rgb(255, 0, 0)';
	                }

	                let maximumColor = 'rgb(0, 255, 0)';

	                if (data.maxElevationIsWarning) {
	                  maximumColor = 'rgb(255, 255, 0)';
	                } else if (data.maxElevationIsCaution) {
	                  maximumColor = 'rgb(255, 0, 0)';
	                }

	                if (mapVisualizationRef.current) {
	                  mapVisualizationRef.current.NextMinimumElevation = {
	                    altitude: data.minElevation,
	                    color: minimumColor
	                  };
	                  mapVisualizationRef.current.NextMaximumElevation = {
	                    altitude: data.maxElevation,
	                    color: maximumColor
	                  };
	                }
	              } else if (mapVisualizationRef.current) {
	                mapVisualizationRef.current.NextMinimumElevation = {
	                  altitude: Infinity,
	                  color: 'rgb(0, 0, 0)'
	                };
	                mapVisualizationRef.current.NextMaximumElevation = {
	                  altitude: Infinity,
	                  color: 'rgb(0, 0, 0)'
	                };
	              }

	              const newVisualization = new MapVisualizationData(mapVisualizationRef.current);
	              newVisualization.MapTransitionData = imagesBase64;

	              if (newVisualization.TerrainMapBuffer[0].opacity === 0.01) {
	                newVisualization.TerrainMapBuffer[0].data = imagesBase64[imagesBase64.length - 1];
	              } else {
	                newVisualization.TerrainMapBuffer[1].data = imagesBase64[imagesBase64.length - 1];
	              }

	              setMapVisualization(newVisualization);
	            }).catch(_ex => setMapVisualization(new MapVisualizationData()));
	          }).catch(_ex => setMapVisualization(new MapVisualizationData()));
	        }
	      }).catch(_ex => setMapVisualization(new MapVisualizationData()));
	    }, 200);
	  };

	  const mapTransitionDone = () => {
	    const rerenderVisualization = new MapVisualizationData(mapVisualizationRef.current);

	    if (rerenderVisualization.TerrainMapBuffer[0].opacity === 0.01) {
	      rerenderVisualization.TerrainMapBuffer[0].opacity = 1;
	      rerenderVisualization.TerrainMapBuffer[1].opacity = 0.01;
	    } else {
	      rerenderVisualization.TerrainMapBuffer[0].opacity = 0.01;
	      rerenderVisualization.TerrainMapBuffer[1].opacity = 1;
	    }

	    rerenderVisualization.MapTransitionData = [];
	    rerenderVisualization.MinimumElevation = rerenderVisualization.NextMinimumElevation;
	    rerenderVisualization.MaximumElevation = rerenderVisualization.NextMaximumElevation;
	    rerenderVisualization.RerenderTimeout = RERENDER_TIMEOUT;
	    setMapVisualization(rerenderVisualization);
	  };

	  useUpdate(deltaTime => {
	    var _mapVisualizationRef$;

	    if (terrOnNdActive && ((_mapVisualizationRef$ = mapVisualizationRef.current) === null || _mapVisualizationRef$ === void 0 ? void 0 : _mapVisualizationRef$.RerenderTimeout) !== undefined) {
	      if (mapVisualizationRef.current.RerenderTimeout <= 0) {
	        const newVisualizationData = new MapVisualizationData(mapVisualizationRef.current);
	        newVisualizationData.RerenderTimeout = undefined;
	        setMapVisualization(newVisualizationData);
	        Terrain.renderNdMap(side).then(timestamp => {
	          if (timestamp > 0) {
	            syncWithRenderer(timestamp);
	          } else {
	            // clear all data
	            setMapVisualization(new MapVisualizationData());
	          }
	        }).catch(_ex => setMapVisualization(new MapVisualizationData()));
	      } else {
	        const newVisualizationData = new MapVisualizationData(mapVisualizationRef.current);

	        if (newVisualizationData.RerenderTimeout !== undefined) {
	          newVisualizationData.RerenderTimeout -= deltaTime;
	        }

	        setMapVisualization(newVisualizationData);
	      }
	    } else if (!terrOnNdActive) {
	      setMapVisualization(new MapVisualizationData(mapVisualizationRef.current));
	    }
	  });
	  react.useEffect(() => {
	    var _mapVisualizationRef$2;

	    if (!terrOnNdActive) {
	      setMapVisualization(new MapVisualizationData());
	    } else if (((_mapVisualizationRef$2 = mapVisualizationRef.current) === null || _mapVisualizationRef$2 === void 0 ? void 0 : _mapVisualizationRef$2.RerenderTimeout) === undefined) {
	      const newVisualizationData = new MapVisualizationData(mapVisualizationRef.current);
	      newVisualizationData.RerenderTimeout = RERENDER_TIMEOUT;
	      setMapVisualization(newVisualizationData);
	    }

	    const meterPerPixel = Math.round(rangeSettings[rangeIndex] * METRES_TO_NAUTICAL_MILES / height);
	    const displayConfiguration = {
	      active: modeIndex !== Mode.PLAN && terrOnNdActive !== 0,
	      mapWidth: width,
	      mapHeight: height,
	      meterPerPixel: meterPerPixel + (10 - meterPerPixel % 10),
	      mapTransitionTime: MAP_TRANSITION_DURATION,
	      mapTransitionFps: MAP_TRANSITION_FRAMERATE,
	      arcMode: modeIndex === Mode.ARC,
	      gearDown: SimVar.GetSimVarValue('GEAR POSITION:0', 'Enum') !== 1
	    };
	    Terrain.setDisplaySettings(side, displayConfiguration).catch(_ex => setMapVisualization(new MapVisualizationData()));
	  }, [terrOnNdActive, rangeIndex, modeIndex, gearMode]);

	  if (!terrOnNdActive || modeIndex === Mode.PLAN) {
	    return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
	  }

	  let lowerBorder = '';

	  if (Number.isFinite(mapVisualizationRef.current.MinimumElevation.altitude) && mapVisualizationRef.current.MinimumElevation.altitude >= 0) {
	    lowerBorder = String(Math.floor(mapVisualizationRef.current.MinimumElevation.altitude / 100)).padStart(3, '0');
	  }

	  let upperBorder = '';

	  if (Number.isFinite(mapVisualizationRef.current.MaximumElevation.altitude)) {
	    if (mapVisualizationRef.current.MaximumElevation.altitude !== 0) {
	      upperBorder = String(Math.round(mapVisualizationRef.current.MaximumElevation.altitude / 100 + 0.5)).padStart(3, '0');
	    } else {
	      upperBorder = '000';
	    }
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
	      id: "map",
	      clipPath: "url(#".concat(clipName, ")"),
	      opacity: potentiometer,
	      children: [mapVisualization.TerrainMapBuffer.map(frame => frame.data !== '' ? /*#__PURE__*/jsxRuntime.jsx("image", {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        opacity: frame.opacity,
	        xlinkHref: "data:image/png;base64,".concat(frame.data)
	      }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {})), mapVisualization.MapTransitionData.length !== 0 ? /*#__PURE__*/jsxRuntime.jsx(TerrainMapTransition, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        mapdata: mapVisualization.MapTransitionData,
	        onFinished: mapTransitionDone
	      }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {})]
	    }), upperBorder !== '' ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 688,
	        y: 612,
	        fontSize: 23,
	        fill: "rgb(0,255,255)",
	        children: "TERR"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 709,
	        y: 639,
	        fontSize: 22,
	        fill: mapVisualizationRef.current.MaximumElevation.color,
	        children: upperBorder
	      }), /*#__PURE__*/jsxRuntime.jsx("rect", {
	        x: 700,
	        y: 619,
	        width: 54,
	        height: 24,
	        strokeWidth: 3,
	        stroke: "rgb(255,255,0)",
	        fillOpacity: 0
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 709,
	        y: 663,
	        fontSize: 23,
	        fill: mapVisualizationRef.current.MinimumElevation.color,
	        children: lowerBorder
	      }), /*#__PURE__*/jsxRuntime.jsx("rect", {
	        x: 700,
	        y: 643,
	        width: 54,
	        height: 24,
	        strokeWidth: 3,
	        stroke: "rgb(255,255,0)",
	        fillOpacity: 0
	      })]
	    }) : /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {})]
	  });
	};

	const ArcMode = _ref => {
	  let {
	    symbols,
	    adirsAlign,
	    rangeSetting,
	    side,
	    ppos,
	    mapHidden
	  } = _ref;
	  const [magHeading] = useSimVar('PLANE HEADING DEGREES MAGNETIC', 'degrees');
	  const [magTrack] = useSimVar('GPS GROUND MAGNETIC TRACK', 'degrees');
	  const [trueHeading] = useSimVar('PLANE HEADING DEGREES TRUE', 'degrees');
	  const [tcasMode] = useSimVar('L:A32NX_SWITCH_TCAS_Position', 'number');
	  const [selectedHeading] = useSimVar('L:A32NX_AUTOPILOT_HEADING_SELECTED', 'degrees');
	  const [lsCourse] = useSimVar('L:A32NX_FM_LS_COURSE', 'number');
	  const [lsDisplayed] = useSimVar("L:BTN_LS_".concat(side === 'L' ? 1 : 2, "_FILTER_ACTIVE"), 'bool'); // TODO rename simvar

	  const [fmaLatMode] = useSimVar('L:A32NX_FMA_LATERAL_MODE', 'enum', 200);
	  const [armedLateralBitmask] = useSimVar('L:A32NX_FMA_LATERAL_ARMED', 'enum', 200);
	  const [groundSpeed] = useSimVar('GPS GROUND SPEED', 'Meters per second', 200);
	  const heading = Number(MathUtils.fastToFixed(magHeading, 2));
	  let track = Number(MathUtils.fastToFixed(magTrack, 2)); // Workaround for bug with gps ground track simvar

	  if (groundSpeed < 40) {
	    track = (0.025 * groundSpeed + 0.00005) * track + (1 - (0.025 * groundSpeed + 0.00005)) * heading;
	    track = Number(MathUtils.fastToFixed(track, 2));
	  }

	  const [mapParams] = react.useState(() => {
	    const params = new MapParameters();
	    params.compute(ppos, rangeSetting, 492, trueHeading);
	    return params;
	  });
	  react.useEffect(() => {
	    mapParams.compute(ppos, rangeSetting, 492, trueHeading);
	  }, [ppos.lat, ppos.long, trueHeading, rangeSetting].map(n => MathUtils.fastToFixed(n, 6)));

	  if (adirsAlign) {
	    return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx(TerrainMap, {
	        x: -108,
	        y: 128,
	        width: 984,
	        height: 492,
	        side: side,
	        potentiometerIndex: side === 'L' ? 94 : 95,
	        clipName: "arc-mode-map-clip"
	      }), /*#__PURE__*/jsxRuntime.jsx(Overlay$2, {
	        heading: heading,
	        rangeSetting: rangeSetting,
	        tcasMode: tcasMode
	      }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	        id: "map",
	        clipPath: "url(#arc-mode-map-clip)",
	        children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
	          visibility: mapHidden ? 'hidden' : 'visible',
	          children: [/*#__PURE__*/jsxRuntime.jsx(FlightPlan, {
	            x: 384,
	            y: 620,
	            side: side,
	            range: rangeSetting,
	            symbols: symbols,
	            mapParams: mapParams,
	            mapParamsVersion: mapParams.version,
	            debug: false
	          }), (fmaLatMode === LateralMode.NONE || fmaLatMode === LateralMode.HDG || fmaLatMode === LateralMode.TRACK) && !isArmed(armedLateralBitmask, ArmedLateralMode.NAV) && /*#__PURE__*/jsxRuntime.jsx(TrackLine, {
	            x: 384,
	            y: 620,
	            heading: heading,
	            track: track,
	            groundSpeed: Number(MathUtils.fastToFixed(groundSpeed, 2)),
	            mapParams: mapParams,
	            symbols: symbols,
	            ndRange: rangeSetting
	          })]
	        }), /*#__PURE__*/jsxRuntime.jsx(RadioNeedle, {
	          index: 1,
	          side: side,
	          displayMode: Mode.ARC,
	          centreHeight: 620
	        }), /*#__PURE__*/jsxRuntime.jsx(RadioNeedle, {
	          index: 2,
	          side: side,
	          displayMode: Mode.ARC,
	          centreHeight: 620
	        })]
	      }), /*#__PURE__*/jsxRuntime.jsx(ToWaypointIndicator, {
	        side: side
	      }), /*#__PURE__*/jsxRuntime.jsx(ApproachMessage, {
	        side: side
	      }), /*#__PURE__*/jsxRuntime.jsx(TrackBug$1, {
	        heading: heading,
	        track: track
	      }), lsDisplayed && /*#__PURE__*/jsxRuntime.jsx(LsCourseBug$1, {
	        heading: heading,
	        lsCourse: lsCourse
	      }), /*#__PURE__*/jsxRuntime.jsx(SelectedHeadingBug$1, {
	        heading: heading,
	        selected: selectedHeading
	      }), /*#__PURE__*/jsxRuntime.jsx(Plane$2, {}), /*#__PURE__*/jsxRuntime.jsx(CrossTrack, {
	        x: 390,
	        y: 646,
	        side: side
	      }), /*#__PURE__*/jsxRuntime.jsx("g", {
	        clipPath: "url(#arc-mode-tcas-clip)",
	        children: /*#__PURE__*/jsxRuntime.jsx(Traffic, {
	          mode: Mode.ARC,
	          mapParams: mapParams
	        })
	      })]
	    });
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx(MapFailOverlay$1, {
	      rangeSetting: rangeSetting
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 681,
	      y: 28,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: "PPOS"
	    })]
	  });
	};
	const Overlay$2 = /*#__PURE__*/react.memo(_ref2 => {
	  let {
	    heading,
	    rangeSetting,
	    tcasMode
	  } = _ref2;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx(ArcModeOverlayDefs, {}), /*#__PURE__*/jsxRuntime.jsxs("g", {
	      transform: "rotateX(0deg)",
	      stroke: "white",
	      strokeWidth: 2,
	      fill: "none",
	      children: [/*#__PURE__*/jsxRuntime.jsx("g", {
	        clipPath: "url(#arc-mode-overlay-clip-4)",
	        children: /*#__PURE__*/jsxRuntime.jsx("g", {
	          transform: "rotate(".concat(MathUtils.diffAngle(heading, 60), " 384 620)"),
	          children: /*#__PURE__*/jsxRuntime.jsx(ArcModeOverlayHeadingRing, {})
	        })
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M15,620a369,369 0 1,0 738,0a369,369 0 1,0 -738,0",
	        strokeDasharray: "15 10.5",
	        strokeDashoffset: "15",
	        clipPath: "url(#arc-mode-overlay-clip-3)"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 58,
	        y: 482,
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 4 * 3
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 709,
	        y: 482,
	        textAnchor: "end",
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 4 * 3
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M138,620a246,246 0 1,0 492,0a246,246 0 1,0 -492,00",
	        strokeDasharray: "15 10",
	        strokeDashoffset: "-6",
	        clipPath: "url(#arc-mode-overlay-clip-2)"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 175,
	        y: 528,
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 2
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 592,
	        y: 528,
	        textAnchor: "end",
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 2
	      }), (tcasMode === 0 || rangeSetting > 10) && /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M261,620a123,123 0 1,0 246,0a123,123 0 1,0 -246,00",
	        strokeDasharray: "15 10",
	        strokeDashoffset: "-4.2",
	        clipPath: "url(#arc-mode-overlay-clip-1)"
	      }), tcasMode > 0 && rangeSetting === 10 && /*#__PURE__*/jsxRuntime.jsxs("g", {
	        children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 497 - 6,
	          y2: 497 + 6,
	          className: "rounded White",
	          transform: "rotate(-60 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 497 - 6,
	          y2: 497 + 6,
	          className: "rounded White",
	          transform: "rotate(-30 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 497 - 6,
	          y2: 497 + 6,
	          className: "rounded White",
	          transform: "rotate(0 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 497 - 6,
	          y2: 497 + 6,
	          className: "rounded White",
	          transform: "rotate(30 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 497 - 6,
	          y2: 497 + 6,
	          className: "rounded White",
	          transform: "rotate(60 384 620)"
	        })]
	      }), tcasMode > 0 && rangeSetting === 20 && /*#__PURE__*/jsxRuntime.jsxs("g", {
	        children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 558 - 6,
	          y2: 558 + 6,
	          className: "rounded White",
	          transform: "rotate(-60 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 558 - 6,
	          y2: 558 + 6,
	          className: "rounded White",
	          transform: "rotate(-30 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 558 - 6,
	          y2: 558 + 6,
	          className: "rounded White",
	          transform: "rotate(0 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 558 - 6,
	          y2: 558 + 6,
	          className: "rounded White",
	          transform: "rotate(30 384 620)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 558 - 6,
	          y2: 558 + 6,
	          className: "rounded White",
	          transform: "rotate(60 384 620)"
	        })]
	      })]
	    })]
	  });
	});
	const ArcModeOverlayDefs = /*#__PURE__*/react.memo(() => /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	  children: [/*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-map-clip",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M0,312 a492,492 0 0 1 768,0 L768,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L0,625 L0,312"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-wx-terr-clip",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M0,312 a492,492 0 0 1 768,0 L768,562 L648,562 L591,625 L0,625 L0,312"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-tcas-clip",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M0,312 a492,492 0 0 1 768,0 L768,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L0,625 L0,312"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-overlay-clip-4",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "m 6 0 h 756 v 768 h -756 z"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-overlay-clip-3",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "m 0 564 l 384 145 l 384 -145 v -564 h -768 z"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-overlay-clip-2",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "m 0 532 l 384 155 l 384 -146 v -512 h -768 z"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "arc-mode-overlay-clip-1",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "m 0 519 l 384 145 l 384 -86 v -580 h -768 z"
	    })
	  })]
	}));
	const ArcModeOverlayHeadingRing = /*#__PURE__*/react.memo(() => /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	  children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	    d: "M-108,620a492,492 0 1,0 984,0a492,492 0 1,0 -984,0",
	    strokeWidth: 2
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(-60 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "0"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(-55 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(-50 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "1"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(-45 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(-40 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "2"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(-35 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(-30 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "3"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(-25 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(-20 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "4"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(-15 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(-10 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "5"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(-5 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(0 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "6"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(5 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(10 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 95,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "7"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(15 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(20 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 95,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "8"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(25 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(30 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "9"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(35 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(40 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "10"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(45 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(50 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "11"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(55 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(60 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "12"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(65 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(70 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "13"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(75 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(80 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "14"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(85 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(90 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "15"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(95 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(100 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "16"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(105 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(110 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "17"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(115 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(120 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "18"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(125 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(130 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "19"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(135 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(140 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "20"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(145 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(150 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "21"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(155 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(160 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "22"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(165 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(170 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "23"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(175 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(180 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "24"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(185 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(190 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "25"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(195 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(200 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "26"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(205 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(210 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "27"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(215 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(220 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "28"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(225 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(230 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "29"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(235 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(240 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "30"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(245 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(250 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "31"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(255 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(260 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "32"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(265 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(270 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 34,
	      fill: "white",
	      stroke: "none",
	      children: "33"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(275 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(280 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "34"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(285 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(290 384 620)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 99,
	      strokeWidth: 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 91,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "35"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(295 384 620)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 128,
	      x2: 384,
	      y2: 113,
	      strokeWidth: 2
	    })
	  })]
	}));
	const MapFailOverlay$1 = /*#__PURE__*/react.memo(_ref3 => {
	  let {
	    rangeSetting
	  } = _ref3;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	        className: "Red",
	        fontSize: 30,
	        textAnchor: "middle",
	        x: 384,
	        y: 241,
	        children: "HDG"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        className: "Red",
	        fontSize: 30,
	        textAnchor: "middle",
	        x: 384,
	        y: 320.6,
	        children: "MAP NOT AVAIL"
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "arc-mode-map-clip",
	      children: /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M-384,-308 a492,492 0 0 1 768,0 L384,-58 L264,-58 L207,5 L207,148 L-210,148 L-210,63 L-262,5 L-384,5 L-384,-308"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "arc-mode-overlay-clip-4",
	      children: /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "m 6 0 h 756 v 768 h -756 z"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "arc-mode-overlay-clip-3",
	      children: /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "m 0 564 l 384 145 l 384 -145 v -564 h -768 z"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "arc-mode-overlay-clip-2",
	      children: /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "m 0 532 l 384 155 l 384 -146 v -512 h -768 z"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "arc-mode-overlay-clip-1",
	      children: /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "m 0 519 l 384 145 l 384 -86 v -580 h -768 z"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	      stroke: "white",
	      strokeWidth: 3,
	      fill: "none",
	      children: [/*#__PURE__*/jsxRuntime.jsx("g", {
	        clipPath: "url(#arc-mode-overlay-clip-4)",
	        children: /*#__PURE__*/jsxRuntime.jsx("g", {
	          children: /*#__PURE__*/jsxRuntime.jsx("path", {
	            d: "M-108,620a492,492 0 1,0 984,0a492,492 0 1,0 -984,0",
	            strokeWidth: 3.25,
	            stroke: "red"
	          })
	        })
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M15,620a369,369 0 1,0 738,0a369,369 0 1,0 -738,0",
	        strokeDasharray: "15 10.5",
	        strokeDashoffset: "15",
	        clipPath: "url(#arc-mode-overlay-clip-3)",
	        stroke: "red"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 58,
	        y: 482,
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 4 * 3
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 709,
	        y: 482,
	        textAnchor: "end",
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 4 * 3
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M138,620a246,246 0 1,0 492,0a246,246 0 1,0 -492,00",
	        strokeDasharray: "15 10",
	        strokeDashoffset: "-6",
	        clipPath: "url(#arc-mode-overlay-clip-2)",
	        stroke: "red"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 168,
	        y: 528,
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 2
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 592,
	        y: 528,
	        textAnchor: "end",
	        fill: "#00ffff",
	        stroke: "none",
	        fontSize: 22,
	        children: rangeSetting / 2
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M261,620a123,123 0 1,0 246,0a123,123 0 1,0 -246,00",
	        strokeDasharray: "15 10",
	        strokeDashoffset: "-4.2",
	        clipPath: "url(#arc-mode-overlay-clip-1)",
	        stroke: "red"
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("clipPath", {
	        id: "mask",
	        children: /*#__PURE__*/jsxRuntime.jsx("rect", {
	          x: 372,
	          y: 615,
	          width: 24,
	          height: 20
	        })
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 384,
	        cy: 634,
	        r: 10,
	        fill: "none",
	        stroke: "red",
	        strokeWidth: 3.25,
	        clipPath: "url(#mask)"
	      })]
	    })]
	  });
	});
	const Plane$2 = /*#__PURE__*/react.memo(() => /*#__PURE__*/jsxRuntime.jsxs("g", {
	  children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	    id: "lubber-shadow",
	    x1: 384,
	    y1: 108,
	    x2: 384,
	    y2: 148,
	    className: "shadow",
	    strokeWidth: 5.5,
	    strokeLinejoin: "round",
	    strokeLinecap: "round"
	  }), /*#__PURE__*/jsxRuntime.jsx("line", {
	    id: "lubber",
	    x1: 384,
	    y1: 108,
	    x2: 384,
	    y2: 148,
	    className: "Yellow",
	    strokeWidth: 5,
	    strokeLinejoin: "round",
	    strokeLinecap: "round"
	  }), /*#__PURE__*/jsxRuntime.jsx("image", {
	    x: 342,
	    y: 596,
	    width: 84,
	    height: 71,
	    xlinkHref: "/Images/ND/AIRPLANE.svg"
	  })]
	}));
	const TrackBug$1 = /*#__PURE__*/react.memo(_ref4 => {
	  let {
	    heading,
	    track
	  } = _ref4;
	  const diff = getSmallestAngle(track, heading);

	  if (diff > 48) {
	    return null;
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,128 L378,138 L384,148 L390,138 L384,128",
	      transform: "rotate(".concat(diff, " 384 620)"),
	      className: "rounded shadow",
	      strokeWidth: 3.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,128 L378,138 L384,148 L390,138 L384,128",
	      transform: "rotate(".concat(diff, " 384 620)"),
	      className: "rounded Green",
	      strokeWidth: 3
	    })]
	  });
	});

	const LsCourseBug$1 = _ref5 => {
	  let {
	    heading,
	    lsCourse
	  } = _ref5;
	  const diff = getSmallestAngle(lsCourse, heading);

	  if (lsCourse < 0 || Math.abs(diff) > 48) {
	    return null;
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,122 L384,74 M376,114 L392,114",
	      transform: "rotate(".concat(diff, " 384 620)"),
	      className: "rounded shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,122 L384,74 M376,114 L392,114",
	      transform: "rotate(".concat(diff, " 384 620)"),
	      className: "rounded Magenta",
	      strokeWidth: 2
	    })]
	  });
	};

	const SelectedHeadingBug$1 = _ref6 => {
	  let {
	    heading,
	    selected
	  } = _ref6;

	  if (selected < 0) {
	    return null;
	  }

	  const diff = getSmallestAngle(selected, heading);

	  if (Math.abs(diff) <= 48) {
	    return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M382,126 L370,99 L398,99 L386,126",
	        transform: "rotate(".concat(diff, " 384 620)"),
	        className: "rounded shadow",
	        strokeWidth: 3.5
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M382,126 L370,99 L398,99 L386,126",
	        transform: "rotate(".concat(diff, " 384 620)"),
	        className: "rounded Cyan",
	        strokeWidth: 3
	      })]
	    });
	  }

	  return /*#__PURE__*/jsxRuntime.jsx("text", {
	    x: 384,
	    y: 60,
	    textAnchor: "middle",
	    transform: "rotate(".concat(diff < 0 ? -38 : 38, " 384 620)"),
	    className: "shadow Cyan",
	    fontSize: 22,
	    children: "".concat(Math.round(selected).toString().padStart(3, '0'))
	  });
	};

	const mod = (x, n) => x - Math.floor(x / n) * n;

	const WindIndicator = _ref => {
	  let {
	    irs
	  } = _ref;
	  const windDirection = useArinc429Var("L:A32NX_ADIRS_IR_".concat(irs, "_WIND_DIRECTION"), 500);
	  const windVelocity = useArinc429Var("L:A32NX_ADIRS_IR_".concat(irs, "_WIND_VELOCITY"), 500);
	  const planeHeading = useArinc429Var("L:A32NX_ADIRS_IR_".concat(irs, "_HEADING"), 500);
	  let windDirectionText;
	  let windVelocityText;
	  let windArrowShow = false;

	  if (!windVelocity.isNormalOperation() || !windDirection.isNormalOperation()) {
	    windDirectionText = '';
	    windVelocityText = '';
	    windArrowShow = false;
	  } else if (windVelocity.value < 0.00001) {
	    windDirectionText = '---';
	    windVelocityText = '---';
	  } else {
	    windDirectionText = Math.round(windDirection.value).toString().padStart(3, '0');
	    windVelocityText = Math.round(windVelocity.value).toString();

	    if (windVelocity.value >= 2) {
	      windArrowShow = true;
	    }
	  }

	  let rotation;

	  if (planeHeading.isNormalOperation() && windDirection.isNormalOperation()) {
	    rotation = mod(Math.round(windDirection.value) - Math.round(planeHeading.value) + 180, 360);
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 17,
	    y: 56,
	    children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 25,
	      y: 0,
	      fontSize: 22,
	      textAnchor: "end",
	      className: "Green",
	      children: windDirectionText
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 30,
	      y: 0,
	      fontSize: 22,
	      className: "White",
	      children: "/"
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 48,
	      y: 0,
	      fontSize: 22,
	      className: "Green",
	      children: windVelocityText
	    }), windArrowShow && /*#__PURE__*/jsxRuntime.jsx("path", {
	      className: "Green",
	      strokeWidth: 2.25,
	      strokeLinecap: "round",
	      d: "M 0 30 v -20 m -7 8 l 7 -8 l 7 8",
	      transform: "rotate(".concat(rotation, " 0 20)"),
	      visibility: "visible"
	    })]
	  });
	};

	const SpeedIndicator = _ref => {
	  let {
	    adrs,
	    irs
	  } = _ref;
	  const tas = useArinc429Var("L:A32NX_ADIRS_ADR_".concat(adrs, "_TRUE_AIRSPEED"), 200);
	  const gs = useArinc429Var("L:A32NX_ADIRS_IR_".concat(irs, "_GROUND_SPEED"), 200);
	  let tasText;

	  if (!tas.isNormalOperation()) {
	    tasText = '';
	  } else if (tas.value < 0.00001) {
	    tasText = '---';
	  } else {
	    tasText = Math.round(tas.value).toString().padStart(3, '0');
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 2,
	    y: 28,
	    children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 0,
	      y: 0,
	      fontSize: 20,
	      className: "White",
	      children: "GS"
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 82,
	      y: 0,
	      fontSize: 25,
	      textAnchor: "end",
	      className: "Green",
	      children: gs.isNormalOperation() ? Math.round(gs.value).toString().padStart(3) : ''
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 90,
	      y: 0,
	      fontSize: 20,
	      className: "White",
	      children: "TAS"
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 189,
	      y: 0,
	      fontSize: 25,
	      textAnchor: "end",
	      className: "Green",
	      children: tasText
	    })]
	  });
	};

	const getDisplayString = seconds => {
	  if (seconds >= 3600) {
	    return "".concat(Math.floor(seconds / 3600).toString().padStart(2, '0'), "H").concat(Math.floor(seconds % 3600 / 60).toString().padStart(2, '0'), "'");
	  }

	  return "".concat(Math.floor(seconds / 60).toString().padStart(2, '0'), "'").concat(Math.floor(seconds % 60).toString().padStart(2, '0'), "\"");
	};

	const Chrono = _ref => {
	  let {
	    side
	  } = _ref;
	  const [absTime] = useSimVar('E:ABSOLUTE TIME', 'Seconds', 200);
	  const [prevTime, setPrevTime] = react.useState(absTime);
	  const [elapsedTime, setElapsedTime] = react.useState(0);
	  const [state, setState] = react.useState('HIDDEN');
	  react.useEffect(() => {
	    if (state === 'RUNNING') {
	      // max 99 hours, 59 min
	      setElapsedTime(Math.min(359940, elapsedTime + debouncedTimeDelta(absTime, prevTime)));
	    }

	    setPrevTime(absTime);
	  }, [absTime]);
	  useInteractionEvent("A32NX_EFIS_".concat(side, "_CHRONO_PUSHED"), () => {
	    switch (state) {
	      case 'HIDDEN':
	        setPrevTime(absTime);
	        setElapsedTime(0);
	        setState('RUNNING');
	        break;

	      case 'RUNNING':
	        setState('STOPPED');
	        break;

	      case 'STOPPED':
	        setState('HIDDEN');
	        break;
	    }
	  });

	  if (state === 'HIDDEN') {
	    return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {});
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    className: "chrono",
	    children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: 0,
	      y: 632,
	      width: 104,
	      height: 30,
	      className: "Grey Fill"
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 8,
	      y: 652,
	      fontSize: 24,
	      className: "Green",
	      children: getDisplayString(elapsedTime)
	    })]
	  });
	};

	const NavigationDisplayMessages = _ref => {
	  let {
	    adirsAlign,
	    mode,
	    modeChangeShown,
	    rangeChangeShown
	  } = _ref;
	  // Do not show general messages in ROSE VOR/ILS or ANF (latter is not in neo)
	  const modeValidForGeneralMessages = mode !== Mode.ROSE_VOR && mode !== Mode.ROSE_ILS && (adirsAlign || mode === Mode.PLAN);
	  const [tcasState] = useSimVar('L:A32NX_TCAS_STATE', 'Enum', 200);
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 320,
	      className: "Green",
	      textAnchor: "middle",
	      fontSize: 31,
	      visibility: modeChangeShown && !rangeChangeShown && modeValidForGeneralMessages ? 'visible' : 'hidden',
	      children: "MODE CHANGE"
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 320,
	      className: "Green",
	      textAnchor: "middle",
	      fontSize: 31,
	      visibility: rangeChangeShown && modeValidForGeneralMessages ? 'visible' : 'hidden',
	      children: "RANGE CHANGE"
	    }), tcasState === 2 && (mode === Mode.PLAN || mode === Mode.ROSE_ILS || mode === Mode.ROSE_VOR) && !modeChangeShown && !rangeChangeShown && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 320,
	      className: "Amber",
	      textAnchor: "middle",
	      fontSize: 31,
	      children: "TCAS: CHANGE MODE"
	    }), tcasState === 3 && (mode === Mode.PLAN || mode === Mode.ROSE_ILS || mode === Mode.ROSE_VOR) && !modeChangeShown && !rangeChangeShown && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 320,
	      className: "Red",
	      textAnchor: "middle",
	      fontSize: 31,
	      children: "TCAS: CHANGE MODE"
	    })]
	  });
	};

	const FMMessages = _ref => {
	  var _activeMessages$text;

	  let {
	    modeIndex,
	    side
	  } = _ref;
	  const [activeMessages, setActiveMessages] = react.useState([]); // TODO check FM failure and get messages from other FM

	  const [messageFlags] = useSimVar("L:A32NX_EFIS_".concat(side, "_ND_FM_MESSAGE_FLAGS"), 'number', 500);
	  react.useEffect(() => {
	    const newActiveMessages = activeMessages.slice(); // the list must be ordered by priority, and LIFO for equal priority

	    for (const message of Object.values(FMMessageTypes)) {
	      var _message$ndFlag, _message$ndFlag2;

	      if ((((_message$ndFlag = message.ndFlag) !== null && _message$ndFlag !== void 0 ? _message$ndFlag : 0) & messageFlags) > 0) {
	        if (newActiveMessages.findIndex(_ref2 => {
	          let {
	            ndFlag
	          } = _ref2;
	          return ndFlag === message.ndFlag;
	        }) === -1) {
	          newActiveMessages.push(message);
	          newActiveMessages.sort((a, b) => {
	            var _b$ndPriority, _a$ndPriority;

	            return ((_b$ndPriority = b.ndPriority) !== null && _b$ndPriority !== void 0 ? _b$ndPriority : 0) - ((_a$ndPriority = a.ndPriority) !== null && _a$ndPriority !== void 0 ? _a$ndPriority : 0);
	          });
	        }
	      } else if (((_message$ndFlag2 = message.ndFlag) !== null && _message$ndFlag2 !== void 0 ? _message$ndFlag2 : 0) > 0) {
	        const idx = newActiveMessages.findIndex(_ref3 => {
	          let {
	            ndFlag
	          } = _ref3;
	          return ndFlag === message.ndFlag;
	        });

	        if (idx !== -1) {
	          newActiveMessages.splice(idx, 1);
	        }
	      }
	    }

	    setActiveMessages(newActiveMessages);
	  }, [messageFlags]);

	  if (modeIndex !== Mode.ARC && modeIndex !== Mode.PLAN && modeIndex !== Mode.ROSE_NAV || activeMessages.length < 1) {
	    return null;
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 164,
	    y: 713,
	    children: [/*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: 0,
	      y: 0,
	      width: 440,
	      height: 30,
	      className: "White BackgroundFill",
	      strokeWidth: 1.75
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 420 / 2,
	      y: 25,
	      className: "".concat(activeMessages[activeMessages.length - 1].color, " MiddleAlign"),
	      textAnchor: "middle",
	      fontSize: 25,
	      children: "".concat((_activeMessages$text = activeMessages[activeMessages.length - 1].text) !== null && _activeMessages$text !== void 0 ? _activeMessages$text : activeMessages[activeMessages.length - 1].efisText)
	    }), activeMessages.length > 1 && /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M428,2 L428,20 L424,20 L430,28 L436,20 L432,20 L432,2 L428,2",
	      className: "Green Fill"
	    })]
	  });
	};

	const TcasWxrMessages = _ref => {
	  let {
	    modeIndex
	  } = _ref;
	  // TODO get data and decide what to display
	  let leftMessage;
	  let rightMessage;
	  const [tcasOnly] = useSimVar('L:A32NX_TCAS_TA_ONLY', 'boolean', 200);
	  const [tcasFault] = useSimVar('L:A32NX_TCAS_FAULT', 'boolean', 200);

	  if (tcasFault) {
	    leftMessage = {
	      text: 'TCAS',
	      color: 'Amber'
	    };
	  } else if (tcasOnly) {
	    leftMessage = {
	      text: 'TA ONLY',
	      color: 'White'
	    };
	  }

	  if (modeIndex !== Mode.ARC && modeIndex !== Mode.ROSE_NAV && modeIndex !== Mode.ROSE_VOR && modeIndex !== Mode.ROSE_ILS || !leftMessage && !rightMessage) {
	    return null;
	  }

	  const y = modeIndex === Mode.ROSE_VOR || modeIndex === Mode.ROSE_ILS ? 713 : 684;
	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 164,
	    y: y,
	    children: [(modeIndex === Mode.ARC || modeIndex === Mode.ROSE_NAV) && /*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: 0,
	      y: 0,
	      width: 440,
	      height: 59,
	      className: "BackgroundFill",
	      stroke: "none"
	    }), /*#__PURE__*/jsxRuntime.jsx("rect", {
	      x: 0,
	      y: 0,
	      width: 440,
	      height: 30,
	      className: "White BackgroundFill",
	      strokeWidth: 1.75
	    }), leftMessage && /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 8,
	      y: 25,
	      className: "".concat(leftMessage.color),
	      textAnchor: "start",
	      fontSize: 25,
	      children: leftMessage.text
	    }), rightMessage ]
	  });
	};

	const PlanMode = _ref => {
	  let {
	    side,
	    symbols,
	    adirsAlign,
	    rangeSetting,
	    ppos,
	    mapHidden
	  } = _ref;
	  const [planCentreLat] = useSimVar('L:A32NX_SELECTED_WAYPOINT_LAT', 'Degrees');
	  const [planCentreLong] = useSimVar('L:A32NX_SELECTED_WAYPOINT_LONG', 'Degrees');
	  const [trueHeading] = useSimVar('PLANE HEADING DEGREES TRUE', 'degrees');
	  const [mapParams] = react.useState(new MapParameters());
	  react.useEffect(() => {
	    mapParams.compute({
	      lat: planCentreLat,
	      long: planCentreLong
	    }, rangeSetting / 2, 250, 0);
	  }, [planCentreLat, planCentreLong, rangeSetting]);
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx(Overlay$1, {
	      rangeSetting: rangeSetting
	    }), /*#__PURE__*/jsxRuntime.jsx("g", {
	      id: "map",
	      clipPath: "url(#plan-mode-map-clip)",
	      visibility: mapHidden ? 'hidden' : 'visible',
	      children: /*#__PURE__*/jsxRuntime.jsx(FlightPlan, {
	        x: 384,
	        y: 384,
	        side: side,
	        range: rangeSetting,
	        symbols: symbols,
	        mapParams: mapParams,
	        mapParamsVersion: mapParams.version,
	        debug: false
	      })
	    }), adirsAlign && !mapHidden && mapParams.valid && /*#__PURE__*/jsxRuntime.jsx(Plane$1, {
	      location: ppos,
	      heading: trueHeading,
	      mapParams: mapParams
	    }), /*#__PURE__*/jsxRuntime.jsx(ToWaypointIndicator, {
	      side: side
	    }), /*#__PURE__*/jsxRuntime.jsx(CrossTrack, {
	      x: 44,
	      y: 690,
	      side: side,
	      isPlanMode: true
	    })]
	  });
	};
	const Overlay$1 = /*#__PURE__*/react.memo(_ref2 => {
	  let {
	    rangeSetting
	  } = _ref2;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "plan-mode-map-clip",
	      children: /*#__PURE__*/jsxRuntime.jsx("polygon", {
	        points: "45,112 140,112 280,56 488,56 628,112 723,112 723,720 114,720 114,633 45,633"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	      strokeWidth: 3,
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 384,
	        cy: 384,
	        r: 250,
	        className: "White"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M259,384a125,125 0 1,0 250,0a125,125 0 1,0 -250,0",
	        strokeDasharray: "14 13",
	        className: "White"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 310,
	        y: 474,
	        className: "Cyan",
	        fontSize: 22,
	        children: rangeSetting / 4
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 212,
	        y: 556,
	        className: "Cyan",
	        fontSize: 22,
	        children: rangeSetting / 2
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 384,
	        y: 170,
	        className: "White",
	        fontSize: 25,
	        textAnchor: "middle",
	        alignmentBaseline: "central",
	        children: "N"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,141.5 L390,151 L378,151 L384,141.5",
	        fill: "white",
	        stroke: "none"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 598,
	        y: 384,
	        className: "White",
	        fontSize: 25,
	        textAnchor: "middle",
	        alignmentBaseline: "central",
	        children: "E"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M626.2,384 L617,390 L617,378 L626.5,384",
	        fill: "white",
	        stroke: "none"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 384,
	        y: 598,
	        className: "White",
	        fontSize: 25,
	        textAnchor: "middle",
	        alignmentBaseline: "central",
	        children: "S"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,626.5 L390,617 L378,617 L384,626.5",
	        fill: "white",
	        stroke: "none"
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 170,
	        y: 384,
	        className: "White",
	        fontSize: 25,
	        textAnchor: "middle",
	        alignmentBaseline: "central",
	        children: "W"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M141.5,384 L151,390 L151,378 L141.5,384",
	        fill: "white",
	        stroke: "none"
	      })]
	    })]
	  });
	});

	const Plane$1 = _ref3 => {
	  let {
	    location,
	    heading,
	    mapParams
	  } = _ref3;
	  const [x, y] = mapParams.coordinatesToXYy(location);
	  const rotation = mapParams.rotation(heading);
	  return /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "translate(".concat(x, " ").concat(y, ") rotate(").concat(rotation, " 384 384)"),
	    children: /*#__PURE__*/jsxRuntime.jsx("image", {
	      x: 342,
	      y: 357,
	      width: 84,
	      height: 71,
	      xlinkHref: "/Images/ND/AIRPLANE.svg"
	    })
	  });
	};

	const RoseMode = _ref => {
	  let {
	    symbols,
	    adirsAlign,
	    rangeSetting,
	    mode,
	    side,
	    ppos,
	    mapHidden
	  } = _ref;
	  const [magHeading] = useSimVar('PLANE HEADING DEGREES MAGNETIC', 'degrees');
	  const [magTrack] = useSimVar('GPS GROUND MAGNETIC TRACK', 'degrees');
	  const [trueHeading] = useSimVar('PLANE HEADING DEGREES TRUE', 'degrees');
	  const [tcasMode] = useSimVar('L:A32NX_SWITCH_TCAS_Position', 'number');
	  const [selectedHeading] = useSimVar('L:A32NX_AUTOPILOT_HEADING_SELECTED', 'degrees');
	  const [lsCourse] = useSimVar('L:A32NX_FM_LS_COURSE', 'number');
	  const [lsDisplayed] = useSimVar("L:BTN_LS_".concat(side === 'L' ? 1 : 2, "_FILTER_ACTIVE"), 'bool'); // TODO rename simvar

	  const [fmaLatMode] = useSimVar('L:A32NX_FMA_LATERAL_MODE', 'enum', 200);
	  const [armedLateralBitmask] = useSimVar('L:A32NX_FMA_LATERAL_ARMED', 'enum', 200);
	  const [groundSpeed] = useSimVar('GPS GROUND SPEED', 'Meters per second', 200);
	  const heading = Math.round(Number(MathUtils.fastToFixed(magHeading, 1)) * 1000) / 1000;
	  let track = Math.round(Number(MathUtils.fastToFixed(magTrack, 1)) * 1000) / 1000; // Workaround for bug with gps ground track simvar

	  if (groundSpeed < 40) {
	    track = (0.025 * groundSpeed + 0.00005) * track + (1 - (0.025 * groundSpeed + 0.00005)) * heading;
	  }

	  const [mapParams] = react.useState(() => {
	    const params = new MapParameters();
	    params.compute(ppos, rangeSetting / 2, 250, trueHeading);
	    return params;
	  });
	  react.useEffect(() => {
	    mapParams.compute(ppos, rangeSetting / 2, 250, trueHeading);
	  }, [ppos.lat, ppos.long, trueHeading, rangeSetting].map(n => MathUtils.fastToFixed(n, 6)));

	  if (adirsAlign) {
	    return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx(TerrainMap, {
	        x: 0,
	        y: 134,
	        width: 768,
	        height: 250,
	        side: side,
	        potentiometerIndex: side === 'L' ? 94 : 95,
	        clipName: "rose-mode-map-clip"
	      }), /*#__PURE__*/jsxRuntime.jsx(Overlay, {
	        heading: heading,
	        rangeSetting: rangeSetting,
	        tcasMode: tcasMode
	      }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	        id: "map",
	        clipPath: "url(#rose-mode-map-clip)",
	        children: [mode === Mode.ROSE_NAV && /*#__PURE__*/jsxRuntime.jsxs("g", {
	          visibility: mapHidden ? 'hidden' : 'visible',
	          children: [/*#__PURE__*/jsxRuntime.jsx(FlightPlan, {
	            x: 384,
	            y: 384,
	            side: side,
	            range: rangeSetting,
	            symbols: symbols,
	            mapParams: mapParams,
	            mapParamsVersion: mapParams.version,
	            debug: false
	          }), (fmaLatMode === LateralMode.NONE || fmaLatMode === LateralMode.HDG || fmaLatMode === LateralMode.TRACK) && !isArmed(armedLateralBitmask, ArmedLateralMode.NAV) && /*#__PURE__*/jsxRuntime.jsx(TrackLine, {
	            x: 384,
	            y: 384,
	            heading: heading,
	            track: track,
	            mapParams: mapParams,
	            groundSpeed: groundSpeed,
	            symbols: symbols,
	            ndRange: rangeSetting
	          })]
	        }), /*#__PURE__*/jsxRuntime.jsx(RadioNeedle, {
	          index: 1,
	          side: side,
	          displayMode: mode,
	          centreHeight: 384
	        }), /*#__PURE__*/jsxRuntime.jsx(RadioNeedle, {
	          index: 2,
	          side: side,
	          displayMode: mode,
	          centreHeight: 384
	        })]
	      }), mode === Mode.ROSE_VOR && /*#__PURE__*/jsxRuntime.jsx(VorCaptureOverlay, {
	        heading: magHeading,
	        side: side
	      }), mode === Mode.ROSE_ILS && /*#__PURE__*/jsxRuntime.jsx(IlsCaptureOverlay, {
	        heading: magHeading,
	        _side: side
	      }), mode === Mode.ROSE_NAV && /*#__PURE__*/jsxRuntime.jsx(ToWaypointIndicator, {
	        side: side
	      }), mode === Mode.ROSE_VOR && /*#__PURE__*/jsxRuntime.jsx(VorInfo, {
	        side: side
	      }), mode === Mode.ROSE_ILS && /*#__PURE__*/jsxRuntime.jsx(IlsInfo, {}), /*#__PURE__*/jsxRuntime.jsx(ApproachMessage, {
	        side: side
	      }), /*#__PURE__*/jsxRuntime.jsx(TrackBug, {
	        heading: heading,
	        track: track
	      }), mode === Mode.ROSE_NAV && lsDisplayed && /*#__PURE__*/jsxRuntime.jsx(LsCourseBug, {
	        heading: heading,
	        lsCourse: lsCourse
	      }), /*#__PURE__*/jsxRuntime.jsx(SelectedHeadingBug, {
	        heading: heading,
	        selected: selectedHeading
	      }), mode === Mode.ROSE_ILS && /*#__PURE__*/jsxRuntime.jsx(GlideSlope, {}), /*#__PURE__*/jsxRuntime.jsx(Plane, {}), mode === Mode.ROSE_NAV && /*#__PURE__*/jsxRuntime.jsx(CrossTrack, {
	        x: 390,
	        y: 407,
	        side: side
	      }), /*#__PURE__*/jsxRuntime.jsx("g", {
	        clipPath: "url(#rose-mode-tcas-clip)",
	        children: /*#__PURE__*/jsxRuntime.jsx(Traffic, {
	          mode: mode,
	          mapParams: mapParams
	        })
	      })]
	    });
	  }

	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx(MapFailOverlay, {
	      rangeSetting: rangeSetting
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 681,
	      y: 28,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: "PPOS"
	    })]
	  });
	};

	const Overlay = _ref2 => {
	  let {
	    heading,
	    rangeSetting,
	    tcasMode
	  } = _ref2;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx(RoseModeOverlayDefs, {}), /*#__PURE__*/jsxRuntime.jsxs("g", {
	      transform: "rotateX(0deg)",
	      stroke: "white",
	      strokeWidth: 3,
	      fill: "none",
	      children: [/*#__PURE__*/jsxRuntime.jsx("g", {
	        clipPath: "url(#arc-mode-overlay-clip-4)",
	        children: /*#__PURE__*/jsxRuntime.jsx("g", {
	          transform: "rotate(".concat(MathUtils.diffAngle(heading, 0), " 384 384)"),
	          children: /*#__PURE__*/jsxRuntime.jsx(RoseModeOverlayHeadingRing, {})
	        })
	      }), (tcasMode === 0 || rangeSetting > 10) && /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 509 384 A 125 125 0 0 1 259 384 M 259 384 A 125 125 180 0 1 509 384",
	        strokeDasharray: "15 10",
	        strokeDashoffset: "-4.2"
	      }), tcasMode > 0 && rangeSetting === 10 && /*#__PURE__*/jsxRuntime.jsxs("g", {
	        children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(0 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(30 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(60 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(90 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(120 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(150 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(180 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(210 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(240 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(270 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(300 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 264,
	          y2: 254,
	          className: "rounded White",
	          transform: "rotate(330 384 384)"
	        })]
	      }), tcasMode > 0 && rangeSetting === 20 && /*#__PURE__*/jsxRuntime.jsxs("g", {
	        children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(0 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(30 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(60 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(90 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(120 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(150 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(180 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(210 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(240 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(270 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(300 384 384)"
	        }), /*#__PURE__*/jsxRuntime.jsx("line", {
	          x1: 384,
	          x2: 384,
	          y1: 327,
	          y2: 317,
	          className: "rounded White",
	          transform: "rotate(330 384 384)"
	        })]
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 212,
	        y: 556,
	        className: "Cyan",
	        fontSize: 22,
	        children: rangeSetting / 2
	      }), /*#__PURE__*/jsxRuntime.jsx("text", {
	        x: 310,
	        y: 474,
	        className: "Cyan",
	        fontSize: 22,
	        children: rangeSetting / 4
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(45 384 384)",
	        fill: "white"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(90 384 384)",
	        fill: "white"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(135 384 384)",
	        fill: "white"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(180 384 384)",
	        fill: "white"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(225 384 384)",
	        fill: "white"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(270 384 384)",
	        fill: "white"
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,132 L379,123 L389,123 L384,132",
	        transform: "rotate(315 384 384)",
	        fill: "white"
	      })]
	    })]
	  });
	};

	const RoseModeOverlayDefs = /*#__PURE__*/react.memo(() => /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	  children: [/*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "rose-mode-map-clip",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M45,155 L282,155 a250,250 0 0 1 204,0 L723,155 L723,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L45,625 L45,155"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "rose-mode-wx-terr-clip",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M45,155 L282,155 a250,250 0 0 1 204,0 L723,155 L723,384 L45,384 L45,155"
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	    id: "rose-mode-tcas-clip",
	    children: /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M45,155 L282,155 a250,250 0 0 1 204,0 L723,155 L723,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L45,625 L45,155"
	    })
	  })]
	}));
	const RoseModeOverlayHeadingRing = /*#__PURE__*/react.memo(() => /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	  children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	    cx: 384,
	    cy: 384,
	    r: 250
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(0 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "0"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(5 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(10 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(15 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(20 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(25 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(30 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "3"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(35 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(40 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(45 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(50 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(55 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(60 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "6"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(65 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(70 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(75 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(80 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(85 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(90 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "9"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(95 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(100 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(105 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(110 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(115 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(120 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "12"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(125 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(130 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(135 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(140 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(145 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(150 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "15"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(155 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(160 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(165 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(170 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(175 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(180 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "18"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(185 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(190 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(195 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(200 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(205 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(210 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "21"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(215 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(220 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(225 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(230 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(235 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(240 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "24"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(245 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(250 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(255 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(260 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(265 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(270 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "27"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(275 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(280 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(285 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(290 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(295 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(300 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "30"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(305 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(310 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(315 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(320 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(325 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(330 384 384)",
	    children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 384,
	      y: 112,
	      textAnchor: "middle",
	      fontSize: 22,
	      fill: "white",
	      stroke: "none",
	      children: "33"
	    })]
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(335 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(340 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(345 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(350 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 122,
	      strokeWidth: 2.5
	    })
	  }), /*#__PURE__*/jsxRuntime.jsx("g", {
	    transform: "rotate(355 384 384)",
	    children: /*#__PURE__*/jsxRuntime.jsx("line", {
	      x1: 384,
	      y1: 134,
	      x2: 384,
	      y2: 128,
	      strokeWidth: 2.5
	    })
	  })]
	}));
	const MapFailOverlay = /*#__PURE__*/react.memo(_ref3 => {
	  let {
	    rangeSetting
	  } = _ref3;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	      className: "Red",
	      fontSize: 30,
	      textAnchor: "middle",
	      x: 384,
	      y: 241,
	      children: "HDG"
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      className: "Red",
	      fontSize: 30,
	      textAnchor: "middle",
	      x: 384,
	      y: 320.6,
	      children: "MAP NOT AVAIL"
	    }), /*#__PURE__*/jsxRuntime.jsx("clipPath", {
	      id: "rose-mode-map-clip",
	      children: /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M-339,-229 L-102,-229 a250,250 0 0 1 204,0 L339,-229 L339,178 L264,178 L207,241 L207,384 L-210,384 L-210,299 L-262,241 L-339,241 L-339,-229"
	      })
	    }), /*#__PURE__*/jsxRuntime.jsxs("g", {
	      stroke: "white",
	      strokeWidth: 3,
	      fill: "none",
	      children: [/*#__PURE__*/jsxRuntime.jsx("g", {
	        clipPath: "url(#arc-mode-overlay-clip-4)",
	        children: /*#__PURE__*/jsxRuntime.jsx("g", {
	          children: /*#__PURE__*/jsxRuntime.jsx("circle", {
	            cx: 384,
	            cy: 384,
	            r: 250,
	            stroke: "red"
	          })
	        })
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M 509 384 A 125 125 0 0 1 259 384 M 259 384 A 125 125 180 0 1 509 384",
	        stroke: "red"
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 212,
	      y: 556,
	      className: "Cyan",
	      fontSize: 22,
	      children: rangeSetting / 2
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 310,
	      y: 474,
	      className: "Cyan",
	      fontSize: 22,
	      children: rangeSetting / 4
	    })]
	  });
	});

	const VorCaptureOverlay = _ref4 => {
	  let {
	    heading,
	    side
	  } = _ref4;
	  const index = side === 'L' ? 1 : 2;
	  const [course] = useSimVar("NAV OBS:".concat(index), 'degrees');
	  const [courseDeviation] = useSimVar("NAV RADIAL ERROR:".concat(index), 'degrees', 20);
	  const [available] = useSimVar("NAV HAS NAV:".concat(index), 'number');
	  const [toward, setToward] = react.useState(true);
	  const [cdiPx, setCdiPx] = react.useState(12);
	  react.useEffect(() => {
	    let cdiDegrees;

	    if (Math.abs(courseDeviation) <= 90) {
	      cdiDegrees = courseDeviation;
	      setToward(true);
	    } else {
	      cdiDegrees = Math.sign(courseDeviation) * -Avionics.Utils.diffAngle(180, Math.abs(courseDeviation));
	      setToward(false);
	    }

	    setCdiPx(Math.min(12, Math.max(-12, cdiDegrees)) * 74 / 5);
	  }, [courseDeviation.toFixed(2)]);
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(course - heading, " 384 384)"),
	    stroke: "white",
	    strokeWidth: 3,
	    fill: "none",
	    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
	      id: "vor-deviation-scale",
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 236,
	        cy: 384,
	        r: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 310,
	        cy: 384,
	        r: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 458,
	        cy: 384,
	        r: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 532,
	        cy: 384,
	        r: 5
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
	      className: "rounded shadow",
	      id: "vor-course-pointer-shadow",
	      strokeWidth: 4.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
	      className: "rounded Cyan",
	      id: "vor-course-pointer",
	      strokeWidth: 4
	    }), available && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M372,322 L384,304 L396,322",
	        className: "rounded shadow",
	        transform: "translate(".concat(cdiPx, ", ").concat(toward ? 0 : 160, ") rotate(").concat(toward ? 0 : 180, " 384 304)"),
	        id: "vor-deviation-direction-shadow",
	        strokeWidth: 4.5
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,304 L384,464",
	        className: "rounded shadow",
	        transform: "translate(".concat(cdiPx, ", 0)"),
	        id: "vor-deviation-shadow",
	        strokeWidth: 4.5
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M372,322 L384,304 L396,322",
	        className: "rounded Cyan",
	        transform: "translate(".concat(cdiPx, ", ").concat(toward ? 0 : 160, ") rotate(").concat(toward ? 0 : 180, " 384 304)"),
	        id: "vor-deviation-direction",
	        strokeWidth: 4
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,304 L384,464",
	        className: "rounded Cyan",
	        transform: "translate(".concat(cdiPx, ", 0)"),
	        id: "vor-deviation",
	        strokeWidth: 4
	      })]
	    })]
	  });
	};

	const IlsCaptureOverlay = /*#__PURE__*/react.memo(_ref5 => {
	  let {
	    heading,
	    _side
	  } = _ref5;
	  const [course] = useSimVar('NAV LOCALIZER:3', 'degrees');
	  const [courseDeviation] = useSimVar('L:A32NX_RADIO_RECEIVER_LOC_DEVIATION', 'number', 20);
	  const [available] = useSimVar('L:A32NX_RADIO_RECEIVER_LOC_IS_VALID', 'number');
	  const [cdiPx, setCdiPx] = react.useState(12);
	  react.useEffect(() => {
	    // TODO back-course
	    setCdiPx(Math.min(12, Math.max(-12, courseDeviation)) * 74 / 5);
	  }, [courseDeviation.toFixed(2)]);
	  return /*#__PURE__*/jsxRuntime.jsxs("g", {
	    transform: "rotate(".concat(course - heading, " 384 384)"),
	    stroke: "white",
	    strokeWidth: 3,
	    fill: "none",
	    children: [/*#__PURE__*/jsxRuntime.jsxs("g", {
	      id: "ils-deviation-scale",
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 236,
	        cy: 384,
	        r: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 310,
	        cy: 384,
	        r: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 458,
	        cy: 384,
	        r: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 532,
	        cy: 384,
	        r: 5
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
	      className: "rounded shadow",
	      id: "ils-course-pointer-shadow",
	      strokeWidth: 4.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
	      className: "rounded Magenta",
	      id: "ils-course-pointer",
	      strokeWidth: 4
	    }), available && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,304 L384,464",
	        className: "rounded shadow",
	        transform: "translate(".concat(cdiPx, ", 0)"),
	        id: "ils-deviation-shadow",
	        strokeWidth: 4.5
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M384,304 L384,464",
	        className: "rounded Magenta",
	        transform: "translate(".concat(cdiPx, ", 0)"),
	        id: "ils-deviation",
	        strokeWidth: 4
	      })]
	    })]
	  });
	});

	const Plane = () => /*#__PURE__*/jsxRuntime.jsxs("g", {
	  children: [/*#__PURE__*/jsxRuntime.jsx("line", {
	    id: "lubber-shadow",
	    x1: 384,
	    y1: 116,
	    x2: 384,
	    y2: 152,
	    className: "shadow",
	    strokeWidth: 5.5,
	    strokeLinejoin: "round",
	    strokeLinecap: "round"
	  }), /*#__PURE__*/jsxRuntime.jsx("line", {
	    id: "lubber",
	    x1: 384,
	    y1: 116,
	    x2: 384,
	    y2: 152,
	    className: "Yellow",
	    strokeWidth: 5,
	    strokeLinejoin: "round",
	    strokeLinecap: "round"
	  }), /*#__PURE__*/jsxRuntime.jsx("image", {
	    x: 342,
	    y: 357,
	    width: 84,
	    height: 71,
	    xlinkHref: "/Images/ND/AIRPLANE.svg"
	  })]
	});

	const TrackBug = /*#__PURE__*/react.memo(_ref6 => {
	  let {
	    heading,
	    track
	  } = _ref6;
	  const diff = getSmallestAngle(track, heading);
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,134 L379,143 L384,152 L389,143 L384,134",
	      transform: "rotate(".concat(diff, " 384 384)"),
	      className: "rounded shadow",
	      strokeWidth: 3.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,134 L379,143 L384,152 L389,143 L384,134",
	      transform: "rotate(".concat(diff, " 384 384)"),
	      className: "rounded Green",
	      strokeWidth: 3
	    })]
	  });
	});

	const LsCourseBug = _ref7 => {
	  let {
	    heading,
	    lsCourse
	  } = _ref7;

	  if (lsCourse < 0) {
	    return null;
	  }

	  const diff = getSmallestAngle(lsCourse, heading);
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,128 L384,96 M376,120 L392,120",
	      transform: "rotate(".concat(diff, " 384 384)"),
	      className: "rounded shadow",
	      strokeWidth: 2.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M384,128 L384,96 M376,120 L392,120",
	      transform: "rotate(".concat(diff, " 384 384)"),
	      className: "rounded Magenta",
	      strokeWidth: 2
	    })]
	  });
	};

	const SelectedHeadingBug = _ref8 => {
	  let {
	    heading,
	    selected
	  } = _ref8;

	  if (selected < 0) {
	    return null;
	  }

	  const diff = getSmallestAngle(selected, heading);
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M380,132 L372,114 L396,114 L388,132",
	      transform: "rotate(".concat(diff, " 384 384)"),
	      className: "rounded shadow",
	      strokeWidth: 3.5
	    }), /*#__PURE__*/jsxRuntime.jsx("path", {
	      d: "M380,132 L372,114 L396,114 L388,132",
	      transform: "rotate(".concat(diff, " 384 384)"),
	      className: "rounded Cyan",
	      strokeWidth: 3
	    })]
	  });
	};

	const formatTuningMode = tuningMode => {
	  switch (tuningMode) {
	    case TuningMode.Manual:
	      return 'M';

	    case TuningMode.Remote:
	      return 'R';

	    default:
	      return '';
	  }
	};

	const VorInfo = /*#__PURE__*/react.memo(_ref9 => {
	  let {
	    side
	  } = _ref9;
	  const index = side === 'R' ? 2 : 1;
	  const [vorIdent] = useSimVar("NAV IDENT:".concat(index), 'string');
	  const [vorFrequency] = useSimVar("NAV ACTIVE FREQUENCY:".concat(index), 'megahertz');
	  const [vorCourse] = useSimVar("NAV OBS:".concat(index), 'degrees');
	  const [tuningMode] = useSimVar('L:A32NX_FMGC_RADIONAV_TUNING_MODE', 'enum');
	  const [vorAvailable] = useSimVar("NAV HAS NAV:".concat(index), 'boolean');
	  const [freqInt, freqDecimal] = vorFrequency.toFixed(2).split('.', 2);
	  const [tuningModeLabel, setTuningModeLabel] = react.useState('');
	  react.useEffect(() => {
	    setTuningModeLabel(formatTuningMode(tuningMode));
	  }, [tuningMode]);
	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 748,
	    y: 28,
	    children: [/*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: -102,
	      y: 0,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: ["VOR", index]
	    }), vorAvailable && /*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: 0,
	      y: 0,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: [freqInt, /*#__PURE__*/jsxRuntime.jsxs("tspan", {
	        fontSize: 20,
	        children: [".", freqDecimal]
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: -56,
	      y: 30,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: "CRS"
	    }), /*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: 20,
	      y: 30,
	      fontSize: 25,
	      className: "Cyan",
	      textAnchor: "end",
	      children: [vorCourse >= 0 ? "".concat(Math.round(vorCourse)).padStart(3, '0') : '---', "\xB0"]
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: -80,
	      y: 58,
	      fontSize: 20,
	      className: "White",
	      textAnchor: "end",
	      textDecoration: "underline",
	      children: tuningModeLabel
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 0,
	      y: 60,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: vorIdent
	    })]
	  });
	});
	const IlsInfo = /*#__PURE__*/react.memo(() => {
	  const [ilsIdent] = useSimVar('NAV IDENT:3', 'string');
	  const [ilsFrequency] = useSimVar('NAV ACTIVE FREQUENCY:3', 'megahertz');
	  const [ilsCourse] = useSimVar('NAV LOCALIZER:3', 'degrees');
	  const [tuningMode] = useSimVar('L:A32NX_FMGC_RADIONAV_TUNING_MODE', 'enum');
	  const [locAvailable] = useSimVar('L:A32NX_RADIO_RECEIVER_LOC_IS_VALID', 'number');
	  const [freqInt, freqDecimal] = ilsFrequency.toFixed(2).split('.', 2);
	  const [tuningModeLabel, setTuningModeLabel] = react.useState('');
	  react.useEffect(() => {
	    setTuningModeLabel(formatTuningMode(tuningMode));
	  }, [tuningMode]);
	  return /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	    x: 748,
	    y: 28,
	    children: [/*#__PURE__*/jsxRuntime.jsx("text", {
	      x: -102,
	      y: 0,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: "ILS1"
	    }), locAvailable && /*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: 0,
	      y: 0,
	      fontSize: 25,
	      className: "Magenta",
	      textAnchor: "end",
	      children: [freqInt, /*#__PURE__*/jsxRuntime.jsxs("tspan", {
	        fontSize: 20,
	        children: [".", freqDecimal]
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: -56,
	      y: 30,
	      fontSize: 25,
	      className: "White",
	      textAnchor: "end",
	      children: "CRS"
	    }), /*#__PURE__*/jsxRuntime.jsxs("text", {
	      x: 20,
	      y: 30,
	      fontSize: 25,
	      className: "Magenta",
	      textAnchor: "end",
	      children: [locAvailable ? "".concat(Math.round(ilsCourse)).padStart(3, '0') : '---', "\xB0"]
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: -80,
	      y: 58,
	      fontSize: 20,
	      className: "White",
	      textAnchor: "end",
	      textDecoration: "underline",
	      children: tuningModeLabel
	    }), /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 0,
	      y: 60,
	      fontSize: 25,
	      className: "Magenta",
	      textAnchor: "end",
	      children: ilsIdent
	    })]
	  });
	});

	const GlideSlope = () => {
	  // TODO need some photo refs for this
	  const [gsDeviation] = useSimVar('L:A32NX_RADIO_RECEIVER_GS_DEVIATION', 'number');
	  const [gsAvailable] = useSimVar('L:A32NX_RADIO_RECEIVER_GS_IS_VALID', 'number');
	  const deviationPx = gsDeviation / 0.8 * 128;
	  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	    children: [/*#__PURE__*/jsxRuntime.jsxs(Layer, {
	      x: 750,
	      y: 384,
	      children: [/*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: -128,
	        r: 4,
	        strokeWidth: 2.5,
	        className: "White"
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: -64,
	        r: 4,
	        strokeWidth: 2.5,
	        className: "White"
	      }), /*#__PURE__*/jsxRuntime.jsx("line", {
	        x1: -12,
	        x2: 12,
	        y1: 0,
	        y2: 0,
	        className: "Yellow",
	        strokeWidth: 5
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 64,
	        r: 4,
	        strokeWidth: 2.5,
	        className: "White"
	      }), /*#__PURE__*/jsxRuntime.jsx("circle", {
	        cx: 0,
	        cy: 128,
	        r: 4,
	        strokeWidth: 2.5,
	        className: "White"
	      })]
	    }), /*#__PURE__*/jsxRuntime.jsxs(Layer, {
	      x: 750,
	      y: 384,
	      children: [/*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M10,0 L0,-16 L-10,0",
	        transform: "translate(0 ".concat(Math.max(-128, deviationPx), ")"),
	        className: "rounded Magenta",
	        strokeWidth: 2.5,
	        visibility: gsAvailable && deviationPx < 128 ? 'visible' : 'hidden'
	      }), /*#__PURE__*/jsxRuntime.jsx("path", {
	        d: "M-10,0 L0,16 L10,0",
	        transform: "translate(0 ".concat(Math.min(128, deviationPx), ")"),
	        className: "rounded Magenta",
	        strokeWidth: 2.5,
	        visibility: gsAvailable && deviationPx > -128 ? 'visible' : 'hidden'
	      })]
	    })]
	  });
	};

	const LnavStatus = () => {
	  const [strings, setStrings] = react.useState([]);
	  useCoherentEvent('A32NX_FM_DEBUG_LNAV_STATUS', message => {
	    setStrings(message.split('\n'));
	  });
	  return /*#__PURE__*/jsxRuntime.jsx(Layer, {
	    x: 50,
	    y: 280,
	    children: strings.map((line, i) => /*#__PURE__*/jsxRuntime.jsx("text", {
	      x: 0,
	      y: i * 25,
	      fill: "magenta",
	      fontSize: 20,
	      children: line
	    }))
	  });
	};

	const NavigationDisplay = () => {
	  const [displayIndex] = react.useState(() => {
	    var _url$substring;

	    const url = document.getElementsByTagName('a32nx-nd')[0].getAttribute('url');
	    return parseInt((_url$substring = url === null || url === void 0 ? void 0 : url.substring(url.length - 1)) !== null && _url$substring !== void 0 ? _url$substring : '1', 10);
	  });
	  const side = displayIndex === 1 ? 'L' : 'R';
	  const [airDataSwitch] = useSimVar('L:A32NX_AIR_DATA_SWITCHING_KNOB', 'enum', 200);
	  const [attHdgSwitch] = useSimVar('L:A32NX_ATT_HDG_SWITCHING_KNOB', 'enum', 200);
	  const [airDataReferenceSource, setAirDataSource] = react.useState(displayIndex);
	  const [inertialReferenceSource, setInertialSource] = react.useState(displayIndex);
	  react.useEffect(() => {
	    setAirDataSource(getSupplier(displayIndex, airDataSwitch));
	  }, [airDataSwitch]);
	  react.useEffect(() => {
	    setInertialSource(getSupplier(displayIndex, attHdgSwitch));
	  }, [attHdgSwitch]);
	  const arincLat = useArinc429Var("L:A32NX_ADIRS_IR_".concat(inertialReferenceSource, "_LATITUDE"), 200);
	  const arincLong = useArinc429Var("L:A32NX_ADIRS_IR_".concat(inertialReferenceSource, "_LONGITUDE"), 200);
	  const adirsAlign = arincLat.isNormalOperation() && arincLong.isNormalOperation();
	  const ppos = adirsAlign ? {
	    lat: arincLat.value,
	    long: arincLong.value
	  } : {
	    lat: NaN,
	    long: NaN
	  };
	  const [rangeIndex] = useSimVar(displayIndex === 1 ? 'L:A32NX_EFIS_L_ND_RANGE' : 'L:A32NX_EFIS_R_ND_RANGE', 'number', 100);
	  const [modeIndex] = useSimVar(displayIndex === 1 ? 'L:A32NX_EFIS_L_ND_MODE' : 'L:A32NX_EFIS_R_ND_MODE', 'number', 100);
	  const [modeChangeShown, setModeChangeShown] = react.useState(false);
	  const [rangeChangeShown, setRangeChangeShown] = react.useState(false);
	  const firstModeUpdate = react.useRef(true);
	  const firstRangeUpdate = react.useRef(true);
	  react.useEffect(() => {
	    if (firstModeUpdate.current) {
	      firstModeUpdate.current = false;
	      return () => {};
	    }

	    setModeChangeShown(true);
	    const timeout = setTimeout(() => {
	      setModeChangeShown(false);
	    }, 500); // TODO looks like this depends on range or number of symbols IRL

	    return () => clearTimeout(timeout);
	  }, [modeIndex]);
	  react.useEffect(() => {
	    if (firstRangeUpdate.current) {
	      firstRangeUpdate.current = false;
	      return () => {};
	    } // RANGE CHANGE has priority over MODE CHANGE


	    if (modeChangeShown) {
	      setModeChangeShown(false);
	    }

	    setRangeChangeShown(true);
	    const timeout = setTimeout(() => {
	      setRangeChangeShown(false);
	    }, 500); // TODO looks like this depends on range or number of symbols IRL

	    return () => clearTimeout(timeout);
	  }, [rangeIndex]);
	  const [symbols, setSymbols] = react.useState([]);
	  useFlowSyncEvent("A32NX_EFIS_".concat(side, "_SYMBOLS"), react.useCallback((_topic, data) => {
	    if (data) {
	      setSymbols(data);
	    }
	  }, []));
	  return /*#__PURE__*/jsxRuntime.jsxs(DisplayUnit, {
	    electricitySimvar: displayIndex === 1 ? 'L:A32NX_ELEC_AC_ESS_BUS_IS_POWERED' : 'L:A32NX_ELEC_AC_2_BUS_IS_POWERED',
	    potentiometerIndex: displayIndex === 1 ? 89 : 91,
	    children: [/*#__PURE__*/jsxRuntime.jsx(TerrainMapProvider, {
	      side: side
	    }), /*#__PURE__*/jsxRuntime.jsx(FlightPlanProvider, {
	      children: /*#__PURE__*/jsxRuntime.jsxs("svg", {
	        className: "nd-svg",
	        version: "1.1",
	        viewBox: "0 0 768 768",
	        children: [/*#__PURE__*/jsxRuntime.jsx(SpeedIndicator, {
	          adrs: airDataReferenceSource,
	          irs: inertialReferenceSource
	        }), /*#__PURE__*/jsxRuntime.jsx(WindIndicator, {
	          adrs: airDataReferenceSource,
	          irs: inertialReferenceSource
	        }), /*#__PURE__*/jsxRuntime.jsx(LnavStatus, {}), modeIndex === Mode.PLAN && /*#__PURE__*/jsxRuntime.jsx(PlanMode, {
	          adirsAlign: adirsAlign,
	          rangeSetting: rangeSettings[rangeIndex],
	          symbols: symbols,
	          side: side,
	          ppos: ppos,
	          mapHidden: modeChangeShown || rangeChangeShown
	        }), modeIndex === Mode.ARC && /*#__PURE__*/jsxRuntime.jsx(ArcMode, {
	          adirsAlign: adirsAlign,
	          rangeSetting: rangeSettings[rangeIndex],
	          symbols: symbols,
	          side: side,
	          ppos: ppos,
	          mapHidden: modeChangeShown || rangeChangeShown
	        }), (modeIndex === Mode.ROSE_ILS || modeIndex === Mode.ROSE_VOR || modeIndex === Mode.ROSE_NAV) && /*#__PURE__*/jsxRuntime.jsx(RoseMode, {
	          adirsAlign: adirsAlign,
	          rangeSetting: rangeSettings[rangeIndex],
	          symbols: symbols,
	          side: side,
	          ppos: ppos,
	          mode: modeIndex,
	          mapHidden: modeChangeShown || rangeChangeShown
	        }), /*#__PURE__*/jsxRuntime.jsx(Chrono, {
	          side: side
	        }), /*#__PURE__*/jsxRuntime.jsx(NavigationDisplayMessages, {
	          adirsAlign: adirsAlign,
	          mode: modeIndex,
	          modeChangeShown: modeChangeShown,
	          rangeChangeShown: rangeChangeShown
	        }), adirsAlign && modeIndex !== Mode.PLAN && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
	          children: [/*#__PURE__*/jsxRuntime.jsx(RadioNavInfo, {
	            index: 1,
	            side: side
	          }), /*#__PURE__*/jsxRuntime.jsx(RadioNavInfo, {
	            index: 2,
	            side: side
	          })]
	        }), /*#__PURE__*/jsxRuntime.jsx(TcasWxrMessages, {
	          modeIndex: modeIndex
	        }), /*#__PURE__*/jsxRuntime.jsx(FMMessages, {
	          modeIndex: modeIndex,
	          side: side
	        })]
	      })
	    })]
	  });
	};

	render( /*#__PURE__*/jsxRuntime.jsx(NavigationDisplay, {}));

})();

    </script>
    <style id="ND_BUNDLED_STYLE">
        /* same deal as above */
        .SelfTest {
  position: absolute;
  left: 0%;
  top: 0%;
  width: 100%;
  height: 100%;
  border: none;
}

.SelfTestBackground {
  fill: #040405;
}

.SelfTestText {
  font-size: 24px;
  fill: #00ff00;
  text-anchor: middle;
  font-family: "Ecam", monospace;
}
.BacklightBleed {
  content: "";
  width: 100%;
  height: 100%;
  position: absolute;
  z-index: 998;
  opacity: 1;
  background-color: rgba(0, 0, 255, 0.035);
  box-shadow: inset 0px 0px 30px 10px rgba(0, 76, 255, 0.08);
}
@font-face {
  font-family: "Ecam";
  src: url("/A318_Fonts/A318_ECAMFontRegular.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}
@font-face {
  font-family: "NDChrono";
  src: url("/A318_Fonts/A318_NDChrono.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}
.nd-svg {
  position: absolute;
  width: 768px;
  height: 768px;
  background: #040405;
  font-family: "Ecam", monospace !important;
}

.GtLayer {
  -webkit-transform: rotateX(0deg);
}

.MiddleAlign {
  text-anchor: middle;
}

.Magenta {
  fill: none;
  stroke: #ff94ff;
}

.Magenta.Fill {
  fill: #ff94ff;
  stroke: none;
}

.Magenta text,
text.Magenta {
  fill: #ff94ff;
  stroke: none;
}

.Cyan {
  fill: none;
  stroke: #00ffff;
}

.Cyan.Fill {
  fill: #00ffff;
  stroke: none;
}

.Cyan text,
text.Cyan {
  fill: #00ffff;
  stroke: none;
}

tspan.Cyan {
  fill: #00ffff;
  stroke: none;
}

.White {
  fill: none;
  stroke: #ffffff;
}

.White.Fill {
  fill: #ffffff;
  stroke: none;
}

.White text,
text.White {
  fill: #ffffff;
  stroke: none;
}

.Green {
  stroke: #00ff00;
  fill: none;
}

.Green.Fill {
  fill: #00ff00;
  stroke: none;
}

.Green text,
text.Green {
  fill: #00ff00;
  stroke: none;
}

.Amber {
  stroke: #e68000;
  fill: none;
}

.Amber text,
text.Amber {
  fill: #e68000;
  stroke: none;
}

.Yellow {
  stroke: #ffff00;
  fill: none;
}

.Yellow.Fill {
  fill: #ffff00;
  stroke: none;
}

.Yellow text,
text.Yellow {
  fill: #ffff00;
  stroke: none;
}

.Red {
  stroke: #ff0000;
  fill: none;
}

.Red.Fill {
  fill: #ff0000;
  stroke: none;
}

.Red text,
text.Red {
  fill: #ff0000;
  stroke: none;
}

.Grey.Fill {
  fill: #787878;
  stroke: none;
}

.BackgroundFill {
  fill: #040405;
}

path.rounded {
  stroke-linecap: round;
  stroke-linejoin: round;
}

text.shadow {
  stroke: #040405;
  stroke-width: 1px;
  paint-order: stroke;
}

circle.shadow,
line.shadow,
path.shadow,
rect.shadow {
  stroke: #040405;
  fill: none;
}

.chrono {
  font-family: "NDChrono", monospace !important;
}
    </style>
</script>

<script type="text/html" import-script="/JS/dataStorage.js" import-async="false"></script>
,<script type="text/html" import-script="/Pages/VCockpit/Instruments/FlightElements/A318_Waypoint.js" import-async="false"></script>
,<script type="text/html" import-script="/Pages/A318_Core/math.js" import-async="false"></script>
,<script type="text/html" import-script="/JS/A318_Util.js" import-async="false"></script>
,<script type="text/html" import-script="/JS/fmgc/A318_LzUtf8.js" import-async="false"></script>

<script type="text/html" import-script="/Pages/VCockpit/Instruments/A318ceoCFM/ND/template.js" import-async="false"></script>
