(() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

  // ../node_modules/@microsoft/msfs-sdk/msfssdk.js
  var SimVarValueType;
  (function(SimVarValueType2) {
    SimVarValueType2["Number"] = "number";
    SimVarValueType2["Percent"] = "percent";
    SimVarValueType2["Degree"] = "degrees";
    SimVarValueType2["Knots"] = "knots";
    SimVarValueType2["Feet"] = "feet";
    SimVarValueType2["Meters"] = "meters";
    SimVarValueType2["FPM"] = "feet per minute";
    SimVarValueType2["Radians"] = "radians";
    SimVarValueType2["InHG"] = "inches of mercury";
    SimVarValueType2["MB"] = "Millibars";
    SimVarValueType2["Bool"] = "bool";
    SimVarValueType2["Celsius"] = "celsius";
    SimVarValueType2["MHz"] = "MHz";
    SimVarValueType2["KHz"] = "KHz";
    SimVarValueType2["NM"] = "nautical mile";
    SimVarValueType2["String"] = "string";
    SimVarValueType2["RPM"] = "Rpm";
    SimVarValueType2["PPH"] = "Pounds per hour";
    SimVarValueType2["GPH"] = "gph";
    SimVarValueType2["Farenheit"] = "farenheit";
    SimVarValueType2["PSI"] = "psi";
    SimVarValueType2["GAL"] = "gallons";
    SimVarValueType2["LBS"] = "pounds";
    SimVarValueType2["Hours"] = "Hours";
    SimVarValueType2["Volts"] = "Volts";
    SimVarValueType2["Amps"] = "Amperes";
    SimVarValueType2["Seconds"] = "seconds";
    SimVarValueType2["Enum"] = "enum";
    SimVarValueType2["LLA"] = "latlonalt";
    SimVarValueType2["MetersPerSecond"] = "meters per second";
    SimVarValueType2["Mach"] = "mach";
    SimVarValueType2["Pounds"] = "pounds";
    SimVarValueType2["SlugsPerCubicFoot"] = "slug per cubic foot";
  })(SimVarValueType || (SimVarValueType = {}));
  var latlonaltRegEx = new RegExp(/latlonalt/i);
  var latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
  var pbhRegex = new RegExp(/pbh/i);
  var pid_structRegex = new RegExp(/pid_struct/i);
  var xyzRegex = new RegExp(/xyz/i);
  var stringRegex = new RegExp(/string/i);
  var boolRegex = new RegExp(/boolean|bool/i);
  var numberRegex = new RegExp(/number/i);
  var defaultSource = "";
  SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
      if (simvar) {
        let output;
        const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
        if (registeredID >= 0) {
          if (numberRegex.test(unit)) {
            output = simvar.getValueReg(registeredID);
          } else if (stringRegex.test(unit)) {
            output = simvar.getValueReg_String(registeredID);
          } else if (latlonaltRegEx.test(unit)) {
            output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
          } else if (latlonaltpbhRegex.test(unit)) {
            output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
          } else if (pbhRegex.test(unit)) {
            output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
          } else if (pid_structRegex.test(unit)) {
            output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
          } else if (xyzRegex.test(unit)) {
            output = new XYZ(simvar.getValue_XYZ(name, dataSource));
          } else {
            output = simvar.getValueReg(registeredID);
          }
        }
        return output;
      } else {
        console.warn("SimVar handler is not defined (" + name + ")");
      }
    } catch (error) {
      console.warn("ERROR ", error, " GetSimVarValue " + name + " unit : " + unit);
      return null;
    }
    return null;
  };
  SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == void 0) {
      console.warn(name + " : Trying to set a null value");
      return Promise.resolve();
    }
    try {
      if (simvar) {
        const regID = SimVar.GetRegisteredId(name, unit, dataSource);
        if (regID >= 0) {
          if (stringRegex.test(unit)) {
            return Coherent.call("setValueReg_String", regID, value);
          } else if (boolRegex.test(unit)) {
            return Coherent.call("setValueReg_Bool", regID, !!value);
          } else if (numberRegex.test(unit)) {
            return Coherent.call("setValueReg_Number", regID, value);
          } else if (latlonaltRegEx.test(unit)) {
            return Coherent.call("setValue_LatLongAlt", name, value, dataSource);
          } else if (latlonaltpbhRegex.test(unit)) {
            return Coherent.call("setValue_LatLongAltPBH", name, value, dataSource);
          } else if (pbhRegex.test(unit)) {
            return Coherent.call("setValue_PBH", name, value, dataSource);
          } else if (pid_structRegex.test(unit)) {
            return Coherent.call("setValue_PID_STRUCT", name, value, dataSource);
          } else if (xyzRegex.test(unit)) {
            return Coherent.call("setValue_XYZ", name, value, dataSource);
          } else {
            return Coherent.call("setValueReg_Number", regID, value);
          }
        }
      } else {
        console.warn("SimVar handler is not defined");
      }
    } catch (error) {
      console.warn("error SetSimVarValue " + error);
    }
    return Promise.resolve();
  };
  var NumberUnit = class {
    constructor(number, unit) {
      this._number = number;
      this._unit = unit;
      this.readonly = new NumberUnitReadOnly(this);
    }
    get number() {
      return this._number;
    }
    get unit() {
      return this._unit;
    }
    toNumberOfThisUnit(value, unit) {
      if (typeof value !== "number" && this.unit.canConvert(value.unit)) {
        return this.unit.convertFrom(value.number, value.unit);
      }
      if (typeof value === "number" && (!unit || this.unit.canConvert(unit))) {
        return unit ? this.unit.convertFrom(value, unit) : value;
      }
      return void 0;
    }
    set(arg1, arg2) {
      const converted = this.toNumberOfThisUnit(arg1, arg2);
      if (converted !== void 0) {
        this._number = converted;
        return this;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number + converted, this.unit);
        } else {
          out = this;
          this._number += converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number - converted, this.unit);
        } else {
          out = this;
          this._number -= converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    scale(factor, out) {
      if (out) {
        return out.set(this.number * factor, this.unit);
      } else {
        this._number *= factor;
        return this;
      }
    }
    ratio(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted) {
        return this.number / converted;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    abs(out) {
      if (out) {
        return out.set(Math.abs(this.number), this.unit);
      } else {
        this._number = Math.abs(this._number);
        return this;
      }
    }
    asUnit(unit) {
      return this.unit.convertTo(this.number, unit);
    }
    compare(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        throw new Error("Invalid unit conversion attempted.");
      }
      const diff = this.number - converted;
      if (Math.abs(diff) < 1e-14) {
        return 0;
      }
      return Math.sign(diff);
    }
    equals(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        return false;
      }
      if (isNaN(converted) && this.isNaN()) {
        return true;
      }
      const diff = this.number - converted;
      return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    isNaN() {
      return isNaN(this.number);
    }
    copy() {
      return new NumberUnit(this.number, this.unit);
    }
  };
  var NumberUnitReadOnly = class {
    constructor(source) {
      this.source = source;
    }
    get number() {
      return this.source.number;
    }
    get unit() {
      return this.source.unit;
    }
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.add(arg1, arg2, out);
      } else {
        return this.source.add(arg1, out);
      }
    }
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.subtract(arg1, arg2, out);
      } else {
        return this.source.subtract(arg1, out);
      }
    }
    scale(factor, out) {
      return this.source.scale(factor, out);
    }
    ratio(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.ratio(arg1, arg2);
      } else {
        return this.source.ratio(arg1);
      }
    }
    abs(out) {
      return this.source.abs(out);
    }
    asUnit(unit) {
      return this.source.asUnit(unit);
    }
    compare(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.compare(arg1, arg2);
      } else {
        return this.source.compare(arg1);
      }
    }
    equals(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2);
      } else {
        return this.source.equals(arg1);
      }
    }
    isNaN() {
      return this.source.isNaN();
    }
    copy() {
      return this.source.copy();
    }
  };
  var AbstractUnit = class {
    constructor(name) {
      this.name = name;
    }
    canConvert(otherUnit) {
      return this.family === otherUnit.family;
    }
    createNumber(value) {
      return new NumberUnit(value, this);
    }
    equals(other) {
      return this.family === other.family && this.name === other.name;
    }
  };
  var SimpleUnit = class extends AbstractUnit {
    constructor(family, name, scaleFactor, zeroOffset = 0) {
      super(name);
      this.family = family;
      this.scaleFactor = scaleFactor;
      this.zeroOffset = zeroOffset;
    }
    canConvert(otherUnit) {
      return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
  };
  var CompoundUnit = class extends AbstractUnit {
    constructor(family, numerator, denominator, name) {
      if (name === void 0) {
        name = "";
        let i = 0;
        while (i < numerator.length - 1) {
          name += `${numerator[i++].name}-`;
        }
        name += `${numerator[i].name}`;
        if (denominator.length > 0) {
          name += " per ";
          i = 0;
          while (i < denominator.length - 1) {
            name += `${denominator[i++].name}-`;
          }
          name += `${denominator[i].name}`;
        }
      }
      super(name);
      this.family = family;
      this.numerator = Array.from(numerator);
      this.denominator = Array.from(denominator);
      this.numerator.sort((a, b) => a.family.localeCompare(b.family));
      this.denominator.sort((a, b) => a.family.localeCompare(b.family));
      this.scaleFactor = this.getScaleFactor();
    }
    getScaleFactor() {
      let factor = 1;
      factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
      factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
      return factor;
    }
    canConvert(otherUnit) {
      return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
  };
  var UnitFamily;
  (function(UnitFamily2) {
    UnitFamily2["Distance"] = "distance";
    UnitFamily2["Angle"] = "angle";
    UnitFamily2["Duration"] = "duration";
    UnitFamily2["Weight"] = "weight";
    UnitFamily2["Volume"] = "volume";
    UnitFamily2["Pressure"] = "pressure";
    UnitFamily2["Temperature"] = "temperature";
    UnitFamily2["TemperatureDelta"] = "temperature_delta";
    UnitFamily2["Speed"] = "speed";
    UnitFamily2["Acceleration"] = "acceleration";
    UnitFamily2["WeightFlux"] = "weight_flux";
    UnitFamily2["VolumeFlux"] = "volume_flux";
  })(UnitFamily || (UnitFamily = {}));
  var UnitType = class {
  };
  UnitType.METER = new SimpleUnit(UnitFamily.Distance, "meter", 1);
  UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, "foot", 0.3048);
  UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, "kilometer", 1e3);
  UnitType.MILE = new SimpleUnit(UnitFamily.Distance, "mile", 1609.34);
  UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, "nautical mile", 1852);
  UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, "great arc radian", 6378100);
  UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, "radian", 1);
  UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, "degree", Math.PI / 180);
  UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, "minute", Math.PI / 180 / 60);
  UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, "second", Math.PI / 180 / 3600);
  UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, "millisecond", 1e-3);
  UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, "second", 1);
  UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, "minute", 60);
  UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, "hour", 3600);
  UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, "kilogram", 1);
  UnitType.POUND = new SimpleUnit(UnitFamily.Weight, "pound", 0.453592);
  UnitType.TON = new SimpleUnit(UnitFamily.Weight, "ton", 907.185);
  UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, "tonne", 1e3);
  UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, "liter", 0.80283679);
  UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "gallon", 3.0390664);
  UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "imperial gallon", 3.6497683);
  UnitType.LITER = new SimpleUnit(UnitFamily.Volume, "liter", 1);
  UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, "gallon", 3.78541);
  UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, "hectopascal", 1);
  UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, "atmosphere", 1013.25);
  UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, "inch of mercury", 33.8639);
  UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, "millimeter of mercury", 1.33322);
  UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, "kelvin", 1, 0);
  UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, "\xB0 Celsius", 1, 273.15);
  UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, "\xB0 Fahrenheit", 5 / 9, 459.67);
  UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, "\xB0 Rankine", 5 / 9, 0);
  UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Celsius", 1);
  UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Fahrenheit", 5 / 9);
  UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], "knot");
  UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
  UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
  UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
  UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
  UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
  UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
  UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [new SimpleUnit(UnitFamily.Distance, "9.80665 meter", 9.80665)], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
  UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
  UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
  UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
  UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
  var BasePublisher = class {
    constructor(bus, pacer = void 0) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.publishActive = false;
      this.pacer = pacer;
    }
    startPublish() {
      this.publishActive = true;
    }
    stopPublish() {
      this.publishActive = false;
    }
    isPublishing() {
      return this.publishActive;
    }
    onUpdate() {
      return;
    }
    publish(topic, data, sync = false, isCached = true) {
      if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
        this.publisher.pub(topic, data, sync, isCached);
      }
    }
  };
  var SimVarPublisher = class extends BasePublisher {
    constructor(simVarMap, bus, pacer) {
      super(bus, pacer);
      this.resolvedSimVars = /* @__PURE__ */ new Map();
      this.indexedSimVars = /* @__PURE__ */ new Map();
      this.subscribed = /* @__PURE__ */ new Set();
      for (const [topic, entry] of simVarMap) {
        if (entry.indexed) {
          this.indexedSimVars.set(topic, entry);
          this.resolveIndexedSimVar(topic, entry);
        } else {
          this.resolvedSimVars.set(topic, entry);
        }
      }
      const handleSubscribedTopic = (topic) => {
        if (this.resolvedSimVars.has(topic)) {
          this.onTopicSubscribed(topic);
        } else {
          this.tryMatchIndexedSubscribedTopic(topic);
        }
      };
      this.bus.forEachSubscribedTopic(handleSubscribedTopic);
      this.bus.getSubscriber().on("event_bus_topic_first_sub").handle(handleSubscribedTopic);
    }
    tryMatchIndexedSubscribedTopic(topic) {
      if (this.indexedSimVars.size === 0) {
        return;
      }
      if (!SimVarPublisher.INDEXED_REGEX.test(topic)) {
        return;
      }
      const match = topic.match(SimVarPublisher.INDEXED_REGEX);
      const [, matchedTopic, index] = match;
      const entry = this.indexedSimVars.get(matchedTopic);
      if (entry) {
        this.onTopicSubscribed(this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index)));
      }
    }
    resolveIndexedSimVar(topic, entry, index) {
      const resolvedTopic = index === void 0 ? topic : `${topic}_${index}`;
      if (this.resolvedSimVars.has(resolvedTopic)) {
        return resolvedTopic;
      }
      this.resolvedSimVars.set(resolvedTopic, { name: entry.name.replace("#index#", `${index !== null && index !== void 0 ? index : 1}`), type: entry.type, map: entry.map });
      return resolvedTopic;
    }
    onTopicSubscribed(topic) {
      if (this.subscribed.has(topic)) {
        return;
      }
      this.subscribed.add(topic);
      if (this.publishActive) {
        this.publishTopic(topic);
      }
    }
    subscribe(data) {
      return;
    }
    unsubscribe(data) {
      return;
    }
    onUpdate() {
      for (const topic of this.subscribed.values()) {
        this.publishTopic(topic);
      }
    }
    publishTopic(topic) {
      const value = this.getValue(topic);
      if (value !== void 0) {
        this.publish(topic, value);
      }
    }
    getValue(topic) {
      const entry = this.resolvedSimVars.get(topic);
      if (entry === void 0) {
        return void 0;
      }
      return entry.map === void 0 ? this.getSimVarValue(entry) : entry.map(this.getSimVarValue(entry));
    }
    getSimVarValue(entry) {
      const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
      if (entry.type === SimVarValueType.Bool) {
        return svValue === 1;
      }
      return svValue;
    }
  };
  SimVarPublisher.INDEXED_REGEX = /(.*)_([1-9]\d*)$/;
  var AeroMath = class {
    static pressureAir(temperature, density) {
      return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    static densityAir(pressure, temperature) {
      return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    static temperatureAir(pressure, density) {
      return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    static soundSpeedAir(temperature) {
      return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    static totalPressureRatioAir(mach) {
      return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    static isaTemperature(altitude) {
      if (altitude < 11e3) {
        return 15 + Math.max(altitude, -610) * -65e-4;
      } else if (altitude < 2e4) {
        return -56.5;
      } else if (altitude < 32e3) {
        return -56.5 + (altitude - 2e4) * 1e-3;
      } else if (altitude < 47e3) {
        return -44.5 + (altitude - 32e3) * 28e-4;
      } else if (altitude < 51e3) {
        return -2.5;
      } else if (altitude < 71e3) {
        return -2.5 + (altitude - 51e3) * -28e-4;
      } else {
        return -58.5 + (Math.min(altitude, 8e4) - 71e3) * -2e-3;
      }
    }
    static isaPressure(altitude) {
      if (altitude < -610) {
        return 1099.15;
      } else if (altitude <= 11e3) {
        return 1013.25 * Math.pow(1 - 22558e-9 * altitude, 5.2558);
      } else if (altitude <= 2e4) {
        return 226.32 * Math.exp(-157686e-9 * (altitude - 11e3));
      } else if (altitude <= 32e3) {
        return 54.7499 * Math.pow(1 + 461574e-11 * (altitude - 2e4), -34.1627);
      } else if (altitude <= 47e3) {
        return 8.68058 * Math.pow(1 + 122458e-10 * (altitude - 32e3), -12.201);
      } else if (altitude <= 51e3) {
        return 1.10914 * Math.exp(-126225e-9 * (altitude - 47e3));
      } else if (altitude <= 71e3) {
        return 0.669439 * Math.pow(1 - 103455e-10 * (altitude - 51e3), 12.201);
      } else if (altitude <= 8e4) {
        return 0.039568 * Math.pow(1 - 931749e-11 * (altitude - 71e3), 17.0814);
      } else {
        return 88638e-7;
      }
    }
    static isaDensity(altitude, deltaIsa = 0) {
      return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    static soundSpeedIsa(altitude, deltaIsa = 0) {
      return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    static tasToMach(tas, soundSpeed) {
      return tas / soundSpeed;
    }
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
      return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static machToTas(mach, soundSpeed) {
      return mach * soundSpeed;
    }
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
      return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static casToMach(cas, pressure) {
      const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
      const impactPressure = 1013.25 * (Math.pow(1 + 0.2 * mach0 * mach0, 3.5) - 1);
      return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    static casToMachIsa(cas, altitude) {
      return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    static machToCas(mach, pressure) {
      const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
      return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    static machToCasIsa(mach, altitude) {
      return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    static casToTas(cas, pressure, temperature) {
      return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
      return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static tasToCas(tas, pressure, temperature) {
      return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
      return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    static flowCoefFromForce(force, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return force / (dynamicPressure * area);
    }
    static flowForceFromCoef(coef, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return coef * dynamicPressure * area;
    }
  };
  AeroMath.R = 8.314462618153;
  AeroMath.R_AIR = 287.057;
  AeroMath.GAMMA_AIR = 1.4;
  AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
  AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.lift = AeroMath.flowForceFromCoef;
  AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.drag = AeroMath.flowForceFromCoef;
  var BitFlags = class {
    static createFlag(index) {
      if (index < 0 || index > 32) {
        throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
      }
      return 1 << index;
    }
    static not(flags, mask = ~0) {
      return flags ^ mask;
    }
    static union(...flags) {
      let result = 0;
      const len = flags.length;
      for (let i = 0; i < len; i++) {
        result |= flags[i];
      }
      return result;
    }
    static intersection(...flags) {
      const len = flags.length;
      if (len === 0) {
        return 0;
      }
      let result = flags[0];
      for (let i = 1; i < len; i++) {
        result &= flags[i];
      }
      return result;
    }
    static set(flags, valuesToSet, mask) {
      return flags & ~mask | valuesToSet & mask;
    }
    static isAny(flags, conditions) {
      return (flags & conditions) !== 0;
    }
    static isAll(flags, conditions) {
      return (flags & conditions) === conditions;
    }
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
      startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0, 0, 32);
      endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = 32, 0, 32);
      for (let i = startIndex; i < endIndex; i++) {
        const value = (flags & 1 << i) !== 0;
        if (valueFilter === void 0 || valueFilter === value) {
          callback(value, i, flags);
        }
      }
    }
  };
  var HandlerSubscription = class {
    constructor(handler, initialNotifyFunc, onDestroy) {
      this.handler = handler;
      this.initialNotifyFunc = initialNotifyFunc;
      this.onDestroy = onDestroy;
      this._isAlive = true;
      this._isPaused = false;
      this.canInitialNotify = initialNotifyFunc !== void 0;
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    initialNotify() {
      if (!this._isAlive) {
        throw new Error("HandlerSubscription: cannot notify a dead Subscription.");
      }
      this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot pause a dead Subscription.");
      }
      this._isPaused = true;
      return this;
    }
    resume(initialNotify = false) {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot resume a dead Subscription.");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      if (initialNotify) {
        this.initialNotify();
      }
      return this;
    }
    destroy() {
      if (!this._isAlive) {
        return;
      }
      this._isAlive = false;
      this.onDestroy && this.onDestroy(this);
    }
  };
  var SubscribablePipe = class extends HandlerSubscription {
    constructor(from, to, arg3, arg4) {
      let handler;
      let onDestroy;
      if (typeof arg4 === "function") {
        handler = (fromVal) => {
          to.set(arg3(fromVal, to.get()));
        };
        onDestroy = arg4;
      } else {
        handler = (fromVal) => {
          to.set(fromVal);
        };
        onDestroy = arg3;
      }
      super(handler, (sub) => {
        sub.handler(from.get());
      }, onDestroy);
    }
  };
  var AbstractSubscribable = class {
    constructor() {
      this.isSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.notifySubscription.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    notify() {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            this.notifySubscription(sub);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`AbstractSubscribable: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    notifySubscription(sub) {
      sub.handler(this.get());
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    map(fn, equalityFunc, mutateFunc, initialVal) {
      return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var MappedSubscribableClass = class extends AbstractSubscribable {
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
      super();
      this.input = input;
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.input.get()));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.input.get());
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSub = this.input.sub((inputValue) => {
        this.updateValue(inputValue);
      }, true);
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    updateValue(inputValue) {
      const value = this.mapFunc(inputValue, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    get() {
      return this.value;
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot pause a dead subscribable");
      }
      if (this._isPaused) {
        return this;
      }
      this.inputSub.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot resume a dead subscribable");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this.inputSub.resume(true);
      return this;
    }
    destroy() {
      this._isAlive = false;
      this.inputSub.destroy();
    }
  };
  var NumberUnitSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    static createFromNumberUnit(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var Vec2Math = class {
    static create(x, y) {
      const vec = new Float64Array(2);
      if (x !== void 0 && y !== void 0) {
        vec[0] = x;
        vec[1] = y;
      }
      return vec;
    }
    static theta(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    static set(x, y, vec) {
      vec[0] = x;
      vec[1] = y;
      return vec;
    }
    static setFromPolar(r, theta, vec) {
      vec[0] = r * Math.cos(theta);
      vec[1] = r * Math.sin(theta);
      return vec;
    }
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      return out;
    }
    static abs(v1) {
      return Math.hypot(v1[0], v1[1]);
    }
    static normalize(v1, out) {
      const mag = Vec2Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      return out;
    }
    static normal(v1, out, counterClockwise = false) {
      const x = v1[0];
      const y = v1[1];
      if (!counterClockwise) {
        out[0] = y;
        out[1] = -x;
      } else {
        out[0] = -y;
        out[1] = x;
      }
      return out;
    }
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    static copy(from, to) {
      return Vec2Math.set(from[0], from[1], to);
    }
    static pointWithinPolygon(polygon, point) {
      let k = 0;
      let f = 0;
      let u1 = 0;
      let v1 = 0;
      let u2 = 0;
      let v2 = 0;
      let currentP = null;
      let nextP = null;
      const x = point[0];
      const y = point[1];
      const contourLen = polygon.length - 1;
      currentP = polygon[0];
      if (currentP[0] !== polygon[contourLen][0] && currentP[1] !== polygon[contourLen][1]) {
        throw new Error("First and last coordinates in a ring must be the same");
      }
      u1 = currentP[0] - x;
      v1 = currentP[1] - y;
      for (let i = 0; i < polygon.length - 1; i++) {
        nextP = polygon[i + 1];
        v2 = nextP[1] - y;
        if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
          currentP = nextP;
          v1 = v2;
          u1 = currentP[0] - x;
          continue;
        }
        u2 = nextP[0] - point[0];
        if (v2 > 0 && v1 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f > 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v1 > 0 && v2 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f < 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v2 === 0 && v1 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 === 0) {
          if (u2 <= 0 && u1 >= 0) {
            return void 0;
          } else if (u1 <= 0 && u2 >= 0) {
            return void 0;
          }
        }
        currentP = nextP;
        v1 = v2;
        u1 = u2;
      }
      if (k % 2 === 0) {
        return false;
      }
      return true;
    }
  };
  var Vec3Math = class {
    static create(x, y, z) {
      const vec = new Float64Array(3);
      if (x !== void 0 && y !== void 0 && z !== void 0) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
      }
      return vec;
    }
    static theta(vec) {
      return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    static phi(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    static set(x, y, z, vec) {
      vec[0] = x;
      vec[1] = y;
      vec[2] = z;
      return vec;
    }
    static setFromSpherical(r, theta, phi, vec) {
      const sinTheta = Math.sin(theta);
      vec[0] = sinTheta * Math.cos(phi);
      vec[1] = sinTheta * Math.sin(phi);
      vec[2] = Math.cos(theta);
      return vec;
    }
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      out[2] = v1[2] + v2[2];
      return out;
    }
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      out[2] = v1[2] - v2[2];
      return out;
    }
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    static cross(v1, v2, out) {
      const x1 = v1[0];
      const y1 = v1[1];
      const z1 = v1[2];
      const x2 = v2[0];
      const y2 = v2[1];
      const z2 = v2[2];
      out[0] = y1 * z2 - z1 * y2;
      out[1] = z1 * x2 - x1 * z2;
      out[2] = x1 * y2 - y1 * x2;
      return out;
    }
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      out[2] = v1[2] * scalar;
      return out;
    }
    static abs(v1) {
      return Math.hypot(v1[0], v1[1], v1[2]);
    }
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      out[2] = v1[2] / mag;
      return out;
    }
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    static copy(from, to) {
      return Vec3Math.set(from[0], from[1], from[2], to);
    }
  };
  var VecNMath = class {
    static create(length, ...components) {
      const vec = new Float64Array(length);
      for (let i = 0; i < length && components.length; i++) {
        vec[i] = components[i];
      }
      return vec;
    }
    static set(vec, ...components) {
      for (let i = 0; i < vec.length && components.length; i++) {
        vec[i] = components[i];
      }
      return vec;
    }
    static abs(vec) {
      return Math.hypot(...vec);
    }
    static dot(v1, v2) {
      if (v1.length !== v2.length) {
        throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
      }
      let dot = 0;
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        dot += v1[i] * v2[i];
      }
      return dot;
    }
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        out[i] = v1[i] / mag;
      }
      return out;
    }
    static equals(vec1, vec2) {
      if (vec1.length !== vec2.length) {
        return false;
      }
      for (let i = 0; i < vec1.length; i++) {
        if (vec1[i] !== vec2[i]) {
          return false;
        }
      }
      return true;
    }
    static copy(from, to) {
      if (from.length !== to.length) {
        throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
      }
      to.set(from);
      return to;
    }
  };
  var Vec2Subject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new Vec2Subject(initialVal);
    }
    static createFromVector(initialVal) {
      return new Vec2Subject(initialVal);
    }
    get() {
      return this.value;
    }
    set(arg1, arg2) {
      let x, y;
      if (typeof arg1 === "number") {
        x = arg1;
        y = arg2;
      } else {
        x = arg1[0];
        y = arg1[1];
      }
      const equals = x === this.value[0] && y === this.value[1];
      if (!equals) {
        Vec2Math.set(x, y, this.value);
        this.notify();
      }
    }
  };
  var VecNSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new VecNSubject(initialVal);
    }
    static createFromVector(initialVal) {
      return new VecNSubject(initialVal);
    }
    get() {
      return this.value;
    }
    set(arg1, ...args) {
      let array;
      if (typeof arg1 === "number") {
        array = args;
        args.unshift(arg1);
      } else {
        array = arg1;
      }
      if (array.length > this.value.length) {
        throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
      }
      let equals = true;
      const len = array.length;
      for (let i = 0; i < len; i++) {
        if (array[i] !== this.value[i]) {
          equals = false;
          break;
        }
      }
      if (!equals) {
        this.value.set(array);
        this.notify();
      }
    }
  };
  var Subject = class extends AbstractSubscribable {
    constructor(value, equalityFunc, mutateFunc) {
      super();
      this.value = value;
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.isMutableSubscribable = true;
    }
    static create(v, equalityFunc, mutateFunc) {
      return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    notifySub(sub) {
      sub(this.value);
    }
    set(value) {
      if (!this.equalityFunc(value, this.value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    apply(value) {
      let changed = false;
      for (const prop in value) {
        changed = value[prop] !== this.value[prop];
        if (changed) {
          break;
        }
      }
      Object.assign(this.value, value);
      changed && this.notify();
    }
    notify() {
      super.notify();
    }
    get() {
      return this.value;
    }
  };
  var Transform2D = class {
    constructor() {
      this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    getParameters() {
      return this.array;
    }
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
      let scaleX = arg1;
      if (arg1 instanceof Transform2D) {
        [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewX;
      array[2] = translateX;
      array[3] = skewY;
      array[4] = scaleY;
      array[5] = translateY;
      return this;
    }
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    setScaleY(value) {
      this.array[4] = value;
      return this;
    }
    setScale(x, y) {
      this.array[0] = x;
      this.array[4] = y;
      return this;
    }
    setSkewX(value) {
      this.array[1] = value;
      return this;
    }
    setSkewY(value) {
      this.array[3] = value;
      return this;
    }
    setTranslateX(value) {
      this.array[2] = value;
      return this;
    }
    setTranslateY(value) {
      this.array[5] = value;
      return this;
    }
    setTranslate(x, y) {
      this.array[2] = x;
      this.array[5] = y;
      return this;
    }
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_10 = array[3];
      const e_11 = array[4];
      const e_12 = array[5];
      const i_00 = e_11;
      const i_01 = -e_10;
      const i_10 = -e_01;
      const i_11 = e_00;
      const i_20 = e_01 * e_12 - e_02 * e_11;
      const i_21 = -(e_00 * e_12 - e_02 * e_10);
      const det = e_00 * i_00 + e_01 * i_01;
      return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    copy() {
      return new Transform2D().set(this);
    }
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
      const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
      return Vec2Math.set(x, y, out);
    }
    offsetOrigin(x, y) {
      Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
      Transform2D.offsetOriginCache[1] = this;
      Transform2D.offsetOriginCache[2].toTranslation(x, y);
      return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    toIdentity() {
      return this.set(1, 0, 0, 0, 1, 0);
    }
    toTranslation(x, y) {
      return this.set(1, 0, x, 0, 1, y);
    }
    toScale(x, y, originX, originY) {
      this.set(x, 0, 0, 0, y, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    toRotation(theta, originX, originY) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, -sin, 0, sin, cos, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    toReflection(theta, originX, originY) {
      const sin = Math.sin(2 * theta);
      const cos = Math.cos(2 * theta);
      this.set(cos, sin, 0, sin, -cos, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    addTranslation(x, y, order = "after") {
      if (order === "before") {
        Transform2D.addCache[0].toTranslation(x, y);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        Transform2D.addCache[1].toTranslation(x, y);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addScale(x, y, arg3, arg4, arg5) {
      let originX, originY, order;
      if (typeof arg3 === "number") {
        originX = arg3;
        originY = arg4;
        order = arg5;
      } else {
        order = arg3;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addRotation(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addReflection(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform2D.concatCache[0];
      const newTransform = Transform2D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 2; j++) {
            newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform2D.offsetOriginCache = [new Transform2D(), void 0, new Transform2D()];
  Transform2D.addCache = [new Transform2D(), new Transform2D()];
  Transform2D.concatCache = [new Transform2D(), new Transform2D()];
  var Transform3D = class {
    constructor() {
      this.array = new Float64Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    }
    getParameters() {
      return this.array;
    }
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
      let scaleX = arg1;
      if (arg1 instanceof Transform3D) {
        [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewXY;
      array[2] = skewXZ;
      array[3] = translateX;
      array[4] = skewYX;
      array[5] = scaleY;
      array[6] = skewYZ;
      array[7] = translateY;
      array[8] = skewZX;
      array[9] = skewZY;
      array[10] = scaleZ;
      array[11] = translateZ;
      return this;
    }
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    setScaleY(value) {
      this.array[5] = value;
      return this;
    }
    setScaleZ(value) {
      this.array[10] = value;
      return this;
    }
    setScale(x, y, z) {
      this.array[0] = x;
      this.array[5] = y;
      this.array[10] = z;
      return this;
    }
    setSkewX(y, z) {
      this.array[1] = y;
      this.array[2] = z;
      return this;
    }
    setSkewY(x, z) {
      this.array[4] = x;
      this.array[6] = z;
      return this;
    }
    setSkewZ(x, y) {
      this.array[8] = x;
      this.array[9] = y;
      return this;
    }
    setTranslateX(value) {
      this.array[3] = value;
      return this;
    }
    setTranslateY(value) {
      this.array[7] = value;
      return this;
    }
    setTranslateZ(value) {
      this.array[11] = value;
      return this;
    }
    setTranslate(x, y, z) {
      this.array[3] = x;
      this.array[7] = y;
      this.array[11] = z;
      return this;
    }
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_03 = array[3];
      const e_10 = array[4];
      const e_11 = array[5];
      const e_12 = array[6];
      const e_13 = array[7];
      const e_20 = array[8];
      const e_21 = array[9];
      const e_22 = array[10];
      const e_23 = array[11];
      const c_00 = e_11 * e_22 - e_12 * e_21;
      const c_01 = e_12 * e_20 - e_10 * e_22;
      const c_02 = e_10 * e_21 - e_11 * e_20;
      const c_10 = e_02 * e_21 - e_01 * e_22;
      const c_11 = e_00 * e_22 - e_02 * e_20;
      const c_12 = e_01 * e_20 - e_00 * e_21;
      const c_20 = e_01 * e_12 - e_02 * e_11;
      const c_21 = e_02 * e_10 - e_00 * e_12;
      const c_22 = e_00 * e_11 - e_01 * e_10;
      const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
      if (det === 0) {
        throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
      }
      const i_00 = c_00 / det;
      const i_01 = c_10 / det;
      const i_02 = c_20 / det;
      const i_10 = c_01 / det;
      const i_11 = c_11 / det;
      const i_12 = c_21 / det;
      const i_20 = c_02 / det;
      const i_21 = c_12 / det;
      const i_22 = c_22 / det;
      const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
      const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
      const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
      return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    copy() {
      return new Transform3D().set(this);
    }
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
      const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
      const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
      return Vec3Math.set(x, y, z, out);
    }
    offsetOrigin(x, y, z) {
      Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
      Transform3D.offsetOriginCache[1] = this;
      Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
      return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    toIdentity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    toTranslation(x, y, z) {
      return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    toScale(x, y, z, originX, originY, originZ) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationX(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationY(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationZ(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
      const abs = Math.hypot(axisX, axisY, axisZ);
      const ux = axisX / abs;
      const uy = axisY / abs;
      const uz = axisZ / abs;
      const ux_uy = ux * uy;
      const ux_uz = ux * uz;
      const uy_uz = uy * uz;
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      const cosCompl = 1 - cos;
      this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    addTranslation(x, y, z, order = "after") {
      if (order === "before") {
        Transform3D.addCache[0].toTranslation(x, y, z);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        Transform3D.addCache[1].toTranslation(x, y, z);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
      let originX, originY, originZ, order;
      if (typeof arg4 === "number") {
        originX = arg4;
        originY = arg5;
        originZ = arg6;
        order = arg7;
      } else {
        order = arg4;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationX(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationY(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
      let originX, originY, originZ, order;
      if (typeof arg5 === "number") {
        originX = arg5;
        originY = arg6;
        originZ = arg7;
        order = arg8;
      } else {
        order = arg5;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform3D.concatCache[0];
      const newTransform = Transform3D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 3; j++) {
            newArray[j * 4 + i] = oldArray[i] * nextArray[j * 4] + oldArray[4 + i] * nextArray[j * 4 + 1] + oldArray[8 + i] * nextArray[j * 4 + 2] + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform3D.offsetOriginCache = [new Transform3D(), void 0, new Transform3D()];
  Transform3D.addCache = [new Transform3D(), new Transform3D()];
  Transform3D.concatCache = [new Transform3D(), new Transform3D()];
  var TransformPerspective = class {
    constructor() {
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create(0, 0, 1);
      this.cameraPosTransform = new Transform3D();
      this.cameraRotationTransform = new Transform3D();
      this.cameraRotationInverseTransform = new Transform3D();
      this.allCameraTransforms = [this.cameraPosTransform, this.cameraRotationInverseTransform];
      this.fullTransform = new Transform3D();
    }
    getCameraPosition() {
      return this.cameraPos;
    }
    getCameraRotation() {
      return this.cameraRotationTransform;
    }
    getSurfacePosition() {
      return this.cameraPos;
    }
    set(arg1, arg2, arg3) {
      if (arg1 instanceof Float64Array) {
        this._setCameraPosition(arg1);
        this._setCameraRotation(arg2);
        this.setSurfacePosition(arg3);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
      } else {
        return this.set(arg1.getCameraPosition(), arg1.getCameraRotation(), arg1.getSurfacePosition());
      }
    }
    _setCameraPosition(cameraPos) {
      Vec3Math.copy(cameraPos, this.cameraPos);
      this.cameraPosTransform.toTranslation(-cameraPos[0], -cameraPos[1], -cameraPos[2]);
    }
    _setCameraRotation(cameraRotation) {
      this.cameraRotationTransform.set(cameraRotation);
      this.cameraRotationInverseTransform.set(cameraRotation).invert();
    }
    setCameraPosition(cameraPos) {
      this._setCameraPosition(cameraPos);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    setCameraRotation(cameraRotation) {
      this._setCameraRotation(cameraRotation);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    setSurfacePosition(surfacePos) {
      Vec3Math.copy(surfacePos, this.surfacePos);
      return this;
    }
    copy() {
      return new TransformPerspective().set(this);
    }
    apply(vec, out) {
      const transformedVec = this.fullTransform.apply(vec, TransformPerspective.vec3Cache[0]);
      if (Vec3Math.abs(transformedVec) < 1e-7) {
        return Vec2Math.set(0, 0, out);
      }
      if (transformedVec[2] < 0) {
        return Vec2Math.set(NaN, NaN, out);
      }
      const ratio = this.surfacePos[2] / transformedVec[2];
      return Vec2Math.set(transformedVec[0] * ratio + this.surfacePos[0], transformedVec[1] * ratio + this.surfacePos[1], out);
    }
  };
  TransformPerspective.vec3Cache = [Vec3Math.create()];
  var MathUtils = class {
    static clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    static round(value, precision = 1) {
      return Math.round(value / precision) * precision;
    }
    static diffAngle(start, end, directional = true) {
      const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
      return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      if (x0 !== x1 && y0 !== y1) {
        const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
        return fraction * (y1 - y0) + y0;
      } else {
        return y0;
      }
    }
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      const length = Math.min(y0.length, y1.length, out.length);
      for (let i = 0; i < length; i++) {
        out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
      }
      return out;
    }
  };
  MathUtils.TWO_PI = Math.PI * 2;
  MathUtils.HALF_PI = Math.PI / 2;
  var ExpSmoother = class {
    constructor(tau, initial = null, dtThreshold = Infinity) {
      this.tau = tau;
      this.dtThreshold = dtThreshold;
      this.lastValue = initial;
    }
    last() {
      return this.lastValue;
    }
    next(raw, dt) {
      let next;
      if (this.tau > 0 && this.lastValue !== null) {
        const factor = this.calculateFactor(dt);
        next = ExpSmoother.smooth(raw, this.lastValue, factor);
      } else {
        next = raw;
      }
      this.lastValue = next;
      return next;
    }
    calculateFactor(dt) {
      if (dt > this.dtThreshold) {
        return 0;
      } else {
        return Math.exp(-dt / this.tau);
      }
    }
    reset(value) {
      return this.lastValue = value !== null && value !== void 0 ? value : null;
    }
    static smooth(value, last, factor) {
      return value * (1 - factor) + last * factor;
    }
  };
  var GeoPointReadOnly = class {
    constructor(source) {
      this.source = source;
    }
    get lat() {
      return this.source.lat;
    }
    get lon() {
      return this.source.lon;
    }
    distance(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distance(arg1, arg2);
      } else {
        return this.source.distance(arg1);
      }
    }
    distanceRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distanceRhumb(arg1, arg2);
      } else {
        return this.source.distanceRhumb(arg1);
      }
    }
    bearingTo(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingTo(arg1, arg2);
      } else {
        return this.source.bearingTo(arg1);
      }
    }
    bearingFrom(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingFrom(arg1, arg2);
      } else {
        return this.source.bearingFrom(arg1);
      }
    }
    bearingRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingRhumb(arg1, arg2);
      } else {
        return this.source.bearingRhumb(arg1);
      }
    }
    offset(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offset(bearing, distance, out);
    }
    offsetRhumb(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offsetRhumb(bearing, distance, out);
    }
    antipode(out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.antipode(out);
    }
    toCartesian(out) {
      return this.source.toCartesian(out);
    }
    equals(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2, arg3);
      } else {
        return this.source.equals(arg1, arg2);
      }
    }
    copy(to) {
      return this.source.copy(to);
    }
  };
  var GeoPoint = class {
    constructor(lat, lon) {
      this._lat = 0;
      this._lon = 0;
      this.set(lat, lon);
      this.readonly = new GeoPointReadOnly(this);
    }
    get lat() {
      return this._lat;
    }
    get lon() {
      return this._lon;
    }
    static asLatLonInterface(arg1, arg2) {
      if (typeof arg1 === "number") {
        return GeoPoint.tempGeoPoint.set(arg1, arg2);
      } else {
        return arg1;
      }
    }
    static asVec3(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
      } else {
        return arg1;
      }
    }
    set(arg1, arg2) {
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      lat = GeoPoint.toPlusMinus180(lat);
      lon = GeoPoint.toPlusMinus180(lon);
      if (Math.abs(lat) > 90) {
        lat = 180 - lat;
        lat = GeoPoint.toPlusMinus180(lat);
        lon += 180;
        lon = GeoPoint.toPlusMinus180(lon);
      }
      this._lat = lat;
      this._lon = lon;
      return this;
    }
    setFromCartesian(arg1, arg2, arg3) {
      const vec = GeoPoint.asVec3(arg1, arg2, arg3);
      const theta = Vec3Math.theta(vec);
      const phi = Vec3Math.phi(vec);
      return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    distance(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    distanceRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    bearingTo(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    bearingFrom(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    bearingRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    offset(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(latRad);
      const cosLat = Math.cos(latRad);
      const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
      const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
      const angularDistance = distance;
      const sinAngularDistance = Math.sin(angularDistance);
      const cosAngularDistance = Math.cos(angularDistance);
      const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
      const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
      const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
      const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    offsetRhumb(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const bearingRad = bearing * Avionics.Utils.DEG2RAD;
      const deltaLat = distance * Math.cos(bearingRad);
      let offsetLat = latRad + deltaLat;
      let offsetLon;
      if (Math.abs(offsetLat) >= Math.PI / 2) {
        offsetLat = Math.sign(offsetLat) * 90;
        offsetLon = 0;
      } else {
        const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
        const deltaLon = distance * Math.sin(bearingRad) / correction;
        offsetLon = lonRad + deltaLon;
        offsetLat *= Avionics.Utils.RAD2DEG;
        offsetLon *= Avionics.Utils.RAD2DEG;
      }
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    antipode(out) {
      return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    toCartesian(out) {
      return GeoPoint.sphericalToCartesian(this, out);
    }
    equals(arg1, arg2, arg3) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      if (other) {
        if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
          return true;
        }
        const tolerance = typeof arg1 === "number" ? arg3 : arg2;
        const distance = this.distance(other);
        return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return false;
      }
    }
    copy(to) {
      return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    static sphericalToCartesian(arg1, arg2, arg3) {
      const point = GeoPoint.asLatLonInterface(arg1, arg2);
      const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
      const phi = point.lon * Avionics.Utils.DEG2RAD;
      return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    static equals(arg1, arg2, arg3, arg4, arg5) {
      if (arg1 instanceof Float64Array) {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      } else if (typeof arg1 === "number") {
        return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      }
    }
    static distance(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof Float64Array) {
        return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
      } else {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === "number") {
          lat1 = arg1;
          lon1 = arg2;
          lat2 = arg3;
          lon2 = arg4;
        } else {
          lat1 = arg1.lat;
          lon1 = arg1.lon;
          lat2 = arg2.lat;
          lon2 = arg2.lon;
        }
        lat1 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
        const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
        const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
    }
    static distanceRhumb(arg1, arg2, arg3, arg4) {
      let lat1, lon1, lat2, lon2;
      if (typeof arg1 === "number") {
        lat1 = arg1 * Avionics.Utils.DEG2RAD;
        lon1 = arg2 * Avionics.Utils.DEG2RAD;
        lat2 = arg3 * Avionics.Utils.DEG2RAD;
        lon2 = arg4 * Avionics.Utils.DEG2RAD;
      } else if (arg1 instanceof Float64Array) {
        const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
        lat1 = point1.lat;
        lon1 = point1.lon;
        const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
        lat2 = point2.lat;
        lon2 = point2.lon;
      } else {
        lat1 = arg1.lat;
        lon1 = arg1.lon;
        lat2 = arg2.lat;
        lon2 = arg2.lon;
      }
      const deltaLat = lat2 - lat1;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    static initialBearing(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      const cosLat2 = Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
      const y = Math.sin(lon2 - lon1) * cosLat2;
      const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
      return (bearing + 360) % 360;
    }
    static finalBearing(lat1, lon1, lat2, lon2) {
      return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    static bearingRhumb(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    static toPlusMinus180(angle) {
      return (angle % 360 + 540) % 360 - 180;
    }
    static deltaPsi(latRad1, latRad2) {
      return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
      return Math.abs(deltaPsi) > 1e-12 ? (latRad2 - latRad1) / deltaPsi : Math.cos(latRad1);
    }
  };
  GeoPoint.EQUALITY_TOLERANCE = 1e-7;
  GeoPoint.tempVec3 = new Float64Array(3);
  GeoPoint.tempGeoPoint = new GeoPoint(0, 0);
  var GeoCircle = class {
    constructor(center, radius) {
      this._center = new Float64Array(3);
      this._radius = 0;
      this._sinRadius = 0;
      this.set(center, radius);
    }
    get center() {
      return this._center;
    }
    get radius() {
      return this._radius;
    }
    isGreatCircle() {
      return this._radius === Math.PI / 2;
    }
    arcLength(angle) {
      return this._sinRadius * angle;
    }
    angularWidth(length) {
      return length / this._sinRadius;
    }
    set(center, radius) {
      if (center instanceof Float64Array) {
        if (Vec3Math.abs(center) === 0) {
          Vec3Math.set(1, 0, 0, this._center);
        } else {
          Vec3Math.normalize(center, this._center);
        }
      } else {
        GeoPoint.sphericalToCartesian(center, this._center);
      }
      this._radius = Math.abs(radius) % Math.PI;
      this._sinRadius = Math.sin(this._radius);
      return this;
    }
    setAsGreatCircle(arg1, arg2) {
      this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
      return this;
    }
    reverse() {
      Vec3Math.multScalar(this._center, -1, this._center);
      this._radius = Math.PI - this._radius;
      return this;
    }
    distanceToCenter(point) {
      if (point instanceof Float64Array) {
        point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
      } else {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const dot = Vec3Math.dot(point, this._center);
      return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    closest(point, out) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
      const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
      const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
        return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
      }
      const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
      const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
      return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    distance(point) {
      const distanceToCenter = this.distanceToCenter(point);
      return distanceToCenter - this._radius;
    }
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return Math.abs(distance) < tolerance;
    }
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return inclusive ? distance <= tolerance : distance < -tolerance;
    }
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
      }
      if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
        throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
      const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
      const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
      const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
      return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angle = distance / Math.sin(this.radius);
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this.radius === 0) {
        return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
      }
      point = this.closest(point, GeoCircle.vec3Cache[3]);
      const sin = Math.sin(angle / 2);
      const q0 = Math.cos(angle / 2);
      const q1 = sin * this._center[0];
      const q2 = sin * this._center[1];
      const q3 = sin * this._center[2];
      const q0Sq = q0 * q0;
      const q1Sq = q1 * q1;
      const q2Sq = q2 * q2;
      const q3Sq = q3 * q3;
      const q01 = q0 * q1;
      const q02 = q0 * q2;
      const q03 = q0 * q3;
      const q12 = q1 * q2;
      const q13 = q1 * q3;
      const q23 = q2 * q3;
      const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
      const rot_12 = 2 * (q12 - q03);
      const rot_13 = 2 * (q13 + q02);
      const rot_21 = 2 * (q12 + q03);
      const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
      const rot_23 = 2 * (q23 - q01);
      const rot_31 = 2 * (q13 - q02);
      const rot_32 = 2 * (q23 + q01);
      const rot_33 = q0Sq - q1Sq - q2Sq + q3Sq;
      const x = point[0];
      const y = point[1];
      const z = point[2];
      const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
      const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
      const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
      return out instanceof Float64Array ? Vec3Math.set(rotX, rotY, rotZ, out) : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    intersection(other, out) {
      const center1 = this._center;
      const center2 = other._center;
      const radius1 = this._radius;
      const radius2 = other._radius;
      const dot = Vec3Math.dot(center1, center2);
      const dotSquared = dot * dot;
      if (dotSquared === 1) {
        return 0;
      }
      const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross, cross);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
      let solutionCount = 1;
      if (!out[0]) {
        out[0] = new Float64Array(3);
      }
      out[0].set(cross);
      Vec3Math.multScalar(out[0], offset, out[0]);
      Vec3Math.add(out[0], intersection, out[0]);
      if (offset > 0) {
        if (!out[1]) {
          out[1] = new Float64Array(3);
        }
        out[1].set(cross);
        Vec3Math.multScalar(out[1], -offset, out[1]);
        Vec3Math.add(out[1], intersection, out[1]);
        solutionCount++;
      }
      return solutionCount;
    }
    intersectionGeoPoint(other, out) {
      const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
      for (let i = 0; i < solutionCount; i++) {
        if (!out[i]) {
          out[i] = new GeoPoint(0, 0);
        }
        out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
      }
      return solutionCount;
    }
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const center1 = this.center;
      const center2 = other.center;
      const radius1 = this.radius;
      const radius2 = other.radius;
      const dot = Vec3Math.dot(center1, center2);
      const dotSquared = dot * dot;
      if (dotSquared === 1) {
        if (dot === 1) {
          return Math.abs(this.radius - other.radius) <= tolerance ? NaN : 0;
        } else {
          return Math.abs(Math.PI - this.radius - other.radius) <= tolerance ? NaN : 0;
        }
      }
      const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross, cross);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const sinTol = Math.sin(tolerance);
      return (1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol ? 2 : 1;
    }
    static createFromPoint(point, radius) {
      return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
      return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    static createGreatCircleFromPointBearing(point, bearing) {
      return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    static getGreatCircleNormal(arg1, arg2, out) {
      return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    static _getGreatCircleNormal(arg1, arg2, out) {
      if (typeof arg2 === "number") {
        return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
      } else {
        return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
      }
    }
    static getGreatCircleNormalFromPoints(point1, point2, out) {
      if (!(point1 instanceof Float64Array)) {
        point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
      }
      return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
      if (point instanceof Float64Array) {
        point = GeoCircle.tempGeoPoint.setFromCartesian(point);
      }
      const lat = point.lat * Avionics.Utils.DEG2RAD;
      const long = point.lon * Avionics.Utils.DEG2RAD;
      bearing *= Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(lat);
      const sinLon = Math.sin(long);
      const cosLon = Math.cos(long);
      const sinBearing = Math.sin(bearing);
      const cosBearing = Math.cos(bearing);
      const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
      const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
      const z = Math.cos(lat) * sinBearing;
      return Vec3Math.set(x, y, z, out);
    }
  };
  GeoCircle.ANGULAR_TOLERANCE = 1e-7;
  GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
  GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
  GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var NavMath = class {
    static clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    static normalizeHeading(heading) {
      if (isFinite(heading)) {
        return (heading % 360 + 360) % 360;
      } else {
        console.error(`normalizeHeading: Invalid heading: ${heading}`);
        return NaN;
      }
    }
    static reciprocateHeading(heading) {
      return NavMath.normalizeHeading(heading + 180);
    }
    static turnRadius(airspeedTrue, bankAngle) {
      return Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)) / 3.2808399;
    }
    static bankAngle(airspeedTrue, radius) {
      const airspeedMS = airspeedTrue * 0.51444444;
      return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    static getTurnDirection(startCourse, endCourse) {
      return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? "left" : "right";
    }
    static polarToDegreesNorth(radians) {
      return NavMath.normalizeHeading(180 / Math.PI * (Math.PI / 2 - radians));
    }
    static degreesNorthToPolar(degrees) {
      return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    static calculateArcDistance(startBearing, endBearing, radius) {
      const angularWidth = (endBearing - startBearing + 360) % 360 * Avionics.Utils.DEG2RAD;
      const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
      return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const a = dx * dx + dy * dy;
      const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
      const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
      const det = b * b - 4 * a * c;
      if (a < 1e-7 || det < 0) {
        sRef.x1 = NaN;
        sRef.x2 = NaN;
        sRef.y1 = NaN;
        sRef.y2 = NaN;
        return 0;
      } else if (det == 0) {
        const t = -b / (2 * a);
        sRef.x1 = x1 + t * dx;
        sRef.y1 = y1 + t * dy;
        sRef.x2 = NaN;
        sRef.y2 = NaN;
        return 1;
      } else {
        const t1 = (-b + Math.sqrt(det)) / (2 * a);
        sRef.x1 = x1 + t1 * dx;
        sRef.y1 = y1 + t1 * dy;
        const t2 = (-b - Math.sqrt(det)) / (2 * a);
        sRef.x2 = x1 + t2 * dx;
        sRef.y2 = y1 + t2 * dy;
        return 2;
      }
    }
    static northAngle(cx, cy, x, y) {
      return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    static bearingIsBetween(bearing, start, end) {
      const range = this.normalizeHeading(end - start);
      const relativeBearing = this.normalizeHeading(bearing - start);
      return relativeBearing >= 0 && relativeBearing <= range;
    }
    static headingToAngle(heading, turnDirection) {
      return NavMath.normalizeHeading(heading + (turnDirection === "left" ? 90 : -90));
    }
    static angleToHeading(angle, turnDirection) {
      return NavMath.normalizeHeading(angle + (turnDirection === "left" ? -90 : 90));
    }
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
      const currCrosswind = windSpeed * Math.sin(course * Math.PI / 180 - windDirection * Math.PI / 180);
      const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
      return windCorrection;
    }
    static crossTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    static alongTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
      return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    static desiredTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    static desiredTrackArc(center, turnDirection, pos) {
      const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
      return NavMath.angleToHeading(northAngle, turnDirection);
    }
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
      const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
      const sign = turnDirection === "right" ? 1 : -1;
      const alpha = ((end - start) * sign + 360) % 360;
      const mid = (start + alpha / 2 * sign + 360) % 360;
      const rotBearing = (bearingFromCenter - mid + 540) % 360 - 180;
      const frac = rotBearing * sign / alpha + 0.5;
      return frac;
    }
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
      const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
      const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
      const bearing = turnDirection === "right" ? start + theta : start - theta;
      center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
      return out;
    }
    static crossTrackArc(center, radius, pos) {
      return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    static diffAngle(a, b) {
      let diff = b - a;
      while (diff > 180) {
        diff -= 360;
      }
      while (diff <= -180) {
        diff += 360;
      }
      return diff;
    }
    static napierSide(b, c, beta, gamma) {
      return 2 * Math.atan(Math.tan(0.5 * (b - c)) * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    static normal(course, turnDirection, outVector) {
      const normalCourse = NavMath.headingToAngle(course, turnDirection);
      const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
      outVector[0] = Math.cos(polarCourse);
      outVector[1] = Math.sin(polarCourse);
    }
  };
  NavMath.vec3Cache = [new Float64Array(3)];
  NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MagVar = class {
    static get(arg1, arg2) {
      return MagVar.getMagVar(arg1, arg2);
    }
    static magneticToTrue(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing + (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    static trueToMagnetic(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing - (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    static getMagVar(arg1, arg2) {
      if (typeof Facilities === "undefined") {
        return 0;
      }
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      return Facilities.getMagVar(lat, lon);
    }
  };
  var GeoPointSubject = class extends AbstractSubscribable {
    constructor(value, tolerance) {
      super();
      this.value = value;
      this.tolerance = tolerance;
      this.isMutableSubscribable = true;
    }
    static create(initialVal, tolerance) {
      return new GeoPointSubject(initialVal, tolerance);
    }
    static createFromGeoPoint(initialVal) {
      return new GeoPointSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var AbstractGeoProjection = class {
    constructor() {
      this.center = new GeoPoint(0, 0);
      this.centerTranslation = new Float64Array(2);
      this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
      this.preRotation = new Float64Array(3);
      this.translation = new Float64Array(2);
      this.postRotation = 0;
      this.rotationSin = 0;
      this.rotationCos = 1;
      this.reflectY = 1;
      this.preRotationForwardTransform = new Transform3D();
      this.preRotationReverseTransform = new Transform3D();
      this.rotationCache = [new Transform3D(), new Transform3D()];
    }
    getCenter() {
      return this.center.readonly;
    }
    getScaleFactor() {
      return this.scaleFactor;
    }
    getPreRotation() {
      return this.preRotation;
    }
    getTranslation() {
      return this.translation;
    }
    getPostRotation() {
      return this.postRotation;
    }
    getReflectY() {
      return this.reflectY === -1;
    }
    setCenter(point) {
      this.center.set(point);
      this.updateCenterTranslation();
      return this;
    }
    setScaleFactor(factor) {
      this.scaleFactor = factor;
      return this;
    }
    setPreRotation(vec) {
      this.preRotation.set(vec);
      this.updatePreRotationTransforms();
      this.updateCenterTranslation();
      return this;
    }
    setTranslation(vec) {
      this.translation.set(vec);
      return this;
    }
    setPostRotation(rotation) {
      this.postRotation = rotation;
      this.rotationCos = Math.cos(rotation);
      this.rotationSin = Math.sin(rotation);
      return this;
    }
    setReflectY(val) {
      this.reflectY = val ? -1 : 1;
      return this;
    }
    copyParametersFrom(other) {
      return this.setCenter(other.getCenter()).setPreRotation(other.getPreRotation()).setScaleFactor(other.getScaleFactor()).setTranslation(other.getTranslation()).setPostRotation(other.getPostRotation()).setReflectY(other.getReflectY());
    }
    updatePreRotationTransforms() {
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      this.rotationCache[0].toRotationX(gamma);
      this.rotationCache[1].toRotationY(-phi);
      Transform3D.concat(this.preRotationForwardTransform, this.rotationCache);
      this.preRotationReverseTransform.set(this.preRotationForwardTransform);
      this.preRotationReverseTransform.invert();
    }
    updateCenterTranslation() {
      const centerArray = AbstractGeoProjection.vec2Cache[0];
      centerArray[0] = this.center.lon;
      centerArray[1] = this.center.lat;
      this.preRotateForward(centerArray, centerArray);
      this.projectRaw(centerArray, this.centerTranslation);
    }
    preRotateForward(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      if (phi === 0 && gamma === 0) {
        return Vec2Math.set(rotatedLon, lat, out);
      }
      const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
      const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
      const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
      return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    preRotateReverse(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      let rotatedLat = lat;
      let rotatedLon = lon;
      if (phi !== 0 || gamma !== 0) {
        const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
        const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
        rotatedLat = unrotated.lat;
        rotatedLon = unrotated.lon;
      }
      rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    project(point, out) {
      if (point instanceof Float64Array) {
        out.set(point);
      } else {
        out[0] = point.lon;
        out[1] = point.lat;
      }
      this.preRotateForward(out, out);
      this.projectRaw(out, out);
      out[0] -= this.centerTranslation[0];
      out[1] -= this.centerTranslation[1];
      out[1] *= this.reflectY;
      out[0] *= this.scaleFactor;
      out[1] *= this.scaleFactor;
      const x = out[0];
      const y = out[1];
      out[0] = x * this.rotationCos - y * this.rotationSin;
      out[1] = x * this.rotationSin + y * this.rotationCos;
      out[0] += this.translation[0];
      out[1] += this.translation[1];
      return out;
    }
    invert(vec, out) {
      const projected = AbstractGeoProjection.vec2Cache[0];
      projected.set(vec);
      projected[0] -= this.translation[0];
      projected[1] -= this.translation[1];
      const x = projected[0];
      const y = projected[1];
      projected[0] = x * this.rotationCos + y * this.rotationSin;
      projected[1] = -x * this.rotationSin + y * this.rotationCos;
      projected[0] /= this.scaleFactor;
      projected[1] /= this.scaleFactor;
      projected[1] *= this.reflectY;
      projected[0] += this.centerTranslation[0];
      projected[1] += this.centerTranslation[1];
      const inverted = this.invertRaw(projected, projected);
      this.preRotateReverse(inverted, inverted);
      if (out instanceof Float64Array) {
        out.set(inverted);
        return out;
      } else {
        return out.set(inverted[1], inverted[0]);
      }
    }
  };
  AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
  AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
  AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
  var MercatorProjection = class extends AbstractGeoProjection {
    projectRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.DEG2RAD;
      out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
      return out;
    }
    invertRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.RAD2DEG;
      out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
      return out;
    }
  };
  var GeoCircleResampler = class {
    constructor(minDistance, dpTolerance, maxDepth) {
      this.minDistance = minDistance;
      this.dpTolerance = dpTolerance;
      this.maxDepth = maxDepth;
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.startVector = {
        type: "start",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.lineVector = {
        type: "line",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.arcVector = {
        type: "arc",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        projectedArcCenter: new Float64Array(2),
        projectedArcRadius: 0,
        projectedArcStartAngle: 0,
        projectedArcEndAngle: 0,
        index: 0
      };
      this.state = {
        index: 0,
        prevX: 0,
        prevY: 0,
        vectorType: "line",
        arcCenterX: 0,
        arcCenterY: 0,
        arcRadius: 0,
        isArcCounterClockwise: false
      };
      this.cosMinDistance = Math.cos(minDistance);
      this.dpTolSq = dpTolerance * dpTolerance;
    }
    resample(projection, circle, start, end, handler) {
      let startPoint, startVec, endPoint, endVec;
      if (start instanceof Float64Array) {
        startPoint = this.geoPointCache[0].setFromCartesian(start);
        startVec = start;
      } else {
        startPoint = start;
        startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
      }
      if (end instanceof Float64Array) {
        endPoint = this.geoPointCache[0].setFromCartesian(end);
        endVec = end;
      } else {
        endPoint = end;
        endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
      }
      const startLat = startPoint.lat;
      const startLon = startPoint.lon;
      const endLat = endPoint.lat;
      const endLon = endPoint.lon;
      const startProjected = projection.project(start, this.vec2Cache[0]);
      const endProjected = projection.project(end, this.vec2Cache[1]);
      const startX = startProjected[0];
      const startY = startProjected[1];
      const endX = endProjected[0];
      const endY = endProjected[1];
      this.startVector.point.set(startLat, startLon);
      Vec2Math.copy(startProjected, this.startVector.projected);
      handler(this.startVector);
      this.state.index = 1;
      this.state.prevX = startX;
      this.state.prevY = startY;
      this.state.vectorType = "line";
      const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
      this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
      if (depth >= this.maxDepth) {
        return state;
      }
      const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
      const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
      const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
      if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
        return state;
      }
      const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
      const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
      const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
      const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
      const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
      const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
      const midProjected = projection.project(midPoint, this.vec2Cache[2]);
      const lat0 = midPoint.lat;
      const lon0 = midPoint.lon;
      const x0 = midVec[0];
      const y0 = midVec[1];
      const z0 = midVec[2];
      const projX0 = midProjected[0];
      const projY0 = midProjected[1];
      const A = projX2 - projX1;
      const B = projY2 - projY1;
      const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
      const D = projX0 - projX1;
      const E = projY0 - projY1;
      const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
      const det = 2 * (A * E - B * D);
      const dpDisSq = det * det / 4 / deltaProjectedDot;
      if (dpDisSq > this.dpTolSq) {
        const arcCenterX = (B * F - C * E) / det;
        const arcCenterY = (C * D - A * F) / det;
        const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
        const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
        const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
        const cross = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
        state.vectorType = "arc";
        state.arcCenterX = arcCenterX;
        state.arcCenterY = arcCenterY;
        state.arcRadius = arcRadius;
        state.isArcCounterClockwise = cross[2] > 0;
      } else {
        state.vectorType = "line";
      }
      const cosDistance = Vec3Math.dot(startVec, midVec);
      if (cosDistance > this.cosMinDistance) {
        if (state.vectorType === "line") {
          return state;
        }
        const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
        const projectedQuery = projection.project(query, this.vec2Cache[0]);
        let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
        if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
          circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
          projection.project(query, projectedQuery);
          distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
          if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
            return state;
          }
        }
      }
      state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
      this.callHandler(handler, lat0, lon0, projX0, projY0, state);
      state.index++;
      state.prevX = projX0;
      state.prevY = projY0;
      return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    callHandler(handler, lat, lon, projX, projY, state) {
      let vector;
      if (state.vectorType === "line") {
        vector = this.lineVector;
      } else {
        vector = this.arcVector;
        Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
        vector.projectedArcRadius = state.arcRadius;
        vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
        vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
        if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
          vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils.TWO_PI : MathUtils.TWO_PI;
        }
      }
      vector.point.set(lat, lon);
      Vec2Math.set(projX, projY, vector.projected);
      vector.index = state.index;
      handler(vector);
    }
  };
  var NavAngleUnitReferenceNorth;
  (function(NavAngleUnitReferenceNorth2) {
    NavAngleUnitReferenceNorth2["True"] = "true";
    NavAngleUnitReferenceNorth2["Magnetic"] = "magnetic";
  })(NavAngleUnitReferenceNorth || (NavAngleUnitReferenceNorth = {}));
  var BasicNavAngleUnit = class extends AbstractUnit {
    constructor(referenceNorth, magVar) {
      super(referenceNorth === NavAngleUnitReferenceNorth.True ? "true bearing" : "magnetic bearing");
      this.family = "navangle";
      this._magVar = 0;
      this._magVar = magVar;
    }
    get magVar() {
      return this._magVar;
    }
    isMagnetic() {
      return this.name === "magnetic bearing";
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === toUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.magneticToTrue(value, this.magVar) : MagVar.trueToMagnetic(value, this.magVar);
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === fromUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.trueToMagnetic(value, this.magVar) : MagVar.magneticToTrue(value, this.magVar);
    }
    setMagVar(magVar) {
      this._magVar = magVar;
    }
    setMagVarFromLocation(arg1, arg2) {
      if (typeof arg1 === "number") {
        this._magVar = MagVar.get(arg1, arg2);
      } else {
        this._magVar = MagVar.get(arg1);
      }
    }
    equals(other) {
      return other instanceof BasicNavAngleUnit && this.name === other.name && this.magVar === other.magVar;
    }
    static create(isMagnetic, arg2, arg3) {
      const referenceNorth = isMagnetic ? NavAngleUnitReferenceNorth.Magnetic : NavAngleUnitReferenceNorth.True;
      let magVar = 0;
      if (arg2 !== void 0) {
        if (typeof arg2 === "number") {
          if (arg3 === void 0) {
            magVar = arg2;
          } else {
            magVar = MagVar.get(arg2, arg3);
          }
        } else {
          magVar = MagVar.get(arg2);
        }
      }
      return new BasicNavAngleUnit(referenceNorth, magVar);
    }
  };
  var BasicNavAngleSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new BasicNavAngleSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2, arg3) {
      const isArg1Number = typeof arg1 === "number";
      const isArg2Number = typeof arg2 === "number";
      const isArg2LatLon = typeof arg2 === "object" && "lat" in arg2 && "lon" in arg2;
      const unit = isArg1Number ? isArg2Number || isArg2LatLon || arg2 === void 0 ? this.value.unit : arg2 : arg1.unit;
      const oldMagVar = this.value.unit.magVar;
      const oldValue = this.value.number;
      if (isArg2LatLon) {
        this.value.unit.setMagVarFromLocation(arg2);
      } else if (isArg2Number) {
        if (typeof arg3 === "number") {
          this.value.unit.setMagVarFromLocation(arg2, arg3);
        } else {
          this.value.unit.setMagVar(arg2);
        }
      } else {
        this.value.unit.setMagVar(unit.magVar);
      }
      if (isArg1Number) {
        this.value.set(arg1, unit);
      } else {
        this.value.set(arg1);
      }
      if (!(isNaN(oldMagVar) && isNaN(this.value.unit.magVar)) && oldMagVar !== this.value.unit.magVar || !(isNaN(oldValue) && isNaN(this.value.number)) && oldValue !== this.value.number) {
        this.notify();
      }
    }
  };
  BasicNavAngleSubject.TRUE_BEARING = BasicNavAngleUnit.create(false);
  var AntiIcePublisher = class extends SimVarPublisher {
    constructor(bus, pacer) {
      const engineIndexedSimVars = [
        ["anti_ice_engine_switch_on", { name: "ENG ANTI ICE", type: SimVarValueType.Bool }],
        ["anti_ice_prop_switch_on", { name: "PROP DEICE SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(AntiIcePublisher.nonIndexedSimVars);
      const engineCount = SimVar.GetSimVarValue("NUMBER OF ENGINES", SimVarValueType.Number);
      for (const [topic, simvar2] of engineIndexedSimVars) {
        for (let i = 1; i <= engineCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  AntiIcePublisher.nonIndexedSimVars = [
    ["anti_ice_structural_switch_on", { name: "STRUCTURAL DEICE SWITCH", type: SimVarValueType.Bool }],
    ["anti_ice_windshield_switch_on", { name: "WINDSHIELD DEICE SWITCH", type: SimVarValueType.Bool }]
  ];
  var BasicConsumer = class {
    constructor(subscribe, state = {}, currentHandler) {
      this.subscribe = subscribe;
      this.state = state;
      this.currentHandler = currentHandler;
      this.isConsumer = true;
      this.activeSubs = /* @__PURE__ */ new Map();
    }
    handle(handler, paused = false) {
      let activeHandler;
      if (this.currentHandler !== void 0) {
        activeHandler = (data) => {
          this.currentHandler(data, this.state, handler);
        };
      } else {
        activeHandler = handler;
      }
      let activeSubArray = this.activeSubs.get(handler);
      if (!activeSubArray) {
        activeSubArray = [];
        this.activeSubs.set(handler, activeSubArray);
      }
      const onDestroyed = (destroyed) => {
        const activeSubsArray = this.activeSubs.get(handler);
        if (activeSubsArray) {
          activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
          if (activeSubsArray.length === 0) {
            this.activeSubs.delete(handler);
          }
        }
      };
      const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
      if (sub.isAlive) {
        activeSubArray.push(sub);
      } else if (activeSubArray.length === 0) {
        this.activeSubs.delete(handler);
      }
      return sub;
    }
    off(handler) {
      var _a;
      const activeSubArray = this.activeSubs.get(handler);
      if (activeSubArray) {
        (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
        if (activeSubArray.length === 0) {
          this.activeSubs.delete(handler);
        }
      }
    }
    atFrequency(frequency, immediateFirstPublish = true) {
      const initialState = {
        previousTime: Date.now(),
        firstRun: immediateFirstPublish
      };
      return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    getAtFrequencyHandler(frequency) {
      const deltaTimeTrigger = 1e3 / frequency;
      return (data, state, next) => {
        const currentTime = Date.now();
        const deltaTime = currentTime - state.previousTime;
        if (deltaTimeTrigger <= deltaTime || state.firstRun) {
          while (state.previousTime + deltaTimeTrigger < currentTime) {
            state.previousTime += deltaTimeTrigger;
          }
          if (state.firstRun) {
            state.firstRun = false;
          }
          this.with(data, next);
        }
      };
    }
    withPrecision(precision) {
      return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    getWithPrecisionHandler(precision) {
      return (data, state, next) => {
        const dataValue = data;
        const multiplier = Math.pow(10, precision);
        const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
        if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
          state.hasLastValue = true;
          state.lastValue = currentValueAtPrecision;
          this.with(currentValueAtPrecision, next);
        }
      };
    }
    whenChangedBy(amount) {
      return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    getWhenChangedByHandler(amount) {
      return (data, state, next) => {
        const dataValue = data;
        const diff = Math.abs(dataValue - state.lastValue);
        if (!state.hasLastValue || diff >= amount) {
          state.hasLastValue = true;
          state.lastValue = dataValue;
          this.with(data, next);
        }
      };
    }
    whenChanged() {
      return new BasicConsumer(this.subscribe, { lastValue: "", hasLastValue: false }, this.getWhenChangedHandler());
    }
    getWhenChangedHandler() {
      return (data, state, next) => {
        if (!state.hasLastValue || state.lastValue !== data) {
          state.hasLastValue = true;
          state.lastValue = data;
          this.with(data, next);
        }
      };
    }
    onlyAfter(deltaTime) {
      return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    getOnlyAfterHandler(deltaTime) {
      return (data, state, next) => {
        const currentTime = Date.now();
        const timeDiff = currentTime - state.previousTime;
        if (timeDiff > deltaTime) {
          state.previousTime += deltaTime;
          this.with(data, next);
        }
      };
    }
    with(data, handler) {
      if (this.currentHandler !== void 0) {
        this.currentHandler(data, this.state, handler);
      } else {
        handler(data);
      }
    }
  };
  var ConsumerSubscription = class {
    constructor(sub, onDestroy) {
      this.sub = sub;
      this.onDestroy = onDestroy;
    }
    get isAlive() {
      return this.sub.isAlive;
    }
    get isPaused() {
      return this.sub.isPaused;
    }
    get canInitialNotify() {
      return this.sub.canInitialNotify;
    }
    pause() {
      this.sub.pause();
      return this;
    }
    resume(initialNotify = false) {
      this.sub.resume(initialNotify);
      return this;
    }
    destroy() {
      this.sub.destroy();
      this.onDestroy(this);
    }
  };
  var EventSubscriber = class {
    constructor(bus) {
      this.bus = bus;
    }
    on(topic) {
      return new BasicConsumer((handler, paused) => {
        return this.bus.on(topic, handler, paused);
      });
    }
  };
  var APLockType;
  (function(APLockType2) {
    APLockType2[APLockType2["Heading"] = 0] = "Heading";
    APLockType2[APLockType2["Nav"] = 1] = "Nav";
    APLockType2[APLockType2["Alt"] = 2] = "Alt";
    APLockType2[APLockType2["Bank"] = 3] = "Bank";
    APLockType2[APLockType2["WingLevel"] = 4] = "WingLevel";
    APLockType2[APLockType2["Vs"] = 5] = "Vs";
    APLockType2[APLockType2["Flc"] = 6] = "Flc";
    APLockType2[APLockType2["Pitch"] = 7] = "Pitch";
    APLockType2[APLockType2["Approach"] = 8] = "Approach";
    APLockType2[APLockType2["Backcourse"] = 9] = "Backcourse";
    APLockType2[APLockType2["Glideslope"] = 10] = "Glideslope";
    APLockType2[APLockType2["VNav"] = 11] = "VNav";
  })(APLockType || (APLockType = {}));
  var APSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(APSimVarPublisher.simvars, bus, pacer);
    }
  };
  APSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["ap_heading_selected", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_1", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_2", { name: "AUTOPILOT HEADING LOCK DIR:2", type: SimVarValueType.Degree }],
    ["ap_heading_selected_3", { name: "AUTOPILOT HEADING LOCK DIR:3", type: SimVarValueType.Degree }],
    ["ap_altitude_selected", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_1", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_2", { name: "AUTOPILOT ALTITUDE LOCK VAR:2", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_3", { name: "AUTOPILOT ALTITUDE LOCK VAR:3", type: SimVarValueType.Feet }],
    ["ap_master_status", { name: "AUTOPILOT MASTER", type: SimVarValueType.Bool }],
    ["ap_yd_status", { name: "AUTOPILOT YAW DAMPER", type: SimVarValueType.Bool }],
    ["ap_heading_hold", { name: "AUTOPILOT HEADING LOCK", type: SimVarValueType.Bool }],
    ["ap_nav_hold", { name: "AUTOPILOT NAV1 LOCK", type: SimVarValueType.Bool }],
    ["ap_bank_hold", { name: "AUTOPILOT BANK HOLD", type: SimVarValueType.Bool }],
    ["ap_max_bank_id", { name: "AUTOPILOT MAX BANK ID", type: SimVarValueType.Number }],
    ["ap_max_bank_value", { name: "AUTOPILOT MAX BANK", type: SimVarValueType.Degree }],
    ["ap_wing_lvl_hold", { name: "AUTOPILOT WING LEVELER", type: SimVarValueType.Bool }],
    ["ap_approach_hold", { name: "AUTOPILOT APPROACH HOLD", type: SimVarValueType.Bool }],
    ["ap_backcourse_hold", { name: "AUTOPILOT BACKCOURSE HOLD", type: SimVarValueType.Bool }],
    ["ap_vs_hold", { name: "AUTOPILOT VERTICAL HOLD", type: SimVarValueType.Bool }],
    ["ap_flc_hold", { name: "AUTOPILOT FLIGHT LEVEL CHANGE", type: SimVarValueType.Bool }],
    ["ap_alt_hold", { name: "AUTOPILOT ALTITUDE LOCK", type: SimVarValueType.Bool }],
    ["ap_glideslope_hold", { name: "AUTOPILOT GLIDESLOPE HOLD", type: SimVarValueType.Bool }],
    ["ap_pitch_hold", { name: "AUTOPILOT PITCH HOLD", type: SimVarValueType.Bool }],
    ["ap_toga_hold", { name: "AUTOPILOT TAKEOFF POWER ACTIVE", type: SimVarValueType.Bool }],
    ["ap_vs_selected", { name: "AUTOPILOT VERTICAL HOLD VAR:1", type: SimVarValueType.FPM }],
    ["ap_fpa_selected", { name: "L:WT_AP_FPA_Target:1", type: SimVarValueType.Degree }],
    ["ap_ias_selected", { name: "AUTOPILOT AIRSPEED HOLD VAR", type: SimVarValueType.Knots }],
    ["ap_mach_selected", { name: "AUTOPILOT MACH HOLD VAR", type: SimVarValueType.Number }],
    ["ap_selected_speed_is_mach", { name: "AUTOPILOT MANAGED SPEED IN MACH", type: SimVarValueType.Bool }],
    ["ap_selected_speed_is_manual", { name: "L:XMLVAR_SpeedIsManuallySet", type: SimVarValueType.Bool }],
    ["flight_director_bank", { name: "AUTOPILOT FLIGHT DIRECTOR BANK", type: SimVarValueType.Degree }],
    ["flight_director_pitch", { name: "AUTOPILOT FLIGHT DIRECTOR PITCH", type: SimVarValueType.Degree }],
    ["flight_director_is_active_1", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:1", type: SimVarValueType.Bool }],
    ["flight_director_is_active_2", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:2", type: SimVarValueType.Bool }],
    ["vnav_active", { name: "L:XMLVAR_VNAVButtonValue", type: SimVarValueType.Bool }],
    ["ap_pitch_selected", { name: "AUTOPILOT PITCH HOLD REF", type: SimVarValueType.Degree }]
  ]);
  var RadioUtils = class {
    static isNavFrequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 108e3 || freqKhz > 117950) {
        return false;
      }
      return freqKhz % 50 === 0;
    }
    static isLocalizerFrequency(freq) {
      return freq >= 108.1 && freq <= 111.95 && Math.trunc(freq * 10) % 2 === 1;
    }
    static isCom833Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136990) {
        return false;
      }
      return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    static isCom25Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136975) {
        return false;
      }
      return freqKhz % 25 === 0;
    }
    static isAdfFrequency(freq) {
      const freqHz = Math.round(freq * 1e3);
      if (freqHz < 19e4 || freqHz > 1799500) {
        return false;
      }
      return freqHz % 500 === 0;
    }
  };
  RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];
  var RadioType;
  (function(RadioType2) {
    RadioType2["Com"] = "COM";
    RadioType2["Nav"] = "NAV";
    RadioType2["Adf"] = "ADF";
  })(RadioType || (RadioType = {}));
  var FrequencyBank;
  (function(FrequencyBank2) {
    FrequencyBank2[FrequencyBank2["Active"] = 0] = "Active";
    FrequencyBank2[FrequencyBank2["Standby"] = 1] = "Standby";
  })(FrequencyBank || (FrequencyBank = {}));
  var ComSpacing;
  (function(ComSpacing2) {
    ComSpacing2[ComSpacing2["Spacing25Khz"] = 0] = "Spacing25Khz";
    ComSpacing2[ComSpacing2["Spacing833Khz"] = 1] = "Spacing833Khz";
  })(ComSpacing || (ComSpacing = {}));
  var NavProcSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    static createNavRadioDefinitions(index) {
      return [
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
        [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
        [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
        [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
        [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
        [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
        [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
        [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
        [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
        [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
        [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
        [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
      ];
    }
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
      ];
    }
  };
  NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ["gps_dtk", { name: "GPS WP DESIRED TRACK", type: SimVarValueType.Degree }],
    ["gps_xtk", { name: "GPS WP CROSS TRK", type: SimVarValueType.NM }],
    ["gps_wp", { name: "GPS WP NEXT ID", type: SimVarValueType.NM }],
    ["gps_wp_bearing", { name: "GPS WP BEARING", type: SimVarValueType.String }],
    ["gps_wp_distance", { name: "GPS WP DISTANCE", type: SimVarValueType.NM }],
    ["mkr_bcn_state_simvar", { name: "MARKER BEACON STATE", type: SimVarValueType.Number }],
    ["gps_obs_active_simvar", { name: "GPS OBS ACTIVE", type: SimVarValueType.Bool }],
    ["gps_obs_value_simvar", { name: "GPS OBS VALUE", type: SimVarValueType.Degree }]
  ]);
  var NavSourceType;
  (function(NavSourceType2) {
    NavSourceType2[NavSourceType2["Nav"] = 0] = "Nav";
    NavSourceType2[NavSourceType2["Gps"] = 1] = "Gps";
    NavSourceType2[NavSourceType2["Adf"] = 2] = "Adf";
  })(NavSourceType || (NavSourceType = {}));
  var VorToFrom;
  (function(VorToFrom2) {
    VorToFrom2[VorToFrom2["OFF"] = 0] = "OFF";
    VorToFrom2[VorToFrom2["TO"] = 1] = "TO";
    VorToFrom2[VorToFrom2["FROM"] = 2] = "FROM";
  })(VorToFrom || (VorToFrom = {}));
  var MarkerBeaconState;
  (function(MarkerBeaconState2) {
    MarkerBeaconState2[MarkerBeaconState2["Inactive"] = 0] = "Inactive";
    MarkerBeaconState2[MarkerBeaconState2["Outer"] = 1] = "Outer";
    MarkerBeaconState2[MarkerBeaconState2["Middle"] = 2] = "Middle";
    MarkerBeaconState2[MarkerBeaconState2["Inner"] = 3] = "Inner";
  })(MarkerBeaconState || (MarkerBeaconState = {}));
  var EventBus = class {
    constructor(useAlternativeEventSync = false, shouldResync = true) {
      this._topicSubsMap = /* @__PURE__ */ new Map();
      this._wildcardSubs = new Array();
      this._notifyDepthMap = /* @__PURE__ */ new Map();
      this._wildcardNotifyDepth = 0;
      this._eventCache = /* @__PURE__ */ new Map();
      this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
      this._busId = Math.floor(Math.random() * 2147483647);
      useAlternativeEventSync = typeof RegisterGenericDataListener === "undefined";
      const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
      this._busSync = new syncFunc(this.pub.bind(this), this._busId);
      if (shouldResync === true) {
        this.syncEvent("event_bus", "resync_request", false);
        this.on("event_bus", (data) => {
          if (data == "resync_request") {
            this.resyncEvents();
          }
        });
      }
    }
    on(topic, handler, paused = false) {
      let subs = this._topicSubsMap.get(topic);
      if (subs === void 0) {
        this._topicSubsMap.set(topic, subs = []);
        this.pub("event_bus_topic_first_sub", topic, false, false);
      }
      const initialNotifyFunc = (sub2) => {
        const lastState = this._eventCache.get(topic);
        if (lastState !== void 0) {
          sub2.handler(lastState.data);
        }
      };
      const onDestroyFunc = (sub2) => {
        var _a;
        if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
          const subsToSplice = this._topicSubsMap.get(topic);
          if (subsToSplice) {
            subsToSplice.splice(subsToSplice.indexOf(sub2), 1);
          }
        }
      };
      const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
      subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
    off(topic, handler) {
      const handlers = this._topicSubsMap.get(topic);
      const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    onAll(handler) {
      const sub = new HandlerSubscription(handler, void 0, this.onWildcardSubDestroyedFunc);
      this._wildcardSubs.push(sub);
      return sub;
    }
    offAll(handler) {
      const toDestroy = this._wildcardSubs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    pub(topic, data, sync = false, isCached = true) {
      var _a;
      if (isCached) {
        this._eventCache.set(topic, { data, synced: sync });
      }
      const subs = this._topicSubsMap.get(topic);
      if (subs !== void 0) {
        let needCleanUpSubs2 = false;
        const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
        this._notifyDepthMap.set(topic, notifyDepth + 1);
        const len = subs.length;
        for (let i = 0; i < len; i++) {
          try {
            const sub = subs[i];
            if (sub.isAlive && !sub.isPaused) {
              sub.handler(data);
            }
            needCleanUpSubs2 || (needCleanUpSubs2 = !sub.isAlive);
          } catch (error) {
            console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
            if (error instanceof Error) {
              console.error(error.stack);
            }
          }
        }
        this._notifyDepthMap.set(topic, notifyDepth);
        if (needCleanUpSubs2 && notifyDepth === 0) {
          const filteredSubs = subs.filter((sub) => sub.isAlive);
          this._topicSubsMap.set(topic, filteredSubs);
        }
      }
      if (sync) {
        this.syncEvent(topic, data, isCached);
      }
      let needCleanUpSubs = false;
      this._wildcardNotifyDepth++;
      const wcLen = this._wildcardSubs.length;
      for (let i = 0; i < wcLen; i++) {
        const sub = this._wildcardSubs[i];
        if (sub.isAlive && !sub.isPaused) {
          sub.handler(topic, data);
        }
        needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
      }
      this._wildcardNotifyDepth--;
      if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
        this._wildcardSubs = this._wildcardSubs.filter((sub) => sub.isAlive);
      }
    }
    onWildcardSubDestroyed(sub) {
      if (this._wildcardNotifyDepth === 0) {
        this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
      }
    }
    resyncEvents() {
      for (const [topic, event] of this._eventCache) {
        if (event.synced) {
          this.syncEvent(topic, event.data, true);
        }
      }
    }
    syncEvent(topic, data, isCached) {
      this._busSync.sendEvent(topic, data, isCached);
    }
    getPublisher() {
      return this;
    }
    getSubscriber() {
      return new EventSubscriber(this);
    }
    getTopicSubscriberCount(topic) {
      var _a, _b;
      return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    forEachSubscribedTopic(fn) {
      this._topicSubsMap.forEach((subs, topic) => {
        subs.length > 0 && fn(topic, subs.length);
      });
    }
  };
  var EventBusSyncBase = class {
    constructor(recvEventCb, busId) {
      this.isPaused = false;
      this.lastEventSynced = -1;
      this.dataPackageQueue = [];
      this.recvEventCb = recvEventCb;
      this.busId = busId;
      this.hookReceiveEvent();
      const sendFn = () => {
        if (!this.isPaused && this.dataPackageQueue.length > 0) {
          const syncDataPackage = {
            busId: this.busId,
            packagedId: Math.floor(Math.random() * 1e9),
            data: this.dataPackageQueue
          };
          if (this.executeSync(syncDataPackage)) {
            this.dataPackageQueue.length = 0;
          } else {
            console.warn("Failed to send sync data package");
          }
        }
        requestAnimationFrame(sendFn);
      };
      requestAnimationFrame(sendFn);
    }
    processEventsReceived(syncData) {
      if (this.busId !== syncData.busId) {
        if (this.lastEventSynced !== syncData.packagedId) {
          this.lastEventSynced = syncData.packagedId;
          syncData.data.forEach((data) => {
            try {
              this.recvEventCb(data.topic, data.data !== void 0 ? data.data : void 0, false, data.isCached);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          });
        }
      }
    }
    sendEvent(topic, data, isCached) {
      const dataObj = data;
      const dataPackage = {
        topic,
        data: dataObj,
        isCached
      };
      this.dataPackageQueue.push(dataPackage);
    }
  };
  var EventBusCoherentSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, void 0, true);
      this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
        try {
          const evt = JSON.parse(e);
          this.processEventsReceived(evt);
        } catch (error) {
          console.error(error);
        }
      });
    }
  };
  EventBusCoherentSync.EB_KEY = "eb.evt";
  EventBusCoherentSync.EB_LISTENER_KEY = "JS_LISTENER_SIMVARS";
  var EventBusFlowEventSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        LaunchFlowEvent("ON_MOUSERECT_HTMLEVENT", EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      Coherent.on("OnInteractionEvent", (target, args) => {
        if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
          return;
        }
        this.processEventsReceived(JSON.parse(args[2]));
      });
    }
  };
  EventBusFlowEventSync.EB_LISTENER_KEY = "EB_EVENTS";
  var EventBusListenerSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      this.isPaused = true;
      this.listener = RegisterGenericDataListener(() => {
        this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
          try {
            this.processEventsReceived(data);
          } catch (error) {
            console.error(error);
          }
        });
        this.isPaused = false;
      });
    }
  };
  EventBusListenerSync.EB_KEY = "wt.eb.evt";
  EventBusListenerSync.EB_LISTENER_KEY = "JS_LISTENER_GENERICDATA";
  var ConsumerValue = class {
    constructor(consumer, initialValue) {
      this.consumerHandler = (v) => {
        this.value = v;
      };
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialValue;
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    get isPaused() {
      return this._isPaused;
    }
    get() {
      return this.value;
    }
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    destroy() {
      var _a;
      this.isDestroyed = true;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    static create(consumer, initialValue) {
      return new ConsumerValue(consumer, initialValue);
    }
  };
  var HEventPublisher = class extends BasePublisher {
    dispatchHEvent(hEvent, sync = false) {
      this.publish("hEvent", hEvent, sync, false);
    }
  };
  var ConsumerSubject = class extends AbstractSubscribable {
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
      super();
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.consumerHandler = this.onEventConsumed.bind(this);
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialVal;
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    get isPaused() {
      return this._isPaused;
    }
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
      return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    onEventConsumed(value) {
      if (!this.equalityFunc(this.value, value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    get() {
      return this.value;
    }
    destroy() {
      var _a;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.isDestroyed = true;
    }
  };
  var CompositeLogicXMLValueType;
  (function(CompositeLogicXMLValueType2) {
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Any"] = 0] = "Any";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Number"] = 1] = "Number";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["String"] = 2] = "String";
  })(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
  var DataStore;
  (function(DataStore2) {
    function set(key, value) {
      SetStoredData(key, JSON.stringify(value));
    }
    DataStore2.set = set;
    function get(key) {
      try {
        const string = GetStoredData(key);
        return JSON.parse(string);
      } catch (e) {
        return void 0;
      }
    }
    DataStore2.get = get;
    function remove(key) {
      DeleteStoredData(key);
    }
    DataStore2.remove = remove;
  })(DataStore || (DataStore = {}));
  var GameStateProvider = class {
    constructor() {
      this.gameState = Subject.create(void 0);
      window.document.addEventListener("OnVCockpitPanelAttributesChanged", this.onAttributesChanged.bind(this));
      this.onAttributesChanged();
    }
    onAttributesChanged() {
      var _a;
      if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute("gamestate")) {
        const attribute = window.parent.document.body.getAttribute("gamestate");
        if (attribute !== null) {
          this.gameState.set(GameState[attribute]);
          return;
        }
      }
      this.gameState.set(void 0);
    }
    static get() {
      var _a;
      return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : GameStateProvider.INSTANCE = new GameStateProvider()).gameState;
    }
  };
  var KeyEventManager = class {
    constructor(keyListener, bus) {
      this.keyListener = keyListener;
      this.bus = bus;
      Coherent.on("keyIntercepted", this.onKeyIntercepted.bind(this));
    }
    onKeyIntercepted(key, value1, value0, value2) {
      if (value0 !== void 0 && value0 >= 2147483648) {
        value0 -= 4294967296;
      }
      this.bus.pub("key_intercept", { key, value0, value1, value2 }, false, false);
    }
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
      return Coherent.call("TRIGGER_KEY_EVENT", key, bypass, value0, value1, value2);
    }
    interceptKey(key, passThrough) {
      Coherent.call("INTERCEPT_KEY_EVENT", key, passThrough ? 0 : 1);
    }
    static getManager(bus) {
      if (KeyEventManager.INSTANCE) {
        return Promise.resolve(KeyEventManager.INSTANCE);
      }
      if (!KeyEventManager.isCreatingInstance) {
        KeyEventManager.createInstance(bus);
      }
      return new Promise((resolve) => {
        KeyEventManager.pendingPromiseResolves.push(resolve);
      });
    }
    static async createInstance(bus) {
      KeyEventManager.isCreatingInstance = true;
      KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
      KeyEventManager.isCreatingInstance = false;
      for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
        KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
      }
    }
    static create(bus) {
      return new Promise((resolve, reject) => {
        const gameState = GameStateProvider.get();
        const sub = gameState.sub((state) => {
          if (window["IsDestroying"]) {
            sub.destroy();
            reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            sub.destroy();
            const keyListener = RegisterViewListener("JS_LISTENER_KEYEVENT", () => {
              if (window["IsDestroying"]) {
                reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
                return;
              }
              resolve(new KeyEventManager(keyListener, bus));
            });
          }
        }, false, true);
        sub.resume(true);
      });
    }
  };
  KeyEventManager.isCreatingInstance = false;
  KeyEventManager.pendingPromiseResolves = [];
  var FacilityFrequencyType;
  (function(FacilityFrequencyType2) {
    FacilityFrequencyType2[FacilityFrequencyType2["None"] = 0] = "None";
    FacilityFrequencyType2[FacilityFrequencyType2["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType2[FacilityFrequencyType2["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType2[FacilityFrequencyType2["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType2[FacilityFrequencyType2["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType2[FacilityFrequencyType2["Ground"] = 5] = "Ground";
    FacilityFrequencyType2[FacilityFrequencyType2["Tower"] = 6] = "Tower";
    FacilityFrequencyType2[FacilityFrequencyType2["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType2[FacilityFrequencyType2["Approach"] = 8] = "Approach";
    FacilityFrequencyType2[FacilityFrequencyType2["Departure"] = 9] = "Departure";
    FacilityFrequencyType2[FacilityFrequencyType2["Center"] = 10] = "Center";
    FacilityFrequencyType2[FacilityFrequencyType2["FSS"] = 11] = "FSS";
    FacilityFrequencyType2[FacilityFrequencyType2["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType2[FacilityFrequencyType2["ASOS"] = 13] = "ASOS";
    FacilityFrequencyType2[FacilityFrequencyType2["CPT"] = 14] = "CPT";
    FacilityFrequencyType2[FacilityFrequencyType2["GCO"] = 15] = "GCO";
  })(FacilityFrequencyType || (FacilityFrequencyType = {}));
  var AdditionalApproachType;
  (function(AdditionalApproachType2) {
    AdditionalApproachType2[AdditionalApproachType2["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
  })(AdditionalApproachType || (AdditionalApproachType = {}));
  var FixTypeFlags;
  (function(FixTypeFlags2) {
    FixTypeFlags2[FixTypeFlags2["None"] = 0] = "None";
    FixTypeFlags2[FixTypeFlags2["IAF"] = 1] = "IAF";
    FixTypeFlags2[FixTypeFlags2["IF"] = 2] = "IF";
    FixTypeFlags2[FixTypeFlags2["MAP"] = 4] = "MAP";
    FixTypeFlags2[FixTypeFlags2["FAF"] = 8] = "FAF";
    FixTypeFlags2[FixTypeFlags2["MAHP"] = 16] = "MAHP";
  })(FixTypeFlags || (FixTypeFlags = {}));
  var RnavTypeFlags;
  (function(RnavTypeFlags2) {
    RnavTypeFlags2[RnavTypeFlags2["None"] = 0] = "None";
    RnavTypeFlags2[RnavTypeFlags2["LNAV"] = 1] = "LNAV";
    RnavTypeFlags2[RnavTypeFlags2["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags2[RnavTypeFlags2["LP"] = 4] = "LP";
    RnavTypeFlags2[RnavTypeFlags2["LPV"] = 8] = "LPV";
  })(RnavTypeFlags || (RnavTypeFlags = {}));
  var AirportClass;
  (function(AirportClass2) {
    AirportClass2[AirportClass2["None"] = 0] = "None";
    AirportClass2[AirportClass2["HardSurface"] = 1] = "HardSurface";
    AirportClass2[AirportClass2["SoftSurface"] = 2] = "SoftSurface";
    AirportClass2[AirportClass2["AllWater"] = 3] = "AllWater";
    AirportClass2[AirportClass2["HeliportOnly"] = 4] = "HeliportOnly";
    AirportClass2[AirportClass2["Private"] = 5] = "Private";
  })(AirportClass || (AirportClass = {}));
  var AirportClassMask;
  (function(AirportClassMask2) {
    AirportClassMask2[AirportClassMask2["None"] = 0] = "None";
    AirportClassMask2[AirportClassMask2["HardSurface"] = 2] = "HardSurface";
    AirportClassMask2[AirportClassMask2["SoftSurface"] = 4] = "SoftSurface";
    AirportClassMask2[AirportClassMask2["AllWater"] = 8] = "AllWater";
    AirportClassMask2[AirportClassMask2["HeliportOnly"] = 16] = "HeliportOnly";
    AirportClassMask2[AirportClassMask2["Private"] = 32] = "Private";
  })(AirportClassMask || (AirportClassMask = {}));
  var IntersectionType;
  (function(IntersectionType2) {
    IntersectionType2[IntersectionType2["None"] = 0] = "None";
    IntersectionType2[IntersectionType2["Named"] = 1] = "Named";
    IntersectionType2[IntersectionType2["Unnamed"] = 2] = "Unnamed";
    IntersectionType2[IntersectionType2["Vor"] = 3] = "Vor";
    IntersectionType2[IntersectionType2["NDB"] = 4] = "NDB";
    IntersectionType2[IntersectionType2["Offroute"] = 5] = "Offroute";
    IntersectionType2[IntersectionType2["IAF"] = 6] = "IAF";
    IntersectionType2[IntersectionType2["FAF"] = 7] = "FAF";
    IntersectionType2[IntersectionType2["RNAV"] = 8] = "RNAV";
    IntersectionType2[IntersectionType2["VFR"] = 9] = "VFR";
  })(IntersectionType || (IntersectionType = {}));
  var UserFacilityType;
  (function(UserFacilityType2) {
    UserFacilityType2[UserFacilityType2["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType2[UserFacilityType2["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType2[UserFacilityType2["LAT_LONG"] = 2] = "LAT_LONG";
  })(UserFacilityType || (UserFacilityType = {}));
  var LegType;
  (function(LegType2) {
    LegType2[LegType2["Unknown"] = 0] = "Unknown";
    LegType2[LegType2["AF"] = 1] = "AF";
    LegType2[LegType2["CA"] = 2] = "CA";
    LegType2[LegType2["CD"] = 3] = "CD";
    LegType2[LegType2["CF"] = 4] = "CF";
    LegType2[LegType2["CI"] = 5] = "CI";
    LegType2[LegType2["CR"] = 6] = "CR";
    LegType2[LegType2["DF"] = 7] = "DF";
    LegType2[LegType2["FA"] = 8] = "FA";
    LegType2[LegType2["FC"] = 9] = "FC";
    LegType2[LegType2["FD"] = 10] = "FD";
    LegType2[LegType2["FM"] = 11] = "FM";
    LegType2[LegType2["HA"] = 12] = "HA";
    LegType2[LegType2["HF"] = 13] = "HF";
    LegType2[LegType2["HM"] = 14] = "HM";
    LegType2[LegType2["IF"] = 15] = "IF";
    LegType2[LegType2["PI"] = 16] = "PI";
    LegType2[LegType2["RF"] = 17] = "RF";
    LegType2[LegType2["TF"] = 18] = "TF";
    LegType2[LegType2["VA"] = 19] = "VA";
    LegType2[LegType2["VD"] = 20] = "VD";
    LegType2[LegType2["VI"] = 21] = "VI";
    LegType2[LegType2["VM"] = 22] = "VM";
    LegType2[LegType2["VR"] = 23] = "VR";
    LegType2[LegType2["Discontinuity"] = 99] = "Discontinuity";
    LegType2[LegType2["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
  })(LegType || (LegType = {}));
  var AltitudeRestrictionType;
  (function(AltitudeRestrictionType2) {
    AltitudeRestrictionType2[AltitudeRestrictionType2["Unused"] = 0] = "Unused";
    AltitudeRestrictionType2[AltitudeRestrictionType2["At"] = 1] = "At";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType2[AltitudeRestrictionType2["Between"] = 4] = "Between";
  })(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
  var LegTurnDirection;
  (function(LegTurnDirection2) {
    LegTurnDirection2[LegTurnDirection2["None"] = 0] = "None";
    LegTurnDirection2[LegTurnDirection2["Left"] = 1] = "Left";
    LegTurnDirection2[LegTurnDirection2["Right"] = 2] = "Right";
    LegTurnDirection2[LegTurnDirection2["Either"] = 3] = "Either";
  })(LegTurnDirection || (LegTurnDirection = {}));
  var AirwayType;
  (function(AirwayType2) {
    AirwayType2[AirwayType2["None"] = 0] = "None";
    AirwayType2[AirwayType2["Victor"] = 1] = "Victor";
    AirwayType2[AirwayType2["Jet"] = 2] = "Jet";
    AirwayType2[AirwayType2["Both"] = 3] = "Both";
  })(AirwayType || (AirwayType = {}));
  var NdbType;
  (function(NdbType2) {
    NdbType2[NdbType2["CompassPoint"] = 0] = "CompassPoint";
    NdbType2[NdbType2["MH"] = 1] = "MH";
    NdbType2[NdbType2["H"] = 2] = "H";
    NdbType2[NdbType2["HH"] = 3] = "HH";
  })(NdbType || (NdbType = {}));
  var VorType;
  (function(VorType2) {
    VorType2[VorType2["Unknown"] = 0] = "Unknown";
    VorType2[VorType2["VOR"] = 1] = "VOR";
    VorType2[VorType2["VORDME"] = 2] = "VORDME";
    VorType2[VorType2["DME"] = 3] = "DME";
    VorType2[VorType2["TACAN"] = 4] = "TACAN";
    VorType2[VorType2["VORTAC"] = 5] = "VORTAC";
    VorType2[VorType2["ILS"] = 6] = "ILS";
    VorType2[VorType2["VOT"] = 7] = "VOT";
  })(VorType || (VorType = {}));
  var RunwaySurfaceType;
  (function(RunwaySurfaceType2) {
    RunwaySurfaceType2[RunwaySurfaceType2["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType2[RunwaySurfaceType2["Grass"] = 1] = "Grass";
    RunwaySurfaceType2[RunwaySurfaceType2["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType2[RunwaySurfaceType2["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType2[RunwaySurfaceType2["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType2[RunwaySurfaceType2["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType2[RunwaySurfaceType2["Snow"] = 8] = "Snow";
    RunwaySurfaceType2[RunwaySurfaceType2["Ice"] = 9] = "Ice";
    RunwaySurfaceType2[RunwaySurfaceType2["Urban"] = 10] = "Urban";
    RunwaySurfaceType2[RunwaySurfaceType2["Forest"] = 11] = "Forest";
    RunwaySurfaceType2[RunwaySurfaceType2["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType2[RunwaySurfaceType2["Coral"] = 13] = "Coral";
    RunwaySurfaceType2[RunwaySurfaceType2["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType2[RunwaySurfaceType2["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType2[RunwaySurfaceType2["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType2[RunwaySurfaceType2["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType2[RunwaySurfaceType2["Brick"] = 18] = "Brick";
    RunwaySurfaceType2[RunwaySurfaceType2["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType2[RunwaySurfaceType2["Planks"] = 20] = "Planks";
    RunwaySurfaceType2[RunwaySurfaceType2["Sand"] = 21] = "Sand";
    RunwaySurfaceType2[RunwaySurfaceType2["Shale"] = 22] = "Shale";
    RunwaySurfaceType2[RunwaySurfaceType2["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType2[RunwaySurfaceType2["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    RunwaySurfaceType2[RunwaySurfaceType2["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType2[RunwaySurfaceType2["Water"] = 27] = "Water";
    RunwaySurfaceType2[RunwaySurfaceType2["Pond"] = 28] = "Pond";
    RunwaySurfaceType2[RunwaySurfaceType2["Lake"] = 29] = "Lake";
    RunwaySurfaceType2[RunwaySurfaceType2["River"] = 30] = "River";
    RunwaySurfaceType2[RunwaySurfaceType2["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType2[RunwaySurfaceType2["Paint"] = 32] = "Paint";
  })(RunwaySurfaceType || (RunwaySurfaceType = {}));
  var RunwayLightingType;
  (function(RunwayLightingType2) {
    RunwayLightingType2[RunwayLightingType2["Unknown"] = 0] = "Unknown";
    RunwayLightingType2[RunwayLightingType2["None"] = 1] = "None";
    RunwayLightingType2[RunwayLightingType2["PartTime"] = 2] = "PartTime";
    RunwayLightingType2[RunwayLightingType2["FullTime"] = 3] = "FullTime";
    RunwayLightingType2[RunwayLightingType2["Frequency"] = 4] = "Frequency";
  })(RunwayLightingType || (RunwayLightingType = {}));
  var AirportPrivateType;
  (function(AirportPrivateType2) {
    AirportPrivateType2[AirportPrivateType2["Uknown"] = 0] = "Uknown";
    AirportPrivateType2[AirportPrivateType2["Public"] = 1] = "Public";
    AirportPrivateType2[AirportPrivateType2["Military"] = 2] = "Military";
    AirportPrivateType2[AirportPrivateType2["Private"] = 3] = "Private";
  })(AirportPrivateType || (AirportPrivateType = {}));
  var GpsBoolean;
  (function(GpsBoolean2) {
    GpsBoolean2[GpsBoolean2["Unknown"] = 0] = "Unknown";
    GpsBoolean2[GpsBoolean2["No"] = 1] = "No";
    GpsBoolean2[GpsBoolean2["Yes"] = 2] = "Yes";
  })(GpsBoolean || (GpsBoolean = {}));
  var VorClass;
  (function(VorClass2) {
    VorClass2[VorClass2["Unknown"] = 0] = "Unknown";
    VorClass2[VorClass2["Terminal"] = 1] = "Terminal";
    VorClass2[VorClass2["LowAlt"] = 2] = "LowAlt";
    VorClass2[VorClass2["HighAlt"] = 3] = "HighAlt";
    VorClass2[VorClass2["ILS"] = 4] = "ILS";
    VorClass2[VorClass2["VOT"] = 5] = "VOT";
  })(VorClass || (VorClass = {}));
  var FacilityType;
  (function(FacilityType2) {
    FacilityType2["Airport"] = "LOAD_AIRPORT";
    FacilityType2["Intersection"] = "LOAD_INTERSECTION";
    FacilityType2["VOR"] = "LOAD_VOR";
    FacilityType2["NDB"] = "LOAD_NDB";
    FacilityType2["USR"] = "USR";
    FacilityType2["RWY"] = "RWY";
    FacilityType2["VIS"] = "VIS";
  })(FacilityType || (FacilityType = {}));
  var FacilitySearchType;
  (function(FacilitySearchType2) {
    FacilitySearchType2[FacilitySearchType2["All"] = 0] = "All";
    FacilitySearchType2[FacilitySearchType2["Airport"] = 1] = "Airport";
    FacilitySearchType2[FacilitySearchType2["Intersection"] = 2] = "Intersection";
    FacilitySearchType2[FacilitySearchType2["Vor"] = 3] = "Vor";
    FacilitySearchType2[FacilitySearchType2["Ndb"] = 4] = "Ndb";
    FacilitySearchType2[FacilitySearchType2["Boundary"] = 5] = "Boundary";
    FacilitySearchType2[FacilitySearchType2["User"] = 6] = "User";
    FacilitySearchType2[FacilitySearchType2["Visual"] = 7] = "Visual";
    FacilitySearchType2[FacilitySearchType2["AllExceptVisual"] = 8] = "AllExceptVisual";
  })(FacilitySearchType || (FacilitySearchType = {}));
  var BoundaryType;
  (function(BoundaryType2) {
    BoundaryType2[BoundaryType2["None"] = 0] = "None";
    BoundaryType2[BoundaryType2["Center"] = 1] = "Center";
    BoundaryType2[BoundaryType2["ClassA"] = 2] = "ClassA";
    BoundaryType2[BoundaryType2["ClassB"] = 3] = "ClassB";
    BoundaryType2[BoundaryType2["ClassC"] = 4] = "ClassC";
    BoundaryType2[BoundaryType2["ClassD"] = 5] = "ClassD";
    BoundaryType2[BoundaryType2["ClassE"] = 6] = "ClassE";
    BoundaryType2[BoundaryType2["ClassF"] = 7] = "ClassF";
    BoundaryType2[BoundaryType2["ClassG"] = 8] = "ClassG";
    BoundaryType2[BoundaryType2["Tower"] = 9] = "Tower";
    BoundaryType2[BoundaryType2["Clearance"] = 10] = "Clearance";
    BoundaryType2[BoundaryType2["Ground"] = 11] = "Ground";
    BoundaryType2[BoundaryType2["Departure"] = 12] = "Departure";
    BoundaryType2[BoundaryType2["Approach"] = 13] = "Approach";
    BoundaryType2[BoundaryType2["MOA"] = 14] = "MOA";
    BoundaryType2[BoundaryType2["Restricted"] = 15] = "Restricted";
    BoundaryType2[BoundaryType2["Prohibited"] = 16] = "Prohibited";
    BoundaryType2[BoundaryType2["Warning"] = 17] = "Warning";
    BoundaryType2[BoundaryType2["Alert"] = 18] = "Alert";
    BoundaryType2[BoundaryType2["Danger"] = 19] = "Danger";
    BoundaryType2[BoundaryType2["NationalPark"] = 20] = "NationalPark";
    BoundaryType2[BoundaryType2["ModeC"] = 21] = "ModeC";
    BoundaryType2[BoundaryType2["Radar"] = 22] = "Radar";
    BoundaryType2[BoundaryType2["Training"] = 23] = "Training";
  })(BoundaryType || (BoundaryType = {}));
  var BoundaryAltitudeType;
  (function(BoundaryAltitudeType2) {
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType2[BoundaryAltitudeType2["MSL"] = 1] = "MSL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["AGL"] = 2] = "AGL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unlimited"] = 3] = "Unlimited";
  })(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
  var BoundaryVectorType;
  (function(BoundaryVectorType2) {
    BoundaryVectorType2[BoundaryVectorType2["None"] = 0] = "None";
    BoundaryVectorType2[BoundaryVectorType2["Start"] = 1] = "Start";
    BoundaryVectorType2[BoundaryVectorType2["Line"] = 2] = "Line";
    BoundaryVectorType2[BoundaryVectorType2["Origin"] = 3] = "Origin";
    BoundaryVectorType2[BoundaryVectorType2["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType2[BoundaryVectorType2["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType2[BoundaryVectorType2["Circle"] = 6] = "Circle";
  })(BoundaryVectorType || (BoundaryVectorType = {}));
  var MetarWindSpeedUnits;
  (function(MetarWindSpeedUnits2) {
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["KilometerPerHour"] = 2] = "KilometerPerHour";
  })(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
  var MetarVisibilityUnits;
  (function(MetarVisibilityUnits2) {
    MetarVisibilityUnits2[MetarVisibilityUnits2["Meter"] = 0] = "Meter";
    MetarVisibilityUnits2[MetarVisibilityUnits2["StatuteMile"] = 1] = "StatuteMile";
  })(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
  var MetarCloudLayerCoverage;
  (function(MetarCloudLayerCoverage2) {
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Few"] = 3] = "Few";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Overcast"] = 6] = "Overcast";
  })(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
  var MetarCloudLayerType;
  (function(MetarCloudLayerType2) {
    MetarCloudLayerType2[MetarCloudLayerType2["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType2[MetarCloudLayerType2["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType2[MetarCloudLayerType2["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType2[MetarCloudLayerType2["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
  })(MetarCloudLayerType || (MetarCloudLayerType = {}));
  var MetarPhenomenonType;
  (function(MetarPhenomenonType2) {
    MetarPhenomenonType2[MetarPhenomenonType2["None"] = 0] = "None";
    MetarPhenomenonType2[MetarPhenomenonType2["Mist"] = 1] = "Mist";
    MetarPhenomenonType2[MetarPhenomenonType2["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType2[MetarPhenomenonType2["Dust"] = 3] = "Dust";
    MetarPhenomenonType2[MetarPhenomenonType2["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType2[MetarPhenomenonType2["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType2[MetarPhenomenonType2["Fog"] = 6] = "Fog";
    MetarPhenomenonType2[MetarPhenomenonType2["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType2[MetarPhenomenonType2["Hail"] = 8] = "Hail";
    MetarPhenomenonType2[MetarPhenomenonType2["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType2[MetarPhenomenonType2["Haze"] = 10] = "Haze";
    MetarPhenomenonType2[MetarPhenomenonType2["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType2[MetarPhenomenonType2["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType2[MetarPhenomenonType2["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType2[MetarPhenomenonType2["Spray"] = 14] = "Spray";
    MetarPhenomenonType2[MetarPhenomenonType2["Rain"] = 15] = "Rain";
    MetarPhenomenonType2[MetarPhenomenonType2["Sand"] = 16] = "Sand";
    MetarPhenomenonType2[MetarPhenomenonType2["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType2[MetarPhenomenonType2["Shower"] = 18] = "Shower";
    MetarPhenomenonType2[MetarPhenomenonType2["Snow"] = 19] = "Snow";
    MetarPhenomenonType2[MetarPhenomenonType2["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType2[MetarPhenomenonType2["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType2[MetarPhenomenonType2["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType2[MetarPhenomenonType2["VolcanicAsh"] = 23] = "VolcanicAsh";
  })(MetarPhenomenonType || (MetarPhenomenonType = {}));
  var MetarPhenomenonIntensity;
  (function(MetarPhenomenonIntensity2) {
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Light"] = -1] = "Light";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Heavy"] = 1] = "Heavy";
  })(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
  var ICAO = class {
    static getFacilityType(icao) {
      switch (icao[0]) {
        case "A":
          return FacilityType.Airport;
        case "W":
          return FacilityType.Intersection;
        case "V":
          return FacilityType.VOR;
        case "N":
          return FacilityType.NDB;
        case "U":
          return FacilityType.USR;
        case "R":
          return FacilityType.RWY;
        case "S":
          return FacilityType.VIS;
        default:
          throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
      }
    }
    static getAssociatedAirportIdent(icao) {
      return icao.substr(3, 4).trim();
    }
    static isFacility(icao, type) {
      switch (icao[0]) {
        case "A":
          return type === void 0 || type === FacilityType.Airport;
        case "W":
          return type === void 0 || type === FacilityType.Intersection;
        case "V":
          return type === void 0 || type === FacilityType.VOR;
        case "N":
          return type === void 0 || type === FacilityType.NDB;
        case "U":
          return type === void 0 || type === FacilityType.USR;
        case "R":
          return type === void 0 || type === FacilityType.RWY;
        case "S":
          return type === void 0 || type === FacilityType.VIS;
        default:
          return false;
      }
    }
    static getIdent(icao) {
      return icao.substr(7).trim();
    }
    static getRegionCode(icao) {
      return icao.substr(1, 2).trim();
    }
  };
  ICAO.emptyIcao = "            ";
  var FacilityUtils = class {
    static isFacilityType(facility, type) {
      if (facility["__Type"] === "JS_FacilityIntersection") {
        return type === FacilityType.Intersection;
      }
      return ICAO.isFacility(facility.icao, type);
    }
    static getMagVar(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
        return -facility.magneticVariation;
      } else {
        return MagVar.get(facility.lat, facility.lon);
      }
    }
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
      return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
      const magVar1 = FacilityUtils.getMagVar(reference1);
      const magVar2 = FacilityUtils.getMagVar(reference2);
      const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
      const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
      const radial1IncludesRef2 = radialCircle1.includes(reference2);
      const radial2IncludesRef1 = radialCircle2.includes(reference1);
      if (radial1IncludesRef2 && radial2IncludesRef1) {
        return out.set(NaN, NaN);
      } else if (radial1IncludesRef2) {
        return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
      } else if (radial2IncludesRef1) {
        return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
      }
      const numIntersections = radialCircle1.encircles(reference2) ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache) : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
      if (numIntersections === 0) {
        return out.set(NaN, NaN);
      }
      return out.set(FacilityUtils.intersectionCache[0]);
    }
  };
  FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
  FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var IntersectionFacilityUtils = class {
    static isTerminal(arg) {
      const icao = typeof arg === "string" ? arg : arg.icao;
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao);
    }
    static getNonTerminalICAO(icao) {
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao) ? `${icao.substring(0, 3)}    ${icao.substring(7)}` : icao;
    }
    static getIcaoIdentity(icao) {
      return icao;
    }
    static getIcaoFacility(facility) {
      return facility.icao;
    }
    static filterDuplicates(array, arg2, arg3) {
      if (array.length === 0) {
        return [];
      }
      let getIcao;
      let retainTerminal;
      if (typeof arg2 === "function") {
        getIcao = arg2;
        retainTerminal = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        retainTerminal = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        if (typeof array[0] === "string") {
          getIcao = IntersectionFacilityUtils.getIcaoIdentity;
        } else {
          getIcao = IntersectionFacilityUtils.getIcaoFacility;
        }
      }
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      for (let i = 0; i < array.length; i++) {
        const icao = getIcao(array[i]);
        if (ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) === retainTerminal) {
          IntersectionFacilityUtils.filterDuplicatesSet.add(IntersectionFacilityUtils.getNonTerminalICAO(icao));
        }
      }
      if (IntersectionFacilityUtils.filterDuplicatesSet.size === 0) {
        return array.slice();
      }
      const filtered = array.filter((icao) => {
        return IntersectionFacilityUtils.filterDuplicatesHelper(icao, getIcao, retainTerminal, IntersectionFacilityUtils.filterDuplicatesSet);
      });
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      return filtered;
    }
    static filterDuplicatesHelper(element, getIcao, retainTerminal, nonTerminalIcaosToFilter) {
      const icao = getIcao(element);
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        return true;
      }
      const isTerminal = IntersectionFacilityUtils.isTerminal(icao);
      if (isTerminal === retainTerminal) {
        return true;
      }
      if (isTerminal) {
        return !nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao));
      } else {
        return !nonTerminalIcaosToFilter.has(icao);
      }
    }
  };
  IntersectionFacilityUtils.TERMINAL_REGEX = /^...[a-zA-Z\d]/;
  IntersectionFacilityUtils.filterDuplicatesSet = /* @__PURE__ */ new Set();
  var UserFacilityUtils = class {
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
      const fac = {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat,
        lon,
        userFacilityType: UserFacilityType.LAT_LONG,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(lat, lon)
      };
      return fac;
    }
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
      const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
      return {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_DISTANCE,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference.icao,
        reference1Radial: radial,
        reference1MagVar: FacilityUtils.getMagVar(reference),
        reference1Distance: distance
      };
    }
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
      const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
      if (isNaN(location.lat) || isNaN(location.lon)) {
        return void 0;
      }
      return {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_RADIAL,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference1.icao,
        reference1Radial: radial1,
        reference1MagVar: FacilityUtils.getMagVar(reference1),
        reference2Icao: reference2.icao,
        reference2Radial: radial2,
        reference2MagVar: FacilityUtils.getMagVar(reference2)
      };
    }
  };
  UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  var RunwaySurfaceCategory;
  (function(RunwaySurfaceCategory2) {
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Water"] = 8] = "Water";
  })(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
  var RunwayUtils = class {
    static getDesignatorLetter(designator, lowerCase = false) {
      const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
      return lowerCase ? letter.toLowerCase() : letter;
    }
    static createEmptyOneWayRunway() {
      return {
        parentRunwayIndex: -1,
        designation: "",
        direction: 36,
        runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
        course: 0,
        elevation: 0,
        elevationEnd: 0,
        gradient: 0,
        latitude: 0,
        longitude: 0,
        length: 0,
        width: 0,
        startThresholdLength: 0,
        endThresholdLength: 0,
        surface: RunwaySurfaceType.Concrete,
        lighting: RunwayLightingType.Unknown
      };
    }
    static getOneWayRunwaysFromAirport(airport) {
      const runways = [];
      airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach((d) => {
        runways.push(d[0]);
        runways.push(d[1]);
      });
      runways.sort(RunwayUtils.sortRunways);
      return runways;
    }
    static getOneWayRunways(runway, index) {
      const splitRunways = [];
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        let course = 0;
        let thresholdDistanceFromCenter = 0;
        let thresholdElevation = 0;
        let endThresholdElevation = 0;
        let ilsFrequency;
        let startThresholdLength = 0, endThresholdLength = 0;
        if (i === 0) {
          designator = runway.designatorCharPrimary;
          course = runway.direction;
          thresholdDistanceFromCenter = runway.length / 2 - runway.primaryThresholdLength;
          thresholdElevation = runway.primaryElevation;
          endThresholdElevation = runway.secondaryElevation;
          ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? void 0 : runway.primaryILSFrequency;
          startThresholdLength = runway.primaryThresholdLength;
          endThresholdLength = runway.secondaryThresholdLength;
        } else if (i === 1) {
          designator = runway.designatorCharSecondary;
          course = NavMath.normalizeHeading(runway.direction + 180);
          thresholdDistanceFromCenter = runway.length / 2 - runway.secondaryThresholdLength;
          thresholdElevation = runway.secondaryElevation;
          endThresholdElevation = runway.primaryElevation;
          ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? void 0 : runway.secondaryILSFrequency;
          startThresholdLength = runway.secondaryThresholdLength;
          endThresholdLength = runway.primaryThresholdLength;
        }
        const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
        const coordinates = RunwayUtils.tempGeoPoint.set(runway.latitude, runway.longitude).offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
        splitRunways.push({
          parentRunwayIndex: index,
          designation,
          direction: runwayNumber,
          runwayDesignator: designator,
          course,
          elevation: thresholdElevation,
          elevationEnd: endThresholdElevation,
          gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
          latitude: coordinates.lat,
          longitude: coordinates.lon,
          ilsFrequency,
          length: runway.length,
          width: runway.width,
          startThresholdLength,
          endThresholdLength,
          surface: runway.surface,
          lighting: runway.lighting
        });
      }
      return splitRunways;
    }
    static getRunwayPairNameString(runway, padded = true) {
      const pad = padded ? 2 : 0;
      const dashIndex = runway.designation.search("-");
      const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
      const secondary = dashIndex < 0 ? "" : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
      return primary + secondary;
    }
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = "") {
      let numberText = `${runwayNumber}`;
      if (padded) {
        numberText = numberText.padStart(2, "0");
      }
      return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    static getRunwayNumberPrimary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return parseInt(runway.designation);
      } else {
        return parseInt(runway.designation.substring(0, dashIndex));
      }
    }
    static getRunwayNumberSecondary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return void 0;
      } else {
        return parseInt(runway.designation.substring(dashIndex + 1));
      }
    }
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const length = airport.runways.length;
      for (let r = 0; r < length; r++) {
        const runway = airport.runways[r];
        const designation = runway.designation;
        const primaryRunwayNumber = parseInt(designation.split("-")[0]);
        const secondaryRunwayNumber = parseInt(designation.split("-")[1]);
        if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
          const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
          return oneWayRunways[0];
        } else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
          const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
          return oneWayRunways[1];
        }
      }
      return void 0;
    }
    static matchOneWayRunwayFromDesignation(airport, designation) {
      const length = airport.runways.length;
      for (let i = 0; i < length; i++) {
        const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
          return r.designation === designation;
        });
        if (match) {
          return match;
        }
      }
      return void 0;
    }
    static matchOneWayRunwayFromIdent(airport, ident) {
      return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    static getProceduresForRunway(procedures, runway) {
      const oneways = new Array();
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let runwayName;
        if (i === 0) {
          runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, "");
        } else {
          runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, "");
        }
        oneways.push(runwayName);
      }
      const found = new Array();
      for (const procedure of procedures) {
        if (oneways.includes(procedure.runway.trim())) {
          found.push(procedure);
        } else if (procedure.runwayNumber === 0) {
          found.push(procedure);
        }
      }
      return found;
    }
    static getLocFrequency(airport, arg1, arg2) {
      let runway;
      if (typeof arg1 === "string") {
        const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else if (typeof arg1 === "number") {
        const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else {
        runway = arg1;
      }
      const runwayDesignation = runway.designation;
      if (runway.ilsFrequency) {
        return runway.ilsFrequency;
      }
      for (let i = 0; i < airport.frequencies.length; i++) {
        const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ""));
        if (match > -1) {
          return airport.frequencies[i];
        }
      }
      return void 0;
    }
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
      const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
      if (!matchedRunway) {
        return void 0;
      }
      return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
      let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
      switch (runwayDesignator) {
        case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
          break;
        case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
          break;
        default:
          oppositeRunwayDesignator = runwayDesignator;
          break;
      }
      return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    static sortRunways(r1, r2) {
      if (r1.direction === r2.direction) {
        let v1 = 0;
        if (r1.designation.indexOf("L") != -1) {
          v1 = 1;
        } else if (r1.designation.indexOf("C") != -1) {
          v1 = 2;
        } else if (r1.designation.indexOf("R") != -1) {
          v1 = 3;
        }
        let v2 = 0;
        if (r2.designation.indexOf("L") != -1) {
          v2 = 1;
        } else if (r2.designation.indexOf("C") != -1) {
          v2 = 2;
        } else if (r2.designation.indexOf("R") != -1) {
          v2 = 3;
        }
        return v1 - v2;
      }
      return r1.direction - r2.direction;
    }
    static getRunwayFacilityIcao(airport, runway) {
      const icao = typeof airport === "string" ? airport : airport.icao;
      return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, " ")}`;
    }
    static createRunwayFacility(airport, runway) {
      return {
        icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
        name: `Runway ${runway.designation}`,
        region: airport.region,
        city: airport.city,
        lat: runway.latitude,
        lon: runway.longitude,
        magvar: airport.magvar,
        runway
      };
    }
    static getRunwayCode(number) {
      const n = Math.round(number);
      return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    static getSurfaceCategory(runway) {
      const surface = typeof runway === "object" ? runway.surface : runway;
      if (this.SURFACES_HARD.includes(surface)) {
        return RunwaySurfaceCategory.Hard;
      } else if (this.SURFACES_SOFT.includes(surface)) {
        return RunwaySurfaceCategory.Soft;
      } else if (this.SURFACES_WATER.includes(surface)) {
        return RunwaySurfaceCategory.Water;
      } else {
        return RunwaySurfaceCategory.Unknown;
      }
    }
  };
  RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: "",
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: "L",
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: "R",
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: "C",
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: "W",
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: "A",
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: "B"
  };
  RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban
  ];
  RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
  ];
  RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
  ];
  RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);
  var AirportUtils = class {
    static tryGetRegionCode(facility) {
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        if (approach.runway.length === 0 || approach.finalLegs.length === 0) {
          continue;
        }
        const fixIcao = approach.finalLegs[approach.finalLegs.length - 1].fixIcao;
        if (ICAO.isFacility(fixIcao, FacilityType.RWY)) {
          const region = ICAO.getRegionCode(fixIcao);
          if (AirportUtils.REGION_CODES.has(region)) {
            return region;
          }
        }
      }
      if (facility.approaches.length > 1) {
        let region = void 0;
        let regionCount = 0;
        for (let i = 0; i < facility.approaches.length; i++) {
          const approach = facility.approaches[i];
          for (let j = 0; j < approach.finalLegs.length; j++) {
            const leg = approach.finalLegs[j];
            if (leg.fixTypeFlags === FixTypeFlags.FAF && ICAO.isFacility(leg.fixIcao)) {
              const fafRegion = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(fafRegion)) {
                region !== null && region !== void 0 ? region : region = fafRegion;
                if (region !== fafRegion) {
                  region = void 0;
                }
                regionCount++;
                break;
              }
            }
          }
          if (region === void 0 && regionCount > 0) {
            break;
          }
        }
        if (region !== void 0 && regionCount > 1) {
          return region;
        }
      }
      const ident = ICAO.getIdent(facility.icao);
      if (ident.length === 4 && ident.search(AirportUtils.NUMERAL_REGEX) < 0) {
        const region = ident.substring(0, 2);
        if (AirportUtils.REGION_CODES.has(region)) {
          return region;
        }
      }
      for (let i = 0; i < facility.departures.length; i++) {
        const departure = facility.departures[i];
        for (let j = 0; j < departure.commonLegs.length; j++) {
          const leg = departure.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < departure.runwayTransitions.length; j++) {
          const transition = departure.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.arrivals.length; i++) {
        const arrival = facility.arrivals[i];
        for (let j = 0; j < arrival.commonLegs.length; j++) {
          const leg = arrival.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < arrival.runwayTransitions.length; j++) {
          const transition = arrival.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        for (let j = 0; j < approach.finalLegs.length; j++) {
          const leg = approach.finalLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < approach.transitions.length; j++) {
          const transition = approach.transitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      return void 0;
    }
    static getElevation(facility) {
      if (facility.runways.length === 0) {
        return void 0;
      }
      return facility.runways.reduce((sum, runway) => sum + runway.elevation, 0) / facility.runways.length;
    }
    static getLongestRunway(facility) {
      let longestRunway = null;
      for (const runway of facility.runways) {
        if (longestRunway === null || runway.length > longestRunway.length) {
          longestRunway = runway;
        }
      }
      return longestRunway;
    }
    static getFilteredRunways(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      const result = [];
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
            result.push(runway);
          }
        }
      }
      return result;
    }
    static hasMatchingRunway(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
            return true;
          }
        }
      }
      return false;
    }
  };
  AirportUtils.REGION_CODES = /* @__PURE__ */ new Set([
    "AG",
    "AN",
    "AY",
    "BG",
    "BI",
    "BK",
    "CY",
    "DA",
    "DB",
    "DF",
    "DG",
    "DI",
    "DN",
    "DR",
    "DT",
    "DX",
    "EB",
    "ED",
    "EE",
    "EF",
    "EG",
    "EH",
    "EI",
    "EK",
    "EL",
    "EN",
    "EP",
    "ES",
    "ET",
    "EV",
    "EY",
    "FA",
    "FB",
    "FC",
    "FD",
    "FE",
    "FG",
    "FH",
    "FI",
    "FJ",
    "FK",
    "FL",
    "FM",
    "FN",
    "FO",
    "FP",
    "FQ",
    "FS",
    "FT",
    "FV",
    "FW",
    "FX",
    "FY",
    "FZ",
    "GA",
    "GB",
    "GC",
    "GE",
    "GF",
    "GG",
    "GL",
    "GM",
    "GO",
    "GQ",
    "GS",
    "GU",
    "GV",
    "HA",
    "HB",
    "HD",
    "HE",
    "HH",
    "HK",
    "HL",
    "HR",
    "HS",
    "HT",
    "HU",
    "K1",
    "K2",
    "K3",
    "K4",
    "K5",
    "K6",
    "K7",
    "LA",
    "LB",
    "LC",
    "LD",
    "LE",
    "LF",
    "LG",
    "LH",
    "LI",
    "LJ",
    "LK",
    "LL",
    "LM",
    "LO",
    "LP",
    "LQ",
    "LR",
    "LS",
    "LT",
    "LU",
    "LV",
    "LW",
    "LX",
    "LY",
    "LZ",
    "MB",
    "MD",
    "MG",
    "MH",
    "MK",
    "MM",
    "MN",
    "MP",
    "MR",
    "MS",
    "MT",
    "MU",
    "MW",
    "MY",
    "MZ",
    "NC",
    "NF",
    "NG",
    "NI",
    "NL",
    "NS",
    "NT",
    "NV",
    "NW",
    "NZ",
    "OA",
    "OB",
    "OE",
    "OI",
    "OJ",
    "OK",
    "OL",
    "OM",
    "OO",
    "OP",
    "OR",
    "OS",
    "OT",
    "OY",
    "PA",
    "PG",
    "PH",
    "PJ",
    "PK",
    "PL",
    "PM",
    "PO",
    "PP",
    "PT",
    "PW",
    "RC",
    "RJ",
    "RK",
    "RO",
    "RP",
    "SA",
    "SB",
    "SC",
    "SD",
    "SE",
    "SG",
    "SI",
    "SJ",
    "SK",
    "SL",
    "SM",
    "SO",
    "SP",
    "SS",
    "SU",
    "SV",
    "SW",
    "SY",
    "TA",
    "TB",
    "TD",
    "TF",
    "TG",
    "TI",
    "TJ",
    "TK",
    "TL",
    "TN",
    "TQ",
    "TT",
    "TU",
    "TV",
    "TX",
    "UA",
    "UB",
    "UC",
    "UD",
    "UE",
    "UG",
    "UH",
    "UI",
    "UK",
    "UL",
    "UM",
    "UN",
    "UO",
    "UR",
    "US",
    "UT",
    "UU",
    "UW",
    "VA",
    "VC",
    "VD",
    "VE",
    "VG",
    "VH",
    "VI",
    "VL",
    "VM",
    "VN",
    "VO",
    "VR",
    "VT",
    "VV",
    "VY",
    "WA",
    "WB",
    "WI",
    "WM",
    "WR",
    "WS",
    "YB",
    "YM",
    "ZB",
    "ZG",
    "ZH",
    "ZK",
    "ZL",
    "ZM",
    "ZP",
    "ZS",
    "ZU",
    "ZW",
    "ZY"
  ]);
  AirportUtils.NUMERAL_REGEX = /\d/;
  var AirspaceType;
  (function(AirspaceType2) {
    AirspaceType2[AirspaceType2["None"] = 0] = "None";
    AirspaceType2[AirspaceType2["Center"] = 1] = "Center";
    AirspaceType2[AirspaceType2["ClassA"] = 2] = "ClassA";
    AirspaceType2[AirspaceType2["ClassB"] = 3] = "ClassB";
    AirspaceType2[AirspaceType2["ClassC"] = 4] = "ClassC";
    AirspaceType2[AirspaceType2["ClassD"] = 5] = "ClassD";
    AirspaceType2[AirspaceType2["ClassE"] = 6] = "ClassE";
    AirspaceType2[AirspaceType2["ClassF"] = 7] = "ClassF";
    AirspaceType2[AirspaceType2["ClassG"] = 8] = "ClassG";
    AirspaceType2[AirspaceType2["Tower"] = 9] = "Tower";
    AirspaceType2[AirspaceType2["Clearance"] = 10] = "Clearance";
    AirspaceType2[AirspaceType2["Ground"] = 11] = "Ground";
    AirspaceType2[AirspaceType2["Departure"] = 12] = "Departure";
    AirspaceType2[AirspaceType2["Approach"] = 13] = "Approach";
    AirspaceType2[AirspaceType2["MOA"] = 14] = "MOA";
    AirspaceType2[AirspaceType2["Restricted"] = 15] = "Restricted";
    AirspaceType2[AirspaceType2["Prohibited"] = 16] = "Prohibited";
    AirspaceType2[AirspaceType2["Warning"] = 17] = "Warning";
    AirspaceType2[AirspaceType2["Alert"] = 18] = "Alert";
    AirspaceType2[AirspaceType2["Danger"] = 19] = "Danger";
    AirspaceType2[AirspaceType2["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType2[AirspaceType2["ModeC"] = 21] = "ModeC";
    AirspaceType2[AirspaceType2["Radar"] = 22] = "Radar";
    AirspaceType2[AirspaceType2["Training"] = 23] = "Training";
    AirspaceType2[AirspaceType2["Max"] = 24] = "Max";
  })(AirspaceType || (AirspaceType = {}));
  var CoherentAirspace = class {
    constructor(def, uid) {
      this.name = "";
      this._segments = [];
      this.type = def.type;
      this.uid = uid;
      const segments = def.segments;
      const len = segments.length;
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        this._segments[i] = new GeoPoint(point.lat, point.long);
      }
    }
    get segments() {
      return this._segments;
    }
    equals(other) {
      if (other instanceof CoherentAirspace) {
        return this.uid === other.uid;
      }
      return this.type === other.type && this.segments.length === other.segments.length && this.segments.every((point, index) => point.equals(other.segments[index]));
    }
  };
  var AirspaceSearcher = class {
    constructor(cacheSize = AirspaceSearcher.DEFAULT_CACHE_SIZE) {
      this.cacheSize = cacheSize;
      this.cache = /* @__PURE__ */ new Map();
      this._isBusy = false;
      this.queue = [];
    }
    isBusy() {
      return this._isBusy;
    }
    search(center) {
      return new Promise((resolve) => {
        if (this._isBusy || this.queue.length > 0) {
          this.enqueueSearch(center, resolve);
        } else {
          this.doSearch(center, resolve);
        }
      });
    }
    enqueueSearch(center, resolve) {
      this.queue.push(this.doSearch.bind(this, center, resolve));
    }
    processQueue() {
      const next = this.queue.shift();
      if (next) {
        next();
      }
    }
    async doSearch(center, resolve) {
      this._isBusy = true;
      try {
        const coherentDefs = await Promise.race([
          this.executeCoherentSearch(center),
          new Promise((timeoutResolve, reject) => setTimeout(() => reject("Airspace search timed out."), AirspaceSearcher.SEARCH_TIMEOUT))
        ]);
        const airspaces = this.processCoherentDefs(coherentDefs);
        resolve(airspaces);
      } catch (e) {
        resolve([]);
      }
      this._isBusy = false;
      this.processQueue();
    }
    async executeCoherentSearch(center) {
      await Coherent.call("SET_LOAD_LATLON", center.lat, center.lon);
      return await Coherent.call("GET_NEAREST_AIRSPACES");
    }
    processCoherentDefs(defs) {
      const result = [];
      const len = defs.length;
      for (let i = 0; i < len; i++) {
        const def = defs[i];
        if (def.type === AirspaceType.None) {
          continue;
        }
        const uid = AirspaceSearcher.generateUID(def);
        let airspace = this.cache.get(uid);
        if (!airspace) {
          airspace = new CoherentAirspace(def, uid);
          this.cacheAirspace(airspace);
        }
        result.push(airspace);
      }
      return result;
    }
    cacheAirspace(airspace) {
      this.cache.set(airspace.uid, airspace);
      if (this.cache.size > this.cacheSize) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    static generateUID(def) {
      const segments = def.segments;
      let uid = `${def.type}[${segments.length}]:`;
      const len = Math.min(segments.length - 1, 10);
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        uid += `(${point.lat},${point.long})`;
      }
      if (len < segments.length - 1) {
        const point = segments[segments.length - 2];
        uid += `(${point.lat},${point.long})`;
      }
      return uid;
    }
  };
  AirspaceSearcher.SEARCH_TIMEOUT = 5e3;
  AirspaceSearcher.DEFAULT_CACHE_SIZE = 1e3;
  var MSFSAPStates;
  (function(MSFSAPStates2) {
    MSFSAPStates2[MSFSAPStates2["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates2[MSFSAPStates2["APOn"] = 2] = "APOn";
    MSFSAPStates2[MSFSAPStates2["FDOn"] = 4] = "FDOn";
    MSFSAPStates2[MSFSAPStates2["FLC"] = 8] = "FLC";
    MSFSAPStates2[MSFSAPStates2["Alt"] = 16] = "Alt";
    MSFSAPStates2[MSFSAPStates2["AltArm"] = 32] = "AltArm";
    MSFSAPStates2[MSFSAPStates2["GS"] = 64] = "GS";
    MSFSAPStates2[MSFSAPStates2["GSArm"] = 128] = "GSArm";
    MSFSAPStates2[MSFSAPStates2["Pitch"] = 256] = "Pitch";
    MSFSAPStates2[MSFSAPStates2["VS"] = 512] = "VS";
    MSFSAPStates2[MSFSAPStates2["Heading"] = 1024] = "Heading";
    MSFSAPStates2[MSFSAPStates2["Nav"] = 2048] = "Nav";
    MSFSAPStates2[MSFSAPStates2["NavArm"] = 4096] = "NavArm";
    MSFSAPStates2[MSFSAPStates2["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates2[MSFSAPStates2["Attitude"] = 16384] = "Attitude";
    MSFSAPStates2[MSFSAPStates2["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates2[MSFSAPStates2["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates2[MSFSAPStates2["ATArm"] = 131072] = "ATArm";
    MSFSAPStates2[MSFSAPStates2["YD"] = 262144] = "YD";
    MSFSAPStates2[MSFSAPStates2["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates2[MSFSAPStates2["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates2[MSFSAPStates2["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates2[MSFSAPStates2["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates2[MSFSAPStates2["Bank"] = 8388608] = "Bank";
    MSFSAPStates2[MSFSAPStates2["FBW"] = 16777216] = "FBW";
    MSFSAPStates2[MSFSAPStates2["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates2[MSFSAPStates2["None"] = -2147483648] = "None";
  })(MSFSAPStates || (MSFSAPStates = {}));
  var airportIcaoRegionPattern = new RegExp(/^A../);
  var FacilityTypeSearchType = {
    [FacilityType.Airport]: FacilitySearchType.Airport,
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    [FacilityType.VOR]: FacilitySearchType.Vor,
    [FacilityType.USR]: FacilitySearchType.User,
    [FacilityType.VIS]: FacilitySearchType.Visual
  };
  var FacilityLoader = class {
    constructor(facilityRepo, onInitialized = () => {
    }) {
      this.facilityRepo = facilityRepo;
      this.onInitialized = onInitialized;
      if (FacilityLoader.facilityListener === void 0) {
        FacilityLoader.facilityListener = RegisterViewListener("JS_LISTENER_FACILITY", () => {
          FacilityLoader.facilityListener.on("SendAirport", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendIntersection", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendVor", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendNdb", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("NearestSearchCompleted", FacilityLoader.onNearestSearchCompleted);
          setTimeout(() => FacilityLoader.init(), 2e3);
        }, true);
      }
      this.awaitInitialization().then(() => this.onInitialized());
    }
    static init() {
      FacilityLoader.isInitialized = true;
      for (const resolve of this.initPromiseResolveQueue) {
        resolve();
      }
      this.initPromiseResolveQueue.length = 0;
    }
    awaitInitialization() {
      if (FacilityLoader.isInitialized) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          FacilityLoader.initPromiseResolveQueue.push(resolve);
        });
      }
    }
    getFacility(type, icao) {
      switch (type) {
        case FacilityType.USR:
        case FacilityType.RWY:
        case FacilityType.VIS:
          return this.getFacilityFromRepo(type, icao);
        default:
          return this.getFacilityFromCoherent(type, icao);
      }
    }
    async getFacilityFromRepo(type, icao) {
      const fac = this.facilityRepo.get(icao);
      if (fac) {
        return fac;
      } else if (type === FacilityType.RWY) {
        try {
          const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
          const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
          if (runway) {
            const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
            this.facilityRepo.add(runwayFac);
            return runwayFac;
          }
        } catch (e) {
        }
      }
      throw `Facility ${icao} could not be found.`;
    }
    async getFacilityFromCoherent(type, icao) {
      const isMismatch = ICAO.getFacilityType(icao) !== type;
      if (type === FacilityType.Airport) {
        icao = icao.replace(airportIcaoRegionPattern, "A  ");
      }
      let queue = FacilityLoader.requestQueue;
      let cache = FacilityLoader.facCache;
      if (isMismatch) {
        queue = FacilityLoader.mismatchRequestQueue;
        cache = FacilityLoader.typeMismatchFacCache;
      }
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const cachedFac = cache.get(icao);
      if (cachedFac !== void 0) {
        return Promise.resolve(cachedFac);
      }
      const currentTime = Date.now();
      let request = queue.get(icao);
      if (request === void 0 || currentTime - request.timeStamp > 1e4) {
        if (request !== void 0) {
          request.reject(`Facility request for ${icao} has timed out.`);
        }
        let resolve = void 0;
        let reject = void 0;
        const promise = new Promise((resolution, rejection) => {
          resolve = resolution;
          reject = rejection;
          Coherent.call(type, icao).then((isValid) => {
            if (!isValid) {
              rejection(`Facility ${icao} could not be found.`);
              queue.delete(icao);
            }
          });
        });
        request = { promise, timeStamp: currentTime, resolve, reject };
        queue.set(icao, request);
      }
      return request.promise;
    }
    async getAirway(airwayName, airwayType, icao) {
      if (FacilityLoader.airwayCache.has(airwayName)) {
        const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
        const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
          w.icao === icao;
        });
        if (match !== void 0 && cachedAirway !== void 0) {
          return cachedAirway;
        }
      }
      const fac = await this.getFacility(FacilityType.Intersection, icao);
      const route = fac.routes.find((r) => r.name === airwayName);
      if (route !== void 0) {
        const airwayBuilder = new AirwayBuilder(fac, route, this);
        const status = await airwayBuilder.startBuild();
        if (status === AirwayStatus.COMPLETE) {
          const waypoints = airwayBuilder.waypoints;
          if (waypoints !== null) {
            const airway = new AirwayObject(airwayName, airwayType);
            airway.waypoints = [...waypoints];
            FacilityLoader.addToAirwayCache(airway);
            return airway;
          }
        }
      }
      throw new Error("Airway could not be found.");
    }
    async startNearestSearchSession(type) {
      switch (type) {
        case FacilitySearchType.User:
        case FacilitySearchType.Visual:
          return this.startRepoNearestSearchSession(type);
        case FacilitySearchType.AllExceptVisual:
          return this.startCoherentNearestSearchSession(FacilitySearchType.All);
        default:
          return this.startCoherentNearestSearchSession(type);
      }
    }
    async startCoherentNearestSearchSession(type) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const sessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", type);
      let session;
      switch (type) {
        case FacilitySearchType.Airport:
          session = new NearestAirportSearchSession(sessionId);
          break;
        case FacilitySearchType.Intersection:
          session = new NearestIntersectionSearchSession(sessionId);
          break;
        case FacilitySearchType.Vor:
          session = new NearestVorSearchSession(sessionId);
          break;
        case FacilitySearchType.Boundary:
          session = new NearestBoundarySearchSession(sessionId);
          break;
        default:
          session = new CoherentNearestSearchSession(sessionId);
          break;
      }
      FacilityLoader.searchSessions.set(sessionId, session);
      return session;
    }
    startRepoNearestSearchSession(type) {
      const sessionId = FacilityLoader.repoSearchSessionId--;
      switch (type) {
        case FacilitySearchType.User:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        case FacilitySearchType.Visual:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        default:
          throw new Error();
      }
    }
    async getMetar(arg) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const ident = typeof arg === "string" ? arg : ICAO.getIdent(arg.icao);
      const metar = await Coherent.call("GET_METAR_BY_IDENT", ident);
      return FacilityLoader.cleanMetar(metar);
    }
    async searchMetar(lat, lon) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const metar = await Coherent.call("GET_METAR_BY_LATLON", lat, lon);
      return FacilityLoader.cleanMetar(metar);
    }
    static cleanMetar(raw) {
      if (raw.icao === "") {
        return void 0;
      }
      raw.gust < 0 && delete raw.gust;
      raw.vertVis < 0 && delete raw.vertVis;
      isNaN(raw.altimeterA) && delete raw.altimeterA;
      raw.altimeterQ < 0 && delete raw.altimeterQ;
      isNaN(raw.slp) && delete raw.slp;
      return raw;
    }
    async searchByIdent(filter, ident, maxItems = 40) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      let results;
      if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
        const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
        results = await Coherent.call("SEARCH_BY_IDENT", ident, coherentFilter, maxItems);
      } else {
        results = [];
      }
      const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
      if (facRepositorySearchTypes) {
        this.facilityRepo.forEach((fac) => {
          const facIdent = ICAO.getIdent(fac.icao);
          if (facIdent === ident) {
            results.unshift(fac.icao);
          } else if (facIdent.startsWith(ident)) {
            results.push(fac.icao);
          }
        }, facRepositorySearchTypes);
      }
      return results;
    }
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
      const results = await this.searchByIdent(filter, ident, maxItems);
      if (!results) {
        return [];
      }
      const promises = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i];
        const facIdent = ICAO.getIdent(icao);
        if (facIdent === ident) {
          const facType = ICAO.getFacilityType(icao);
          promises.push(this.getFacility(facType, icao));
        }
      }
      const foundFacilities = await Promise.all(promises);
      if (foundFacilities.length > 1) {
        foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
        return foundFacilities;
      } else if (foundFacilities.length === 1) {
        return foundFacilities;
      } else {
        return [];
      }
    }
    static onFacilityReceived(facility) {
      const isMismatch = facility["__Type"] === "JS_FacilityIntersection" && facility.icao[0] !== "W";
      const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
      const request = queue.get(facility.icao);
      if (request !== void 0) {
        request.resolve(facility);
        FacilityLoader.addToFacilityCache(facility, isMismatch);
        queue.delete(facility.icao);
      }
    }
    static onNearestSearchCompleted(results) {
      const session = FacilityLoader.searchSessions.get(results.sessionId);
      if (session instanceof CoherentNearestSearchSession) {
        session.onSearchCompleted(results);
      }
    }
    static addToFacilityCache(fac, isTypeMismatch) {
      const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
      cache.set(fac.icao, fac);
      if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
        cache.delete(cache.keys().next().value);
      }
    }
    static addToAirwayCache(airway) {
      FacilityLoader.airwayCache.set(airway.name, airway);
      if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
        FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
      }
    }
  };
  FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1e3;
  FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1e3;
  FacilityLoader.requestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.mismatchRequestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.facCache = /* @__PURE__ */ new Map();
  FacilityLoader.typeMismatchFacCache = /* @__PURE__ */ new Map();
  FacilityLoader.airwayCache = /* @__PURE__ */ new Map();
  FacilityLoader.searchSessions = /* @__PURE__ */ new Map();
  FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
  };
  FacilityLoader.repoSearchSessionId = -1;
  FacilityLoader.isInitialized = false;
  FacilityLoader.initPromiseResolveQueue = [];
  var CoherentNearestSearchSession = class {
    constructor(sessionId) {
      this.sessionId = sessionId;
      this.searchQueue = /* @__PURE__ */ new Map();
    }
    searchNearest(lat, lon, radius, maxItems) {
      const promise = new Promise((resolve) => {
        Coherent.call("SEARCH_NEAREST", this.sessionId, lat, lon, radius, maxItems).then((searchId) => {
          this.searchQueue.set(searchId, { promise, resolve });
        });
      });
      return promise;
    }
    onSearchCompleted(results) {
      const request = this.searchQueue.get(results.searchId);
      if (request !== void 0) {
        request.resolve(results);
        this.searchQueue.delete(results.searchId);
      }
    }
  };
  var NearestAirportSearchSession = class extends CoherentNearestSearchSession {
    setAirportFilter(showClosed, classMask) {
      Coherent.call("SET_NEAREST_AIRPORT_FILTER", this.sessionId, showClosed ? 1 : 0, classMask);
    }
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      Coherent.call("SET_NEAREST_EXTENDED_AIRPORT_FILTERS", this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
  };
  NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
  };
  var NearestIntersectionSearchSession = class extends CoherentNearestSearchSession {
    setIntersectionFilter(typeMask) {
      Coherent.call("SET_NEAREST_INTERSECTION_FILTER", this.sessionId, typeMask);
    }
  };
  NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
  };
  var NearestVorSearchSession = class extends CoherentNearestSearchSession {
    setVorFilter(classMask, typeMask) {
      Coherent.call("SET_NEAREST_VOR_FILTER", this.sessionId, classMask, typeMask);
    }
  };
  NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
  };
  var NearestBoundarySearchSession = class extends CoherentNearestSearchSession {
    setBoundaryFilter(classMask) {
      Coherent.call("SET_NEAREST_BOUNDARY_FILTER", this.sessionId, classMask);
    }
  };
  var NearestRepoFacilitySearchSession = class {
    constructor(repo, sessionId) {
      this.repo = repo;
      this.sessionId = sessionId;
      this.filter = void 0;
      this.cachedResults = /* @__PURE__ */ new Set();
      this.searchId = 0;
    }
    searchNearest(lat, lon, radius, maxItems) {
      const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
      const added = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i].icao;
        if (this.cachedResults.has(icao)) {
          this.cachedResults.delete(icao);
        } else {
          added.push(icao);
        }
      }
      const removed = Array.from(this.cachedResults);
      this.cachedResults.clear();
      for (let i = 0; i < results.length; i++) {
        this.cachedResults.add(results[i].icao);
      }
      return Promise.resolve({
        sessionId: this.sessionId,
        searchId: this.searchId++,
        added,
        removed
      });
    }
    setUserFacilityFilter(filter) {
      this.filter = filter;
    }
  };
  var AirwayObject = class {
    constructor(name, type) {
      this._waypoints = [];
      this._name = name;
      this._type = type;
    }
    get name() {
      return this._name;
    }
    get type() {
      return this._type;
    }
    get waypoints() {
      return this._waypoints;
    }
    set waypoints(waypoints) {
      this._waypoints = waypoints;
    }
  };
  var AirwayStatus;
  (function(AirwayStatus2) {
    AirwayStatus2[AirwayStatus2["INCOMPLETE"] = 0] = "INCOMPLETE";
    AirwayStatus2[AirwayStatus2["COMPLETE"] = 1] = "COMPLETE";
    AirwayStatus2[AirwayStatus2["PARTIAL"] = 2] = "PARTIAL";
  })(AirwayStatus || (AirwayStatus = {}));
  var AirwayBuilder = class {
    constructor(_initialWaypoint, _initialData, facilityLoader) {
      this._initialWaypoint = _initialWaypoint;
      this._initialData = _initialData;
      this.facilityLoader = facilityLoader;
      this._waypointsArray = [];
      this._hasStarted = false;
      this._isDone = false;
    }
    get hasStarted() {
      return this._hasStarted;
    }
    get isDone() {
      return this._isDone;
    }
    get waypoints() {
      return this._waypointsArray;
    }
    async _step(stepForward, arrayInsertFunc) {
      let isDone = false;
      let current = this._initialData;
      while (!isDone && current) {
        const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
        if (nextICAO && nextICAO.length > 0 && nextICAO[0] != " " && this._waypointsArray !== null && !this._waypointsArray.find((waypoint) => waypoint.icao === nextICAO)) {
          const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
          arrayInsertFunc(fac);
          const next = fac.routes.find((route) => route.name === current.name);
          if (next !== void 0) {
            current = next;
          } else {
            isDone = true;
          }
        } else {
          isDone = true;
        }
      }
    }
    async _stepForward() {
      if (this._waypointsArray !== null) {
        return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
      }
    }
    async _stepBackward() {
      if (this._waypointsArray !== null) {
        return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
      }
    }
    setWaypointsArray(array) {
      this._waypointsArray = array;
    }
    startBuild() {
      if (this.hasStarted) {
        return Promise.reject(new Error("Airway builder has already started building."));
      }
      return new Promise((resolve) => {
        this._hasStarted = true;
        if (this._waypointsArray !== null) {
          this._waypointsArray.push(this._initialWaypoint);
          Promise.all([
            this._stepForward(),
            this._stepBackward()
          ]).then(() => {
            this._isDone = true;
            resolve(AirwayStatus.COMPLETE);
          }).catch(() => {
            this._isDone = true;
            resolve(AirwayStatus.PARTIAL);
          });
        }
      });
    }
  };
  var ArrayUtils = class {
    static create(length, init) {
      const newArray = [];
      for (let i = 0; i < length; i++) {
        newArray[i] = init(i);
      }
      return newArray;
    }
    static at(array, index) {
      if (index < 0) {
        index += array.length;
      }
      if (index < 0 || index >= array.length) {
        throw new RangeError();
      }
      return array[index];
    }
    static peekAt(array, index) {
      if (index < 0) {
        index += array.length;
      }
      return array[index];
    }
    static first(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[0];
    }
    static peekFirst(array) {
      return array[0];
    }
    static last(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[array.length - 1];
    }
    static peekLast(array) {
      return array[array.length - 1];
    }
    static includes(array, searchElement, fromIndex) {
      return array.includes(searchElement, fromIndex);
    }
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalsFunc(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    static flatMap(array, map) {
      const out = [];
      for (let i = 0; i < array.length; i++) {
        const mapped = map(array[i], i, array);
        if (Array.isArray(mapped)) {
          for (let j = 0; j < mapped.length; j++) {
            out[out.length] = mapped[j];
          }
        } else {
          out[out.length] = mapped;
        }
      }
      return out;
    }
    static flat(array, depth = 1) {
      const out = [];
      this.flatHelper(array, depth, 0, out);
      return out;
    }
    static flatHelper(array, maxDepth, depth, out) {
      for (let i = 0; i < array.length; i++) {
        const element = array[i];
        if (Array.isArray(element) && depth < maxDepth) {
          this.flatHelper(element, maxDepth, depth + 1, out);
        } else {
          out[out.length] = element;
        }
      }
    }
    static shallowCopy(source, target = []) {
      target.length = source.length;
      for (let i = 0; i < source.length; i++) {
        target[i] = source[i];
      }
      return target;
    }
    static binarySearch(array, element, comparator, first = true) {
      let min = 0;
      let max = array.length;
      let index = Math.floor((min + max) / 2);
      while (min < max) {
        const compare = comparator(element, array[index]);
        if (compare < 0) {
          max = index;
        } else if (compare > 0) {
          min = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min + max) / 2);
      }
      return -(index + 1);
    }
    static getMaxStringLength(array) {
      return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
  };
  ArrayUtils.STRICT_EQUALS = (a, b) => a === b;
  var BinaryHeap = class {
    constructor(comparator) {
      this.comparator = comparator;
      this.tree = [];
    }
    get size() {
      return this.tree.length;
    }
    findMin() {
      return this.tree[0];
    }
    removeMin() {
      if (this.tree.length === 0) {
        return void 0;
      }
      const min = this.tree[0];
      this.swap(0, this.tree.length - 1);
      this.tree.length--;
      this.heapifyDown(0);
      return min;
    }
    insert(element) {
      this.tree.push(element);
      this.heapifyUp(this.tree.length - 1);
      return this;
    }
    insertAndRemoveMin(element) {
      if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
        return element;
      }
      return this.removeMinAndInsert(element);
    }
    removeMinAndInsert(element) {
      const min = this.tree[0];
      this.tree[0] = element;
      this.heapifyDown(0);
      return min;
    }
    clear() {
      this.tree.length = 0;
      return this;
    }
    heapifyUp(index) {
      let parent = BinaryHeap.parent(index);
      while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
        this.swap(parent, index);
        index = parent;
        parent = BinaryHeap.parent(index);
      }
    }
    heapifyDown(index) {
      const len = this.tree.length;
      while (index < len) {
        const left = BinaryHeap.left(index);
        const right = BinaryHeap.right(index);
        let needSwapFlags = 0;
        if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
          needSwapFlags |= 1;
        }
        if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
          needSwapFlags |= 2;
        }
        if (needSwapFlags === 3) {
          needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
        }
        if (needSwapFlags === 0) {
          break;
        }
        const swapChild = needSwapFlags === 1 ? left : right;
        this.swap(index, swapChild);
        index = swapChild;
      }
    }
    swap(index1, index2) {
      const old1 = this.tree[index1];
      this.tree[index1] = this.tree[index2];
      this.tree[index2] = old1;
    }
    static parent(index) {
      return index - 1 >> 1;
    }
    static left(index) {
      return index * 2 + 1;
    }
    static right(index) {
      return index * 2 + 2;
    }
  };
  var SortedArray = class {
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
      this.comparatorFunc = comparatorFunc;
      this.equalityFunc = equalityFunc;
      this._array = [];
    }
    get array() {
      return this._array;
    }
    get length() {
      return this._array.length;
    }
    findIndex(element, first = true) {
      let min = 0;
      let max = this._array.length;
      let index = Math.floor((min + max) / 2);
      while (min < max) {
        const compare = this.comparatorFunc(element, this._array[index]);
        if (compare < 0) {
          max = index;
        } else if (compare > 0) {
          min = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min + max) / 2);
      }
      return -(index + 1);
    }
    searchEquals(element, startIndex) {
      let index = startIndex;
      while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
        if (this.equalityFunc(element, this._array[index])) {
          return index;
        }
        index++;
      }
      return -1;
    }
    get(index) {
      if (index < 0 || index >= this._array.length) {
        throw new RangeError();
      }
      return this._array[index];
    }
    peek(index) {
      return this._array[index];
    }
    first() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[0];
    }
    peekFirst() {
      return this._array[0];
    }
    last() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[this._array.length - 1];
    }
    peekLast() {
      return this._array[this._array.length - 1];
    }
    has(element) {
      return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    insert(element) {
      let index = this.findIndex(element, false);
      if (index < 0) {
        index = -index - 1;
      }
      this._array.splice(index, 0, element);
      return index;
    }
    insertAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let toInsertIndex = 0;
      let toInsert = sorted[toInsertIndex];
      const len = this._array.length;
      const insertLen = sorted.length;
      for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
        if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
          this._array.splice(i, 0, toInsert);
          toInsert = sorted[++toInsertIndex];
        }
      }
      for (; toInsertIndex < insertLen; toInsertIndex++) {
        this._array.push(sorted[toInsertIndex]);
      }
      return sorted.length;
    }
    remove(element) {
      const index = this.searchEquals(element, this.findIndex(element));
      if (index >= 0) {
        this._array.splice(index, 1);
      }
      return index;
    }
    removeAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let numRemoved = 0;
      let toRemoveIndex = 0;
      let toRemove = sorted[toRemoveIndex];
      const len = this._array.length;
      const removeLen = sorted.length;
      for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
        if (this.equalityFunc(toRemove, this._array[i])) {
          this._array.splice(i--, 1);
          toRemove = sorted[++toRemoveIndex];
          numRemoved++;
        }
      }
      return numRemoved;
    }
    removeAt(index) {
      if (index < 0 || index >= this._array.length) {
        return void 0;
      }
      return this._array.splice(index, 1)[0];
    }
    pop() {
      return this._array.pop();
    }
    shift() {
      return this._array.shift();
    }
    resort() {
      this._array.sort(this.comparatorFunc);
    }
    indexOf(element) {
      return this.searchEquals(element, this.findIndex(element));
    }
    match(query) {
      const index = this.matchIndex(query);
      return this._array[index];
    }
    matchIndex(query) {
      return this.findIndex(query);
    }
    clear() {
      this._array.length = 0;
    }
    values() {
      return this._array.values();
    }
    [Symbol.iterator]() {
      return this._array.values();
    }
  };
  SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var LerpLookupTable = class {
    constructor(arg) {
      this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg === "number") {
        this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
        return;
      }
      const leastDimension = arg.reduce((accum, current) => current.length < accum.length ? current : accum);
      this._dimensionCount = Math.max(0, leastDimension ? leastDimension.length - 1 : 0);
      if (this._dimensionCount === 0) {
        return;
      }
      for (let i = 0; i < arg.length; i++) {
        this.insertBreakpoint(arg[i]);
      }
    }
    get dimensionCount() {
      return this._dimensionCount;
    }
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    get(...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table);
      if (value === void 0) {
        throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    lookupHelper(key, dimension, lookupArray) {
      const dimensionKey = key[dimension];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array);
        endValue = this.lookupHelper(key, dimension + 1, end.array);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      if (startValue === endValue) {
        return startValue;
      }
      return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpLookupTable.tempBreakpoint = { key: 0 };
  var LerpVectorLookupTable = class {
    constructor(arg1, arg2) {
      var _a, _b;
      this.table = new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg1 === "number") {
        this._dimensionCount = isFinite(arg1) ? 0 : Math.max(0, arg1);
        this._vectorLength = isFinite(arg2) ? 0 : Math.max(0, arg2);
      } else {
        let leastBreakpointDimension = Infinity;
        let leastVectorLength = Infinity;
        for (let i = 0; i < arg1.length; i++) {
          leastBreakpointDimension = Math.min(leastBreakpointDimension, Math.max(arg1[i].length - 1, 0));
          leastVectorLength = Math.min(leastVectorLength, (_b = (_a = arg1[i][0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        }
        this._dimensionCount = isFinite(leastBreakpointDimension) ? leastBreakpointDimension : 0;
        this._vectorLength = isFinite(leastVectorLength) ? leastVectorLength : 0;
        if (this._dimensionCount > 0) {
          for (let i = 0; i < arg1.length; i++) {
            this.insertBreakpoint(arg1[i]);
          }
        }
      }
      this.tempVectors = ArrayUtils.create(this._dimensionCount * 2, () => new Float64Array(this._vectorLength));
    }
    get dimensionCount() {
      return this._dimensionCount;
    }
    get vectorLength() {
      return this._vectorLength;
    }
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      if (breakpoint[0].length < this._vectorLength) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint[0].length}-length vector into a table with vectors of length ${this._vectorLength}`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    get(out, ...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table, out);
      if (value === void 0) {
        throw new Error(`LerpVectorLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    lookupHelper(key, dimension, lookupArray, out) {
      const dimensionKey = key[dimension];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array, this.tempVectors[dimension * 2]);
        endValue = this.lookupHelper(key, dimension + 1, end.array, this.tempVectors[dimension * 2 + 1]);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      return MathUtils.lerpVector(out, dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpVectorLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpVectorLookupTable.tempBreakpoint = { key: 0 };
  var KdTree = class {
    constructor(dimensionCount, keyFunc) {
      this.keyFunc = keyFunc;
      this.elements = [];
      this.keys = [];
      this.nodes = [];
      this.minDepth = -1;
      this.maxDepth = -1;
      this.dimensionCount = Math.trunc(dimensionCount);
      if (this.dimensionCount < 2) {
        throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
      }
      this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
      this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
        return (a, b) => {
          const aKey = this.keys[a];
          const bKey = this.keys[b];
          for (let i = 0; i < this.dimensionCount; i++) {
            const dimension = (i + index) % this.dimensionCount;
            if (aKey[dimension] < bKey[dimension]) {
              return -1;
            } else if (aKey[dimension] > bKey[dimension]) {
              return 1;
            }
          }
          return 0;
        };
      });
      this.keyCache = [
        new Float64Array(this.dimensionCount)
      ];
    }
    get size() {
      return this.elements.length;
    }
    searchKey(key, radius, arg3, out, filter) {
      if (typeof arg3 === "number") {
        return this.doResultsSearch(void 0, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(void 0, key, radius, arg3);
      }
    }
    search(element, radius, arg3, out, filter) {
      const key = this.keyFunc(element, this.keyCache[0]);
      if (typeof arg3 === "number") {
        return this.doResultsSearch(element, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(element, key, radius, arg3);
      }
    }
    doVisitorSearch(element, key, radius, visitor) {
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        return visitor(elementInner, keyInner, distance, queryKey, queryElement);
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        return searchRadius + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
      if (maxResultCount <= 0) {
        out.length = 0;
        return out;
      }
      const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
          if (heap.size === maxResultCount) {
            heap.insertAndRemoveMin(elementIndex);
          } else {
            heap.insert(elementIndex);
          }
        }
        return true;
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        let maxDist = searchRadius;
        if (heap.size === maxResultCount) {
          maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
        }
        return maxDist + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
      out.length = heap.size;
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = this.elements[heap.removeMin()];
      }
      return out;
    }
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
      const elementIndex = this.nodes[nodeIndex];
      if (elementIndex === void 0) {
        return true;
      }
      const nodeKey = this.keys[elementIndex];
      const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
      if (distanceFromNode <= radius) {
        if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
          return false;
        }
      }
      const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      const lesserNodeIndex = KdTree.lesser(nodeIndex);
      const greaterNodeIndex = KdTree.greater(nodeIndex);
      if (this.nodes[lesserNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, -1)) {
        if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      if (this.nodes[greaterNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, 1)) {
        if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      return true;
    }
    insert(element) {
      const insertDepth = this.insertElementInTree(element) + 1;
      this.maxDepth = Math.max(this.maxDepth, insertDepth);
      if (insertDepth === this.minDepth + 1) {
        this.minDepth = KdTree.depth(this.nodes.indexOf(void 0, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
      }
      if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
        this.rebuild();
      }
    }
    insertAll(elements) {
      for (const element of elements) {
        this.elements.push(element);
        this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
        const insertedIndex = this.elements.length - 1;
        for (let i = 0; i < this.dimensionCount; i++) {
          this.indexArrays[i].push(insertedIndex);
        }
      }
      this.rebuild();
    }
    insertElementInTree(element) {
      const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
      let index = 0;
      let depth = 0;
      let elementIndex;
      while ((elementIndex = this.nodes[index]) !== void 0) {
        const pivotDimension = depth % this.dimensionCount;
        const keyToCompare = key[pivotDimension];
        if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
          index = KdTree.lesser(index);
        } else {
          index = KdTree.greater(index);
        }
        depth++;
      }
      this.elements.push(element);
      this.keys.push(key);
      const insertedIndex = this.elements.length - 1;
      this.nodes[index] = insertedIndex;
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].push(insertedIndex);
      }
      return depth;
    }
    remove(element) {
      if (!this.removeElementFromArrays(element)) {
        return false;
      }
      this.resetIndexArrays();
      this.rebuild();
      return true;
    }
    removeAll(elements) {
      let removed = false;
      for (const element of elements) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
        this.rebuild();
      }
      return removed;
    }
    removeElementFromArrays(element) {
      const index = this.elements.indexOf(element);
      if (index < 0) {
        return false;
      }
      const lastIndex = this.elements.length - 1;
      this.elements[index] = this.elements[lastIndex];
      this.keys[index] = this.keys[lastIndex];
      this.elements.length--;
      this.keys.length--;
      return true;
    }
    resetIndexArrays() {
      for (let i = 0; i < this.dimensionCount; i++) {
        const array = this.indexArrays[i];
        array.length = this.elements.length;
        for (let j = 0; j < array.length; j++) {
          array[j] = j;
        }
      }
    }
    removeAndInsert(toRemove, toInsert) {
      let removed = false;
      for (const element of toRemove) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
      }
      this.insertAll(toInsert);
    }
    rebuild() {
      this.nodes.length = 0;
      if (this.size === 0) {
        return;
      }
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].sort(this.indexSortFuncs[i]);
      }
      this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
      const log = Math.log2(this.elements.length + 1);
      this.minDepth = Math.floor(log) - 1;
      this.maxDepth = Math.ceil(log) - 1;
    }
    buildSubTree(nodeIndex, pivotDimension, start, end) {
      const tempArray = this.indexArrays[this.dimensionCount];
      const sortedArray = this.indexArrays[0];
      const medianIndex = Math.trunc((start + end) / 2);
      const medianKeyIndex = sortedArray[medianIndex];
      this.nodes[nodeIndex] = medianKeyIndex;
      if (end - start === 1) {
        return;
      }
      if (end - start <= 3) {
        const lesserIndex = medianIndex - 1;
        const greaterIndex = medianIndex + 1;
        if (lesserIndex >= start) {
          this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
        }
        if (greaterIndex < end) {
          this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
        }
        return;
      }
      for (let i = start; i < end; i++) {
        tempArray[i] = sortedArray[i];
      }
      for (let i = 1; i < this.dimensionCount; i++) {
        const targetArray = this.indexArrays[i - 1];
        const toPartitionArray = this.indexArrays[i];
        let lesserCount = 0;
        let greaterCount = 0;
        for (let j = start; j < end; j++) {
          const keyIndex = toPartitionArray[j];
          if (keyIndex === medianKeyIndex) {
            targetArray[medianIndex] = keyIndex;
          } else {
            const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
            if (comparison <= 0) {
              const index = start + lesserCount++;
              targetArray[index] = keyIndex;
            } else {
              const index = medianIndex + 1 + greaterCount++;
              targetArray[index] = keyIndex;
            }
          }
        }
      }
      const newSortedArray = this.indexArrays[this.dimensionCount - 1];
      for (let i = start; i < end; i++) {
        newSortedArray[i] = tempArray[i];
      }
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
      this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    clear() {
      this.elements.length = 0;
      this.keys.length = 0;
      this.nodes.length = 0;
      for (let i = 0; i < this.indexArrays.length; i++) {
        this.indexArrays[i].length = 0;
      }
      this.minDepth = -1;
      this.maxDepth = -1;
    }
    static parent(index) {
      return index - 1 >> 1;
    }
    static lesser(index) {
      return index * 2 + 1;
    }
    static greater(index) {
      return index * 2 + 2;
    }
    static leastIndexAtDepth(depth) {
      return 1 << depth - 1;
    }
    static depth(index) {
      return Math.trunc(Math.log2(index + 1));
    }
    static distance(key1, key2, dimensionCount) {
      let sumSq = 0;
      for (let i = 0; i < dimensionCount; i++) {
        const diff = key1[i] - key2[i];
        sumSq += diff * diff;
      }
      return Math.sqrt(sumSq);
    }
  };
  var GeoKdTree = class {
    constructor(keyFunc) {
      this.keyFunc = keyFunc;
      this.cartesianTree = new KdTree(3, (element, out) => {
        const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
        out[0] = vec[0];
        out[1] = vec[1];
        out[2] = vec[2];
        return out;
      });
    }
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
      let center, radius;
      let argA, argB, argC;
      if (typeof arg1 === "number") {
        center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
        radius = arg3;
        argA = arg4;
        argB = arg5;
        argC = arg6;
      } else if (!(arg1 instanceof Float64Array)) {
        center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      } else {
        center = arg1;
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      }
      const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
      if (typeof argA === "number") {
        return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
      } else {
        this.doVisitorSearch(center, radiusCartesian, argA);
      }
    }
    doVisitorSearch(center, radiusCartesian, visitor) {
      this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return visitor(element, vec, greatCircleDist, center);
      });
    }
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
      const cartesianFilter = filter ? (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return filter(element, vec, greatCircleDist, center);
      } : void 0;
      return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    insert(element) {
      this.cartesianTree.insert(element);
    }
    insertAll(elements) {
      this.cartesianTree.insertAll(elements);
    }
    remove(element) {
      return this.cartesianTree.remove(element);
    }
    removeAll(elements) {
      return this.cartesianTree.removeAll(elements);
    }
    removeAndInsert(toRemove, toInsert) {
      this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    rebuild() {
      this.cartesianTree.rebuild();
    }
    clear() {
      this.cartesianTree.clear();
    }
  };
  GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  var SubscribableArrayEventType;
  (function(SubscribableArrayEventType2) {
    SubscribableArrayEventType2["Added"] = "Added";
    SubscribableArrayEventType2["Removed"] = "Removed";
    SubscribableArrayEventType2["Cleared"] = "Cleared";
  })(SubscribableArrayEventType || (SubscribableArrayEventType = {}));
  var AbstractSubscribableArray = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    get(index) {
      const array = this.getArray();
      if (index > array.length - 1) {
        throw new Error("Index out of range");
      }
      return array[index];
    }
    tryGet(index) {
      return this.getArray()[index];
    }
    notify(index, type, modifiedItem) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(index, type, modifiedItem, this.getArray());
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ArraySubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    initialNotify(sub) {
      const array = this.getArray();
      sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
  };
  var FacilityRepositorySyncType;
  (function(FacilityRepositorySyncType2) {
    FacilityRepositorySyncType2["Add"] = "Add";
    FacilityRepositorySyncType2["Remove"] = "Remove";
    FacilityRepositorySyncType2["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType2["DumpResponse"] = "DumpResponse";
  })(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
  var FacilityRepository = class {
    constructor(bus) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.repos = /* @__PURE__ */ new Map();
      this.trees = {
        [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc)
      };
      this.ignoreSync = false;
      bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
      this.pubSyncEvent({
        type: FacilityRepositorySyncType.DumpRequest,
        uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
      });
    }
    size(types) {
      var _a, _b;
      let size = 0;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          size += repo.size;
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        }
      }
      return size;
    }
    get(icao) {
      var _a;
      if (!ICAO.isFacility(icao)) {
        return void 0;
      }
      return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    search(type, lat, lon, radius, arg5, out, filter) {
      if (type !== FacilityType.USR && type !== FacilityType.VIS) {
        throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
      }
      if (typeof arg5 === "number") {
        return this.trees[type].search(lat, lon, radius, arg5, out, filter);
      } else {
        this.trees[type].search(lat, lon, radius, arg5);
      }
    }
    add(fac) {
      if (!ICAO.isFacility(fac.icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
      }
      this.addToRepo(fac);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    addMultiple(facs) {
      this.addMultipleToRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    remove(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      if (!ICAO.isFacility(icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
      }
      this.removeFromRepo(icao);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    removeMultiple(facs) {
      this.removeMultipleFromRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map((fac) => typeof fac === "object" ? fac.icao : fac) });
    }
    forEach(fn, types) {
      var _a;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          repo.forEach(fn);
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
      }
    }
    addToRepo(fac) {
      const facilityType = ICAO.getFacilityType(fac.icao);
      let repo = this.repos.get(facilityType);
      if (repo === void 0) {
        this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
      }
      const existing = repo.get(fac.icao);
      repo.set(fac.icao, fac);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        if (existing === void 0) {
          this.trees[facilityType].insert(fac);
        } else {
          this.trees[facilityType].removeAndInsert([existing], [fac]);
        }
      }
      if (existing === void 0) {
        this.publisher.pub("facility_added", fac, false, false);
      } else {
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    addMultipleToRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const addedFacilities = [];
      const changedFacilitiesRemoved = [];
      const changedFacilitiesAdded = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === void 0) {
          this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (existing === void 0) {
          addedFacilities.push(fac);
        } else {
          changedFacilitiesRemoved.push(existing);
          changedFacilitiesAdded.push(fac);
        }
      }
      const addedUserFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (addedUserFacilities.length > 0) {
        const removedUserFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
      }
      const addedVisFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (addedVisFacilities.length > 0) {
        const removedVisFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
      }
      for (let i = 0; i < addedFacilities.length; i++) {
        const fac = addedFacilities[i];
        this.publisher.pub("facility_added", fac, false, false);
      }
      for (let i = 0; i < changedFacilitiesAdded.length; i++) {
        const fac = changedFacilitiesAdded[i];
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    removeFromRepo(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      const facilityType = ICAO.getFacilityType(icao);
      const repo = this.repos.get(ICAO.getFacilityType(icao));
      if (repo === void 0) {
        return;
      }
      const facilityInRepo = repo.get(icao);
      if (facilityInRepo === void 0) {
        return;
      }
      repo.delete(icao);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        this.trees[facilityType].remove(facilityInRepo);
      }
      this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
      this.publisher.pub("facility_removed", facilityInRepo, false, false);
    }
    removeMultipleFromRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const removedFacilities = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const icao = typeof fac === "string" ? fac : fac.icao;
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === void 0) {
          continue;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === void 0) {
          continue;
        }
        repo.delete(icao);
        removedFacilities.push(facilityInRepo);
      }
      const removedUserFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (removedUserFacilities.length > 0) {
        this.trees[FacilityType.USR].removeAll(removedUserFacilities);
      }
      const removedVisFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (removedVisFacilities.length > 0) {
        this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
      }
      for (let i = 0; i < removedFacilities.length; i++) {
        const removedFac = removedFacilities[i];
        this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
        this.publisher.pub("facility_removed", removedFac, false, false);
      }
    }
    pubSyncEvent(data) {
      this.ignoreSync = true;
      this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
      this.ignoreSync = false;
    }
    onSyncEvent(data) {
      if (this.ignoreSync) {
        return;
      }
      switch (data.type) {
        case FacilityRepositorySyncType.DumpResponse:
          if (data.uid !== this.lastDumpRequestUid) {
            break;
          } else {
            this.lastDumpRequestUid = void 0;
          }
        case FacilityRepositorySyncType.Add:
          if (data.facs.length === 1) {
            this.addToRepo(data.facs[0]);
          } else {
            this.addMultipleToRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.Remove:
          if (data.facs.length === 1) {
            this.removeFromRepo(data.facs[0]);
          } else {
            this.removeMultipleFromRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.DumpRequest:
          if (data.uid !== this.lastDumpRequestUid) {
            const facs = [];
            this.forEach((fac) => facs.push(fac));
            this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
          }
          break;
      }
    }
    static getRepository(bus) {
      var _a;
      return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : FacilityRepository.INSTANCE = new FacilityRepository(bus);
    }
  };
  FacilityRepository.SYNC_TOPIC = "facilityrepo_sync";
  FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
  };
  var HoldEntryType;
  (function(HoldEntryType2) {
    HoldEntryType2[HoldEntryType2["Direct"] = 0] = "Direct";
    HoldEntryType2[HoldEntryType2["Teardrop"] = 1] = "Teardrop";
    HoldEntryType2[HoldEntryType2["Parallel"] = 2] = "Parallel";
    HoldEntryType2[HoldEntryType2["None"] = 3] = "None";
  })(HoldEntryType || (HoldEntryType = {}));
  var HoldMaxSpeedRule;
  (function(HoldMaxSpeedRule2) {
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Faa"] = 0] = "Faa";
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Icao"] = 1] = "Icao";
  })(HoldMaxSpeedRule || (HoldMaxSpeedRule = {}));
  var SubscribableUtils = class {
    static isSubscribable(query) {
      return typeof query === "object" && query !== null && query.isSubscribable === true;
    }
    static isMutableSubscribable(query) {
      return typeof query === "object" && query !== null && query.isMutableSubscribable === true;
    }
    static toSubscribable(value, excludeSubscribables) {
      if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
        return value;
      } else {
        return Subject.create(value);
      }
    }
  };
  SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || isNaN(a) && isNaN(b);
  var facilitySearchTypeMap = /* @__PURE__ */ new Map([
    [FacilitySearchType.Airport, FacilityType.Airport],
    [FacilitySearchType.Intersection, FacilityType.Intersection],
    [FacilitySearchType.Vor, FacilityType.VOR],
    [FacilitySearchType.Ndb, FacilityType.NDB],
    [FacilitySearchType.User, FacilityType.USR]
  ]);
  var AbstractNearestSubscription = class extends AbstractSubscribableArray {
    constructor(facilityLoader, type) {
      super();
      this.facilityLoader = facilityLoader;
      this.type = type;
      this.facilities = [];
      this.facilityIndex = /* @__PURE__ */ new Map();
      this.startPromiseResolves = [];
      this.updatePromiseResolves = [];
      this.hasRequestedSession = false;
      this.searchInProgress = false;
    }
    get length() {
      return this.facilities.length;
    }
    get started() {
      return this.session !== void 0;
    }
    getArray() {
      return this.facilities;
    }
    awaitStart() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        this.startPromiseResolves.push(resolve);
      });
    }
    start() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      if (this.hasRequestedSession) {
        return this.awaitStart();
      }
      return new Promise((resolve) => {
        this.hasRequestedSession = true;
        this.startPromiseResolves.push(resolve);
        this.facilityLoader.startNearestSearchSession(this.type).then((session) => {
          this.session = session;
          this.startPromiseResolves.forEach((queuedResolve) => {
            queuedResolve();
          });
          this.startPromiseResolves.length = 0;
        });
      });
    }
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      if (!this.started) {
        await this.start();
      }
      const results = await this.session.searchNearest(lat, lon, radius, maxItems);
      await this.onResults(results);
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    addFacility(facility, key) {
      if (this.facilityIndex.has(key)) {
        console.warn(`Facility ${key} is already in the collection.`);
      }
      this.facilities.push(facility);
      this.facilityIndex.set(key, facility);
      this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, facility);
    }
    removeFacility(key) {
      const facility = this.facilityIndex.get(key);
      if (facility !== void 0) {
        const index = this.facilities.indexOf(facility);
        this.facilities.splice(index, 1);
        this.facilityIndex.delete(key);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Removed, facility);
      }
    }
  };
  var NearestWaypointSubscription = class extends AbstractNearestSubscription {
    constructor(facilityLoader, type, filterCb) {
      super(facilityLoader, type);
      this.facilityCache = /* @__PURE__ */ new Map();
      this.filterCb = filterCb;
    }
    setFilterCb(filter) {
      this.filterCb = filter;
      this.refilter();
    }
    refilter() {
      if (this.filterCb) {
        for (const icao of this.facilityIndex.keys()) {
          if (!this.filterCb(this.facilityIndex.get(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
          this.addFacility(this.facilityCache.get(icao), icao);
        }
      }
    }
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          this.facilityCache.set(added[i].icao, added[i]);
          if (this.filterCb === void 0 || this.filterCb(added[i])) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestAirportSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader, filterCb) {
      super(facilityLoader, FacilitySearchType.Airport, filterCb);
    }
    setFilter(showClosed, classMask) {
      if (this.session !== void 0) {
        this.session.setAirportFilter(showClosed, classMask);
      }
    }
    setExtendedFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      if (this.session !== void 0) {
        this.session.setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
      }
    }
  };
  var NearestIntersectionSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader, filterCb, filterDupTerminal = false) {
      super(facilityLoader, FacilitySearchType.Intersection, filterCb);
      this.nonTerminalIcaosToFilter = /* @__PURE__ */ new Set();
      this.filterDupTerminal = filterDupTerminal;
    }
    setFilter(typeMask) {
      if (this.session !== void 0) {
        this.session.setIntersectionFilter(typeMask);
      }
    }
    setFilterDupTerminal(filter) {
      if (filter === this.filterDupTerminal) {
        return;
      }
      this.filterDupTerminal = filter;
      this.refilter();
    }
    refilter() {
      this.nonTerminalIcaosToFilter.clear();
      if (this.filterDupTerminal) {
        for (const icao of this.facilityCache.keys()) {
          if (ICAO.isFacility(icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
            this.nonTerminalIcaosToFilter.add(icao);
          }
        }
      }
      if (this.filterCb || this.filterDupTerminal) {
        for (const icao of this.facilityIndex.keys()) {
          if (this.filterCb && !this.filterCb(this.facilityIndex.get(icao)) || this.filterDupTerminal && ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) && this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao)) {
          if ((this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao))) && (!this.filterDupTerminal || !ICAO.isFacility(icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(icao) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao)))) {
            this.addFacility(this.facilityCache.get(icao), icao);
          }
        }
      }
    }
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.nonTerminalIcaosToFilter.delete(results.removed[i]);
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          this.facilityCache.set(fac.icao, fac);
          if (this.filterDupTerminal && ICAO.isFacility(fac.icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(fac) && (this.filterCb === void 0 || this.filterCb(fac))) {
            this.nonTerminalIcaosToFilter.add(fac.icao);
          }
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          if ((this.filterCb === void 0 || this.filterCb(fac)) && (!this.filterDupTerminal || !ICAO.isFacility(fac.icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(fac) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(fac.icao)))) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestVorSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Vor);
    }
    setVorFilter(classMask, typeMask) {
      if (this.session !== void 0) {
        this.session.setVorFilter(classMask, typeMask);
      }
    }
  };
  var NearestNdbSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Ndb);
    }
  };
  var NearestUsrSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.User);
    }
  };
  var AdaptiveNearestSubscription = class extends AbstractSubscribableArray {
    constructor(innerSubscription, absoluteMaxItems) {
      super();
      this.innerSubscription = innerSubscription;
      this.sortFunc = (a, b) => this.pos.distance(a) - this.pos.distance(b);
      this.facilities = [];
      this.derivedMaxItems = 0;
      this.searchInProgress = false;
      this.pos = new GeoPoint(0, 0);
      this.diffMap = /* @__PURE__ */ new Map();
      this.updatePromiseResolves = [];
      this.absoluteMaxItems = SubscribableUtils.toSubscribable(absoluteMaxItems, true);
    }
    get length() {
      return this.facilities.length;
    }
    getArray() {
      return this.facilities;
    }
    get started() {
      return this.innerSubscription.started;
    }
    awaitStart() {
      return this.innerSubscription.awaitStart();
    }
    start() {
      return this.innerSubscription.start();
    }
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      this.pos.set(lat, lon);
      maxItems = Math.max(0, maxItems);
      if (maxItems > this.derivedMaxItems) {
        this.derivedMaxItems = maxItems;
      }
      await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
      if (this.innerSubscription.length > maxItems) {
        this.derivedMaxItems = Math.max(Math.round(this.derivedMaxItems - this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_DOWN_FACTOR), maxItems);
      } else {
        const absoluteMaxItems = this.absoluteMaxItems.get();
        while (this.innerSubscription.length < maxItems && this.derivedMaxItems < absoluteMaxItems) {
          this.derivedMaxItems = Math.min(Math.round(this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_UP_FACTOR), absoluteMaxItems);
          await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
        }
      }
      if (this.innerSubscription.length > maxItems) {
        if (maxItems > 1) {
          const sorted = Array.from(this.innerSubscription.getArray()).sort(this.sortFunc);
          sorted.length = maxItems;
          this.diffAndNotify(sorted);
        } else if (maxItems === 1) {
          this.diffAndNotify([this.findNearest(this.innerSubscription.getArray())]);
        } else {
          this.diffAndNotify(AdaptiveNearestSubscription.EMPTY_ARRAY);
        }
      } else {
        this.diffAndNotify(this.innerSubscription.getArray());
      }
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    findNearest(array) {
      let nearest = array[0];
      let nearestDistance = this.pos.distance(nearest);
      for (let i = 1; i < array.length; i++) {
        const fac = array[i];
        const distance = this.pos.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    diffAndNotify(newArray) {
      if (this.facilities.length === 0 && newArray.length === 0) {
        return;
      }
      if (newArray.length === 0) {
        this.facilities.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
        return;
      }
      if (this.facilities.length === 0) {
        for (let i = 0; i < newArray.length; i++) {
          this.facilities[i] = newArray[i];
        }
        this.facilities.length = newArray.length;
        this.notify(0, SubscribableArrayEventType.Added, this.facilities);
        return;
      }
      for (let i = 0; i < newArray.length; i++) {
        this.diffMap.set(newArray[i].icao, newArray[i]);
      }
      for (let i = this.facilities.length - 1; i >= 0; i--) {
        const old = this.facilities[i];
        if (this.diffMap.has(old.icao)) {
          this.diffMap.delete(old.icao);
        } else {
          this.facilities.splice(i, 1);
          this.notify(i, SubscribableArrayEventType.Removed, old);
        }
      }
      for (const toAdd of this.diffMap.values()) {
        this.facilities.push(toAdd);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, toAdd);
      }
      this.diffMap.clear();
    }
  };
  AdaptiveNearestSubscription.RAMP_UP_FACTOR = 1.33;
  AdaptiveNearestSubscription.RAMP_DOWN_FACTOR = 0.1;
  AdaptiveNearestSubscription.EMPTY_ARRAY = [];
  var LodBoundary = class {
    constructor(facility, lodDistanceThresholds, lodVectorCountTargets) {
      this.facility = facility;
      this.lodDistanceThresholds = (lodDistanceThresholds === null || lodDistanceThresholds === void 0 ? void 0 : lodDistanceThresholds.length) ? [...lodDistanceThresholds] : [0];
      this.lodVectorCountTargets = lodVectorCountTargets ? [...lodVectorCountTargets] : [];
      this.lods = this.processLods();
    }
    processLods() {
      var _a;
      const lodShapes = [];
      const originalShapes = this.processShapes(this.facility.vectors);
      if (Array.isArray(this.facility.lods)) {
        lodShapes.push(originalShapes);
        for (let i = 0; i < this.facility.lods.length; i++) {
          lodShapes.push(this.processShapes(this.facility.lods[i]));
        }
      } else {
        let startIndex = 0;
        if (this.lodDistanceThresholds[0] === 0 && ((_a = this.lodVectorCountTargets[0]) !== null && _a !== void 0 ? _a : 0) <= 0) {
          lodShapes.push(originalShapes);
          startIndex = 1;
        }
        const len = this.lodDistanceThresholds.length;
        for (let i = startIndex; i < len; i++) {
          lodShapes.push(this.simplifyShapes(originalShapes, this.lodDistanceThresholds[i], this.lodVectorCountTargets[i]));
        }
      }
      return lodShapes;
    }
    processShapes(vectors) {
      const shapes = [];
      const len = vectors.length;
      let index = 0;
      let currentShape;
      while (index < len) {
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            currentShape = [];
            index = this.processShape(currentShape, vectors, index);
            shapes.push(currentShape);
            break;
          case BoundaryVectorType.Circle:
            currentShape = [];
            index = this.processCircle(currentShape, vectors, index - 1);
            shapes.push(currentShape);
            break;
        }
        index++;
      }
      return shapes;
    }
    processShape(shape, vectors, index) {
      const start = vectors[index++];
      shape.push({ end: new GeoPoint(start.lat, start.lon) });
      const origins = [];
      const len = vectors.length;
      while (index < len) {
        const lastEndpoint = shape[shape.length - 1].end;
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            break;
          case BoundaryVectorType.Line:
            if (!lastEndpoint.equals(vector)) {
              shape.push({ circle: GeoCircle.createGreatCircle(lastEndpoint, vector), end: new GeoPoint(vector.lat, vector.lon) });
            }
            break;
          case BoundaryVectorType.Origin:
            origins[vector.originId] = vector;
            break;
          case BoundaryVectorType.ArcCCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const radius = end.distance(origin);
            shape.push({ circle: GeoCircle.createFromPoint(origin, radius), end });
            break;
          }
          case BoundaryVectorType.ArcCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const circle = GeoCircle.createFromPoint(origin, end.distance(origin)).reverse();
            shape.push({ circle, end });
            break;
          }
          case BoundaryVectorType.Circle:
            return index - 1;
        }
        index++;
      }
      return index - 1;
    }
    processCircle(shape, vectors, index) {
      const originVector = vectors[index];
      const circleVector = vectors[index + 1];
      if (originVector.type === BoundaryVectorType.Origin && circleVector.originId === originVector.originId) {
        const radius = UnitType.METER.convertTo(circleVector.radius, UnitType.GA_RADIAN);
        const circle = GeoCircle.createFromPoint(originVector, radius);
        const isCenterPole = circle.center[0] === 0 && circle.center[1] === 0 && Math.abs(circle.center[2]) === 1;
        const end = isCenterPole ? new GeoPoint(0, 0) : new GeoPoint(90, 0);
        circle.closest(end, end);
        shape.push({ end });
        shape.push({ circle, end });
      }
      return index + 1;
    }
    simplifyShapes(shapes, distanceThreshold, vectorCountTarget) {
      const simplified = [];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        simplified.push(this.simplifyShape(shapes[i], distanceThreshold, vectorCountTarget));
      }
      return simplified;
    }
    simplifyShape(shape, distanceThreshold, vectorCountTarget) {
      if (shape.length < 3) {
        return shape;
      }
      const simplified = [];
      const retain = [];
      retain[0] = true;
      retain[shape.length - 1] = true;
      if (vectorCountTarget === void 0 || vectorCountTarget <= 0) {
        this.simplify(distanceThreshold, shape, 0, shape.length, retain);
      } else {
        this.simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, 0, shape.length, retain);
      }
      this.rebuildSimplifiedVectors(shape, retain, simplified);
      return simplified;
    }
    simplify(distanceThreshold, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.index < 0) {
        return;
      }
      if (farthest.distance >= distanceThreshold) {
        retain[farthest.index] = true;
        this.simplify(distanceThreshold, shape, startIndex, farthest.index + 1, retain);
        this.simplify(distanceThreshold, shape, farthest.index, endIndex, retain);
      }
    }
    simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const queue = LodBoundary.queue;
      queue.clear();
      let edgeIndex = 0;
      let currentStartIndex = startIndex;
      let currentEndIndex = endIndex;
      let currentFarthestIndex;
      let retainCount = 2;
      while (retainCount < vectorCountTarget) {
        if (currentFarthestIndex === void 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentEndIndex, queue, edgeIndex++);
        } else if (currentFarthestIndex >= 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentFarthestIndex + 1, queue, edgeIndex++);
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentFarthestIndex, currentEndIndex, queue, edgeIndex++);
        }
        if (queue.size === 0) {
          break;
        }
        const edge = queue.removeMin();
        currentStartIndex = edge.startIndex;
        currentEndIndex = edge.endIndex;
        currentFarthestIndex = edge.farthestVectorIndex;
        retain[currentFarthestIndex] = true;
        retainCount++;
      }
    }
    computeAndInsertEdgeToQueue(distanceThreshold, shape, startIndex, endIndex, queue, edgeIndex) {
      var _a;
      var _b;
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.distance >= distanceThreshold) {
        const edge = (_a = (_b = LodBoundary.edgeCache)[edgeIndex]) !== null && _a !== void 0 ? _a : _b[edgeIndex] = LodBoundary.createEdge();
        edge.startIndex = startIndex;
        edge.endIndex = endIndex;
        edge.farthestVectorIndex = farthest.index;
        edge.distanceToFarthestVector = farthest.distance;
        queue.insert(edge);
      }
    }
    findFarthestVector(shape, startIndex, endIndex, reference) {
      let maxDistance = 0;
      let index = -1;
      for (let i = startIndex; i < endIndex; i++) {
        const distance = this.getDistanceFromReference(shape, i, reference);
        if (distance > maxDistance) {
          index = i;
          maxDistance = distance;
        }
      }
      return { index, distance: maxDistance };
    }
    getDistanceFromReference(shape, index, reference) {
      const vector = shape[index];
      if (!vector.circle) {
        return reference instanceof GeoCircle ? Math.abs(reference.distance(vector.end)) : reference.distance(vector.end);
      } else {
        const center = reference instanceof GeoCircle ? reference.center : reference;
        const arcStart = shape[index - 1].end;
        const maxAngularDist = vector.circle.angleAlong(arcStart, vector.end, Math.PI);
        const projectedAngularDist = vector.circle.angleAlong(arcStart, center, Math.PI);
        const oppositeAngularDist = (projectedAngularDist + Math.PI) % (2 * Math.PI);
        let arcDistance;
        if (oppositeAngularDist > 0 && oppositeAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center) + vector.circle.radius * 2);
          arcDistance = Math.min(arcDistance, 2 * Math.PI - arcDistance);
        } else if (projectedAngularDist > 0 && projectedAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center));
        }
        if (reference instanceof GeoCircle) {
          return arcDistance ? Math.abs(arcDistance - Math.PI / 2) : Math.abs(reference.distance(vector.end));
        } else {
          return arcDistance !== null && arcDistance !== void 0 ? arcDistance : vector.end.distance(reference);
        }
      }
    }
    rebuildSimplifiedVectors(shape, retain, simplified) {
      var _a;
      let lastRetained;
      const len = shape.length;
      for (let i = 0; i < len; i++) {
        if (!retain[i]) {
          continue;
        }
        const currentVector = shape[i];
        if (currentVector) {
          const prevRetain = retain[i - 1];
          const prevVector = shape[i - 1];
          if (!prevRetain) {
            if (lastRetained) {
              if (currentVector.circle && !currentVector.circle.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, prevVector.end), end: prevVector.end });
                simplified.push(LodBoundary.copyVector(currentVector));
              } else if ((_a = currentVector.circle) === null || _a === void 0 ? void 0 : _a.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, currentVector.end), end: currentVector.end });
              } else {
                simplified.push(LodBoundary.copyVector(currentVector));
              }
            } else {
              simplified.push({ end: currentVector.end });
            }
          } else {
            simplified.push(LodBoundary.copyVector(currentVector));
          }
          lastRetained = currentVector;
        }
      }
    }
    static copyVector(source) {
      return { circle: source.circle ? new GeoCircle(source.circle.center, source.circle.radius) : void 0, end: source.end.copy() };
    }
    static createEdge() {
      return {
        startIndex: -1,
        endIndex: -1,
        farthestVectorIndex: -1,
        distanceToFarthestVector: 0
      };
    }
  };
  LodBoundary.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  LodBoundary.edgeCache = [];
  LodBoundary.queue = new BinaryHeap((a, b) => b.distanceToFarthestVector - a.distanceToFarthestVector);
  var LodBoundaryCache = class {
    constructor(size, lodDistanceThresholds, lodVectorCountTargets) {
      this.size = size;
      this.lodDistanceThresholds = lodDistanceThresholds;
      this.lodVectorCountTargets = lodVectorCountTargets;
      this.cache = /* @__PURE__ */ new Map();
    }
    get(facility) {
      const existing = this.cache.get(facility.id);
      if (existing) {
        return existing;
      }
      return this.create(facility);
    }
    create(facility) {
      const boundary = new LodBoundary(facility, this.lodDistanceThresholds, this.lodVectorCountTargets);
      this.cache.set(facility.id, boundary);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
      return boundary;
    }
  };
  var ArrayTaskQueue = class {
    constructor(tasks) {
      this.tasks = tasks;
      this.head = 0;
    }
    hasNext() {
      return this.head < this.tasks.length;
    }
    next() {
      return this.tasks[this.head++];
    }
  };
  var ThrottledTaskQueueProcess = class {
    constructor(queue, handler) {
      this.queue = queue;
      this.handler = handler;
      this._hasStarted = false;
      this._hasEnded = false;
      this._shouldAbort = false;
    }
    hasStarted() {
      return this._hasStarted;
    }
    hasEnded() {
      return this._hasEnded;
    }
    start() {
      this._hasStarted = true;
      this.processQueue(0);
    }
    processQueue(elapsedFrameCount) {
      let dispatchCount = 0;
      const t0 = performance.now();
      while (!this._shouldAbort && this.queue.hasNext()) {
        if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
          const task = this.queue.next();
          task();
          dispatchCount++;
        } else {
          break;
        }
      }
      if (this._shouldAbort) {
        return;
      }
      if (!this.queue.hasNext()) {
        this.handler.onFinished(elapsedFrameCount);
        this._hasEnded = true;
      } else {
        this.handler.onPaused(elapsedFrameCount);
        requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
      }
    }
    abort() {
      if (this._hasStarted && !this._hasEnded) {
        this.handler.onAborted();
        this._shouldAbort = true;
        this._hasEnded = true;
      }
    }
  };
  var NearestLodBoundarySearchSession = class {
    constructor(cache, session, frameBudget) {
      this.cache = cache;
      this.session = session;
      this.frameBudget = frameBudget;
    }
    async searchNearest(lat, lon, radius, maxItems) {
      const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
      const results = { added: [], removed: facilityResults.removed };
      const tasks = facilityResults.added.map((fac, index) => () => {
        results.added[index] = this.cache.get(fac);
      });
      await new Promise((resolve) => {
        const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
        taskQueue.start();
      });
      return results;
    }
    setFilter(classMask) {
      this.session.setBoundaryFilter(classMask);
    }
  };
  var NearestLodBoundarySearchTaskQueueHandler = class {
    constructor(frameBudget, resolve) {
      this.frameBudget = frameBudget;
      this.resolve = resolve;
    }
    onStarted() {
    }
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
      return timeElapsed < this.frameBudget;
    }
    onPaused() {
    }
    onFinished() {
      this.resolve();
    }
    onAborted() {
    }
  };
  var FlightPathVectorFlags;
  (function(FlightPathVectorFlags2) {
    FlightPathVectorFlags2[FlightPathVectorFlags2["None"] = 0] = "None";
    FlightPathVectorFlags2[FlightPathVectorFlags2["TurnToCourse"] = 1] = "TurnToCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Arc"] = 2] = "Arc";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Direct"] = 4] = "Direct";
    FlightPathVectorFlags2[FlightPathVectorFlags2["InterceptCourse"] = 8] = "InterceptCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["CourseReversal"] = 512] = "CourseReversal";
    FlightPathVectorFlags2[FlightPathVectorFlags2["LegToLegTurn"] = 1024] = "LegToLegTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Fallback"] = 4096] = "Fallback";
  })(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
  var ProcedureDetails = class {
    constructor() {
      this.originRunway = void 0;
      this.departureIndex = -1;
      this.departureTransitionIndex = -1;
      this.departureRunwayIndex = -1;
      this.arrivalIndex = -1;
      this.arrivalTransitionIndex = -1;
      this.arrivalRunwayTransitionIndex = -1;
      this.arrivalRunway = void 0;
      this.approachIndex = -1;
      this.approachTransitionIndex = -1;
      this.destinationRunway = void 0;
    }
  };
  var FlightPlanSegmentType;
  (function(FlightPlanSegmentType2) {
    FlightPlanSegmentType2["Origin"] = "Origin";
    FlightPlanSegmentType2["Departure"] = "Departure";
    FlightPlanSegmentType2["Enroute"] = "Enroute";
    FlightPlanSegmentType2["Arrival"] = "Arrival";
    FlightPlanSegmentType2["Approach"] = "Approach";
    FlightPlanSegmentType2["Destination"] = "Destination";
    FlightPlanSegmentType2["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType2["RandomDirectTo"] = "RandomDirectTo";
  })(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
  var FlightPlanSegment = class {
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
      this.segmentIndex = segmentIndex;
      this.offset = offset;
      this.legs = legs;
      this.segmentType = segmentType;
      this.airway = airway;
    }
  };
  FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
  var LegDefinitionFlags;
  (function(LegDefinitionFlags2) {
    LegDefinitionFlags2[LegDefinitionFlags2["None"] = 0] = "None";
    LegDefinitionFlags2[LegDefinitionFlags2["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags2[LegDefinitionFlags2["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags2[LegDefinitionFlags2["Obs"] = 4] = "Obs";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
  })(LegDefinitionFlags || (LegDefinitionFlags = {}));
  var VerticalFlightPhase;
  (function(VerticalFlightPhase2) {
    VerticalFlightPhase2["Climb"] = "Climb";
    VerticalFlightPhase2["Descent"] = "Descent";
  })(VerticalFlightPhase || (VerticalFlightPhase = {}));
  var SpeedUnit;
  (function(SpeedUnit2) {
    SpeedUnit2[SpeedUnit2["IAS"] = 0] = "IAS";
    SpeedUnit2[SpeedUnit2["MACH"] = 1] = "MACH";
  })(SpeedUnit || (SpeedUnit = {}));
  var SpeedRestrictionType;
  (function(SpeedRestrictionType2) {
    SpeedRestrictionType2[SpeedRestrictionType2["Unused"] = 0] = "Unused";
    SpeedRestrictionType2[SpeedRestrictionType2["At"] = 1] = "At";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType2[SpeedRestrictionType2["Between"] = 4] = "Between";
  })(SpeedRestrictionType || (SpeedRestrictionType = {}));
  var FlightPathUtils = class {
    static createEmptyCircleVector() {
      return {
        vectorType: "circle",
        flags: FlightPathVectorFlags.None,
        radius: 0,
        centerX: 1,
        centerY: 0,
        centerZ: 0,
        startLat: 0,
        startLon: 0,
        endLat: 0,
        endLon: 0,
        distance: 0
      };
    }
    static setCircleVector(vector, circle, start, end, flags) {
      vector.flags = flags;
      vector.radius = circle.radius;
      vector.centerX = circle.center[0];
      vector.centerY = circle.center[1];
      vector.centerZ = circle.center[2];
      vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
      start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
      end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
      vector.startLat = start.lat;
      vector.startLon = start.lon;
      vector.endLat = end.lat;
      vector.endLon = end.lon;
      return vector;
    }
    static isVectorGreatCircle(vector) {
      return vector.radius === Math.PI / 2;
    }
    static setGeoCircleFromVector(vector, out) {
      return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    static getVectorTurnDirection(vector) {
      return vector.radius > MathUtils.HALF_PI ? "right" : "left";
    }
    static getVectorTurnRadius(vector) {
      return Math.min(vector.radius, Math.PI - vector.radius);
    }
    static getVectorInitialCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    static getVectorFinalCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    static getLegTrueCourse(leg, point, magVarFacility) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      const magVar = magVarFacility ? -magVarFacility.magneticVariation : Facilities.getMagVar(point.lat, point.lon);
      return NavMath.normalizeHeading(leg.course + magVar);
    }
    static getLegFinalPosition(legCalc, out) {
      if (legCalc.endLat !== void 0 && legCalc.endLon !== void 0) {
        return out.set(legCalc.endLat, legCalc.endLon);
      }
      return void 0;
    }
    static getLegFinalCourse(legCalc) {
      if (legCalc.flightPath.length > 0) {
        const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
        return this.getVectorFinalCourse(vector);
      }
      return void 0;
    }
    static getTurnCircle(center, radius, turnDirection, out) {
      out.set(center, radius);
      if (turnDirection === "right") {
        out.reverse();
      }
      return out;
    }
    static reverseTurnCircle(circle, out) {
      return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    static getTurnDirectionFromCircle(circle) {
      return circle.radius > MathUtils.HALF_PI ? "right" : "left";
    }
    static getTurnRadiusFromCircle(circle) {
      return Math.min(circle.radius, Math.PI - circle.radius);
    }
    static getTurnCenterFromCircle(circle, out) {
      return circle.radius > MathUtils.HALF_PI ? out instanceof Float64Array ? Vec3Math.multScalar(circle.center, -1, out) : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2]) : out instanceof Float64Array ? Vec3Math.copy(circle.center, out) : out.setFromCartesian(circle.center);
    }
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
      }
      const radius = turnDirection === "left" ? turnRadius : Math.PI - turnRadius;
      const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
      const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
      return out.set(turnCenter, radius);
    }
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      return circle.arcLength((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
        return posAngularDistance >= Math.PI ? -Infinity : Infinity;
      }
      return ((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angularTolerance = circle.angularWidth(tolerance);
      if (typeof end !== "number") {
        end = circle.angleAlong(start, end, Math.PI, angularTolerance);
      }
      if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
        return true;
      }
      const angle = circle.angleAlong(start, pos, Math.PI);
      if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
        return true;
      }
      const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
      return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    static projectVelocityToCircle(speed, position, direction, projectTo) {
      if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      if (speed === 0) {
        return 0;
      }
      if (!(position instanceof Float64Array)) {
        position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
      }
      const velocityPath = typeof direction === "number" ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction) : direction.isGreatCircle() ? direction : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
      const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
      const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
      const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
      const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
      const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
      return speed * sinTheta * sign;
    }
    static resolveIngressToEgress(legCalc) {
      var _a, _b, _c, _d, _e, _f;
      var _g, _h, _j, _k, _l, _m;
      const vectors = legCalc.ingressToEgress;
      let vectorIndex = 0;
      let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
      const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
      const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
      const firstEgressVector = legCalc.egress[0];
      const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
      if (lastIngressVector && ingressJoinVector) {
        const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
        const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
        const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon) : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
        const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
        const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
        if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
          if (ingressEndAlongVectorDistance > normalizedTolerance) {
            ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
            FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : vectors[_g] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
          } else {
            Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : vectors[_h] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVector);
          }
        }
        flightPathVectorIndex++;
      }
      const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
      for (let i = flightPathVectorIndex; i < end; i++) {
        Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : vectors[_j] = FlightPathUtils.createEmptyCircleVector(), legCalc.flightPath[i]);
        flightPathVectorIndex++;
      }
      if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
        if (firstEgressVector) {
          const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
          const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
          const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
          const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
          const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
          const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
          if (egressStartAlongVectorDistance > normalizedTolerance) {
            if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
              egressJoinVectorCircle.closest(egressStart, egressStart);
              FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : vectors[_k] = FlightPathUtils.createEmptyCircleVector(), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
            } else {
              Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : vectors[_l] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
            }
          }
        } else {
          Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : vectors[_m] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
        }
      }
      vectors.length = vectorIndex;
      return legCalc;
    }
  };
  FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var CircleVectorBuilder = class {
    build(vectors, index, ...args) {
      if (args[0] instanceof GeoCircle) {
        this.setFromCircle(vectors, index, ...args);
      } else {
        this.setFromPoints(vectors, index, ...args);
      }
      return 1;
    }
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
      return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
      var _a;
      const vector = ((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === "circle" ? vectors[index] : vectors[index] = FlightPathUtils.createEmptyCircleVector();
      return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
  };
  CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var GreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, pathArg, endArg, flags) {
      if (pathArg instanceof GeoCircle) {
        return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
      } else {
        return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
      }
    }
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
      const startPoint = start instanceof Float64Array ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start) : GreatCircleBuilder.geoPointCache[0].set(start);
      const endPoint = end instanceof Float64Array ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end) : GreatCircleBuilder.geoPointCache[1].set(end);
      const distance = startPoint.distance(endPoint);
      const path = GreatCircleBuilder.geoCircleCache[0];
      if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
        if (initialCourse === void 0) {
          throw new Error("GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.");
        } else {
          path.setAsGreatCircle(start, initialCourse);
        }
      } else {
        path.setAsGreatCircle(start, end);
      }
      return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
      if (!path.isGreatCircle()) {
        throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
      }
      const end = typeof endArg === "number" ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI) : endArg;
      return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
  };
  GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
  GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var TurnToCourseBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
      if (start instanceof Float64Array) {
        start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
      }
      const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === "left" ? -90 : 90), radiusRad);
      const turnStartBearing = turnCenterPoint.bearingTo(start);
      const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
      if (turnEndPoint.equals(start)) {
        return 0;
      }
      return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
  };
  TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var CircleInterceptBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, pathArg, circle, flags = 0) {
      if (circle.includes(start)) {
        return 0;
      }
      let startPath;
      if (pathArg instanceof GeoCircle) {
        if (!pathArg.includes(start)) {
          throw new Error("CircleInterceptBuilder: the starting point does not lie on the starting path.");
        }
        startPath = pathArg;
      } else {
        startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
      }
      const intersections = CircleInterceptBuilder.intersectionCache;
      const numIntersections = startPath.intersection(circle, intersections);
      if (numIntersections === 0) {
        return 0;
      }
      const intersectionIndex = numIntersections === 1 || circle.encircles(start) ? 0 : 1;
      const endVec = intersections[intersectionIndex];
      return startPath.isGreatCircle() ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags) : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
  };
  CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
      if (!endPath.isGreatCircle()) {
        throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
      }
      let startPath;
      if (startPathArg instanceof GeoCircle) {
        if (!startPathArg.isGreatCircle()) {
          throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
        } else if (!startPathArg.includes(start)) {
          throw new Error("TurnToJoinPathBuilder: the starting point does not lie on the starting path.");
        }
        startPath = startPathArg;
      } else {
        startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
      }
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
      }
      const turnDirection = endPath.encircles(start) ? "left" : "right";
      const radiusRad = turnDirection === "left" ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
      const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
      const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === "left" ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
  };
  TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var ConnectCirclesBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, fromCircle, toCircle, radius, from, to, fromCircleVectorFlags = 0, toCircleVectorFlags = 0, connectVectorFlags = 0) {
      if (radius === 0) {
        return 0;
      }
      const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
      if (angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius || Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE) {
        return 0;
      }
      if (from && !(from instanceof Float64Array)) {
        from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
      }
      if (to && !(to instanceof Float64Array)) {
        to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
      }
      const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
      const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
      if (!joinCircle) {
        return 0;
      }
      let vectorIndex = index;
      const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
      const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
      if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart, fromCircleVectorFlags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd, connectVectorFlags);
      if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to, toCircleVectorFlags);
      }
      return vectorIndex - index;
    }
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
      const solutions = [];
      const intersections = ConnectCirclesBuilder.intersectionCache;
      const leftTurnRadius = radius;
      let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
      let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
      let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
      let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
      const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
      if (numLeftTurnSolutions === 1) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
      } else if (numLeftTurnSolutions === 2) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
      }
      if (radius !== Math.PI / 2) {
        const rightTurnRadius = Math.PI - radius;
        fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
        toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
        fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
        toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
        const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numRightTurnSolutions === 1) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
        } else if (numRightTurnSolutions === 2) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
          solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
        }
      }
      if (solutions.length === 0) {
        return null;
      } else if (solutions.length === 1) {
        return out.set(solutions[0].center, solutions[0].radius);
      } else {
        let circle = solutions[0];
        let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
        for (let i = 1; i < solutions.length; i++) {
          const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
          if (distance < minDistance) {
            circle = solutions[i];
            minDistance = distance;
          }
        }
        return out.set(circle.center, circle.radius);
      }
    }
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
      let distance = 0;
      const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
      const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
      if (from) {
        distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
      }
      distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
      if (to) {
        distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
      }
      return distance;
    }
  };
  ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleAtPointBuilder = class {
    constructor() {
      this.connectCirclesBuilder = new ConnectCirclesBuilder();
    }
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, end, endPath, endTurnRadius, endTurnDirection, startTurnVectorFlags = 0, endTurnVectorFlags = 0, connectVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[1]);
      }
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      const startTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
      const startTurnCircleRadiusRad = startTurnDirection === "left" ? startTurnRadiusRad : Math.PI - startTurnRadiusRad;
      const startTurnCircleCenter = startTurnOffsetPath.offsetDistanceAlong(start, startTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const startTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].set(startTurnCircleCenter, startTurnCircleRadiusRad);
      const endTurnRadiusRad = UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      const endTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
      const endTurnCircleRadiusRad = endTurnDirection === "left" ? endTurnRadiusRad : Math.PI - endTurnRadiusRad;
      const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const endTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
      return this.connectCirclesBuilder.build(vectors, index, startTurnCircle, endTurnCircle, void 0, start, end, startTurnVectorFlags, endTurnVectorFlags, connectVectorFlags);
    }
  };
  TurnToJoinGreatCircleAtPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleAtPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var InterceptGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
      }
      const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
      if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
      const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
      const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      if (startTurnDirection === void 0) {
        const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
        if (interceptCount === 0) {
          startTurnDirection = startPath.encircles(end) ? "left" : "right";
        } else {
          let intersectionIndex = 0;
          if (interceptCount > 1) {
            intersectionIndex = endPath.encircles(start) ? 0 : 1;
          }
          let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
          if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
            cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
              startTurnDirection = "right";
            } else {
              startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? "left" : "right";
            }
          } else {
            startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? "left" : "right";
          }
        }
      }
      const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
      const endTurnRadiusRad = endTurnRadius === void 0 ? void 0 : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        const startTurnEnd2 = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd2, end, Math.PI);
        if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd2, startTurnVectorFlags);
      }
      const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
      const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
      if (interceptPathCount === 0) {
        return 0;
      }
      const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
      let interceptCrossSign;
      if (startToEndPathAngleRad >= interceptAngleRad) {
        const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
        const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
        interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
        interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === "right") ? 1 : -1;
      } else {
        interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
        interceptCrossSign = startTurnDirection === "right" ? 1 : -1;
      }
      const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
      const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
      const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      let minDInterceptEnd = 0;
      if (endTurnRadiusRad !== void 0) {
        const endTheta = Math.PI - interceptAngleRad;
        minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
        if (isNaN(minDInterceptEnd)) {
          return 0;
        }
      }
      const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
      if (interceptToEndOffset < minDInterceptEnd) {
        return 0;
      }
      let vectorIndex = index;
      if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
        if (endTurnRadiusRad === void 0) {
          const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
          if (startTurnEndPathIntersectionCount === 0) {
            return 0;
          }
          const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === "right" ? 0 : 1];
          if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
        } else {
          const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
          const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === "left" ? 1 : -1));
          const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
          if (endTurnCircleCount === 0) {
            return 0;
          }
          const endTurnCenter = intersections[0];
          const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === "left" ? "right" : "left", InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
          endTurnCircle.closest(startTurnCenter, startTurnEnd);
          const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
        }
      } else {
        if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        let interceptPathEnd = intercept;
        if (endTurnRadiusRad !== void 0) {
          interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
        }
        if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
        }
        if (endTurnRadius !== void 0) {
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
        }
      }
      return vectorIndex - index;
    }
  };
  InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var JoinGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
      this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
      }
      if (!intersection) {
        const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
        const solutionCount = startPath.intersection(endPath, intersections);
        if (solutionCount === 0) {
          return 0;
        }
        intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0 ? intersections[0] : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
      const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
      const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const isEndForwardOfIntersection = intersectionToEndSign > 0;
      minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : minTurnRadius = 0;
      const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
      const pathDot = Vec3Math.dot(startPath.center, endPath.center);
      const theta = Math.acos(-pathDot);
      const tanHalfTheta = Math.tan(theta / 2);
      let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
      if (isNaN(minD)) {
        minD = Infinity;
      }
      const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
      const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
      const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
      const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
      const towardEndPointTurnDirection = startPath.encircles(end, false) ? "left" : "right";
      let needCalculateTwoTurnPath = false;
      let needCalculateOneTurnPath = false;
      if (isEndForwardOfIntersection) {
        if (desiredTurnDirection === void 0 || desiredTurnDirection === towardEndPointTurnDirection) {
          const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
          const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
          if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          } else {
            const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
            if (intersectionStartDistance <= intersectionEndDistance) {
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
              if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
              }
            } else {
              let turnStart = start;
              if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
              }
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
            }
          }
        } else {
          if (pathDot >= 0) {
            if (intersectionStartOffset <= minD) {
              needCalculateOneTurnPath = true;
            } else {
              needCalculateTwoTurnPath = !preferSingleTurn;
              needCalculateOneTurnPath = preferSingleTurn;
            }
          } else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          }
        }
      } else {
        needCalculateTwoTurnPath = !preferSingleTurn;
        needCalculateOneTurnPath = preferSingleTurn;
      }
      let needDirectFallback = false;
      if (needCalculateTwoTurnPath) {
        const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
        const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, void 0, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
        if (numInterceptVectors === 0) {
          needDirectFallback = allowDirectFallback;
        } else {
          vectorIndex += numInterceptVectors;
          const lastVector = vectors[vectorIndex - 1];
          const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
          if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
          }
        }
      } else if (needCalculateOneTurnPath) {
        minD = Math.min(minD, Math.PI / 2);
        if (minD > Math.PI / 2) {
          needDirectFallback = allowDirectFallback;
        } else {
          const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
          const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
          const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
          const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
          if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
          }
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
          if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
          }
        }
      }
      if (needDirectFallback) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
      }
      return vectorIndex - index;
    }
  };
  JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45;
  JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var ProcedureTurnBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
      }
      initialCourse !== null && initialCourse !== void 0 ? initialCourse : initialCourse = startPath.bearingAt(start, Math.PI);
      finalCourse !== null && finalCourse !== void 0 ? finalCourse : finalCourse = endPath.bearingAt(end, Math.PI);
      const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
      const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
      const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === "left");
      const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
      const thetaOutbound = (Math.PI - deltaOutbound) / 2;
      const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : initialTurnDirection === "left" === deltaOutbound < Math.PI ? "right" : "left";
      const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
      let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10 ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1) : 0;
      desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound)) * (isInitialTurnTowardEndPath ? 1 : -1);
      const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
      let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
      desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
      desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
      const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
      const initialTurnStartPoint = alongStartPathDistance > 0 ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1]) : startPoint;
      const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
      const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
      const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
      const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === "left" ? -1 : 1));
      const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
      const turnStartPoint = alongTurnOutboundPathDistance > 0 ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4]) : initialTurnEndPoint;
      const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
      const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
      let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
      const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
      let finalTurnDirection;
      let finalTurnRadius;
      let finalTurnStartPoint;
      let finalTurnCenterPoint;
      let finalTurnEndPoint;
      let endPoint;
      if (endPath.encircles(turnEndVec) === (initialTurnDirection === "left")) {
        const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnCircle.intersection(endPath, intersections);
        if (numIntersections === 0) {
          endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
        } else {
          if (numIntersections === 2) {
            const headingAdjustment = turnDirection === "left" ? -90 : 90;
            const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
          } else {
            turnEndPoint.setFromCartesian(intersections[0]);
          }
          turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
        }
      } else {
        const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
        const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnInboundPath.intersection(endPath, intersections);
        if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
          const intersection = intersections[numIntersections === 1 || endPath.encircles(turnEndVec) ? 0 : 1];
          if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
            const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
            const thetaInbound = (Math.PI - deltaInbound) / 2;
            const tanThetaInbound = Math.tan(thetaInbound);
            const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
            const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
            const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance ? desiredTurnRadiusRad : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
            finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
            finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
            finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
            finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === "left" ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
            finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
          }
        }
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      if (initialTurnStartPoint !== startPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
      if (turnStartPoint !== initialTurnEndPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
      if (finalTurnCenterPoint) {
        if (!finalTurnStartPoint.equals(turnEndPoint)) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, void 0, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
      } else {
        if (endPoint) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, void 0, flags);
        }
      }
      return vectorIndex - index;
    }
  };
  ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0)
  ];
  ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var DirectToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
    }
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
      let vectorIndex = index;
      if (typeof startPath === "number") {
        startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
      }
      const endPos = DirectToPointBuilder.geoPointCache[0];
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        endPos.set(end);
        end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
      } else {
        endPos.setFromCartesian(end);
      }
      const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
      if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
        return vectorIndex - index;
      } else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
        return vectorIndex - index;
      }
      const startPathEncirclesTerminator = startPath.encircles(end);
      const startPathIncludesTerminator = startPath.includes(end);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPathEncirclesTerminator && !startPathIncludesTerminator ? "left" : "right";
      const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === "left" ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2]) : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
      let maxTurnRadiusRad;
      if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === "left")) {
        const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
        const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
        maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
      } else {
        maxTurnRadiusRad = Math.PI / 2;
      }
      const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
      const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
      const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
      const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
      const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
      const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
      const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === "left" ? -1 : 1) + 180);
      const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
      const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
      flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
      if (!GeoPoint.equals(turnEndVec, start)) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
      }
      if (!GeoPoint.equals(turnEndVec, end)) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, void 0, flags);
      }
      return vectorIndex - index;
    }
  };
  DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var AbstractFlightPathLegCalculator = class {
    constructor(facilityCache, skipWhenActive = false) {
      this.facilityCache = facilityCache;
      this.skipWhenActive = skipWhenActive;
    }
    getPositionFromIcao(icao, out) {
      const facility = this.facilityCache.get(icao);
      return facility ? out.set(facility) : void 0;
    }
    getTerminatorPosition(leg, icao, out) {
      if (leg.lat !== void 0 && leg.lon !== void 0) {
        return out.set(leg.lat, leg.lon);
      } else {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility.lat, facility.lon) : void 0;
      }
    }
    getLegMagVar(leg, point) {
      const facIcao = leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR) ? leg.originIcao : leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR) ? leg.fixIcao : void 0;
      const facility = facIcao !== void 0 ? this.facilityCache.get(facIcao) : void 0;
      return facility === void 0 ? MagVar.get(point) : -facility.magneticVariation;
    }
    getLegTrueCourse(leg, point) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
      var _a, _b, _c;
      var _d;
      const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : _d.calculated = {
        courseMagVar: 0,
        startLat: void 0,
        startLon: void 0,
        endLat: void 0,
        endLon: void 0,
        distance: 0,
        distanceWithTransitions: 0,
        initialDtk: void 0,
        cumulativeDistance: 0,
        cumulativeDistanceWithTransitions: 0,
        flightPath: [],
        ingress: [],
        ingressJoinIndex: -1,
        ingressToEgress: [],
        egressJoinIndex: -1,
        egress: [],
        endsInFallback: false
      };
      const vectors = calcs.flightPath;
      if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
        state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
        state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
        state.isFallback = calcs.endsInFallback;
        return calcs;
      }
      try {
        this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
        this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
        resolveIngressToEgress && this.resolveIngressToEgress(calcs);
        calcs.endsInFallback = state.isFallback;
      } catch (e) {
        console.error(e);
        if (e instanceof Error) {
          console.error(e.stack);
        }
        vectors.length = 0;
        calcs.ingress.length = 0;
        calcs.ingressJoinIndex = 0;
        calcs.egress.length = 0;
        calcs.egressJoinIndex = -1;
        calcs.ingressToEgress.length = 0;
        calcs.endsInFallback = false;
        state.isFallback = false;
      }
      return calcs;
    }
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
      return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    resolveIngressToEgress(legCalc) {
      FlightPathUtils.resolveIngressToEgress(legCalc);
    }
  };
  var CourseToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    constructor(facilityCache) {
      super(facilityCache, true);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0)
      ];
      this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
      this.procTurnBuilder = new ProcedureTurnBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const leg = legs[calculateIndex].leg;
      const prevLeg = legs[calculateIndex - 1];
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : void 0;
      const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
      if (!endPoint) {
        vectors.length = vectorIndex;
        state.isFallback = false;
        return;
      }
      const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
      if (state.isFallback && state.currentPosition !== void 0 && state.currentCourse !== void 0) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, void 0, FlightPathVectorFlags.Fallback);
        state.isFallback = false;
      } else {
        state.isFallback = false;
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM)) {
          const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        } else {
          const startVec = startPoint.toCartesian(this.vec3Cache[0]);
          const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
          const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
          const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
          const isStartEqualToEnd = startPoint.equals(endPoint);
          const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
          if (!leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type) && threshold.encircles(startVec, false)) {
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
            (_d = state.currentCourse) !== null && _d !== void 0 ? _d : state.currentCourse = currentCourse;
            state.isFallback = true;
          } else {
            const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
            if (pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE) {
              let desiredTurnDirection;
              switch (leg.turnDirection) {
                case LegTurnDirection.Left:
                  desiredTurnDirection = "left";
                  break;
                case LegTurnDirection.Right:
                  desiredTurnDirection = "right";
                  break;
                default: {
                  const endDistanceFromStartPath = startPath.distance(endVec);
                  if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? "left" : "right";
                  } else {
                    desiredTurnDirection = endDistanceFromStartPath < 0 ? "left" : "right";
                  }
                }
              }
              vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === "left" ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
              if (vectorIndex > 0) {
                const lastVector2 = vectors[vectorIndex - 1];
                const interceptVec = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                  vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector2.endLat, lastVector2.endLon), endPoint);
                }
              }
            } else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE || !isStartEqualToEnd && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 || ((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))) {
              if (!isStartEqualToEnd) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
              }
            } else {
              const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : void 0;
              vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
              const lastVector2 = vectors[vectorIndex - 1];
              if (lastVector2 !== void 0 && Math.abs(FlightPathUtils.getVectorFinalCourse(lastVector2) - endCourse) > 1 && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                let startTurnCircle;
                let startTurnEnd;
                const isLastVectorGreatCircle = FlightPathUtils.isVectorGreatCircle(lastVector2);
                if (isLastVectorGreatCircle && vectors[vectorIndex - 2] !== void 0) {
                  const startTurnVector = vectors[vectorIndex - 2];
                  startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                  startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[2]);
                } else if (!isLastVectorGreatCircle) {
                  startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPath.encircles(endVec) ? "left" : "right", this.geoCircleCache[3]);
                  if (Math.min(lastVector2.radius, Math.PI - lastVector2.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                    startTurnEnd = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                  }
                }
                if (startTurnCircle !== void 0) {
                  const intersections = this.intersectionCache;
                  const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                  if (intersectionCount === 1) {
                    if (threshold.encircles(FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, this.vec3Cache[2]))) {
                      vectorIndex = 0;
                      ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
                      (_h = state.currentCourse) !== null && _h !== void 0 ? _h : state.currentCourse = currentCourse;
                      state.isFallback = true;
                    }
                  } else if (startTurnEnd === void 0 || intersectionCount === 2) {
                    const thresholdCrossing = intersections[0];
                    const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                    if (startTurnEnd === void 0 || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                      vectorIndex = 0;
                      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                      state.isFallback = true;
                    }
                  }
                }
              }
            }
          }
        }
      }
      const lastVector = vectors[vectorIndex - 1];
      if (lastVector !== void 0) {
        ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : state.currentPosition = new GeoPoint(0, 0)).set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
      }
      vectors.length = vectorIndex;
    }
  };
  CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
  ];
  var FlightPathTurnCalculator = class {
    constructor() {
      this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
      var _a, _b, _c, _d, _e, _f;
      const end = startIndex + count;
      let currentIndex = startIndex;
      while (currentIndex < end) {
        const fromLegCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
        const toLegCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
        if (fromLegCalc && toLegCalc) {
          const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
          const toVector = toLegCalc.flightPath[0];
          if (fromVector && toVector && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn)) && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
              currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
              continue;
            } else if (toVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
              continue;
            } else if (fromVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
              continue;
            }
          }
        }
        if (fromLegCalc && BitFlags.isAll((_d = (_c = fromLegCalc.egress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
          fromLegCalc.egress.length = 0;
          fromLegCalc.egressJoinIndex = -1;
        }
        if (toLegCalc && BitFlags.isAll((_f = (_e = toLegCalc.ingress[0]) === null || _e === void 0 ? void 0 : _e.flags) !== null && _f !== void 0 ? _f : 0, FlightPathVectorFlags.LegToLegTurn)) {
          toLegCalc.ingress.length = 0;
          toLegCalc.ingressJoinIndex = -1;
        }
        currentIndex++;
      }
    }
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
      const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
      const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
      if (trackAngleDiff < 1 || fromTrack.distance === 0 || toTrack.distance === 0 || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      if (trackAngleDiff > 175) {
        return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
      }
      const theta = (180 - trackAngleDiff) / 2;
      const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
      const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
      let restrictedD = Infinity;
      if (isRestrictedByPrevTurn) {
        if (previousTanTheta === void 0) {
          if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
            const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
            restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
          }
        } else {
          const tanThetaRatio = previousTanTheta / tanTheta;
          const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
          const cosTotalD = Math.cos(totalD);
          let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
          if (prevTurnRestrictedD > totalD) {
            prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
          }
          restrictedD = prevTurnRestrictedD;
        }
      }
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          let nextTurnRestrictedD;
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
          }
          restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
        }
      }
      const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
      const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
      const turnRadiusRad = desiredD === D ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN) : Math.atan(Math.sin(D) * tanTheta);
      if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
      const turnBisectorBearing = toTrackBearing + theta * (turnDirection === "left" ? -1 : 1);
      const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
      const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
      const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
      return lastComputedIndex;
    }
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
          }
        }
      }
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
      const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? "left" : "right";
      const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === "left" ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
      toLegCalc.ingress.length = length;
      toLegCalc.ingressJoinIndex = 0;
      return lastComputedIndex;
    }
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      if (arc.distance === 0 || track.distance === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const fromVector = isArcFirst ? arc : track;
      const toVector = isArcFirst ? track : arc;
      const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
      const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
      if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
        return toIndex;
      }
      const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
      const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
      const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
      if (vectorBearingDiff < 1) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
      const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, FlightPathTurnCalculator.geoPointCache[2]);
      const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
      const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const arcCircle = FlightPathTurnCalculator.geoCircleCache[0].set(arcCenter, arcRadius);
      const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[1]);
      const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
      const arcStartRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
      const arcEndRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
      const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
      if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
      let isInside;
      let turnRadiusRad;
      let arcCircleOffsetSign;
      let trackPathOffsetSign;
      if (arcTrackIntersectionCount === 1) {
        const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
        if (isForward) {
          this.setEmptyTurn(fromLegCalc, toLegCalc);
          return toIndex;
        } else {
          isInside = false;
          turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
          arcCircleOffsetSign = 1;
          trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
        }
      } else {
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        isInside = isArcFirst ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90 : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
        const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, FlightPathTurnCalculator.vector3Cache[0]);
        const maxTrackLimitDistance = isInside ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius)) : Infinity;
        const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
        const trackLimitPoint = isArcFirst ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]) : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]);
        const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, isArcFirst === isInside ? -1 : 1, FlightPathTurnCalculator.vector3Cache[1]), arcCircle.center, FlightPathTurnCalculator.vector3Cache[1]), Math.PI / 2);
        const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
        trackPerpendicularDiameter.intersection(arcCircle, antipodes);
        const intersectingPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === "left") ? antipodes[0] : antipodes[1], trackLimitPoint);
        const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
        let arcLimitAngularWidth = Infinity;
        if (numArcIntersections > 0) {
          const pseudoArcLimitPoint = arcIntersections[0];
          const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
          arcLimitAngularWidth = Math.abs(NavMath.diffAngle(isArcFirst ? arcEndRadial : arcStartRadial, pseudoArcLimitPointAngle));
        }
        let arcTurnRadiusLimit = 0;
        const arcAngularWidth = ((arcDirection === "left" ? arcStartRadial - arcEndRadial : arcEndRadial - arcStartRadial) + 360) % 360;
        arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
        if (arcLimitAngularWidth > 0) {
          const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * (arcDirection === "left" ? -1 : 1);
          const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, FlightPathTurnCalculator.geoPointCache[4]);
          const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
          const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
          if (theta >= Math.PI / 2) {
            if (isInside) {
              const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
              arcTurnRadiusLimit = (arcRadius - d) / 2;
            } else {
              arcTurnRadiusLimit = Infinity;
            }
          } else {
            const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
            arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
            const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
            const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[1]), FlightPathTurnCalculator.vector3Cache[1]);
            const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
            const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
            const sinTheta = Math.sin(theta);
            const sign = isInside ? -1 : 1;
            arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
          }
        }
        turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
        arcCircleOffsetSign = isInside ? -1 : 1;
        trackPathOffsetSign = turnDirection === "left" ? -1 : 1;
      }
      if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
      const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
      const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
      const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
      if (intersectionCount === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      let turnCenter;
      if (intersectionCount === 2) {
        if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
          turnCenter = intersections[1];
        } else {
          turnCenter = intersections[0];
        }
      } else {
        turnCenter = intersections[0];
      }
      const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
      const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
      const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
      const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
      let turnAngularDelta = turnEndBearing - turnStartBearing;
      if (turnDirection === "right" && turnEndBearing <= turnStartBearing) {
        turnAngularDelta += 360;
      } else if (turnDirection === "left" && turnEndBearing >= turnStartBearing) {
        turnAngularDelta -= 360;
      }
      const turnMiddleBearing = (turnStartBearing + turnAngularDelta / 2 + 360) % 360;
      const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
      const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
      const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
      turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
      return toIndex;
    }
    setEmptyTurn(fromLegCalc, toLegCalc) {
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      toLegCalc.ingress.length = 0;
      toLegCalc.ingressJoinIndex = -1;
    }
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
      var _a, _b;
      var _c, _d;
      const egress = (_a = (_c = fromLegCalc.egress)[0]) !== null && _a !== void 0 ? _a : _c[0] = FlightPathUtils.createEmptyCircleVector();
      const ingress = (_b = (_d = toLegCalc.ingress)[0]) !== null && _b !== void 0 ? _b : _d[0] = FlightPathUtils.createEmptyCircleVector();
      fromLegCalc.egress.length = 1;
      toLegCalc.ingress.length = 1;
      fromLegCalc.egressJoinIndex = fromLegCalc.flightPath.length - 1;
      toLegCalc.ingressJoinIndex = 0;
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
      const egressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | fromLegCalc.flightPath[fromLegCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      const ingressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | toLegCalc.flightPath[toLegCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      FlightPathUtils.setCircleVector(egress, circle, start, middle, egressFlags);
      FlightPathUtils.setCircleVector(ingress, circle, middle, end, ingressFlags);
    }
  };
  FlightPathTurnCalculator.vector3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
  };
  var FlightPlanUtils = class {
    static isAltitudeLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    static isHeadingToLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    static isHoldLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    static isManualDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    static isDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    static getTerminatorIcao(leg) {
      switch (leg.type) {
        case LegType.IF:
        case LegType.TF:
        case LegType.DF:
        case LegType.CF:
        case LegType.AF:
        case LegType.RF:
        case LegType.HA:
        case LegType.HF:
        case LegType.HM:
          return leg.fixIcao;
        default:
          return void 0;
      }
    }
  };
  FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
  FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
  FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
  FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
  FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];
  var FlightPathAirplaneSpeedMode;
  (function(FlightPathAirplaneSpeedMode2) {
    FlightPathAirplaneSpeedMode2["Default"] = "Default";
    FlightPathAirplaneSpeedMode2["GroundSpeed"] = "GroundSpeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeed"] = "TrueAirspeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
  })(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
  var LegEventType;
  (function(LegEventType2) {
    LegEventType2["Added"] = "Added";
    LegEventType2["Removed"] = "Removed";
    LegEventType2["Changed"] = "Changed";
  })(LegEventType || (LegEventType = {}));
  var SegmentEventType;
  (function(SegmentEventType2) {
    SegmentEventType2["Added"] = "Added";
    SegmentEventType2["Removed"] = "Removed";
    SegmentEventType2["Changed"] = "Changed";
    SegmentEventType2["Inserted"] = "Inserted";
  })(SegmentEventType || (SegmentEventType = {}));
  var ActiveLegType;
  (function(ActiveLegType2) {
    ActiveLegType2["Lateral"] = "Lateral";
    ActiveLegType2["Vertical"] = "Vertical";
    ActiveLegType2["Calculating"] = "Calculating";
  })(ActiveLegType || (ActiveLegType = {}));
  var OriginDestChangeType;
  (function(OriginDestChangeType2) {
    OriginDestChangeType2["OriginAdded"] = "OriginAdded";
    OriginDestChangeType2["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType2["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType2["DestinationRemoved"] = "DestinationRemoved";
  })(OriginDestChangeType || (OriginDestChangeType = {}));
  var FlightPlan = class {
    constructor(planIndex, calculator, onLegNameRequested) {
      this.planIndex = planIndex;
      this.calculator = calculator;
      this.onLegNameRequested = onLegNameRequested;
      this._activeLateralLeg = 0;
      this._activeVerticalLeg = 0;
      this._activeCalculatingLeg = 0;
      this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
      this.events = {};
      this.procedureDetails = new ProcedureDetails();
      this.planSegments = [];
      this.userData = {};
    }
    get originAirport() {
      return this._originAirport;
    }
    get destinationAirport() {
      return this._destinationAirport;
    }
    get activeLateralLeg() {
      return this._activeLateralLeg;
    }
    get activeVerticalLeg() {
      return this._activeVerticalLeg;
    }
    get activeCalculatingLeg() {
      return this._activeCalculatingLeg;
    }
    get length() {
      const segment = this.planSegments[this.planSegments.length - 1];
      if (segment !== void 0) {
        return segment.offset + segment.legs.length;
      }
      return 0;
    }
    get segmentCount() {
      return this.planSegments.length;
    }
    legs(reverse = false, startIndex, endIndex) {
      return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    *_legs(startIndex = 0, endIndex = this.length) {
      endIndex = Math.min(this.length, endIndex);
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.min(segment.legs.length, endIndex - segment.offset);
          if (end <= 0) {
            return;
          }
          for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
            yield segment.legs[l];
          }
        }
      }
    }
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
      endIndex = Math.max(-1, endIndex);
      for (let i = this.planSegments.length - 1; i > -1; i--) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.max(-1, endIndex - segment.offset);
          if (end >= segment.legs.length) {
            return;
          }
          for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
            yield segment.legs[l];
          }
        }
      }
    }
    *segments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0) {
          yield segment;
        }
      }
    }
    *segmentsOfType(segmentType) {
      for (const segment of this.segments()) {
        if (segment.segmentType == segmentType) {
          yield segment;
        }
      }
    }
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
      this.planSegments[segmentIndex] = segment;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
      return segment;
    }
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segment !== void 0) {
        const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments.splice(segmentIndex, 0, newSegment);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
        return newSegment;
      } else {
        return this.addSegment(segmentIndex, segmentType, airway, notify);
      }
    }
    reflowSegments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.segmentIndex !== i) {
          segment.segmentIndex = i;
        }
      }
    }
    deleteSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segmentIndex === this.planSegments.length - 1) {
        this.planSegments.splice(segmentIndex, 1);
      } else {
        delete this.planSegments[segmentIndex];
      }
      if (this.directToData.segmentIndex === segmentIndex)
        ;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    removeSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      this.planSegments.splice(segmentIndex, 1);
      this.reflowSegments();
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    getSegment(segmentIndex) {
      const segment = this.tryGetSegment(segmentIndex);
      if (segment === null) {
        throw new Error(`Flight plan segment with ${segmentIndex === void 0 ? "active leg" : `segment index ${segmentIndex}`} could not be found.`);
      } else {
        return segment;
      }
    }
    tryGetSegment(segmentIndex) {
      if (segmentIndex === void 0) {
        let calculatedSegmentIndex = 0;
        for (const segment2 of this.segments()) {
          if (this.activeLateralLeg == 0 && segment2.legs.length == 0) {
            calculatedSegmentIndex++;
          } else if (this.activeLateralLeg > segment2.offset + segment2.legs.length) {
            calculatedSegmentIndex++;
          } else {
            break;
          }
        }
        const segment = this.planSegments[calculatedSegmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      } else if (segmentIndex >= 0) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      }
      return null;
    }
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
      const segment = this.getSegment(segmentIndex);
      const legDefinition = {
        name: this.onLegNameRequested(leg),
        leg,
        flags,
        verticalData: {
          phase: VerticalFlightPhase.Descent,
          altDesc: AltitudeRestrictionType.Unused,
          altitude1: 0,
          altitude2: 0,
          displayAltitude1AsFlightLevel: false,
          displayAltitude2AsFlightLevel: false,
          speedDesc: SpeedRestrictionType.Unused,
          speed: 0,
          speedUnit: SpeedUnit.IAS
        }
      };
      if (segmentLegIndex === void 0) {
        segment.legs.push(legDefinition);
        segmentLegIndex = segment.legs.length - 1;
      } else {
        segment.legs.splice(segmentLegIndex, 0, legDefinition);
      }
      this.reflowSegmentOffsets();
      notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
      return legDefinition;
    }
    getLeg(arg1, arg2) {
      const leg = this._tryGetLeg(arg1, arg2);
      if (leg) {
        return leg;
      }
      throw new Error(`Leg with ${arg2 === void 0 ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    tryGetLeg(arg1, arg2) {
      return this._tryGetLeg(arg1, arg2);
    }
    _tryGetLeg(arg1, arg2) {
      var _a, _b;
      if (arg2 === void 0) {
        const legIndex = arg1;
        for (const segment of this.segments()) {
          if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
            return segment.legs[legIndex - segment.offset];
          }
        }
        return null;
      } else {
        const segmentIndex = arg1;
        const segmentLegIndex = arg2;
        return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
      }
    }
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
      const segment = this.getSegment(segmentIndex);
      let legDefinition;
      if (segmentLegIndex === void 0) {
        legDefinition = segment.legs.pop();
        segmentLegIndex = segment.legs.length;
      } else {
        const deleted = segment.legs.splice(segmentLegIndex, 1);
        legDefinition = deleted[0];
      }
      if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex)
        ;
      this.reflowSegmentOffsets();
      notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
      return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    async calculate(globalLegIndex, notify = true) {
      const legs = [...this.legs()];
      await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === void 0 ? this.activeCalculatingLeg : globalLegIndex);
      notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    setOriginAirport(facilityIcao, notify = true) {
      this._originAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    removeOriginAirport(notify = true) {
      const facilityIcao = this._originAirport;
      this._originAirport = void 0;
      this.procedureDetails.departureIndex = -1;
      this.procedureDetails.departureRunwayIndex = -1;
      this.procedureDetails.departureTransitionIndex = -1;
      this.procedureDetails.originRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    setDestinationAirport(facilityIcao, notify = true) {
      this._destinationAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    removeDestinationAirport(notify = true) {
      const facilityIcao = this._destinationAirport;
      this._destinationAirport = void 0;
      this.procedureDetails.approachIndex = -1;
      this.procedureDetails.approachTransitionIndex = -1;
      this.procedureDetails.arrivalIndex = -1;
      this.procedureDetails.arrivalRunwayTransitionIndex = -1;
      this.procedureDetails.arrivalRunway = void 0;
      this.procedureDetails.arrivalTransitionIndex = -1;
      this.procedureDetails.destinationRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    setLateralLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeLateralLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    setVerticalLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeVerticalLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    setCalculatingLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeCalculatingLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    setProcedureDetails(details, notify = true) {
      for (const key of Object.keys(this.procedureDetails)) {
        this.procedureDetails[key] = details[key];
      }
      notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    getLegIndexFromLeg(leg) {
      let index = 0;
      for (const toCompare of this.legs()) {
        if (toCompare === leg) {
          return index;
        }
        index++;
      }
      return -1;
    }
    getSegmentFromLeg(leg) {
      for (const segment of this.segments()) {
        if (segment.legs.includes(leg)) {
          return segment;
        }
      }
      return null;
    }
    getSegmentIndex(globalLegIndex) {
      for (const segment of this.segments()) {
        if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.segmentIndex;
        }
      }
      return -1;
    }
    getSegmentLegIndex(globalLegIndex) {
      const segmentIndex = this.getSegmentIndex(globalLegIndex);
      if (segmentIndex === -1) {
        return -1;
      }
      return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    getPrevLeg(segmentIndex, legIndex) {
      var _a, _b;
      if (segmentIndex < 0) {
        return null;
      }
      segmentIndex = Math.min(segmentIndex, this.planSegments.length);
      legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
      while (!leg && --segmentIndex >= 0) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[segment.legs.length - 1];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    getNextLeg(segmentIndex, legIndex) {
      if (segmentIndex >= this.planSegments.length) {
        return null;
      }
      segmentIndex = Math.max(segmentIndex, -1);
      legIndex = Math.max(legIndex, -1);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
      while (!leg && ++segmentIndex < this.planSegments.length) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[0];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    setDirectToData(arg1, arg2, arg3) {
      if (typeof arg1 !== "number") {
        arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
      }
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let notify = true;
      if (typeof arg2 !== "number") {
        const globalLegIndex = arg1;
        if (globalLegIndex >= 0) {
          segmentIndex = this.getSegmentIndex(globalLegIndex);
          if (segmentIndex >= 0) {
            segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
          }
        }
        notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
      }
      this.directToData.segmentIndex = segmentIndex;
      this.directToData.segmentLegIndex = segmentLegIndex;
      notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    setLegVerticalData(arg1, arg2, arg3, arg4) {
      let notify = true;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let verticalData;
      if (typeof arg2 !== "number") {
        segmentIndex = this.getSegmentIndex(arg1);
        const segment = this.getSegment(segmentIndex);
        segmentLegIndex = arg1 - segment.offset;
        verticalData = arg2;
        notify = arg3 !== void 0 ? arg3 : notify;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        verticalData = arg3;
        notify = arg4 !== void 0 ? arg4 : notify;
      }
      const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
      if (leg) {
        Object.assign(leg.verticalData, verticalData);
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
      } else {
        console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
      }
    }
    setAirway(segmentIndex, airway, notify = true) {
      const segment = this.getSegment(segmentIndex);
      if (!airway) {
        segment.airway = void 0;
      } else {
        segment.airway = airway;
      }
      this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    setUserData(key, data, notify = true) {
      this.userData[key] = data;
      this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    deleteUserData(key, notify = true) {
      if (this.userData[key] !== void 0) {
        delete this.userData[key];
      }
      this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    getUserData(key) {
      return this.userData[key];
    }
    reflowSegmentOffsets() {
      let nextOffset = void 0;
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment) {
          if (nextOffset === void 0) {
            segment.offset = 0;
          } else {
            segment.offset = nextOffset;
          }
          nextOffset = segment.legs.length + segment.offset;
        }
      }
    }
    setOriginRunway(runway = void 0, notify = true) {
      this.procedureDetails.originRunway = runway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setDestinationRunway(runway = void 0, notify = true) {
      this.procedureDetails.destinationRunway = runway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setDeparture(facilityIcao = void 0, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
      this.procedureDetails.departureIndex = departureIndex;
      this.procedureDetails.departureFacilityIcao = facilityIcao;
      this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
      this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setArrival(facilityIcao = void 0, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = void 0, notify = true) {
      this.procedureDetails.arrivalIndex = arrivalIndex;
      this.procedureDetails.arrivalFacilityIcao = facilityIcao;
      this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
      this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
      this.procedureDetails.arrivalRunway = arrivalRunway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setApproach(facilityIcao = void 0, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachFacilityIcao = facilityIcao;
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    copy(planIndex, copyCalcs = false) {
      if (planIndex === void 0) {
        planIndex = this.planIndex;
      }
      const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
      newPlan.setProcedureDetails(this.procedureDetails, false);
      newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
      for (const segment of this.segments()) {
        newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
        for (const leg of segment.legs) {
          const newLeg = newPlan.addLeg(segment.segmentIndex, leg.leg, void 0, leg.flags, false);
          const legIndex = newPlan.getLegIndexFromLeg(newLeg);
          newPlan.setLegVerticalData(legIndex, leg.verticalData);
          copyCalcs && this.copyLegCalculations(leg, newLeg);
        }
      }
      if (this.originAirport !== void 0) {
        newPlan.setOriginAirport(this.originAirport, false);
      }
      if (this.destinationAirport !== void 0) {
        newPlan.setDestinationAirport(this.destinationAirport, false);
      }
      newPlan.setLateralLeg(this.activeLateralLeg);
      newPlan.setVerticalLeg(this.activeVerticalLeg);
      newPlan.setCalculatingLeg(this.activeCalculatingLeg);
      for (const key in this.userData) {
        newPlan.setUserData(key, this.userData[key], false);
      }
      return newPlan;
    }
    copyLegCalculations(existingLeg, newLeg) {
      if (existingLeg.calculated !== void 0) {
        newLeg.calculated = {
          courseMagVar: existingLeg.calculated.courseMagVar,
          initialDtk: existingLeg.calculated.initialDtk,
          distance: existingLeg.calculated.distance,
          cumulativeDistance: existingLeg.calculated.cumulativeDistance,
          distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
          cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
          startLat: existingLeg.calculated.startLat,
          startLon: existingLeg.calculated.startLon,
          endLat: existingLeg.calculated.endLat,
          endLon: existingLeg.calculated.endLon,
          flightPath: existingLeg.calculated.flightPath.map((vector) => Object.assign({}, vector)),
          ingress: existingLeg.calculated.ingress.map((vector) => Object.assign({}, vector)),
          ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
          ingressToEgress: existingLeg.calculated.ingressToEgress.map((vector) => Object.assign({}, vector)),
          egressJoinIndex: existingLeg.calculated.egressJoinIndex,
          egress: existingLeg.calculated.egress.map((vector) => Object.assign({}, vector)),
          endsInFallback: existingLeg.calculated.endsInFallback
        };
      }
      return newLeg;
    }
  };
  FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
  }, partial);
  var SubEvent = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    on(handler, paused = false) {
      const sub = new HandlerSubscription(handler, void 0, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      }
      return sub;
    }
    off(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    clear() {
      this.notifyDepth++;
      for (let i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }
      this.notifyDepth--;
      if (this.notifyDepth === 0) {
        this.subs.length = 0;
      }
    }
    notify(sender, data) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(sender, data);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`SubEvent: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
  };
  var WaypointTypes;
  (function(WaypointTypes2) {
    WaypointTypes2["Custom"] = "Custom";
    WaypointTypes2["Airport"] = "Airport";
    WaypointTypes2["NDB"] = "NDB";
    WaypointTypes2["VOR"] = "VOR";
    WaypointTypes2["Intersection"] = "Intersection";
    WaypointTypes2["Runway"] = "Runway";
    WaypointTypes2["User"] = "User";
    WaypointTypes2["Visual"] = "Visual";
    WaypointTypes2["FlightPlan"] = "FlightPlan";
    WaypointTypes2["VNAV"] = "VNAV";
  })(WaypointTypes || (WaypointTypes = {}));
  var AbstractWaypoint = class {
    equals(other) {
      return this.uid === other.uid;
    }
  };
  var BasicFacilityWaypoint = class extends AbstractWaypoint {
    constructor(facility, bus) {
      super();
      this.bus = bus;
      this.isFacilityWaypoint = true;
      this._facility = Subject.create(facility);
      this._location = GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat, facility.lon));
      this._type = BasicFacilityWaypoint.getType(facility);
      const facType = ICAO.getFacilityType(facility.icao);
      if (facType === FacilityType.VIS || facType === FacilityType.USR) {
        this.facChangeSub = this.bus.getSubscriber().on(`facility_changed_${facility.icao}`).handle((newFacility) => {
          this._facility.set(newFacility);
          this._location.set(newFacility.lat, newFacility.lon);
        });
      }
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this.facility.get().icao;
    }
    get type() {
      return this._type;
    }
    get facility() {
      return this._facility;
    }
    static getType(facility) {
      switch (ICAO.getFacilityType(facility.icao)) {
        case FacilityType.Airport:
          return WaypointTypes.Airport;
        case FacilityType.Intersection:
          return WaypointTypes.Intersection;
        case FacilityType.NDB:
          return WaypointTypes.NDB;
        case FacilityType.RWY:
          return WaypointTypes.Runway;
        case FacilityType.USR:
          return WaypointTypes.User;
        case FacilityType.VIS:
          return WaypointTypes.Visual;
        case FacilityType.VOR:
          return WaypointTypes.VOR;
        default:
          return WaypointTypes.User;
      }
    }
  };
  var FacilityWaypointUtils = class {
    static isFacilityWaypoint(waypoint, facilityType) {
      if (waypoint.isFacilityWaypoint !== true) {
        return false;
      }
      return facilityType === void 0 || FacilityUtils.isFacilityType(waypoint.facility.get(), facilityType);
    }
  };
  var FlightPathWaypoint = class extends AbstractWaypoint {
    constructor(arg1, arg2, arg3, arg4, arg5) {
      super();
      if (typeof arg1 === "number") {
        this._location = GeoPointSubject.create(new GeoPoint(arg1, arg2));
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg4}`;
        this.leg = arg3;
        this.ident = arg5;
      } else {
        this._location = arg1;
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg3}`;
        this.leg = arg2;
        this.ident = arg4;
      }
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this._uid;
    }
    get type() {
      return WaypointTypes.FlightPlan;
    }
  };
  FlightPathWaypoint.UID_PREFIX = "FLPTH";
  var VNavWaypoint = class extends AbstractWaypoint {
    constructor(leg, distanceFromEnd, uid, ident) {
      super();
      this.ident = ident;
      this._uid = uid;
      this._location = GeoPointSubject.create(this.getWaypointLocation(leg, distanceFromEnd, new GeoPoint(0, 0)));
    }
    get type() {
      return WaypointTypes.VNAV;
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this._uid;
    }
    setLocation(leg, distanceFromEnd) {
      this._location.set(this.getWaypointLocation(leg, distanceFromEnd, VNavWaypoint.geoPointCache[0]));
    }
    getWaypointLocation(leg, distanceFromEnd, out) {
      var _a, _b;
      if (leg.calculated !== void 0) {
        const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
        let vectorIndex = vectors.length - 1;
        while (vectorIndex >= 0) {
          const vector = vectors[vectorIndex];
          const vectorDistance = vector.distance;
          if (vectorDistance >= distanceFromEnd) {
            const end = GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, VNavWaypoint.vec3Cache[0]);
            return FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]).offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out, Math.PI);
          } else {
            distanceFromEnd -= vectorDistance;
          }
          vectorIndex--;
        }
        if (vectors.length > 0) {
          out.set(vectors[0].startLat, vectors[0].startLon);
        } else {
          out.set((_a = leg.calculated.endLat) !== null && _a !== void 0 ? _a : 0, (_b = leg.calculated.endLon) !== null && _b !== void 0 ? _b : 0);
        }
      }
      return out;
    }
  };
  VNavWaypoint.vec3Cache = [new Float64Array(3)];
  VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
  VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var DefaultFacilityWaypointCache = class {
    constructor(bus, size) {
      this.bus = bus;
      this.size = size;
      this.cache = /* @__PURE__ */ new Map();
    }
    get(facility) {
      const key = DefaultFacilityWaypointCache.getFacilityKey(facility);
      let existing = this.cache.get(key);
      if (!existing) {
        existing = new BasicFacilityWaypoint(facility, this.bus);
        this.addToCache(key, existing);
      }
      return existing;
    }
    addToCache(key, waypoint) {
      this.cache.set(key, waypoint);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    static getCache(bus) {
      var _a;
      return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(bus, 1e3);
    }
    static getFacilityKey(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection) && ICAO.getFacilityType(facility.icao) !== FacilityType.Intersection) {
        return `mismatch.${facility.icao}`;
      }
      return facility.icao;
    }
  };
  var DefaultLodBoundaryCache = class {
    static getCache() {
      var _a;
      return (_a = DefaultLodBoundaryCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultLodBoundaryCache.INSTANCE = new LodBoundaryCache(DefaultLodBoundaryCache.SIZE, DefaultLodBoundaryCache.DISTANCE_THRESHOLDS, DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS);
    }
  };
  DefaultLodBoundaryCache.SIZE = 500;
  DefaultLodBoundaryCache.DISTANCE_THRESHOLDS = [0, 3e-5, 1e-4, 3e-4];
  DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS = [500, 300, 200, 100];
  var SubscribableMapFunctions = class {
    static identity() {
      return (input) => input;
    }
    static not() {
      return (input) => !input;
    }
    static negate() {
      return (input) => -input;
    }
    static abs() {
      return Math.abs;
    }
    static withPrecision(precision) {
      return SubscribableUtils.isSubscribable(precision) ? (input) => {
        const precisionVal = precision.get();
        return Math.round(input / precisionVal) * precisionVal;
      } : (input) => {
        return Math.round(input / precision) * precision;
      };
    }
    static changedBy(threshold) {
      return SubscribableUtils.isSubscribable(threshold) ? (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal : (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    static atFrequency(freq, timeFunc = Date.now) {
      let t0;
      let timeRemaining = 0;
      if (SubscribableUtils.isSubscribable(freq)) {
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            const period = 1e3 / freq.get();
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      } else {
        const period = 1e3 / freq;
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      }
    }
  };
  var MappedSubject = class extends AbstractSubscribable {
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
      super();
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      this.inputs = inputs;
      this.inputValues = inputs.map((input) => input.get());
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.inputValues, void 0));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.inputValues, void 0);
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSubs = this.inputs.map((input, index) => input.sub((inputValue) => {
        this.inputValues[index] = inputValue;
        this.updateValue();
      }));
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    static create(...args) {
      let mapFunc, equalityFunc, mutateFunc, initialVal;
      if (typeof args[0] === "function") {
        mapFunc = args.shift();
        if (typeof args[0] === "function") {
          equalityFunc = args.shift();
        } else {
          equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
        }
        if (typeof args[0] === "function") {
          mutateFunc = args.shift();
          initialVal = args.shift();
        }
      } else {
        mapFunc = MappedSubject.IDENTITY_MAP;
        equalityFunc = MappedSubject.NEVER_EQUALS;
      }
      return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    updateValue() {
      const value = this.mapFunc(this.inputValues, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    get() {
      return this.value;
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot pause a dead subject");
      }
      if (this._isPaused) {
        return this;
      }
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].pause();
      }
      this._isPaused = true;
      return this;
    }
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot resume a dead subject");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputValues[i] = this.inputs[i].get();
        this.inputSubs[i].resume();
      }
      this.updateValue();
      return this;
    }
    destroy() {
      this._isAlive = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].destroy();
      }
    }
  };
  MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
  MappedSubject.NEVER_EQUALS = () => false;
  var SubscribableSetEventType;
  (function(SubscribableSetEventType2) {
    SubscribableSetEventType2["Added"] = "Added";
    SubscribableSetEventType2["Deleted"] = "Deleted";
  })(SubscribableSetEventType || (SubscribableSetEventType = {}));
  var ArraySubject = class extends AbstractSubscribableArray {
    constructor(arr) {
      super();
      this.array = arr;
    }
    get length() {
      return this.array.length;
    }
    static create(arr = []) {
      return new ArraySubject(arr);
    }
    insert(item, index) {
      if (index === void 0 || index > this.array.length - 1) {
        index = this.array.length;
        this.array.push(item);
      } else {
        this.array.splice(index, 0, item);
      }
      this.notify(index, SubscribableArrayEventType.Added, item);
    }
    insertRange(index = 0, arr) {
      this.array.splice(index, 0, ...arr);
      this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    removeAt(index) {
      const removedItem = this.array.splice(index, 1);
      this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    removeItem(item) {
      const index = this.array.indexOf(item);
      if (index > -1) {
        this.removeAt(index);
        return true;
      } else {
        return false;
      }
    }
    set(arr) {
      this.clear();
      this.insertRange(0, arr);
    }
    clear() {
      this.array.length = 0;
      this.notify(0, SubscribableArrayEventType.Cleared);
    }
    getArray() {
      return this.array;
    }
  };
  var ObjectSubject = class {
    constructor(obj) {
      this.obj = obj;
      this.isSubscribable = true;
      this.isMutableSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    static create(v) {
      return new ObjectSubject(v);
    }
    get() {
      return this.obj;
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    set(arg1, value) {
      if (typeof arg1 === "object") {
        for (const prop in arg1) {
          if (prop in this.obj) {
            this.set(prop, arg1[prop]);
          }
        }
      } else {
        const oldValue = this.obj[arg1];
        if (value !== oldValue) {
          this.obj[arg1] = value;
          this.notify(arg1, oldValue);
        }
      }
    }
    notify(key, oldValue) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(this.obj, key, this.obj[key], oldValue);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ObjectSubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    initialNotify(sub) {
      for (const key in this.obj) {
        const v = this.obj[key];
        sub.handler(this.obj, key, v, v);
      }
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    map(fn, equalityFunc, mutateFunc, initialVal) {
      const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
      return mutateFunc ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this) : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  var NearestContext = class {
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this.airports = new NearestAirportSubscription(facilityLoader);
      this.vors = new NearestVorSubscription(facilityLoader);
      this.intersections = new NearestIntersectionSubscription(facilityLoader);
      this.ndbs = new NearestNdbSubscription(facilityLoader);
      this.usrs = new NearestUsrSubscription(facilityLoader);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("NearestContext was not initialized.");
    }
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new NearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("NearestContext was already initialized.");
      }
    }
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    getRegionCode() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region;
        }
      }
      return void 0;
    }
    getRegionIdent() {
      const region = this.getRegionCode();
      if (region !== void 0) {
        return region[0] === "K" ? "K" : region;
      }
      return void 0;
    }
    getRegionLetter() {
      const region = this.getRegionCode();
      return region !== void 0 ? region[0] : void 0;
    }
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  NearestContext.initializedSubEvent = new SubEvent();
  var AdaptiveNearestContext = class {
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this._maxAirportsAbsolute = Subject.create(100);
      this._maxVorsAbsolute = Subject.create(100);
      this._maxIntersectionsAbsolute = Subject.create(100);
      this._maxNdbsAbsolute = Subject.create(100);
      this._maxUsrsAbsolute = Subject.create(100);
      this.airports = new AdaptiveNearestSubscription(new NearestAirportSubscription(facilityLoader), this._maxAirportsAbsolute);
      this.vors = new AdaptiveNearestSubscription(new NearestVorSubscription(facilityLoader), this._maxVorsAbsolute);
      this.intersections = new AdaptiveNearestSubscription(new NearestIntersectionSubscription(facilityLoader), this._maxIntersectionsAbsolute);
      this.ndbs = new AdaptiveNearestSubscription(new NearestNdbSubscription(facilityLoader), this._maxNdbsAbsolute);
      this.usrs = new AdaptiveNearestSubscription(new NearestUsrSubscription(facilityLoader), this._maxUsrsAbsolute);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    get maxAirportsAbsolute() {
      return this._maxAirportsAbsolute.get();
    }
    set maxAirportsAbsolute(val) {
      this._maxAirportsAbsolute.set(val);
    }
    get maxVorsAbsolute() {
      return this._maxVorsAbsolute.get();
    }
    set maxVorsAbsolute(val) {
      this._maxVorsAbsolute.set(val);
    }
    get maxIntersectionsAbsolute() {
      return this._maxIntersectionsAbsolute.get();
    }
    set maxIntersectionsAbsolute(val) {
      this._maxIntersectionsAbsolute.set(val);
    }
    get maxNdbsAbsolute() {
      return this._maxNdbsAbsolute.get();
    }
    set maxNdbsAbsolute(val) {
      this._maxNdbsAbsolute.set(val);
    }
    get maxUsrsAbsolute() {
      return this._maxUsrsAbsolute.get();
    }
    set maxUsrsAbsolute(val) {
      this._maxUsrsAbsolute.set(val);
    }
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("AdaptiveNearestContext was not initialized.");
    }
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new AdaptiveNearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("AdaptiveNearestContext was already initialized.");
      }
    }
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    getRegionLetter() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region[0];
        }
      }
      return void 0;
    }
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  AdaptiveNearestContext.initializedSubEvent = new SubEvent();
  var IcaoSearchFilter;
  (function(IcaoSearchFilter2) {
    IcaoSearchFilter2[IcaoSearchFilter2["ALL"] = 0] = "ALL";
    IcaoSearchFilter2[IcaoSearchFilter2["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter2[IcaoSearchFilter2["VOR"] = 2] = "VOR";
    IcaoSearchFilter2[IcaoSearchFilter2["NDB"] = 3] = "NDB";
    IcaoSearchFilter2[IcaoSearchFilter2["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter2[IcaoSearchFilter2["USR"] = 5] = "USR";
  })(IcaoSearchFilter || (IcaoSearchFilter = {}));
  var ElectricalPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(ElectricalPublisher.simvars, bus, pacer);
      this.flightStarted = false;
      this.avBusList = ["elec_av1_bus", "elec_av2_bus"];
      for (const topic of this.avBusList) {
        if (bus.getTopicSubscriberCount(topic)) {
          this.subscribed.add(topic);
        }
      }
      bus.getSubscriber().on("event_bus_topic_first_sub").handle((event) => {
        if (this.avBusList.includes(event)) {
          this.subscribed.add(event);
        }
      });
      const gameStateSub = GameStateProvider.get().sub((state) => {
        if (state === GameState.briefing || state === GameState.ingame) {
          gameStateSub.destroy();
          this.flightStarted = true;
        }
      }, false, true);
      gameStateSub.resume(true);
    }
    onUpdate() {
      if (this.flightStarted) {
        super.onUpdate();
        if (this.av1BusLogic && this.subscribed.has("elec_av1_bus")) {
          this.publish("elec_av1_bus", this.av1BusLogic.getValue() !== 0);
        }
        if (this.av2BusLogic && this.subscribed.has("elec_av2_bus")) {
          this.publish("elec_av2_bus", this.av2BusLogic.getValue() !== 0);
        }
      }
    }
    setAv1Bus(logicElement) {
      this.av1BusLogic = logicElement;
    }
    setAv2Bus(logicElement) {
      this.av2BusLogic = logicElement;
    }
  };
  ElectricalPublisher.simvars = /* @__PURE__ */ new Map([
    ["elec_master_battery", { name: "ELECTRICAL MASTER BATTERY", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_1", { name: "CIRCUIT AVIONICS ON:1", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_2", { name: "CIRCUIT AVIONICS ON:2", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom1_on", { name: "CIRCUIT NAVCOM1 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom2_on", { name: "CIRCUIT NAVCOM2 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom3_on", { name: "CIRCUIT NAVCOM3 ON", type: SimVarValueType.Bool }],
    ["elec_bus_main_v", { name: "ELECTRICAL MAIN BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_main_a", { name: "ELECTRICAL MAIN BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_avionics_v", { name: "ELECTRICAL AVIONICS BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_avionics_a", { name: "ELECTRICAL AVIONICS BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_1_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_2_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:2", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_1_a", { name: "ELECTRICAL GENALT BUS AMPS:1", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_2_a", { name: "ELECTRICAL GENALT BUS AMPS:2", type: SimVarValueType.Amps }],
    ["elec_bat_a_1", { name: "ELECTRICAL BATTERY LOAD:1", type: SimVarValueType.Amps }],
    ["elec_bat_v_1", { name: "ELECTRICAL BATTERY VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bat_a_2", { name: "ELECTRICAL BATTERY LOAD:2", type: SimVarValueType.Amps }],
    ["elec_bat_v_2", { name: "ELECTRICAL BATTERY VOLTAGE:2", type: SimVarValueType.Volts }]
  ]);
  var FlightTimerMode;
  (function(FlightTimerMode2) {
    FlightTimerMode2[FlightTimerMode2["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode2[FlightTimerMode2["CountingUp"] = 1] = "CountingUp";
  })(FlightTimerMode || (FlightTimerMode = {}));
  var SBASGroupName;
  (function(SBASGroupName2) {
    SBASGroupName2["WAAS"] = "WAAS";
    SBASGroupName2["EGNOS"] = "EGNOS";
    SBASGroupName2["GAGAN"] = "GAGAN";
    SBASGroupName2["MSAS"] = "MSAS";
  })(SBASGroupName || (SBASGroupName = {}));
  var GPSSatelliteState;
  (function(GPSSatelliteState2) {
    GPSSatelliteState2["None"] = "None";
    GPSSatelliteState2["Unreachable"] = "Unreachable";
    GPSSatelliteState2["Acquired"] = "Acquired";
    GPSSatelliteState2["Faulty"] = "Faulty";
    GPSSatelliteState2["DataCollected"] = "DataCollected";
    GPSSatelliteState2["InUse"] = "InUse";
    GPSSatelliteState2["InUseDiffApplied"] = "InUseDiffApplied";
  })(GPSSatelliteState || (GPSSatelliteState = {}));
  var GPSSystemState;
  (function(GPSSystemState2) {
    GPSSystemState2["Searching"] = "Searching";
    GPSSystemState2["Acquiring"] = "Acquiring";
    GPSSystemState2["SolutionAcquired"] = "SolutionAcquired";
    GPSSystemState2["DiffSolutionAcquired"] = "DiffSolutionAcquired";
  })(GPSSystemState || (GPSSystemState = {}));
  var GPSSystemSBASState;
  (function(GPSSystemSBASState2) {
    GPSSystemSBASState2["Disabled"] = "Disabled";
    GPSSystemSBASState2["Inactive"] = "Inactive";
    GPSSystemSBASState2["Active"] = "Active";
  })(GPSSystemSBASState || (GPSSystemSBASState = {}));
  var MinimumsMode;
  (function(MinimumsMode2) {
    MinimumsMode2[MinimumsMode2["OFF"] = 0] = "OFF";
    MinimumsMode2[MinimumsMode2["BARO"] = 1] = "BARO";
    MinimumsMode2[MinimumsMode2["RA"] = 2] = "RA";
    MinimumsMode2[MinimumsMode2["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
  })(MinimumsMode || (MinimumsMode = {}));
  var MinimumsSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(MinimumsSimVarPublisher.simvars, bus);
    }
  };
  MinimumsSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["decision_height_feet", { name: "DECISION HEIGHT", type: SimVarValueType.Feet }],
    ["decision_altitude_feet", { name: "DECISION ALTITUDE MSL", type: SimVarValueType.Feet }],
    ["minimums_mode", { name: "L:WT_MINIMUMS_MODE", type: SimVarValueType.Number }]
  ]);
  var NavComSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(NavComSimVarPublisher.simvars, bus, pacer);
    }
    static createNavRadioDefinitions(index) {
      return [
        [`nav_active_frequency_${index}`, { name: `NAV ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_standby_frequency_${index}`, { name: `NAV STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_sound_${index}`, { name: `NAV SOUND:${index}`, type: SimVarValueType.Bool }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_volume_${index}`, { name: `NAV VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    static createComRadioDefinitions(index) {
      return [
        [`com_active_frequency_${index}`, { name: `COM ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_standby_frequency_${index}`, { name: `COM STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_active_facility_name_${index}`, { name: `COM ACTIVE FREQ NAME:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_type_${index}`, { name: `COM ACTIVE FREQ TYPE:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_ident_${index}`, { name: `COM ACTIVE FREQ IDENT:${index}`, type: SimVarValueType.String }],
        [`com_receive_${index}`, { name: `COM RECEIVE EX1:${index}`, type: SimVarValueType.Bool }],
        [`com_status_${index}`, { name: `COM STATUS:${index}`, type: SimVarValueType.Number }],
        [`com_transmit_${index}`, { name: `COM TRANSMIT:${index}`, type: SimVarValueType.Bool }],
        [`com_spacing_mode_${index}`, { name: `COM SPACING MODE:${index}`, type: SimVarValueType.Enum }],
        [`com_volume_${index}`, { name: `COM VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_active_frequency_${index}`, { name: `ADF ACTIVE FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_standby_frequency_${index}`, { name: `ADF STANDBY FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_sound_${index}`, { name: `ADF SOUND:${index}`, type: SimVarValueType.Bool }],
        [`adf_volume_${index}`, { name: `ADF VOLUME:${index}`, type: SimVarValueType.Percent }],
        [`adf_ident_${index}`, { name: `ADF IDENT:${index}`, type: SimVarValueType.String }],
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }]
      ];
    }
  };
  NavComSimVarPublisher.simvars = new Map([
    ...NavComSimVarPublisher.createNavRadioDefinitions(1),
    ...NavComSimVarPublisher.createNavRadioDefinitions(2),
    ...NavComSimVarPublisher.createNavRadioDefinitions(3),
    ...NavComSimVarPublisher.createNavRadioDefinitions(4),
    ...NavComSimVarPublisher.createComRadioDefinitions(1),
    ...NavComSimVarPublisher.createComRadioDefinitions(2),
    ...NavComSimVarPublisher.createComRadioDefinitions(3),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(2),
    ["marker_beacon_hisense_on", { name: "MARKER BEACON SENSITIVITY HIGH", type: SimVarValueType.Bool }],
    ["marker_beacon_sound", { name: "MARKER SOUND", type: SimVarValueType.Bool }]
  ]);
  var PitotPublisher = class extends SimVarPublisher {
    constructor(bus, pitotCount, pacer) {
      const indexedSimVars = [
        ["pitot_heat_switch_on", { name: "PITOT HEAT SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(PitotPublisher.nonIndexedSimVars);
      for (const [topic, simvar2] of indexedSimVars) {
        for (let i = 1; i <= pitotCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  PitotPublisher.nonIndexedSimVars = [
    ["pitot_heat_on", { name: "PITOT HEAT", type: SimVarValueType.Bool }],
    ["pitot_icing_pct", { name: "PITOT ICE PCT", type: SimVarValueType.Percent }]
  ];
  var PressurizationPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(PressurizationPublisher.simvars, bus, pacer);
    }
    onUpdate() {
      super.onUpdate();
    }
  };
  PressurizationPublisher.simvars = /* @__PURE__ */ new Map([
    ["cabin_altitude", { name: "PRESSURIZATION CABIN ALTITUDE", type: SimVarValueType.Feet }],
    ["cabin_altitude_rate", { name: "PRESSURIZATION CABIN ALTITUDE RATE", type: SimVarValueType.FPM }],
    ["pressure_diff", { name: "PRESSURIZATION PRESSURE DIFFERENTIAL", type: SimVarValueType.PSI }]
  ]);
  var DebounceTimer = class {
    constructor() {
      this.timer = null;
    }
    isPending() {
      return this.timer !== null;
    }
    schedule(action, delay) {
      this.clear();
      this.timer = setTimeout(() => {
        this.timer = null;
        action();
      }, delay);
    }
    clear() {
      if (this.timer === null) {
        return;
      }
      clearTimeout(this.timer);
      this.timer = null;
    }
  };
  var XPDRMode;
  (function(XPDRMode2) {
    XPDRMode2[XPDRMode2["OFF"] = 0] = "OFF";
    XPDRMode2[XPDRMode2["STBY"] = 1] = "STBY";
    XPDRMode2[XPDRMode2["TEST"] = 2] = "TEST";
    XPDRMode2[XPDRMode2["ON"] = 3] = "ON";
    XPDRMode2[XPDRMode2["ALT"] = 4] = "ALT";
    XPDRMode2[XPDRMode2["GROUND"] = 5] = "GROUND";
  })(XPDRMode || (XPDRMode = {}));
  var Wait = class {
    static awaitDelay(delay) {
      return new Promise((resolve) => setTimeout(() => resolve(), delay));
    }
    static awaitCondition(predicate, interval = 0, timeout = 0) {
      const t0 = Date.now();
      if (interval <= 0) {
        const loopFunc = (resolve, reject) => {
          if (timeout > 0 && Date.now() - t0 >= timeout) {
            reject("Await condition timed out.");
          } else {
            predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(void 0, resolve, reject));
          }
        };
        return new Promise((resolve, reject) => {
          loopFunc(resolve, reject);
        });
      } else {
        return new Promise((resolve, reject) => {
          const timer = setInterval(() => {
            if (timeout > 0 && Date.now() - t0 > timeout) {
              clearInterval(timer);
              reject("Await condition timed out.");
            } else if (predicate()) {
              clearInterval(timer);
              resolve();
            }
          }, interval);
        });
      }
    }
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = subscribable.sub((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub.destroy();
            resolve(val);
          }
        }, false, true);
        sub.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = consumer.handle((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub.destroy();
            resolve(val);
          }
        }, true);
        sub.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    static awaitSubEvent(event, predicate, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = event.on((sender, data) => {
          if (predicate === void 0 || predicate(data, sender)) {
            sub.destroy();
            resolve(data);
          }
        }, true);
        sub.resume();
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
  };
  var TrafficContactClass = class {
    constructor(uid, contactTimeResetThreshold) {
      this.uid = uid;
      this.contactTimeResetThreshold = contactTimeResetThreshold;
      this._lastPosition = new GeoPoint(NaN, NaN);
      this.lastPosition = this._lastPosition.readonly;
      this._lastAltitude = UnitType.FOOT.createNumber(NaN);
      this.lastAltitude = this._lastAltitude.readonly;
      this._lastHeading = NaN;
      this._lastContactTime = NaN;
      this._groundSpeed = UnitType.KNOT.createNumber(NaN);
      this.groundSpeed = this._groundSpeed.readonly;
      this._groundTrack = NaN;
      this._verticalSpeed = UnitType.FPM.createNumber(NaN);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
    }
    get lastHeading() {
      return this._lastHeading;
    }
    get lastContactTime() {
      return this._lastContactTime;
    }
    get groundTrack() {
      return this._groundTrack;
    }
    predict(simTime, positionOut, altitudeOut) {
      if (this.groundSpeed.isNaN()) {
        positionOut.set(NaN, NaN);
        altitudeOut.set(NaN);
        return;
      }
      const dt = simTime - this.lastContactTime;
      const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 36e5), UnitType.GA_RADIAN);
      this._lastPosition.offset(this._groundTrack, distance, positionOut);
      const deltaAlt = this._verticalSpeed.number * (dt / 6e4);
      this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    update(lat, lon, altitude, heading, simTime) {
      const dt = simTime - this._lastContactTime;
      if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
        this.reset(lat, lon, altitude, heading, simTime);
        return;
      }
      if (!isNaN(dt) && dt > 0) {
        this.updateComputedValues(dt / 1e3, lat, lon, altitude);
      }
      this.setReportedValues(lat, lon, altitude, heading);
      if (this.areComputedValuesValid()) {
        this._lastContactTime = simTime;
      } else {
        this.reset(lat, lon, altitude, heading, simTime);
      }
    }
    reset(lat, lon, altitude, heading, simTime) {
      this.setReportedValues(lat, lon, altitude, heading);
      this._groundSpeed.set(NaN);
      this._groundTrack = NaN;
      this._verticalSpeed.set(NaN);
      this.groundSpeedSmoother.reset();
      this.groundTrackSmoother.reset();
      this.verticalSpeedSmoother.reset();
      this._lastContactTime = simTime;
    }
    setReportedValues(lat, lon, altitude, heading) {
      this._lastPosition.set(lat, lon);
      this._lastAltitude.set(altitude);
      this._lastHeading = heading;
    }
    updateComputedValues(dt, lat, lon, altitude) {
      const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
      const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
      const track = pos.bearingFrom(this._lastPosition);
      this.updateGroundSpeed(dt, distanceNM);
      this.updateGroundTrack(dt, track, distanceNM);
      this.updateVerticalSpeed(dt, altitude);
    }
    updateGroundSpeed(dt, distanceNM) {
      const dtHours = dt / 3600;
      const speedKnots = distanceNM / dtHours;
      this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    updateGroundTrack(dt, track, distanceNM) {
      const last = this.groundTrackSmoother.last();
      if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
        if (last !== null && !isNaN(last)) {
          let delta = track - last;
          if (delta > 180) {
            delta = delta - 360;
          } else if (delta < -180) {
            delta = delta + 360;
          }
          track = last + delta;
        }
      } else {
        track = last === null ? NaN : last;
      }
      const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
      this._groundTrack = (next + 360) % 360;
    }
    updateVerticalSpeed(dt, altitude) {
      const dtMin = dt / 60;
      const deltaAltFeet = altitude - this._lastAltitude.number;
      const vsFPM = deltaAltFeet / dtMin;
      this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    areComputedValuesValid() {
      const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
      const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
      return isGroundSpeedValid && isVerticalSpeedValid;
    }
  };
  TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500;
  TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 1e4;
  TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852;
  TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);
  var Easing = class {
    static linear() {
      return (x) => MathUtils.clamp(x, 0, 1);
    }
    static quad(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x;
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - (1 - x) * (1 - x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 2 * x * x : 1 - 2 * (1 - x) * (1 - x);
        default:
          throw new Error(`Easing.quad(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static cubic(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 4 * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 4 * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.cubic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static quart(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 8 * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 8 * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quart(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static quint(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 16 * x * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 16 * compl * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quint(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static polynomial(order, end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(x, order);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(1 - x, order);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2 * x, order) : 1 - 0.5 * Math.pow(2 * (1 - x), order);
        default:
          throw new Error(`Easing.polynomial(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static sin(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.cos(x * MathUtils.HALF_PI);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sin(x * MathUtils.HALF_PI);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : (1 - Math.cos(x * Math.PI)) * 0.5;
        default:
          throw new Error(`Easing.sin(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static circ(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.sqrt(1 - x * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sqrt(1 - (x - 1) * (x - 1));
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? (1 - Math.sqrt(1 - 4 * x * x)) * 0.5 : (Math.sqrt(1 - 4 * (1 - x) * (1 - x)) + 1) * 0.5;
        default:
          throw new Error(`Easing.circ(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static exp(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(2, 10 * (x - 1));
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(2, -10 * x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2, 20 * (x - 0.5)) : 1 - 0.5 * Math.pow(2, 20 * (0.5 - x));
        default:
          throw new Error(`Easing.exp(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static back(end) {
      const c1 = 2.70158;
      const c2 = 1.70158;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * x * x * x - c2 * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl + c2 * compl * compl;
            }
          };
        case "both": {
          const c3 = c2 * 1.525;
          const c4 = c3 + 1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 2 * (x * x * (2 * c4 * x - c3));
            } else {
              const compl = 1 - x;
              return 1 - 2 * compl * compl * (2 * c4 * compl - c3);
            }
          };
        }
        default:
          throw new Error(`Easing.back(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static elastic(end) {
      const c1 = MathUtils.TWO_PI / 3;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * Math.pow(2, 10 * (x - 1)) * Math.sin(10.75 - 10 * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - c1 * Math.pow(2, -10 * x) * Math.sin(0.75 - 10 * x);
        case "both": {
          const c2 = c1 * c1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 0.5 * Math.pow(2, 20 * (x - 0.5)) * Math.sin(c2 * (11.125 - 20 * x));
            } else {
              return 1 - 0.5 * Math.pow(2, 20 * (0.5 - x)) * Math.sin(c2 * (11.125 - 20 * x));
            }
          };
        }
        default:
          throw new Error(`Easing.elastic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static bezier(c1x, c1y, c2x, c2y, precompute = false, minXResolution, epsilon = 1e-3, maxDepth = 10) {
      c1x = MathUtils.clamp(c1x, 0, 1);
      c2x = MathUtils.clamp(c2x, 0, 1);
      if (precompute) {
        const minXRes = minXResolution !== null && minXResolution !== void 0 ? minXResolution : 0.1;
        const lookup = new LerpLookupTable(1);
        lookup.insertBreakpoint([0, 0]);
        lookup.insertBreakpoint([1, 1]);
        if (maxDepth > 0) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, 0, 0, 0, 1, 1, 1, 1);
        }
        return (x) => {
          return x <= 0 ? 0 : x >= 1 ? 1 : lookup.get(x);
        };
      } else {
        const minXRes = Math.max(minXResolution !== null && minXResolution !== void 0 ? minXResolution : 1e-4, 1e-6);
        return (x) => {
          if (x <= 0) {
            return 0;
          } else if (x >= 1) {
            return 1;
          }
          let t0 = 0, t1 = 1;
          let tquery = (t0 + t1) / 2;
          let xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          while (Math.abs(x - xquery) > minXRes) {
            if (x - xquery < 0) {
              t1 = tquery;
            } else {
              t0 = tquery;
            }
            tquery = (t0 + t1) / 2;
            xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          }
          return Easing.easingBezierFunc(tquery, c1y, c2y);
        };
      }
    }
    static precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, t1, x1, y1, depth) {
      const tmid = (t0 + t1) / 2;
      const xdelta = x1 - x0;
      const xmid = Easing.easingBezierFunc(tmid, c1x, c2x);
      const ymid = Easing.easingBezierFunc(tmid, c1y, c2y);
      const ylerp = MathUtils.lerp(xmid, x0, x1, y0, y1);
      let shouldContinue = false;
      shouldContinue = xdelta > minXRes || Math.abs(ylerp - ymid) > epsilon;
      if (shouldContinue) {
        lookup.insertBreakpoint([ymid, xmid]);
        if (depth < maxDepth) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, tmid, xmid, ymid, depth + 1);
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, tmid, xmid, ymid, t1, x1, y1, depth + 1);
        }
      }
    }
    static easingBezierFunc(t, c1, c2) {
      return 3 * (1 - t) * (1 - t) * t * c1 + 3 * (1 - t) * t * t * c2 + t * t * t;
    }
    static withEndpointParams(ease) {
      return (start, stop, progress) => {
        return start + (stop - start) * ease(progress);
      };
    }
    static withEndpoints(ease, start, stop) {
      const delta = stop - start;
      return (progress) => {
        return start + delta * ease(progress);
      };
    }
  };
  var Animator = class {
    constructor() {
      this._value = Subject.create(0);
      this._isAnimating = false;
      this.isAnimationLoopActive = false;
      this.animationEaseFunc = Animator.DEFAULT_EASE_FUNC;
      this.animationStart = 0;
      this.animationStop = 0;
      this.animationStartTime = 0;
      this.animationDuration = 0;
      this.animationLoop = () => {
        if (!this._isAnimating) {
          this.isAnimationLoopActive = false;
          return;
        }
        const progress = (Date.now() - this.animationStartTime) / this.animationDuration;
        if (progress < 1) {
          this._value.set(this.animationEaseFunc(this.animationStart, this.animationStop, progress));
          requestAnimationFrame(this.animationLoop);
        } else {
          this._isAnimating = false;
          this.isAnimationLoopActive = false;
          this._value.set(this.animationStop);
        }
      };
    }
    get value() {
      return this._value;
    }
    isAnimating() {
      return this._isAnimating;
    }
    start(target, duration, easeFunc) {
      if (duration <= 0) {
        this.set(target);
        return;
      }
      this._isAnimating = true;
      this.animationStart = this._value.get();
      this.animationStop = target;
      this.animationStartTime = Date.now();
      this.animationDuration = duration;
      this.animationEaseFunc = easeFunc !== null && easeFunc !== void 0 ? easeFunc : Animator.DEFAULT_EASE_FUNC;
      if (!this.isAnimationLoopActive) {
        this.isAnimationLoopActive = true;
        requestAnimationFrame(this.animationLoop);
      }
    }
    set(value) {
      this._isAnimating = false;
      this._value.set(value);
    }
    stop(setAnimationTarget = false) {
      if (!this._isAnimating) {
        return;
      }
      this._isAnimating = false;
      if (setAnimationTarget) {
        this._value.set(this.animationStop);
      }
    }
  };
  Animator.DEFAULT_EASE_FUNC = Easing.withEndpointParams(Easing.linear());
  var BacklightLevelController = class {
    constructor(bus, paused = false, minIntensity = BacklightLevelController.DEFAULT_MIN_INTENSITY, maxIntensity = BacklightLevelController.DEFAULT_MAX_INTENSITY) {
      this.simTime = ConsumerSubject.create(null, 0);
      this.ppos = new Float64Array(3);
      this.needRecalcAuto = true;
      this.lastSimTime = 0;
      this.paused = false;
      this._intensity = Subject.create(0);
      this.intensity = this._intensity;
      this._autoMinIntensity = minIntensity;
      this._autoMaxIntensity = maxIntensity;
      this._autoIntensityRange = this.autoMaxIntensity - this.autoMinIntensity;
      this.needRecalcAuto = true;
      const sub = bus.getSubscriber();
      this.simTime.setConsumer(sub.on("simTime"));
      this.pposSub = sub.on("gps-position").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onPPosChanged.bind(this));
      this.updateSub = sub.on("realTime").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));
      this.setPaused(paused);
    }
    get autoMaxIntensity() {
      return this._autoMaxIntensity;
    }
    set autoMaxIntensity(max_intensity) {
      this._autoMaxIntensity = max_intensity;
      this._autoIntensityRange = this._autoMaxIntensity - this._autoMinIntensity;
      this.needRecalcAuto = true;
    }
    get autoMinIntensity() {
      return this._autoMinIntensity;
    }
    set autoMinIntensity(min_intensity) {
      this._autoMinIntensity = min_intensity;
      this._autoIntensityRange = this._autoMinIntensity - min_intensity;
      this.needRecalcAuto = true;
    }
    setPaused(paused) {
      if (paused !== this.paused) {
        this.paused = paused;
        if (paused) {
          this.updateSub.pause();
          this.pposSub.pause();
          this.simTime.pause();
          this.needRecalcAuto = false;
        } else {
          this.needRecalcAuto = true;
          this.simTime.resume();
          this.pposSub.resume(true);
          this.updateSub.resume(true);
        }
      }
    }
    onPPosChanged(ppos) {
      const pposVec = GeoPoint.sphericalToCartesian(ppos.lat, ppos.long, BacklightLevelController.tempVec3);
      if (Vec3Math.dot(pposVec, this.ppos) >= 1 - 1e-4) {
        return;
      }
      Vec3Math.copy(pposVec, this.ppos);
      this.needRecalcAuto = true;
    }
    onUpdate() {
      const simTime = this.simTime.get();
      this.needRecalcAuto || (this.needRecalcAuto = Math.abs(simTime - this.lastSimTime) >= BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD);
      if (this.needRecalcAuto) {
        this.needRecalcAuto = false;
        this.updateAutoBacklightIntensity(simTime);
      }
    }
    updateAutoBacklightIntensity(simTime) {
      this.lastSimTime = simTime;
      const subSolarPoint = BacklightLevelController.calculateSubSolarPoint(simTime, BacklightLevelController.tempVec3);
      const sinSolarAngle = Vec3Math.dot(this.ppos, subSolarPoint);
      const sinSolarAngleClamped = Utils.Clamp(sinSolarAngle, BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN, BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN);
      const intensityFrac = (sinSolarAngleClamped - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN) / BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN;
      this._intensity.set(this._autoMinIntensity + intensityFrac * this._autoIntensityRange);
    }
    static calculateSubSolarPoint(time, out) {
      const PI2 = 2 * Math.PI;
      const days = (time - BacklightLevelController.EPOCH) / BacklightLevelController.DAY;
      const daysFrac = days - Math.floor(days);
      const L = 4.895055 + 0.01720279 * days;
      const g = 6.240041 + 0.01720197 * days;
      const lambda = L + 0.033423 * Math.sin(g) + 349e-6 * Math.sin(2 * g);
      const epsilon = 0.40910518 - 698e-11 * days;
      const rAscension = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
      const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
      const E = (((L - rAscension) % PI2 + 3 * Math.PI) % PI2 - Math.PI) * 0.159155;
      const lat = declination * Avionics.Utils.RAD2DEG;
      const lon = -15 * (daysFrac - 0.5 + E) * 24;
      return GeoPoint.sphericalToCartesian(lat, lon, out);
    }
  };
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE = 3;
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE = -8;
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MAX_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MIN_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN = BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN;
  BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ = 10;
  BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD = 6e4;
  BacklightLevelController.EPOCH = 9466848e5;
  BacklightLevelController.DAY = 864e5;
  BacklightLevelController.DEFAULT_MIN_INTENSITY = 0;
  BacklightLevelController.DEFAULT_MAX_INTENSITY = 1;
  BacklightLevelController.tempVec3 = new Float64Array(3);
  var LinearServo = class {
    constructor(rate) {
      this.rate = rate;
    }
    drive(currentValue, setValue) {
      if (this.currentTime === void 0) {
        this.currentTime = new Date().appTime();
        return currentValue;
      }
      const currentTime = new Date().appTime();
      const deltaTime = currentTime - this.currentTime;
      this.currentTime = currentTime;
      const deltaValue = setValue - currentValue;
      const maximumDrive = this.rate * (deltaTime / 1e3);
      const output = Math.abs(deltaValue) > maximumDrive ? currentValue + Math.sign(deltaValue) * maximumDrive : setValue;
      return output;
    }
    reset() {
      this.currentTime = void 0;
    }
  };
  var PidController = class {
    constructor(kP, kI, kD, maxOut, minOut, maxI = Number.MAX_SAFE_INTEGER, minI = Number.MIN_SAFE_INTEGER) {
      this.kP = kP;
      this.kI = kI;
      this.kD = kD;
      this.maxOut = maxOut;
      this.minOut = minOut;
      this.maxI = maxI;
      this.minI = minI;
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    getOutput(deltaTime, error) {
      var _a;
      const p = this.kP * error;
      if (this.previousError !== void 0 && Math.sign(error) === Math.sign(this.previousError)) {
        this.integral += (error * deltaTime + deltaTime * (error - this.previousError) / 2) * this.kI;
        this.integral = PidController.clamp(this.integral, this.maxI, this.minI);
      } else {
        this.integral = 0;
      }
      const i = this.integral;
      const d = this.kD * ((error - ((_a = this.previousError) !== null && _a !== void 0 ? _a : error)) / deltaTime);
      const output = PidController.clamp(p + i + d, this.maxOut, this.minOut);
      this.previousError = error;
      this.previousOutput = output;
      return output;
    }
    reset() {
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    static clamp(value, max, min) {
      return Math.min(Math.max(value, min), max);
    }
  };
  var ResourceModerator = class {
    constructor(resource) {
      this.resource = resource;
      this.pendingConsumer = null;
      this.assignedConsumer = null;
      this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    claim(consumer) {
      var _a;
      const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
      if (consumerToDisplace === consumer) {
        return;
      }
      if (this.queuedConsumers.has(consumer)) {
        return;
      }
      if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
        if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
          if (consumerToDisplace) {
            this.queuedConsumers.insert(consumerToDisplace);
            this.pendingConsumer = null;
          }
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        }
        this.assignedConsumer = null;
        this.pendingConsumer = consumer;
        this.queuedConsumers.insert(consumerToDisplace);
        consumerToDisplace.onCeded(this.resource);
        if (this.pendingConsumer === consumer) {
          this.pendingConsumer = null;
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        } else {
          return;
        }
      }
      this.queuedConsumers.insert(consumer);
    }
    forfeit(consumer) {
      var _a;
      if (this.pendingConsumer === consumer) {
        this.pendingConsumer = null;
        return;
      }
      if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
        this.queuedConsumers.remove(consumer);
        return;
      }
      const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
      this.pendingConsumer = next;
      this.assignedConsumer = null;
      consumer.onCeded(this.resource);
      if (next !== null && this.pendingConsumer === next) {
        this.pendingConsumer = null;
        this.assignedConsumer = next;
        this.assignedConsumer.onAcquired(this.resource);
      }
    }
  };
  var AuralAlertSystem = class {
    constructor(bus) {
      this.bus = bus;
      this.soundServerSub = this.bus.getSubscriber();
      this.controlSub = this.bus.getSubscriber();
      this.soundServerPublisher = this.bus.getPublisher();
      this.publisher = this.bus.getPublisher();
      this.registeredAlerts = /* @__PURE__ */ new Map();
      this.queueToPacketKeyMap = /* @__PURE__ */ new Map();
      this.packetKeyToQueueMap = /* @__PURE__ */ new Map();
      this.queues = /* @__PURE__ */ new Map();
      this.playing = /* @__PURE__ */ new Map();
      this.activeAliasToUuid = /* @__PURE__ */ new Map();
      this.triggeredAliasToUuid = /* @__PURE__ */ new Map();
      this.activeSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToActiveSuffixedIds = /* @__PURE__ */ new Map();
      this.triggeredSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToTriggeredSuffixedIds = /* @__PURE__ */ new Map();
      this.activeAlerts = /* @__PURE__ */ new Map();
      this.triggeredAlerts = /* @__PURE__ */ new Map();
      this.isSoundServerInit = false;
      this.isAwake = false;
      this.controlSub.on("aural_alert_register").handle(this.onAlertRegistered.bind(this));
      this.publisher.pub("aural_alert_request_all_registrations", void 0, true, false);
      this.soundServerSub.on("sound_server_packet_ended").handle(this.onPacketEnded.bind(this));
      this.controlSub.on("aural_alert_activate").handle(this.activateAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate").handle(this.deactivateAlert.bind(this));
      this.controlSub.on("aural_alert_trigger").handle(this.triggerAlert.bind(this));
      this.controlSub.on("aural_alert_untrigger").handle(this.untriggerAlert.bind(this));
      this.controlSub.on("aural_alert_kill").handle(this.killAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate_all").handle(this.deactivateAllAlerts.bind(this));
      this.controlSub.on("aural_alert_untrigger_all").handle(this.untriggerAllAlerts.bind(this));
      this.controlSub.on("aural_alert_kill_all").handle(this.killAllAlerts.bind(this));
      Wait.awaitConsumer(this.soundServerSub.on("sound_server_initialized"), (init) => init, true).then(() => {
        this.isSoundServerInit = true;
        for (const queue of this.queues.values()) {
          this.dequeueAlert(queue);
        }
      });
    }
    wake() {
      if (this.isAwake) {
        return;
      }
      this.isAwake = true;
      for (const alert of this.activeAlerts.values()) {
        if (alert.repeat || alert.packet.continuous) {
          this.queueAlert(alert);
        }
      }
    }
    sleep() {
      if (!this.isAwake) {
        return;
      }
      this.isAwake = false;
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const queueEntry of this.queues.values()) {
        queueEntry.queue.clear();
      }
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    onAlertRegistered(alert) {
      this.registeredAlerts.set(alert.uuid, alert);
      !this.queues.has(alert.queue) && this.createQueue(alert.queue);
    }
    createQueue(queueName) {
      const entry = {
        queue: new BinaryHeap(AuralAlertSystem.ALERT_COMPARATOR),
        debounceTimer: new DebounceTimer()
      };
      this.queues.set(queueName, entry);
      const packetKey = AuralAlertSystem.createPacketKey(queueName);
      this.queueToPacketKeyMap.set(queueName, packetKey);
      this.packetKeyToQueueMap.set(packetKey, queueName);
      return entry;
    }
    isAliasUnique(uuid, alias) {
      if (this.registeredAlerts.has(alias)) {
        return false;
      }
      const existingActive = this.activeAliasToUuid.get(alias);
      if (existingActive !== void 0 && existingActive !== uuid) {
        return false;
      }
      const existingTriggered = this.triggeredAliasToUuid.get(alias);
      if (existingTriggered !== void 0 && existingTriggered !== uuid) {
        return false;
      }
      return true;
    }
    isSuffixedIdUnique(id, suffixedId) {
      if (this.registeredAlerts.has(suffixedId) || this.activeAliasToUuid.has(suffixedId) || this.triggeredAliasToUuid.has(suffixedId)) {
        return false;
      }
      const existingActive = this.activeSuffixedIdToId.get(suffixedId);
      if (existingActive !== void 0 && existingActive !== id) {
        return false;
      }
      const existingTriggered = this.triggeredSuffixedIdToId.get(suffixedId);
      if (existingTriggered !== void 0 && existingTriggered !== id) {
        return false;
      }
      return true;
    }
    activateAlert(activation) {
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.activeAliasToUuid.set(alias, uuid);
      }
      this.activateSuffix(queuedId, suffixedId);
      if (this.activeAlerts.has(queuedId)) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.activeAlerts.set(queuedId, queuedAlert);
      if (this.isAwake) {
        this.queueAlert(queuedAlert);
      }
    }
    activateSuffix(id, suffixedId = id) {
      this.activeSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToActiveSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    triggerAlert(activation) {
      if (!this.isAwake) {
        return;
      }
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.triggeredAliasToUuid.set(alias, uuid);
      }
      this.triggerSuffix(queuedId, suffixedId);
      const existing = this.triggeredAlerts.get(queuedId);
      if (existing && this.playing.get(existing.definition.queue) === existing) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.triggeredAlerts.set(queuedId, queuedAlert);
      this.queueAlert(queuedAlert);
    }
    triggerSuffix(id, suffixedId = id) {
      this.triggeredSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToTriggeredSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    createQueuedAlert(definition, activation) {
      var _a, _b, _c, _d, _e;
      return {
        definition,
        id: (_a = activation === null || activation === void 0 ? void 0 : activation.alias) !== null && _a !== void 0 ? _a : definition.uuid,
        repeat: (_b = activation === null || activation === void 0 ? void 0 : activation.repeat) !== null && _b !== void 0 ? _b : definition.repeat,
        packet: {
          key: this.queueToPacketKeyMap.get(definition.queue),
          sequence: (_c = activation === null || activation === void 0 ? void 0 : activation.sequence) !== null && _c !== void 0 ? _c : definition.sequence,
          continuous: (_d = activation === null || activation === void 0 ? void 0 : activation.continuous) !== null && _d !== void 0 ? _d : definition.continuous,
          timeout: (_e = activation === null || activation === void 0 ? void 0 : activation.timeout) !== null && _e !== void 0 ? _e : definition.timeout
        },
        timestamp: Date.now()
      };
    }
    queueAlert(alert) {
      var _a;
      const queueName = alert.definition.queue;
      const queueEntry = (_a = this.queues.get(queueName)) !== null && _a !== void 0 ? _a : this.createQueue(queueName);
      queueEntry.queue.insert(alert);
      if (this.isSoundServerInit) {
        const playing = this.playing.get(queueName);
        if (!playing) {
          if (!queueEntry.debounceTimer.isPending()) {
            queueEntry.debounceTimer.schedule(this.dequeueAlert.bind(this, queueEntry), 0);
          }
        }
      }
    }
    dequeueAlert(entry) {
      if (this.isAwake) {
        let next = void 0;
        while (entry.queue.size > 0) {
          next = entry.queue.removeMin();
          if (this.activeAlerts.get(next.id) === next || this.triggeredAlerts.get(next.id) === next) {
            break;
          } else {
            next = void 0;
          }
        }
        if (next) {
          this.playing.set(next.definition.queue, next);
          this.soundServerPublisher.pub("sound_server_interrupt", next.packet, true, false);
        }
      } else {
        entry.queue.clear();
      }
    }
    deactivateAlert(id) {
      var _a;
      const deactivatedId = this.deactivateSuffix(id);
      if (deactivatedId === void 0) {
        return;
      }
      const deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
      if (deactivatedUuid !== deactivatedId) {
        this.activeAliasToUuid.delete(deactivatedId);
      }
      const alertDef = this.registeredAlerts.get(deactivatedUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    deactivateSuffix(suffixedId) {
      const id = this.activeSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.activeSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.activeAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.activeAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    untriggerAlert(uuid) {
      var _a;
      const untriggeredId = this.untriggerSuffix(uuid);
      if (untriggeredId === void 0) {
        return;
      }
      const untriggeredUuid = (_a = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _a !== void 0 ? _a : untriggeredId;
      if (untriggeredUuid !== untriggeredId) {
        this.triggeredAliasToUuid.delete(untriggeredId);
      }
      const alertDef = this.registeredAlerts.get(untriggeredUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    untriggerSuffix(suffixedId) {
      const id = this.triggeredSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.triggeredSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.triggeredAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.triggeredAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    killAlert(uuid) {
      var _a, _b;
      const deactivatedId = this.deactivateSuffix(uuid);
      const untriggeredId = this.untriggerSuffix(uuid);
      let deactivatedUuid = void 0;
      let untriggeredUuid = void 0;
      if (deactivatedId !== void 0) {
        deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
        if (deactivatedUuid !== deactivatedId) {
          this.activeAliasToUuid.delete(deactivatedId);
        }
      }
      if (untriggeredId !== void 0) {
        untriggeredUuid = (_b = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _b !== void 0 ? _b : untriggeredId;
        if (untriggeredUuid !== untriggeredId) {
          this.triggeredAliasToUuid.delete(untriggeredId);
        }
      }
      const deactivatedAlertDef = deactivatedUuid === void 0 ? void 0 : this.registeredAlerts.get(deactivatedUuid);
      const untriggeredAlertDef = untriggeredUuid === void 0 ? void 0 : this.registeredAlerts.get(untriggeredUuid);
      let killedPacketKey = void 0;
      if (deactivatedAlertDef) {
        const playing = this.playing.get(deactivatedAlertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
          killedPacketKey = playing.packet.key;
        }
      }
      if (untriggeredAlertDef) {
        const playing = this.playing.get(untriggeredAlertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing && killedPacketKey !== playing.packet.key) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
        }
      }
    }
    deactivateAllAlerts() {
      this.activeAlerts.clear();
      this.activeAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.triggeredAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    untriggerAllAlerts() {
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.activeAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    killAllAlerts() {
      this.activeAlerts.clear();
      this.triggeredAlerts.clear();
      this.activeAliasToUuid.clear();
      this.triggeredAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    onPacketEnded(key) {
      const queueName = this.packetKeyToQueueMap.get(key);
      if (queueName === void 0) {
        return;
      }
      const queueEntry = this.queues.get(queueName);
      if (!queueEntry) {
        this.packetKeyToQueueMap.delete(key);
        this.queueToPacketKeyMap.delete(queueName);
        return;
      }
      const finishedAlert = this.playing.get(queueName);
      if (finishedAlert) {
        if (this.triggeredAlerts.get(finishedAlert.id) === finishedAlert) {
          this.triggeredAlerts.delete(finishedAlert.id);
          if (finishedAlert.id !== finishedAlert.definition.uuid) {
            this.triggeredAliasToUuid.delete(finishedAlert.id);
          }
          const suffixedIds = this.idToTriggeredSuffixedIds.get(finishedAlert.id);
          if (suffixedIds) {
            for (const suffixedId of suffixedIds) {
              this.triggeredSuffixedIdToId.delete(suffixedId);
            }
            this.idToTriggeredSuffixedIds.delete(finishedAlert.id);
          }
        }
        if (finishedAlert.repeat && this.activeAlerts.get(finishedAlert.id) === finishedAlert) {
          this.queueAlert(finishedAlert);
        }
      }
      this.playing.delete(queueName);
      this.dequeueAlert(queueEntry);
    }
    static createPacketKey(queue) {
      return `$$aural-alert-system-queue-${queue}$$`;
    }
  };
  AuralAlertSystem.ALERT_COMPARATOR = (a, b) => {
    const priorityDiff = b.definition.priority - a.definition.priority;
    if (priorityDiff === 0) {
      return a.timestamp - b.timestamp;
    } else {
      return priorityDiff;
    }
  };
  var SoundServer = class {
    constructor(bus) {
      this.bus = bus;
      this.controlSub = this.bus.getSubscriber();
      this.publisher = this.bus.getPublisher();
      this.active = /* @__PURE__ */ new Map();
      this.queued = /* @__PURE__ */ new Map();
      this.publisher.pub("sound_server_initialized", false, true, true);
      this.init();
    }
    async init() {
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      await Wait.awaitDelay(500);
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      this.controlSub.on("sound_server_play").handle(this.playPacket.bind(this));
      this.controlSub.on("sound_server_queue").handle(this.queuePacket.bind(this));
      this.controlSub.on("sound_server_interrupt").handle(this.interruptPacket.bind(this));
      this.controlSub.on("sound_server_stop").handle(this.stopPacket.bind(this));
      this.controlSub.on("sound_server_kill").handle(this.killPacket.bind(this));
      this.controlSub.on("sound_server_stop_all").handle(this.stopAllPackets.bind(this));
      this.controlSub.on("sound_server_kill_all").handle(this.killAllPackets.bind(this));
      this.controlSub.on("sound_server_play_sound").handle(this.playSound.bind(this));
      this.controlSub.on("sound_server_start_sound").handle(this.startSound.bind(this));
      this.controlSub.on("sound_server_stop_sound").handle(this.stopPacket.bind(this));
      this.publisher.pub("sound_server_initialized", true, true, true);
    }
    onSoundEnd(id) {
      const activeEntries = Array.from(this.active.values());
      for (let i = 0; i < activeEntries.length; i++) {
        const entry = activeEntries[i];
        const entrySoundPlaying = entry.sequence[entry.currentIndexPlaying];
        if (!entrySoundPlaying) {
          this.cleanupPacket(entry);
        } else if (Name_Z.compare(entrySoundPlaying, id)) {
          this.advancePacket(entry);
        }
      }
    }
    playPacket(packet) {
      if (!this.active.get(packet.key)) {
        this.queuePacket(packet);
      }
    }
    interruptPacket(packet) {
      const active = this.active.get(packet.key);
      if (active) {
        active.alive = false;
      }
      this.queued.delete(packet.key);
      this.queuePacket(packet);
    }
    queuePacket(packet) {
      var _a;
      const sequence = SoundServer.getSoundSequence(packet);
      const entry = {
        key: packet.key,
        sequence,
        continuous: packet.continuous,
        currentIndexPlaying: 0,
        timeout: (_a = packet.timeout) !== null && _a !== void 0 ? _a : SoundServer.DEFAULT_TIMEOUT,
        alive: true,
        timer: new DebounceTimer(),
        timeoutCallback: () => {
          this.cleanupPacket(entry);
        }
      };
      if (this.active.get(packet.key)) {
        let queue = this.queued.get(entry.key);
        if (!queue) {
          this.queued.set(entry.key, queue = []);
        }
        queue.push(entry);
      } else {
        this.startPacket(entry);
      }
    }
    stopPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.continuous = false;
      }
    }
    killPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.alive = false;
      }
    }
    stopAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.continuous = false;
      }
    }
    killAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.alive = false;
      }
    }
    playSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: false });
    }
    startSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: true });
    }
    startPacket(entry) {
      this.active.set(entry.key, entry);
      this.publisher.pub("sound_server_packet_started", entry.key, true, false);
      if (entry.sequence.length === 0) {
        this.cleanupPacket(entry);
      } else {
        Coherent.call("PLAY_INSTRUMENT_SOUND", entry.sequence[0].originalStr);
        entry.currentIndexPlaying = 0;
        entry.timer.schedule(entry.timeoutCallback, entry.timeout);
      }
    }
    advancePacket(entry) {
      if (!entry.alive) {
        this.cleanupPacket(entry);
        return;
      }
      let nextSoundToPlayIndex = entry.currentIndexPlaying + 1;
      if (nextSoundToPlayIndex >= entry.sequence.length) {
        if (entry.continuous) {
          nextSoundToPlayIndex = 0;
          entry.timer.schedule(entry.timeoutCallback, entry.timeout);
        } else {
          this.cleanupPacket(entry);
          return;
        }
      }
      const soundToPlay = entry.sequence[nextSoundToPlayIndex];
      Coherent.call("PLAY_INSTRUMENT_SOUND", soundToPlay.originalStr);
      entry.currentIndexPlaying = nextSoundToPlayIndex;
    }
    cleanupPacket(entry) {
      entry.alive = false;
      entry.timer.clear();
      const deleted = this.active.delete(entry.key);
      if (!deleted) {
        return;
      }
      this.publisher.pub("sound_server_packet_ended", entry.key, true, false);
      const queue = this.queued.get(entry.key);
      if (queue) {
        const next = queue.shift();
        if (queue.length === 0) {
          this.queued.delete(entry.key);
        }
        if (next) {
          this.startPacket(next);
        }
      }
    }
    static getSoundSequence(packet) {
      const sequence = [];
      if (typeof packet.sequence === "string") {
        if (packet.sequence !== "") {
          sequence.push(new Name_Z(packet.sequence));
        }
      } else {
        for (let i = 0; i < packet.sequence.length; i++) {
          if (packet.sequence[i] !== "") {
            sequence.push(new Name_Z(packet.sequence[i]));
          }
        }
      }
      return sequence;
    }
  };
  SoundServer.DEFAULT_TIMEOUT = 1e4;
  var StringUtils = class {
    static useZeroSlash(text) {
      return text === null || text === void 0 ? void 0 : text.replace(StringUtils.ZERO_REGEX, "0\u0338");
    }
    static trimStart(str) {
      return str.replace(StringUtils.TRIM_START_REGEX, "");
    }
    static trimEnd(str) {
      return str.replace(StringUtils.TRIM_END_REGEX, "");
    }
  };
  StringUtils.DIRECT_TO = "\xD0";
  StringUtils.DEGREE = "\xB0";
  StringUtils.EN_DASH = "\u2013";
  StringUtils.ZERO_REGEX = /0/g;
  StringUtils.TRIM_START_REGEX = /^\s+/;
  StringUtils.TRIM_END_REGEX = /\s+$/;
  var AnnunciationType;
  (function(AnnunciationType2) {
    AnnunciationType2[AnnunciationType2["Warning"] = 0] = "Warning";
    AnnunciationType2[AnnunciationType2["Caution"] = 1] = "Caution";
    AnnunciationType2[AnnunciationType2["Advisory"] = 2] = "Advisory";
    AnnunciationType2[AnnunciationType2["SafeOp"] = 3] = "SafeOp";
  })(AnnunciationType || (AnnunciationType = {}));
  var RenderPosition;
  (function(RenderPosition2) {
    RenderPosition2[RenderPosition2["Before"] = 0] = "Before";
    RenderPosition2[RenderPosition2["After"] = 1] = "After";
    RenderPosition2[RenderPosition2["In"] = 2] = "In";
  })(RenderPosition || (RenderPosition = {}));
  var DisplayComponent = class {
    constructor(props) {
      this.context = void 0;
      this.contextType = void 0;
      this.props = props;
    }
    onBeforeRender() {
      return;
    }
    onAfterRender(node) {
      return;
    }
    destroy() {
      return;
    }
    getContext(context) {
      if (this.context !== void 0 && this.contextType !== void 0) {
        const index = this.contextType.indexOf(context);
        return this.context[index];
      }
      throw new Error("Could not find the provided context type.");
    }
  };
  var NodeReference = class {
    constructor() {
      this._instance = null;
    }
    get instance() {
      if (this._instance !== null) {
        return this._instance;
      }
      throw new Error("Instance was null.");
    }
    set instance(val) {
      this._instance = val;
    }
    getOrDefault() {
      return this._instance;
    }
  };
  var Context = class {
    constructor(defaultValue) {
      this.defaultValue = defaultValue;
      this.Provider = (props) => new ContextProvider(props, this);
    }
  };
  var ContextProvider = class extends DisplayComponent {
    constructor(props, parent) {
      super(props);
      this.parent = parent;
    }
    render() {
      var _a;
      const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
      return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
  };
  var FSComponent;
  (function(FSComponent2) {
    const svgTags = {
      "circle": true,
      "clipPath": true,
      "color-profile": true,
      "cursor": true,
      "defs": true,
      "desc": true,
      "ellipse": true,
      "g": true,
      "image": true,
      "line": true,
      "linearGradient": true,
      "marker": true,
      "mask": true,
      "path": true,
      "pattern": true,
      "polygon": true,
      "polyline": true,
      "radialGradient": true,
      "rect": true,
      "stop": true,
      "svg": true,
      "text": true
    };
    function Fragment2(props) {
      return props.children;
    }
    FSComponent2.Fragment = Fragment2;
    function buildComponent(type, props, ...children) {
      let vnode = null;
      if (typeof type === "string") {
        let element;
        if (svgTags[type] !== void 0) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
        if (props !== null) {
          for (const key in props) {
            if (key === "ref" && props.ref !== void 0) {
              props.ref.instance = element;
            } else {
              const prop = props[key];
              if (key === "class" && typeof prop === "object" && "isSubscribableSet" in prop) {
                prop.sub((set, eventType, modifiedKey) => {
                  if (eventType === SubscribableSetEventType.Added) {
                    element.classList.add(modifiedKey);
                  } else {
                    element.classList.remove(modifiedKey);
                  }
                }, true);
              } else if (typeof prop === "object" && "isSubscribable" in prop) {
                if (key === "style" && prop instanceof ObjectSubject) {
                  prop.sub((v, style, newValue) => {
                    element.style.setProperty(style.toString(), newValue);
                  }, true);
                } else {
                  prop.sub((v) => {
                    element.setAttribute(key, v);
                  }, true);
                }
              } else {
                element.setAttribute(key, prop);
              }
            }
          }
        }
        vnode = {
          instance: element,
          props,
          children: null
        };
        vnode.children = createChildNodes(vnode, children);
      } else if (typeof type === "function") {
        if (children !== null && props === null) {
          props = {
            children
          };
        } else if (props !== null) {
          props.children = children;
        }
        if (typeof type === "function" && type.name === Fragment2.name) {
          let childNodes = type(props);
          while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
            childNodes = childNodes[0];
          }
          vnode = {
            instance: null,
            props,
            children: childNodes
          };
        } else {
          let instance;
          const pluginSystem = window._pluginSystem;
          try {
            instance = type(props);
          } catch (_a) {
            let pluginInstance = void 0;
            if (pluginSystem !== void 0) {
              pluginInstance = pluginSystem.onComponentCreating(type, props);
            }
            if (pluginInstance !== void 0) {
              instance = pluginInstance;
            } else {
              instance = new type(props);
            }
          }
          if (props !== null && props.ref !== null && props.ref !== void 0) {
            props.ref.instance = instance;
          }
          if (instance.contextType !== void 0) {
            instance.context = instance.contextType.map((c) => Subject.create(c.defaultValue));
          }
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentCreated(instance);
          }
          vnode = {
            instance,
            props,
            children: [instance.render()]
          };
        }
      }
      return vnode;
    }
    FSComponent2.buildComponent = buildComponent;
    function createChildNodes(parent, children) {
      let vnodes = null;
      if (children !== null && children !== void 0 && children.length > 0) {
        vnodes = [];
        for (const child of children) {
          if (child !== null) {
            if (child instanceof Array) {
              const arrayNodes = createChildNodes(parent, child);
              if (arrayNodes !== null) {
                vnodes.push(...arrayNodes);
              }
            } else if (typeof child === "object") {
              if ("isSubscribable" in child) {
                const node = {
                  instance: child,
                  children: null,
                  props: null,
                  root: void 0
                };
                child.sub((v) => {
                  if (node.root !== void 0) {
                    node.root.nodeValue = v === "" || v === null || v === void 0 ? " " : v.toString();
                  }
                });
                vnodes.push(node);
              } else {
                vnodes.push(child);
              }
            } else if (typeof child === "string" || typeof child === "number") {
              vnodes.push(createStaticContentNode(child));
            }
          }
        }
      }
      return vnodes;
    }
    FSComponent2.createChildNodes = createChildNodes;
    function createStaticContentNode(content) {
      return {
        instance: content,
        children: null,
        props: null
      };
    }
    FSComponent2.createStaticContentNode = createStaticContentNode;
    function render(node, element, position = RenderPosition.In) {
      if (node.children && node.children.length > 0 && element !== null) {
        const componentInstance = node.instance;
        if (componentInstance !== null && componentInstance.onBeforeRender !== void 0) {
          componentInstance.onBeforeRender();
        }
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
          insertNode(node, position, element);
        } else {
          if (position === RenderPosition.After) {
            for (let i = node.children.length - 1; i >= 0; i--) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          } else {
            for (let i = 0; i < node.children.length; i++) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          }
        }
        const instance = node.instance;
        if (instance instanceof ContextProvider) {
          visitNodes(node, (n) => {
            if (n === void 0 || n === null) {
              return false;
            }
            const nodeInstance = n.instance;
            if (nodeInstance !== null && nodeInstance.contextType !== void 0) {
              const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
              if (contextSlot >= 0) {
                if (nodeInstance.context === void 0) {
                  nodeInstance.context = [];
                }
                nodeInstance.context[contextSlot].set(instance.props.value);
              }
              if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                return true;
              }
            }
            return false;
          });
        }
        if (componentInstance !== null && componentInstance.onAfterRender !== void 0) {
          const pluginSystem = window._pluginSystem;
          componentInstance.onAfterRender(node);
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentRendered(node);
          }
        }
      }
    }
    FSComponent2.render = render;
    function insertNode(node, position, element) {
      var _a, _b, _c, _d, _e, _f;
      if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
        switch (position) {
          case RenderPosition.In:
            element.appendChild(node.instance);
            node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentElement("beforebegin", node.instance);
            node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentElement("afterend", node.instance);
            node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : void 0;
            break;
        }
        if (node.children !== null) {
          for (const child of node.children) {
            insertNode(child, RenderPosition.In, node.instance);
          }
        }
      } else if (typeof node.instance === "string" || typeof node.instance === "object" && node.instance !== null && "isSubscribable" in node.instance) {
        let toRender;
        if (typeof node.instance === "string") {
          toRender = node.instance;
        } else {
          toRender = node.instance.get();
          if (toRender === "") {
            toRender = " ";
          }
        }
        switch (position) {
          case RenderPosition.In:
            element.insertAdjacentHTML("beforeend", toRender);
            node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentHTML("beforebegin", toRender);
            node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentHTML("afterend", toRender);
            node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : void 0;
            break;
        }
      } else if (Array.isArray(node)) {
        if (position === RenderPosition.After) {
          for (let i = node.length - 1; i >= 0; i--) {
            render(node[i], element, position);
          }
        } else {
          for (let i = 0; i < node.length; i++) {
            render(node[i], element, position);
          }
        }
      } else {
        render(node, element, position);
      }
    }
    function renderBefore(node, element) {
      render(node, element, RenderPosition.Before);
    }
    FSComponent2.renderBefore = renderBefore;
    function renderAfter(node, element) {
      render(node, element, RenderPosition.After);
    }
    FSComponent2.renderAfter = renderAfter;
    function remove(element) {
      if (element !== null) {
        element.remove();
      }
    }
    FSComponent2.remove = remove;
    function createRef() {
      return new NodeReference();
    }
    FSComponent2.createRef = createRef;
    function createContext(defaultValue) {
      return new Context(defaultValue);
    }
    FSComponent2.createContext = createContext;
    function visitNodes(node, visitor) {
      if (node === void 0 || node === null) {
        return;
      }
      const stopVisitation = visitor(node);
      if (!stopVisitation && node.children !== void 0 && node.children !== null) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (Array.isArray(child)) {
            for (let childIndex = 0; childIndex < child.length; childIndex++) {
              visitNodes(child[childIndex], visitor);
            }
          } else {
            visitNodes(child, visitor);
          }
        }
      }
      return;
    }
    FSComponent2.visitNodes = visitNodes;
    function parseCssClassesFromString(classString, filter) {
      return classString.split(" ").filter((str) => str !== "" && (filter === void 0 || filter(str)));
    }
    FSComponent2.parseCssClassesFromString = parseCssClassesFromString;
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
      const reservedClassSet = new Set(reservedClasses);
      if (reservedClassSet.size === 0) {
        return classesToSubscribe.sub((set, type, key) => {
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      } else {
        return classesToSubscribe.sub((set, type, key) => {
          if (reservedClassSet.has(key)) {
            return;
          }
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      }
    }
    FSComponent2.bindCssClassSet = bindCssClassSet;
    function shallowDestroy(root) {
      FSComponent2.visitNodes(root, (node) => {
        if (node !== root && node.instance instanceof DisplayComponent) {
          node.instance.destroy();
          return true;
        }
        return false;
      });
    }
    FSComponent2.shallowDestroy = shallowDestroy;
    FSComponent2.EmptyHandler = () => {
      return;
    };
  })(FSComponent || (FSComponent = {}));
  var Fragment = FSComponent.Fragment;
  var BingComponent = class extends DisplayComponent {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
      this.isListenerRegistered = false;
      this.imgRef = FSComponent.createRef();
      this.uid = 0;
      this._isBound = false;
      this._isAwake = true;
      this.isDestroyed = false;
      this.pos = new LatLong(0, 0);
      this.radius = 10;
      this.resolution = (_a = this.props.resolution) !== null && _a !== void 0 ? _a : Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION));
      this.earthColors = (_b = this.props.earthColors) !== null && _b !== void 0 ? _b : ArraySubject.create(ArrayUtils.create(2, () => BingComponent.hexaToRGBColor("#000000")));
      this.earthColorsElevationRange = (_c = this.props.earthColorsElevationRange) !== null && _c !== void 0 ? _c : Vec2Subject.create(Vec2Math.create(0, 3e4));
      this.skyColor = (_d = this.props.skyColor) !== null && _d !== void 0 ? _d : Subject.create(BingComponent.hexaToRGBColor("#000000"));
      this.reference = (_e = this.props.reference) !== null && _e !== void 0 ? _e : Subject.create(EBingReference.SEA);
      this.wxrMode = (_f = this.props.wxrMode) !== null && _f !== void 0 ? _f : Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 });
      this.wxrColors = (_g = this.props.wxrColors) !== null && _g !== void 0 ? _g : ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this.isoLines = (_h = this.props.isoLines) !== null && _h !== void 0 ? _h : Subject.create(false);
      this.wxrColorsArray = [];
      this.wxrRateArray = [];
      this.resolutionHandler = (resolution) => {
        Coherent.call("SET_MAP_RESOLUTION", this.uid, resolution[0], resolution[1]);
        this.positionRadiusInhibitFramesRemaining = BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;
        if (!this.positionRadiusInhibitTimer.isPending()) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        }
      };
      this.earthColorsHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        Coherent.call("SET_MAP_HEIGHT_COLORS", this.uid, colors);
      };
      this.earthColorsElevationRangeHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        const range = this.earthColorsElevationRange.get();
        const terrainColorCount = colors.length - 1;
        const desiredElevationStep = (range[1] - range[0]) / Math.max(terrainColorCount - 1, 1);
        const requiredMin = range[0] - desiredElevationStep;
        const requiredMax = range[1] + desiredElevationStep;
        Coherent.call("SET_MAP_ALTITUDE_RANGE", this.uid, requiredMin, requiredMax);
      };
      this.skyColorHandler = (color) => {
        Coherent.call("SET_MAP_CLEAR_COLOR", this.uid, color);
      };
      this.referenceHandler = (reference) => {
        const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
        this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, flags);
      };
      this.wxrModeHandler = (wxrMode) => {
        Coherent.call("SHOW_MAP_WEATHER", this.uid, wxrMode.mode, wxrMode.arcRadians);
      };
      this.wxrColorsHandler = () => {
        const array = this.wxrColors.getArray();
        if (array.length === 0) {
          return;
        }
        this.wxrColorsArray.length = array.length;
        this.wxrRateArray.length = array.length;
        for (let i = 0; i < array.length; i++) {
          this.wxrColorsArray[i] = array[i][0];
          this.wxrRateArray[i] = array[i][1];
        }
        Coherent.call("SET_MAP_WEATHER_RADAR_COLORS", this.uid, this.wxrColorsArray, this.wxrRateArray);
      };
      this.isoLinesHandler = (showIsolines) => {
        Coherent.call("SHOW_MAP_ISOLINES", this.uid, showIsolines);
      };
      this.setCurrentMapParamsTimer = null;
      this.positionRadiusInhibitFramesRemaining = 0;
      this.isPositionRadiusPending = false;
      this.positionRadiusInhibitTimer = new DebounceTimer();
      this.processPendingPositionRadius = () => {
        if (this.isPositionRadiusPending) {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
        if (--this.positionRadiusInhibitFramesRemaining > 0) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        } else {
          this.isPositionRadiusPending = false;
        }
      };
      this.onListenerBound = (binder, uid) => {
        if (this.isDestroyed) {
          return;
        }
        if (binder.friendlyName === this.props.id) {
          this.binder = binder;
          this.uid = uid;
          if (this._isBound) {
            return;
          }
          this._isBound = true;
          Coherent.call("SHOW_MAP", uid, true);
          const pause = !this._isAwake;
          this.earthColorsSub = this.earthColors.sub(() => {
            this.earthColorsHandler();
            this.earthColorsElevationRangeHandler();
          }, true, pause);
          this.earthColorsElevationRangeSub = this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler, true, pause);
          this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true, pause);
          this.referenceSub = this.reference.sub(this.referenceHandler, true, pause);
          this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true, pause);
          this.wxrColorsSub = this.wxrColors.sub(this.wxrColorsHandler, true, pause);
          this.resolutionSub = this.resolution.sub(this.resolutionHandler, true, pause);
          this.isoLinesSub = this.isoLines.sub(this.isoLinesHandler, true, pause);
          if (this.modeFlags !== 4) {
            Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
          }
          this.props.onBoundCallback && this.props.onBoundCallback(this);
        }
      };
      this.onMapUpdate = (uid, imgSrc) => {
        if (this.binder !== void 0 && this.uid === uid && this.imgRef.instance !== null) {
          if (this.imgRef.instance.src !== imgSrc) {
            this.imgRef.instance.src = imgSrc;
          }
        }
      };
      this.setCurrentMapParams = () => {
        this.setPositionRadius(this.pos, this.radius);
      };
    }
    isBound() {
      return this._isBound;
    }
    isAwake() {
      return this._isAwake;
    }
    onAfterRender() {
      if (window["IsDestroying"]) {
        this.destroy();
        return;
      }
      const gameStateSubscribable = GameStateProvider.get();
      const gameState = gameStateSubscribable.get();
      if (gameState === GameState.briefing || gameState === GameState.ingame) {
        this.registerListener();
      } else {
        this.gameStateSub = gameStateSubscribable.sub((state) => {
          var _a;
          if (this.isDestroyed) {
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.registerListener();
          }
        });
      }
      window.addEventListener("OnDestroy", this.destroy.bind(this));
    }
    registerListener() {
      var _a;
      if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
        setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
        }, this.props.delay);
      } else {
        this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
      }
    }
    onListenerRegistered() {
      if (this.isDestroyed || this.isListenerRegistered) {
        return;
      }
      this.mapListener.on("MapBinded", this.onListenerBound);
      this.mapListener.on("MapUpdated", this.onMapUpdate);
      this.isListenerRegistered = true;
      this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, this.modeFlags);
    }
    wake() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = true;
      if (!this._isBound) {
        return;
      }
      this.setCurrentMapParams();
      if (this.modeFlags !== 4) {
        this.setCurrentMapParamsTimer = setInterval(this.setCurrentMapParams, 200);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.resume(true);
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.resume(true);
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.resume(true);
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.resume(true);
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.resume(true);
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.resume(true);
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.resume(true);
    }
    sleep() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = false;
      if (!this._isBound) {
        return;
      }
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.pause();
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.pause();
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.pause();
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.pause();
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.pause();
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.pause();
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.pause();
    }
    setPositionRadius(pos, radius) {
      this.pos = pos;
      this.radius = Math.max(radius, 10);
      if (this._isBound && this._isAwake) {
        if (this.positionRadiusInhibitFramesRemaining > 0) {
          this.isPositionRadiusPending = true;
        } else {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
      }
    }
    render() {
      var _a;
      return FSComponent.buildComponent("img", { ref: this.imgRef, src: "", style: "position: absolute; left: 0; top: 0; width: 100%; height: 100%;", class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      this.isDestroyed = true;
      this._isBound = false;
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.earthColorsSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.earthColorsElevationRangeSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.skyColorSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.referenceSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.wxrModeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.wxrColorsSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.resolutionSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.isoLinesSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.mapListener) === null || _k === void 0 ? void 0 : _k.off("MapBinded", this.onListenerBound);
      (_l = this.mapListener) === null || _l === void 0 ? void 0 : _l.off("MapUpdated", this.onMapUpdate);
      (_m = this.mapListener) === null || _m === void 0 ? void 0 : _m.trigger("JS_UNBIND_BINGMAP", this.props.id);
      this.isListenerRegistered = false;
      this.imgRef.instance.src = "";
      (_o = this.imgRef.instance.parentNode) === null || _o === void 0 ? void 0 : _o.removeChild(this.imgRef.instance);
      super.destroy();
    }
    resetImgSrc() {
      const imgRef = this.imgRef.getOrDefault();
      if (imgRef !== null) {
        const currentSrc = imgRef.src;
        imgRef.src = "";
        imgRef.src = currentSrc;
      }
    }
    static hexaToRGBColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      return BingComponent.rgbColor(r, g, b);
    }
    static rgbToHexaColor(rgb, poundPrefix = true) {
      const b = Math.floor(rgb % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgb % (256 * 256) / 256);
      const r = rgb % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
    }
    static rgbColor(r, g, b) {
      return 256 * 256 * b + 256 * g + r;
    }
    static hexaToRGBAColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      const a = parseInt(hexStringColor.substr(6 + offset, 2), 16);
      return BingComponent.rgbaColor(r, g, b, a);
    }
    static rgbaToHexaColor(rgba, poundPrefix = true) {
      const a = Math.floor(rgba % (256 * 256 * 256 * 256) / (256 * 256 * 256));
      const b = Math.floor(rgba % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgba % (256 * 256) / 256);
      const r = rgba % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}${a.toString(16).padStart(2, "0")}`;
    }
    static rgbaColor(r, g, b, a) {
      return 256 * 256 * 256 * a + 256 * 256 * b + 256 * g + r;
    }
    static createEarthColorsArray(waterColor, terrainColors, minElevation = 0, maxElevation = 3e4, stepCount = 61) {
      const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
      const curve = new Avionics.Curve();
      curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
      for (let i = 0; i < terrainColors.length; i++) {
        curve.add(terrainColors[i].elev, terrainColors[i].color);
      }
      const elevationStep = (maxElevation - minElevation) / Math.max(stepCount - 1, 1);
      for (let i = 0; i < stepCount; i++) {
        const color = curve.evaluate(minElevation + i * elevationStep);
        earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
      }
      return earthColors;
    }
  };
  BingComponent.DEFAULT_RESOLUTION = 1024;
  BingComponent.DEFAULT_WEATHER_COLORS = [
    [BingComponent.hexaToRGBAColor("#00000000"), 0.5],
    [BingComponent.hexaToRGBAColor("#004d00ff"), 2.75],
    [BingComponent.hexaToRGBAColor("#cb7300ff"), 12.5],
    [BingComponent.hexaToRGBAColor("#ff0000ff"), 12.5]
  ];
  BingComponent.POSITION_RADIUS_INHIBIT_FRAMES = 10;
  var DurationDisplayFormat;
  (function(DurationDisplayFormat2) {
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_ss"] = 0] = "hh_mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm"] = 1] = "hh_mm";
    DurationDisplayFormat2[DurationDisplayFormat2["mm_ss"] = 2] = "mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_or_mm_ss"] = 3] = "hh_mm_or_mm_ss";
  })(DurationDisplayFormat || (DurationDisplayFormat = {}));
  var DurationDisplayDelim;
  (function(DurationDisplayDelim2) {
    DurationDisplayDelim2[DurationDisplayDelim2["Colon"] = 0] = "Colon";
    DurationDisplayDelim2[DurationDisplayDelim2["ColonOrCross"] = 1] = "ColonOrCross";
    DurationDisplayDelim2[DurationDisplayDelim2["Space"] = 2] = "Space";
  })(DurationDisplayDelim || (DurationDisplayDelim = {}));
  var DurationDisplay = class extends DisplayComponent {
    constructor(props) {
      super(props);
      this.value = "isSubscribable" in this.props.value ? this.props.value : Subject.create(this.props.value);
      this.options = Object.assign({}, DurationDisplay.DEFAULT_OPTIONS, this.props.options);
      this.negativeSign = this.options.useMinusSign ? "\u2212" : "-";
      this.positiveSign = this.options.forceSign ? "+" : "";
      this.text = Subject.create("");
      switch (this.options.delim) {
        case DurationDisplayDelim.Colon:
          this.delim = ":";
          break;
        case DurationDisplayDelim.Space:
          this.delim = " ";
          break;
        default:
          this.delim = "";
      }
    }
    onAfterRender() {
      this.valueSub = this.value.sub(this.onValueChanged.bind(this), true);
    }
    onValueChanged(value) {
      this.setDisplay(value);
    }
    setDisplay(value) {
      let text;
      if (value.isNaN()) {
        text = this.options.nanString;
      } else {
        let hrText = "";
        let minText = "";
        let secText = "";
        let hrUnitText = "";
        let minUnitText = "";
        let secUnitText = "";
        let hrDelim = "";
        let minDelim = "";
        const valueAsSeconds = Math.abs(value.asUnit(UnitType.SECOND));
        const isNegative = value.number < 0;
        let hours = Math.floor(valueAsSeconds / 3600);
        if (this.options.format != DurationDisplayFormat.mm_ss && !(this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours == 0)) {
          hrText = hours.toFixed(0);
          if (this.options.delim === DurationDisplayDelim.ColonOrCross) {
            if (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss || this.options.format === DurationDisplayFormat.hh_mm) {
              hrDelim = "+";
            } else {
              hrDelim = ":";
            }
          } else {
            hrDelim = this.delim;
          }
        }
        const hoursInMinutes = hours * 60;
        let minutes;
        let seconds;
        if (this.options.format === DurationDisplayFormat.hh_mm || this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours !== 0) {
          minutes = valueAsSeconds / 60 - hoursInMinutes;
          minText = this.options.numberFormatter(minutes);
        } else {
          minutes = Math.floor(valueAsSeconds / 60 - hoursInMinutes);
          minText = minutes.toFixed(0);
          minDelim = this.options.delim === DurationDisplayDelim.ColonOrCross ? ":" : this.delim;
          seconds = valueAsSeconds - (hoursInMinutes + minutes) * 60;
          secText = this.options.numberFormatter(seconds);
        }
        if (secText && secText.replace(/\b0+/, "").substring(0, 2) === "60") {
          seconds = parseFloat(secText) - 60;
          minutes++;
          secText = this.options.numberFormatter(seconds);
          minText = `${minutes}`;
        }
        if (minText && minText.replace(/\b0+/, "").substring(0, 2) === "60" && hrText) {
          if (secText) {
            minutes = 0;
            minText = "00";
          } else {
            minutes = parseFloat(minText) - 60;
            minText = this.options.numberFormatter(minutes);
          }
          hours++;
          hrText = `${hours}`;
        }
        if (hrText) {
          hrText = hrText.padStart(this.options.pad, "0");
          if (secText) {
            minText = minText.padStart(2, "0");
            secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
          } else {
            minText = DurationDisplay.padIntegerPart(minText.replace(/^0+/, ""), 2, "0");
          }
        } else {
          minText = minText.padStart(this.options.pad, "0");
          secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
        }
        if (this.options.showUnits) {
          hrText && (hrUnitText = this.options.unitFormatter(parseFloat(hrText), UnitType.HOUR));
          minUnitText = this.options.unitFormatter(parseFloat(minText), UnitType.MINUTE);
          secText && (secUnitText = this.options.unitFormatter(parseFloat(secText), UnitType.SECOND));
        }
        const sign = isNegative ? this.negativeSign : this.positiveSign;
        text = `${sign}${hrText}${hrUnitText}${hrDelim}${minText}${minUnitText}${minDelim}${secText}${secUnitText}`;
      }
      this.text.set(text);
    }
    static padIntegerPart(str, maxLength, fillString) {
      const decimalIndex = str.indexOf(".");
      return str.padStart(decimalIndex < 0 ? maxLength : str.length - decimalIndex + maxLength, fillString);
    }
    render() {
      var _a;
      return FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: "white-space: nowrap;" }, this.text);
    }
    destroy() {
      var _a;
      (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  DurationDisplay.DEFAULT_OPTIONS = {
    pad: 0,
    format: DurationDisplayFormat.hh_mm_ss,
    delim: DurationDisplayDelim.Colon,
    showUnits: false,
    numberFormatter: (value) => value.toFixed(0),
    unitFormatter: (value, unit) => unit.name[0],
    useMinusSign: false,
    forceSign: false,
    nanString: ""
  };
  var DmsDirection;
  (function(DmsDirection2) {
    DmsDirection2["NORTH"] = "N";
    DmsDirection2["SOUTH"] = "S";
    DmsDirection2["WEST"] = "W";
    DmsDirection2["EAST"] = "E";
  })(DmsDirection || (DmsDirection = {}));
  var FocusPosition;
  (function(FocusPosition2) {
    FocusPosition2["MostRecent"] = "MostRecent";
    FocusPosition2["First"] = "First";
    FocusPosition2["Last"] = "Last";
    FocusPosition2["None"] = "None";
  })(FocusPosition || (FocusPosition = {}));
  var BlurReconciliation;
  (function(BlurReconciliation2) {
    BlurReconciliation2["First"] = "First";
    BlurReconciliation2["Last"] = "Last";
    BlurReconciliation2["Next"] = "Next";
    BlurReconciliation2["Prev"] = "Prev";
    BlurReconciliation2["None"] = "None";
  })(BlurReconciliation || (BlurReconciliation = {}));
  var HorizonProjectionChangeType;
  (function(HorizonProjectionChangeType2) {
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Position"] = 1] = "Position";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Altitude"] = 2] = "Altitude";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Heading"] = 4] = "Heading";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Pitch"] = 8] = "Pitch";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Roll"] = 16] = "Roll";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Offset"] = 32] = "Offset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedSize"] = 64] = "ProjectedSize";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Fov"] = 128] = "Fov";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["FovEndpoints"] = 256] = "FovEndpoints";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ScaleFactor"] = 512] = "ScaleFactor";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedOffset"] = 1024] = "ProjectedOffset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["OffsetCenterProjected"] = 2048] = "OffsetCenterProjected";
  })(HorizonProjectionChangeType || (HorizonProjectionChangeType = {}));
  var HorizonProjection = class {
    constructor(projectedWidth, projectedHeight, fov) {
      this.position = new GeoPoint(0, 0);
      this.altitude = 0;
      this.heading = 0;
      this.roll = 0;
      this.pitch = 0;
      this.offset = Vec3Math.create();
      this.fovEndpoints = VecNMath.create(4, 0.5, 0, 0.5, 1);
      this.scaleFactor = 1;
      this.projectedOffset = Vec2Math.create();
      this.offsetCenterProjected = Vec2Math.create();
      this.positionAngleTransforms = [new Transform3D(), new Transform3D()];
      this.altitudeTransform = new Transform3D();
      this.positionAltitudeTransforms = [...this.positionAngleTransforms, this.altitudeTransform];
      this.positionTransform = new Transform3D();
      this.planeAngles = Vec3Math.create();
      this.planeAngleTransforms = [new Transform3D(), new Transform3D(), new Transform3D()];
      this.planeTransform = new Transform3D();
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create();
      this.perspectiveTransform = new TransformPerspective();
      this.oldParameters = {
        position: new GeoPoint(0, 0),
        altitude: 0,
        heading: 0,
        pitch: 0,
        roll: 0,
        offset: Vec3Math.create(),
        projectedSize: Vec2Math.create(),
        fov: 0,
        fovEndpoints: VecNMath.create(4),
        scaleFactor: 1,
        projectedOffset: Vec2Math.create(),
        offsetCenterProjected: Vec2Math.create()
      };
      this.queuedParameters = {};
      this.updateQueued = false;
      this.changeEvent = new SubEvent();
      this.projectedSize = Vec2Math.create(projectedWidth, projectedHeight);
      this.fov = fov;
      this.recompute();
    }
    getPosition() {
      return this.position.readonly;
    }
    getAltitude() {
      return this.altitude;
    }
    getHeading() {
      return this.heading;
    }
    getPitch() {
      return this.pitch;
    }
    getRoll() {
      return this.roll;
    }
    getProjectedSize() {
      return this.projectedSize;
    }
    getFov() {
      return this.fov;
    }
    getFovEndpoints() {
      return this.fovEndpoints;
    }
    getFocalLength() {
      return this.surfacePos[2];
    }
    getScaleFactor() {
      return this.scaleFactor;
    }
    getProjectedOffset() {
      return this.projectedOffset;
    }
    getOffsetCenterProjected() {
      return this.offsetCenterProjected;
    }
    recompute() {
      Vec2Math.set(this.projectedSize[0] / 2 + this.projectedOffset[0], this.projectedSize[1] / 2 + this.projectedOffset[1], this.offsetCenterProjected);
      this.positionAngleTransforms[0].toRotationZ(-this.position.lon * Avionics.Utils.DEG2RAD);
      this.positionAngleTransforms[1].toRotationY(this.position.lat * Avionics.Utils.DEG2RAD);
      this.altitudeTransform.toTranslation(-(UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + this.altitude), 0, 0);
      Transform3D.concat(this.positionTransform, this.positionAltitudeTransforms);
      this.planeAngles[0] = -this.heading * Avionics.Utils.DEG2RAD;
      this.planeAngles[1] = this.pitch * Avionics.Utils.DEG2RAD;
      this.planeAngles[2] = this.roll * Avionics.Utils.DEG2RAD;
      this.planeAngleTransforms[0].toRotationZ(this.planeAngles[2]);
      this.planeAngleTransforms[1].toRotationY(this.planeAngles[1]);
      this.planeAngleTransforms[2].toRotationX(this.planeAngles[0]);
      Transform3D.concat(this.planeTransform, this.planeAngleTransforms);
      this.planeTransform.apply(this.offset, this.cameraPos);
      this.scaleFactor = Math.hypot(this.fovEndpoints[2] * this.projectedSize[0] - this.fovEndpoints[0] * this.projectedSize[0], this.fovEndpoints[3] * this.projectedSize[1] - this.fovEndpoints[1] * this.projectedSize[1]);
      this.surfacePos[2] = 1 / (2 * Math.tan(this.fov * 0.5 * Avionics.Utils.DEG2RAD));
      this.perspectiveTransform.set(this.cameraPos, this.planeTransform, this.surfacePos);
    }
    set(parameters) {
      var _a, _b, _c, _d, _e;
      this.storeParameters(this.oldParameters);
      parameters.position !== void 0 && this.position.set(parameters.position);
      this.altitude = (_a = parameters.altitude) !== null && _a !== void 0 ? _a : this.altitude;
      this.heading = (_b = parameters.heading) !== null && _b !== void 0 ? _b : this.heading;
      this.pitch = (_c = parameters.pitch) !== null && _c !== void 0 ? _c : this.pitch;
      this.roll = (_d = parameters.roll) !== null && _d !== void 0 ? _d : this.roll;
      parameters.offset !== void 0 && this.offset.set(parameters.offset);
      parameters.projectedSize !== void 0 && this.projectedSize.set(parameters.projectedSize);
      this.fov = (_e = parameters.fov) !== null && _e !== void 0 ? _e : this.fov;
      parameters.fovEndpoints !== void 0 && this.fovEndpoints.set(parameters.fovEndpoints);
      parameters.projectedOffset !== void 0 && this.projectedOffset.set(parameters.projectedOffset);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        this.changeEvent.notify(this, changeFlags);
      }
    }
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    storeParameters(record) {
      record.position.set(this.position);
      record.altitude = this.altitude;
      record.heading = this.heading;
      record.pitch = this.pitch;
      record.roll = this.roll;
      record.offset.set(this.offset);
      record.projectedSize.set(this.projectedSize);
      record.fov = this.fov;
      record.fovEndpoints.set(this.fovEndpoints);
      record.scaleFactor = this.scaleFactor;
      record.projectedOffset.set(this.projectedOffset);
      record.offsetCenterProjected.set(this.offsetCenterProjected);
    }
    computeChangeFlags(oldParameters) {
      return (oldParameters.position.equals(this.position) ? 0 : HorizonProjectionChangeType.Position) | (oldParameters.altitude === this.altitude ? 0 : HorizonProjectionChangeType.Altitude) | (oldParameters.heading === this.heading ? 0 : HorizonProjectionChangeType.Heading) | (oldParameters.pitch === this.pitch ? 0 : HorizonProjectionChangeType.Pitch) | (oldParameters.roll === this.roll ? 0 : HorizonProjectionChangeType.Roll) | (Vec3Math.equals(oldParameters.offset, this.offset) ? 0 : HorizonProjectionChangeType.Offset) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : HorizonProjectionChangeType.ProjectedSize) | (oldParameters.fov === this.fov ? 0 : HorizonProjectionChangeType.Fov) | (VecNMath.equals(oldParameters.fovEndpoints, this.fovEndpoints) ? 0 : HorizonProjectionChangeType.ProjectedOffset) | (Vec2Math.equals(oldParameters.projectedOffset, this.projectedOffset) ? 0 : HorizonProjectionChangeType.ProjectedOffset);
    }
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.scaleFactor === this.scaleFactor ? 0 : HorizonProjectionChangeType.ScaleFactor) | (Vec2Math.equals(oldParameters.offsetCenterProjected, this.offsetCenterProjected) ? 0 : HorizonProjectionChangeType.OffsetCenterProjected);
    }
    onChange(listener) {
      return this.changeEvent.on(listener);
    }
    project(position, altitude, out) {
      const vec = GeoPoint.sphericalToCartesian(position, HorizonProjection.vec3Cache[0]);
      Vec3Math.multScalar(vec, UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + altitude, vec);
      this.positionTransform.apply(vec, vec);
      return this.projectRelativeVec(vec, out);
    }
    projectRelativeSpherical(bearing, distance, height, out) {
      return this.project(this.position.offset(bearing, UnitType.METER.convertTo(distance, UnitType.GA_RADIAN), HorizonProjection.geoPointCache[0]), this.altitude + height, out);
    }
    projectRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    projectRelativeVec(vec, out) {
      this.perspectiveTransform.apply(vec, out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    projectCameraRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    projectCameraRelativeVec(vec, out) {
      this.perspectiveTransform.apply(Vec3Math.add(vec, this.perspectiveTransform.getCameraPosition(), HorizonProjection.cameraRelativeVec3Cache[0]), out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    isInProjectedBounds(point, arg2, arg3) {
      let bounds;
      if (point instanceof Float64Array) {
        bounds = arg2;
      } else {
        point = this.project(point, arg2, HorizonProjection.vec2Cache[0]);
        bounds = arg3;
      }
      const x = point[0];
      const y = point[1];
      if (!isFinite(x) || !isFinite(y)) {
        return false;
      }
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      return x >= left && x <= right && y >= top && y <= bottom;
    }
  };
  HorizonProjection.vec2Cache = [Vec2Math.create()];
  HorizonProjection.vec3Cache = [Vec3Math.create()];
  HorizonProjection.geoPointCache = [new GeoPoint(0, 0)];
  HorizonProjection.cameraRelativeVec3Cache = [Vec3Math.create()];
  var MapLayer = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this._isVisible = true;
    }
    isVisible() {
      return this._isVisible;
    }
    setVisible(val) {
      if (this._isVisible === val) {
        return;
      }
      this._isVisible = val;
      this.onVisibilityChanged(val);
    }
    onVisibilityChanged(isVisible) {
    }
    onAttached() {
    }
    onWake() {
    }
    onSleep() {
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    onUpdated(time, elapsed) {
    }
    onDetached() {
    }
  };
  var MapProjectionChangeType;
  (function(MapProjectionChangeType2) {
    MapProjectionChangeType2[MapProjectionChangeType2["Target"] = 1] = "Target";
    MapProjectionChangeType2[MapProjectionChangeType2["Center"] = 2] = "Center";
    MapProjectionChangeType2[MapProjectionChangeType2["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType2[MapProjectionChangeType2["Range"] = 8] = "Range";
    MapProjectionChangeType2[MapProjectionChangeType2["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType2[MapProjectionChangeType2["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType2[MapProjectionChangeType2["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedResolution"] = 256] = "ProjectedResolution";
  })(MapProjectionChangeType || (MapProjectionChangeType = {}));
  var MapProjection = class {
    constructor(projectedWidth, projectedHeight) {
      this.target = new GeoPoint(0, 0);
      this.targetProjectedOffset = new Float64Array(2);
      this.targetProjected = new Float64Array(2);
      this.range = 1;
      this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]);
      this.projectedSize = new Float64Array(2);
      this.center = new GeoPoint(0, 0);
      this.centerProjected = new Float64Array(2);
      this.projectedRange = 0;
      this.widthRange = 0;
      this.heightRange = 0;
      this.oldParameters = {
        target: new GeoPoint(0, 0),
        center: new GeoPoint(0, 0),
        targetProjected: new Float64Array(2),
        range: 1,
        rangeEndpoints: new Float64Array(4),
        scaleFactor: 1,
        rotation: 0,
        projectedSize: new Float64Array(2),
        projectedResolution: 0
      };
      this.queuedParameters = Object.assign({}, this.oldParameters);
      this.updateQueued = false;
      this.changeListeners = [];
      Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
      this.geoProjection = new MercatorProjection();
      Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
      this.targetProjected.set(this.centerProjected);
      this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
      this.recompute();
    }
    getGeoProjection() {
      return this.geoProjection;
    }
    getTarget() {
      return this.target.readonly;
    }
    getTargetProjectedOffset() {
      return this.targetProjectedOffset;
    }
    getTargetProjected() {
      return this.targetProjected;
    }
    getRange() {
      return this.range;
    }
    getRangeEndpoints() {
      return this.rangeEndpoints;
    }
    getWidthRange() {
      return this.widthRange;
    }
    getHeightRange() {
      return this.heightRange;
    }
    getScaleFactor() {
      return this.geoProjection.getScaleFactor();
    }
    getRotation() {
      return this.geoProjection.getPostRotation();
    }
    getProjectedSize() {
      return this.projectedSize;
    }
    getCenter() {
      return this.center.readonly;
    }
    getCenterProjected() {
      return this.centerProjected;
    }
    getProjectedResolution() {
      return this.range / this.projectedRange;
    }
    calculateRangeAtCenter(centerProjected) {
      const endpoints = this.rangeEndpoints;
      const projectedWidth = this.projectedSize[0];
      const projectedHeight = this.projectedSize[1];
      const endpoint1 = MapProjection.tempVec2_3;
      endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
      endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
      const endpoint2 = MapProjection.tempVec2_4;
      endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
      endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
      const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
      const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
      return top.distance(bottom);
    }
    recompute() {
      const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
      if (!isFinite(currentTargetProjected[0] + currentTargetProjected[1])) {
        const translation = this.geoProjection.getTranslation();
        if (isFinite(this.target.lat) && isFinite(this.target.lon) && isFinite(this.geoProjection.getPostRotation()) && isFinite(translation[0]) && isFinite(translation[1])) {
          this.geoProjection.setScaleFactor(MapProjection.DEFAULT_SCALE_FACTOR);
          this.geoProjection.setCenter(MapProjection.tempGeoPoint_1.set(0, 0));
          this.geoProjection.setPreRotation(Vec3Math.set(0, 0, 0, MapProjection.vec3Cache[0]));
        } else {
          return;
        }
      }
      const currentCenterProjected = MapProjection.tempVec2_2;
      currentCenterProjected.set(currentTargetProjected);
      currentCenterProjected[0] -= this.targetProjectedOffset[0];
      currentCenterProjected[1] -= this.targetProjectedOffset[1];
      let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
      let ratio = currentRange / this.range;
      if (!isFinite(ratio) || ratio === 0) {
        return;
      }
      let lastScaleFactor = this.geoProjection.getScaleFactor();
      let iterCount = 0;
      let ratioError = Math.abs(ratio - 1);
      let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
      while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
        this.geoProjection.setScaleFactor(ratio * lastScaleFactor);
        this.geoProjection.project(this.target, currentTargetProjected);
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        const newRatio = currentRange / this.range;
        const ratioDelta = newRatio - ratio;
        if (!isFinite(ratio) || ratio < 1 && ratioDelta <= 0 || ratio > 1 && ratioDelta >= 0) {
          this.geoProjection.setScaleFactor(lastScaleFactor);
        }
        lastScaleFactor = this.geoProjection.getScaleFactor();
        ratio = newRatio;
        const newRatioError = Math.abs(ratio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.invert(currentCenterProjected, this.center);
      this.geoProjection.setCenter(this.center);
      const preRotation = Vec3Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, 0, MapProjection.vec3Cache[0]);
      this.geoProjection.setPreRotation(preRotation);
      const width = this.projectedSize[0];
      const height = this.projectedSize[1];
      this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
      const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
      const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
      this.widthRange = this.geoDistance(left, right);
      const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
      const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
      this.heightRange = this.geoDistance(top, bottom);
    }
    set(parameters) {
      this.storeParameters(this.oldParameters);
      parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
      parameters.target && this.target.set(parameters.target);
      parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
      parameters.range !== void 0 && (this.range = parameters.range);
      parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
      parameters.rotation !== void 0 && this.geoProjection.setPostRotation(parameters.rotation);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        if (changeFlags !== 0) {
          this.notifyChangeListeners(changeFlags);
        }
      }
    }
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    setProjectedSize(size) {
      this.projectedSize.set(size);
      Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
      this.geoProjection.setTranslation(this.centerProjected);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    setTargetProjectedOffset(offset) {
      this.targetProjectedOffset.set(offset);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    storeParameters(record) {
      record.target.set(this.target);
      record.center.set(this.center);
      record.targetProjected.set(this.targetProjected);
      record.range = this.range;
      record.rangeEndpoints.set(this.rangeEndpoints);
      record.scaleFactor = this.geoProjection.getScaleFactor();
      record.rotation = this.getRotation();
      record.projectedSize.set(this.projectedSize);
      record.projectedResolution = this.getProjectedResolution();
    }
    computeChangeFlags(oldParameters) {
      return (oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target) | (Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected) | (oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range) | (VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints) | (oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize);
    }
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center) | (oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor) | (oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    project(point, out) {
      return this.geoProjection.project(point, out);
    }
    invert(vec, out) {
      return this.geoProjection.invert(vec, out);
    }
    isInProjectedBounds(point, bounds) {
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      if (!(point instanceof Float64Array)) {
        point = this.project(point, MapProjection.tempVec2_2);
      }
      const x = point[0];
      const y = point[1];
      return x >= left && x <= right && y >= top && y <= bottom;
    }
    geoDistance(point1, point2) {
      if (point1 instanceof Float64Array) {
        point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
      }
      if (point2 instanceof Float64Array) {
        point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
      }
      return point1.distance(point2);
    }
    projectedDistance(point1, point2) {
      if (!(point1 instanceof Float64Array)) {
        point1 = this.project(point1, MapProjection.tempVec2_1);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = this.project(point2, MapProjection.tempVec2_2);
      }
      return Vec2Math.distance(point1, point2);
    }
    notifyChangeListeners(changeFlags) {
      for (let i = 0; i < this.changeListeners.length; i++) {
        this.changeListeners[i](this, changeFlags);
      }
    }
    addChangeListener(listener) {
      this.changeListeners.push(listener);
    }
    removeChangeListener(listener) {
      const index = this.changeListeners.lastIndexOf(listener);
      if (index >= 0) {
        this.changeListeners.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
  };
  MapProjection.DEFAULT_SCALE_FACTOR = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
  MapProjection.SCALE_FACTOR_MAX_ITER = 20;
  MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
  MapProjection.tempVec2_1 = new Float64Array(2);
  MapProjection.tempVec2_2 = new Float64Array(2);
  MapProjection.tempVec2_3 = new Float64Array(2);
  MapProjection.tempVec2_4 = new Float64Array(2);
  MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
  MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);
  MapProjection.vec3Cache = [Vec3Math.create()];
  var MapComponent = class extends DisplayComponent {
    constructor(props) {
      var _a;
      super(props);
      this.layerEntries = [];
      this.lastUpdateTime = 0;
      this._isAwake = true;
      this.updateCycleHandler = this.update.bind(this);
      this.projectedSize = "isSubscribable" in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
      const initialSize = this.projectedSize.get();
      if (this.props.projection !== void 0) {
        this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
      }
      this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    getProjectedSize() {
      return this.mapProjection.getProjectedSize();
    }
    get isAwake() {
      return this._isAwake;
    }
    sleep() {
      this.setAwakeState(false);
    }
    wake() {
      this.setAwakeState(true);
    }
    setAwakeState(isAwake) {
      if (this._isAwake === isAwake) {
        return;
      }
      this._isAwake = isAwake;
      this._isAwake ? this.onWake() : this.onSleep();
    }
    onAfterRender(thisNode) {
      var _a;
      this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
      this.projectedSizeSub = this.projectedSize.sub((size) => {
        this.mapProjection.set({ projectedSize: size });
      });
      (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub((freq) => {
        var _a2;
        (_a2 = this.updateCycleSub) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.updateCycleSub = this.props.bus.getSubscriber().on("realTime").whenChanged().atFrequency(freq).handle(this.updateCycleHandler);
      }, true);
      this.attachLayers(thisNode);
    }
    attachLayers(thisNode) {
      FSComponent.visitNodes(thisNode, (node) => {
        if (node.instance instanceof MapLayer) {
          this.attachLayer(node.instance);
          return true;
        }
        return false;
      });
    }
    onWake() {
      this.wakeLayers();
    }
    wakeLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onWake();
      }
    }
    onSleep() {
      this.sleepLayers();
    }
    sleepLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onSleep();
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.onProjectedSizeChanged();
      }
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
      }
    }
    attachLayer(layer) {
      if (this.layerEntries.findIndex((entry2) => entry2.layer === layer) >= 0) {
        return;
      }
      const entry = new LayerEntry(layer);
      this.layerEntries.push(entry);
      entry.attach();
    }
    detachLayer(layer) {
      const index = this.layerEntries.findIndex((entry) => entry.layer === layer);
      if (index >= 0) {
        const entry = this.layerEntries[index];
        entry.detach();
        this.layerEntries.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    update(time) {
      if (!this._isAwake) {
        return;
      }
      this.onUpdated(time, time - this.lastUpdateTime);
      this.lastUpdateTime = time;
    }
    onUpdated(time, elapsed) {
      this.updateLayers(time, elapsed);
    }
    updateLayers(time, elapsed) {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].update(time);
      }
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].destroy();
      }
    }
  };
  var LayerEntry = class {
    constructor(layer) {
      this.layer = layer;
      this.updatePeriod = 0;
      this.lastUpdated = 0;
    }
    attach() {
      var _a, _b;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
        const clamped = Math.max(0, freq);
        this.updatePeriod = clamped === 0 ? 0 : 1e3 / clamped;
      }, true);
      this.layer.onAttached();
    }
    update(currentTime) {
      if (currentTime - this.lastUpdated >= this.updatePeriod) {
        this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
        this.lastUpdated = currentTime;
      }
    }
    detach() {
      var _a;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.layer.onDetached();
    }
    destroy() {
      this.detach();
      this.layer.destroy();
    }
  };
  var MapModel = class {
    constructor() {
      this.modules = /* @__PURE__ */ new Map();
    }
    getModule(nameOrModule) {
      if (typeof nameOrModule === "string") {
        return this.modules.get(nameOrModule);
      } else if (typeof nameOrModule === "function") {
        return this.modules.get(nameOrModule.name);
      }
      throw new Error("Invalid type supplied: must be a string key or a module constructor.");
    }
    addModule(name, module) {
      if (this.modules.has(name)) {
        return;
      }
      this.modules.set(name, module);
    }
  };
  var AbstractMapTextLabel = class {
    constructor(text, priority, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.text = SubscribableUtils.toSubscribable(text, true);
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
      this.font = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.font) !== null && _b !== void 0 ? _b : "", true);
      this.fontSize = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : 10, true);
      this.fontStr = MappedSubject.create(([s, f]) => {
        return `${s}px ${f}`;
      }, this.fontSize, this.font);
      this.fontColor = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _d !== void 0 ? _d : "white", true);
      this.fontOutlineWidth = SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _e !== void 0 ? _e : 0, true);
      this.fontOutlineColor = SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _f !== void 0 ? _f : "black", true);
      this.showBg = SubscribableUtils.toSubscribable((_g = options === null || options === void 0 ? void 0 : options.showBg) !== null && _g !== void 0 ? _g : false, true);
      this.bgColor = SubscribableUtils.toSubscribable((_h = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _h !== void 0 ? _h : "black", true);
      this.bgPadding = SubscribableUtils.toSubscribable((_j = options === null || options === void 0 ? void 0 : options.bgPadding) !== null && _j !== void 0 ? _j : VecNMath.create(4), true);
      this.bgBorderRadius = SubscribableUtils.toSubscribable((_k = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _k !== void 0 ? _k : 0, true);
      this.bgOutlineWidth = SubscribableUtils.toSubscribable((_l = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _l !== void 0 ? _l : 0, true);
      this.bgOutlineColor = SubscribableUtils.toSubscribable((_m = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _m !== void 0 ? _m : "white", true);
    }
    draw(context, mapProjection) {
      if (this.fontSize.get() !== 0) {
        this.setTextStyle(context);
        const width = context.measureText(this.text.get()).width;
        const height = this.fontSize.get();
        const showBg = this.showBg.get();
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        const bgExtraWidth = showBg ? bgPadding[1] + bgPadding[3] + bgOutlineWidth * 2 : 0;
        const bgExtraHeight = showBg ? bgPadding[0] + bgPadding[2] + bgOutlineWidth * 2 : 0;
        const anchor = this.anchor.get();
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (anchor[0] - 0.5) * (width + bgExtraWidth);
        const centerY = pos[1] - (anchor[1] - 0.5) * (height + bgExtraHeight);
        if (showBg) {
          this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
      }
    }
    setTextStyle(context) {
      context.font = this.fontStr.get();
      context.textBaseline = "middle";
      context.textAlign = "center";
    }
    drawText(context, centerX, centerY) {
      const text = this.text.get();
      const fontOutlineWidth = this.fontOutlineWidth.get();
      if (fontOutlineWidth > 0) {
        context.lineWidth = fontOutlineWidth * 2;
        context.strokeStyle = this.fontOutlineColor.get();
        context.strokeText(text, centerX, centerY);
      }
      context.fillStyle = this.fontColor.get();
      context.fillText(text, centerX, centerY);
    }
    drawBackground(context, centerX, centerY, width, height) {
      const bgPadding = this.bgPadding.get();
      const bgOutlineWidth = this.bgOutlineWidth.get();
      const bgBorderRadius = this.bgBorderRadius.get();
      const backgroundLeft = centerX - width / 2 - (bgPadding[3] + bgOutlineWidth);
      const backgroundTop = centerY - height / 2 - (bgPadding[0] + bgOutlineWidth);
      const backgroundWidth = width + (bgPadding[1] + bgPadding[3] + 2 * bgOutlineWidth);
      const backgroundHeight = height + (bgPadding[0] + bgPadding[2] + 2 * bgOutlineWidth);
      let isRounded = false;
      if (bgBorderRadius > 0) {
        isRounded = true;
        this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, bgBorderRadius);
      }
      if (bgOutlineWidth > 0) {
        context.lineWidth = bgOutlineWidth * 2;
        context.strokeStyle = this.bgOutlineColor.get();
        if (isRounded) {
          context.stroke();
        } else {
          context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
      }
      context.fillStyle = this.bgColor.get();
      if (isRounded) {
        context.fill();
      } else {
        context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
      }
    }
    loadBackgroundPath(context, left, top, width, height, radius) {
      const right = left + width;
      const bottom = top + height;
      context.beginPath();
      context.moveTo(left + radius, top);
      context.lineTo(right - radius, top);
      context.arcTo(right, top, right, top + radius, radius);
      context.lineTo(right, bottom - radius);
      context.arcTo(right, bottom, right - radius, bottom, radius);
      context.lineTo(left + radius, bottom);
      context.arcTo(left, bottom, left, bottom - radius, radius);
      context.lineTo(left, top + radius);
      context.arcTo(left, top, left + radius, top, radius);
    }
  };
  AbstractMapTextLabel.tempVec2 = new Float64Array(2);
  var MapLocationTextLabel = class extends AbstractMapTextLabel {
    constructor(text, priority, location, options) {
      var _a;
      super(text, priority, options);
      this.location = SubscribableUtils.toSubscribable(location, true);
      this.offset = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
    }
    getPosition(mapProjection, out) {
      mapProjection.project(this.location.get(), out);
      Vec2Math.add(out, this.offset.get(), out);
      return out;
    }
  };
  var MapCullableLocationTextLabel = class extends MapLocationTextLabel {
    constructor(text, priority, location, alwaysShow, options) {
      super(text, priority, location, options);
      this.bounds = new Float64Array(4);
      this.invalidation = new SubEvent();
      this.subs = [];
      this.alwaysShow = SubscribableUtils.toSubscribable(alwaysShow, true);
      this.subs.push(this.priority.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.alwaysShow.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.location.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.text.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.fontSize.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.anchor.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.offset.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgPadding.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgOutlineWidth.sub(() => {
        this.invalidation.notify(this);
      }));
    }
    updateBounds(mapProjection) {
      const fontSize = this.fontSize.get();
      const anchor = this.anchor.get();
      const width = 0.6 * fontSize * this.text.get().length;
      const height = fontSize;
      const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
      let left = pos[0] - anchor[0] * width;
      let right = left + width;
      let top = pos[1] - anchor[1] * height;
      let bottom = top + height;
      if (this.showBg.get()) {
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        left -= bgPadding[3] + bgOutlineWidth;
        right += bgPadding[1] + bgOutlineWidth;
        top -= bgPadding[0] + bgOutlineWidth;
        bottom += bgPadding[2] + bgOutlineWidth;
      }
      this.bounds[0] = left;
      this.bounds[1] = top;
      this.bounds[2] = right;
      this.bounds[3] = bottom;
    }
    destroy() {
      for (const sub of this.subs) {
        sub.destroy();
      }
    }
  };
  var MapCullableTextLabelManager = class {
    constructor(cullingEnabled = true) {
      this.cullingEnabled = cullingEnabled;
      this.registered = /* @__PURE__ */ new Map();
      this._visibleLabels = [];
      this.needUpdate = false;
      this.lastScaleFactor = 1;
      this.lastRotation = 0;
      this.invalidationHandler = () => {
        this.needUpdate = true;
      };
    }
    get visibleLabels() {
      return this._visibleLabels;
    }
    register(label) {
      if (this.registered.has(label)) {
        return;
      }
      this.registered.set(label, label.invalidation.on(this.invalidationHandler));
      this.needUpdate = true;
    }
    deregister(label) {
      const sub = this.registered.get(label);
      if (sub === void 0) {
        return;
      }
      sub.destroy();
      this.registered.delete(label);
      this.needUpdate = true;
    }
    setCullingEnabled(enabled) {
      this.cullingEnabled = enabled;
      this.needUpdate = true;
    }
    update(mapProjection) {
      if (!this.needUpdate) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
        if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
          const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
          if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
            return;
          }
        }
      }
      this._visibleLabels = [];
      if (this.cullingEnabled) {
        const labelArray = Array.from(this.registered.keys());
        const len = labelArray.length;
        for (let i = 0; i < len; i++) {
          labelArray[i].updateBounds(mapProjection);
        }
        labelArray.sort(MapCullableTextLabelManager.SORT_FUNC);
        const collisionArray = [];
        for (let i = 0; i < len; i++) {
          const label = labelArray[i];
          let show = true;
          if (!label.alwaysShow.get()) {
            const len2 = collisionArray.length;
            for (let j = 0; j < len2; j++) {
              const other = collisionArray[j];
              if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                show = false;
                break;
              }
            }
          }
          if (show) {
            collisionArray.push(label.bounds);
            this._visibleLabels.push(label);
          }
        }
      } else {
        this._visibleLabels.push(...this.registered.keys());
      }
      this.lastScaleFactor = mapProjection.getScaleFactor();
      this.lastRotation = mapProjection.getRotation();
      this.needUpdate = false;
    }
    static doesCollide(a, b) {
      return a[0] < b[2] && a[2] > b[0] && a[1] < b[3] && a[3] > b[1];
    }
  };
  MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
  MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;
  MapCullableTextLabelManager.SORT_FUNC = (a, b) => {
    const alwaysShowA = a.alwaysShow.get();
    const alwaysShowB = b.alwaysShow.get();
    if (alwaysShowA && !alwaysShowB) {
      return -1;
    } else if (alwaysShowB && !alwaysShowA) {
      return 1;
    } else {
      return b.priority.get() - a.priority.get();
    }
  };
  var AbstractMapWaypointIcon = class {
    constructor(waypoint, priority, size, options) {
      var _a, _b;
      this.waypoint = waypoint;
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.size = SubscribableUtils.toSubscribable(size, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(0.5, 0.5), true);
      this.offset = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.offset) !== null && _b !== void 0 ? _b : Vec2Math.create(), true);
    }
    draw(context, mapProjection) {
      const size = this.size.get();
      const offset = this.offset.get();
      const anchor = this.anchor.get();
      const projected = mapProjection.project(this.waypoint.location.get(), MapWaypointImageIcon.tempVec2);
      const left = projected[0] + offset[0] - anchor[0] * size[0];
      const top = projected[1] + offset[1] - anchor[1] * size[1];
      this.drawIconAt(context, mapProjection, left, top);
    }
  };
  AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
  var MapWaypointImageIcon = class extends AbstractMapWaypointIcon {
    constructor(waypoint, priority, img, size, options) {
      super(waypoint, priority, size, options);
      this.img = img;
    }
    drawIconAt(context, mapProjection, left, top) {
      const size = this.size.get();
      context.drawImage(this.img, left, top, size[0], size[1]);
    }
  };
  var MapWaypointRenderer = class {
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
      this.textManager = textManager;
      this.selectRoleToRender = selectRoleToRender;
      this.registered = /* @__PURE__ */ new Map();
      this.toCleanUp = /* @__PURE__ */ new Set();
      this.roleDefinitions = /* @__PURE__ */ new Map();
      this.onWaypointAdded = new SubEvent();
      this.onWaypointRemoved = new SubEvent();
    }
    hasRenderRole(role) {
      return this.roleDefinitions.has(role);
    }
    addRenderRole(role, def) {
      if (this.roleDefinitions.has(role)) {
        return false;
      }
      this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
      return true;
    }
    removeRenderRole(role) {
      return this.roleDefinitions.delete(role);
    }
    getRenderRoleDefinition(role) {
      return this.roleDefinitions.get(role);
    }
    renderRoles() {
      return this.roleDefinitions.keys();
    }
    clearRenderRoles() {
      this.roleDefinitions.clear();
    }
    setIconFactory(role, factory) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.iconFactory = factory;
      return true;
    }
    setLabelFactory(role, factory) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.labelFactory = factory;
      return true;
    }
    setCanvasContext(role, context) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.canvasContext = context;
      return true;
    }
    setVisibilityHandler(role, handler) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.visibilityHandler = handler;
      return true;
    }
    isRegistered(waypoint, role) {
      if (!waypoint) {
        return false;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return false;
      }
      if (role === void 0) {
        return true;
      }
      return entry.isAllRoles(role);
    }
    register(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      let entry = this.registered.get(waypoint.uid);
      if (!entry) {
        entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
        this.registered.set(waypoint.uid, entry);
        this.onWaypointAdded.notify(this, waypoint);
      }
      entry.addRole(role, sourceId);
    }
    deregister(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return;
      }
      entry.removeRole(role, sourceId);
      if (entry.roles === 0) {
        this.deleteEntry(entry);
        this.onWaypointRemoved.notify(this, waypoint);
      }
    }
    deleteEntry(entry) {
      this.registered.delete(entry.waypoint.uid);
      this.toCleanUp.add(entry);
    }
    update(mapProjection) {
      var _a;
      this.toCleanUp.forEach((entry) => {
        entry.destroy();
      });
      this.toCleanUp.clear();
      const entriesToDrawIcon = [];
      this.registered.forEach((entry) => {
        entry.update();
        if (entry.icon) {
          entriesToDrawIcon.push(entry);
        }
      });
      const projectedSize = mapProjection.getProjectedSize();
      for (const roleDef of this.roleDefinitions.values()) {
        const context = roleDef.canvasContext;
        if (context) {
          context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
        }
      }
      entriesToDrawIcon.sort(MapWaypointRenderer.ENTRY_SORT_FUNC);
      const len2 = entriesToDrawIcon.length;
      for (let i = 0; i < len2; i++) {
        const entry = entriesToDrawIcon[i];
        const icon = entry.icon;
        const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
        if (context) {
          icon.draw(context, mapProjection);
        }
      }
    }
    getNearestWaypoint(pos, first) {
      var _a, _b;
      const ordered = [...this.registered.values()].sort((a, b) => this.orderByDistance(a.waypoint, b.waypoint, pos)).filter((w) => {
        const roleDef = this.getRenderRoleDefinition(w.lastRenderedRole);
        if (roleDef !== void 0) {
          return roleDef.visibilityHandler(w.waypoint);
        }
        return false;
      });
      if (first !== void 0) {
        return (_a = ordered.find((entry) => first(entry.waypoint))) === null || _a === void 0 ? void 0 : _a.waypoint;
      }
      return (_b = ordered[0]) === null || _b === void 0 ? void 0 : _b.waypoint;
    }
    orderByDistance(a, b, pos) {
      const aDist = a.location.get().distance(pos);
      const bDist = b.location.get().distance(pos);
      return aDist - bDist;
    }
  };
  MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
  };
  MapWaypointRenderer.ENTRY_SORT_FUNC = (a, b) => {
    return a.icon.priority.get() - b.icon.priority.get();
  };
  MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
      if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
        return role;
      }
    }
    return 0;
  };
  var MapWaypointRendererEntry = class {
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
      this.waypoint = waypoint;
      this.textManager = textManager;
      this.roleDefinitions = roleDefinitions;
      this.selectRoleToRender = selectRoleToRender;
      this.registrations = {};
      this._roles = 0;
      this._icon = null;
      this._label = null;
      this._lastRenderedRole = 0;
    }
    get roles() {
      return this._roles;
    }
    get lastRenderedRole() {
      return this._lastRenderedRole;
    }
    get icon() {
      return this._icon;
    }
    get label() {
      return this._label;
    }
    isAnyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAny(toCompare, roles);
    }
    isOnlyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return toCompare === roles;
    }
    isAllRoles(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAll(toCompare, roles);
    }
    addRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        var _a;
        var _b, _c;
        ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : _b[_c] = /* @__PURE__ */ new Set()).add(sourceId);
      }, true);
      this._roles = this._roles | roles;
    }
    removeRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        const role = 1 << index;
        const registrations = this.registrations[role];
        if (registrations) {
          registrations.delete(sourceId);
          if (registrations.size === 0) {
            this._roles = this._roles & ~role;
          }
        }
      }, true);
    }
    prepareRender(showRole, iconFactory, labelFactory) {
      var _a, _b;
      if (showRole === this._lastRenderedRole) {
        return;
      }
      this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
      const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
      if (this._label && this._label !== label) {
        this.textManager.deregister(this._label);
      }
      if (label && label !== this._label) {
        this.textManager.register(label);
      }
      this._label = label;
      this._lastRenderedRole = showRole;
    }
    update() {
      var _a, _b;
      const showRole = this.selectRoleToRender(this, this.roleDefinitions);
      const roleDef = this.roleDefinitions.get(showRole);
      const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
      const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
      this.prepareRender(showRole, iconFactory, labelFactory);
    }
    destroy() {
      if (this._label) {
        this.textManager.deregister(this._label);
      }
    }
  };
  var NullPathStream = class {
    beginPath() {
    }
    moveTo() {
    }
    lineTo() {
    }
    bezierCurveTo() {
    }
    quadraticCurveTo() {
    }
    arc() {
    }
    closePath() {
    }
  };
  NullPathStream.INSTANCE = new NullPathStream();
  var AbstractTransformingPathStream = class {
    constructor(consumer) {
      this.consumer = consumer;
    }
    getConsumer() {
      return this.consumer;
    }
    setConsumer(consumer) {
      this.consumer = consumer;
    }
  };
  var Outcode;
  (function(Outcode2) {
    Outcode2[Outcode2["Inside"] = 0] = "Inside";
    Outcode2[Outcode2["Left"] = 1] = "Left";
    Outcode2[Outcode2["Top"] = 2] = "Top";
    Outcode2[Outcode2["Right"] = 4] = "Right";
    Outcode2[Outcode2["Bottom"] = 8] = "Bottom";
  })(Outcode || (Outcode = {}));
  var ClippedPathStream = class extends AbstractTransformingPathStream {
    constructor(consumer, bounds) {
      super(consumer);
      this.bounds = bounds;
      this.boundsHandler = this.onBoundsChanged.bind(this);
      this.boundsLines = [
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3)
      ];
      this.isBoundingRectNonZero = false;
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.prevPointOutcode = 0;
      bounds.sub(this.boundsHandler, true);
    }
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    moveTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
      if (this.prevPointOutcode === 0) {
        this.consumer.moveTo(x, y);
      }
    }
    lineTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      const outcode = this.getOutcode(x, y);
      if ((this.prevPointOutcode | outcode) === 0) {
        this.consumer.lineTo(x, y);
      } else if ((this.prevPointOutcode & outcode) === 0) {
        const bounds = this.bounds.get();
        const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
        let entryPoint, exitPoint;
        const outcodeOr = this.prevPointOutcode | outcode;
        if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              break;
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              break;
            }
          }
        } else {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                entryPoint = intersection;
                break;
              }
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                exitPoint = intersection;
                break;
              }
            }
          }
        }
        if (entryPoint) {
          this.consumer.moveTo(entryPoint[0], entryPoint[1]);
        }
        if (exitPoint) {
          this.consumer.lineTo(exitPoint[0], exitPoint[1]);
        } else if (outcode === Outcode.Inside) {
          this.consumer.lineTo(x, y);
        }
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = outcode;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const pi2 = 2 * Math.PI;
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
      const bounds = this.bounds.get();
      const radiusSq = radius * radius;
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
      const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
      const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const intersections = ClippedPathStream.intersectionCache;
      let intersectionCount = 0;
      for (let i = 0; i < 4; i++) {
        const axisCoordIndex = i % 2;
        const crossAxisCoordIndex = (i + 1) % 2;
        const centerAxisCoord = i % 2 === 0 ? x : y;
        const centerCrossAxisCoord = i % 2 === 0 ? y : x;
        const deltaToBound = bounds[i] - centerAxisCoord;
        if (Math.abs(deltaToBound) < radius) {
          const crossAxisBoundMin = bounds[crossAxisCoordIndex];
          const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
          const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
          let intersectionRadialOffset;
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
        }
      }
      let isOutside = startPointOutcode !== Outcode.Inside;
      const startAngleNormalized = (startAngle % pi2 + pi2) % pi2;
      let lastRadial = startAngleNormalized;
      let intersectionStartIndex = -1;
      let minAngularDiff = Infinity;
      for (let i = 0; i < intersectionCount; i++) {
        const angularDiff = ((intersections[i].radial - startAngleNormalized) * directionSign + pi2) % pi2;
        if (angularDiff < minAngularDiff) {
          intersectionStartIndex = i;
          minAngularDiff = angularDiff;
        }
      }
      if (intersectionStartIndex >= 0) {
        for (let i = 0; i < intersectionCount; i++) {
          const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
          const intersection = intersections[index];
          if (((intersection.radial - startAngleNormalized) * directionSign + pi2) % pi2 >= angularWidth) {
            break;
          }
          if (isOutside) {
            this.consumer.moveTo(intersection.point[0], intersection.point[1]);
          } else {
            const segmentAngularWidth = ((intersection.radial - lastRadial) * directionSign + pi2) % pi2;
            this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
          }
          isOutside = !isOutside;
          lastRadial = intersection.radial;
        }
      }
      const endAngleNormalized = (startAngleNormalized + angularWidth * directionSign + pi2) % pi2;
      if (!isOutside) {
        const segmentAngularWidth = ((endAngleNormalized - lastRadial) * directionSign + pi2) % pi2;
        this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
        if (Math.abs((endAngleNormalized - endAngle) % pi2) > 1e-14) {
          this.consumer.moveTo(endPoint[0], endPoint[1]);
        }
      }
      Vec2Math.copy(endPoint, this.prevPoint);
      this.prevPointOutcode = endPointOutcode;
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.prevPointOutcode = 0;
    }
    getOutcode(x, y) {
      const bounds = this.bounds.get();
      let code = 0;
      if (x < bounds[0]) {
        code |= Outcode.Left;
      } else if (x > bounds[2]) {
        code |= Outcode.Right;
      }
      if (y < bounds[1]) {
        code |= Outcode.Top;
      } else if (y > bounds[3]) {
        code |= Outcode.Bottom;
      }
      return code;
    }
    onBoundsChanged() {
      const bounds = this.bounds.get();
      Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
      Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
      Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
      Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
      this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
      this.beginPath();
    }
    destroy() {
      this.bounds.unsub(this.boundsHandler);
    }
    static getLineCoordinates(x1, y1, x2, y2, out) {
      const a = y1 - y2;
      const b = x2 - x1;
      const c = -(a * x1 + b * y1);
      return Vec3Math.set(a, b, c, out);
    }
    static findLineLineIntersection(line1, line2, out) {
      const cross = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
      const w = cross[2];
      if (w === 0) {
        return void 0;
      }
      return Vec2Math.set(cross[0] / w, cross[1] / w, out);
    }
  };
  ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: 0 };
  });
  var GeoProjectionPathStream = class extends AbstractTransformingPathStream {
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.projection = projection;
      this.firstPoint = new GeoPoint(NaN, NaN);
      this.prevPoint = new GeoPoint(NaN, NaN);
      this.prevPointProjected = new Float64Array(2);
      this.resampleHandler = this.onResampled.bind(this);
      if (arg1 instanceof GeoCircleResampler) {
        this.resampler = arg1;
      } else {
        this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
      }
    }
    getProjection() {
      return this.projection;
    }
    setProjection(projection) {
      this.projection = projection;
    }
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    moveTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (isNaN(this.firstPoint.lat)) {
        this.firstPoint.set(lat, lon);
      }
      this.prevPoint.set(lat, lon);
      const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
      this.consumer.moveTo(projected[0], projected[1]);
    }
    lineTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(lon, lat);
        return;
      }
      const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
      const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
      if (!isFinite(circle.center[0])) {
        throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
      }
      this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
      this.prevPoint.set(lat, lon);
    }
    bezierCurveTo() {
      throw new Error("GeodesicResamplerStream: bezierCurveTo() is not supported");
    }
    quadraticCurveTo() {
      throw new Error("GeodesicResamplerStream: quadraticCurveTo() is not supported");
    }
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        return;
      }
      if (MathUtils.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
        const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
        this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
        this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
        return;
      }
      const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
      const start = GeoProjectionPathStream.geoPointCache[2];
      const end = GeoProjectionPathStream.geoPointCache[3];
      if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        const circleLat = Math.sign(lat) * (MathUtils.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
        start.set(circleLat, startAngle);
        end.set(circleLat, endAngle);
      } else {
        center.offset(startAngle, radius, start);
        center.offset(endAngle, radius, end);
      }
      if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(start.lon, start.lat);
      } else if (!start.equals(this.prevPoint)) {
        this.lineTo(start.lon, start.lat);
      }
      const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
      if (!counterClockwise) {
        circle.reverse();
      }
      this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
      this.prevPoint.set(end);
    }
    closePath() {
      if (!isNaN(this.firstPoint.lat)) {
        this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
      }
    }
    reset() {
      this.firstPoint.set(NaN, NaN);
      this.prevPoint.set(NaN, NaN);
    }
    onResampled(vector) {
      switch (vector.type) {
        case "start":
          return;
        case "line":
          this.consumer.lineTo(vector.projected[0], vector.projected[1]);
          break;
        case "arc":
          this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
          break;
      }
      Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
  };
  GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var AffineTransformPathStream = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.transform = new Transform2D();
      this.concatCache = [];
      this.scale = 1;
      this.rotation = 0;
    }
    addTranslation(x, y, order = "after") {
      const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
      if (order === "before") {
        this.concatCache[0] = translation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = translation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      return this;
    }
    addScale(factor, order = "after") {
      const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
      if (order === "before") {
        this.concatCache[0] = scale;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = scale;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    addRotation(angle, order = "after") {
      const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
      if (order === "before") {
        this.concatCache[0] = rotation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = rotation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    resetTransform() {
      this.transform.toIdentity();
      this.updateScaleRotation();
      return this;
    }
    beginPath() {
      this.consumer.beginPath();
    }
    moveTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.moveTo(transformed[0], transformed[1]);
    }
    lineTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.lineTo(transformed[0], transformed[1]);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      const cp1Transformed = this.applyTransform(cp1x, cp1y);
      cp1x = cp1Transformed[0];
      cp1y = cp1Transformed[1];
      const cp2Transformed = this.applyTransform(cp2x, cp2y);
      cp2x = cp2Transformed[0];
      cp2y = cp2Transformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      const cpTransformed = this.applyTransform(cpx, cpy);
      cpx = cpTransformed[0];
      cpy = cpTransformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      const transformed = this.applyTransform(x, y);
      this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    closePath() {
      this.consumer.closePath();
    }
    updateScaleRotation() {
      const params = this.transform.getParameters();
      this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
      this.rotation = Math.atan2(params[3], params[0]);
    }
    applyTransform(x, y) {
      const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
      return this.transform.apply(vec, vec);
    }
  };
  AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
  AffineTransformPathStream.transformCache = [new Transform2D()];
  var PatternPathStream = class {
    constructor(consumer, pattern) {
      this.pattern = pattern;
      this.clipBounds = VecNSubject.createFromVector(new Float64Array([Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]));
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.distanceLeft = NaN;
      this.transformStream = new AffineTransformPathStream(consumer);
      this.clipStream = new ClippedPathStream(this.transformStream, this.clipBounds);
    }
    getPattern() {
      return this.pattern;
    }
    setPattern(pattern) {
      if (!isNaN(this.distanceLeft) && this.pattern) {
        this.distanceLeft = Math.max(0, this.distanceLeft - this.pattern.anchor * this.pattern.length);
      }
      this.pattern = pattern;
      if (pattern) {
        if (!isNaN(this.distanceLeft)) {
          this.distanceLeft += pattern.anchor * pattern.length;
        }
      } else {
        this.distanceLeft = NaN;
      }
    }
    getConsumer() {
      return this.transformStream.getConsumer();
    }
    setConsumer(consumer) {
      this.transformStream.setConsumer(consumer);
    }
    beginPath() {
      this.reset();
      this.getConsumer().beginPath();
    }
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.distanceLeft = NaN;
    }
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.pattern) {
        const x0 = this.prevPoint[0];
        const y0 = this.prevPoint[1];
        const dx = x - x0;
        const dy = y - y0;
        const distance = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        this.transformStream.resetTransform().addRotation(angle).addTranslation(x0, y0);
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            this.transformStream.addTranslation(distanceToNextAnchor, 0, "before");
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            this.transformStream.addTranslation(distanceToPatternEnd, 0, "before");
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().lineTo(x, y);
      }
      Vec2Math.set(x, y, this.prevPoint);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this.moveTo(x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, PatternPathStream.vec2Cache[1]), PatternPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      if (this.pattern) {
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
          const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
          endAngle = startAngle + angleDiff * directionSign;
        }
        const angularWidth = (endAngle - startAngle) * directionSign;
        const distance = angularWidth * radius;
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          let angle = startAngle;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            angle += distanceToNextAnchor / radius * directionSign;
            this.transformStream.resetTransform().addRotation(Math.PI / 2 * directionSign).addTranslation(radius, 0).addRotation(angle).addTranslation(x, y);
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            angle += distanceToPatternEnd / radius * directionSign;
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().arc(x, y, radius, startAngle, endAngle, counterClockwise);
      }
      Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, endAngle, PatternPathStream.vec2Cache[1]), this.prevPoint);
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.distanceLeft = NaN;
    }
  };
  PatternPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var TransformingPathStreamStack = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.stack = [];
    }
    push(stream) {
      var _a;
      stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
      this.stack.push(stream);
    }
    pop() {
      const removed = this.stack.pop();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      return removed;
    }
    unshift(stream) {
      const displaced = this.stack[0];
      displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
      stream.setConsumer(this.consumer);
      this.stack.unshift(stream);
    }
    shift() {
      var _a;
      const removed = this.stack.shift();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
      return removed;
    }
    setConsumer(consumer) {
      var _a;
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    beginPath() {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    moveTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    lineTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    closePath() {
      this.stack[this.stack.length - 1].closePath();
    }
  };
  var GeoProjectionPathStreamStack = class extends AbstractTransformingPathStream {
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.postStack = new TransformingPathStreamStack(consumer);
      if (arg1 instanceof GeoCircleResampler) {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
      } else {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
      }
      this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    getProjection() {
      return this.projectionStream.getProjection();
    }
    setProjection(projection) {
      this.projectionStream.setProjection(projection);
    }
    pushPreProjected(stream) {
      this.preStack.push(stream);
    }
    popPreProjected() {
      return this.preStack.pop();
    }
    unshiftPreProjected(stream) {
      this.preStack.unshift(stream);
    }
    shiftPreProjected() {
      return this.preStack.shift();
    }
    pushPostProjected(stream) {
      this.postStack.push(stream);
    }
    popPostProjected() {
      return this.postStack.pop();
    }
    unshiftPostProjected(stream) {
      this.postStack.unshift(stream);
    }
    shiftPostProjected() {
      return this.postStack.shift();
    }
    setConsumer(consumer) {
      this.postStack.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    beginPath() {
      this.preStack.beginPath();
    }
    moveTo(x, y) {
      this.preStack.moveTo(x, y);
    }
    lineTo(x, y) {
      this.preStack.lineTo(x, y);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    closePath() {
      this.preStack.closePath();
    }
  };
  var GeoCirclePathRenderer = class {
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
      if (!continuePath) {
        streamStack.beginPath();
        streamStack.moveTo(startLon, startLat);
      }
      if (circle.isGreatCircle()) {
        const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
        const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
          const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
          const midLat = midPoint.lat;
          const midLon = midPoint.lon;
          streamStack.lineTo(midLon, midLat);
          streamStack.lineTo(endLon, endLat);
        } else {
          streamStack.lineTo(endLon, endLat);
        }
      } else {
        const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
        const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
        let startAngle, endAngle;
        if (isCenterPole) {
          startAngle = startLon;
          endAngle = endLon;
        } else {
          startAngle = turnCenter.bearingTo(startLat, startLon);
          endAngle = turnCenter.bearingTo(endLat, endLon);
        }
        streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === "left");
      }
    }
  };
  GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
  GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];
  var GeoCircleLineRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
    }
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash, outlineWidth = 0, outlineStyle = "black") {
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
      if (outlineWidth > 0) {
        context.lineWidth = width + outlineWidth * 2;
        context.strokeStyle = outlineStyle;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
      context.stroke();
    }
  };
  GeoCircleLineRenderer.EMPTY_DASH = [];
  var GeoCirclePatternRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
      this.patternStream = new PatternPathStream(NullPathStream.INSTANCE, null);
    }
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, pattern, continuePath = false) {
      this.patternStream.setPattern(pattern);
      streamStack.unshiftPostProjected(this.patternStream);
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath);
      streamStack.shiftPostProjected();
    }
  };
  var AbstractFlightPathPlanRenderer = class {
    constructor(renderOrder = "forward", renderActiveLegLast = true) {
      this.renderOrder = renderOrder;
      this.renderActiveLegLast = renderActiveLegLast;
    }
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
      startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0;
      endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = plan.length - 1;
      const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
      const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : void 0;
      const isReverse = this.renderOrder === "reverse";
      if (isReverse) {
        const oldEndIndex = endIndex;
        endIndex = startIndex;
        startIndex = oldEndIndex;
      }
      let index = startIndex;
      const delta = isReverse ? -1 : 1;
      for (const leg of plan.legs(isReverse, startIndex)) {
        if ((index - endIndex) * delta > 0) {
          break;
        }
        if (this.renderActiveLegLast && index === activeLegIndex) {
          index += delta;
          continue;
        }
        this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
        index += delta;
      }
      if (this.renderActiveLegLast && activeLeg) {
        this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
      }
    }
  };
  var FlightPathLegRenderPart;
  (function(FlightPathLegRenderPart2) {
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["None"] = 0] = "None";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Ingress"] = 1] = "Ingress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Base"] = 2] = "Base";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Egress"] = 4] = "Egress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["All"] = 7] = "All";
  })(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
  var AbstractFlightPathLegRenderer = class {
    constructor() {
      this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    render(leg, context, streamStack, partsToRender, ...args) {
      const legCalc = leg.calculated;
      if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
        return;
      }
      const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
      const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
      const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
      let mainVectors = legCalc.ingressToEgress;
      let mainVectorStartIndex = 0;
      let mainVectorEndIndex = legCalc.ingressToEgress.length;
      if (excludeIngress || excludeEgress) {
        mainVectors = legCalc.flightPath;
        mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
      }
      if (!excludeIngress) {
        for (let i = 0; i < legCalc.ingress.length; i++) {
          this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
        }
        if (excludeEgress && !excludeBase) {
          mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
          const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
          const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
          if (lastIngressVector && ingressJoinVector) {
            const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            if (!ingressEnd.equals(vectorEnd)) {
              const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
            mainVectorStartIndex++;
          }
        }
      }
      if (!excludeBase) {
        const len = Math.min(mainVectorEndIndex, mainVectors.length);
        for (let i = mainVectorStartIndex; i < len; i++) {
          this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
        }
      }
      if (!excludeEgress) {
        if (excludeIngress && !excludeBase) {
          const firstEgressVector = legCalc.egress[0];
          const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
          if (firstEgressVector && egressJoinVector) {
            const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
            const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
            if (!egressStart.equals(egressJoinVectorStart)) {
              const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
          }
        }
        for (let i = 0; i < legCalc.egress.length; i++) {
          this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
        }
      }
    }
  };
  AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathLegLineRenderer = class extends AbstractFlightPathLegRenderer {
    constructor(styleSelector) {
      super();
      this.styleSelector = styleSelector;
      this.pathRenderer = new GeoCirclePathRenderer();
      this.styleBuffer = [
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        },
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        }
      ];
      this.activeStyleIndex = 0;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = false;
    }
    render(leg, context, streamStack, partsToRender, ...args) {
      this.isAtLegStart = true;
      this.needStrokeLineAtLegEnd = false;
      super.render(leg, context, streamStack, partsToRender, ...args);
      if (this.needStrokeLineAtLegEnd) {
        this.strokeLine(context, this.styleBuffer[(this.activeStyleIndex + 1) % 2]);
        this.needStrokeLineAtLegEnd = false;
      }
    }
    renderVector(vector, isIngress, isEgress, leg, context, streamStack, ...args) {
      const style = this.styleSelector(vector, isIngress, isEgress, leg, streamStack.getProjection(), this.styleBuffer[this.activeStyleIndex], ...args);
      const previousStyle = this.styleBuffer[(this.activeStyleIndex + 1) % 2];
      const didStyleChange = !this.isAtLegStart && !FlightPathLegLineRenderer.areStylesEqual(style, previousStyle);
      const continuePath = !this.isAtLegStart && style.isContinuous && !didStyleChange;
      if (didStyleChange) {
        this.strokeLine(context, previousStyle);
        this.needStrokeLineAtLegEnd = false;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathLegLineRenderer.geoCircleCache[1]);
      this.pathRenderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, streamStack, continuePath);
      this.activeStyleIndex = (this.activeStyleIndex + 1) % 2;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = true;
    }
    strokeLine(context, style) {
      var _a, _b;
      if (style.outlineWidth > 0) {
        const outlineWidth = style.strokeWidth + 2 * style.outlineWidth;
        context.lineWidth = outlineWidth;
        context.strokeStyle = style.outlineStyle;
        context.setLineDash((_a = style.outlineDash) !== null && _a !== void 0 ? _a : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      if (style.strokeWidth > 0) {
        context.lineWidth = style.strokeWidth;
        context.strokeStyle = style.strokeStyle;
        context.setLineDash((_b = style.strokeDash) !== null && _b !== void 0 ? _b : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
    }
    static areStylesEqual(style1, style2) {
      return (style1.strokeWidth === 0 && style2.strokeWidth === 0 || style1.strokeWidth === style2.strokeWidth && style1.strokeStyle === style2.strokeStyle && style1.strokeDash === style2.strokeDash) && (style1.outlineWidth === 0 && style2.outlineWidth === 0 || style1.outlineWidth === style2.outlineWidth && style1.outlineStyle === style2.outlineStyle && style1.outlineDash === style2.outlineDash);
    }
  };
  FlightPathLegLineRenderer.EMPTY_DASH = [];
  FlightPathLegLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorPatternRenderer = class {
    constructor() {
      this.renderer = new GeoCirclePatternRenderer();
    }
    render(vector, context, streamStack, pattern, continuePath = false) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorPatternRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, pattern, continuePath);
    }
  };
  FlightPathVectorPatternRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorLineRenderer = class {
    constructor() {
      this.renderer = new GeoCircleLineRenderer();
    }
    render(vector, context, streamStack, width, style, dash, outlineWidth, outlineStyle) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash, outlineWidth, outlineStyle);
    }
  };
  FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MapAbstractAirspaceRenderer = class {
    render(airspace, projection, context, lod = 0, stream) {
      const shapes = airspace.lods[lod];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        this.renderShape(shapes[i], projection, context, stream);
      }
    }
  };
  var MapSingleLineAirspaceRenderer = class extends MapAbstractAirspaceRenderer {
    constructor(lineWidth, strokeStyle, dash) {
      super();
      this.lineWidth = lineWidth;
      this.strokeStyle = strokeStyle;
      this.dash = dash;
    }
    renderShape(shape, projection, context, stream) {
      if (shape.length < 2) {
        return;
      }
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const firstProjected = projection.project(shape[0].end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.moveTo(firstProjected[0], firstProjected[1]);
      let start = shape[0].end;
      const len = shape.length;
      for (let i = 1; i < len; i++) {
        const vector = shape[i];
        const circle = vector.circle;
        if (circle) {
          if (circle.isGreatCircle()) {
            this.pathGreatCircle(circle, start, vector.end, projection, stream);
          } else {
            this.pathSmallCircle(circle, start, vector.end, projection, stream);
          }
        } else {
          const endProjected = projection.project(vector.end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
          stream.moveTo(endProjected[0], endProjected[1]);
        }
        start = vector.end;
      }
      context.lineWidth = this.lineWidth;
      context.strokeStyle = this.strokeStyle;
      context.setLineDash(this.dash);
      context.stroke();
    }
    pathGreatCircle(circle, start, end, projection, stream) {
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.lineTo(endProjected[0], endProjected[1]);
    }
    pathSmallCircle(circle, start, end, projection, stream) {
      const center = MapSingleLineAirspaceRenderer.geoPointCache[0].setFromCartesian(circle.radius < Math.PI / 2 ? circle.center : Vec3Math.multScalar(circle.center, -1, MapSingleLineAirspaceRenderer.vec3Cache[0]));
      const centerProjected = projection.project(center, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[1]);
      if (start.equals(end)) {
        const radius = Vec2Math.distance(endProjected, centerProjected);
        const startAngle = Math.atan2(endProjected[1] - centerProjected[1], endProjected[0] - centerProjected[0]);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, startAngle + 2 * Math.PI);
        stream.moveTo(endProjected[0], endProjected[1]);
      } else {
        const startProjected = projection.project(start, MapSingleLineAirspaceRenderer.vec2Cache[2]);
        const startDelta = Vec2Math.sub(startProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[3]);
        const startDeltaMag = Vec2Math.abs(startDelta);
        const endDelta = Vec2Math.sub(endProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[4]);
        const endDeltaMag = Vec2Math.abs(endDelta);
        const radius = (startDeltaMag + endDeltaMag) / 2;
        const startAngle = Vec2Math.theta(startDelta);
        const arcStartX = centerProjected[0] + radius / startDeltaMag * startDelta[0];
        const arcStartY = centerProjected[1] + radius / startDeltaMag * startDelta[1];
        const endAngle = Vec2Math.theta(endDelta);
        const arcEndX = centerProjected[0] + radius / endDeltaMag * endDelta[0];
        const arcEndY = centerProjected[1] + radius / endDeltaMag * endDelta[1];
        stream.lineTo(arcStartX, arcStartY);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, endAngle, circle.radius < Math.PI / 2);
        stream.lineTo(arcEndX, arcEndY);
      }
    }
  };
  MapSingleLineAirspaceRenderer.geoPointCache = [new GeoPoint(0, 0)];
  MapSingleLineAirspaceRenderer.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  MapSingleLineAirspaceRenderer.vec3Cache = [new Float64Array(3)];
  var Shape = class {
    constructor() {
      this.segments = [];
      this.length = 0;
      this.isClosed = false;
      this.windingOrder = 1;
    }
    build(shape, projection) {
      if (shape.length < 2) {
        return;
      }
      this.buildSegments(shape, projection);
      let signedArea = 0;
      let prev = this.segments[0];
      for (let i = 1; i < this.length; i++) {
        const segment = this.segments[i];
        signedArea += this.calculateSignedArea(segment, prev);
        prev = segment;
      }
      const first = this.segments[0].end;
      const last = this.segments[this.length - 1].end;
      this.isClosed = Vec2Math.equals(first, last);
      if (!this.isClosed) {
        signedArea += last[0] * first[1] - first[0] * last[1];
      }
      this.windingOrder = signedArea >= 0 ? 1 : -1;
      this.calculateVertices();
    }
    buildSegments(shape, projection) {
      this.buildStartSegment(projection, 0, shape[0]);
      let start = shape[0].end;
      this.length = shape.length;
      for (let i = 1; i < this.length; i++) {
        const vector = shape[i];
        this.buildSegment(projection, i, vector, start);
        start = vector.end;
      }
    }
    buildSegment(projection, index, vector, start) {
      const circle = vector.circle;
      if (circle) {
        if (circle.isGreatCircle()) {
          this.buildSegmentFromGreatCircle(projection, index, circle, start, vector.end);
        } else {
          this.buildSegmentFromSmallCircle(projection, index, circle, start, vector.end);
        }
      } else {
        this.buildStartSegment(projection, index, vector);
      }
    }
    buildStartSegment(projection, index, vector) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "start";
      projection.project(vector.end, segment.end);
    }
    buildSegmentFromGreatCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "line";
      projection.project(end, segment.end);
      const delta = Vec2Math.sub(segment.end, this.segments[index - 1].end, Shape.vec2Cache[0]);
      Vec2Math.normalize(Vec2Math.normal(delta, segment.endNormal), segment.endNormal);
    }
    buildSegmentFromSmallCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const isClockwise = circle.radius > Math.PI / 2;
      const center = Shape.geoPointCache[0].setFromCartesian(isClockwise ? Vec3Math.multScalar(circle.center, -1, Shape.vec3Cache[0]) : circle.center);
      const startProjected = this.segments[index - 1].end;
      const centerProjected = projection.project(center, Shape.vec2Cache[0]);
      const endProjected = projection.project(end, Shape.vec2Cache[1]);
      const startRadial = Vec2Math.sub(startProjected, centerProjected, Shape.vec2Cache[2]);
      const startRadialMag = Vec2Math.abs(startRadial);
      const endRadial = Vec2Math.sub(endProjected, centerProjected, Shape.vec2Cache[3]);
      const endRadialMag = Vec2Math.abs(endRadial);
      const radius = (startRadialMag + endRadialMag) / 2;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "arc";
      segment.radius = radius;
      segment.isClockwise = isClockwise;
      Vec2Math.copy(centerProjected, segment.center);
      Vec2Math.copy(endProjected, segment.end);
      Vec2Math.normalize(startRadial, segment.startNormal);
      Vec2Math.normalize(endRadial, segment.endNormal);
    }
    calculateSignedArea(segment, prevSegment) {
      if (segment.type === "start") {
        return 0;
      }
      if (segment.type === "line") {
        return prevSegment.end[0] * segment.end[1] - segment.end[0] * prevSegment.end[1];
      }
      const startRadial = Vec2Math.sub(prevSegment.end, segment.center, Shape.vec2Cache[0]);
      const startTheta = Vec2Math.theta(startRadial);
      const endRadial = Vec2Math.sub(segment.end, segment.center, Shape.vec2Cache[1]);
      const endTheta = Vec2Math.theta(endRadial);
      const angularWidth = Shape.getAngularWidth(startTheta, endTheta, segment.isClockwise, true);
      return prevSegment.end[0] * segment.center[1] - segment.center[0] * prevSegment.end[1] + segment.center[0] * segment.end[1] - segment.end[0] * segment.center[1] + angularWidth * segment.radius * segment.radius * (segment.isClockwise ? 1 : -1);
    }
    calculateVertices() {
      const max = this.isClosed ? this.length - 1 : this.length;
      for (let i = 0; i < this.length; i++) {
        const next = this.isClosed ? i % max + 1 : (i + 1) % max;
        this.calculateVertex(i, next);
      }
    }
    calculateVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      if (curr.type === "start" && next.type === "start") {
        curr.vertex.type = "null";
        curr.vertex.fromIndex = currIndex;
        curr.vertex.toIndex = nextIndex;
      } else if (curr.type === "start" && next.type === "line") {
        this.calculateLineStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "line" && next.type === "start") {
        this.calculateLineStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "start" && next.type === "arc") {
        this.calculateArcStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "arc" && next.type === "start") {
        this.calculateArcStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "line" && next.type === "line") {
        this.calculateLineLineVertex(currIndex, nextIndex);
      } else if (curr.type === "line" && next.type === "arc") {
        this.calculateLineArcVertex(currIndex, nextIndex, false);
      } else if (curr.type === "arc" && next.type === "line") {
        this.calculateLineArcVertex(currIndex, nextIndex, true);
      } else {
        this.calculateArcArcVertex(currIndex, nextIndex);
      }
    }
    calculateLineStartVertex(currIndex, nextIndex, isStartFirst) {
      const line = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "line-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.multScalar(line.endNormal, this.windingOrder, vertex.normal);
    }
    calculateArcStartVertex(currIndex, nextIndex, isStartFirst) {
      const arc = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "arc-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const arcNormal = isStartFirst ? arc.startNormal : arc.endNormal;
      Vec2Math.multScalar(arcNormal, this.windingOrder * (arc.isClockwise ? 1 : -1), vertex.normal);
    }
    calculateLineLineVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "line-line";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.normalize(Vec2Math.multScalar(Vec2Math.add(curr.endNormal, next.endNormal, vertex.normal), this.windingOrder, vertex.normal), vertex.normal);
      const deltaUnit = Vec2Math.normalize(Vec2Math.sub(next.end, curr.end, Shape.vec2Cache[0]), Shape.vec2Cache[0]);
      const scaleFactor = Math.abs(1 / (vertex.normal[0] * deltaUnit[1] - vertex.normal[1] * deltaUnit[0]));
      Vec2Math.multScalar(vertex.normal, scaleFactor, vertex.normal);
    }
    calculateLineArcVertex(currIndex, nextIndex, isArcFirst) {
      const curr = this.segments[currIndex];
      const line = this.segments[isArcFirst ? nextIndex : currIndex];
      const arc = this.segments[isArcFirst ? currIndex : nextIndex];
      const end = curr.end;
      const vertex = curr.vertex;
      vertex.type = "line-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      vertex.arcOffsetSign = this.windingOrder * (arc.isClockwise ? 1 : -1);
      const centerEndDelta = Vec2Math.sub(isArcFirst ? arc.end : line.end, arc.center, Shape.vec2Cache[0]);
      const dot = centerEndDelta[1] * line.endNormal[0] - centerEndDelta[0] * line.endNormal[1];
      const theta = Vec2Math.theta(line.endNormal) + (dot >= 0 ? Math.PI / 2 : -Math.PI / 2);
      Shape.transformCache[0].toTranslation(-arc.center[0], -arc.center[1]);
      const rotation = Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.r0 = arc.radius;
      vertex.y0 = vertex.transform.apply(end, Shape.vec2Cache[0])[1];
      vertex.lineOffsetSign = rotation.apply(line.endNormal, Shape.vec2Cache[0])[1] >= 0 ? this.windingOrder : -this.windingOrder;
      vertex.transform.invert();
    }
    calculateArcArcVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "arc-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const centerDelta = Vec2Math.sub(next.center, curr.center, Shape.vec2Cache[0]);
      const centerEndDelta = Vec2Math.sub(curr.end, curr.center, Shape.vec2Cache[1]);
      const dot = centerDelta[0] * centerEndDelta[1] - centerDelta[1] * centerEndDelta[0];
      const theta = Vec2Math.theta(centerDelta) + (dot >= 0 ? 0 : Math.PI);
      Shape.transformCache[0].toTranslation(-curr.center[0], -curr.center[1]);
      Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.d = vertex.transform.apply(next.center, Shape.vec2Cache[0])[0];
      vertex.arcOffsetSign = this.windingOrder * (curr.isClockwise ? 1 : -1);
      vertex.arc2OffsetSign = this.windingOrder * (next.isClockwise ? 1 : -1);
      vertex.transform.invert();
    }
    renderLine(context, offset, lineWidth, strokeStyle, dash, stream) {
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const startPoint = Vec2Math.set(0, 0, Shape.vec2Cache[0]);
      if (this.isClosed) {
        if (offset === 0) {
          Vec2Math.copy(this.segments[0].end, startPoint);
        } else {
          const lastIndex = this.length - 1;
          const result = this.calculateOffsetVertex(lastIndex, offset, startPoint);
          if (!result || Shape.isPointInSegmentBounds(this.segments[lastIndex], this.segments[lastIndex - 1].end, result)) {
            this.calculateOffsetEndPoint(lastIndex, offset, startPoint);
          }
        }
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      for (let i = this.isClosed ? 1 : 0; i < this.length; i++) {
        const segment = this.segments[i];
        let newStartPoint;
        switch (segment.type) {
          case "start":
            newStartPoint = this.pathStartSegment(stream, i, offset);
            break;
          case "line":
            newStartPoint = this.pathLineSegment(stream, i, startPoint, offset);
            break;
          case "arc":
            newStartPoint = this.pathArcSegment(stream, i, startPoint, offset);
            break;
        }
        Vec2Math.copy(newStartPoint, startPoint);
      }
      context.lineWidth = lineWidth;
      context.strokeStyle = strokeStyle;
      context.setLineDash(dash);
      context.stroke();
    }
    pathStartSegment(stream, index, offset) {
      const segment = this.segments[index];
      if (offset === 0) {
        stream.moveTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd) {
          stream.moveTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          stream.moveTo(segment.end[0], segment.end[1]);
          return segment.end;
        }
      }
    }
    pathLineSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      if (offset === 0) {
        stream.lineTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          stream.lineTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
          stream.lineTo(endPoint[0], endPoint[1]);
          const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
          stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
          return nextStartPoint;
        }
      }
    }
    pathArcSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      let startAngle;
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
        startAngle = Math.atan2(startPoint[1] - segment.center[1], startPoint[0] - segment.center[0]);
      } else {
        startAngle = Math.atan2(start[1] - segment.center[1], start[0] - segment.center[0]);
      }
      if (offset === 0) {
        const endAngle = Vec2Math.theta(segment.endNormal);
        const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
        stream.arc(segment.center[0], segment.center[1], segment.radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), !segment.isClockwise);
        return segment.end;
      } else {
        const baseEndAngle = Vec2Math.theta(segment.endNormal);
        const baseAngularWidth = Shape.getAngularWidth(startAngle, baseEndAngle, segment.isClockwise, true);
        const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
        const radius = segment.radius + offset * sign;
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          const endAngle = Math.atan2(offsetEnd[1] - segment.center[1], offsetEnd[0] - segment.center[0]);
          const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
          const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
          stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
          return offsetEnd;
        } else {
          if (radius > 0) {
            const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
            const endAngle = Math.atan2(endPoint[1] - segment.center[1], endPoint[0] - segment.center[0]);
            const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
            const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
            stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
            const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
            stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
            return nextStartPoint;
          } else {
            stream.moveTo(segment.center[0], segment.center[1]);
            return segment.center;
          }
        }
      }
    }
    calculateOffsetVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      switch (vertex.type) {
        case "line-start":
        case "arc-start":
        case "line-line":
          return this.calculateOffsetVertexFromNormal(index, offset, out);
        case "line-arc":
          return this.calculateOffsetLineArcVertex(index, offset, out);
        case "arc-arc":
          return this.calculateOffsetArcArcVertex(index, offset, out);
        default:
          return Vec2Math.copy(this.segments[vertex.fromIndex].end, out);
      }
    }
    calculateOffsetVertexFromNormal(index, offset, out) {
      const segment = this.segments[index];
      const vertex = segment.vertex;
      return Vec2Math.add(segment.end, Vec2Math.multScalar(vertex.normal, offset, out), out);
    }
    calculateOffsetLineArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      const radius = vertex.r0 + offset * vertex.arcOffsetSign;
      if (radius <= 0) {
        return void 0;
      }
      const y = vertex.y0 + offset * vertex.lineOffsetSign;
      const xSq = radius * radius - y * y;
      if (xSq < 0) {
        return void 0;
      }
      const x = Math.sqrt(xSq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    calculateOffsetArcArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      if (vertex.d === 0) {
        return void 0;
      }
      const segment1 = this.segments[vertex.fromIndex];
      const segment2 = this.segments[vertex.toIndex];
      const radius1 = segment1.radius + offset * vertex.arcOffsetSign;
      const radius2 = segment2.radius + offset * vertex.arc2OffsetSign;
      if (radius1 <= 0 || radius2 <= 0) {
        return void 0;
      }
      const dSq = vertex.d * vertex.d;
      const radius1Sq = radius1 * radius1;
      const radius2Sq = radius2 * radius2;
      const x = (dSq - radius2Sq + radius1Sq) / (2 * vertex.d);
      const ySq = radius1Sq - x * x;
      if (ySq < 0) {
        return void 0;
      }
      const y = Math.sqrt(ySq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    calculateOffsetStartPoint(index, offset, out) {
      const prevSegment = this.segments[index - 1];
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(prevSegment.end[0] + segment.endNormal[0] * this.windingOrder * offset, prevSegment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(prevSegment.end[0] + segment.startNormal[0] * sign * offset, prevSegment.end[1] + segment.startNormal[1] * sign * offset, out);
        }
      }
    }
    calculateOffsetEndPoint(index, offset, out) {
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * this.windingOrder * offset, segment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * sign * offset, segment.end[1] + segment.endNormal[1] * sign * offset, out);
        }
      }
    }
    static isPointInSegmentBounds(segment, start, point) {
      if (segment.type === "start") {
        return true;
      }
      if (segment.type === "line") {
        const lineDeltaX = segment.end[0] - start[0];
        const lineDeltaY = segment.end[1] - start[1];
        const startDeltaX = point[0] - start[0];
        const startDeltaY = point[1] - start[1];
        const endDeltaX = point[0] - segment.end[0];
        const endDeltaY = point[1] - segment.end[1];
        const startDot = startDeltaX * lineDeltaX + startDeltaY * lineDeltaY;
        const endDot = endDeltaX * lineDeltaX + endDeltaY * lineDeltaY;
        return startDot >= 0 && endDot <= 0;
      }
      const startAngle = Vec2Math.theta(segment.startNormal);
      const endAngle = Vec2Math.theta(segment.endNormal);
      const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
      const pointAngle = Math.atan2(point[1] - segment.center[1], point[0] - segment.center[0]);
      const angleDiff = Shape.getAngularWidth(startAngle, pointAngle, segment.isClockwise);
      return angleDiff <= angularWidth;
    }
    static getAngularWidth(startAngle, endAngle, isClockwise, zeroIsCircle = false, zeroTolerance = 1e-6) {
      const width = ((isClockwise ? endAngle - startAngle : startAngle - endAngle) + 2 * Math.PI) % (2 * Math.PI);
      return zeroIsCircle && Math.min(width, 2 * Math.PI - width) < zeroTolerance ? 2 * Math.PI : width;
    }
    static createSegment() {
      return {
        type: "arc",
        center: new Float64Array(2),
        radius: 0,
        isClockwise: false,
        end: new Float64Array(2),
        endNormal: new Float64Array(2),
        startNormal: new Float64Array(2),
        vertex: {
          type: "null",
          fromIndex: -1,
          toIndex: -1,
          normal: new Float64Array(2),
          transform: new Transform2D(),
          r0: 0,
          y0: 0,
          lineOffsetSign: 1,
          arcOffsetSign: 1,
          arc2OffsetSign: 1,
          d: 0
        }
      };
    }
  };
  Shape.geoPointCache = [new GeoPoint(0, 0)];
  Shape.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  Shape.vec3Cache = [new Float64Array(3)];
  Shape.transformCache = [new Transform2D(), new Transform2D()];
  var MapFieldOfViewCalculator = class {
    constructor(maxIter = MapFieldOfViewCalculator.DEFAULT_MAX_ITER, rangeTolerance = MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE) {
      this.maxIter = maxIter;
      this.rangeTolerance = rangeTolerance;
      this.tempProjection = new MapProjection(100, 100);
    }
    calculateFov(mapProjection, focus, margins, out) {
      out.range = NaN;
      out.target.set(NaN, NaN);
      if (focus.length === 0) {
        return out;
      }
      const projectedSize = mapProjection.getProjectedSize();
      const targetWidth = projectedSize[0] - margins[0] - margins[2];
      const targetHeight = projectedSize[1] - margins[1] - margins[3];
      if (targetWidth * targetHeight <= 0) {
        return out;
      }
      const mean = Vec3Math.set(0, 0, 0, MapFieldOfViewCalculator.vec3Cache[0]);
      for (let i = 0; i < focus.length; i++) {
        Vec3Math.add(mean, GeoPoint.sphericalToCartesian(focus[i], MapFieldOfViewCalculator.vec3Cache[1]), mean);
      }
      Vec3Math.multScalar(mean, 1 / focus.length, mean);
      this.tempProjection.set({
        projectedSize: mapProjection.getProjectedSize(),
        rotation: mapProjection.getRotation(),
        target: MapFieldOfViewCalculator.geoPointCache[0].setFromCartesian(mean),
        targetProjectedOffset: Vec2Math.set(margins[0] + (targetWidth - projectedSize[0]) / 2, margins[1] + (targetHeight - projectedSize[1]) / 2, MapFieldOfViewCalculator.vec2Cache[0]),
        rangeEndpoints: mapProjection.getRangeEndpoints(),
        range: mapProjection.getRange()
      });
      let minX;
      let minY;
      let maxX;
      let maxY;
      for (let i = 0; i < focus.length; i++) {
        const projected = this.tempProjection.project(focus[i], MapFieldOfViewCalculator.vec2Cache[0]);
        minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
        minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
        maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
        maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
      }
      if (minX === void 0 || minY === void 0 || maxX === void 0 || maxY === void 0) {
        return out;
      }
      let focusWidth = maxX - minX;
      let focusHeight = maxY - minY;
      if (focusWidth === 0 && focusHeight === 0) {
        out.target.set(focus[0]);
        out.range = 0;
        return out;
      }
      this.tempProjection.invert(Vec2Math.set((minX + maxX) / 2, (minY + maxY) / 2, MapFieldOfViewCalculator.vec2Cache[0]), out.target);
      this.tempProjection.set({
        target: out.target
      });
      let widthRatio = focusWidth / targetWidth;
      let heightRatio = focusHeight / targetHeight;
      let constrainedRatio = Math.max(widthRatio, heightRatio);
      const range = out.range = this.tempProjection.getRange();
      const topLeft = this.tempProjection.invert(Vec2Math.set(minX, minY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[0]);
      const bottomRight = this.tempProjection.invert(Vec2Math.set(maxX, maxY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[1]);
      let iterCount = 0;
      const rangeParam = { range };
      let ratioError = Math.abs(constrainedRatio - 1);
      let deltaRatioError = this.rangeTolerance + 1;
      while (iterCount++ < this.maxIter && ratioError > this.rangeTolerance && deltaRatioError > this.rangeTolerance) {
        rangeParam.range = out.range = this.tempProjection.getRange() * constrainedRatio;
        if (out.range <= GeoPoint.EQUALITY_TOLERANCE) {
          out.range = GeoPoint.EQUALITY_TOLERANCE;
          return out;
        }
        this.tempProjection.set(rangeParam);
        const topLeftProjected = this.tempProjection.project(topLeft, MapFieldOfViewCalculator.vec2Cache[0]);
        const bottomRightProjected = this.tempProjection.project(bottomRight, MapFieldOfViewCalculator.vec2Cache[1]);
        focusWidth = bottomRightProjected[0] - topLeftProjected[0];
        focusHeight = bottomRightProjected[1] - topLeftProjected[1];
        widthRatio = focusWidth / targetWidth;
        heightRatio = focusHeight / targetHeight;
        constrainedRatio = Math.max(widthRatio, heightRatio);
        const newRatioError = Math.abs(constrainedRatio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.tempProjection.invert(mapProjection.getTargetProjected(), out.target);
      return out;
    }
  };
  MapFieldOfViewCalculator.DEFAULT_MAX_ITER = 20;
  MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE = 0.01;
  MapFieldOfViewCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  MapFieldOfViewCalculator.vec2Cache = [Vec2Math.create(), Vec2Math.create()];
  MapFieldOfViewCalculator.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
  var MapOwnAirplaneIconOrientation;
  (function(MapOwnAirplaneIconOrientation2) {
    MapOwnAirplaneIconOrientation2["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation2["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation2["MapUp"] = "MapUp";
  })(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));
  var MapOwnAirplaneIconModule = class {
    constructor() {
      this.show = Subject.create(true);
      this.orientation = Subject.create(MapOwnAirplaneIconOrientation.HeadingUp);
    }
  };
  var MapOwnAirplanePropsModule = class {
    constructor() {
      this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
      this.hdgTrue = Subject.create(0);
      this.turnRate = Subject.create(0);
      this.altitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.verticalSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
      this.trackTrue = Subject.create(0);
      this.groundSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0));
      this.isOnGround = Subject.create(true);
      this.magVar = Subject.create(0);
    }
  };
  var MapAutopilotPropsModule = class {
    constructor() {
      this.selectedAltitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.apSelectedAltitudeHandler = (alt) => {
        this.selectedAltitude.set(alt);
      };
    }
  };
  var MapAirspaceModule = class {
    constructor(showTypes) {
      this.showTypes = showTypes;
      this.show = {};
      for (const type in showTypes) {
        this.show[type] = Subject.create(false);
      }
    }
  };
  var AbstractCssTransform = class {
    constructor(initialParams) {
      this.params = new Float64Array(initialParams);
      this.cachedParams = new Float64Array(initialParams);
    }
    resolve() {
      if (this.stringValue !== void 0 && VecNMath.equals(this.params, this.cachedParams)) {
        return this.stringValue;
      }
      VecNMath.copy(this.params, this.cachedParams);
      this.stringValue = this.buildString(this.params);
      return this.stringValue;
    }
  };
  var CssMatrixTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
      let scaleX;
      if (typeof arg1 === "number") {
        scaleX = arg1;
      } else {
        [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
      }
      this.params[0] = scaleX;
      this.params[1] = skewY;
      this.params[2] = skewX;
      this.params[3] = scaleY;
      this.params[4] = translateX;
      this.params[5] = translateY;
    }
    buildString(params) {
      return `matrix(${params.join(", ")})`;
    }
  };
  CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
  var CssRotateTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssRotateTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(angle, precision = 0) {
      this.params[0] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    buildString(params) {
      return `rotate(${params[0]}${this.unit})`;
    }
  };
  CssRotateTransform.DEFAULT_PARAMS = [0];
  var CssRotate3dTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssRotate3dTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(x, y, z, angle, precision = 0) {
      this.params[0] = x;
      this.params[1] = y;
      this.params[2] = z;
      this.params[3] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    buildString(params) {
      return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
  };
  CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
  var CssTranslateXTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateXTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    buildString(params) {
      return `translateX(${params[0]}${this.unit})`;
    }
  };
  CssTranslateXTransform.DEFAULT_PARAMS = [0];
  var CssTranslateYTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateYTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    buildString(params) {
      return `translateY(${params[0]}${this.unit})`;
    }
  };
  CssTranslateYTransform.DEFAULT_PARAMS = [0];
  var CssTranslateZTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateZTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    buildString(params) {
      return `translateZ(${params[0]}${this.unit})`;
    }
  };
  CssTranslateZTransform.DEFAULT_PARAMS = [0];
  var CssTranslateTransform = class extends AbstractCssTransform {
    constructor(unitX, unitY = unitX) {
      super(CssTranslateTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
    }
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    buildString(params) {
      return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
  };
  CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
  var CssTranslate3dTransform = class extends AbstractCssTransform {
    constructor(unitX, unitY = unitX, unitZ = unitX) {
      super(CssTranslate3dTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
      this.unitZ = unitZ;
    }
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils.round(z, precisionZ);
    }
    buildString(params) {
      return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
  };
  CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
  var CssScaleXTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    buildString(params) {
      return `scaleX(${params[0]})`;
    }
  };
  CssScaleXTransform.DEFAULT_PARAMS = [1];
  var CssScaleYTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    buildString(params) {
      return `scaleY(${params[0]})`;
    }
  };
  CssScaleYTransform.DEFAULT_PARAMS = [1];
  var CssScaleZTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    buildString(params) {
      return `scaleZ(${params[0]})`;
    }
  };
  CssScaleZTransform.DEFAULT_PARAMS = [1];
  var CssScaleTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleTransform.DEFAULT_PARAMS);
    }
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    buildString(params) {
      return `scale(${params[0]}, ${params[1]})`;
    }
  };
  CssScaleTransform.DEFAULT_PARAMS = [1, 1];
  var CssScale3dTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils.round(y, precisionZ);
    }
    buildString(params) {
      return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
  };
  CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
  var CssTransformChain = class {
    constructor(...transforms) {
      this.stringValues = [];
      this.transforms = transforms;
    }
    getChild(index) {
      if (index < 0 || index >= this.transforms.length) {
        throw new RangeError();
      }
      return this.transforms[index];
    }
    resolve() {
      let needRebuildString = false;
      for (let i = 0; i < this.transforms.length; i++) {
        const stringValue = this.transforms[i].resolve();
        if (this.stringValues[i] !== stringValue) {
          this.stringValues[i] = stringValue;
          needRebuildString = true;
        }
      }
      if (needRebuildString || this.chainedStringValue === void 0) {
        this.chainedStringValue = this.stringValues.join(" ");
      }
      return this.chainedStringValue;
    }
  };
  var CssTransformSubject = class extends AbstractSubscribable {
    constructor(transform) {
      super();
      this._transform = transform;
      this.stringValue = transform.resolve();
      this.transform = transform;
    }
    get() {
      return this.stringValue;
    }
    resolve() {
      const stringValue = this._transform.resolve();
      if (stringValue !== this.stringValue) {
        this.stringValue = stringValue;
        this.notify();
      }
    }
    static create(transform) {
      return new CssTransformSubject(transform);
    }
  };
  var CssTransformBuilder = class {
    static matrix() {
      return new CssMatrixTransform();
    }
    static rotate(unit) {
      return new CssRotateTransform(unit);
    }
    static rotate3d(unit) {
      return new CssRotate3dTransform(unit);
    }
    static translateX(unit) {
      return new CssTranslateXTransform(unit);
    }
    static translateY(unit) {
      return new CssTranslateYTransform(unit);
    }
    static translateZ(unit) {
      return new CssTranslateZTransform(unit);
    }
    static translate(unitX, unitY) {
      return new CssTranslateTransform(unitX, unitY);
    }
    static translate3d(unitX, unitY, unitZ) {
      return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    static scaleX() {
      return new CssScaleXTransform();
    }
    static scaleY() {
      return new CssScaleYTransform();
    }
    static scaleZ() {
      return new CssScaleZTransform();
    }
    static scale() {
      return new CssScaleTransform();
    }
    static scale3d() {
      return new CssScale3dTransform();
    }
    static concat(...transforms) {
      return new CssTransformChain(...transforms);
    }
  };
  var NumberFormatter = class {
    static formatNumber(number, opts) {
      if (isNaN(number)) {
        return opts.nanString;
      }
      const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
      const sign = number < 0 ? -1 : 1;
      const abs = Math.abs(number);
      let rounded = abs;
      if (precision !== 0) {
        rounded = roundFunc(abs / precision) * precision;
      }
      if (cache) {
        if (opts.cachedString !== void 0 && opts.cachedNumber === rounded) {
          return opts.cachedString;
        }
        opts.cachedNumber = rounded;
      }
      const signText = sign === -1 ? useMinusSign ? "\u2212" : "-" : "+";
      let formatted;
      if (precision != 0) {
        const precisionString = `${precision}`;
        const decimalIndex2 = precisionString.indexOf(".");
        if (decimalIndex2 >= 0) {
          formatted = rounded.toFixed(precisionString.length - decimalIndex2 - 1);
        } else {
          formatted = `${rounded}`;
        }
      } else {
        formatted = `${abs}`;
      }
      let decimalIndex = formatted.indexOf(".");
      if (!forceDecimalZeroes && decimalIndex >= 0) {
        formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, "");
        if (formatted.indexOf(".") == formatted.length - 1) {
          formatted = formatted.substring(0, formatted.length - 1);
        }
      }
      decimalIndex = formatted.indexOf(".");
      if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
        const shift = Math.max(maxDigits - decimalIndex, 0);
        const shiftPrecision = Math.pow(0.1, shift);
        formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
      }
      if (pad === 0) {
        formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, ".");
      } else if (pad > 1) {
        decimalIndex = formatted.indexOf(".");
        if (decimalIndex < 0) {
          decimalIndex = formatted.length;
        }
        formatted = formatted.padStart(pad + formatted.length - decimalIndex, "0");
      }
      if (showCommas) {
        const parts = formatted.split(".");
        parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ",");
        formatted = parts.join(".");
      }
      formatted = (forceSign || signText !== "+" ? signText : "") + formatted;
      if (cache) {
        opts.cachedString = formatted;
      }
      return formatted;
    }
    static create(options) {
      const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
      optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
      return (number) => {
        return NumberFormatter.formatNumber(number, optsToUse);
      };
    }
  };
  NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: "NaN",
    cache: false
  };
  NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
  };
  NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
  NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
  NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;
  var SvgPathStream = class {
    constructor(precision = 0) {
      this.svgPath = "";
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.precision = precision;
      this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    getSvgPath() {
      return this.svgPath.trim();
    }
    getPrecision() {
      return this.precision;
    }
    setPrecision(precision) {
      this.precision = Math.abs(precision);
      this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    beginPath() {
      this.reset();
    }
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = counterClockwise ? MathUtils.diffAngle(endAngle, startAngle) : MathUtils.diffAngle(startAngle, endAngle);
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(MathUtils.TWO_PI, (endAngle - startAngle) * directionSign);
      if (angularWidth === MathUtils.TWO_PI) {
        const midAngle = startAngle + Math.PI * directionSign;
        this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
        this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
      const radiusString = this.formatter(radius);
      this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
      Vec2Math.copy(endPoint, this.prevPoint);
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.svgPath = "";
    }
  };
  SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var MapSystemKeys = class {
  };
  MapSystemKeys.TargetControl = "targetControlModerator";
  MapSystemKeys.RotationControl = "rotationControlModerator";
  MapSystemKeys.RangeControl = "rangeControlModerator";
  MapSystemKeys.ClockUpdate = "clockUpdate";
  MapSystemKeys.OwnAirplaneProps = "ownAirplaneProps";
  MapSystemKeys.AutopilotProps = "autopilotProps";
  MapSystemKeys.AltitudeArc = "altitudeArc";
  MapSystemKeys.TerrainColors = "terrainColors";
  MapSystemKeys.Weather = "weather";
  MapSystemKeys.FollowAirplane = "followAirplane";
  MapSystemKeys.Rotation = "rotation";
  MapSystemKeys.OwnAirplaneIcon = "ownAirplaneIcon";
  MapSystemKeys.OwnAirplaneIconOrientation = "ownAirplaneIconOrientation";
  MapSystemKeys.TextLayer = "text";
  MapSystemKeys.TextManager = "textManager";
  MapSystemKeys.Bing = "bing";
  MapSystemKeys.WaypointRenderer = "waypointRenderer";
  MapSystemKeys.IconFactory = "iconFactory";
  MapSystemKeys.LabelFactory = "labelFactory";
  MapSystemKeys.NearestWaypoints = "nearestWaypoints";
  MapSystemKeys.FlightPlan = "flightPlan";
  MapSystemKeys.FlightPlanner = "flightPlanner";
  MapSystemKeys.FlightPathRenderer = "flightPathRenderer";
  MapSystemKeys.Airspace = "airspace";
  MapSystemKeys.AirspaceManager = "airspaceRenderManager";
  MapSystemKeys.Traffic = "traffic";
  MapSystemKeys.DataIntegrity = "dataIntegrity";
  var MapCanvasLayerCanvasInstanceClass = class {
    constructor(canvas, context, isDisplayed) {
      this.canvas = canvas;
      this.context = context;
      this.isDisplayed = isDisplayed;
    }
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    reset() {
      const width = this.canvas.width;
      this.canvas.width = 0;
      this.canvas.width = width;
    }
  };
  var MapCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.displayCanvasRef = FSComponent.createRef();
      this.width = 0;
      this.height = 0;
      this.displayCanvasContext = null;
      this.isInit = false;
    }
    get display() {
      if (!this._display) {
        throw new Error("MapCanvasLayer: attempted to access display before it was initialized");
      }
      return this._display;
    }
    get buffer() {
      if (!this._buffer) {
        throw new Error("MapCanvasLayer: attempted to access buffer before it was initialized");
      }
      return this._buffer;
    }
    tryGetDisplay() {
      return this._display;
    }
    tryGetBuffer() {
      return this._buffer;
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    setWidth(width) {
      if (width === this.width) {
        return;
      }
      this.width = width;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    setHeight(height) {
      if (height === this.height) {
        return;
      }
      this.height = height;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    copyBufferToDisplay() {
      if (!this.isInit || !this.props.useBuffer) {
        return;
      }
      this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    onAfterRender() {
      this.displayCanvasContext = this.displayCanvasRef.instance.getContext("2d");
    }
    onVisibilityChanged(isVisible) {
      if (this.isInit) {
        this.updateCanvasVisibility();
      }
    }
    updateFromVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    onAttached() {
      this.initCanvasInstances();
      this.isInit = true;
      this.updateCanvasVisibility();
      this.updateCanvasSize();
    }
    initCanvasInstances() {
      this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
      if (this.props.useBuffer) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        this._buffer = this.createCanvasInstance(canvas, context, false);
      }
    }
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    updateCanvasSize() {
      const displayCanvas = this.display.canvas;
      displayCanvas.width = this.width;
      displayCanvas.height = this.height;
      displayCanvas.style.width = `${this.width}px`;
      displayCanvas.style.height = `${this.height}px`;
      if (this._buffer) {
        const bufferCanvas = this._buffer.canvas;
        bufferCanvas.width = this.width;
        bufferCanvas.height = this.height;
      }
    }
    updateCanvasVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    render() {
      var _a;
      return FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", width: "0", height: "0", style: "position: absolute;" });
    }
  };
  var MapSyncedCanvasLayer = class extends MapCanvasLayer {
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    updateFromProjectedSize(projectedSize) {
      this.setWidth(projectedSize[0]);
      this.setHeight(projectedSize[1]);
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = "0px";
      displayCanvas.style.top = "0px";
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
    }
  };
  var MapAltitudeArcLayer = class extends MapLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.layerRef = FSComponent.createRef();
      this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
      this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
      this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
      this.strokeLineCap = (_e = this.props.strokeLineCap) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;
      this.outlineWidth = (_f = this.props.outlineWidth) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_g = this.props.outlineStyle) !== null && _g !== void 0 ? _g : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineLineCap = (_h = this.props.outlineLineCap) !== null && _h !== void 0 ? _h : MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;
      this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.autopilotModule = this.props.model.getModule(MapSystemKeys.AutopilotProps);
      this.vsPrecisionFpm = "isSubscribable" in this.props.verticalSpeedPrecision ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));
      this.vsThresholdFpm = "isSubscribable" in this.props.verticalSpeedThreshold ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));
      this.altDevThresholdFeet = "isSubscribable" in this.props.altitudeDeviationThreshold ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map((v) => v.asUnit(UnitType.FOOT)) : Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));
      this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map((vs) => vs.asUnit(UnitType.FPM));
      this.vsFpmQuantized = MappedSubject.create(([vsFpm, precision]) => {
        return Math.round(vsFpm / precision) * precision;
      }, this.vsFpm, this.vsPrecisionFpm);
      this.projectedPlanePosition = Vec2Subject.create(Vec2Math.create());
      this.projectPlanePositionHandler = () => {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
        this.projectedPlanePosition.set(projected);
      };
      this.isArcVisibleDynamic = MappedSubject.create(([vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
        if (Math.abs(vsFpm) < vsThreshold) {
          return false;
        }
        const altDevFeet = selectedAlt.asUnit(UnitType.FOOT) - alt.asUnit(UnitType.FOOT);
        return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
      }, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet).pause();
      this.projectedArcPosition = Vec2Subject.create(Vec2Math.create());
      this.projectedArcAngle = Subject.create(0);
      this.needUpdate = false;
      this.subscriptions = [];
    }
    onVisibilityChanged(isVisible) {
      var _a;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(isVisible);
      if (isVisible) {
        this.needUpdate = true;
      }
    }
    onAttached() {
      var _a, _b;
      this.layerRef.instance.onAttached();
      this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      const altitudeArcModule = this.props.model.getModule(MapSystemKeys.AltitudeArc);
      const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
      this.isArcVisibleStatic = MappedSubject.create(([show, isGpsValid, isAdcValid]) => {
        return show && isGpsValid && isAdcValid;
      }, altitudeArcModule.show, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true));
      const isArcVisibleDynamicSub = this.isArcVisibleDynamic.sub((isVisible) => {
        this.setVisible(isVisible);
      }, false, true);
      this.isArcVisibleStatic.sub((isVisible) => {
        if (isVisible) {
          this.isArcVisibleDynamic.resume();
          isArcVisibleDynamicSub.resume(true);
        } else {
          this.isArcVisibleDynamic.pause();
          isArcVisibleDynamicSub.pause();
          this.setVisible(false);
        }
      }, true);
      this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
      this.vsFpmQuantized.sub(scheduleUpdate);
      this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
      this.layerRef.instance.setVisible(this.isVisible());
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.layerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.projectPlanePositionHandler();
      this.needUpdate = true;
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const track = this.ownAirplanePropsModule.trackTrue.get();
      const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
      const altitude = this.ownAirplanePropsModule.altitude.get();
      const selectedAltitude = this.autopilotModule.selectedAltitude.get();
      const vsFpm = this.vsFpmQuantized.get();
      const timeToAltitudeMinute = (selectedAltitude.asUnit(UnitType.FOOT) - altitude.asUnit(UnitType.FOOT)) / vsFpm;
      const distanceToAltitudeFeet = groundSpeed.asUnit(UnitType.FPM) * timeToAltitudeMinute;
      const distancePx = UnitType.FOOT.convertTo(distanceToAltitudeFeet, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
      const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - MathUtils.HALF_PI;
      const projectedPlanePos = this.projectedPlanePosition.get();
      const projectedArcPos = Vec2Math.add(Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
      this.projectedArcPosition.set(projectedArcPos);
      this.projectedArcAngle.set(projectedTrackAngle);
      this.layerRef.instance.onUpdated();
      this.needUpdate = false;
    }
    render() {
      const props = {
        ref: this.layerRef,
        model: this.props.model,
        mapProjection: this.props.mapProjection,
        arcAngularWidth: this.arcAngularWidth,
        arcRadius: this.arcRadius,
        strokeWidth: this.strokeWidth,
        strokeStyle: this.strokeStyle,
        strokeLineCap: this.strokeLineCap,
        outlineWidth: this.outlineWidth,
        outlineStyle: this.outlineStyle,
        outlineLineCap: this.outlineLineCap,
        projectedArcPosition: this.projectedArcPosition,
        projectedArcAngle: this.projectedArcAngle
      };
      return this.props.renderMethod === "canvas" ? FSComponent.buildComponent(MapAltitudeArcCanvasLayer, Object.assign({}, props)) : FSComponent.buildComponent(MapAltitudeArcSvgLayer, Object.assign({}, props));
    }
    destroy() {
      var _a, _b, _c, _d, _e;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.vsPrecisionMap) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.vsThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.altDevThresholdMap) === null || _d === void 0 ? void 0 : _d.destroy();
      this.vsFpm.destroy();
      (_e = this.isArcVisibleStatic) === null || _e === void 0 ? void 0 : _e.destroy();
      this.isArcVisibleDynamic.destroy();
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60;
  MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64;
  MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2;
  MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = "cyan";
  MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP = "butt";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1;
  MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = "#505050";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP = "butt";
  MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.canvasLayerRef = FSComponent.createRef();
      this.subscriptions = [];
      this.needUpdate = false;
    }
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (isVisible) {
        this.needUpdate = true;
      } else {
        (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
      this.needUpdate = true;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const display = this.canvasLayerRef.instance.display;
      display.clear();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        return;
      }
      display.context.beginPath();
      const projectedArcAngle = this.props.projectedArcAngle.get();
      const center = Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius, projectedArcAngle, MapAltitudeArcCanvasLayer.vec2Cache[0]), arcPos, MapAltitudeArcCanvasLayer.vec2Cache[0]);
      const arcStart = Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, MapAltitudeArcCanvasLayer.vec2Cache[1]), center, MapAltitudeArcCanvasLayer.vec2Cache[1]);
      display.context.moveTo(arcStart[0], arcStart[1]);
      display.context.arc(center[0], center[1], this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, projectedArcAngle + this.arcHalfAngularWidth);
      if (this.props.outlineWidth > 0) {
        display.context.lineWidth = this.totalArcThickness;
        display.context.strokeStyle = this.props.outlineStyle;
        display.context.lineCap = this.props.outlineLineCap;
        display.context.stroke();
      }
      if (this.props.strokeWidth > 0) {
        display.context.lineWidth = this.props.strokeWidth;
        display.context.strokeStyle = this.props.strokeStyle;
        display.context.lineCap = this.props.strokeLineCap;
        display.context.stroke();
      }
      this.needUpdate = false;
    }
    render() {
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection });
    }
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcCanvasLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcSvgLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.width = this.props.arcRadius * (1 - Math.cos(this.arcHalfAngularWidth)) + this.totalArcThickness + 2;
      this.height = 2 * this.props.arcRadius * Math.sin(Math.min(this.arcHalfAngularWidth, MathUtils.HALF_PI)) + this.totalArcThickness + 2;
      this.svgStyle = ObjectSubject.create({
        "display": "",
        "position": "absolute",
        "left": `${this.totalArcThickness / 2 + 1 - this.width}px`,
        "top": `${-this.height / 2}px`,
        "width": `${this.width}px`,
        "height": `${this.height}px`,
        "transform": "translate3d(0px, 0px, 0px) rotate(0rad)",
        "transform-origin": `${this.width - (this.totalArcThickness / 2 + 1)}px ${this.height / 2}px`
      });
      this.svgTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("rad"));
      this.needUpdate = false;
      this.subscriptions = [];
    }
    onVisibilityChanged(isVisible) {
      if (isVisible) {
        this.needUpdate = true;
      } else {
        this.svgStyle.set("display", "none");
      }
    }
    onAttached() {
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        this.svgStyle.set("display", "none");
      } else {
        this.svgStyle.set("display", "");
        this.svgTransform.getChild(0).set(arcX, arcY, 0, 0.1);
        this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(), 1e-4);
        this.svgStyle.set("transform", this.svgTransform.resolve());
      }
      this.needUpdate = false;
    }
    render() {
      const svgPathStream = new SvgPathStream(0.01);
      const transformPathStream = new AffineTransformPathStream(svgPathStream);
      transformPathStream.beginPath();
      transformPathStream.addRotation(-this.arcHalfAngularWidth).addTranslation(-this.props.arcRadius, 0);
      transformPathStream.moveTo(this.props.arcRadius, 0);
      transformPathStream.arc(0, 0, this.props.arcRadius, 0, this.props.arcAngularWidth);
      const path = svgPathStream.getSvgPath();
      return FSComponent.buildComponent(
        "svg",
        { viewBox: `${this.totalArcThickness / 2 + 1 - this.width} ${-this.height / 2} ${this.width} ${this.height}`, style: this.svgStyle },
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.outlineStyle, "stroke-width": this.totalArcThickness, "stroke-linecap": this.props.outlineLineCap }),
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.strokeStyle, "stroke-width": this.props.strokeWidth, "stroke-linecap": this.props.strokeLineCap })
      );
    }
    destroy() {
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  var MapBingLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.bingRef = FSComponent.createRef();
      this.wrapperStyle = ObjectSubject.create({
        "position": "absolute",
        "left": "0px",
        "top": "0px",
        "width": "0px",
        "height": "0px",
        "display": "",
        "transform": ""
      });
      this.resolution = Vec2Subject.create(Vec2Math.create(1024, 1024));
      this.rotationTransform = CssTransformBuilder.rotate("rad");
      this.size = 0;
      this.needUpdate = false;
    }
    onVisibilityChanged(isVisible) {
      this.wrapperStyle.set("display", isVisible ? "" : "none");
    }
    onAttached() {
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      if (this.props.wxrMode !== void 0) {
        this.props.wxrMode.sub(() => {
          this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
          this.needUpdate = true;
        });
      }
    }
    onWake() {
      this.bingRef.instance.wake();
    }
    onSleep() {
      this.bingRef.instance.sleep();
    }
    updateFromProjectedSize(projectedSize) {
      let offsetX, offsetY;
      if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
        const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
        const offset = this.props.mapProjection.getTargetProjectedOffset();
        offsetSize[0] += offset[0];
        offsetSize[1] += offset[1];
        this.size = this.getSize(offsetSize);
        offsetX = (projectedSize[0] - this.size) / 2 + offset[0];
        offsetY = (projectedSize[1] - this.size) / 2 + offset[1];
      } else {
        this.size = this.getSize(projectedSize);
        offsetX = (projectedSize[0] - this.size) / 2;
        offsetY = (projectedSize[1] - this.size) / 2;
      }
      this.wrapperStyle.set("left", `${offsetX}px`);
      this.wrapperStyle.set("top", `${offsetY}px`);
      this.wrapperStyle.set("width", `${this.size}px`);
      this.wrapperStyle.set("height", `${this.size}px`);
      this.resolution.set(this.size, this.size);
    }
    getSize(projectedSize) {
      return Vec2Math.abs(projectedSize);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.TargetProjected)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
      if (this.bingRef.instance.isBound()) {
        this.needUpdate = true;
      }
    }
    onBingBound() {
      this.needUpdate = true;
    }
    onUpdated(time, elapsed) {
      if (!this.needUpdate) {
        return;
      }
      this.updatePositionRadius();
      this.needUpdate = false;
    }
    resetImgSrc() {
      this.bingRef.instance.resetImgSrc();
    }
    updatePositionRadius() {
      const center = this.props.mapProjection.getCenter();
      const radius = this.calculateDesiredRadius(this.props.mapProjection);
      this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
      if (!this.props.wxrMode || this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL) {
        this.rotationTransform.set(this.props.mapProjection.getRotation(), 1e-3);
      } else {
        this.rotationTransform.set(0);
      }
      this.wrapperStyle.set("transform", this.rotationTransform.resolve());
    }
    calculateDesiredRadius(mapProjection) {
      const scaleFactor = mapProjection.getScaleFactor();
      const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
      const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
      return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        "div",
        { style: this.wrapperStyle, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" },
        FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolution, mode: (_b = this.props.mode) !== null && _b !== void 0 ? _b : EBingMode.PLANE, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, reference: this.props.reference, wxrMode: this.props.wxrMode, wxrColors: this.props.wxrColors, isoLines: this.props.isoLines, delay: this.props.delay })
      );
    }
  };
  var MapCachedCanvasLayerReferenceClass = class {
    constructor() {
      this._center = new GeoPoint(0, 0);
      this._scaleFactor = 1;
      this._rotation = 0;
    }
    get center() {
      return this._center.readonly;
    }
    get scaleFactor() {
      return this._scaleFactor;
    }
    get rotation() {
      return this._rotation;
    }
    syncWithMapProjection(mapProjection) {
      this._center.set(mapProjection.getCenter());
      this._scaleFactor = mapProjection.getScaleFactor();
      this._rotation = mapProjection.getRotation();
    }
    syncWithReference(reference) {
      this._center.set(reference.center);
      this._scaleFactor = reference.scaleFactor;
      this._rotation = reference.rotation;
    }
  };
  var MapCachedCanvasLayerTransformClass = class {
    constructor() {
      this._scale = 0;
      this._rotation = 0;
      this._translation = new Float64Array(2);
      this._margin = 0;
      this._marginRemaining = 0;
    }
    get scale() {
      return this._scale;
    }
    get rotation() {
      return this._rotation;
    }
    get translation() {
      return this._translation;
    }
    get margin() {
      return this._margin;
    }
    get marginRemaining() {
      return this._marginRemaining;
    }
    update(mapProjection, reference, referenceMargin) {
      this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
      this._rotation = mapProjection.getRotation() - reference.rotation;
      mapProjection.project(reference.center, this._translation);
      Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
      this._margin = referenceMargin * this._scale;
      this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    copyFrom(other) {
      this._scale = other.scale;
      this._rotation = other.rotation;
      this._translation.set(other.translation);
      this._margin = other.margin;
    }
  };
  var MapCachedCanvasLayerCanvasInstanceClass = class extends MapCanvasLayerCanvasInstanceClass {
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
      super(canvas, context, isDisplayed);
      this.getReferenceMargin = getReferenceMargin;
      this._reference = new MapCachedCanvasLayerReferenceClass();
      this._transform = new MapCachedCanvasLayerTransformClass();
      this._isInvalid = false;
      this._geoProjection = new MercatorProjection();
      this.canvasTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(), CssTransformBuilder.translate("px"), CssTransformBuilder.rotate("rad")));
      this.canvasTransform.sub((transform) => {
        this.canvas.style.transform = transform;
      }, true);
    }
    get reference() {
      return this._reference;
    }
    get transform() {
      return this._transform;
    }
    get isInvalid() {
      return this._isInvalid;
    }
    get geoProjection() {
      return this._geoProjection;
    }
    syncWithMapProjection(mapProjection) {
      const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
      this._reference.syncWithMapProjection(mapProjection);
      this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      this._isInvalid = false;
      if (this.isDisplayed) {
        this.transformCanvasElement();
      }
    }
    syncWithCanvasInstance(other) {
      this._reference.syncWithReference(other.reference);
      this._geoProjection.copyParametersFrom(other.geoProjection);
      this._transform.copyFrom(other.transform);
      this._isInvalid = other.isInvalid;
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    updateTransform(mapProjection) {
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      if (!this._isInvalid) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
        this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || this._transform.marginRemaining < 0;
      }
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    transformCanvasElement() {
      const transform = this.transform;
      const offsetX = transform.translation[0] / transform.scale;
      const offsetY = transform.translation[1] / transform.scale;
      this.canvasTransform.transform.getChild(0).set(transform.scale, transform.scale, 1e-3);
      this.canvasTransform.transform.getChild(1).set(offsetX, offsetY, 0.1);
      this.canvasTransform.transform.getChild(2).set(transform.rotation, 1e-4);
      this.canvasTransform.resolve();
    }
    invalidate() {
      this._isInvalid = true;
      this.clear();
    }
  };
  MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
  MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
  var MapCachedCanvasLayer = class extends MapCanvasLayer {
    constructor(props) {
      super(props);
      this.size = 0;
      this.referenceMargin = 0;
      this.needUpdateTransforms = false;
      this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    getSize() {
      return this.size;
    }
    getReferenceMargin() {
      return this.referenceMargin;
    }
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      this.needUpdateTransforms = true;
    }
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    updateFromProjectedSize(projectedSize) {
      const projectedWidth = projectedSize[0];
      const projectedHeight = projectedSize[1];
      const diag = Math.hypot(projectedWidth, projectedHeight);
      this.size = diag * this.props.overdrawFactor;
      this.referenceMargin = (this.size - diag) / 2;
      this.setWidth(this.size);
      this.setHeight(this.size);
      const posX = (projectedWidth - this.size) / 2;
      const posY = (projectedHeight - this.size) / 2;
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = `${posX}px`;
      displayCanvas.style.top = `${posY}px`;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      var _a;
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
        this.display.invalidate();
        (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.invalidate();
      }
      this.needUpdateTransforms = true;
    }
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (!this.needUpdateTransforms) {
        return;
      }
      this.updateTransforms();
    }
    updateTransforms() {
      var _a;
      const mapProjection = this.props.mapProjection;
      this.display.updateTransform(mapProjection);
      (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.updateTransform(mapProjection);
      this.needUpdateTransforms = false;
    }
  };
  var MapLabeledRingLabelClass = class {
    constructor(content, wrapper) {
      this.content = content;
      this.wrapper = wrapper;
      this.center = new Float64Array(2);
      this.radius = 0;
      this.anchor = new Float64Array(2);
      this.radialAngle = 0;
      this.radialOffset = 0;
    }
    getAnchor() {
      return this.anchor;
    }
    getRadialAngle() {
      return this.radialAngle;
    }
    getRadialOffset() {
      return this.radialOffset;
    }
    setAnchor(anchor) {
      this.anchor.set(anchor);
      this.wrapper.style.transform = `translate(${-anchor[0] * 100}%, ${-anchor[1] * 100}%)`;
    }
    setRadialAngle(angle) {
      if (this.radialAngle === angle) {
        return;
      }
      this.radialAngle = angle;
      this.updatePosition();
    }
    setRadialOffset(offset) {
      if (this.radialOffset === offset) {
        return;
      }
      this.radialOffset = offset;
      this.updatePosition();
    }
    setRingPosition(center, radius) {
      if (Vec2Math.equals(this.center, center) && radius === this.radius) {
        return;
      }
      this.center.set(center);
      this.radius = radius;
      this.updatePosition();
    }
    updatePosition() {
      const pos = MapLabeledRingLabelClass.tempVec2_1;
      Vec2Math.setFromPolar(this.radius + this.radialOffset, this.radialAngle, pos);
      Vec2Math.add(this.center, pos, pos);
      this.wrapper.style.left = `${pos[0]}px`;
      this.wrapper.style.top = `${pos[1]}px`;
    }
  };
  MapLabeledRingLabelClass.tempVec2_1 = new Float64Array(2);
  var MapOwnAirplaneLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.imageFilePath = SubscribableUtils.isSubscribable(this.props.imageFilePath) ? this.props.imageFilePath.map(SubscribableMapFunctions.identity()) : this.props.imageFilePath;
      this.style = ObjectSubject.create({
        display: "",
        position: "absolute",
        left: "0px",
        top: "0px",
        width: "0px",
        height: "0px",
        transform: "translate3d(0, 0, 0) rotate(0deg)",
        "transform-origin": "50% 50%"
      });
      this.ownAirplanePropsModule = this.props.model.getModule("ownAirplaneProps");
      this.ownAirplaneIconModule = this.props.model.getModule("ownAirplaneIcon");
      this.iconSize = SubscribableUtils.toSubscribable(this.props.iconSize, true);
      this.iconAnchor = SubscribableUtils.toSubscribable(this.props.iconAnchor, true);
      this.iconOffset = Vec2Math.create();
      this.visibilityBounds = VecNMath.create(4);
      this.iconTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("deg"));
      this.isGsAboveTrackThreshold = this.ownAirplanePropsModule.groundSpeed.map((gs) => gs.asUnit(UnitType.KNOT) >= 5).pause();
      this.showIcon = true;
      this.isInsideVisibilityBounds = true;
      this.planeRotation = 0;
      this.needUpdateVisibility = false;
      this.needUpdatePositionRotation = false;
    }
    onVisibilityChanged(isVisible) {
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    onAttached() {
      this.showSub = this.ownAirplaneIconModule.show.sub((show) => {
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = this.showIcon = show && this.isVisible();
      });
      this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
        this.needUpdatePositionRotation = this.showIcon;
      });
      this.headingSub = this.ownAirplanePropsModule.hdgTrue.sub((hdg) => {
        this.planeRotation = hdg;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackSub = this.ownAirplanePropsModule.trackTrue.sub((track) => {
        this.planeRotation = track;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackThresholdSub = this.isGsAboveTrackThreshold.sub((isAboveThreshold) => {
        if (isAboveThreshold) {
          this.headingSub.pause();
          this.trackSub.resume(true);
        } else {
          this.trackSub.pause();
          this.headingSub.resume(true);
        }
      }, false, true);
      this.iconSizeSub = this.iconSize.sub((size) => {
        this.style.set("width", `${size}px`);
        this.style.set("height", `${size}px`);
        this.updateOffset();
      }, true);
      this.iconAnchorSub = this.iconAnchor.sub(() => {
        this.updateOffset();
      });
      this.orientationSub = this.ownAirplaneIconModule.orientation.sub((orientation) => {
        switch (orientation) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.trackSub.pause();
            this.headingSub.resume(true);
            break;
          case MapOwnAirplaneIconOrientation.TrackUp:
            this.headingSub.pause();
            this.trackSub.pause();
            this.isGsAboveTrackThreshold.resume();
            this.trackThresholdSub.resume(true);
            break;
          default:
            this.needUpdatePositionRotation = this.showIcon;
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.headingSub.pause();
            this.trackSub.pause();
            this.planeRotation = 0;
        }
      }, true);
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = true;
    }
    updateOffset() {
      const anchor = this.iconAnchor.get();
      this.iconOffset.set(anchor);
      Vec2Math.multScalar(this.iconOffset, -this.iconSize.get(), this.iconOffset);
      this.style.set("left", `${this.iconOffset[0]}px`);
      this.style.set("top", `${this.iconOffset[1]}px`);
      this.style.set("transform-origin", `${anchor[0] * 100}% ${anchor[1] * 100}%`);
      this.updateVisibilityBounds();
    }
    updateVisibilityBounds() {
      const size = this.iconSize.get();
      const maxProtrusion = Math.max(
        Math.hypot(this.iconOffset[0], this.iconOffset[1]),
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1]),
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1] + size),
        Math.hypot(this.iconOffset[0], this.iconOffset[1] + size)
      );
      const boundsOffset = maxProtrusion + 50;
      const projectedSize = this.props.mapProjection.getProjectedSize();
      this.visibilityBounds[0] = -boundsOffset;
      this.visibilityBounds[1] = -boundsOffset;
      this.visibilityBounds[2] = projectedSize[0] + boundsOffset;
      this.visibilityBounds[3] = projectedSize[1] + boundsOffset;
      this.needUpdatePositionRotation = this.showIcon;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateVisibilityBounds();
      }
      this.needUpdatePositionRotation = this.showIcon;
    }
    onUpdated(time, elapsed) {
      if (this.needUpdatePositionRotation) {
        this.updateIconPositionRotation();
        this.needUpdatePositionRotation = false;
        this.needUpdateVisibility = false;
      } else if (this.needUpdateVisibility) {
        this.updateIconVisibility();
        this.needUpdateVisibility = false;
      }
    }
    updateIconVisibility() {
      this.style.set("display", this.isInsideVisibilityBounds && this.showIcon ? "" : "none");
    }
    updateIconPositionRotation() {
      const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.vec2Cache[0]);
      this.isInsideVisibilityBounds = this.props.mapProjection.isInProjectedBounds(projected, this.visibilityBounds);
      if (this.isInsideVisibilityBounds) {
        let rotation;
        switch (this.ownAirplaneIconModule.orientation.get()) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
          case MapOwnAirplaneIconOrientation.TrackUp:
            rotation = this.planeRotation + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
            break;
          default:
            rotation = 0;
        }
        this.iconTransform.getChild(0).set(projected[0], projected[1], 0, 0.1);
        this.iconTransform.getChild(1).set(rotation, 0.1);
        this.style.set("transform", this.iconTransform.resolve());
      }
      this.updateIconVisibility();
    }
    render() {
      var _a;
      return FSComponent.buildComponent("img", { src: this.imageFilePath, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: this.style });
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (SubscribableUtils.isSubscribable(this.imageFilePath)) {
        this.imageFilePath.destroy();
      }
      this.isGsAboveTrackThreshold.destroy();
      (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.headingSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.trackSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.trackThresholdSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.iconSizeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.iconAnchorSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.orientationSub) === null || _h === void 0 ? void 0 : _h.destroy();
      super.destroy();
    }
  };
  MapOwnAirplaneLayer.vec2Cache = [Vec2Math.create()];
  var MapCullableTextLayer = class extends MapSyncedCanvasLayer {
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      this.props.manager.update(this.props.mapProjection);
      this.redrawLabels();
    }
    redrawLabels() {
      const labels = this.props.manager.visibleLabels;
      const display = this.display;
      display.clear();
      for (let i = labels.length - 1; i >= 0; i--) {
        labels[i].draw(display.context, this.props.mapProjection);
      }
    }
  };
  var MapAirspaceLayer = class extends MapLayer {
    constructor() {
      var _a, _b;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
        this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
        this.isAttached && this.scheduleSearch(0, true);
      });
      this.searchedAirspaces = /* @__PURE__ */ new Map();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
      this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
      this.activeRenderProcess = null;
      this.renderTaskQueueHandler = {
        renderTimeBudget: this.renderTimeBudget,
        onStarted() {
        },
        canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
          return timeElapsed < this.renderTimeBudget;
        },
        onPaused: this.onRenderPaused.bind(this),
        onFinished: this.onRenderFinished.bind(this),
        onAborted: this.onRenderAborted.bind(this)
      };
      this.searchDebounceTimer = 0;
      this.isSearchScheduled = false;
      this.needRefilter = false;
      this.isSearchBusy = false;
      this.lastDesiredSearchRadius = 0;
      this.lastSearchRadius = 0;
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
      this.isDisplayInvalidated = true;
      this.isAttached = false;
    }
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      this.updateClipBounds();
      this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
      this.props.maxSearchRadius.sub((radius) => {
        const radiusMeters = radius.asUnit(UnitType.METER);
        if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
          this.scheduleSearch(0, false);
        }
      });
      this.props.maxSearchItemCount.sub(() => {
        this.scheduleSearch(0, false);
      });
      this.initModuleListeners();
      this.isAttached = true;
      this.searchSession && this.scheduleSearch(0, true);
    }
    initModuleListeners() {
      const airspaceModule = this.props.model.getModule("airspace");
      for (const type of Object.values(airspaceModule.show)) {
        type.sub(this.onAirspaceTypeShowChanged.bind(this));
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateClipBounds();
      }
    }
    updateClipBounds() {
      const size = this.canvasLayerRef.instance.getSize();
      this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    scheduleSearch(delay, refilter) {
      if (!this.searchSession) {
        return;
      }
      this.searchDebounceTimer = delay;
      this.isSearchScheduled = true;
      this.needRefilter || (this.needRefilter = refilter);
    }
    scheduleRender() {
      this.isRenderScheduled = true;
    }
    async searchAirspaces(refilter) {
      this.isSearchBusy = true;
      const center = this.props.mapProjection.getCenter();
      const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
      this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
      this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
      const session = this.searchSession;
      refilter && session.setFilter(this.getBoundaryFilter());
      const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
      for (let i = 0; i < results.added.length; i++) {
        const airspace = results.added[i];
        this.searchedAirspaces.set(airspace.facility.id, airspace);
      }
      for (let i = 0; i < results.removed.length; i++) {
        this.searchedAirspaces.delete(results.removed[i]);
      }
      this.isSearchBusy = false;
      this.scheduleRender();
    }
    getBoundaryFilter() {
      const module = this.props.model.getModule("airspace");
      const show = module.show;
      let filter = 0;
      for (const type in show) {
        if (show[type].get()) {
          filter |= module.showTypes[type];
        }
      }
      return filter;
    }
    onUpdated(time, elapsed) {
      this.canvasLayerRef.instance.onUpdated(time, elapsed);
      this.updateFromInvalidation();
      this.updateScheduledRender();
      this.updateScheduledSearch(elapsed);
    }
    updateFromInvalidation() {
      const canvasLayer = this.canvasLayerRef.instance;
      const display = canvasLayer.display;
      const buffer = canvasLayer.buffer;
      const needBackgroundRender = !this.isBackgroundRenderScheduled && !this.activeRenderProcess && display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD;
      const shouldScheduleSearch = needBackgroundRender || display.isInvalid || buffer.isInvalid && this.activeRenderProcess;
      this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
      if (display.isInvalid) {
        this.isDisplayInvalidated = true;
        this.isBackgroundRenderScheduled = false;
        display.clear();
        display.syncWithMapProjection(this.props.mapProjection);
      }
      if (buffer.isInvalid) {
        if (this.activeRenderProcess) {
          this.activeRenderProcess.abort();
          this.cleanUpRender();
        }
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
      }
      if (shouldScheduleSearch) {
        this.scheduleSearch(this.searchDebounceDelay, false);
      }
    }
    updateScheduledSearch(elapsed) {
      if (!this.isSearchScheduled) {
        return;
      }
      this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
      if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
        this.searchAirspaces(this.needRefilter);
        this.isSearchScheduled = false;
        this.needRefilter = false;
      }
    }
    updateScheduledRender() {
      if (!this.isRenderScheduled) {
        return;
      }
      this.startRenderProcess();
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
    }
    startRenderProcess() {
      const canvasLayer = this.canvasLayerRef.instance;
      if (this.activeRenderProcess) {
        this.activeRenderProcess.abort();
      }
      const buffer = canvasLayer.buffer;
      buffer.clear();
      buffer.syncWithMapProjection(this.props.mapProjection);
      this.props.airspaceRenderManager.clearRegisteredAirspaces();
      for (const airspace of this.searchedAirspaces.values()) {
        if (this.isAirspaceInBounds(airspace, buffer)) {
          this.props.airspaceRenderManager.registerAirspace(airspace);
        }
      }
      const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
      this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
      this.activeRenderProcess.start();
    }
    isAirspaceInBounds(airspace, canvas) {
      const corner = MapAirspaceLayer.geoPointCache[0];
      const cornerProjected = MapAirspaceLayer.vec2Cache[0];
      let minX, maxX, minY, maxY;
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = maxX = cornerProjected[0];
      minY = maxY = cornerProjected[1];
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      const width = canvas.canvas.width;
      const height = canvas.canvas.height;
      return minX < width && maxX > 0 && minY < height && maxY > 0;
    }
    selectLod(resolution) {
      const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
      let i = thresholds.length - 1;
      while (i >= 0) {
        if (resolution * 2 >= thresholds[i]) {
          break;
        }
        i--;
      }
      return i;
    }
    cleanUpRender() {
      this.canvasLayerRef.instance.buffer.reset();
      this.activeRenderProcess = null;
    }
    renderAirspacesToDisplay() {
      const display = this.canvasLayerRef.instance.display;
      const buffer = this.canvasLayerRef.instance.buffer;
      display.clear();
      display.syncWithCanvasInstance(buffer);
      this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    onRenderPaused() {
      if (this.isDisplayInvalidated) {
        this.renderAirspacesToDisplay();
      }
    }
    onRenderFinished() {
      this.renderAirspacesToDisplay();
      this.cleanUpRender();
      this.isDisplayInvalidated = false;
    }
    onRenderAborted() {
      this.cleanUpRender();
    }
    onAirspaceTypeShowChanged() {
      this.scheduleSearch(0, true);
    }
    render() {
      return FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 });
    }
  };
  MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500;
  MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2;
  MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1;
  MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10;
  MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
  MapAirspaceLayer.vec2Cache = [new Float64Array(2)];
  var MapNearestWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
      this.searchRadius = 0;
      this.searchMargin = 0;
      this.userFacilityHasChanged = false;
      this.icaosToRender = /* @__PURE__ */ new Set();
      this.cachedRenderedWaypoints = /* @__PURE__ */ new Map();
      this.isInit = false;
      this.facilityRepoSubs = [];
    }
    onFacilityLoaderInitialized() {
      Promise.all([
        this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),
        this.facLoader.startNearestSearchSession(FacilitySearchType.User)
      ]).then((value) => {
        const [airportSession, vorSession, ndbSession, intSession, userSession] = value;
        this.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      });
    }
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession) {
      const callback = this.processSearchResults.bind(this);
      this.facilitySearches = {
        [FacilitySearchType.Airport]: new MapNearestWaypointsLayerSearch(airportSession, callback),
        [FacilitySearchType.Vor]: new MapNearestWaypointsLayerSearch(vorSession, callback),
        [FacilitySearchType.Ndb]: new MapNearestWaypointsLayerSearch(ndbSession, callback),
        [FacilitySearchType.Intersection]: new MapNearestWaypointsLayerSearch(intSession, callback),
        [FacilitySearchType.User]: new MapNearestWaypointsLayerSearch(userSession, callback)
      };
      const sub = this.props.bus.getSubscriber();
      this.facilityRepoSubs.push(sub.on("facility_added").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub.on("facility_changed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub.on("facility_removed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }));
      this.props.onSessionsStarted && this.props.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      if (this.isInit) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    onAttached() {
      super.onAttached();
      this.canvasLayerRef.instance.onAttached();
      this.doInit();
      this.isInit = true;
      this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    doInit() {
      this.initWaypointRenderer();
      this.updateSearchRadius();
    }
    getSearchCenter() {
      return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    initWaypointRenderer() {
      this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    refreshWaypoints() {
      this.tryRefreshAllSearches(void 0, void 0, true);
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.deregisterWaypoint(w, this.props.waypointRenderer);
      });
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.registerWaypoint(w, this.props.waypointRenderer);
      });
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
        this.updateSearchRadius();
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      } else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    updateSearchRadius() {
      let mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
      mapHalfDiagRange = Math.max(mapHalfDiagRange, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
      this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
      this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    onUpdated(time, elapsed) {
      var _a;
      if (this.userFacilityHasChanged) {
        const search = (_a = this.facilitySearches) === null || _a === void 0 ? void 0 : _a[FacilitySearchType.User];
        if (search !== void 0) {
          this.userFacilityHasChanged = false;
          this.scheduleSearchRefresh(FacilitySearchType.User, search, this.getSearchCenter(), this.searchRadius);
        }
      }
      this.updateSearches(elapsed);
    }
    updateSearches(elapsed) {
      if (!this.facilitySearches) {
        return;
      }
      this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
      this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
      this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
      this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
      this.facilitySearches[FacilitySearchType.User].update(elapsed);
    }
    tryRefreshAllSearches(center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshAllSearches(center, radius, force);
    }
    tryRefreshSearch(type, center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshSearch(type, center, radius, force);
    }
    _tryRefreshAllSearches(center, radius, force) {
      this._tryRefreshSearch(FacilitySearchType.Airport, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Vor, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.User, center, radius, force);
    }
    _tryRefreshSearch(type, center, radius, force) {
      const search = this.facilitySearches && this.facilitySearches[type];
      if (!search || !force && !this.shouldRefreshSearch(type, center, radius)) {
        return;
      }
      const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : void 0;
      if (radiusLimit !== void 0 && isFinite(radiusLimit)) {
        radius = Math.min(radius, Math.max(0, radiusLimit));
      }
      if (force || search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
        this.scheduleSearchRefresh(type, search, center, radius);
      }
    }
    shouldRefreshSearch(type, center, radius) {
      return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    scheduleSearchRefresh(type, search, center, radius) {
      const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
      search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    processSearchResults(results) {
      if (!results) {
        return;
      }
      const numAdded = results.added.length;
      for (let i = 0; i < numAdded; i++) {
        const icao = results.added[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.registerIcao(icao);
      }
      const numRemoved = results.removed.length;
      for (let i = 0; i < numRemoved; i++) {
        const icao = results.removed[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.deregisterIcao(icao);
      }
    }
    async registerIcao(icao) {
      this.icaosToRender.add(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (!this.icaosToRender.has(icao)) {
          return;
        }
        this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
      }
    }
    registerWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.set(facility.icao, waypoint);
      this.props.registerWaypoint(waypoint, renderer);
    }
    async deregisterIcao(icao) {
      this.icaosToRender.delete(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (this.icaosToRender.has(icao)) {
          return;
        }
        this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
        if (this.icaosToRender.has(icao)) {
          return;
        }
        const cachedWaypoint = this.cachedRenderedWaypoints.get(icao);
        if (cachedWaypoint !== void 0) {
          this.cachedRenderedWaypoints.delete(icao);
          this.props.deregisterWaypoint(cachedWaypoint, this.props.waypointRenderer);
        }
      }
    }
    deregisterWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.delete(facility.icao);
      this.props.deregisterWaypoint(waypoint, renderer);
    }
    setVisible(val) {
      super.setVisible(val);
      this.canvasLayerRef.instance.setVisible(val);
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.facilityRepoSubs.forEach((sub) => {
        sub.destroy();
      });
      super.destroy();
    }
  };
  MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
  var MapNearestWaypointsLayerSearch = class {
    constructor(session, refreshCallback) {
      this.session = session;
      this.refreshCallback = refreshCallback;
      this._lastCenter = new GeoPoint(0, 0);
      this._lastRadius = 0;
      this.maxItemCount = 0;
      this.refreshDebounceTimer = 0;
      this.isRefreshScheduled = false;
    }
    get lastCenter() {
      return this._lastCenter.readonly;
    }
    get lastRadius() {
      return this._lastRadius;
    }
    scheduleRefresh(center, radius, maxItemCount, delay) {
      this._lastCenter.set(center);
      this._lastRadius = radius;
      this.maxItemCount = maxItemCount;
      if (!this.isRefreshScheduled) {
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
      }
    }
    update(elapsed) {
      if (!this.isRefreshScheduled) {
        return;
      }
      this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
      if (this.refreshDebounceTimer === 0) {
        this.refresh();
        this.isRefreshScheduled = false;
      }
    }
    async refresh() {
      const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
      this.refreshCallback(results);
    }
  };
  var MapLineLayer = class extends MapSyncedCanvasLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(...arguments);
      this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapLineLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapLineLayer.DEFAULT_STROKE_STYLE;
      this.strokeDash = (_c = this.props.strokeDash) !== null && _c !== void 0 ? _c : MapLineLayer.DEFAULT_STROKE_DASH;
      this.outlineWidth = (_d = this.props.outlineWidth) !== null && _d !== void 0 ? _d : MapLineLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_e = this.props.outlineStyle) !== null && _e !== void 0 ? _e : MapLineLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineDash = (_f = this.props.outlineDash) !== null && _f !== void 0 ? _f : MapLineLayer.DEFAULT_OUTLINE_DASH;
      this.vec = new Float64Array([0, 0]);
      this.isUpdateScheduled = false;
    }
    onAttached() {
      super.onAttached();
      this.props.start.sub(() => {
        this.scheduleUpdate();
      });
      this.props.end.sub(() => {
        this.scheduleUpdate();
      });
      this.scheduleUpdate();
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.scheduleUpdate();
    }
    scheduleUpdate() {
      this.isUpdateScheduled = true;
    }
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (this.isUpdateScheduled) {
        this.display.clear();
        const start = this.props.start.get();
        const end = this.props.end.get();
        if (start !== null && end !== null) {
          const [x1, y1] = start instanceof Float64Array ? start : this.props.mapProjection.project(start, this.vec);
          const [x2, y2] = end instanceof Float64Array ? end : this.props.mapProjection.project(end, this.vec);
          this.drawLine(x1, y1, x2, y2);
        }
        this.isUpdateScheduled = false;
      }
    }
    drawLine(x1, y1, x2, y2) {
      const context = this.display.context;
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      if (this.outlineWidth > 0) {
        this.stroke(context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
      }
      if (this.strokeWidth > 0) {
        this.stroke(context, this.strokeWidth, this.strokeStyle, this.strokeDash);
      }
    }
    stroke(context, width, style, dash) {
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash);
      context.stroke();
    }
  };
  MapLineLayer.DEFAULT_STROKE_WIDTH = 2;
  MapLineLayer.DEFAULT_STROKE_STYLE = "white";
  MapLineLayer.DEFAULT_STROKE_DASH = [];
  MapLineLayer.DEFAULT_OUTLINE_WIDTH = 0;
  MapLineLayer.DEFAULT_OUTLINE_STYLE = "black";
  MapLineLayer.DEFAULT_OUTLINE_DASH = [];
  var MapSystemController = class {
    constructor(context) {
      this._isAlive = true;
      this.context = context;
    }
    get isAlive() {
      return this._isAlive;
    }
    onAfterMapRender(ref) {
    }
    onDeadZoneChanged(deadZone) {
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    onBeforeUpdated(time, elapsed) {
    }
    onAfterUpdated(time, elapsed) {
    }
    onWake() {
    }
    onSleep() {
    }
    onMapDestroyed() {
    }
    destroy() {
      this._isAlive = false;
    }
  };
  var MapBindingsController = class extends MapSystemController {
    constructor(context, bindings, onDestroy) {
      super(context);
      this.bindings = bindings;
      this.onDestroy = onDestroy;
      this.maps = [];
      this.pipes = [];
    }
    onAfterMapRender() {
      for (const binding of this.bindings) {
        if ("map" in binding) {
          if ("sources" in binding) {
            const map = MappedSubject.create(...binding.sources);
            this.maps.push(map);
            this.pipes.push(map.pipe(binding.target, binding.map));
          } else {
            this.pipes.push(binding.source.pipe(binding.target, binding.map));
          }
        } else {
          this.pipes.push(binding.source.pipe(binding.target));
        }
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    onWake() {
      this.maps.forEach((map) => {
        map.resume();
      });
      this.pipes.forEach((pipe) => {
        pipe.resume(true);
      });
    }
    onSleep() {
      this.maps.forEach((map) => {
        map.pause();
      });
      this.pipes.forEach((pipe) => {
        pipe.pause();
      });
    }
    destroy() {
      this.onDestroy && this.onDestroy();
      this.maps.forEach((map) => {
        map.destroy();
      });
      this.pipes.forEach((pipe) => {
        pipe.destroy();
      });
      super.destroy();
    }
  };
  var MapClockUpdateController = class extends MapSystemController {
    onAfterMapRender(ref) {
      this.freqSub = this.context.updateFreq.sub((freq) => {
        var _a;
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.clockSub = this.context.bus.getSubscriber().on("realTime").atFrequency(freq).handle((realTime) => {
          ref.update(realTime);
        });
      }, true);
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var MapFlightPlanController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
      this.planCopiedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
      };
      this.planCreatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
      };
      this.planDeletedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(void 0);
      };
      this.planChangeHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
      };
      this.planCalculatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
      };
      this.activeLegChangedHandler = (evt) => {
        if (evt.type === ActiveLegType.Lateral) {
          this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.index);
        }
      };
    }
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      this.fplCopiedSub = sub.on("fplCopied").handle(this.planCopiedHandler);
      this.fplCreatedSub = sub.on("fplCreated").handle(this.planCreatedHandler);
      this.fplDeletedSub = sub.on("fplDeleted").handle(this.planDeletedHandler);
      this.fplDirectToDataChangedSub = sub.on("fplDirectToDataChanged").handle(this.planChangeHandler);
      this.fplLoadedSub = sub.on("fplLoaded").handle(this.planCreatedHandler);
      this.fplOriginDestChangedSub = sub.on("fplOriginDestChanged").handle(this.planChangeHandler);
      this.fplProcDetailsChangedSub = sub.on("fplProcDetailsChanged").handle(this.planChangeHandler);
      this.fplSegmentChangeSub = sub.on("fplSegmentChange").handle(this.planChangeHandler);
      this.fplUserDataDeleteSub = sub.on("fplUserDataDelete").handle(this.planChangeHandler);
      this.fplUserDataSetSub = sub.on("fplUserDataSet").handle(this.planChangeHandler);
      this.fplActiveLegChangeSub = sub.on("fplActiveLegChange").handle(this.activeLegChangedHandler);
      this.fplCalculatedSub = sub.on("fplCalculated").handle(this.planCalculatedHandler);
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      super.destroy();
      (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
      (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
      (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
  };
  var MapFollowAirplaneController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
      this.mapProjectionParams = {
        target: new GeoPoint(0, 0)
      };
      this.targetControl = this.context[MapSystemKeys.TargetControl];
      this.targetControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.isFollowingAirplane.set(true);
        },
        onCeded: () => {
          this.isFollowingAirplane.set(false);
        }
      };
    }
    onAfterMapRender() {
      this.targetControl.claim(this.targetControlConsumer);
    }
    onBeforeUpdated() {
      if (this.isFollowingAirplane.get()) {
        this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
        this.context.projection.setQueued(this.mapProjectionParams);
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      super.destroy();
      this.targetControl.forfeit(this.targetControlConsumer);
    }
  };
  var MapRotation;
  (function(MapRotation2) {
    MapRotation2["Undefined"] = "Undefined";
    MapRotation2["NorthUp"] = "NorthUp";
    MapRotation2["TrackUp"] = "TrackUp";
    MapRotation2["HeadingUp"] = "HeadingUp";
    MapRotation2["DtkUp"] = "DtkUp";
  })(MapRotation || (MapRotation = {}));
  var MapRotationModule = class {
    constructor() {
      this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
  };
  var MapOwnAirplaneIconOrientationController = class extends MapSystemController {
    constructor(context, desiredOrientation) {
      super(context);
      this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
      this.needUpdateIconOrientation = false;
      this.desiredIconOrientation = SubscribableUtils.toSubscribable(desiredOrientation, true);
      this.orientationState = MappedSubject.create(this.desiredIconOrientation, this.context.model.getModule(MapSystemKeys.Rotation).rotationType);
    }
    onAfterMapRender() {
      var _a;
      (_a = this.orientationState) === null || _a === void 0 ? void 0 : _a.sub(() => {
        this.needUpdateIconOrientation = true;
      }, true);
    }
    onBeforeUpdated() {
      if (this.needUpdateIconOrientation) {
        const [desiredOrientation, rotation] = this.orientationState.get();
        if (desiredOrientation === MapOwnAirplaneIconOrientation.HeadingUp && rotation === MapRotation.HeadingUp || desiredOrientation === MapOwnAirplaneIconOrientation.TrackUp && rotation === MapRotation.TrackUp) {
          this.ownAirplaneIconModule.orientation.set(MapOwnAirplaneIconOrientation.MapUp);
        } else {
          this.ownAirplaneIconModule.orientation.set(desiredOrientation);
        }
        this.needUpdateIconOrientation = false;
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      this.orientationState.destroy();
      super.destroy();
    }
  };
  var MapOwnAirplanePropsController = class extends MapSystemController {
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.subs = {};
    }
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      this.updateFreqSub = this.updateFreq.sub((freq) => {
        var _a;
        for (const property of this.properties) {
          (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
          this.subs[property] = this.bindProperty(sub, property, freq);
        }
      }, true);
    }
    bindProperty(sub, property, updateFreq) {
      switch (property) {
        case "position":
          return sub.on("gps-position").atFrequency(updateFreq).handle((lla) => {
            this.module.position.set(lla.lat, lla.long);
          });
        case "altitude":
          return sub.on("indicated_alt").atFrequency(updateFreq).handle((alt) => {
            this.module.altitude.set(alt, UnitType.FOOT);
          });
        case "groundSpeed":
          return sub.on("ground_speed").atFrequency(updateFreq).handle((gs) => {
            this.module.groundSpeed.set(gs, UnitType.KNOT);
          });
        case "hdgTrue":
          return sub.on("hdg_deg_true").atFrequency(updateFreq).handle((hdg) => {
            this.module.hdgTrue.set(hdg);
          });
        case "trackTrue":
          return sub.on("track_deg_true").atFrequency(updateFreq).handle((track) => {
            this.module.trackTrue.set(track);
          });
        case "verticalSpeed":
          return sub.on("vertical_speed").atFrequency(updateFreq).handle((vs) => {
            this.module.verticalSpeed.set(vs, UnitType.FPM);
          });
        case "turnRate":
          return sub.on("delta_heading_rate").atFrequency(updateFreq).handle((turnRate) => {
            this.module.turnRate.set(turnRate);
          });
        case "isOnGround":
          return sub.on("on_ground").atFrequency(updateFreq).handle((isOnGround) => {
            this.module.isOnGround.set(isOnGround);
          });
        case "magVar":
          return sub.on("magvar").atFrequency(updateFreq).handle((magVar) => {
            this.module.magVar.set(magVar);
          });
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapRotationController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.rotationParam = {
        rotation: 0
      };
      this.hasRotationControl = false;
      this.rotationControl = this.context[MapSystemKeys.RotationControl];
      this.rotationControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.hasRotationControl = true;
        },
        onCeded: () => {
          this.hasRotationControl = false;
        }
      };
      this.rotationFuncs = {
        [MapRotation.NorthUp]: () => 0,
        [MapRotation.HeadingUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.TrackUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => this.ownAirplanePropsModule.groundSpeed.get().asUnit(UnitType.KNOT) < 5 ? -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD : -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.DtkUp]: () => 0
      };
    }
    onAfterMapRender() {
      this.rotationSub = this.rotationModule.rotationType.sub((type) => {
        this.rotationFunc = this.rotationFuncs[type];
      }, true);
      this.rotationControl.claim(this.rotationControlConsumer);
    }
    onBeforeUpdated() {
      if (this.hasRotationControl && this.rotationFunc !== void 0) {
        this.rotationParam.rotation = this.rotationFunc();
        this.context.projection.setQueued(this.rotationParam);
      }
    }
    onMapDestroyed() {
      super.onMapDestroyed();
      this.destroy();
    }
    destroy() {
      var _a;
      super.destroy();
      (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.rotationControl.forfeit(this.rotationControlConsumer);
    }
  };
  var MapSystemWaypointRoles;
  (function(MapSystemWaypointRoles2) {
    MapSystemWaypointRoles2["Normal"] = "Normal";
    MapSystemWaypointRoles2["FlightPlan"] = "FlightPlan";
  })(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));
  var MapSystemFlightPlanLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.instanceId = MapSystemFlightPlanLayer.instanceId++;
      this.flightPathLayerRef = FSComponent.createRef();
      this.waypointLayerRef = FSComponent.createRef();
      this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
      this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
      this.waypointPrefix = `${MapSystemFlightPlanLayer.WAYPOINT_PREFIX}_${this.instanceId}`;
      this.legWaypoints = /* @__PURE__ */ new Map();
      this.waypointsUpdating = false;
      this.waypointId = 0;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
      this.facWaypointCache = DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.clipBounds = VecNSubject.create(new Float64Array(4));
      this.clippedPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.clipBounds);
      this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
      this.updateScheduled = false;
    }
    onAttached() {
      this.flightPathLayerRef.instance.onAttached();
      this.waypointLayerRef.instance.onAttached();
      this.pathStreamStack.pushPostProjected(this.clippedPathStream);
      this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
      this.initWaypointRenderer();
      this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
      this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
      super.onAttached();
    }
    initWaypointRenderer() {
      let hasDefaultRole = false;
      const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
      for (let i = 0; i < flightPlanRoles.length; i++) {
        const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
        if (roleId !== void 0) {
          this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
          this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
          this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
          if (!hasDefaultRole) {
            this.props.flightPathRenderer.defaultRoleId = roleId;
            hasDefaultRole = true;
          }
        }
      }
    }
    onUpdated(time, elapsed) {
      this.flightPathLayerRef.instance.onUpdated(time, elapsed);
      this.waypointLayerRef.instance.onUpdated(time, elapsed);
      if (this.isVisible()) {
        const display = this.flightPathLayerRef.instance.display;
        if (display.isInvalid) {
          display.clear();
          display.syncWithMapProjection(this.props.mapProjection);
          this.updateScheduled = true;
        }
        if (this.updateScheduled) {
          if (!this.waypointsUpdating) {
            this.updateWaypoints();
          }
          const context = display.context;
          display.clear();
          const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
          if (plan !== void 0) {
            this.pathStreamStack.setProjection(display.geoProjection);
            this.props.flightPathRenderer.render(plan, void 0, void 0, context, this.pathStreamStack);
          }
          this.updateScheduled = false;
        }
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      const size = this.flightPathLayerRef.instance.getSize();
      this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);
    }
    setVisible(val) {
      super.setVisible(val);
      this.waypointLayerRef.instance.setVisible(val);
      this.flightPathLayerRef.instance.setVisible(val);
    }
    async updateWaypoints() {
      if (this.waypointsUpdating) {
        throw new Error("A flight plan waypoint update is already in progress.");
      }
      this.waypointsUpdating = true;
      const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
      const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
      if (flightPlan === void 0) {
        for (const legWaypoint of this.legWaypoints.values()) {
          const [waypoint, roleId] = legWaypoint;
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
        this.legWaypoints.clear();
        this.waypointsUpdating = false;
        return;
      }
      const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
      const legsToDisplay = /* @__PURE__ */ new Map();
      let legIndex = 0;
      for (const leg of flightPlan.legs()) {
        let roleId = this.defaultRoleId;
        const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
        if (handler !== void 0) {
          roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
        }
        if (roleId !== 0) {
          legsToDisplay.set(leg, roleId);
        }
        legIndex++;
      }
      for (const leg of this.legWaypoints) {
        const [legDefinition, legWaypoint] = leg;
        const [waypoint, roleId] = legWaypoint;
        if (!legsToDisplay.has(legDefinition)) {
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.delete(legDefinition);
        }
      }
      const waypointRefreshes = [];
      for (const leg of legsToDisplay) {
        waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
      }
      await Promise.all(waypointRefreshes);
      this.waypointsUpdating = false;
    }
    async buildPlanWaypoint(leg, roleId) {
      switch (leg.leg.type) {
        case LegType.CD:
        case LegType.VD:
        case LegType.CR:
        case LegType.VR:
        case LegType.FC:
        case LegType.FD:
        case LegType.FA:
        case LegType.CA:
        case LegType.VA:
        case LegType.FM:
        case LegType.VM:
        case LegType.CI:
        case LegType.VI:
          await this.buildTerminatorWaypoint(leg, roleId);
          break;
        case LegType.Discontinuity:
        case LegType.ThruDiscontinuity:
          break;
        default:
          await this.buildFixWaypoint(leg, roleId);
          break;
      }
    }
    async buildTerminatorWaypoint(leg, roleId) {
      var _a, _b, _c, _d, _e, _f;
      const currentLeg = this.legWaypoints.get(leg);
      if (currentLeg !== void 0) {
        const [waypoint, currentRoleId] = currentLeg;
        const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
        if (lastVector !== void 0) {
          if (!waypoint.location.get().equals(lastVector.endLat, lastVector.endLon)) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            const ident = (_c = leg.name) !== null && _c !== void 0 ? _c : "";
            const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
            this.legWaypoints.set(leg, [newWaypoint, roleId]);
            this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          } else if (currentRoleId !== roleId) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            this.legWaypoints.set(leg, [waypoint, roleId]);
          }
        } else {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
        }
      } else {
        const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
        if (lastVector !== void 0) {
          const ident = (_f = leg.name) !== null && _f !== void 0 ? _f : "";
          const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
      }
    }
    async buildFixWaypoint(leg, roleId) {
      var _a;
      const legWaypoint = this.legWaypoints.get(leg);
      if (legWaypoint === void 0) {
        const facIcao = leg.leg.fixIcao;
        let facility;
        try {
          facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
        } catch (err) {
        }
        if (facility !== void 0) {
          const waypoint = this.facWaypointCache.get(facility);
          const ident = (_a = leg.name) !== null && _a !== void 0 ? _a : "";
          const newWaypoint = new FlightPathWaypoint(waypoint.location, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
        }
      } else {
        const [waypoint, currentRoleId] = legWaypoint;
        if (currentRoleId !== roleId) {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
          this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [waypoint, roleId]);
        }
      }
    }
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        FSComponent.Fragment,
        null,
        FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, overdrawFactor: Math.SQRT2, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }),
        FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_b = this.props.class) !== null && _b !== void 0 ? _b : "" })
      );
    }
  };
  MapSystemFlightPlanLayer.WAYPOINT_PREFIX = "MapSystemFplLayer";
  MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10;
  MapSystemFlightPlanLayer.instanceId = 0;
  var AdsbOperatingMode;
  (function(AdsbOperatingMode2) {
    AdsbOperatingMode2["Standby"] = "Standby";
    AdsbOperatingMode2["Surface"] = "Surface";
    AdsbOperatingMode2["Airborne"] = "Airborne";
  })(AdsbOperatingMode || (AdsbOperatingMode = {}));
  var TcasOperatingMode;
  (function(TcasOperatingMode2) {
    TcasOperatingMode2["Off"] = "Off";
    TcasOperatingMode2["Standby"] = "Standby";
    TcasOperatingMode2["TAOnly"] = "TAOnly";
    TcasOperatingMode2["TA_RA"] = "TA/RA";
    TcasOperatingMode2["Test"] = "Test";
    TcasOperatingMode2["Failed"] = "Failed";
  })(TcasOperatingMode || (TcasOperatingMode = {}));
  var TcasAlertLevel;
  (function(TcasAlertLevel2) {
    TcasAlertLevel2[TcasAlertLevel2["None"] = 0] = "None";
    TcasAlertLevel2[TcasAlertLevel2["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
  })(TcasAlertLevel || (TcasAlertLevel = {}));
  var TcasResolutionAdvisoryFlags;
  (function(TcasResolutionAdvisoryFlags2) {
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Corrective"] = 1] = "Corrective";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["UpSense"] = 2] = "UpSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DownSense"] = 4] = "DownSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Crossing"] = 8] = "Crossing";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Climb"] = 16] = "Climb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Descend"] = 32] = "Descend";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Increase"] = 64] = "Increase";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Reversal"] = 128] = "Reversal";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceClimb"] = 256] = "ReduceClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceDescent"] = 512] = "ReduceDescent";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotClimb"] = 1024] = "DoNotClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotDescend"] = 2048] = "DoNotDescend";
  })(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
  var TcasResolutionAdvisoryType;
  (function(TcasResolutionAdvisoryType2) {
    TcasResolutionAdvisoryType2["Climb"] = "Climb";
    TcasResolutionAdvisoryType2["CrossingClimb"] = "CrossingClimb";
    TcasResolutionAdvisoryType2["MaintainClimb"] = "MaintainClimb";
    TcasResolutionAdvisoryType2["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    TcasResolutionAdvisoryType2["IncreaseClimb"] = "IncreaseClimb";
    TcasResolutionAdvisoryType2["ReversalClimb"] = "ReversalClimb";
    TcasResolutionAdvisoryType2["ReduceDescent"] = "ReduceDescent";
    TcasResolutionAdvisoryType2["DoNotDescend0"] = "DoNotDescend0";
    TcasResolutionAdvisoryType2["DoNotDescend500"] = "DoNotDescend500";
    TcasResolutionAdvisoryType2["DoNotDescend1000"] = "DoNotDescend1000";
    TcasResolutionAdvisoryType2["DoNotDescend1500"] = "DoNotDescend1500";
    TcasResolutionAdvisoryType2["DoNotDescend2000"] = "DoNotDescend2000";
    TcasResolutionAdvisoryType2["Descend"] = "Descend";
    TcasResolutionAdvisoryType2["CrossingDescend"] = "CrossingDescend";
    TcasResolutionAdvisoryType2["MaintainDescend"] = "MaintainDescend";
    TcasResolutionAdvisoryType2["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    TcasResolutionAdvisoryType2["IncreaseDescend"] = "IncreaseDescend";
    TcasResolutionAdvisoryType2["ReversalDescend"] = "ReversalDescend";
    TcasResolutionAdvisoryType2["ReduceClimb"] = "ReduceClimb";
    TcasResolutionAdvisoryType2["DoNotClimb0"] = "DoNotClimb0";
    TcasResolutionAdvisoryType2["DoNotClimb500"] = "DoNotClimb500";
    TcasResolutionAdvisoryType2["DoNotClimb1000"] = "DoNotClimb1000";
    TcasResolutionAdvisoryType2["DoNotClimb1500"] = "DoNotClimb1500";
    TcasResolutionAdvisoryType2["DoNotClimb2000"] = "DoNotClimb2000";
    TcasResolutionAdvisoryType2["Clear"] = "Clear";
  })(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
  var Tcas = class {
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.bus = bus;
      this.tfcInstrument = tfcInstrument;
      this.maxIntruderCount = maxIntruderCount;
      this.realTimeUpdateFreq = realTimeUpdateFreq;
      this.simTimeUpdateFreq = simTimeUpdateFreq;
      this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
      this.intrudersSorted = [];
      this.intrudersFiltered = [];
      this.intrudersRA = /* @__PURE__ */ new Set();
      this.contactCreatedHandler = this.onContactAdded.bind(this);
      this.contactRemovedHandler = this.onContactRemoved.bind(this);
      this.ownAirplaneSubs = {
        position: GeoPointSubject.create(new GeoPoint(0, 0)),
        altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        groundTrack: ConsumerSubject.create(null, 0),
        groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
        verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
        radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        isOnGround: ConsumerSubject.create(null, false)
      };
      this.simTime = ConsumerSubject.create(null, 0);
      this.lastUpdateSimTime = 0;
      this.lastUpdateRealTime = 0;
      this.alertLevelSubs = /* @__PURE__ */ new Map();
      this.eventPublisher = this.bus.getPublisher();
      this.eventSubscriber = this.bus.getSubscriber();
      this.paSeparationCache = {
        horizontal: UnitType.NMILE.createNumber(0),
        vertical: UnitType.FOOT.createNumber(0)
      };
      this.sensitivity = this.createSensitivity();
      this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
      const fullRAOptions = {
        initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
        initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
        subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
        subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
        allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : () => true,
        allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : () => true,
        allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100,
        allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450
      };
      this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    getOperatingMode() {
      return this.operatingModeSub.get();
    }
    setOperatingMode(mode) {
      this.operatingModeSub.set(mode);
    }
    getIntruders() {
      return this.intrudersFiltered;
    }
    getResolutionAdvisoryHost() {
      return this.resolutionAdvisoryHost;
    }
    getEventSubscriber() {
      return this.eventSubscriber;
    }
    init() {
      const sub = this.bus.getSubscriber();
      this.contactCreatedConsumer = sub.on("traffic_contact_added");
      this.contactRemovedConsumer = sub.on("traffic_contact_removed");
      this.contactCreatedConsumer.handle(this.contactCreatedHandler);
      this.contactRemovedConsumer.handle(this.contactRemovedHandler);
      this.tfcInstrument.forEachContact((contact) => {
        this.onContactAdded(contact.uid);
      });
      sub.on("gps-position").atFrequency(this.realTimeUpdateFreq).handle((lla) => {
        this.ownAirplaneSubs.position.set(lla.lat, lla.long);
        this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
      });
      sub.on("ground_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((gs) => {
        this.ownAirplaneSubs.groundSpeed.set(gs);
      });
      sub.on("vertical_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((vs) => {
        this.ownAirplaneSubs.verticalSpeed.set(vs);
      });
      sub.on("radio_alt").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((alt) => {
        this.ownAirplaneSubs.radarAltitude.set(alt);
      });
      this.ownAirplaneSubs.groundTrack.setConsumer(sub.on("track_deg_true"));
      this.ownAirplaneSubs.isOnGround.setConsumer(sub.on("on_ground"));
      this.simTime.setConsumer(sub.on("simTime"));
      this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
      sub.on("simTime").whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    onOperatingModeChanged(mode) {
      this.bus.pub("tcas_operating_mode", mode, false, true);
      if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.cancel(this.simTime.get());
        for (let i = 0; i < this.intrudersFiltered.length; i++) {
          this.cleanUpIntruder(this.intrudersFiltered[i]);
        }
        this.intrudersFiltered = [];
      }
    }
    intruderComparator(a, b) {
      if (a.isPredictionValid && !b.isPredictionValid) {
        return -1;
      } else if (!a.isPredictionValid && b.isPredictionValid) {
        return 1;
      } else if (a.isPredictionValid) {
        let tcaPredictionA, tcaPredictionB;
        const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || a.tcaRA.isValid && a.tcaRA.isThreat;
        const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || b.tcaRA.isValid && b.tcaRA.isThreat;
        if (aRA && !bRA) {
          return -1;
        } else if (!aRA && bRA) {
          return 1;
        } else if (aRA && bRA) {
          tcaPredictionA = a.tcaRA;
          tcaPredictionB = b.tcaRA;
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || a.tcaTA.isValid && a.tcaTA.isThreat;
          const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || b.tcaTA.isValid && b.tcaTA.isThreat;
          if (aTA && !bTA) {
            return -1;
          } else if (!aTA && bTA) {
            return 1;
          } else if (aTA && bTA) {
            tcaPredictionA = a.tcaTA;
            tcaPredictionB = b.tcaTA;
          }
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
            return -1;
          } else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
            return 1;
          } else {
            return 0;
          }
        }
        const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
        const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
        let firstComparison;
        let secondComparison;
        if (tcaPredictionA.isThreat) {
          firstComparison = tcaComparison;
          secondComparison = normComparison;
        } else {
          firstComparison = normComparison;
          secondComparison = tcaComparison;
        }
        if (firstComparison === 0) {
          return secondComparison;
        } else {
          return firstComparison;
        }
      } else {
        return 0;
      }
    }
    onContactAdded(uid) {
      const contact = this.tfcInstrument.getContact(uid);
      const intruder = this.createIntruderEntry(contact);
      this.intrudersSorted.push(intruder);
    }
    onContactRemoved(uid) {
      const sortedIndex = this.intrudersSorted.findIndex((intruder) => intruder.contact.uid === uid);
      const culledIndex = this.intrudersFiltered.findIndex((intruder) => intruder.contact.uid === uid);
      if (sortedIndex >= 0) {
        this.intrudersSorted.splice(sortedIndex, 1);
      }
      if (culledIndex >= 0) {
        const removed = this.intrudersFiltered[culledIndex];
        this.intrudersFiltered.splice(culledIndex, 1);
        this.cleanUpIntruder(removed);
      }
    }
    onSimTimeChanged(simTime) {
      switch (this.operatingModeSub.get()) {
        case TcasOperatingMode.Off:
        case TcasOperatingMode.Standby:
        case TcasOperatingMode.Failed:
        case TcasOperatingMode.Test:
          return;
      }
      const realTime = Date.now();
      if (Math.abs(simTime - this.lastUpdateSimTime) < 1e3 / this.simTimeUpdateFreq || Math.abs(realTime - this.lastUpdateRealTime) < 1e3 / this.realTimeUpdateFreq) {
        return;
      }
      this.doUpdate(simTime);
      this.lastUpdateSimTime = simTime;
      this.lastUpdateRealTime = realTime;
    }
    doUpdate(simTime) {
      this.updateSensitivity();
      this.updateIntruderPredictions(simTime);
      this.updateIntruderArrays();
      this.updateFilteredIntruderAlertLevels(simTime);
      this.updateResolutionAdvisory(simTime);
    }
    updateIntruderPredictions(simTime) {
      this.ownAirplane.update(simTime);
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersSorted[i];
        const sensitivity = this.sensitivity.selectParameters(intruder);
        intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
      }
    }
    updateIntruderArrays() {
      this.intrudersSorted.sort(this.intruderComparator.bind(this));
      const oldCulled = this.intrudersFiltered;
      this.intrudersFiltered = [];
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
        const intruder = this.intrudersSorted[i];
        if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
          this.intrudersFiltered.push(intruder);
          if (!oldCulled.includes(intruder)) {
            this.initIntruder(intruder);
          }
        } else {
          if (oldCulled.includes(intruder)) {
            this.cleanUpIntruder(intruder);
          }
        }
      }
    }
    filterIntruder(intruder) {
      return true;
    }
    updateFilteredIntruderAlertLevels(simTime) {
      let taCount = 0, raCount = 0;
      const len = this.intrudersFiltered.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersFiltered[i];
        this.updateIntruderAlertLevel(simTime, intruder);
        switch (intruder.alertLevel.get()) {
          case TcasAlertLevel.TrafficAdvisory:
            taCount++;
            break;
          case TcasAlertLevel.ResolutionAdvisory:
            raCount++;
            break;
        }
      }
      this.eventPublisher.pub("tcas_ta_intruder_count", taCount, false, true);
      this.eventPublisher.pub("tcas_ra_intruder_count", raCount, false, true);
    }
    updateIntruderAlertLevel(simTime, intruder) {
      const currentAlertLevel = intruder.alertLevel.get();
      if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
        if (this.canIssueResolutionAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat) && !this.canCancelResolutionAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
        if (this.canIssueTrafficAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat) && !this.canCancelTrafficAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.isPredictionValid) {
        const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
        const radius = parametersPA.protectedRadius;
        const height = parametersPA.protectedHeight;
        if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
          intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
          if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0 && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
            intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
            return;
          }
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
        return;
      }
      intruder.alertLevel.set(TcasAlertLevel.None);
    }
    canIssueResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() === TcasOperatingMode.TA_RA && intruder.tcaRA.isValid && intruder.tcaRA.tcpa.number > 0 && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    canCancelResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    canIssueTrafficAdvisory(simTime, intruder) {
      return true;
    }
    canCancelTrafficAdvisory(simTime, intruder) {
      return true;
    }
    canIssueProximityAdvisory(simTime, intruder) {
      return true;
    }
    canCancelProximityAdvisory(simTime, intruder) {
      return true;
    }
    updateResolutionAdvisory(simTime) {
      if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
      } else {
        this.resolutionAdvisoryHost.cancel(simTime);
      }
    }
    initIntruder(intruder) {
      this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
      this.eventPublisher.pub("tcas_intruder_added", intruder, false, false);
    }
    cleanUpIntruder(intruder) {
      var _a;
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.delete(intruder);
      }
      (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
      this.eventPublisher.pub("tcas_intruder_removed", intruder, false, false);
    }
    onAlertLevelChanged(intruder) {
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.add(intruder);
      } else {
        this.intrudersRA.delete(intruder);
      }
      this.eventPublisher.pub("tcas_intruder_alert_changed", intruder, false, false);
    }
  };
  Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
  };
  var TcasAirplane = class {
    constructor() {
      this._position = new GeoPoint(0, 0);
      this.position = this._position.readonly;
      this._altitude = UnitType.FOOT.createNumber(0);
      this.altitude = this._altitude.readonly;
      this._groundTrack = 0;
      this._groundSpeed = UnitType.KNOT.createNumber(0);
      this.groundSpeed = this._groundSpeed.readonly;
      this._verticalSpeed = UnitType.FPM.createNumber(0);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.positionVec = new Float64Array(3);
      this.velocityVec = new Float64Array(3);
      this.lastUpdateTime = 0;
    }
    get groundTrack() {
      return this._groundTrack;
    }
  };
  var OwnAirplane = class extends TcasAirplane {
    constructor(subs) {
      super();
      this.subs = subs;
      this._radarAltitude = UnitType.FOOT.createNumber(0);
      this.radarAltitude = this._radarAltitude.readonly;
      this._isOnGround = false;
    }
    get isOnGround() {
      return this._isOnGround;
    }
    predictPosition(simTime, out) {
      const dt = (simTime - this.lastUpdateTime) / 1e3;
      return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    update(simTime) {
      this.updateParameters();
      this.updateVectors();
      this.lastUpdateTime = simTime;
    }
    updateParameters() {
      this._position.set(this.subs.position.get());
      this._altitude.set(this.subs.altitude.get());
      this._groundTrack = this.subs.groundTrack.get();
      this._groundSpeed.set(this.subs.groundSpeed.get());
      this._verticalSpeed.set(this.subs.verticalSpeed.get());
      this._radarAltitude.set(this.subs.radarAltitude.get());
      this._isOnGround = this.subs.isOnGround.get();
    }
    updateVectors() {
      Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
    }
  };
  var AbstractTcasIntruder = class extends TcasAirplane {
    constructor(contact) {
      super();
      this.contact = contact;
      this.alertLevel = Subject.create(TcasAlertLevel.None);
      this.relativePositionVec = new Float64Array(3);
      this.relativeVelocityVec = new Float64Array(3);
      this._isPredictionValid = false;
      this.tcaTA = new TcasTcaPredictionClass(this);
      this.tcaRA = new TcasTcaPredictionClass(this);
    }
    get isPredictionValid() {
      return this._isPredictionValid;
    }
    predictDisplacement(simTime, out) {
      if (!this._isPredictionValid) {
        return Vec3Math.set(NaN, NaN, NaN, out);
      }
      const dt = (simTime - this.contact.lastContactTime) / 1e3;
      return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    predictSeparation(simTime, horizontalOut, verticalOut) {
      if (!this._isPredictionValid) {
        horizontalOut.set(NaN);
        verticalOut.set(NaN);
        return;
      }
      const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
      AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
      AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    updatePrediction(simTime, ownAirplane, sensitivity) {
      this.updateParameters(simTime, ownAirplane);
      if (this.isPredictionValid) {
        const taParams = sensitivity.parametersTA;
        const raParams = sensitivity.parametersRA;
        this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
        this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
      } else {
        this.invalidatePredictions();
      }
      this.lastUpdateTime = simTime;
    }
    updateParameters(simTime, ownAirplane) {
      if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
        this._isPredictionValid = false;
        this._position.set(NaN, NaN);
        this._altitude.set(NaN);
        this._groundTrack = NaN;
        this._groundSpeed.set(NaN);
        this._verticalSpeed.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.positionVec);
        Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
      } else {
        this.updatePosition(simTime, ownAirplane);
        this.updateVelocity(ownAirplane);
        this._groundSpeed.set(this.contact.groundSpeed);
        this._verticalSpeed.set(this.contact.verticalSpeed);
        this._isPredictionValid = true;
      }
    }
    updatePosition(simTime, ownAirplane) {
      this.contact.predict(simTime, this._position, this._altitude);
      this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
      const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
      const bearing = ownAirplane.position.bearingTo(this._position);
      Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
      const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
      this.positionVec[2] = verticalPosition;
      Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    updateVelocity(ownAirplane) {
      Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
      Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    invalidatePredictions() {
      this.tcaTA.invalidate();
      this.tcaRA.invalidate();
    }
    static displacementToHorizontalSeparation(displacement, out) {
      return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    static displacementToVerticalSeparation(displacement, out) {
      return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
  };
  AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
  AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  var TcasTcaPredictionClass = class {
    constructor(intruder) {
      this.intruder = intruder;
      this._isValid = false;
      this._time = NaN;
      this._tcpa = UnitType.SECOND.createNumber(NaN);
      this.tcpa = this._tcpa.readonly;
      this._tcoa = UnitType.SECOND.createNumber(NaN);
      this.tcoa = this._tcoa.readonly;
      this._isThreat = false;
      this.cpaDisplacement = new Float64Array(3);
      this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
      this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
      this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
      this.cpaVerticalSep = this._cpaVerticalSep.readonly;
      this._cpaNorm = NaN;
    }
    get isValid() {
      return this._isValid;
    }
    get time() {
      return this._time;
    }
    get isThreat() {
      return this._isThreat;
    }
    get cpaNorm() {
      return this._cpaNorm;
    }
    update(simTime, tau, dmod, zthr, hmd) {
      var _a;
      this._time = simTime;
      if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
        this.invalidate();
        return;
      }
      const tauSeconds = tau.asUnit(UnitType.SECOND);
      const s = this.intruder.relativePositionVec;
      const v = this.intruder.relativeVelocityVec;
      const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
      const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
      const h = zthr.asUnit(UnitType.METER);
      const r = dmod.asUnit(UnitType.METER);
      const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
      const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
      const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
      const rSquared = r * r;
      const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
      const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
      const tcoa = -s[2] / v[2];
      const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
      const isVerticalThreat = Math.abs(s[2]) <= h || tcoa >= 0 && tcoa <= tauSeconds;
      let passHmdFilter = true;
      if (hmd !== void 0 && isHorizontalThreat && isVerticalThreat) {
        const d = hmd.asUnit(UnitType.METER);
        const dSquared = d * d;
        if (vHorizSquared === 0) {
          passHmdFilter = sHorizSquared <= dSquared;
        } else {
          const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
          if (delta < 0) {
            passHmdFilter = false;
          } else {
            const a = vHorizSquared;
            const b = 2 * dotSHorizVHoriz;
            const c = sHorizSquared - dSquared;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) {
              passHmdFilter = false;
            } else {
              passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
            }
          }
        }
      }
      this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
      this._tcpa.set(tcpa);
      this._tcoa.set(tcoa);
      TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
      AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
      AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
      this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
      this._isValid = true;
    }
    invalidate() {
      this._isValid = false;
      this._isThreat = false;
      this._tcpa.set(NaN);
      this._tcoa.set(NaN);
      Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
      this._cpaHorizontalSep.set(NaN);
      this._cpaVerticalSep.set(NaN);
      this._cpaNorm = NaN;
    }
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
      return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    static calculateCylindricalNorm(vector, radius, halfHeight) {
      const horizLength = Math.hypot(vector[0], vector[1]);
      return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
  };
  TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var TcasResolutionAdvisoryHostClass = class {
    constructor(bus, options, ownAirplane) {
      this.options = options;
      this.ownAirplane = ownAirplane;
      this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
      this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
      this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.intruders = /* @__PURE__ */ new Set();
      this.intruderArray = [];
      this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
      this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.minVerticalSpeed = this._minVerticalSpeed.readonly;
      this._flags = 0;
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._secondaryType = null;
      this._primaryFlags = 0;
      this._secondaryFlags = 0;
      this.vsConstraints = [];
      this.lastStateChangeTime = 0;
      this.stateChangeDelay = 0;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher = bus.getPublisher();
    }
    get flags() {
      return this._flags;
    }
    get primaryType() {
      return this._primaryType;
    }
    get secondaryType() {
      return this._secondaryType;
    }
    get primaryFlags() {
      return this._primaryFlags;
    }
    get secondaryFlags() {
      return this._secondaryFlags;
    }
    canIssueResolutionAdvisory(simTime, intruder) {
      if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
        return false;
      }
      if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    canCancelResolutionAdvisory(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    update(simTime, alim, intruders) {
      if (this.intruderArray.length === 0 && intruders.size === 0) {
        return;
      }
      if (simTime < this.lastStateChangeTime) {
        this.lastStateChangeTime = simTime;
      }
      if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
        return;
      }
      if (intruders.size === 0) {
        this.cancel(simTime);
      } else {
        const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        const alimMeters = alim.asUnit(UnitType.METER);
        const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
        const responseTimeSecondsRemaining = isInitial ? responseTimeSeconds : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1e3, 0, responseTimeSeconds);
        const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
        this.updateIntruders(intruders);
        this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
        if (isInitial) {
          this.selectInitialState(simTime, ownAirplaneVsMps);
        } else {
          if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
            this.updatePositive(simTime);
          } else if (this._secondaryType === null) {
            this.updateNegative(simTime, ownAirplaneVsMps);
          } else {
            this.updateComposite(simTime, ownAirplaneVsMps);
          }
        }
      }
    }
    updateIntruders(intruders) {
      for (let i = 0; i < this.intruderArray.length; i++) {
        if (!intruders.has(this.intruderArray[i])) {
          this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
        }
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      for (const intruder of intruders) {
        this.intruders.add(intruder);
        this.intruderArray.push(intruder);
      }
      this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
      var _a;
      var _b;
      const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
      for (let i = 0; i < this.intruderArray.length; i++) {
        const intruder = this.intruderArray[i];
        let above = -Infinity;
        let below = Infinity;
        if (intruder.tcaRA.isValid) {
          const t0 = intruder.tcaRA.time;
          const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
          const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1e3;
          const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
          const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
          const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
          const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
          const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
          if (aboveAlimSense === 1) {
            above = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters) : NaN;
            if (isNaN(above)) {
              above = Infinity;
            }
          } else {
            above = tcpaSeconds > 0 ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : -Infinity;
          }
          if (belowAlimSense === -1) {
            below = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters) : NaN;
            if (isNaN(below)) {
              below = -Infinity;
            }
          } else {
            below = tcpaSeconds > 0 ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : Infinity;
          }
        }
        const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : _b[i] = { above: 0, below: 0 };
        constraint.above = above;
        constraint.below = below;
      }
      this.vsConstraints.length = this.intruderArray.length;
    }
    selectInitialState(simTime, ownAirplaneVsMps) {
      let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
      let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
      let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
      const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
      const canClimb = this.options.allowClimb(simTime);
      const canDescend = this.options.allowDescend(simTime);
      const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
      const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
      minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
      maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
      let sense;
      let senseIsCrossing = false;
      let doesSenseAchieveAlim = false;
      let senseRequiredVs = 0;
      if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
        sense = 1;
      } else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
        sense = -1;
      } else {
        const closestIntruder = this.intruderArray[0];
        const t0 = closestIntruder.tcaRA.time;
        const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
        const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
        const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
        const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
        if (crossingSense === -1 && !isUpSenseInhibited) {
          sense = 1;
        } else if (crossingSense === 1 && !isDownSenseInhibited) {
          sense = -1;
        } else {
          if (!isUpSenseInhibited && isDownSenseInhibited) {
            sense = 1;
          } else if (isUpSenseInhibited && !isDownSenseInhibited) {
            sense = -1;
          } else {
            if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
              sense = 1;
            } else {
              sense = -1;
            }
          }
          senseIsCrossing = sense === crossingSense;
        }
      }
      doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
      doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
      doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
      senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
      if (this.intruderArray.length > 1) {
        const doesCompositeAchieveAlim = this.vsConstraints.every((constraint) => constraint.above <= 0 || constraint.below >= 0);
        if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
          sense = 0;
          doesSenseAchieveAlim = doesCompositeAchieveAlim;
        } else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
          if (senseIsCrossing) {
            sense = 0;
            doesSenseAchieveAlim = doesCompositeAchieveAlim;
          } else {
            if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
              sense = 0;
              doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
          }
        }
      }
      let primaryType;
      let secondaryType = null;
      switch (sense) {
        case 0:
          if (doesSenseAchieveAlim) {
            const maxVsMps = this.getCompositeRequiredMaxVs();
            const minVsMps = this.getCompositeRequiredMinVs();
            if (ownAirplaneVsMps > maxVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
            } else if (ownAirplaneVsMps < minVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            }
          } else {
            primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
          }
          break;
        case 1:
          if (ownAirplaneVsMps < minUpSenseVsMps) {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            }
          } else {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
            }
          }
          break;
        case -1:
          if (ownAirplaneVsMps > maxDownSenseVsMps) {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
            }
          } else {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
            }
          }
          break;
      }
      this.setState(simTime, primaryType, secondaryType, true);
    }
    updatePositive(simTime) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
      const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
      if (isInhibited) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
        return;
      }
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        if (requiredVsMps * sense <= 0) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
      } else {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
        let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
        }
      }
    }
    updateNegative(simTime, ownAirplaneVsMps) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        return;
      }
      const requirePositive = requiredVsMps * sense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
      } else {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
      }
    }
    updateComposite(simTime, ownAirplaneVsMps) {
      if (this._secondaryType === null) {
        throw new Error("TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active");
      }
      const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
      const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredMinVsMps = this.getCompositeRequiredMinVs();
      const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
      const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
      if (primarySense === 1) {
        primaryCurrentVsMps = currentMinVsMps;
        primaryRequiredVsMps = requiredMinVsMps;
        secondaryCurrentVsMps = currentMaxVsMps;
        secondaryRequiredVsMps = requiredMaxVsMps;
      } else {
        primaryCurrentVsMps = currentMaxVsMps;
        primaryRequiredVsMps = requiredMaxVsMps;
        secondaryCurrentVsMps = currentMinVsMps;
        secondaryRequiredVsMps = requiredMinVsMps;
      }
      const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
      const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
      const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0 || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      let primaryType;
      if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
      } else {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
      }
      const secondaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
      this.setState(simTime, primaryType, secondaryType);
    }
    setState(simTime, primaryType, secondaryType, isInitial = false) {
      if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
        return;
      }
      let minSpeed, maxSpeed;
      const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
      this._primaryType = primaryType;
      this._primaryFlags = primaryTypeDef.flags;
      this._secondaryType = secondaryType;
      if (secondaryType !== null) {
        const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
        this._secondaryFlags = secondaryTypeDef.flags;
        minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
        maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
      } else {
        this._secondaryFlags = 0;
        minSpeed = primaryTypeDef.minVerticalSpeed;
        maxSpeed = primaryTypeDef.maxVerticalSpeed;
      }
      this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
      this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
      this.isInitial = isInitial;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1e3;
      if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
        this.senseReversalCount++;
      }
      if (isInitial) {
        this.publisher.pub("tcas_ra_issued", this, false, false);
      } else {
        this.publisher.pub("tcas_ra_updated", this, false, false);
      }
    }
    cancel(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
        return;
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      this._maxVerticalSpeed.set(NaN);
      this._minVerticalSpeed.set(NaN);
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._primaryFlags = 0;
      this._secondaryType = null;
      this._secondaryFlags = 0;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher.pub("tcas_ra_canceled", void 0, false, false);
    }
    getUpSenseRequiredMinVs() {
      return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    getDownSenseRequiredMaxVs() {
      return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    getCompositeRequiredMinVs() {
      return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    getCompositeRequiredMaxVs() {
      return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
      const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
      if (signedAccel === 0) {
        return vs;
      }
      const y0 = currentAlt + vs * responseTime;
      const tc = tcpa - responseTime;
      const a = signedAccel / 2;
      const b = -signedAccel * tc;
      const c = targetAlt - y0 - vs * tc;
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) {
        return NaN;
      }
      const sqrtDiscr = Math.sqrt(discriminant);
      const t1 = (-b + sqrtDiscr) / (2 * a);
      const t2 = (-b - sqrtDiscr) / (2 * a);
      if (t1 <= tc && t1 >= 0) {
        return vs + signedAccel * t1;
      }
      if (t2 <= tc && t2 >= 0) {
        return vs + signedAccel * t2;
      }
      return NaN;
    }
    static getDoNotDescendType(minVsMps) {
      if (minVsMps > -500) {
        return TcasResolutionAdvisoryType.DoNotDescend0;
      } else if (minVsMps > -1e3) {
        return TcasResolutionAdvisoryType.DoNotDescend500;
      } else if (minVsMps > -1500) {
        return TcasResolutionAdvisoryType.DoNotDescend1000;
      } else if (minVsMps > -2e3) {
        return TcasResolutionAdvisoryType.DoNotDescend1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotDescend2000;
      }
    }
    static getDoNotClimbType(maxVsMps) {
      if (maxVsMps < 500) {
        return TcasResolutionAdvisoryType.DoNotClimb0;
      } else if (maxVsMps < 1e3) {
        return TcasResolutionAdvisoryType.DoNotClimb500;
      } else if (maxVsMps < 1500) {
        return TcasResolutionAdvisoryType.DoNotClimb1000;
      } else if (maxVsMps < 2e3) {
        return TcasResolutionAdvisoryType.DoNotClimb1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotClimb2000;
      }
    }
  };
  TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5e3;
  TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
      return -1;
    } else if (tcpaComparison > 0) {
      return 1;
    } else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
      return -1;
    } else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
      return 1;
    } else {
      return 0;
    }
  };
  TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
      flags: 0,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 2500,
      maxVerticalSpeed: 3e3
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -3e3,
      maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1e3
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 2e3
    }
  };
  TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];
  var TcasIISensitivityParameters = class {
    selectLevel(altitude, radarAltitude) {
      const altFeet = altitude.asUnit(UnitType.FOOT);
      const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
      let level;
      if (radarAltFeet > 2350) {
        if (altFeet > 42e3) {
          level = 6;
        } else if (altFeet > 2e4) {
          level = 5;
        } else if (altFeet > 1e4) {
          level = 4;
        } else if (altFeet > 5e3) {
          level = 3;
        } else {
          level = 2;
        }
      } else if (radarAltFeet > 1e3) {
        level = 1;
      } else {
        level = 0;
      }
      return level;
    }
    selectPA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.PA;
    }
    selectTA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    selectRA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    selectRAAlim(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    getPA(level) {
      return TcasIISensitivityParameters.PA;
    }
    getTA(level) {
      return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    getRA(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    getRAAlim(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
  };
  TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
  };
  TcasIISensitivityParameters.TA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.33),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.48),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(40),
      protectedRadius: UnitType.NMILE.createNumber(0.75),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(45),
      protectedRadius: UnitType.NMILE.createNumber(1),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(1200)
    }
  ];
  TcasIISensitivityParameters.RA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.35),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.55),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(350),
      hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.8),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(400),
      hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(700),
      alim: UnitType.FOOT.createNumber(600),
      hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(800),
      alim: UnitType.FOOT.createNumber(700),
      hmd: UnitType.NMILE.createNumber(0.98)
    }
  ];
  var MapTrafficAlertLevelVisibility;
  (function(MapTrafficAlertLevelVisibility2) {
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["All"] = 15] = "All";
  })(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
  var MapTrafficModule = class {
    constructor(tcas) {
      this.tcas = tcas;
      this.show = Subject.create(true);
      this.operatingMode = Subject.create(TcasOperatingMode.Standby);
      this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
      this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
      this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.isAltitudeRelative = Subject.create(true);
      this.tcas.getEventSubscriber().on("tcas_operating_mode").whenChanged().handle((mode) => {
        this.operatingMode.set(mode);
      });
    }
  };
  var MapSystemTrafficLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.iconLayerRef = FSComponent.createRef();
      this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
      this.intruderIcons = {
        [TcasAlertLevel.None]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ProximityAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.TrafficAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ResolutionAdvisory]: /* @__PURE__ */ new Map()
      };
      this.needHandleOffscaleOob = this.props.offScaleIntruders !== void 0 || this.props.oobIntruders !== void 0;
      this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
      this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
      this.isInit = false;
    }
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (!isVisible) {
        if (this.isInit) {
          this.iconLayerRef.instance.display.clear();
        }
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    onAttached() {
      this.iconLayerRef.instance.onAttached();
      this.oobOffset.sub(this.updateOobBounds.bind(this), true);
      this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
      this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
      this.initCanvasStyles();
      this.initIntruders();
      this.initTCASHandlers();
      this.isInit = true;
    }
    initCanvasStyles() {
      this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    initIntruders() {
      const intruders = this.trafficModule.tcas.getIntruders();
      const len = intruders.length;
      for (let i = 0; i < len; i++) {
        this.onIntruderAdded(intruders[i]);
      }
    }
    initTCASHandlers() {
      const tcasSub = this.props.context.bus.getSubscriber();
      tcasSub.on("tcas_intruder_added").handle(this.onIntruderAdded.bind(this));
      tcasSub.on("tcas_intruder_removed").handle(this.onIntruderRemoved.bind(this));
      tcasSub.on("tcas_intruder_alert_changed").handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.initCanvasStyles();
        this.updateOobBounds();
      }
    }
    updateOobBounds() {
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const oobOffset = this.oobOffset.get();
      this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    onUpdated(time, elapsed) {
      if (!this.isVisible()) {
        return;
      }
      this.redrawIntruders();
    }
    redrawIntruders() {
      const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
      const offScaleRange = this.trafficModule.offScaleRange.get();
      const oobBounds = this.oobBounds.get();
      const iconDisplay = this.iconLayerRef.instance.display;
      iconDisplay.clear();
      for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
        const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
        if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b, _c, _d, _e, _f;
            icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
            if (this.needHandleOffscaleOob) {
              if (icon.isOffScale) {
                (_a = this.props.oobIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                (_b = this.props.offScaleIntruders) === null || _b === void 0 ? void 0 : _b.add(icon.intruder);
              } else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
              } else {
                (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
              }
            }
          });
        } else if (this.needHandleOffscaleOob) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b;
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
          });
        }
      }
    }
    updateVisibility() {
      const operatingMode = this.trafficModule.tcas.getOperatingMode();
      this.setVisible(this.trafficModule.show.get() && (operatingMode === TcasOperatingMode.TAOnly || operatingMode === TcasOperatingMode.TA_RA || operatingMode === TcasOperatingMode.Test));
    }
    onIntruderAdded(intruder) {
      const icon = this.props.iconFactory(intruder, this.props.context);
      this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    onIntruderRemoved(intruder) {
      var _a, _b;
      (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
      (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
      this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    onIntruderAlertLevelChanged(intruder) {
      let oldAlertLevel;
      let view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.None].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ProximityAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.TrafficAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ResolutionAdvisory].get(intruder);
      if (view) {
        this.intruderIcons[oldAlertLevel].delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
      }
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
  };
  MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TcasAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TcasAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TcasAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TcasAlertLevel.ResolutionAdvisory }
  ];
  var AbstractMapTrafficIntruderIcon = class {
    constructor(intruder, trafficModule, ownshipModule) {
      this.intruder = intruder;
      this.trafficModule = trafficModule;
      this.ownshipModule = ownshipModule;
      this.projectedPos = new Float64Array(2);
      this.isOffScale = false;
    }
    draw(projection, context, offScaleRange) {
      this.updatePosition(projection, offScaleRange);
      this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    updatePosition(projection, offScaleRange) {
      const ownAirplanePos = this.ownshipModule.position.get();
      if (offScaleRange.isNaN()) {
        projection.project(this.intruder.position, this.projectedPos);
        this.isOffScale = false;
      } else {
        this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
      }
    }
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
      const intruderPos = this.intruder.position;
      const horizontalSeparation = intruderPos.distance(ownAirplanePos);
      const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
      if (horizontalSeparation > offscaleRangeRad) {
        this.isOffScale = true;
        projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
      } else {
        this.isOffScale = false;
        projection.project(intruderPos, this.projectedPos);
      }
    }
  };
  AbstractMapTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];
  var MapSystemWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.waypointsLayer = FSComponent.createRef();
      this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
      this.waypointCache = (_a = this.props.waypointCache) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.searchItemLimits = {
        [FacilitySearchType.Airport]: 500,
        [FacilitySearchType.Vor]: 250,
        [FacilitySearchType.Ndb]: 250,
        [FacilitySearchType.Intersection]: 500,
        [FacilitySearchType.User]: 100
      };
      this.searchRadiusLimits = {
        [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.User]: Number.POSITIVE_INFINITY
      };
    }
    onAttached() {
      super.onAttached();
      this.waypointsLayer.instance.onAttached();
      this.initEventHandlers();
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    onUpdated(time, elapsed) {
      if (this.isVisible()) {
        this.waypointsLayer.instance.onUpdated(time, elapsed);
      }
    }
    initEventHandlers() {
      this.displayModule.numAirports.sub((num) => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
      this.displayModule.numIntersections.sub((num) => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
      this.displayModule.numVors.sub((num) => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
      this.displayModule.numNdbs.sub((num) => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
      this.displayModule.airportsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.intersectionsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.vorsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.ndbsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.refreshWaypoints.on(() => this.waypointsLayer.instance.refreshWaypoints());
    }
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession) {
      this.displayModule.intersectionsFilter.sub((filters) => intSession.setIntersectionFilter(filters.typeMask));
      this.displayModule.vorsFilter.sub((filters) => vorSession.setVorFilter(filters.classMask, filters.typeMask));
      this.displayModule.airportsFilter.sub((filters) => {
        airportSession.setAirportFilter(filters.showClosed, filters.classMask);
      });
      this.displayModule.extendedAirportsFilter.sub((filters) => {
        airportSession.setExtendedAirportFilters(filters.runwaySurfaceTypeMask, filters.approachTypeMask, filters.toweredMask, filters.minimumRunwayLength);
      });
    }
    initWaypointRenderer(renderer, canvasLayer) {
      this.defineRenderRole(renderer, canvasLayer);
      renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    defineRenderRole(renderer, canvasLayer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.setCanvasContext(roleId, canvasLayer.display.context);
          renderer.setIconFactory(roleId, this.props.iconFactory);
          renderer.setLabelFactory(roleId, this.props.labelFactory);
          renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
        }
      });
    }
    setVisible(val) {
      super.setVisible(val);
      this.waypointsLayer.instance.setVisible(val);
    }
    isWaypointVisible(waypoint) {
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        switch (waypoint.type) {
          case WaypointTypes.Airport:
            return this.displayModule.showAirports.get()(waypoint);
          case WaypointTypes.Intersection:
            return this.displayModule.showIntersections.get()(waypoint);
          case WaypointTypes.VOR:
            return this.displayModule.showVors.get()(waypoint);
          case WaypointTypes.NDB:
            return this.displayModule.showNdbs.get()(waypoint);
        }
      }
      return false;
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: this.registerWaypoint.bind(this), deregisterWaypoint: this.deregisterWaypoint.bind(this), searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : void 0, onSessionsStarted: this.onSessionsStarted.bind(this), class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    registerWaypoint(waypoint, renderer) {
      const selector = this.displayModule.waypointRoleSelector.get();
      if (selector) {
        const id = selector(waypoint);
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.register(waypoint, roleId, "waypoints-layer");
        }
      } else {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach((id) => {
          const roleId = renderer.getRoleFromName(id);
          if (roleId !== void 0) {
            renderer.register(waypoint, roleId, "waypoints-layer");
          }
        });
      }
    }
    deregisterWaypoint(waypoint, renderer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.deregister(waypoint, roleId, "waypoints-layer");
        }
      });
    }
  };
  var MapTerrainColorsModule = class {
    constructor() {
      this.reference = Subject.create(EBingReference.SEA);
      this.showIsoLines = Subject.create(false);
      this.colors = ArraySubject.create(BingComponent.createEarthColorsArray("#0000FF", [
        {
          elev: 0,
          color: "#000000"
        }
      ], 0, 3e4, 1));
      this.colorsElevationRange = Vec2Subject.create(Vec2Math.create(0, 3e4));
    }
  };
  var MapFlightPlanModule = class {
    constructor() {
      this.plans = [];
    }
    getPlanSubjects(index) {
      let planSubject = this.plans[index];
      if (planSubject === void 0) {
        planSubject = new PlanSubjects();
        this.plans[index] = planSubject;
      }
      return planSubject;
    }
  };
  var PlanSubjects = class {
    constructor() {
      this.flightPlan = Subject.create(void 0);
      this.planChanged = new SubEvent();
      this.planCalculated = new SubEvent();
      this.activeLeg = Subject.create(0);
    }
  };
  var MapFollowAirplaneModule = class {
    constructor() {
      this.isFollowing = Subject.create(false);
    }
  };
  var MapWaypointDisplayModule = class {
    constructor() {
      this.showAirports = Subject.create(() => true);
      this.showIntersections = Subject.create(() => false);
      this.showNdbs = Subject.create(() => true);
      this.showVors = Subject.create(() => true);
      this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.numAirports = Subject.create(40);
      this.numIntersections = Subject.create(40);
      this.numNdbs = Subject.create(40);
      this.numVors = Subject.create(40);
      this.intersectionsFilter = Subject.create({
        typeMask: NearestIntersectionSearchSession.Defaults.TypeMask,
        showTerminalWaypoints: true
      });
      this.vorsFilter = Subject.create({
        typeMask: NearestVorSearchSession.Defaults.TypeMask,
        classMask: NearestVorSearchSession.Defaults.ClassMask
      });
      this.airportsFilter = Subject.create({
        classMask: NearestAirportSearchSession.Defaults.ClassMask,
        showClosed: NearestAirportSearchSession.Defaults.ShowClosed
      });
      this.extendedAirportsFilter = Subject.create({
        runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
        approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
        minimumRunwayLength: NearestAirportSearchSession.Defaults.MinimumRunwayLength,
        toweredMask: NearestAirportSearchSession.Defaults.ToweredMask
      });
      this.waypointRoleSelector = Subject.create(void 0);
      this.refreshWaypoints = new SubEvent();
    }
  };
  var MapWxrModule = class {
    constructor() {
      this.isEnabled = Subject.create(false);
      this.weatherRadarArc = NumberUnitSubject.create(UnitType.DEGREE.createNumber(90));
      this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
      this.weatherRadarColors = ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this._wxrMode = MappedSubject.create(([isEnabled, arc, mode]) => {
        return {
          mode: isEnabled ? mode : EWeatherRadar.OFF,
          arcRadians: arc.asUnit(UnitType.RADIAN)
        };
      }, this.isEnabled, this.weatherRadarArc, this.weatherRadarMode);
    }
    get wxrMode() {
      return this._wxrMode;
    }
  };
  var WaypointDisplayBuilder = class {
    constructor(iconFactory, labelFactory, waypointRenderer) {
      this.iconFactory = iconFactory;
      this.labelFactory = labelFactory;
      this.waypointRenderer = waypointRenderer;
      this.roleGroup = MapSystemWaypointRoles.Normal;
      this.isCenterTarget = false;
    }
    addIcon(role, type, config) {
      this.iconFactory.addIconFactory(this.determineRoleId(role), type, config);
      return this;
    }
    addDefaultIcon(role, config) {
      this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config);
      return this;
    }
    addLabel(role, type, config) {
      this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config);
      return this;
    }
    addDefaultLabel(role, config) {
      this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config);
      return this;
    }
    determineRoleId(role) {
      let roleId = 0;
      if (typeof role === "string") {
        const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
        if (roleIdFromName !== void 0) {
          roleId = roleIdFromName;
        }
      } else {
        roleId = role;
      }
      return roleId;
    }
    registerRole(name) {
      this.waypointRenderer.addRenderRole(name, void 0, this.roleGroup);
      return this;
    }
    getRoleId(role) {
      const roleId = this.waypointRenderer.getRoleFromName(role);
      if (roleId === void 0) {
        throw new Error(`The role with name ${role} was not defined and could not be found.`);
      }
      return roleId;
    }
    withSearchCenter(center) {
      if (center === "center") {
        this.isCenterTarget = false;
      } else {
        this.isCenterTarget = true;
      }
      return this;
    }
    getIsCenterTarget() {
      return this.isCenterTarget;
    }
    withWaypointCache(cache) {
      this.facilityWaypointCache = cache;
      return this;
    }
    getWaypointCache() {
      return this.facilityWaypointCache;
    }
  };
  var FlightPlanDisplayBuilder = class extends WaypointDisplayBuilder {
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
      super(iconFactory, labelFactory, waypointRenderer);
      this.flightPlanRenderer = flightPlanRenderer;
      this.planIndex = planIndex;
      this.roleGroup = MapSystemWaypointRoles.FlightPlan;
      this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
      flightPlanRenderer.legStyleHandlers;
    }
    registerRole(name) {
      this.waypointRenderer.insertRenderRole(name, MapSystemWaypointRoles.Normal, void 0, this.roleGroup);
      return this;
    }
    withLegPathStyles(handler) {
      this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
      return this;
    }
    withLegWaypointRoles(handler) {
      this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
      return this;
    }
    withAnticipationTurns(visible) {
      const visibleSub = SubscribableUtils.toSubscribable(visible, true);
      this.flightPlanRenderer.renderEgress = visibleSub;
      this.flightPlanRenderer.renderIngress = visibleSub;
      return this;
    }
  };
  var GenericAirspaceRenderManager = class {
    constructor(renderOrder, selectRenderer) {
      this.renderOrder = renderOrder;
      this.selectRenderer = selectRenderer;
      this.airspaces = /* @__PURE__ */ new Map();
    }
    getRegisteredAirspaces() {
      return Array.from(this.airspaces.values());
    }
    registerAirspace(airspace) {
      if (this.airspaces.has(airspace.facility.id)) {
        return false;
      }
      this.airspaces.set(airspace.facility.id, airspace);
      return true;
    }
    deregisterAirspace(airspace) {
      return this.airspaces.delete(airspace.facility.id);
    }
    replaceRegisteredAirspaces(airspaces) {
      let changed = false;
      let numMatched = 0;
      for (const airspace of airspaces) {
        changed || (changed = !this.airspaces.has(airspace.facility.id));
        if (changed) {
          break;
        } else {
          numMatched++;
        }
      }
      changed || (changed = numMatched !== this.airspaces.size);
      if (!changed) {
        return false;
      }
      this.airspaces.clear();
      for (const airspace of airspaces) {
        this.registerAirspace(airspace);
      }
      return true;
    }
    clearRegisteredAirspaces() {
      if (this.airspaces.size === 0) {
        return false;
      }
      this.airspaces.clear();
      return true;
    }
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
      const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
      const tasks = sorted.map((airspace) => {
        const renderer = this.selectRenderer(airspace);
        return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
      });
      return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
  };
  var MapAutopilotPropsController = class extends MapSystemController {
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
      this.subs = {};
    }
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      if (this.updateFreq) {
        this.updateFreqSub = this.updateFreq.sub((freq) => {
          var _a;
          for (const property of this.properties) {
            (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
            this.subs[property] = this.bindProperty(sub, property, freq);
          }
        }, true);
      } else {
        for (const property of this.properties) {
          this.subs[property] = this.bindProperty(sub, property);
        }
      }
    }
    bindProperty(sub, property, updateFreq) {
      switch (property) {
        case "selectedAltitude":
          return (updateFreq === void 0 ? sub.on("ap_altitude_selected") : sub.on("ap_altitude_selected").atFrequency(updateFreq)).handle((alt) => {
            this.module.selectedAltitude.set(alt, UnitType.FOOT);
          });
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapSystemComponent = class extends MapComponent {
    constructor(props) {
      var _a;
      super(props);
      this.rootStyles = ObjectSubject.create({
        width: "0px",
        height: "0px"
      });
      this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
      this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    onAfterRender(thisNode) {
      super.onAfterRender(thisNode);
      this.onProjectedSizeChanged();
      this.props.onAfterRender();
    }
    onDeadZoneChanged(deadZone) {
      this.props.onDeadZoneChanged(deadZone);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    setRootSize(size) {
      this.rootStyles.set("width", `${size[0]}px`);
      this.rootStyles.set("height", `${size[1]}px`);
    }
    onProjectedSizeChanged() {
      this.setRootSize(this.mapProjection.getProjectedSize());
    }
    onUpdated(time, elapsed) {
      this.props.onBeforeUpdated(time, elapsed);
      super.onUpdated(time, elapsed);
      this.props.onAfterUpdated(time, elapsed);
    }
    onWake() {
      super.onWake();
      this.props.onWake();
    }
    onSleep() {
      super.onSleep();
      this.props.onSleep();
    }
    render() {
      var _a;
      return FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }, this.props.children);
    }
    destroy() {
      super.destroy();
      this.props.onDestroy();
    }
  };
  var DefaultMapSystemContext = class {
    constructor(bus, projection, projectedSize, deadZone) {
      this.bus = bus;
      this.projection = projection;
      this.projectedSize = projectedSize;
      this.deadZone = deadZone;
      this.model = new MapModel();
      this.layers = /* @__PURE__ */ new Map();
      this.controllers = /* @__PURE__ */ new Map();
    }
    getLayer(key) {
      return this.layers.get(key);
    }
    getController(key) {
      return this.controllers.get(key);
    }
    setLayer(key, layer) {
      this.layers.set(key, layer);
    }
    setController(key, controller) {
      this.controllers.set(key, controller);
    }
  };
  var MapSystemGenericController = class extends MapSystemController {
    constructor(context, callbacks) {
      super(context);
      this.callbacks = callbacks;
    }
    onAfterMapRender() {
      this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    onDeadZoneChanged(deadZone) {
      this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    onBeforeUpdated(time, elapsed) {
      this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    onAfterUpdated(time, elapsed) {
      this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    onWake() {
      this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    onSleep() {
      this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    onMapDestroyed() {
      this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    destroy() {
      super.destroy();
      this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
  };
  var MapSystemPlanRenderer = class extends AbstractFlightPathPlanRenderer {
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
      super(renderOrder, renderActiveLegLast);
      this.defaultRoleId = defaultRoleId;
      this.legRenderer = new MapSystemLegRenderer();
      this.legStyleHandlers = /* @__PURE__ */ new Map();
      this.legWaypointHandlers = /* @__PURE__ */ new Map();
      this.renderIngress = Subject.create(false);
      this.renderEgress = Subject.create(false);
    }
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
      this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
      const handler = this.legStyleHandlers.get(plan.planIndex);
      if (handler !== void 0) {
        this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
      }
      let partsToRender = FlightPathLegRenderPart.Base | (this.renderIngress.get() ? FlightPathLegRenderPart.Ingress : 0) | (this.renderEgress.get() ? FlightPathLegRenderPart.Egress : 0);
      if (this.legRenderer.currentRenderStyle.partsToRender !== void 0) {
        partsToRender = this.legRenderer.currentRenderStyle.partsToRender;
      }
      this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
  };
  var MapSystemLegRenderer = class extends AbstractFlightPathLegRenderer {
    constructor() {
      super(...arguments);
      this.vectorRenderer = new FlightPathVectorLineRenderer();
      this.currentRenderStyle = new FlightPathRenderStyle();
    }
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
      if ("styleBuilder" in this.currentRenderStyle) {
        const currentRenderStyle = this.currentRenderStyle.styleBuilder(vector, isIngress, isEgress);
        this.vectorRenderer.render(vector, context, streamStack, currentRenderStyle.width, currentRenderStyle.style, currentRenderStyle.dash, currentRenderStyle.outlineWidth, currentRenderStyle.outlineStyle);
      } else {
        if (this.currentRenderStyle.isDisplayed) {
          this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash, this.currentRenderStyle.outlineWidth, this.currentRenderStyle.outlineStyle);
        }
      }
    }
  };
  var FlightPathRenderStyle = class {
    constructor(isDisplayed = true) {
      this.isDisplayed = isDisplayed;
      this.width = 2;
      this.style = "";
    }
  };
  FlightPathRenderStyle.Default = new FlightPathRenderStyle();
  FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);
  var MapSystemUtils = class {
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
      return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
      return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    static nominalToTrueRelativeXY(nominal, size, deadZone, out) {
      return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size[1], deadZone), out);
    }
  };
  var MapSystemWaypointsRenderer = class extends MapWaypointRenderer {
    constructor(textManager) {
      super(textManager, (entry, roleDefinitions) => {
        var _a;
        for (let i = 0; i < this.rolePriorityOrder.length; i++) {
          const role = this.rolePriorityOrder[i];
          if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
            return role;
          }
        }
        return 0;
      });
      this.rolePriorityOrder = [];
      this.rolesByGroup = /* @__PURE__ */ new Map();
      this.roleIdMap = /* @__PURE__ */ new Map();
      this.currentBit = 1;
      this.onRolesAdded = new SubEvent();
    }
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      if (typeof arg1 === "number") {
        return false;
      }
      this.roleIdMap.set(arg1, this.currentBit);
      super.addRenderRole(this.currentBit, def);
      this.rolePriorityOrder.push(this.currentBit);
      let roleGroup = this.rolesByGroup.get(group);
      if (roleGroup === void 0) {
        roleGroup = [];
        this.rolesByGroup.set(group, roleGroup);
      }
      roleGroup.push(arg1);
      this.currentBit *= 2;
      this.onRolesAdded.notify(this);
      return true;
    }
    insertRenderRole(name, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      const role = this.currentBit;
      this.addRenderRole(name, def, group);
      const roleToInsertBefore = this.roleIdMap.get(insertBefore);
      if (roleToInsertBefore !== void 0) {
        const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
        if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
          this.rolePriorityOrder.pop();
          this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
        }
      }
      return true;
    }
    getRoleFromName(name) {
      return this.roleIdMap.get(name);
    }
    getRoleNamesByGroup(group) {
      const roleNames = this.rolesByGroup.get(group);
      if (roleNames !== void 0) {
        return roleNames;
      }
      return [];
    }
  };
  MapSystemWaypointsRenderer.DefaultGroup = "DEFAULT_GROUP";
  var MapSystemIconFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.iconFactories = /* @__PURE__ */ new Map();
      this.defaultIconFactories = /* @__PURE__ */ new Map();
    }
    addIconFactory(role, iconType, factory) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      roleFactories.set(iconType, factory);
    }
    addDefaultIconFactory(role, factory) {
      this.defaultIconFactories.set(role, factory);
    }
    getIcon(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let icon = roleCache.get(waypoint.uid);
      if (icon === void 0) {
        icon = this.createIcon(role, waypoint);
        roleCache.set(waypoint.uid, icon);
      }
      return icon;
    }
    createIcon(role, waypoint) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      const factory = roleFactories.get(waypoint.type);
      if (factory !== void 0) {
        return factory(waypoint);
      } else {
        const defaultFactory = this.defaultIconFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      const imageEl = document.createElement("img");
      imageEl.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC";
      return new MapWaypointImageIcon(waypoint, 0, imageEl, Vec2Math.create(24, 24));
    }
  };
  var MapSystemLabelFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.labelFactories = /* @__PURE__ */ new Map();
      this.defaultLabelFactories = /* @__PURE__ */ new Map();
    }
    addLabelFactory(role, iconType, factory) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      roleFactories.set(iconType, factory);
    }
    addDefaultLabelFactory(role, factory) {
      this.defaultLabelFactories.set(role, factory);
    }
    getLabel(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let label = roleCache.get(waypoint.uid);
      if (label === void 0) {
        label = this.createLabel(role, waypoint);
        roleCache.set(waypoint.uid, label);
      }
      return label;
    }
    createLabel(role, waypoint) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      const factory = roleFactories.get(waypoint.type);
      if (factory !== void 0) {
        return factory(waypoint);
      } else {
        const defaultFactory = this.defaultLabelFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      let text = "";
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        text = ICAO.getIdent(waypoint.facility.get().icao);
      }
      return new MapCullableLocationTextLabel(text, 0, waypoint.location, false, { fontSize: 22, font: "monospace", anchor: new Float64Array([-0.25, 0.4]) });
    }
  };
  var MapSystemBuilder = class {
    constructor(bus) {
      this.bus = bus;
      this.moduleFactories = /* @__PURE__ */ new Map();
      this.layerFactories = /* @__PURE__ */ new Map();
      this.controllerFactories = /* @__PURE__ */ new Map();
      this.contextFactories = /* @__PURE__ */ new Map();
      this.initCallbacks = /* @__PURE__ */ new Map();
      this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    get moduleCount() {
      return this.moduleFactories.size;
    }
    get layerCount() {
      return this.layerFactories.size;
    }
    get controllerCount() {
      return this.controllerFactories.size;
    }
    static create(bus) {
      return new MapSystemBuilder(bus);
    }
    withProjectedSize(size) {
      this.projectedSize = "isSubscribable" in size ? size : Subject.create(size);
      return this;
    }
    withDeadZone(deadZone) {
      this.deadZone = "isSubscribable" in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
      return this;
    }
    withTargetOffset(offset) {
      this.targetOffset = offset;
      return this;
    }
    withRangeEndpoints(endpoints) {
      this.nominalRangeEndpoints = endpoints;
      return this;
    }
    withRange(range) {
      this.range = range.asUnit(UnitType.GA_RADIAN);
      return this;
    }
    withModule(key, factory) {
      this.moduleFactories.set(key, { key, factory });
      return this;
    }
    withLayer(key, factory, order) {
      const wasDeleted = this.layerFactories.delete(key);
      this.layerFactories.set(key, { key, factory, order: order !== null && order !== void 0 ? order : this.layerFactories.size + (wasDeleted ? 1 : 0) });
      return this;
    }
    withController(key, factory) {
      this.controllerFactories.set(key, { factory });
      return this;
    }
    withContext(key, factory) {
      var _a;
      if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
        const existing = this.contextFactories.get(key);
        const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
        this.contextFactories.set(key, { key, factory, order });
      }
      return this;
    }
    withInit(key, callback) {
      this.initCallbacks.set(key, callback);
      return this;
    }
    withLayerOrder(key, order) {
      const factory = this.layerFactories.get(key);
      if (factory) {
        this.layerFactories.delete(key);
        factory.order = order;
        this.layerFactories.set(key, factory);
      }
      return this;
    }
    withBindings(key, bindings, onDestroy) {
      return this.withController(key, (context) => new MapBindingsController(context, bindings(context), onDestroy));
    }
    withClockUpdate(updateFreq) {
      return this.withContext("updateFreq", () => typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq).withController(MapSystemKeys.ClockUpdate, (context) => new MapClockUpdateController(context));
    }
    withTargetControlModerator() {
      return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(void 0));
    }
    withRotationControlModerator() {
      return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(void 0));
    }
    withRangeControlModerator() {
      return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(void 0));
    }
    withFollowAirplane() {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule()).withTargetControlModerator().withController(MapSystemKeys.FollowAirplane, (context) => new MapFollowAirplaneController(context));
    }
    withRotation() {
      return this.withModule(MapSystemKeys.Rotation, () => new MapRotationModule()).withRotationControlModerator().withController(MapSystemKeys.Rotation, (context) => new MapRotationController(context));
    }
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule()).withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
        return FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: iconFilePath, iconSize, iconAnchor, class: cssClass });
      }, order);
    }
    withOwnAirplaneIconOrientation(desiredOrientation) {
      return this.withController(MapSystemKeys.OwnAirplaneIconOrientation, (context) => new MapOwnAirplaneIconOrientationController(context, desiredOrientation));
    }
    withOwnAirplanePropBindings(properties, updateFreq) {
      return this.withController(MapSystemKeys.OwnAirplaneProps, (context) => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
    }
    withAutopilotProps(propertiesToBind, updateFreq) {
      this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
      if (propertiesToBind !== void 0) {
        this.withController(MapSystemKeys.AutopilotProps, (context) => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
      }
      return this;
    }
    withTextLayer(enableCulling, order, cssClass) {
      return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling)).withLayer(MapSystemKeys.TextLayer, (context) => {
        return FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager, class: cssClass });
      }, order);
    }
    withBing(bingId, delay = 0, mode, order, cssClass) {
      return this.withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule()).withModule(MapSystemKeys.Weather, () => new MapWxrModule()).withLayer(MapSystemKeys.Bing, (context) => {
        const terrainColors = context.model.getModule("terrainColors");
        const weather = context.model.getModule("weather");
        return FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, earthColorsElevationRange: terrainColors.colorsElevationRange, isoLines: terrainColors.showIsoLines, wxrMode: weather.wxrMode, wxrColors: weather.weatherRadarColors, mode, delay, class: cssClass });
      }, order);
    }
    withWaypoints() {
      return this.withContext(MapSystemKeys.WaypointRenderer, (context) => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager])).withController("waypointRendererUpdate", (context) => new MapSystemGenericController(context, {
        onAfterUpdated: (contextArg) => {
          contextArg[MapSystemKeys.WaypointRenderer].update(context.projection);
        }
      }));
    }
    withNearestWaypoints(configure, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling).withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule()).withWaypoints().withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory());
      let facilityWaypointCache = void 0;
      this.withContext("useTargetAsWaypointSearchCenter", (context) => {
        context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, void 0, MapSystemWaypointRoles.Normal);
        const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
        configure(builder);
        facilityWaypointCache = builder.getWaypointCache();
        return builder.getIsCenterTarget();
      });
      const layerCount = this.layerCount;
      return this.withLayer(MapSystemKeys.NearestWaypoints, (context) => {
        return FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter, waypointCache: facilityWaypointCache, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling, void 0, "flight-plan-text-layer").withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule()).withWaypoints().withContext(MapSystemKeys.FlightPlanner, () => flightPlanner).withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory()).withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1)).withController(MapSystemKeys.FlightPlan, (context) => new MapFlightPlanController(context)).withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
        context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, void 0, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
        configure(builder);
      });
      const layerCount = this.layerCount;
      return this.withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        return FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
      return this.withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes)).withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer)).withLayer(MapSystemKeys.Airspace, (context) => {
        var _a, _b;
        const optionsToUse = Object.assign({}, options);
        (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10));
        (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : optionsToUse.maxSearchItemCount = Subject.create(100);
        return FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse));
      }, order);
    }
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order, cssClass) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas)).withLayer("traffic", (context) => {
        const options = offScaleOobOptions !== void 0 ? Object.assign({}, offScaleOobOptions(context)) : {};
        if (options.oobOffset !== void 0 && !("isSubscribable" in options.oobOffset)) {
          options.oobOffset = Subject.create(options.oobOffset);
        }
        return FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context, model: context.model, mapProjection: context.projection, iconFactory, initCanvasStyles, class: cssClass }, options));
      }, order);
    }
    with(builder, ...args) {
      return builder(this, ...args);
    }
    build(cssClass) {
      const context = this.buildContext();
      const controllers = [];
      const ref = FSComponent.createRef();
      const onAfterRender = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterMapRender(ref.instance);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDeadZoneChanged = (deadZone) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onDeadZoneChanged(deadZone);
          } catch (e) {
            console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onMapProjectionChanged = (mapProjection, changeFlags) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onBeforeUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onBeforeUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
        context.projection.applyQueued();
      };
      const onAfterUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onWake = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onWake();
          } catch (e) {
            console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onSleep = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onSleep();
          } catch (e) {
            console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDestroy = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapDestroyed();
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const map = FSComponent.buildComponent(MapSystemComponent, { ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender, onDeadZoneChanged, onMapProjectionChanged, onBeforeUpdated, onAfterUpdated, onWake, onSleep, onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map((factory) => {
        const node = factory.factory(context);
        context.setLayer(factory.key, node.instance);
        return node;
      }));
      const controllerEntries = Array.from(this.controllerFactories).map(([key, factory]) => [key, factory.factory(context)]);
      for (const [key, controller] of controllerEntries) {
        context.setController(key, controller);
      }
      controllers.push(...controllerEntries.map(([, controller]) => controller));
      for (const callback of this.initCallbacks.values()) {
        callback(context);
      }
      return { context, map, ref };
    }
    buildContext() {
      var _a;
      const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
      context.projection.set({
        targetProjectedOffset: this.targetOffset,
        rangeEndpoints: this.nominalRangeEndpoints !== void 0 ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create()) : void 0,
        range: this.range
      });
      for (const factory of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
        context[factory.key] = factory.factory(context);
      }
      for (const factory of this.moduleFactories.values()) {
        context.model.addModule(factory.key, factory.factory());
      }
      return context;
    }
  };
  MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = /* @__PURE__ */ new Set([
    "bus",
    "model",
    "projection",
    "projectedSize",
    "deadZone",
    "getLayer",
    "setLayer",
    "getController",
    "setController"
  ]);
  var WarningType;
  (function(WarningType2) {
    WarningType2[WarningType2["Warning"] = 0] = "Warning";
    WarningType2[WarningType2["Caution"] = 1] = "Caution";
    WarningType2[WarningType2["Test"] = 2] = "Test";
    WarningType2[WarningType2["SoundOnly"] = 3] = "SoundOnly";
  })(WarningType || (WarningType = {}));
  var XMLCircularGaugeCursor;
  (function(XMLCircularGaugeCursor2) {
    XMLCircularGaugeCursor2[XMLCircularGaugeCursor2["Triangle"] = 1] = "Triangle";
  })(XMLCircularGaugeCursor || (XMLCircularGaugeCursor = {}));
  var XMLCircularGaugeValuePos;
  (function(XMLCircularGaugeValuePos2) {
    XMLCircularGaugeValuePos2[XMLCircularGaugeValuePos2["End"] = 1] = "End";
  })(XMLCircularGaugeValuePos || (XMLCircularGaugeValuePos = {}));
  var XMLHorizontalGaugeValuePos;
  (function(XMLHorizontalGaugeValuePos2) {
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["End"] = 1] = "End";
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLHorizontalGaugeValuePos || (XMLHorizontalGaugeValuePos = {}));
  var XMLVerticalGaugeValuePos;
  (function(XMLVerticalGaugeValuePos2) {
    XMLVerticalGaugeValuePos2[XMLVerticalGaugeValuePos2["None"] = 1] = "None";
  })(XMLVerticalGaugeValuePos || (XMLVerticalGaugeValuePos = {}));
  var XMLDoubleHorizontalGaugeValuePos;
  (function(XMLDoubleHorizontalGaugeValuePos2) {
    XMLDoubleHorizontalGaugeValuePos2[XMLDoubleHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLDoubleHorizontalGaugeValuePos || (XMLDoubleHorizontalGaugeValuePos = {}));
  var XMLGaugeType;
  (function(XMLGaugeType2) {
    XMLGaugeType2["Circular"] = "Circular";
    XMLGaugeType2["Horizontal"] = "Horizontal";
    XMLGaugeType2["DoubleHorizontal"] = "DoubleHorizontal";
    XMLGaugeType2["Vertical"] = "Vertical";
    XMLGaugeType2["DoubleVertical"] = "DoubleVertical";
    XMLGaugeType2["Text"] = "Text";
    XMLGaugeType2["ColumnGroup"] = "ColumnGroup";
    XMLGaugeType2["Column"] = "Column";
    XMLGaugeType2["Cylinder"] = "Cylinder";
    XMLGaugeType2["TwinCylinder"] = "TwinCylinder";
  })(XMLGaugeType || (XMLGaugeType = {}));
  var AlertState;
  (function(AlertState2) {
    AlertState2[AlertState2["New"] = 0] = "New";
    AlertState2[AlertState2["Acked"] = 1] = "Acked";
  })(AlertState || (AlertState = {}));
  var APVerticalModes;
  (function(APVerticalModes2) {
    APVerticalModes2[APVerticalModes2["NONE"] = 0] = "NONE";
    APVerticalModes2[APVerticalModes2["PITCH"] = 1] = "PITCH";
    APVerticalModes2[APVerticalModes2["VS"] = 2] = "VS";
    APVerticalModes2[APVerticalModes2["FLC"] = 3] = "FLC";
    APVerticalModes2[APVerticalModes2["ALT"] = 4] = "ALT";
    APVerticalModes2[APVerticalModes2["PATH"] = 5] = "PATH";
    APVerticalModes2[APVerticalModes2["GP"] = 6] = "GP";
    APVerticalModes2[APVerticalModes2["GS"] = 7] = "GS";
    APVerticalModes2[APVerticalModes2["CAP"] = 8] = "CAP";
    APVerticalModes2[APVerticalModes2["TO"] = 9] = "TO";
    APVerticalModes2[APVerticalModes2["GA"] = 10] = "GA";
    APVerticalModes2[APVerticalModes2["FPA"] = 11] = "FPA";
    APVerticalModes2[APVerticalModes2["FLARE"] = 12] = "FLARE";
  })(APVerticalModes || (APVerticalModes = {}));
  var APLateralModes;
  (function(APLateralModes2) {
    APLateralModes2[APLateralModes2["NONE"] = 0] = "NONE";
    APLateralModes2[APLateralModes2["ROLL"] = 1] = "ROLL";
    APLateralModes2[APLateralModes2["LEVEL"] = 2] = "LEVEL";
    APLateralModes2[APLateralModes2["GPSS"] = 3] = "GPSS";
    APLateralModes2[APLateralModes2["HEADING"] = 4] = "HEADING";
    APLateralModes2[APLateralModes2["VOR"] = 5] = "VOR";
    APLateralModes2[APLateralModes2["LOC"] = 6] = "LOC";
    APLateralModes2[APLateralModes2["BC"] = 7] = "BC";
    APLateralModes2[APLateralModes2["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes2[APLateralModes2["NAV"] = 9] = "NAV";
    APLateralModes2[APLateralModes2["TO"] = 10] = "TO";
    APLateralModes2[APLateralModes2["GA"] = 11] = "GA";
    APLateralModes2[APLateralModes2["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes2[APLateralModes2["TRACK"] = 13] = "TRACK";
    APLateralModes2[APLateralModes2["TRACK_HOLD"] = 14] = "TRACK_HOLD";
  })(APLateralModes || (APLateralModes = {}));
  var APAltitudeModes;
  (function(APAltitudeModes2) {
    APAltitudeModes2[APAltitudeModes2["NONE"] = 0] = "NONE";
    APAltitudeModes2[APAltitudeModes2["ALTS"] = 1] = "ALTS";
    APAltitudeModes2[APAltitudeModes2["ALTV"] = 2] = "ALTV";
  })(APAltitudeModes || (APAltitudeModes = {}));
  var APStates;
  (function(APStates2) {
    APStates2[APStates2["None"] = 0] = "None";
    APStates2[APStates2["APActive"] = 1] = "APActive";
    APStates2[APStates2["YawDamper"] = 2] = "YawDamper";
    APStates2[APStates2["Heading"] = 4] = "Heading";
    APStates2[APStates2["Nav"] = 8] = "Nav";
    APStates2[APStates2["NavArmed"] = 16] = "NavArmed";
    APStates2[APStates2["Approach"] = 32] = "Approach";
    APStates2[APStates2["ApproachArmed"] = 64] = "ApproachArmed";
    APStates2[APStates2["Backcourse"] = 128] = "Backcourse";
    APStates2[APStates2["BackcourseArmed"] = 256] = "BackcourseArmed";
    APStates2[APStates2["Alt"] = 512] = "Alt";
    APStates2[APStates2["AltS"] = 1024] = "AltS";
    APStates2[APStates2["AltV"] = 2048] = "AltV";
    APStates2[APStates2["VS"] = 4096] = "VS";
    APStates2[APStates2["FLC"] = 8192] = "FLC";
    APStates2[APStates2["GP"] = 16384] = "GP";
    APStates2[APStates2["GPArmed"] = 32768] = "GPArmed";
    APStates2[APStates2["GS"] = 65536] = "GS";
    APStates2[APStates2["GSArmed"] = 131072] = "GSArmed";
    APStates2[APStates2["Path"] = 262144] = "Path";
    APStates2[APStates2["PathArmed"] = 524288] = "PathArmed";
    APStates2[APStates2["PathInvalid"] = 1048576] = "PathInvalid";
    APStates2[APStates2["Pitch"] = 2097152] = "Pitch";
    APStates2[APStates2["Roll"] = 4194304] = "Roll";
    APStates2[APStates2["VNAV"] = 8388608] = "VNAV";
    APStates2[APStates2["ATSpeed"] = 16777216] = "ATSpeed";
    APStates2[APStates2["ATMach"] = 33554432] = "ATMach";
    APStates2[APStates2["ATArmed"] = 67108864] = "ATArmed";
    APStates2[APStates2["FD"] = 134217728] = "FD";
  })(APStates || (APStates = {}));
  var DirectorState;
  (function(DirectorState2) {
    DirectorState2["Inactive"] = "Inactive";
    DirectorState2["Armed"] = "Armed";
    DirectorState2["Active"] = "Active";
  })(DirectorState || (DirectorState = {}));
  var EmptyDirector = class {
    constructor() {
      this.onActivate = () => {
      };
      this.onArm = () => {
      };
      this.state = DirectorState.Inactive;
    }
    activate() {
    }
    deactivate() {
    }
    update() {
    }
    arm() {
    }
  };
  EmptyDirector.instance = new EmptyDirector();
  var VNavState;
  (function(VNavState2) {
    VNavState2[VNavState2["Disabled"] = 0] = "Disabled";
    VNavState2[VNavState2["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    VNavState2[VNavState2["Enabled_Active"] = 2] = "Enabled_Active";
  })(VNavState || (VNavState = {}));
  var VNavPathMode;
  (function(VNavPathMode2) {
    VNavPathMode2[VNavPathMode2["None"] = 0] = "None";
    VNavPathMode2[VNavPathMode2["PathArmed"] = 1] = "PathArmed";
    VNavPathMode2[VNavPathMode2["PathActive"] = 2] = "PathActive";
    VNavPathMode2[VNavPathMode2["PathInvalid"] = 3] = "PathInvalid";
  })(VNavPathMode || (VNavPathMode = {}));
  var ApproachGuidanceMode;
  (function(ApproachGuidanceMode2) {
    ApproachGuidanceMode2[ApproachGuidanceMode2["None"] = 0] = "None";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSArmed"] = 1] = "GSArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSActive"] = 2] = "GSActive";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPArmed"] = 3] = "GPArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPActive"] = 4] = "GPActive";
  })(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
  var VNavAltCaptureType;
  (function(VNavAltCaptureType2) {
    VNavAltCaptureType2[VNavAltCaptureType2["None"] = 0] = "None";
    VNavAltCaptureType2[VNavAltCaptureType2["Selected"] = 1] = "Selected";
    VNavAltCaptureType2[VNavAltCaptureType2["VNAV"] = 2] = "VNAV";
  })(VNavAltCaptureType || (VNavAltCaptureType = {}));
  var VNavAvailability;
  (function(VNavAvailability2) {
    VNavAvailability2["Available"] = "Available";
    VNavAvailability2["InvalidLegs"] = "InvalidLegs";
  })(VNavAvailability || (VNavAvailability = {}));
  var VNavUtils = class {
    static isUserConstraint(lateralLeg) {
      if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1 || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
        return true;
      }
      return false;
    }
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
      const delta = targetAltitude - currentAltitude;
      const minutesToConstraint = distance / groundSpeed * 60;
      return delta / minutesToConstraint;
    }
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
      return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    static getFpaFromVerticalSpeed(vs, groundspeed) {
      return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    static getFpa(distance, altitude) {
      return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    static altitudeForDistance(fpa, distance) {
      return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    static distanceForAltitude(fpa, altitude) {
      return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    static getMissedApproachLegIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
            return l;
          }
        }
      }
      return Math.max(0, plan.length - 1);
    }
    static getFafIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
            return l;
          }
        }
      }
      return void 0;
    }
    static getFafIndexReverse(lateralPlan, iterator) {
      let fafIndex = -1;
      iterator.iterateReverse(lateralPlan, (cursor) => {
        if (fafIndex === -1 && cursor.legDefinition && cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF) {
          fafIndex = cursor.legIndex + cursor.segment.offset;
        }
      });
      fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
      return fafIndex;
    }
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
        if (verticalPlan.constraints[c].index >= globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        if (verticalPlan.constraints[c].index < globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    static getIsPathEnd(verticalPlan, globalLegIndex) {
      const constraintIndex = verticalPlan.constraints.findIndex((c) => c.index === globalLegIndex);
      if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
        return true;
      }
      return false;
    }
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
      var _a, _b;
      return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    static getConstraintDistanceFromConstraint(constraint) {
      let distance = 0;
      for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
        distance += constraint.legs[legIndex].distance;
      }
      return distance;
    }
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
      let distance = 0;
      const startGlobalIndex = previousConstraint !== void 0 ? previousConstraint.index + 1 : 0;
      for (let i = startGlobalIndex; i <= constraint.index; i++) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
        distance += verticalLeg.distance;
      }
      return distance;
    }
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
      if (activeLegIndex > constraint.index) {
        return 0;
      }
      let distance = 0;
      let index = activeLegIndex;
      for (const leg of lateralPlan.legs(false, activeLegIndex)) {
        if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
          return Number.POSITIVE_INFINITY;
        } else if (leg.calculated !== void 0) {
          distance += leg.calculated.distanceWithTransitions;
        }
        if (++index > constraint.index) {
          break;
        }
      }
      distance -= distanceAlongLeg;
      return distance;
    }
    static getConstraintDetails(constraint, out) {
      if (constraint.maxAltitude === constraint.minAltitude) {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      } else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
        switch (constraint.type) {
          case "climb":
          case "missed":
            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            }
            break;
          default:
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            }
        }
      } else {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      }
      return out;
    }
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
      if (verticalPlan.constraints.length > 0) {
        if (selectedGlobalLegIndex < activeLegIndex) {
          return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
        }
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
          const constraint = verticalPlan.constraints[c];
          if (constraint.index === selectedGlobalLegIndex || c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index) {
            return constraint;
          } else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
            return verticalPlan.constraints[c + 1];
          }
        }
      }
      return void 0;
    }
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if ((constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.minAltitude : void 0;
    }
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint) {
        if (currentConstraint.type === "climb" && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return currentConstraint;
        } else if (currentConstraint.type === "climb" && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
          const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== void 0 ? VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
          for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === "climb" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              return constraint;
            }
          }
        }
      }
      return void 0;
    }
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if (constraint.type === "missed" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint.targetAltitude;
      }
      const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
      return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    static getFafAltitude(verticalPlan) {
      if (verticalPlan.fafLegIndex !== void 0) {
        return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
      }
      return void 0;
    }
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
      var _a;
      out.todLegIndex = -1;
      out.bodLegIndex = -1;
      out.todLegDistance = 0;
      out.distanceFromTod = 0;
      out.distanceFromBod = 0;
      out.currentConstraintLegIndex = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (!activeConstraint || (activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== void 0 && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex) {
        return out;
      }
      out.currentConstraintLegIndex = activeConstraint.index;
      const altitude = currentAltitude - currentVS / 20;
      let bodConstraintIndex, bodConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
          bodConstraintIndex = i;
          bodConstraint = constraint;
          break;
        }
      }
      if (!bodConstraint) {
        return out;
      }
      out.bodLegIndex = bodConstraint.index;
      let todConstraintIndex = bodConstraintIndex;
      for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const prevConstraint = verticalPlan.constraints[i + 1];
        if (!prevConstraint || prevConstraint.index < activeLegIndex || prevConstraint.type === "climb" || prevConstraint.type === "missed" || prevConstraint.targetAltitude > altitude || prevConstraint.fpa <= 0 || prevConstraint.isPathEnd) {
          todConstraintIndex = i;
          break;
        }
      }
      const todConstraint = verticalPlan.constraints[todConstraintIndex];
      let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
      let constraintIndex = todConstraintIndex;
      let todLegIndex = todConstraint.index;
      let todLegDistance = 0;
      let todLeg = todConstraint.legs[0];
      while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
        const constraint = verticalPlan.constraints[constraintIndex];
        for (let i = 0; i < constraint.legs.length; i++) {
          if (!constraint.legs[i].isEligible) {
            constraintIndex = verticalPlan.constraints.length;
            break;
          }
          todLeg = constraint.legs[i];
          distance -= todLeg.distance;
          if (distance <= 0) {
            todLegIndex = constraint.index - i;
            todLegDistance = todLeg.distance + distance;
            break;
          }
        }
        constraintIndex++;
      }
      if (distance > 0) {
        todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
        todLegDistance = todLeg.distance;
      }
      out.todLegIndex = todLegIndex;
      out.todLegDistance = todLegDistance;
      let globalLegIndex = bodConstraint.index;
      let distanceToBOD = 0, distanceToTOD = 0;
      let hasReachedTOD = false;
      let isDone = false;
      for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const constraint = verticalPlan.constraints[i];
        for (let j = 0; j < constraint.legs.length; j++) {
          const leg = constraint.legs[j];
          if (globalLegIndex === todLegIndex) {
            distanceToTOD -= todLegDistance;
            hasReachedTOD = true;
          }
          if (globalLegIndex > activeLegIndex) {
            distanceToBOD += leg.distance;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance;
            }
          } else if (globalLegIndex === activeLegIndex) {
            distanceToBOD += leg.distance - distanceAlongLeg;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance - distanceAlongLeg;
              isDone = true;
            } else {
              distanceToTOD -= distanceAlongLeg;
            }
          } else {
            if (hasReachedTOD) {
              isDone = true;
            } else {
              distanceToTOD -= leg.distance;
            }
          }
          if (isDone) {
            break;
          } else {
            globalLegIndex--;
          }
        }
        if (isDone) {
          break;
        }
      }
      out.distanceFromBod = distanceToBOD;
      out.distanceFromTod = distanceToTOD;
      return out;
    }
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
      var _a, _b;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (!activeConstraint || activeConstraint.type !== "climb" && activeConstraint.type !== "missed") {
        return out;
      }
      let tocConstraintIndex, tocConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (isFinite(constraint.maxAltitude)) {
          tocConstraintIndex = i;
          tocConstraint = constraint;
          break;
        }
      }
      if (!tocConstraint) {
        return out;
      }
      out.tocConstraintIndex = tocConstraintIndex;
      out.tocAltitude = tocConstraint.maxAltitude;
      const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
      let tocLegIndex;
      let currentConstraintIndex = activeConstraintIndex;
      let currentConstraint;
      let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
      let currentLeg = activeLeg;
      const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
      if (distanceRemaining > activeLegDistanceRemaining) {
        distanceRemaining -= activeLegDistanceRemaining;
        if (currentConstraintLegIndex <= 0) {
          --currentConstraintIndex;
        } else {
          currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
        }
        while (currentConstraintIndex >= tocConstraintIndex) {
          currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          currentLeg = currentConstraint.legs[currentConstraintLegIndex];
          if (currentLeg !== void 0) {
            if (distanceRemaining > currentLeg.distance) {
              out.distanceFromToc += currentLeg.distance;
              distanceRemaining -= currentLeg.distance;
            } else {
              out.distanceFromToc += distanceRemaining;
              tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
              distanceRemaining -= currentLeg.distance;
              break;
            }
          }
          if (currentConstraintLegIndex <= 0) {
            --currentConstraintIndex;
          } else {
            currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
          }
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = tocConstraint.index;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      let lastClimbConstraintIndex = tocConstraintIndex;
      let bocConstraintIndex, bocConstraint;
      for (let i = tocConstraintIndex - 1; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (constraint.maxAltitude > tocConstraint.maxAltitude) {
          bocConstraintIndex = i;
          bocConstraint = constraint;
          break;
        }
        lastClimbConstraintIndex = i;
      }
      let bocDistanceStopConstraintIndex = void 0;
      if (bocConstraint) {
        out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
        bocDistanceStopConstraintIndex = bocConstraintIndex;
      } else {
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
          out.bocLegIndex = lastClimbConstraint.index + 1;
          bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
        }
      }
      if (bocDistanceStopConstraintIndex !== void 0) {
        let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
          distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
        }
        out.distanceFromBoc = distanceToEndOfActiveConstraint;
        for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
          out.distanceFromBoc += verticalPlan.constraints[i].distance;
        }
      }
      return out;
    }
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
      const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
      const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
      const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
      if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
        return out;
      }
      const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
      const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
      if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
        const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
        out.bocLegIndex = lastClimbConstraint.index + 1;
        out.distanceFromBoc = activeLegDistanceRemaining + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
      }
      const deltaAltitude = cruiseAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      let tocLegIndex;
      const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
      if (distanceRemaining > activeLegDistanceRemaining) {
        let legIndex = activeLegIndex + 1;
        for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
          const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
          if (distanceRemaining > legDistance) {
            out.distanceFromToc += legDistance;
            distanceRemaining -= legDistance;
          } else {
            out.distanceFromToc += distanceRemaining;
            tocLegIndex = legIndex;
            distanceRemaining -= legDistance;
            break;
          }
          legIndex++;
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = lastLegIndex;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      out.tocAltitude = cruiseAltitude;
      return out;
    }
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset] !== void 0;
        }
      }
      return false;
    }
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset];
        }
      }
      throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
      const segment = verticalPlan.segments[segmentIndex];
      const leg = segment.legs[legIndex];
      if (segment && leg) {
        return leg;
      } else {
        throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
      }
    }
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
      return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    static getVerticalSegmentsFromPlan(verticalPlan) {
      return verticalPlan.segments;
    }
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
      if (lateralLeg.leg !== void 0) {
        switch (lateralLeg.leg.type) {
          case LegType.HA:
          case LegType.HF:
          case LegType.HM:
          case LegType.PI:
            return true;
        }
      }
      return false;
    }
    static createConstraint(index, minAltitude, maxAltitude, name, type = "descent") {
      return {
        index,
        minAltitude,
        maxAltitude,
        targetAltitude: 0,
        name,
        isTarget: false,
        isPathEnd: false,
        distance: 0,
        fpa: 0,
        legs: [],
        type,
        isBeyondFaf: false
      };
    }
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
      return {
        segmentIndex,
        legIndex,
        fpa: 0,
        altitude: 0,
        isUserDefined: false,
        isDirectToTarget: false,
        distance,
        isEligible: true,
        isBod: false,
        isAdvisory: true,
        name
      };
    }
    static getFirstClimbConstraintIndex(verticalPlan) {
      for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    static getLastClimbConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    static getFirstDescentConstraintIndex(verticalPlan) {
      let index = -1;
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        const type = verticalPlan.constraints[c].type;
        if (type === "descent" || type === "manual") {
          index = c;
        }
        if (type === "direct") {
          return c;
        }
      }
      return index;
    }
    static getLastDescentConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        const type = verticalPlan.constraints[i].type;
        if (type === "descent" || type === "direct" || type === "manual") {
          return i;
        }
      }
      return -1;
    }
    static speedConstraintEquals(a, b) {
      return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    static altitudeConstraintDetailsEquals(a, b) {
      return a.type === b.type && a.altitude === b.altitude;
    }
    static speedConstraintDetailsEquals(a, b) {
      return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint) && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    static getPathErrorDistance(groundSpeed) {
      if (groundSpeed <= 190) {
        return 100;
      } else if (groundSpeed >= 210) {
        return 250;
      } else {
        return 100 + (groundSpeed - 190) / 20 * 150;
      }
    }
  };
  var LNavTransitionMode;
  (function(LNavTransitionMode2) {
    LNavTransitionMode2[LNavTransitionMode2["None"] = 0] = "None";
    LNavTransitionMode2[LNavTransitionMode2["Ingress"] = 1] = "Ingress";
    LNavTransitionMode2[LNavTransitionMode2["Egress"] = 2] = "Egress";
    LNavTransitionMode2[LNavTransitionMode2["Unsuspend"] = 3] = "Unsuspend";
  })(LNavTransitionMode || (LNavTransitionMode = {}));
  var LNavVars;
  (function(LNavVars2) {
    LNavVars2["DTK"] = "L:WTAP_LNav_DTK";
    LNavVars2["XTK"] = "L:WTAP_LNav_XTK";
    LNavVars2["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    LNavVars2["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    LNavVars2["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    LNavVars2["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    LNavVars2["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    LNavVars2["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    LNavVars2["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    LNavVars2["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    LNavVars2["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    LNavVars2["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    LNavVars2["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    LNavVars2["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
  })(LNavVars || (LNavVars = {}));
  var LNavSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(LNavSimVarPublisher.simvars, bus);
    }
  };
  LNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnav_dtk", { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ["lnav_xtk", { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ["lnav_is_tracking", { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ["lnav_tracked_leg_index", { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ["lnav_transition_mode", { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ["lnav_tracked_vector_index", { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ["lnav_course_to_steer", { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ["lnav_is_suspended", { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ["lnav_leg_distance_along", { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_leg_distance_remaining", { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_distance_along", { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_vector_distance_remaining", { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_anticipation_distance", { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ["lnav_along_track_speed", { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
  ]);
  var LNavUtils = class {
    static getVectorsForTransitionMode(calc, mode, isSuspended) {
      switch (mode) {
        case LNavTransitionMode.None:
          return isSuspended ? calc.flightPath : calc.ingressToEgress;
        case LNavTransitionMode.Ingress:
          return calc.ingress;
        case LNavTransitionMode.Egress:
          return calc.egress;
        case LNavTransitionMode.Unsuspend:
          return calc.flightPath;
      }
    }
    static lnavTrackingStateEquals(a, b) {
      return a.isTracking === b.isTracking && a.globalLegIndex === b.globalLegIndex && a.transitionMode === b.transitionMode && a.vectorIndex === b.vectorIndex && a.isSuspended === b.isSuspended;
    }
  };
  var VNavVars;
  (function(VNavVars2) {
    VNavVars2["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    VNavVars2["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    VNavVars2["PathMode"] = "L:WTAP_VNav_Path_Mode";
    VNavVars2["VNAVState"] = "L:WTAP_VNav_State";
    VNavVars2["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    VNavVars2["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    VNavVars2["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    VNavVars2["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    VNavVars2["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    VNavVars2["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    VNavVars2["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    VNavVars2["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    VNavVars2["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    VNavVars2["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    VNavVars2["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    VNavVars2["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    VNavVars2["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    VNavVars2["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    VNavVars2["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    VNavVars2["FPA"] = "L:WTAP_VNav_FPA";
    VNavVars2["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    VNavVars2["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    VNavVars2["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    VNavVars2["GPDistance"] = "L:WTAP_GP_Distance";
    VNavVars2["GPFpa"] = "L:WTAP_GP_FPA";
    VNavVars2["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    VNavVars2["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
  })(VNavVars || (VNavVars = {}));
  var VNavSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(VNavSimVarPublisher.simvars, bus);
    }
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
  };
  VNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["vnav_vertical_deviation", { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ["vnav_target_altitude", { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ["vnav_path_mode", { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ["vnav_path_available", { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ["vnav_state", { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ["vnav_altitude_capture_type", { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ["vnav_tod_distance", { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_leg_distance", { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_bod_distance", { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_global_leg_index", { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ["vnav_bod_global_leg_index", { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ["vnav_toc_distance", { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_leg_distance", { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_boc_distance", { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_global_leg_index", { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_boc_global_leg_index", { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_global_leg_index", { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_altitude", { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_next_constraint_altitude", { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_fpa", { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ["vnav_required_vs", { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ["gp_approach_mode", { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ["gp_vertical_deviation", { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ["gp_distance", { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ["gp_fpa", { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ["gp_required_vs", { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ["gp_service_level", { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
  ]);
  var APHdgDirector = class {
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.toGaHeading = 0;
      this.bankServo = new LinearServo(APHdgDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaHeading = this.currentHeading;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaHeading = this.currentHeading;
          }
          this.setBank(this.desiredBank(this.toGaHeading));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgDirector.BANK_SERVO_RATE = 10;
  var APHdgHoldDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APHdgHoldDirector.BANK_SERVO_RATE);
      this.capturedHeading = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentHeadingSub = this.bus.getSubscriber().on("hdg_deg").withPrecision(0).handle((h) => this.currentHeading = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentHeadingSub.resume();
      this.capturedHeading = null;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentHeadingSub.pause();
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedHeading === null && Math.abs(this.currentBank) < APHdgHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedHeading = this.currentHeading;
        }
        this.setBank(this.capturedHeading !== null ? this.desiredBank(this.capturedHeading) : 0);
      }
    }
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgHoldDirector.BANK_SERVO_RATE = 10;
  APHdgHoldDirector.MIN_BANK_THRESHOLD = 1;
  var APNavDirector = class {
    constructor(bus, apValues, mode, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APNavDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      this.isNavLock = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.disableArming = (_b = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _b !== void 0 ? _b : false;
      this.forceNavSource = options === null || options === void 0 ? void 0 : options.forceNavSource;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        this.setNavLock(true);
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.setNavLock(false);
    }
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.disableArming || this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    canArm() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (this.mode === APLateralModes.LOC && typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      if (this.mode === APLateralModes.VOR && typeIsCorrect) {
        const indexIsCorrect = index == ((_f = this.cdi) === null || _f === void 0 ? void 0 : _f.source.index) && !((_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) && index == ((_h = this.obs) === null || _h === void 0 ? void 0 : _h.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(false);
          return true;
        }
      }
      if (this.mode === APLateralModes.LOC && this.apValues.navToNavLocArm && this.apValues.navToNavLocArm()) {
        this.isApproachMode.set(true);
        return true;
      }
      this.isApproachMode.set(false);
      return false;
    }
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index) || !((_f = this.loc) === null || _f === void 0 ? void 0 : _f.isValid) && index == ((_g = this.obs) === null || _g === void 0 ? void 0 : _g.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && (((_h = this.obs) === null || _h === void 0 ? void 0 : _h.heading) || ((_j = this.loc) === null || _j === void 0 ? void 0 : _j.course))) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? this.loc.course * Avionics.Utils.RAD2DEG : (_k = this.obs) === null || _k === void 0 ? void 0 : _k.heading;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_m = (_l = this.loc) === null || _l === void 0 ? void 0 : _l.isValid) !== null && _m !== void 0 ? _m : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    desiredBank() {
      var _a, _b, _c, _d, _e, _f, _g;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      const hasValidObs = this.obs !== void 0 && this.obs.heading !== null;
      let zoneOfConfusion = false;
      if (isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (!isLoc && (!hasValidDeviation || !hasValidObs)) {
        if (!this.checkForZoneOfConfusion()) {
          this.deactivate();
          return NaN;
        } else {
          zoneOfConfusion = true;
        }
      }
      if (zoneOfConfusion || this.cdi && this.cdi.deviation !== null) {
        const xtk = zoneOfConfusion ? 0 : this.cdi && this.cdi.deviation !== null ? this.getXtk(this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? this.loc.course * Avionics.Utils.RAD2DEG : (_d = this.obs) === null || _d === void 0 ? void 0 : _d.heading;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_f = (_e = this.cdi) === null || _e === void 0 ? void 0 : _e.deviation) !== null && _f !== void 0 ? _f : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_g = this.magVar) !== null && _g !== void 0 ? _g : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    monitorEvents() {
      const sub = this.bus.getSubscriber();
      if (this.forceNavSource) {
        this.navSource = {
          index: this.forceNavSource,
          type: NavSourceType.Nav
        };
        sub.on(`nav_radio_cdi_${this.forceNavSource}`).handle((cdi) => this.cdi = cdi);
        sub.on(`nav_radio_obs_${this.forceNavSource}`).handle((obs) => this.obs = obs);
        sub.on(`nav_radio_localizer_${this.forceNavSource}`).handle((loc) => this.loc = loc);
        sub.on(`nav_radio_nav_location_${this.forceNavSource}`).handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub.on(`nav_radio_magvar_${this.forceNavSource}`).handle((magVar) => {
          this.magVar = magVar;
        });
      } else {
        sub.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
        sub.on("nav_radio_active_obs_setting").handle((obs) => this.obs = obs);
        sub.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
        sub.on("cdi_select").handle((source) => {
          this.navSource = source;
          if (this.state === DirectorState.Active) {
            this.deactivate();
          }
        });
        sub.on("nav_radio_active_nav_location").handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub.on("nav_radio_active_magvar").handle((magVar) => {
          this.magVar = magVar;
        });
      }
      sub.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub.on("tas").handle((s) => this.tas = s);
      sub.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APNavDirector.BANK_SERVO_RATE = 10;
  var APRollDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.actualBank = 0;
      this.bankServo = new LinearServo(APRollDirector.BANK_SERVO_RATE);
      const minBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.minBankAngle) !== null && _a !== void 0 ? _a : 0;
      if (typeof minBankAngleOpt === "number") {
        this.minBankAngleFunc = () => minBankAngleOpt;
      } else {
        this.minBankAngleFunc = minBankAngleOpt;
      }
      const maxBankAngleOpt = options === null || options === void 0 ? void 0 : options.maxBankAngle;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
      const sub = this.bus.getSubscriber();
      sub.on("roll_deg").withPrecision(1).handle((roll) => {
        this.actualBank = roll;
      });
    }
    activate() {
      this.state = DirectorState.Active;
      const maxBank = this.maxBankAngleFunc();
      const minBank = this.minBankAngleFunc();
      if (Math.abs(this.actualBank) < minBank) {
        this.desiredBank = 0;
      } else {
        this.desiredBank = MathUtils.clamp(this.actualBank, -maxBank, maxBank);
      }
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", false);
    }
    update() {
      if (this.state === DirectorState.Active) {
        const maxBank = this.maxBankAngleFunc();
        const minBank = this.minBankAngleFunc();
        if (Math.abs(this.actualBank) < minBank) {
          this.desiredBank = 0;
        } else {
          this.desiredBank = MathUtils.clamp(this.actualBank, -maxBank, maxBank);
        }
        this.setBank(this.desiredBank);
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APRollDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APRollDirector.BANK_SERVO_RATE = 10;
  var APTrkDirector = class {
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.toGaTrack = 0;
      this.bankServo = new LinearServo(APTrkDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("track_deg_magnetic").withPrecision(0).handle((h) => {
        this.currentTrack = h;
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaTrack = this.currentTrack;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaTrack = this.currentTrack;
          }
          this.setBank(this.desiredBank(this.toGaTrack));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkDirector.BANK_SERVO_RATE = 10;
  var APTrkHoldDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APTrkHoldDirector.BANK_SERVO_RATE);
      this.capturedTrack = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentTrackSub = this.bus.getSubscriber().on("track_deg_magnetic").withPrecision(0).handle((h) => this.currentTrack = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentTrackSub.resume();
      this.capturedTrack = null;
      this.currentBankRef = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentTrackSub.pause();
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedTrack === null && Math.abs(this.currentBank) < APTrkHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedTrack = this.currentTrack;
        }
        this.setBank(this.capturedTrack !== null ? this.desiredBank(this.capturedTrack) : 0);
      }
    }
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkHoldDirector.BANK_SERVO_RATE = 10;
  APTrkHoldDirector.MIN_BANK_THRESHOLD = 1;
  var ArcTurnController = class {
    constructor() {
      this.bankController = new PidController(1.5, 0, 0, 15, -15);
      this.precessionController = new PidController(0.025, 0, 0, 300, -300);
      this.filter = new ExpSmoother(500);
    }
    getOutput(radiusError) {
      var _a;
      const currentTime = new Date().appTime();
      let bankAngle = 0;
      if (this.previousRadiusError !== void 0 && this.previousTime !== void 0) {
        const dTime = currentTime - this.previousTime;
        const input = (radiusError - this.previousRadiusError) / dTime * 1e3;
        const precessionRate = isNaN((_a = this.filter.last()) !== null && _a !== void 0 ? _a : NaN) ? this.filter.reset(input) : this.filter.next(input, dTime);
        const targetPrecessionRate = -this.precessionController.getOutput(dTime, radiusError);
        const precessionError = targetPrecessionRate - precessionRate;
        bankAngle = this.bankController.getOutput(dTime, precessionError);
      }
      this.previousTime = currentTime;
      this.previousRadiusError = radiusError;
      return -bankAngle;
    }
    reset() {
      this.previousTime = void 0;
      this.previousRadiusError = void 0;
      this.precessionController.reset();
      this.bankController.reset();
      this.filter.reset();
    }
  };
  var LNavDirector = class {
    constructor(bus, apValues, flightPlanner, obsDirector, options) {
      var _a, _b, _c;
      this.bus = bus;
      this.apValues = apValues;
      this.flightPlanner = flightPlanner;
      this.obsDirector = obsDirector;
      this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.publisher = this.bus.getPublisher();
      this.aircraftState = {
        tas: 0,
        gs: 0,
        track: 0,
        magvar: 0,
        windSpeed: 0,
        windDirection: 0,
        planePos: new GeoPoint(0, 0),
        hdgTrue: 0,
        altAgl: 0,
        bank: 0
      };
      this.currentLeg = void 0;
      this.currentVector = void 0;
      this.dtk = 0;
      this.xtk = 0;
      this.bearingToVectorEnd = 0;
      this.courseToSteer = 0;
      this.alongVectorDistance = 0;
      this.vectorDistanceRemaining = 0;
      this.vectorAnticipationDistance = 0;
      this.alongTrackSpeed = 0;
      this.anticipationVector = void 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      this.inhibitNextSequence = false;
      this.currentBankRef = 0;
      this.bankServo = new LinearServo(LNavDirector.BANK_SERVO_RATE);
      this.currentState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.anticipationState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.currentBankAngleState = {
        arcController: new ArcTurnController(),
        isInterceptingFromArmedState: false,
        trackAtActivation: 0,
        desiredBankAngle: 0
      };
      this.lnavData = ObjectSubject.create({
        dtk: 0,
        xtk: 0,
        trackingState: {
          isTracking: false,
          globalLegIndex: 0,
          transitionMode: LNavTransitionMode.None,
          vectorIndex: 0,
          isSuspended: false
        },
        isTracking: false,
        legIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        courseToSteer: 0,
        isSuspended: false,
        alongLegDistance: 0,
        legDistanceRemaining: 0,
        alongVectorDistance: 0,
        vectorDistanceRemaining: 0,
        vectorAnticipationDistance: 0,
        alongTrackSpeed: 0
      });
      this.isObsDirectorTracking = false;
      this.canArm = false;
      this.awaitCalculateId = 0;
      this.isAwaitingCalculate = false;
      this.isNavLock = Subject.create(false);
      this.lnavDataHandler = (obj, key, value) => {
        switch (key) {
          case "dtk":
            SimVar.SetSimVarValue(LNavVars.DTK, SimVarValueType.Degree, value);
            break;
          case "xtk":
            SimVar.SetSimVarValue(LNavVars.XTK, SimVarValueType.NM, value);
            break;
          case "isTracking":
            SimVar.SetSimVarValue(LNavVars.IsTracking, SimVarValueType.Bool, value);
            break;
          case "legIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number, value);
            break;
          case "transitionMode":
            SimVar.SetSimVarValue(LNavVars.TransitionMode, SimVarValueType.Number, value);
            break;
          case "vectorIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedVectorIndex, SimVarValueType.Number, value);
            break;
          case "courseToSteer":
            SimVar.SetSimVarValue(LNavVars.CourseToSteer, SimVarValueType.Degree, value);
            break;
          case "isSuspended":
            SimVar.SetSimVarValue(LNavVars.IsSuspended, SimVarValueType.Bool, value);
            break;
          case "alongLegDistance":
            SimVar.SetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM, value);
            break;
          case "legDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "alongVectorDistance":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceAlong, SimVarValueType.NM, value);
            break;
          case "vectorDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "vectorAnticipationDistance":
            SimVar.SetSimVarValue(LNavVars.VectorAnticipationDistance, SimVarValueType.NM, value);
            break;
          case "alongTrackSpeed":
            SimVar.SetSimVarValue(LNavVars.AlongTrackSpeed, SimVarValueType.Knots, value);
            break;
          case "trackingState":
            this.publisher.pub("lnav_tracking_state", value, true, true);
            break;
        }
      };
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.hasVectorAnticipation = (_b = options === null || options === void 0 ? void 0 : options.hasVectorAnticipation) !== null && _b !== void 0 ? _b : false;
      this.minimumActivationAltitude = options === null || options === void 0 ? void 0 : options.minimumActivationAltitude;
      this.disableArming = (_c = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _c !== void 0 ? _c : false;
      const sub = bus.getSubscriber();
      this.lnavData.sub(this.lnavDataHandler, true);
      sub.on("ambient_wind_velocity").handle((w) => this.aircraftState.windSpeed = w);
      sub.on("ambient_wind_direction").handle((wd) => this.aircraftState.windDirection = wd);
      sub.on("tas").handle((tas) => this.aircraftState.tas = tas);
      sub.on("hdg_deg_true").handle((hdg) => this.aircraftState.hdgTrue = hdg);
      sub.on("ground_speed").handle((gs) => this.aircraftState.gs = gs);
      sub.on("radio_alt").handle((alt) => this.aircraftState.altAgl = alt);
      sub.on("roll_deg").handle((roll) => this.aircraftState.bank = roll);
      const nav = this.bus.getSubscriber();
      nav.on("cdi_select").handle((src) => {
        if (this.state !== DirectorState.Inactive && src.type !== NavSourceType.Gps) {
          this.deactivate();
        }
      });
      sub.on("suspend_sequencing").handle((suspend) => {
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
        if (flightPlan) {
          if (suspend) {
            this.currentState.inhibitedSuspendLegIndex = -1;
          }
          this.trySetSuspended(flightPlan, this.currentState, suspend, this.currentState, false, false);
        }
      });
      sub.on("activate_missed_approach").handle((v) => {
        this.currentState.isMissedApproachActive = v;
      });
      sub.on("lnav_inhibit_next_sequence").handle((inhibit) => {
        this.inhibitNextSequence = inhibit;
        if (inhibit) {
          this.currentState.inhibitedSuspendLegIndex = -1;
        }
      });
      sub.on("fplActiveLegChange").handle((e) => {
        if (e.planIndex === this.flightPlanner.activePlanIndex && e.type === ActiveLegType.Lateral) {
          this.currentState.inhibitedSuspendLegIndex = -1;
          this.resetVectors();
        }
      });
      sub.on("fplIndexChanged").handle(() => {
        this.resetVectors();
      });
      sub.on("fplCopied").handle((e) => {
        if (e.targetPlanIndex === this.flightPlanner.activePlanIndex) {
          this.resetVectors();
        }
      });
      sub.on("gps-position").handle((lla) => {
        this.aircraftState.planePos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => this.aircraftState.track = t);
      sub.on("magvar").handle((m) => this.aircraftState.magvar = m);
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
      this.state = DirectorState.Inactive;
    }
    resetVectors() {
      this.currentState.vectorIndex = 0;
      this.currentState.transitionMode = LNavTransitionMode.Ingress;
      this.inhibitNextSequence = false;
      this.awaitCalculate();
    }
    activate() {
      this.currentBankAngleState.isInterceptingFromArmedState = !this.disableArming;
      this.currentBankAngleState.trackAtActivation = this.aircraftState.track;
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.currentBankAngleState.isInterceptingFromArmedState = false;
        if (this.canArm) {
          this.state = DirectorState.Armed;
          if (this.onArm !== void 0) {
            this.onArm();
          }
          this.setNavLock(true);
        }
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      if (this.obsDirector && this.obsDirector.state !== DirectorState.Inactive) {
        this.obsDirector.deactivate();
      }
      this.currentBankAngleState.isInterceptingFromArmedState = false;
      this.setNavLock(false);
    }
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    update() {
      var _a;
      let clearInhibitNextSequence = false;
      const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
      this.currentState.globalLegIndex = flightPlan ? flightPlan.activeLateralLeg : 0;
      let isTracking = !!flightPlan && this.currentState.globalLegIndex <= flightPlan.length - 1;
      if (flightPlan && isTracking) {
        if (this.isAwaitingCalculate) {
          return;
        }
        this.currentLeg = flightPlan.getLeg(this.currentState.globalLegIndex);
        clearInhibitNextSequence = !!this.currentLeg.calculated;
        this.calculateTracking(flightPlan);
        if (this.isAwaitingCalculate) {
          return;
        }
        if (this.hasVectorAnticipation) {
          this.updateVectorAnticipation(flightPlan);
        }
        isTracking = this.currentState.globalLegIndex < flightPlan.length && this.currentVector !== void 0 && this.currentVector.radius > LNavDirector.ANGULAR_TOLERANCE && this.currentVector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
        if (isTracking) {
          const calcs = this.currentLeg.calculated;
          if (this.obsDirector) {
            this.obsDirector.setLeg(this.currentState.globalLegIndex, this.currentLeg);
            if (this.obsDirector.obsActive) {
              this.currentState.isSuspended = true;
              this.currentState.inhibitedSuspendLegIndex = this.currentState.globalLegIndex;
              if (!this.isObsDirectorTracking) {
                this.lnavData.unsub(this.lnavDataHandler);
                this.isObsDirectorTracking = true;
                this.obsDirector.startTracking();
              }
              if (this.state === DirectorState.Active && this.obsDirector.state !== DirectorState.Active) {
                this.obsDirector.activate();
                this.setNavLock(true);
              }
              if (this.state === DirectorState.Armed && this.obsDirector.canActivate()) {
                this.obsDirector.activate();
                this.state = DirectorState.Active;
                if (this.onActivate !== void 0) {
                  this.onActivate();
                }
                this.setNavLock(true);
              }
              this.obsDirector.update();
              return;
            }
          }
          isTracking = calcs !== void 0;
          if (this.state !== DirectorState.Inactive) {
            this.navigateFlightPath();
          }
        }
      } else {
        this.currentState.isSuspended = false;
        clearInhibitNextSequence = true;
      }
      if (this.isObsDirectorTracking) {
        this.currentState.isSuspended = false;
      }
      this.canArm = isTracking;
      this.lnavData.set("isTracking", isTracking);
      this.lnavData.set("isSuspended", this.currentState.isSuspended);
      if (isTracking) {
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking !== isTracking || trackingState.globalLegIndex !== this.currentState.globalLegIndex || trackingState.transitionMode !== this.currentState.transitionMode || trackingState.vectorIndex !== this.currentState.vectorIndex || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking,
            globalLegIndex: this.currentState.globalLegIndex,
            transitionMode: this.currentState.transitionMode,
            vectorIndex: this.currentState.vectorIndex,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", this.dtk);
        this.lnavData.set("xtk", this.xtk);
        this.lnavData.set("legIndex", this.currentState.globalLegIndex);
        this.lnavData.set("vectorIndex", this.currentState.vectorIndex);
        this.lnavData.set("transitionMode", this.currentState.transitionMode);
        this.lnavData.set("courseToSteer", this.courseToSteer);
        this.lnavData.set("alongVectorDistance", this.alongVectorDistance);
        this.lnavData.set("vectorDistanceRemaining", this.vectorDistanceRemaining);
        this.lnavData.set("vectorAnticipationDistance", this.vectorAnticipationDistance);
        this.lnavData.set("alongTrackSpeed", this.alongTrackSpeed);
        this.lnavData.set("alongLegDistance", this.getAlongLegDistance(flightPlan, this.currentState, this.alongVectorDistance));
        this.lnavData.set("legDistanceRemaining", this.getLegDistanceRemaining(flightPlan, this.currentState, this.vectorDistanceRemaining));
      } else {
        this.currentLeg = void 0;
        this.currentVector = void 0;
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking || trackingState.globalLegIndex !== 0 || trackingState.transitionMode !== LNavTransitionMode.None || trackingState.vectorIndex !== 0 || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking: false,
            globalLegIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", 0);
        this.lnavData.set("xtk", 0);
        this.lnavData.set("legIndex", 0);
        this.lnavData.set("vectorIndex", 0);
        this.lnavData.set("transitionMode", LNavTransitionMode.None);
        this.lnavData.set("courseToSteer", 0);
        this.lnavData.set("alongLegDistance", 0);
        this.lnavData.set("vectorDistanceRemaining", 0);
        this.lnavData.set("alongVectorDistance", 0);
        this.lnavData.set("legDistanceRemaining", 0);
        this.lnavData.set("vectorAnticipationDistance", 0);
        this.lnavData.set("alongTrackSpeed", 0);
      }
      if (this.isObsDirectorTracking) {
        (_a = this.obsDirector) === null || _a === void 0 ? void 0 : _a.stopTracking();
        this.lnavData.sub(this.lnavDataHandler, true);
        this.isObsDirectorTracking = false;
      }
      if (this.state === DirectorState.Armed) {
        this.tryActivate();
      }
      this.inhibitNextSequence && (this.inhibitNextSequence = !clearInhibitNextSequence);
    }
    navigateFlightPath() {
      let bankAngle;
      if (this.anticipationVector && this.vectorAnticipationDistance > 0 && this.vectorDistanceRemaining <= this.vectorAnticipationDistance && Math.abs(this.xtk) < UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)) {
        this.updateBankAngle(this.anticipationVector, this.anticipationDtk, this.anticipationXtk, this.anticipationBearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (bankAngle === void 0) {
        if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
          return;
        }
        this.updateBankAngle(this.currentVector, this.dtk, this.xtk, this.bearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (this.state === DirectorState.Active) {
        this.setBank(bankAngle);
      }
    }
    updateBankAngle(vector, dtk, xtk, bearingToVectorEnd, bankAngleState) {
      let absInterceptAngle;
      let naturalAbsInterceptAngle = 0;
      if (this.lateralInterceptCurve !== void 0) {
        naturalAbsInterceptAngle = this.lateralInterceptCurve(dtk, xtk, this.aircraftState.tas);
      } else {
        naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
        if (naturalAbsInterceptAngle <= 2.5) {
          naturalAbsInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
        }
      }
      if (bankAngleState.isInterceptingFromArmedState) {
        absInterceptAngle = Math.abs(NavMath.diffAngle(bankAngleState.trackAtActivation, dtk));
        if (absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5 || absInterceptAngle < Math.abs(NavMath.diffAngle(dtk, bearingToVectorEnd))) {
          absInterceptAngle = naturalAbsInterceptAngle;
          bankAngleState.isInterceptingFromArmedState = false;
        }
      } else {
        absInterceptAngle = naturalAbsInterceptAngle;
      }
      const interceptAngle = xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
      const courseToSteer = NavMath.normalizeHeading(dtk + interceptAngle);
      bankAngleState.desiredBankAngle = this.desiredBank(courseToSteer);
      if (vector !== void 0 && !FlightPathUtils.isVectorGreatCircle(vector)) {
        this.adjustBankAngleForArc(vector, bankAngleState);
      }
      return bankAngleState;
    }
    desiredBank(desiredTrack) {
      const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
      const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    adjustBankAngleForArc(vector, bankAngleState) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
      const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const radius = UnitType.GA_RADIAN.convertTo(FlightPathUtils.getTurnRadiusFromCircle(circle), UnitType.METER);
      const relativeWindHeading = NavMath.normalizeHeading(this.aircraftState.windDirection - this.aircraftState.hdgTrue);
      const headwind = this.aircraftState.windSpeed * Math.cos(relativeWindHeading * Avionics.Utils.DEG2RAD);
      const distance = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.METER);
      const bankAdjustment = bankAngleState.arcController.getOutput(distance);
      const turnBankAngle = NavMath.bankAngle(this.aircraftState.tas - headwind, radius) * (turnDirection === "left" ? 1 : -1);
      const turnRadius = NavMath.turnRadius(this.aircraftState.tas - headwind, 25);
      const bankBlendFactor = Math.max(1 - Math.abs(UnitType.NMILE.convertTo(this.xtk, UnitType.METER)) / turnRadius, 0);
      const maxBank = this.maxBankAngleFunc();
      bankAngleState.desiredBankAngle = MathUtils.clamp(bankAngleState.desiredBankAngle * (1 - bankBlendFactor) + turnBankAngle * bankBlendFactor + bankAdjustment, -maxBank, maxBank);
      return bankAngleState;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = LNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    calculateTracking(plan) {
      var _a, _b;
      let didAdvance;
      do {
        didAdvance = false;
        if (!this.currentLeg) {
          break;
        }
        if (this.currentLeg.leg.type === LegType.IF && this.currentState.globalLegIndex === 0 && plan.length > 1) {
          this.currentLeg = plan.getLeg(++this.currentState.globalLegIndex);
          plan.setCalculatingLeg(this.currentState.globalLegIndex);
          plan.setLateralLeg(this.currentState.globalLegIndex);
          continue;
        }
        const transitionMode = this.currentState.transitionMode;
        const legIndex = this.currentState.globalLegIndex;
        const vectorIndex = this.currentState.vectorIndex;
        const isSuspended = this.currentState.isSuspended;
        const calcs = this.currentLeg.calculated;
        if (calcs) {
          const vectors = LNavUtils.getVectorsForTransitionMode(calcs, this.currentState.transitionMode, this.currentState.isSuspended);
          const vector = vectors[this.currentState.vectorIndex];
          const isVectorValid = vector && vector.radius > LNavDirector.ANGULAR_TOLERANCE && vector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
          const isUnsuspendInvalid = this.currentState.transitionMode === LNavTransitionMode.Unsuspend && (calcs.ingress.length === 0 || calcs.flightPath[calcs.ingressJoinIndex] === void 0);
          if (isVectorValid && !isUnsuspendInvalid) {
            const planePos = this.aircraftState.planePos;
            const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
            let endLat, endLon;
            let end;
            let vectorDistanceNM;
            if (transitionMode === LNavTransitionMode.Unsuspend && vectorIndex === calcs.ingressJoinIndex && calcs.ingress.length > 0) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              endLat = lastIngressVector.endLat;
              endLon = lastIngressVector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.NMILE);
            } else {
              endLat = vector.endLat;
              endLon = vector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.METER.convertTo(vector.distance, UnitType.NMILE);
            }
            this.xtk = UnitType.GA_RADIAN.convertTo(circle.distance(planePos), UnitType.NMILE);
            this.dtk = circle.bearingAt(planePos, Math.PI);
            this.bearingToVectorEnd = planePos.bearingTo(endLat, endLon);
            const alongTrackSpeed = FlightPathUtils.projectVelocityToCircle(this.aircraftState.gs, planePos, this.aircraftState.track, circle);
            this.alongTrackSpeed = isNaN(alongTrackSpeed) ? this.aircraftState.gs : alongTrackSpeed;
            const normDist = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, planePos);
            this.alongVectorDistance = normDist * vectorDistanceNM;
            this.vectorDistanceRemaining = (1 - normDist) * vectorDistanceNM;
            if (normDist > 1) {
              this.advanceToNextVector(plan, this.currentState, true, this.currentState);
            }
          } else {
            this.alongVectorDistance = 0;
            this.vectorDistanceRemaining = 0;
            this.vectorAnticipationDistance = 0;
            this.advanceToNextVector(plan, this.currentState, true, this.currentState);
          }
          didAdvance = transitionMode !== this.currentState.transitionMode || legIndex !== this.currentState.globalLegIndex || vectorIndex !== this.currentState.vectorIndex || isSuspended !== this.currentState.isSuspended;
          if (legIndex !== this.currentState.globalLegIndex) {
            this.currentLeg = (_a = plan.tryGetLeg(this.currentState.globalLegIndex)) !== null && _a !== void 0 ? _a : void 0;
            plan.setCalculatingLeg(this.currentState.globalLegIndex);
            plan.setLateralLeg(this.currentState.globalLegIndex);
          }
        }
      } while (!this.isAwaitingCalculate && didAdvance && this.currentState.globalLegIndex <= plan.length - 1);
      if (this.currentState.transitionMode === LNavTransitionMode.Egress && this.currentState.globalLegIndex + 1 < plan.length && plan.activeCalculatingLeg !== this.currentState.globalLegIndex + 1) {
        plan.setCalculatingLeg(this.currentState.globalLegIndex + 1);
      }
      this.currentVector = ((_b = this.currentLeg) === null || _b === void 0 ? void 0 : _b.calculated) ? LNavUtils.getVectorsForTransitionMode(this.currentLeg.calculated, this.currentState.transitionMode, this.currentState.isSuspended)[this.currentState.vectorIndex] : void 0;
    }
    updateVectorAnticipation(plan) {
      var _a;
      this.anticipationVector = void 0;
      this.vectorAnticipationDistance = 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        return;
      }
      this.advanceToNextVector(plan, this.currentState, false, this.anticipationState);
      const anticipationCalcs = (_a = plan.tryGetLeg(this.anticipationState.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!anticipationCalcs) {
        return;
      }
      const anticipationVectors = LNavUtils.getVectorsForTransitionMode(anticipationCalcs, this.anticipationState.transitionMode, this.anticipationState.isSuspended);
      this.anticipationVector = anticipationVectors[this.anticipationState.vectorIndex];
      if (!this.anticipationVector || this.anticipationVector === this.currentVector || this.anticipationVector.radius === 0 || this.anticipationVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        this.anticipationVector = void 0;
        return;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(this.anticipationVector, this.geoCircleCache[0]);
      this.anticipationXtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.NMILE);
      this.anticipationDtk = circle.bearingAt(this.aircraftState.planePos, Math.PI);
      this.anticipationBearingToVectorEnd = this.aircraftState.planePos.bearingTo(this.anticipationVector.endLat, this.anticipationVector.endLon);
      const maxBankAngle = this.maxBankAngleFunc();
      const currentVectorIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.currentVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const anticipationIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.anticipationVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const deltaBank = Math.abs(currentVectorIdealBankAngle - anticipationIdealBankAngle);
      const rollTimeSeconds = deltaBank / LNavDirector.VECTOR_ANTICIPATION_BANK_RATE;
      this.vectorAnticipationDistance = Math.min(
        rollTimeSeconds / 3600 * this.alongTrackSpeed,
        UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)
      );
    }
    applyEndOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      const inhibitNextSequence = this.inhibitNextSequence && leg.leg.type !== LegType.ThruDiscontinuity;
      if (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM || leg.leg.type === LegType.Discontinuity) {
        return this.trySetSuspended(plan, state, true, out, true, false);
      } else if (inhibitNextSequence) {
        return this.trySetSuspended(plan, state, true, out, false, true);
      } else if (state.globalLegIndex < plan.length - 1) {
        const nextLeg = plan.getLeg(state.globalLegIndex + 1);
        if (!state.isMissedApproachActive && (leg.leg.fixTypeFlags === FixTypeFlags.MAP || !BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach) && BitFlags.isAll(nextLeg.flags, LegDefinitionFlags.MissedApproach))) {
          return this.trySetSuspended(plan, state, true, out, true, false);
        }
      }
      return out;
    }
    applyStartOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.getLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      if (leg.leg.type === LegType.HM || state.globalLegIndex === plan.length - 1) {
        return this.trySetSuspended(plan, state, true, out, false, false);
      }
      return out;
    }
    advanceToNextVector(plan, state, awaitCalculateOnNextLeg, out) {
      var _a, _b, _c, _d, _e, _f;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      let leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      let legIndex = state.globalLegIndex;
      let transitionMode = state.transitionMode;
      let isSuspended = state.isSuspended;
      let vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
      let vectorIndex = state.vectorIndex + 1;
      let vectorEndIndex = (_a = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _a !== void 0 ? _a : 0;
      let didAdvance = false;
      let isDone = false;
      if (transitionMode === LNavTransitionMode.Unsuspend && leg.calculated) {
        if (leg.calculated.ingressJoinIndex < 0) {
          vectorEndIndex = 0;
        } else {
          const ingress = leg.calculated.ingress;
          const ingressJoinVector = leg.calculated.flightPath[leg.calculated.ingressJoinIndex];
          if (ingress.length > 0 && ingressJoinVector && GeoPoint.equals(ingress[ingress.length - 1].endLat, ingress[ingress.length - 1].endLon, ingressJoinVector.startLat, ingressJoinVector.startLon)) {
            vectorEndIndex = leg.calculated.ingressJoinIndex;
          } else {
            vectorEndIndex = leg.calculated.ingressJoinIndex + 1;
          }
        }
      }
      while (!vectors || vectorIndex >= vectorEndIndex || vectors[vectorIndex].radius === 0 || vectors[vectorIndex].distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        switch (transitionMode) {
          case LNavTransitionMode.Ingress:
            transitionMode = LNavTransitionMode.None;
            vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
            vectorIndex = Math.max(0, isSuspended ? (_c = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.ingressJoinIndex) !== null && _c !== void 0 ? _c : 0 : 0);
            didAdvance = true;
            break;
          case LNavTransitionMode.Unsuspend:
            transitionMode = LNavTransitionMode.None;
            vectors = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.ingressToEgress;
            vectorIndex = 0;
            didAdvance = true;
            break;
          case LNavTransitionMode.None:
            if (!isSuspended) {
              transitionMode = LNavTransitionMode.Egress;
              vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
              vectorIndex = 0;
              didAdvance = true;
            } else if (leg.leg.type === LegType.HM) {
              vectors = (_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath;
              vectorIndex = 0;
              didAdvance = true;
            } else {
              if (!didAdvance && vectors) {
                vectorIndex = Math.max(0, vectors.length - 1);
              }
              isDone = true;
            }
            break;
          case LNavTransitionMode.Egress:
            out.globalLegIndex = legIndex;
            out.transitionMode = transitionMode;
            out.vectorIndex = vectorIndex;
            out.isSuspended = isSuspended;
            this.advanceToNextLeg(plan, out, out);
            if (awaitCalculateOnNextLeg || out.globalLegIndex === legIndex) {
              return out;
            }
            leg = plan.tryGetLeg(out.globalLegIndex);
            if (!(leg === null || leg === void 0 ? void 0 : leg.calculated)) {
              return out;
            } else {
              legIndex = out.globalLegIndex;
              transitionMode = out.transitionMode;
              vectors = LNavUtils.getVectorsForTransitionMode(leg.calculated, out.transitionMode, out.isSuspended);
              vectorIndex = out.vectorIndex;
              isSuspended = out.isSuspended;
              didAdvance = false;
            }
        }
        if (isDone) {
          break;
        }
        vectorEndIndex = (_f = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _f !== void 0 ? _f : 0;
      }
      out.globalLegIndex = legIndex;
      out.transitionMode = transitionMode;
      out.vectorIndex = vectorIndex;
      out.isSuspended = isSuspended;
      return out;
    }
    advanceToNextLeg(plan, state, out) {
      var _a, _b, _c;
      this.applyEndOfLegSuspends(plan, state, out);
      if (!out.isSuspended) {
        if (out.globalLegIndex + 1 >= plan.length) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = Math.max(0, ((_c = (_b = (_a = plan.tryGetLeg(out.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) !== null && _c !== void 0 ? _c : 0) - 1);
          return out;
        }
        out.globalLegIndex++;
        out.transitionMode = LNavTransitionMode.Ingress;
        out.vectorIndex = 0;
        out.inhibitedSuspendLegIndex = -1;
        this.applyStartOfLegSuspends(plan, out, out);
      }
      return out;
    }
    trySetSuspended(plan, state, suspend, out, inhibitResuspend = false, resetVectorsOnSuspendEnd = false) {
      var _a;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      if (suspend && state.globalLegIndex === state.inhibitedSuspendLegIndex) {
        return out;
      }
      if (suspend) {
        out.inhibitedSuspendLegIndex = inhibitResuspend ? state.globalLegIndex : -1;
        out.resetVectorsOnSuspendEnd = resetVectorsOnSuspendEnd;
      }
      if (state.isSuspended !== suspend) {
        out.isSuspended = suspend;
        if (!suspend && state.resetVectorsOnSuspendEnd) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = 0;
          out.resetVectorsOnSuspendEnd = false;
        } else {
          const leg = plan.tryGetLeg(state.globalLegIndex);
          const legCalc = leg === null || leg === void 0 ? void 0 : leg.calculated;
          const ingressJoinVector = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath[legCalc.ingressJoinIndex];
          if (legCalc && state.transitionMode === LNavTransitionMode.None && legCalc.ingressJoinIndex >= 0 && ingressJoinVector && legCalc.ingress.length > 0) {
            const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
            let vectors;
            let offset;
            if (suspend) {
              vectors = legCalc.flightPath;
              if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                offset = legCalc.ingressJoinIndex + 1;
              } else {
                offset = legCalc.ingressJoinIndex;
              }
            } else {
              let pastIngressJoin = state.vectorIndex > legCalc.ingressJoinIndex;
              if (!pastIngressJoin && state.vectorIndex === legCalc.ingressJoinIndex && legCalc.flightPath[legCalc.ingressJoinIndex]) {
                const vector = legCalc.flightPath[legCalc.ingressJoinIndex];
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                const end = GeoPoint.sphericalToCartesian(ingressJoinVector.endLat, ingressJoinVector.endLon, this.vec3Cache[1]);
                pastIngressJoin = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.aircraftState.planePos) >= 1;
              }
              if (pastIngressJoin) {
                vectors = legCalc.ingressToEgress;
                if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                  offset = -(legCalc.ingressJoinIndex + 1);
                } else {
                  offset = -legCalc.ingressJoinIndex;
                }
              } else {
                vectors = legCalc.flightPath;
                offset = 0;
                out.transitionMode = LNavTransitionMode.Unsuspend;
              }
            }
            out.vectorIndex = Math.max(0, Math.min(state.vectorIndex + offset, vectors.length - 1));
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Unsuspend) {
            out.transitionMode = LNavTransitionMode.None;
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Egress) {
            out.transitionMode = LNavTransitionMode.None;
            out.vectorIndex = Math.max(0, ((_a = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath.length) !== null && _a !== void 0 ? _a : 1) - 1);
          }
        }
      }
      return out;
    }
    tryActivate() {
      if (this.disableArming) {
        this.activate();
        return;
      }
      if (this.minimumActivationAltitude === void 0 || this.aircraftState.altAgl >= this.minimumActivationAltitude) {
        const headingDiff = NavMath.diffAngle(this.aircraftState.track, this.dtk);
        if (Math.abs(this.xtk) < 0.6 && Math.abs(headingDiff) < 110) {
          this.activate();
        }
      }
    }
    async awaitCalculate() {
      if (!this.flightPlanner.hasActiveFlightPlan()) {
        return;
      }
      this.isAwaitingCalculate = true;
      const id = ++this.awaitCalculateId;
      const plan = this.flightPlanner.getActiveFlightPlan();
      try {
        await plan.calculate();
      } catch (_a) {
      }
      if (id !== this.awaitCalculateId) {
        return;
      }
      this.isAwaitingCalculate = false;
    }
    getAlongLegDistance(plan, state, alongVectorDistance) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, false);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let distanceAlong = 0;
      for (let i = state.vectorIndex - 1; i >= 0; i--) {
        distanceAlong += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Egress:
          vectors = calcs.ingressToEgress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          vectors = calcs.ingress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
      }
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex; i < calcs.ingressJoinIndex; i++) {
            distanceAlong -= vectors[i].distance;
          }
          if (state.vectorIndex <= calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceAlong -= UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
        }
      }
      return UnitType.METER.convertTo(distanceAlong, UnitType.NMILE) + alongVectorDistance;
    }
    getLegDistanceRemaining(plan, state, vectorDistanceRemaining) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, state.isSuspended);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let vectorIndex = state.vectorIndex;
      let distanceRemaining = 0;
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex + 1; i < calcs.ingressJoinIndex; i++) {
            distanceRemaining += vectors[i].distance;
          }
          if (state.vectorIndex < calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
          vectorIndex = -1;
        }
        vectors = calcs.ingressToEgress;
      }
      for (let i = vectorIndex + 1; i < vectors.length; i++) {
        distanceRemaining += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Ingress:
          vectors = LNavUtils.getVectorsForTransitionMode(calcs, LNavTransitionMode.None, state.isSuspended);
          for (let i = Math.max(0, state.isSuspended ? calcs.ingressJoinIndex : 0); i < vectors.length; i++) {
            const currentVector = vectors[i];
            if (state.isSuspended && i === calcs.ingressJoinIndex) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              if (lastIngressVector) {
                const circle = FlightPathUtils.setGeoCircleFromVector(currentVector, this.geoCircleCache[0]);
                distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(this.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon), this.geoPointCache[1].set(currentVector.endLat, currentVector.endLon), Math.PI), UnitType.METER);
                continue;
              }
            }
            distanceRemaining += currentVector.distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          if (!state.isSuspended) {
            vectors = calcs.egress;
            for (let i = 0; i < vectors.length; i++) {
              distanceRemaining += vectors[i].distance;
            }
          }
      }
      return UnitType.METER.convertTo(distanceRemaining, UnitType.NMILE) + vectorDistanceRemaining;
    }
    static copyStateInfo(source, target) {
      target.globalLegIndex = source.globalLegIndex;
      target.transitionMode = source.transitionMode;
      target.vectorIndex = source.vectorIndex;
      target.isSuspended = source.isSuspended;
      target.inhibitedSuspendLegIndex = source.inhibitedSuspendLegIndex;
      target.resetVectorsOnSuspendEnd = source.resetVectorsOnSuspendEnd;
      target.isMissedApproachActive = source.isMissedApproachActive;
      return target;
    }
    static getVectorIdealBankAngle(vector, groundSpeed) {
      if (FlightPathUtils.isVectorGreatCircle(vector)) {
        return 0;
      }
      if (vector.radius < MathUtils.HALF_PI) {
        return NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(vector.radius, UnitType.METER));
      } else {
        return -NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(Math.PI - vector.radius, UnitType.METER));
      }
    }
  };
  LNavDirector.ANGULAR_TOLERANCE = GeoCircle.ANGULAR_TOLERANCE;
  LNavDirector.ANGULAR_TOLERANCE_METERS = UnitType.GA_RADIAN.convertTo(GeoCircle.ANGULAR_TOLERANCE, UnitType.METER);
  LNavDirector.BANK_SERVO_RATE = 10;
  LNavDirector.VECTOR_ANTICIPATION_BANK_RATE = 5;
  var APBackCourseDirector = class {
    constructor(bus, apValues, mode, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APBackCourseDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", false);
    }
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    canArm() {
      var _a, _b, _c, _d, _e;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      this.isApproachMode.set(false);
      return false;
    }
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && ((_f = this.loc) === null || _f === void 0 ? void 0 : _f.course)) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_h = (_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) !== null && _h !== void 0 ? _h : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    desiredBank() {
      var _a, _b, _c, _d, _e, _f;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      if (!isLoc || isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (this.cdi && this.cdi.deviation !== null) {
        const xtk = this.cdi && this.cdi.deviation !== null ? this.getXtk(-this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_e = -((_d = this.cdi) === null || _d === void 0 ? void 0 : _d.deviation)) !== null && _e !== void 0 ? _e : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_f = this.magVar) !== null && _f !== void 0 ? _f : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APBackCourseDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    monitorEvents() {
      const sub = this.bus.getSubscriber();
      sub.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
      sub.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
      sub.on("cdi_select").handle((source) => {
        this.navSource = source;
        if (this.state === DirectorState.Active) {
          this.deactivate();
        }
      });
      sub.on("nav_radio_active_nav_location").handle((loc) => {
        this.navLocation.set(loc.lat, loc.long);
      });
      sub.on("nav_radio_active_magvar").handle((magVar) => {
        this.magVar = magVar;
      });
      sub.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub.on("tas").handle((s) => this.tas = s);
      sub.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APBackCourseDirector.BANK_SERVO_RATE = 10;
  var APLvlDirector = class {
    constructor(bus, isToGaMode = false) {
      this.bus = bus;
      this.isToGaMode = isToGaMode;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.bankServo = new LinearServo(APLvlDirector.BANK_SERVO_RATE);
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.desiredBank = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", true);
      }
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", false);
      }
    }
    update() {
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank);
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APLvlDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APLvlDirector.BANK_SERVO_RATE = 10;
  var SmoothingPathCalculator = class {
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.primaryPlanIndex = primaryPlanIndex;
      this.verticalFlightPlans = [];
      this.planBuilt = new SubEvent();
      this.vnavCalculated = new SubEvent();
      this.legAltitudes = [0, 0];
      this.applyPathValuesResult = [void 0, 0];
      this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
      this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
      this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
      this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
      this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
      this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
      this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : () => true;
      this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
      this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
      const fpl = this.bus.getSubscriber();
      fpl.on("fplCreated").handle((e) => this.createVerticalPlan(e.planIndex));
      fpl.on("fplCopied").handle((e) => this.onPlanChanged(e.targetPlanIndex));
      fpl.on("fplLoaded").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplLegChange").handle((e) => this.onPlanChanged(e.planIndex, e));
      fpl.on("fplSegmentChange").handle((e) => this.onPlanChanged(e.planIndex, void 0, e));
      fpl.on("fplIndexChanged").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplCalculated").handle((e) => this.onPlanCalculated(e));
      bus.getSubscriber().on("vnav_set_default_fpa").handle(this.setDefaultFpa.bind(this));
      bus.getSubscriber().on("vnav_set_vnav_direct_to").handle((data) => {
        if (data.globalLegIndex < 0) {
          this.cancelVerticalDirect(data.planIndex);
        } else {
          this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
        }
      });
    }
    getVerticalFlightPlan(planIndex) {
      var _a;
      var _b;
      return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : _b[planIndex] = this.createVerticalPlan(planIndex);
    }
    createVerticalPlan(planIndex) {
      const verticalFlightPlan = {
        planIndex,
        length: 0,
        constraints: [],
        segments: [],
        destLegIndex: void 0,
        fafLegIndex: void 0,
        firstDescentConstraintLegIndex: void 0,
        lastDescentConstraintLegIndex: void 0,
        missedApproachStartIndex: void 0,
        currentAlongLegDistance: void 0,
        verticalDirectIndex: void 0,
        verticalDirectFpa: void 0,
        planChanged: true
      };
      this.verticalFlightPlans[planIndex] = verticalFlightPlan;
      return verticalFlightPlan;
    }
    requestPathCompute(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== void 0) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        this.computePathAndNotify(lateralPlan, verticalPlan);
        return true;
      }
      return false;
    }
    getTargetConstraintIndex(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
          const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
          if (priorConstraint && priorConstraint.type !== "climb" && priorConstraint.type !== "missed") {
            return priorConstraintIndex;
          } else {
            return -1;
          }
        }
        let i = verticalPlan.constraints.length - 1;
        while (i >= 0) {
          const constraint = verticalPlan.constraints[i];
          if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== "climb" && constraint.type !== "missed") {
            return i;
          }
          i--;
        }
      } else {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraintIndex >= 0) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isMissed = currentConstraint.type === "missed";
          for (let i = currentConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === "climb" || isMissed && constraint.type === "missed") {
              if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return i;
              }
            } else {
              return -1;
            }
          }
        }
      }
      return -1;
    }
    getTargetConstraint(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    getTargetAltitude(planIndex, globalLegIndex) {
      var _a, _b;
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
      } else {
        return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
      }
    }
    getFlightPhase(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex)) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
        if (globalLegIndex > -1) {
          const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
          switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
            case "climb":
            case "missed":
              return VerticalFlightPhase.Climb;
          }
        }
      }
      return VerticalFlightPhase.Descent;
    }
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return void 0;
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
      } else {
        return currentConstraint.targetAltitude;
      }
    }
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return { type: AltitudeRestrictionType.Unused, altitude: 0 };
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        if (priorConstraint) {
          return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        } else {
          return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
      } else {
        return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
      }
    }
    getNextConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint !== void 0) {
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
          if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
            return currentConstraint.maxAltitude;
          } else {
            return currentConstraint.minAltitude;
          }
        } else {
          if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
            return currentConstraint.minAltitude;
          } else {
            return currentConstraint.maxAltitude;
          }
        }
      }
      return void 0;
    }
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
      if (currentConstraint) {
        const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
        if (currentConstraintIndex > -1) {
          if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "climb" || constraint.type === "missed") {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          } else {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
                if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          }
        }
      }
      return void 0;
    }
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
      if (constraintGlobalLegIndex < 0) {
        return;
      }
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
      verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    cancelVerticalDirect(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex === void 0) {
        return;
      }
      verticalPlan.verticalDirectIndex = void 0;
      verticalPlan.verticalDirectFpa = void 0;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    setDefaultFpa(fpa) {
      const newFpa = Math.max(0, fpa);
      if (newFpa !== this.flightPathAngle) {
        this.flightPathAngle = newFpa;
        for (let i = 0; i < this.verticalFlightPlans.length; i++) {
          const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : void 0;
          const verticalPlan = this.verticalFlightPlans[i];
          if (lateralPlan && verticalPlan) {
            if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
              verticalPlan.planChanged = true;
              this.notifyCalculated(i);
            }
          }
        }
      }
    }
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
      const plan = this.flightPlanner.getFlightPlan(planIndex);
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex !== void 0) {
        if (legChangeEvent !== void 0) {
          const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
          if (globalIndex <= verticalPlan.verticalDirectIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        } else if (segmentChangeEvent !== void 0) {
          const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
          if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        }
      }
      verticalPlan.planChanged = true;
      verticalPlan.currentAlongLegDistance = void 0;
    }
    onPlanCalculated(event) {
      const lateralPlan = this.flightPlanner.getFlightPlan(event.planIndex);
      const verticalPlan = this.getVerticalFlightPlan(event.planIndex);
      if (verticalPlan.planChanged) {
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      } else {
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      }
    }
    notifyBuilt(planIndex) {
      this.planBuilt.notify(this, planIndex);
    }
    notifyCalculated(planIndex) {
      this.vnavCalculated.notify(this, planIndex);
    }
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
      this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
      this.notifyBuilt(verticalPlan.planIndex);
    }
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
      this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
      SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
      verticalPlan.planChanged = false;
    }
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
      var _a, _b, _c, _d, _e, _f, _g;
      verticalPlan.constraints.length = 0;
      verticalPlan.segments.length = 0;
      verticalPlan.destLegIndex = void 0;
      verticalPlan.firstDescentConstraintLegIndex = void 0;
      verticalPlan.lastDescentConstraintLegIndex = void 0;
      verticalPlan.missedApproachStartIndex = void 0;
      verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
      const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
      let firstApproachGlobalLegIndex;
      for (const segment of lateralPlan.segments()) {
        verticalPlan.segments[segment.segmentIndex] = {
          offset: segment.offset,
          legs: []
        };
        if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === void 0) {
          firstApproachGlobalLegIndex = segment.offset;
        }
        for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
          const globalLegIndex = segment.offset + segmentLegIndex;
          const lateralLeg = segment.legs[segmentLegIndex];
          const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : "", (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : void 0);
          if (verticalPlan.missedApproachStartIndex === void 0 && segment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            verticalPlan.missedApproachStartIndex = globalLegIndex;
          }
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
          verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
          const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== void 0 && globalLegIndex < verticalPlan.verticalDirectIndex;
          const legPrecedesDirectTo = directToTargetLegIndex !== void 0 && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
          if (constraintAltitudes !== void 0 && !legPrecedesVerticalDirectIndex && !legPrecedesDirectTo && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
            verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
            const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.unshift(verticalConstraint);
          }
          verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
        }
      }
      verticalPlan.length = lateralPlan.length;
      if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== void 0) {
        const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
        if (firstApproachConstraint && firstApproachConstraint.type !== "climb" && firstApproachConstraint.type !== "missed") {
          SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
        }
      }
      verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
      verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
      var _a;
      const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? "missed" : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? "descent" : "climb");
      constraint.isBeyondFaf = verticalPlan.fafLegIndex === void 0 ? false : globalLegIndex > verticalPlan.fafLegIndex;
      if (verticalPlan.verticalDirectIndex === globalLegIndex) {
        constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
        constraint.type = "direct";
      }
      const userFpa = lateralLeg.verticalData.fpa;
      if (userFpa !== void 0 && constraint.type !== "climb" && constraint.type !== "missed") {
        constraint.fpa = userFpa;
        constraint.type = "manual";
      }
      return constraint;
    }
    computePathAndNotify(lateralPlan, verticalPlan) {
      if (this.computePath(lateralPlan, verticalPlan)) {
        this.notifyCalculated(lateralPlan.planIndex);
        return true;
      } else {
        return false;
      }
    }
    computePath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return false;
      }
      this.computeDescentPath(lateralPlan, verticalPlan);
      return true;
    }
    computeDescentPath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return;
      }
      this.fillLegDistances(lateralPlan, verticalPlan);
      this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
      this.findAndRemoveInvalidConstraints(verticalPlan);
      this.populateConstraints(verticalPlan);
      if (this.computeFlightPathAngles(verticalPlan)) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
          const constraint = verticalPlan.constraints[constraintIndex];
          if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
            let altitude = constraint.targetAltitude;
            let constraintIsBod = true;
            if (constraintIndex > 0) {
              const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
              if (nextConstraint !== void 0 && nextConstraint.type !== "climb") {
                const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                if (nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25 || constraint.fpa === 0) {
                  constraintIsBod = false;
                }
              }
            }
            if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
              constraint.isPathEnd = true;
              constraint.isTarget = true;
              constraintIsBod = true;
            }
            for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
              const leg = constraint.legs[legIndex];
              leg.fpa = constraint.fpa;
              leg.altitude = altitude;
              altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
              if (legIndex === 0) {
                leg.isAdvisory = false;
              } else {
                leg.isAdvisory = true;
              }
              if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                leg.isBod = true;
              } else {
                leg.isBod = false;
              }
            }
          }
        }
      }
    }
    fillLegDistances(lateralPlan, verticalPlan) {
      var _a, _b, _c;
      if (lateralPlan.length > 0) {
        for (const segment of lateralPlan.segments()) {
          if (segment) {
            const vnavSegment = verticalPlan.segments[segment.segmentIndex];
            for (let l = 0; l < segment.legs.length; l++) {
              const leg = segment.legs[l];
              if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
              } else if (leg && leg.calculated && leg.calculated.endLat !== void 0 && leg.calculated.endLon !== void 0) {
                let prevLeg;
                for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                  if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== void 0 && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== void 0) {
                    prevLeg = checkLeg;
                    break;
                  }
                }
                if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                  vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                }
              } else {
                vnavSegment.legs[l].distance = 0;
              }
            }
          }
        }
      }
    }
    findAndRemoveInvalidConstraints(verticalPlan) {
      var _a, _b, _c;
      let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? firstDescentConstraintIndex : verticalPlan.constraints.length - 1;
      let phase = "climb";
      let priorMinAltitude = -Infinity;
      let priorMaxAltitude = Infinity;
      let distanceFromPriorMinAltitude = 0;
      let requiredFpa = 0;
      for (let i = startIndex; i >= 0; i--) {
        const currentConstraint = verticalPlan.constraints[i];
        const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
        let currentPhase;
        switch (currentConstraint.type) {
          case "climb":
          case "missed":
            currentPhase = currentConstraint.type;
            break;
          default:
            currentPhase = "descent";
        }
        if (currentPhase !== phase) {
          phase = currentPhase;
          priorMinAltitude = -Infinity;
          priorMaxAltitude = Infinity;
          distanceFromPriorMinAltitude = currentConstraintDistance;
        } else {
          distanceFromPriorMinAltitude += currentConstraintDistance;
        }
        let isDescentConstraint;
        let shouldInvalidate;
        switch (phase) {
          case "climb":
          case "missed":
            isDescentConstraint = false;
            shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
            break;
          default:
            isDescentConstraint = true;
            if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
              requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
            } else {
              requiredFpa = 0;
            }
            shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
        }
        const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
        if (shouldInvalidate) {
          constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
          verticalPlan.constraints.splice(i, 1);
          distanceFromPriorMinAltitude -= currentConstraintDistance;
          if (isDescentConstraint && i === firstDescentConstraintIndex) {
            firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
            verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
          }
        } else {
          constraintLeg.invalidConstraintAltitude = void 0;
          if (isFinite(currentConstraint.minAltitude)) {
            priorMinAltitude = currentConstraint.minAltitude;
            distanceFromPriorMinAltitude = 0;
          }
          if (isFinite(currentConstraint.maxAltitude)) {
            priorMaxAltitude = currentConstraint.maxAltitude;
          }
        }
      }
      verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
      var _a;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? verticalPlan.firstDescentConstraintLegIndex + 1 : 0;
      let globalLegIndex = startIndex;
      for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        if (verticalLeg.invalidConstraintAltitude !== void 0) {
          const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          if (constraintAltitudes !== void 0) {
            const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
            if (proposedConstraint.type === "descent" || proposedConstraint.type === "manual" || proposedConstraint.type === "direct" || proposedConstraint.type === "dest") {
              if (verticalPlan.firstDescentConstraintLegIndex === void 0 || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
              }
              if (verticalPlan.lastDescentConstraintLegIndex === void 0 || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
              }
            }
          }
        }
        globalLegIndex++;
      }
    }
    populateConstraints(verticalPlan) {
      for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
        const constraint = verticalPlan.constraints[constraintIndex];
        const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
        constraint.legs.length = 0;
        constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
        let eligibleLegIndex;
        let ineligibleLegIndex;
        for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== void 0 ? previousConstraint.index : -1); globalLegIndex--) {
          const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
          constraint.legs.push(verticalLeg);
          if (ineligibleLegIndex === void 0 && verticalLeg.isEligible) {
            eligibleLegIndex = globalLegIndex;
          }
          if (ineligibleLegIndex === void 0 && !verticalLeg.isEligible) {
            ineligibleLegIndex = globalLegIndex;
          }
        }
        if (ineligibleLegIndex !== void 0 && eligibleLegIndex !== void 0) {
          constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
        }
      }
    }
    computeFlightPathAngles(verticalPlan) {
      let currentTargetConstraint;
      let currentPathSegmentDistance = 0;
      let currentPathSegmentMinFpa = this.minFlightPathAngle;
      let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
      let currentTargetConstraintHasFixedFpa = false;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
      if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
        return false;
      }
      for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
        const constraint = verticalPlan.constraints[targetConstraintIndex];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (!currentTargetConstraint) {
          if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
            currentTargetConstraint = constraint;
            currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
            currentTargetConstraint.isTarget = true;
          } else {
            continue;
          }
        }
        currentPathSegmentMinFpa = this.minFlightPathAngle;
        currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        currentPathSegmentDistance = currentTargetConstraint.distance;
        const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
        if (currentTargetConstraintIsFirstDescentConstraint) {
          if (currentTargetConstraint.type === "descent") {
            currentTargetConstraint.fpa = this.flightPathAngle;
          }
          return true;
        }
        if (currentTargetConstraint.type === "manual") {
          currentPathSegmentMinFpa = currentTargetConstraint.fpa;
          currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
          currentTargetConstraintHasFixedFpa = true;
        } else {
          currentTargetConstraintHasFixedFpa = false;
        }
        let pathSegmentIsFlat = false;
        for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
          const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
          const isCurrentConstraintClimb = currentConstraint.type === "climb" || currentConstraint.type === "missed";
          const isCurrentConstraintManual = currentConstraint.type === "manual";
          const isCurrentConstraintDirect = currentConstraint.type === "direct";
          if (isCurrentConstraintClimb) {
            if (currentConstraintIndex - 1 > targetConstraintIndex) {
              currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
              const maxAltitude2 = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
              const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude2, false);
              if (terminatedIndex < currentConstraintIndex) {
                targetConstraintIndex = terminatedIndex - 1;
                currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                break;
              }
            } else {
              currentTargetConstraint.fpa = this.flightPathAngle;
            }
            targetConstraintIndex = currentConstraintIndex;
            currentTargetConstraint = void 0;
            break;
          }
          const minAltitude = currentConstraint.minAltitude;
          const maxAltitude = currentConstraint.maxAltitude;
          if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
            const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
            const newTargetConstraintIndex = currentConstraintIndex - 1;
            SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
            targetConstraintIndex = newTargetConstraintIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            currentTargetConstraint.targetAltitude = flatSegmentAltitude;
            currentTargetConstraint.isTarget = true;
            break;
          } else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
            pathSegmentIsFlat = true;
            currentTargetConstraint.fpa = 0;
            if (isCurrentConstraintFirstDescent) {
              const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
              SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
              targetConstraintIndex = currentConstraintIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
              currentTargetConstraint.targetAltitude = flatSegmentAltitude;
              currentTargetConstraint.isTarget = true;
              break;
            }
            continue;
          }
          const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
          const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
          const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
          if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
            if (isFpaOutOfBounds) {
              if (minFpa > currentPathSegmentMaxFpa) {
                currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
              } else {
                currentTargetConstraint.fpa = currentPathSegmentMinFpa;
              }
            } else {
              currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
              currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
              currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            }
            const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
            targetConstraintIndex = terminatedIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
            break;
          } else if (isCurrentConstraintFirstDescent) {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
            if (terminatedIndex < currentConstraintIndex + 1) {
              targetConstraintIndex = terminatedIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
              break;
            } else {
              return true;
            }
          } else {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentPathSegmentDistance += currentConstraint.distance;
          }
        }
      }
      return true;
    }
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
      const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
      if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== void 0) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
        const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
        const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
        newTargetConstraint.isTarget = true;
        newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
      }
      return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    getFirstDescentConstraintAltitude(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.constraints.length > 0) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
          const constraint = verticalPlan.constraints[i];
          if (constraint.type !== "climb") {
            return constraint.targetAltitude;
          }
        }
      }
      return void 0;
    }
    static getConstraintAltitudes(leg, out) {
      if (leg.verticalData !== void 0) {
        switch (leg.verticalData.altDesc) {
          case AltitudeRestrictionType.At:
            out[0] = leg.verticalData.altitude1;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.AtOrAbove:
            out[0] = leg.verticalData.altitude1;
            out[1] = Number.POSITIVE_INFINITY;
            return out;
          case AltitudeRestrictionType.AtOrBelow:
            out[0] = Number.NEGATIVE_INFINITY;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.Between:
            out[0] = leg.verticalData.altitude2;
            out[1] = leg.verticalData.altitude1;
            return out;
        }
      }
      return void 0;
    }
    static forceAtConstraint(constraint) {
      if (constraint.minAltitude !== constraint.maxAltitude) {
        if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          constraint.maxAltitude = constraint.minAltitude;
        } else {
          constraint.minAltitude = constraint.maxAltitude;
        }
      }
    }
    static getDirectToTargetLegIndex(lateralPlan) {
      const directToData = lateralPlan.directToData;
      if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
        const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
        if (segment !== null) {
          return segment.offset + directToData.segmentLegIndex;
        }
      }
      return void 0;
    }
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
      if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
        const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
        if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
          const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
          directVerticalLeg.isDirectToTarget = true;
          const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
          if (segment !== void 0) {
            const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type !== "climb" && constraint.type !== "missed" && constraint.index >= globalLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                return;
              }
            }
            verticalPlan.firstDescentConstraintLegIndex = void 0;
          }
        }
      }
    }
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
      if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
        return true;
      }
      return false;
    }
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
      const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
      const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
      if (currentMinWithPrecision > priorMaxWithPrecision) {
        return true;
      }
      return false;
    }
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
      if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
        const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
        const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
        if (minFpaTempValue > maxFpa) {
          return true;
        }
      }
      return false;
    }
    static isLegVnavEligible(lateralLeg) {
      switch (lateralLeg.leg.type) {
        case LegType.VM:
        case LegType.FM:
        case LegType.Discontinuity:
        case LegType.ThruDiscontinuity:
          return false;
        default:
          return true;
      }
    }
    static invalidateClimbConstraint() {
      return false;
    }
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
      return isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10) || requiredFpa > maxFpa;
    }
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
      for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.maxAltitude < Infinity) {
          return constraint.maxAltitude;
        }
        if (i === firstDescentConstraintIndex && constraint.type === "direct") {
          if (constraint.minAltitude > -Infinity) {
            return constraint.minAltitude;
          }
        }
      }
      return Infinity;
    }
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
      const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
      let distance = currentTargetConstraint.distance;
      for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
        const smoothedConstraint = verticalPlan.constraints[i];
        const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
        if (targetAltitude < maxAltitude) {
          smoothedConstraint.fpa = currentTargetConstraint.fpa;
          smoothedConstraint.targetAltitude = targetAltitude;
          distance += smoothedConstraint.distance;
        } else {
          out[0] = i;
          out[1] = distance;
          return out;
        }
      }
      out[0] = void 0;
      out[1] = distance;
      return out;
    }
  };
  SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
  SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
  SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
  SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;
  var LNavDataVars;
  (function(LNavDataVars2) {
    LNavDataVars2["DTKTrue"] = "L:WT_LNavData_DTK_True";
    LNavDataVars2["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    LNavDataVars2["XTK"] = "L:WT_LNavData_XTK";
    LNavDataVars2["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    LNavDataVars2["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    LNavDataVars2["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    LNavDataVars2["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    LNavDataVars2["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
  })(LNavDataVars || (LNavDataVars = {}));
  var LNavDataSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(LNavDataSimVarPublisher.simvars, bus);
    }
  };
  LNavDataSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnavdata_dtk_true", { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ["lnavdata_dtk_mag", { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_xtk", { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ["lnavdata_cdi_scale", { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ["lnavdata_waypoint_bearing_true", { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_bearing_mag", { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_distance", { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ["lnavdata_destination_distance", { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
  ]);
  var AltitudeSelectManager = class {
    constructor(bus, settingsManager, options, stops) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.stops = new SortedArray((a, b) => a - b);
      this.isEnabled = true;
      this.isInitialized = false;
      this.isPaused = false;
      this.isLocked = false;
      this.lockDebounceTimer = new DebounceTimer();
      this.consecIncrSmallCount = 0;
      this.lastIncrSmallDirection = 1;
      this.lastIncrSmallInputTime = 0;
      this.selectedAltitudeChangedHandler = () => {
        setTimeout(() => {
          this.isLocked = false;
          this.lockDebounceTimer.clear();
        });
      };
      this.altitudeHoldSlotIndex = (_a = options.altitudeHoldSlotIndex) !== null && _a !== void 0 ? _a : 1;
      this.altitudeHoldSlotSimVar = `AUTOPILOT ALTITUDE LOCK VAR:${this.altitudeHoldSlotIndex}`;
      this.minValue = Math.round(options.minValue.asUnit(UnitType.FOOT));
      this.maxValue = Math.round(options.maxValue.asUnit(UnitType.FOOT));
      this.minValueMetric = Math.round(((_b = options.minValueMetric) !== null && _b !== void 0 ? _b : options.minValue).asUnit(UnitType.METER));
      this.maxValueMetric = Math.round(((_c = options.maxValueMetric) !== null && _c !== void 0 ? _c : options.maxValue).asUnit(UnitType.METER));
      this.inputIncrLargeThreshold = options.inputIncrLargeThreshold;
      this.incrSmall = Math.round(options.incrSmall.asUnit(UnitType.FOOT));
      this.incrLarge = Math.round(options.incrLarge.asUnit(UnitType.FOOT));
      this.incrSmallMetric = Math.round(((_d = options.incrSmallMetric) !== null && _d !== void 0 ? _d : options.incrSmall).asUnit(UnitType.METER));
      this.incrLargeMetric = Math.round(((_e = options.incrLargeMetric) !== null && _e !== void 0 ? _e : options.incrLarge).asUnit(UnitType.METER));
      this.lockAltToStepOnIncr = (_f = options.lockAltToStepOnIncr) !== null && _f !== void 0 ? _f : true;
      this.lockAltToStepOnIncrMetric = (_g = options.lockAltToStepOnIncrMetric) !== null && _g !== void 0 ? _g : this.lockAltToStepOnIncr;
      this.accelInputCountThreshold = (_h = options.accelInputCountThreshold) !== null && _h !== void 0 ? _h : 0;
      this.accelResetOnDirectionChange = (_j = options.accelResetOnDirectionChange) !== null && _j !== void 0 ? _j : false;
      this.initToIndicatedAlt = (_k = options.initToIndicatedAlt) !== null && _k !== void 0 ? _k : false;
      this.transformSetToIncDec = (_l = options.transformSetToIncDec) !== null && _l !== void 0 ? _l : true;
      this.altimeterMetricSetting = options.supportMetric ? settingsManager.getSetting("altMetric") : void 0;
      if (stops !== void 0) {
        if ("isSubscribableSet" in stops) {
          stops.sub((set, type, key) => {
            if (type === SubscribableSetEventType.Added) {
              this.stops.insert(key);
            } else {
              this.stops.remove(key);
            }
          }, true);
        } else {
          this.stops.insertAll(new Set(stops));
        }
      }
      this.isInitialized = !((_m = options.initOnInput) !== null && _m !== void 0 ? _m : false);
      KeyEventManager.getManager(bus).then((manager) => {
        this.keyEventManager = manager;
        manager.interceptKey("AP_ALT_VAR_SET_ENGLISH", false);
        manager.interceptKey("AP_ALT_VAR_SET_METRIC", false);
        manager.interceptKey("AP_ALT_VAR_INC", false);
        manager.interceptKey("AP_ALT_VAR_DEC", false);
        const sub = this.bus.getSubscriber();
        if (this.transformSetToIncDec) {
          sub.on(`ap_altitude_selected_${this.altitudeHoldSlotIndex}`).whenChanged().handle(this.selectedAltitudeChangedHandler);
        }
        sub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        this.publisher.pub("alt_select_is_initialized", !this.isEnabled || this.isInitialized, true);
      });
    }
    setEnabled(isEnabled) {
      this.isEnabled = isEnabled;
      this.publisher.pub("alt_select_is_initialized", !isEnabled || this.isInitialized, true);
    }
    resume() {
      this.isPaused = false;
    }
    pause() {
      this.isPaused = true;
    }
    reset(altitude, resetInitialized = false) {
      if (!this.isEnabled) {
        return;
      }
      SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, altitude);
      if (resetInitialized) {
        this.isInitialized = false;
        this.publisher.pub("alt_select_is_initialized", false, true);
      }
    }
    onKeyIntercepted({ key, value0: value, value1: index }) {
      switch (key) {
        case "AP_ALT_VAR_INC":
        case "AP_ALT_VAR_DEC":
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          break;
        default:
          return;
      }
      index !== null && index !== void 0 ? index : index = 1;
      index = Math.max(1, index);
      if (!this.isEnabled || index !== this.altitudeHoldSlotIndex) {
        this.passThroughKeyEvent(key, index, value);
        return;
      }
      if (!this.isPaused && !this.isLocked) {
        this.handleKeyEvent(key, value);
      }
    }
    handleKeyEvent(key, value) {
      const currentValue = SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet);
      let startValue = currentValue;
      if (!this.isInitialized) {
        if (this.initToIndicatedAlt) {
          startValue = SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet);
        } else {
          startValue = 0;
        }
        this.publisher.pub("alt_select_is_initialized", true, true);
        this.isInitialized = true;
      }
      let direction = 0;
      let useLargeIncrement = false;
      let setAltitude = void 0;
      switch (key) {
        case "AP_ALT_VAR_INC":
          direction = 1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_DEC":
          direction = -1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC": {
          if (value !== void 0 && value !== currentValue) {
            if (this.transformSetToIncDec) {
              const delta = value - currentValue;
              direction = delta < 0 ? -1 : 1;
              useLargeIncrement = Math.abs(delta) > this.inputIncrLargeThreshold;
            } else {
              setAltitude = value;
            }
          }
          break;
        }
      }
      if (setAltitude !== void 0) {
        this.setSelectedAltitude(setAltitude);
        return;
      }
      if (this.accelInputCountThreshold > 0) {
        const time = Date.now();
        let isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (useLargeIncrement || direction === 0 || this.consecIncrSmallCount > 0 && time - this.lastIncrSmallInputTime > AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD || (isAccelActive ? this.accelResetOnDirectionChange : this.consecIncrSmallCount > 0) && this.lastIncrSmallDirection !== direction) {
          this.consecIncrSmallCount = 0;
        }
        if (!useLargeIncrement) {
          this.consecIncrSmallCount++;
          this.lastIncrSmallDirection = direction;
          this.lastIncrSmallInputTime = time;
        }
        isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (isAccelActive) {
          useLargeIncrement = true;
        }
      }
      if (direction !== 0) {
        this.changeSelectedAltitude(startValue, direction, useLargeIncrement);
      }
    }
    setSelectedAltitude(altitudeFeet) {
      var _a, _b;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min, max, unit;
      if (isMetric) {
        min = this.minValueMetric;
        max = this.maxValueMetric;
        unit = UnitType.METER;
      } else {
        min = this.minValue;
        max = this.maxValue;
        unit = UnitType.FOOT;
      }
      const valueToSet = UnitType.FOOT.convertFrom(MathUtils.clamp(UnitType.FOOT.convertTo(altitudeFeet, unit), min, max), unit);
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
      }
    }
    changeSelectedAltitude(startValue, direction, useLargeIncrement = false) {
      var _a, _b;
      const roundFunc = direction === 1 ? Math.floor : Math.ceil;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min, max, incrSmall, incrLarge, units, lockAlt;
      if (isMetric) {
        min = this.minValueMetric;
        max = this.maxValueMetric;
        incrSmall = this.incrSmallMetric;
        incrLarge = this.incrLargeMetric;
        units = UnitType.METER;
        lockAlt = this.lockAltToStepOnIncrMetric;
      } else {
        min = this.minValue;
        max = this.maxValue;
        incrSmall = this.incrSmall;
        incrLarge = this.incrLarge;
        units = UnitType.FOOT;
        lockAlt = this.lockAltToStepOnIncr;
      }
      const startValueConverted = Math.round(UnitType.FOOT.convertTo(startValue, units));
      useLargeIncrement && (useLargeIncrement = !lockAlt || startValueConverted % incrSmall === 0);
      let valueToSet = UnitType.FOOT.convertFrom(Utils.Clamp((lockAlt ? roundFunc(startValueConverted / incrSmall) * incrSmall : startValueConverted) + direction * (useLargeIncrement ? incrLarge : incrSmall), min, max), units);
      if (this.stops.length > 0) {
        let nextStopIndex = this.stops.matchIndex(startValue);
        if (direction === 1) {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 1;
          } else {
            nextStopIndex++;
          }
        } else {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 2;
          } else {
            nextStopIndex--;
          }
        }
        const nextStop = this.stops.peek(nextStopIndex);
        if (nextStop !== void 0 && Math.abs(valueToSet - startValue) > Math.abs(nextStop - startValue)) {
          valueToSet = nextStop;
        }
      }
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
        if (this.transformSetToIncDec) {
          this.isLocked = true;
          this.lockDebounceTimer.schedule(() => {
            this.isLocked = false;
          }, 250);
        }
      }
    }
    passThroughKeyEvent(key, index, value) {
      index = Math.max(1, index);
      const currentValue = SimVar.GetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet);
      let valueToSet = currentValue;
      switch (key) {
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          if (value !== void 0) {
            valueToSet = value;
          }
          break;
        case "AP_ALT_VAR_INC":
          valueToSet += value === 0 || value === void 0 ? 100 : value;
          break;
        case "AP_ALT_VAR_DEC":
          valueToSet -= value === 0 || value === void 0 ? 100 : value;
          break;
      }
      SimVar.SetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet, valueToSet);
    }
  };
  AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD = 300;
  var APModeType;
  (function(APModeType2) {
    APModeType2[APModeType2["LATERAL"] = 0] = "LATERAL";
    APModeType2[APModeType2["VERTICAL"] = 1] = "VERTICAL";
    APModeType2[APModeType2["APPROACH"] = 2] = "APPROACH";
  })(APModeType || (APModeType = {}));
  var AutothrottleTargetMode;
  (function(AutothrottleTargetMode2) {
    AutothrottleTargetMode2["None"] = "None";
    AutothrottleTargetMode2["Speed"] = "Speed";
    AutothrottleTargetMode2["Power"] = "Power";
    AutothrottleTargetMode2["ThrottlePos"] = "ThrottlePos";
  })(AutothrottleTargetMode || (AutothrottleTargetMode = {}));
  var AbstractAutothrottle = class {
    constructor(bus, airspeedIndex, throttleInfos, options, throttleLeverManager) {
      var _a, _b, _c, _d, _e, _f;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.isOverspeedProtActive = Subject.create(false);
      this.isUnderspeedProtActive = Subject.create(false);
      this.isOverpowerProtActive = Subject.create(false);
      this.targetMode = Subject.create(AutothrottleTargetMode.None);
      this.selectedSpeedIsMach = Subject.create(false);
      this.selectedIas = Subject.create(0);
      this.selectedMach = Subject.create(0);
      this.selectedPower = Subject.create(0);
      this.selectedThrottlePos = Subject.create(0);
      this.maxIas = Subject.create(0);
      this.minIas = Subject.create(0);
      this.maxMach = Subject.create(0);
      this.minMach = Subject.create(0);
      this.maxPower = Subject.create(0);
      this.maxThrottlePos = Subject.create(1);
      this.minThrottlePos = Subject.create(0);
      this.lastSmoothedIas = void 0;
      this.realTime = ConsumerSubject.create(this.bus.getSubscriber().on("realTime"), 0);
      this.updateTimer = null;
      this.lastUpdateTime = 0;
      this.updateHandler = this.update.bind(this);
      this.speedCommand = {
        selectedSpeedPowerTarget: void 0,
        overspeedProtPowerTarget: void 0,
        underspeedProtPowerTarget: void 0,
        isOverspeed: false,
        isUnderspeed: false
      };
      this.powerCommand = {
        speed: void 0,
        targetPos: void 0,
        isOverspeedProtEngaged: false,
        isUnderspeedProtEngaged: false,
        isOverpowerProtEngaged: false
      };
      this.isAlive = true;
      this.airspeedIndex = SubscribableUtils.toSubscribable(airspeedIndex, true);
      this.airspeedIndex.sub((index) => {
        this.airspeedSimVar = `AIRSPEED INDICATED:${index}`;
      }, true);
      this.powerLookahead = SubscribableUtils.toSubscribable(options.powerLookahead, true);
      this.throttles = throttleInfos.map((info) => {
        return this.createThrottle(bus, info, options.servoSpeed, options.powerSmoothingConstant, this.powerLookahead, throttleLeverManager);
      });
      this.machToKiasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.iasLookahead = SubscribableUtils.toSubscribable(options.speedLookahead, true);
      this.iasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lookaheadIasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lastIasLookahead = this.iasLookahead.get();
      this.selectedSpeedPid = AbstractAutothrottle.createPidFromParams(options.speedTargetPid);
      this.overspeedPid = AbstractAutothrottle.createPidFromParams((_a = options.overspeedPid) !== null && _a !== void 0 ? _a : options.speedTargetPid);
      this.underspeedPid = AbstractAutothrottle.createPidFromParams((_b = options.underspeedPid) !== null && _b !== void 0 ? _b : options.speedTargetPid);
      this.selectedPowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid)
      };
      this.overpowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams((_c = options.overpowerPid) !== null && _c !== void 0 ? _c : options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams((_d = options.overpowerPid) !== null && _d !== void 0 ? _d : options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams((_e = options.overpowerPid) !== null && _e !== void 0 ? _e : options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams((_f = options.overpowerPid) !== null && _f !== void 0 ? _f : options.powerTargetPid)
      };
      this.selectedSpeedPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.overspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.underspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.hysteresis = Math.max(0, options.hysteresis);
      this.hysteresisRecord = {
        [1]: 0,
        [2]: 0,
        [3]: 0,
        [4]: 0
      };
      this.publisher.pub("at_master_is_active", false, true, true);
      this.isOverspeedProtActive.sub((val) => this.publisher.pub("at_overspeed_prot_is_active", val, true, true), true);
      this.isUnderspeedProtActive.sub((val) => this.publisher.pub("at_underspeed_prot_is_active", val, true, true), true);
      this.isOverpowerProtActive.sub((val) => this.publisher.pub("at_overpower_prot_is_active", val, true, true), true);
      this.targetMode.sub((val) => this.publisher.pub("at_target_mode", val, true, true), true);
      this.selectedIas.sub((val) => this.publisher.pub("at_selected_ias", val, true, true), true);
      this.selectedMach.sub((val) => this.publisher.pub("at_selected_mach", val, true, true), true);
      this.selectedSpeedIsMach.sub((val) => this.publisher.pub("at_selected_speed_is_mach", val, true, true), true);
      this.selectedPower.sub((val) => this.publisher.pub("at_selected_power", val, true, true), true);
      this.selectedThrottlePos.sub((val) => this.publisher.pub("at_selected_throttle_pos", val, true, true), true);
      this.maxIas.sub((val) => this.publisher.pub("at_max_ias", val, true, true), true);
      this.maxMach.sub((val) => this.publisher.pub("at_max_mach", val, true, true), true);
      this.minIas.sub((val) => this.publisher.pub("at_min_ias", val, true, true), true);
      this.minMach.sub((val) => this.publisher.pub("at_min_mach", val, true, true), true);
      this.maxPower.sub((val) => this.publisher.pub("at_max_power", val, true, true), true);
      this.maxThrottlePos.sub((val) => this.publisher.pub("at_max_throttle_pos", val, true, true), true);
      this.minThrottlePos.sub((val) => this.publisher.pub("at_min_throttle_pos", val, true, true), true);
    }
    setOverspeedProtActive(val) {
      this.isOverspeedProtActive.set(val);
    }
    setUnderspeedProtActive(val) {
      this.isUnderspeedProtActive.set(val);
    }
    setOverpowerProtActive(val) {
      this.isOverpowerProtActive.set(val);
    }
    setTargetMode(mode) {
      this.targetMode.set(mode);
    }
    setSelectedSpeedIsMach(val) {
      this.selectedSpeedIsMach.set(val);
    }
    setSelectedIas(ias) {
      this.selectedIas.set(ias);
    }
    setSelectedMach(mach) {
      this.selectedMach.set(mach);
    }
    setSelectedPower(power) {
      this.selectedPower.set(power);
    }
    setSelectedThrottlePos(pos) {
      this.selectedThrottlePos.set(pos);
    }
    setMaxIas(ias) {
      this.maxIas.set(ias);
    }
    setMinIas(ias) {
      this.minIas.set(ias);
    }
    setMaxMach(mach) {
      this.maxMach.set(mach);
    }
    setMinMach(mach) {
      this.minMach.set(mach);
    }
    setMaxPower(power) {
      this.maxPower.set(power);
    }
    setMaxThrottlePos(pos) {
      this.maxThrottlePos.set(pos);
    }
    setMinThrottlePos(pos) {
      this.minThrottlePos.set(pos);
    }
    setServoActive(index, active) {
      const throttle = this.throttles.find((query) => query.index === index);
      if (throttle !== void 0) {
        throttle.isServoActive = active;
      }
    }
    start(frequency) {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot start a dead autothrottle");
      }
      this.stop();
      this.publisher.pub("at_master_is_active", true, true, true);
      this.updateTimer = setInterval(this.updateHandler, 1e3 / frequency);
    }
    stop() {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot stop a dead autothrottle");
      }
      if (this.updateTimer === null) {
        return;
      }
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      this.machToKiasSmoother.reset();
      this.iasSmoother.reset();
      this.lookaheadIasSmoother.reset();
      this.lastSmoothedIas = void 0;
      this.selectedSpeedPid.reset();
      this.overspeedPid.reset();
      this.underspeedPid.reset();
      this.selectedSpeedPowerTargetSmoother.reset();
      this.overspeedProtPowerTargetSmoother.reset();
      this.underspeedProtPowerTargetSmoother.reset();
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].resetPowerSmoothing();
      }
      for (const index of AbstractAutothrottle.ALL_THROTTLE_INDEXES) {
        this.selectedPowerPids[index].reset();
        this.overpowerPids[index].reset();
        this.hysteresisRecord[index] = 0;
      }
      this.publisher.pub("at_master_is_active", false, true, true);
    }
    update() {
      const realTime = Date.now();
      const dt = (realTime - this.lastUpdateTime) / 1e3;
      if (dt <= 0) {
        return;
      }
      this.lastUpdateTime = realTime;
      if (realTime - this.realTime.get() >= 1e3) {
        return;
      }
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].update(dt);
      }
      const targetMode = this.targetMode.get();
      const speedCommand = this.calculateSpeedTargetPower(dt, this.speedCommand);
      const isOverpowerProtActive = this.isOverpowerProtActive.get();
      const isPowerTargetActive = targetMode === AutothrottleTargetMode.Power;
      const isThrottlePosTargetActive = targetMode === AutothrottleTargetMode.ThrottlePos;
      const minThrottlePos = this.minThrottlePos.get();
      const maxThrottlePos = this.maxThrottlePos.get();
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          const powerCommand = this.calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, this.powerCommand);
          let targetPos = powerCommand.targetPos;
          let speed = powerCommand.speed;
          const isThrottlePosOob = throttle.normPosition < minThrottlePos || throttle.normPosition > maxThrottlePos;
          const isTargetPosOob = targetPos !== void 0 && (targetPos < minThrottlePos || targetPos > maxThrottlePos);
          if (isTargetPosOob) {
            targetPos = MathUtils.clamp(targetPos, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          } else if (isThrottlePosOob && targetPos === void 0) {
            targetPos = MathUtils.clamp(throttle.normPosition, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          }
          if (targetPos !== void 0 && speed !== void 0) {
            const lastCommandedSpeed = this.hysteresisRecord[throttle.index];
            if (isThrottlePosOob || lastCommandedSpeed === 0 || Math.sign(lastCommandedSpeed) === Math.sign(speed) || Math.abs(speed) > this.hysteresis) {
              throttle.drive(targetPos, dt);
              this.hysteresisRecord[throttle.index] = speed;
            }
          } else {
            this.hysteresisRecord[throttle.index] = 0;
          }
        } else {
          this.selectedPowerPids[throttle.index].reset();
          this.overpowerPids[throttle.index].reset();
          this.hysteresisRecord[throttle.index] = 0;
        }
      }
    }
    calculateSpeedTargetPower(dt, out) {
      out.selectedSpeedPowerTarget = void 0;
      out.overspeedProtPowerTarget = void 0;
      out.underspeedProtPowerTarget = void 0;
      out.isOverspeed = false;
      out.isUnderspeed = false;
      const ias = SimVar.GetSimVarValue(this.airspeedSimVar, SimVarValueType.Knots);
      const mach = SimVar.GetSimVarValue("AIRSPEED MACH", SimVarValueType.Number);
      const currentMachToKias = ias > 1 && mach > 0 ? ias / mach : Simplane.getMachToKias(1);
      const machToKias = this.machToKiasSmoother.next(isFinite(currentMachToKias) ? currentMachToKias : 1, dt);
      const lookahead = Math.max(0, this.iasLookahead.get());
      const smoothedIas = this.iasSmoother.next(ias, dt);
      if (lookahead !== this.lastIasLookahead) {
        this.lookaheadIasSmoother.reset();
        this.lastIasLookahead = lookahead;
      }
      let effectiveIas;
      if (lookahead > 0 && this.lastSmoothedIas !== void 0) {
        const delta = smoothedIas - this.lastSmoothedIas;
        const last = this.lookaheadIasSmoother.last();
        effectiveIas = last === null || isFinite(last) ? this.lookaheadIasSmoother.next(ias + delta * lookahead / dt, dt) : this.lookaheadIasSmoother.reset(ias + delta * lookahead / dt);
      } else {
        effectiveIas = smoothedIas;
      }
      this.lastSmoothedIas = smoothedIas;
      const isTargetSpeed = this.targetMode.get() === AutothrottleTargetMode.Speed;
      const isOverspeedProtActive = this.isOverspeedProtActive.get();
      const isUnderspeedProtActive = this.isUnderspeedProtActive.get();
      let overspeedProtDelta;
      let underspeedProtDelta;
      let selectedSpeedDelta;
      if (isOverspeedProtActive) {
        const maxIas = Math.min(this.maxMach.get() * machToKias, this.maxIas.get());
        overspeedProtDelta = this.overspeedPid.getOutput(dt, maxIas - effectiveIas);
        out.isOverspeed = effectiveIas > maxIas;
      } else {
        this.overspeedPid.reset();
      }
      if (isUnderspeedProtActive) {
        const minIas = Math.max(this.minMach.get() * machToKias, this.minIas.get());
        underspeedProtDelta = this.underspeedPid.getOutput(dt, minIas - effectiveIas);
        out.isUnderspeed = effectiveIas < minIas;
      } else {
        this.underspeedPid.reset();
      }
      if (isTargetSpeed) {
        const targetIas = this.selectedSpeedIsMach.get() ? this.selectedMach.get() * machToKias : this.selectedIas.get();
        selectedSpeedDelta = this.selectedSpeedPid.getOutput(dt, targetIas - effectiveIas);
      } else {
        this.selectedSpeedPid.reset();
      }
      let throttlePowerSum = 0;
      let throttlePowerCount = 0;
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          throttlePowerSum += throttle.effectivePower;
          throttlePowerCount++;
        }
      }
      if (throttlePowerCount === 0) {
        this.overspeedProtPowerTargetSmoother.reset();
        this.underspeedProtPowerTargetSmoother.reset();
        this.selectedSpeedPowerTargetSmoother.reset();
        return out;
      }
      if (selectedSpeedDelta !== void 0) {
        out.selectedSpeedPowerTarget = this.selectedSpeedPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + selectedSpeedDelta, dt);
      } else {
        this.selectedSpeedPowerTargetSmoother.reset();
      }
      if (overspeedProtDelta !== void 0) {
        out.overspeedProtPowerTarget = this.overspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + overspeedProtDelta, dt);
      } else {
        this.overspeedProtPowerTargetSmoother.reset();
      }
      if (underspeedProtDelta !== void 0) {
        out.underspeedProtPowerTarget = this.underspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + underspeedProtDelta, dt);
      } else {
        this.underspeedProtPowerTargetSmoother.reset();
      }
      return out;
    }
    calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, out) {
      out.speed = void 0;
      out.targetPos = void 0;
      out.isOverspeedProtEngaged = false;
      out.isUnderspeedProtEngaged = false;
      out.isOverpowerProtEngaged = false;
      const targetPid = this.selectedPowerPids[throttle.index];
      const overpowerPid = this.overpowerPids[throttle.index];
      const power = throttle.power;
      const effectivePower = throttle.effectivePower;
      let overpowerProtDelta;
      let isOverpower = false;
      if (isOverpowerProtActive) {
        const maxPower = this.maxPower.get();
        overpowerProtDelta = overpowerPid.getOutput(dt, maxPower - effectivePower);
        isOverpower = power > maxPower;
      } else {
        overpowerPid.reset();
      }
      let targetDelta;
      let delta;
      let isUsingOverspeedProtCommand = false;
      let isUsingUnderspeedProtCommand = false;
      let isUsingOverpowerProtCommand = false;
      let powerTarget;
      if (isPowerTargetActive) {
        powerTarget = this.selectedPower.get();
      } else {
        powerTarget = speedCommand.selectedSpeedPowerTarget;
      }
      if (powerTarget === void 0) {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isOverspeed && speedCommand.overspeedProtPowerTarget < effectivePower)) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isUnderspeed && speedCommand.underspeedProtPowerTarget > effectivePower)) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      } else {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && speedCommand.overspeedProtPowerTarget < powerTarget) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && speedCommand.underspeedProtPowerTarget > powerTarget) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      }
      if (powerTarget !== void 0) {
        targetDelta = targetPid.getOutput(dt, powerTarget - effectivePower);
      } else {
        targetPid.reset();
      }
      if (targetDelta === void 0) {
        if (overpowerProtDelta !== void 0 && (isThrottlePosTargetActive || isOverpower && overpowerProtDelta < 0)) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        }
      } else {
        if (overpowerProtDelta !== void 0 && overpowerProtDelta < targetDelta) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        } else {
          delta = targetDelta;
        }
      }
      if (isThrottlePosTargetActive) {
        const selectedTarget = this.selectedThrottlePos.get();
        const selectedTargetDelta = MathUtils.clamp((selectedTarget - throttle.normPosition) / dt, -throttle.servoSpeed, throttle.servoSpeed);
        if (delta === void 0 || (isUsingOverspeedProtCommand || isUsingOverpowerProtCommand) && selectedTargetDelta < delta || isUsingUnderspeedProtCommand && selectedTargetDelta > delta) {
          delta = selectedTargetDelta;
          isUsingOverspeedProtCommand = false;
          isUsingUnderspeedProtCommand = false;
          isUsingOverpowerProtCommand = false;
        }
      }
      if (delta === void 0) {
        return out;
      }
      out.speed = delta;
      out.targetPos = throttle.normPosition + delta * dt;
      out.isOverspeedProtEngaged = isUsingOverspeedProtCommand;
      out.isUnderspeedProtEngaged = isUsingUnderspeedProtCommand;
      out.isOverpowerProtEngaged = isUsingOverpowerProtCommand;
      return out;
    }
    destroy() {
      this.isAlive = false;
      this.stop();
      this.realTime.destroy();
      this.throttles.forEach((throttle) => {
        throttle.destroy();
      });
    }
    static createPidFromParams(params) {
      return new PidController(params.kP, params.kI, params.kD, params.maxOut, params.minOut, params.maxI, params.minI);
    }
  };
  AbstractAutothrottle.ALL_THROTTLE_INDEXES = [1, 2, 3, 4];
  var AutothrottleThrottle = class {
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      this.servoSpeed = servoSpeed;
      this.powerLookahead = powerLookahead;
      this._position = 0;
      this._power = 0;
      this._effectivePower = 0;
      this._isServoActive = Subject.create(false);
      this.lastPowerLookahead = this.powerLookahead.get();
      this.lastSmoothedPower = void 0;
      this.initKeyManager(bus);
      ({ index: this.index, idlePosition: this.idlePosition, maxThrustPosition: this.maxThrustPosition } = info);
      if (info.isVirtual) {
        this.virtualPos = ConsumerSubject.create(bus.getSubscriber().on(`v_throttle_lever_pos_${this.index}`), 0), this.getPosition = () => {
          return this.virtualPos.get();
        };
      } else {
        this.throttlePosSimVar = `GENERAL ENG THROTTLE LEVER POSITION:${this.index}`;
        this.getPosition = () => {
          return SimVar.GetSimVarValue(this.throttlePosSimVar, SimVarValueType.Percent) / 100;
        };
      }
      this.normRange = this.maxThrustPosition - this.idlePosition;
      this.throttleSetKVar = `THROTTLE${this.index}_SET`;
      this.throttleLeverManager = info.isVirtual ? throttleLeverManager : void 0;
      const isServoActiveTopic = `at_servo_${this.index}_is_active`;
      this._isServoActive.sub((val) => {
        bus.getPublisher().pub(isServoActiveTopic, val, true, true);
      });
      this.powerSmoother = new ExpSmoother(powerSmoothingConstant);
      this.lookaheadPowerSmoother = new ExpSmoother(powerSmoothingConstant);
    }
    get position() {
      return this._position;
    }
    get normPosition() {
      return (this._position - this.idlePosition) / this.normRange;
    }
    get power() {
      return this._power;
    }
    get effectivePower() {
      return this._effectivePower;
    }
    get isServoActive() {
      return this._isServoActive.get();
    }
    set isServoActive(val) {
      this._isServoActive.set(val);
    }
    async initKeyManager(bus) {
      this.keyEventManager = await KeyEventManager.getManager(bus);
    }
    update(dt) {
      this._position = this.getPosition();
      this._power = this.getPower();
      const lookahead = Math.max(0, this.powerLookahead.get());
      const smoothedPower = this.powerSmoother.next(this._power, dt);
      if (lookahead !== this.lastPowerLookahead) {
        this.lookaheadPowerSmoother.reset();
        this.lastPowerLookahead = lookahead;
      }
      if (lookahead > 0 && this.lastSmoothedPower !== void 0) {
        const delta = smoothedPower - this.lastSmoothedPower;
        this._effectivePower = this.lookaheadPowerSmoother.next(this._power + delta * lookahead / dt, dt);
      } else {
        this._effectivePower = smoothedPower;
      }
      this.lastSmoothedPower = smoothedPower;
    }
    drive(targetNormPos, dt) {
      var _a;
      const current = this.normPosition;
      const delta = targetNormPos - current;
      if (delta === 0) {
        return;
      }
      const deltaSign = Math.sign(delta);
      const toDrive = Math.min(dt * this.servoSpeed, (targetNormPos - current) * deltaSign) * deltaSign;
      const finalPos = this.idlePosition + (current + toDrive) * this.normRange;
      if (Math.abs(finalPos - this._position) < 0.5 / AutothrottleThrottle.RAW_AXIS_MAX) {
        return;
      }
      if (this.throttleLeverManager !== void 0) {
        this.throttleLeverManager.setThrottleLeverPosRaw(this.index, finalPos * AutothrottleThrottle.RAW_AXIS_MAX);
      } else {
        (_a = this.keyEventManager) === null || _a === void 0 ? void 0 : _a.triggerKey(this.throttleSetKVar, false, Math.round(finalPos * AutothrottleThrottle.RAW_AXIS_MAX));
      }
    }
    resetPowerSmoothing() {
      this.powerSmoother.reset();
      this.lookaheadPowerSmoother.reset();
      this.lastSmoothedPower = void 0;
    }
    destroy() {
      var _a;
      (_a = this.virtualPos) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  AutothrottleThrottle.RAW_AXIS_MAX = 16384;
  var CasAlertTransporter = class {
    constructor(bus, uuid, priority, suffix) {
      this.bus = bus;
      this.uuid = uuid;
      this.priority = priority;
      this.suffix = suffix;
      this.currentValue = false;
      this.subs = [];
      this.updateEntries = [];
      this.isAlive = true;
      this.isPaused = false;
    }
    set(active) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot change an alert with a dead transporter");
      }
      if (this.currentValue !== active) {
        if (active) {
          this.bus.getPublisher().pub("cas_activate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        } else {
          this.bus.getPublisher().pub("cas_deactivate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        }
        this.currentValue = active;
      }
    }
    bind(toWatch, predicate) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      this.subs.push(toWatch.sub((v) => this.set(predicate(v)), true, this.isPaused));
      return this;
    }
    bindUpdate(predicate) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: false,
        func: (deltaTime) => this.set(predicate(deltaTime))
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    bindStateUpdate(predicate, state) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: true,
        func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
        state
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    resume() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot resume a dead transporter");
      }
      if (!this.isPaused) {
        return this;
      }
      this.isPaused = false;
      this.subs.forEach((sub) => {
        sub.resume(true);
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = false;
      });
      return this;
    }
    pause() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot pause a dead transporter");
      }
      if (this.isPaused) {
        return this;
      }
      this.isPaused = true;
      this.subs.forEach((sub) => {
        sub.pause();
      });
      if (CasAlertTransporter.updateEntries) {
        this.updateEntries.forEach((entry) => {
          const index = CasAlertTransporter.updateEntries.indexOf(entry);
          if (index >= 0) {
            CasAlertTransporter.updateEntries.splice(index, 1);
          }
        });
      }
      return this;
    }
    destroy() {
      this.isAlive = false;
      this.subs.forEach((sub) => {
        sub.destroy();
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = true;
      });
    }
    static create(bus, uuid, priority, suffix) {
      return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    initUpdateFuncs() {
      if (CasAlertTransporter.updateEntries === void 0) {
        CasAlertTransporter.updateEntries = [];
        this.bus.getSubscriber().on("simTime").handle((timestamp) => {
          if (CasAlertTransporter.previousTimestamp === -1) {
            CasAlertTransporter.previousTimestamp = timestamp;
          }
          const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 1e4);
          if (CasAlertTransporter.updateEntries !== void 0) {
            for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
              const entry = CasAlertTransporter.updateEntries[i];
              if (entry.isPaused) {
                continue;
              }
              if (entry.hasState) {
                entry.func(deltaTime, entry.state);
              } else {
                entry.func(deltaTime);
              }
            }
          }
          CasAlertTransporter.previousTimestamp = timestamp;
        });
      }
    }
  };
  CasAlertTransporter.previousTimestamp = -1;
  var ThrottleLeverManager = class {
    constructor(bus, onInitCallback, throttleLeverHandler) {
      this.bus = bus;
      this.throttleLeverHandler = throttleLeverHandler;
      this.publisher = this.bus.getPublisher();
      this.throttleLevers = ArrayUtils.create(ThrottleLeverManager.THROTTLE_COUNT, (index) => {
        return {
          index: index + 1,
          topic: `v_throttle_lever_pos_${index + 1}`,
          rawPosition: 0
        };
      });
      const sub = bus.getSubscriber();
      const virtualPositions = this.throttleLevers.map((lever) => {
        return ConsumerValue.create(sub.on(lever.topic), NaN);
      });
      KeyEventManager.getManager(bus).then((manager) => {
        for (let i = 0; i < this.throttleLevers.length; i++) {
          const lever = this.throttleLevers[i];
          const virtualPosition = virtualPositions[i].get();
          const initialPosition = isNaN(virtualPosition) ? MathUtils.clamp(SimVar.GetSimVarValue(`GENERAL ENG THROTTLE LEVER POSITION:${lever.index}`, "Percent") / 100, 0, 1) : virtualPosition;
          virtualPositions[i].destroy();
          this.setRawThrottleLeverPosition(initialPosition * ThrottleLeverManager.RAW_MAX, i + 1);
        }
        this.keyEventManager = manager;
        manager.interceptKey("AXIS_THROTTLE_SET", false);
        manager.interceptKey("AXIS_THROTTLE1_SET", false);
        manager.interceptKey("AXIS_THROTTLE2_SET", false);
        manager.interceptKey("AXIS_THROTTLE3_SET", false);
        manager.interceptKey("AXIS_THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE1_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE2_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE3_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE4_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE_SET", false);
        manager.interceptKey("THROTTLE1_SET", false);
        manager.interceptKey("THROTTLE2_SET", false);
        manager.interceptKey("THROTTLE3_SET", false);
        manager.interceptKey("THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_FULL", false);
        manager.interceptKey("THROTTLE1_FULL", false);
        manager.interceptKey("THROTTLE2_FULL", false);
        manager.interceptKey("THROTTLE3_FULL", false);
        manager.interceptKey("THROTTLE4_FULL", false);
        manager.interceptKey("THROTTLE_INCR", false);
        manager.interceptKey("THROTTLE1_INCR", false);
        manager.interceptKey("THROTTLE2_INCR", false);
        manager.interceptKey("THROTTLE3_INCR", false);
        manager.interceptKey("THROTTLE4_INCR", false);
        manager.interceptKey("THROTTLE_DECR", false);
        manager.interceptKey("THROTTLE1_DECR", false);
        manager.interceptKey("THROTTLE2_DECR", false);
        manager.interceptKey("THROTTLE3_DECR", false);
        manager.interceptKey("THROTTLE4_DECR", false);
        manager.interceptKey("THROTTLE_CUT", false);
        manager.interceptKey("THROTTLE1_CUT", false);
        manager.interceptKey("THROTTLE2_CUT", false);
        manager.interceptKey("THROTTLE3_CUT", false);
        manager.interceptKey("THROTTLE4_CUT", false);
        manager.interceptKey("INCREASE_THROTTLE", false);
        manager.interceptKey("DECREASE_THROTTLE", false);
        manager.interceptKey("THROTTLE_10", false);
        manager.interceptKey("THROTTLE_20", false);
        manager.interceptKey("THROTTLE_30", false);
        manager.interceptKey("THROTTLE_40", false);
        manager.interceptKey("THROTTLE_50", false);
        manager.interceptKey("THROTTLE_60", false);
        manager.interceptKey("THROTTLE_70", false);
        manager.interceptKey("THROTTLE_80", false);
        manager.interceptKey("THROTTLE_90", false);
        sub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        onInitCallback && onInitCallback();
      });
    }
    setThrottleLeverPos(index, pos) {
      return this.setThrottleLeverPosRaw(index, pos * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    changeThrottleLeverPos(index, delta) {
      return this.changeThrottleLeverPosRaw(index, delta * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    setThrottleLeverPosRaw(index, pos) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.setRawThrottleLeverPosition(pos, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    changeThrottleLeverPosRaw(index, delta) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.changeRawThrottleLeverPosition(delta, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    onKeyIntercepted({ key, value0 }) {
      switch (key) {
        case "AXIS_THROTTLE_SET":
        case "THROTTLE_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, void 0, key);
          }
          break;
        case "AXIS_THROTTLE1_SET":
        case "THROTTLE1_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 1, key);
          }
          break;
        case "AXIS_THROTTLE2_SET":
        case "THROTTLE2_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 2, key);
          }
          break;
        case "AXIS_THROTTLE3_SET":
        case "THROTTLE3_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 3, key);
          }
          break;
        case "AXIS_THROTTLE4_SET":
        case "THROTTLE4_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 4, key);
          }
          break;
        case "THROTTLE_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, void 0, key);
          }
          break;
        case "THROTTLE1_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 1, key);
          }
          break;
        case "THROTTLE2_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 2, key);
          }
          break;
        case "THROTTLE3_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 3, key);
          }
          break;
        case "THROTTLE4_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 4, key);
          }
          break;
        case "THROTTLE_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, void 0, key);
          break;
        case "THROTTLE1_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 1, key);
          break;
        case "THROTTLE2_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 2, key);
          break;
        case "THROTTLE3_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 3, key);
          break;
        case "THROTTLE4_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 4, key);
          break;
        case "THROTTLE_CUT":
          this.setRawThrottleLeverPosition(0, void 0, key);
          break;
        case "THROTTLE1_CUT":
          this.setRawThrottleLeverPosition(0, 1, key);
          break;
        case "THROTTLE2_CUT":
          this.setRawThrottleLeverPosition(0, 2, key);
          break;
        case "THROTTLE3_CUT":
          this.setRawThrottleLeverPosition(0, 3, key);
          break;
        case "THROTTLE4_CUT":
          this.setRawThrottleLeverPosition(0, 4, key);
          break;
        case "THROTTLE_INCR":
        case "INCREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_DECR":
        case "DECREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_10":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.1, void 0, key);
          break;
        case "THROTTLE_20":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.2, void 0, key);
          break;
        case "THROTTLE_30":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.3, void 0, key);
          break;
        case "THROTTLE_40":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.4, void 0, key);
          break;
        case "THROTTLE_50":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.5, void 0, key);
          break;
        case "THROTTLE_60":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.6, void 0, key);
          break;
        case "THROTTLE_70":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.7, void 0, key);
          break;
        case "THROTTLE_80":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.8, void 0, key);
          break;
        case "THROTTLE_90":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.9, void 0, key);
          break;
      }
    }
    setRawThrottleLeverPosition(rawPosition, index, keyEvent) {
      rawPosition = MathUtils.clamp(Math.round(rawPosition), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        const lever = this.throttleLevers[i - 1];
        if (this.throttleLeverHandler) {
          rawPosition = MathUtils.clamp(Math.round(this.throttleLeverHandler(lever.index, lever.rawPosition / ThrottleLeverManager.RAW_MAX, rawPosition / ThrottleLeverManager.RAW_MAX, keyEvent) * ThrottleLeverManager.RAW_MAX), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
        }
        if (rawPosition !== lever.rawPosition) {
          lever.rawPosition = rawPosition;
          this.publishThrottleLeverPosition(lever);
        }
      }
    }
    changeRawThrottleLeverPosition(delta, index, keyEvent) {
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        this.setRawThrottleLeverPosition(this.throttleLevers[i - 1].rawPosition + delta, i, keyEvent);
      }
    }
    publishThrottleLeverPosition(lever) {
      this.publisher.pub(lever.topic, lever.rawPosition / ThrottleLeverManager.RAW_MAX, true, true);
    }
  };
  ThrottleLeverManager.THROTTLE_COUNT = 4;
  ThrottleLeverManager.RAW_MAX = 16384;
  ThrottleLeverManager.RAW_STEP = 256;
  var Binding = class {
    constructor(input, valueHandler) {
      this.input = input;
      this.valueHandler = valueHandler;
      this.canInitialNotify = false;
      if ("isConsumer" in this.input) {
        this.sub = this.input.handle((data) => this.valueHandler(data));
      } else {
        this.canInitialNotify = true;
        this.sub = this.input.sub((data) => this.valueHandler(data), this.canInitialNotify, true);
      }
    }
    get isPaused() {
      return this.sub.isPaused;
    }
    get isAlive() {
      return this.sub.isAlive;
    }
    pause() {
      this.sub.pause();
      return this;
    }
    resume() {
      this.sub.resume(true);
      return this;
    }
    destroy() {
      this.sub.destroy();
    }
  };
  var FmcComponent = class {
    constructor(page, options) {
      this.page = page;
      this.options = options;
    }
    invalidate() {
      this.page.invalidate();
    }
    async handleSelectKey(event) {
      var _a, _b;
      if (this.options.disabled) {
        return false;
      }
      if (event.isDelete) {
        if (this.options.onDelete) {
          const result = await this.options.onDelete();
          if (result === true || typeof result === "string") {
            if ((_a = this.options.clearScratchpadOnSelectedHandled) !== null && _a !== void 0 ? _a : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        }
      }
      if (this.options.onSelected) {
        try {
          const result = await this.options.onSelected(event.scratchpadContents);
          if (result === true || typeof result === "string") {
            if ((_b = this.options.clearScratchpadOnSelectedHandled) !== null && _b !== void 0 ? _b : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        } catch (error) {
          return Promise.reject(error);
        }
      }
      return this.onHandleSelectKey(event);
    }
    getOptions() {
      return this.options;
    }
  };
  var FmcPageLifecyclePolicy;
  (function(FmcPageLifecyclePolicy2) {
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Singleton"] = 0] = "Singleton";
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Transient"] = 1] = "Transient";
  })(FmcPageLifecyclePolicy || (FmcPageLifecyclePolicy = {}));
  var AbstractFmcPage = class {
    constructor(bus, screen) {
      this.bus = bus;
      this.screen = screen;
      this.memorizedComponents = [];
      this.bindings = [];
      this.params = /* @__PURE__ */ new Map();
      this.isDirty = false;
      this.clockHandler = (d) => {
        if (this.isDirty) {
          this.isDirty = false;
          this.initialRender();
        }
      };
      this.isInitialized = false;
      this.currentOutput = [];
      this.screen = screen;
      this.clockConsumer = this.bus.getSubscriber().on("realTime").atFrequency(10, false);
    }
    init() {
      this.onInit();
      this.addBinding(new Binding(this.screen.currentSubpageIndex, () => this.invalidate()));
    }
    onInit() {
    }
    pause() {
      for (const binding of this.bindings) {
        binding.pause();
      }
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      this.onPause();
    }
    onPause() {
    }
    resume() {
      for (const binding of this.bindings) {
        binding.resume(true);
      }
      this.onResume();
      this.isDirty = true;
      this.clockConsumer.handle(this.clockHandler);
    }
    onResume() {
    }
    onPageButtonPressed() {
    }
    destroy() {
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      for (const binding of this.bindings) {
        binding.destroy();
      }
      this.onDestroy();
    }
    onDestroy() {
    }
    invalidate() {
      this.isDirty = true;
    }
    initialRender() {
      if (!this.isInitialized) {
        return;
      }
      const templates = this.render();
      this.screen.currentSubpageCount.set(templates.length);
      const template = templates[this.screen.currentSubpageIndex.get() - 1];
      const render = [];
      this.memorizedComponents.length = 0;
      for (let i = 0; i < template.length; i++) {
        if (!render[i]) {
          render[i] = [];
        }
        const row = template[i];
        const renderRow = render[i];
        for (let j = 0; j < row.length; j++) {
          const col = row[j];
          if (col instanceof FmcComponent) {
            if (!this.memorizedComponents[i]) {
              this.memorizedComponents[i] = [null, null, null];
            }
            this.memorizedComponents[i][j] = col;
            const componentRender = col.render();
            if (Array.isArray(componentRender)) {
              for (let k = 0; k < componentRender.length; k++) {
                const componentRenderRow = componentRender[k];
                for (let l = 0; l < componentRenderRow.length; l++) {
                  if (!render[i + k]) {
                    render[i + k] = [];
                  }
                  render[i + k][l] = componentRenderRow[l];
                }
              }
            } else {
              renderRow[row.indexOf(col)] = componentRender;
            }
          } else {
            renderRow[j] = col;
          }
        }
      }
      this.currentOutput = render;
      this.renderCallback(this.currentOutput, template, 0);
    }
    addBinding(binding) {
      this.bindings.push(binding);
    }
    async handleLineSelectKey(event) {
      var _a;
      const componentAtSk = (_a = this.memorizedComponents[event.row]) === null || _a === void 0 ? void 0 : _a[event.col];
      if (componentAtSk) {
        const selectKeyHandled = await componentAtSk.handleSelectKey(event);
        if (selectKeyHandled !== false) {
          return selectKeyHandled;
        }
      }
      const handledByPage = await this.onHandleSelectKey(event);
      if (!handledByPage) {
        return Promise.reject("KEY NOT ACTIVE");
      }
      return handledByPage;
    }
    async onHandleSelectKey(event) {
      return false;
    }
    async handleScrolling(event) {
      return this.onHandleScrolling(event);
    }
    async onHandleScrolling(event) {
      return false;
    }
  };
  AbstractFmcPage.lifecyclePolicy = FmcPageLifecyclePolicy.Singleton;
  var ImageCache = class {
    static addToCache(key, url) {
      if (this.cache[key] === void 0) {
        const img = new Image();
        img.src = url;
        this.cache[key] = img;
      }
    }
    static get(key) {
      return this.cache[key];
    }
  };
  ImageCache.cache = {};
  var DmsFormatter2 = class {
    static create(format, unit, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format, precision, unit);
      return (angle) => {
        if (isNaN(angle)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle, unit), "");
      };
    }
    static createForNumberUnit(format, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format, precision.number, precision.unit);
      return (angle) => {
        if (angle.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle.number, angle.unit), "");
      };
    }
    static createBuilder(format, precision, precisionUnit) {
      const split = format.split(DmsFormatter2.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DmsFormatter2.FORMAT_REGEXP)) {
          return DmsFormatter2.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DmsFormatter2.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          posStringMatch,
          negStringMatch
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DmsFormatter2.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        unitMatch,
        leftOptionalMatch,
        rightMatch,
        rightForcedMatch,
        rightOptionalMatch
      ] = numericMatch;
      const unitInfo = DmsFormatter2.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (angle, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
      } : (angle, unit, epsilon) => {
        return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(angle), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (angle, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (angle, unit) => {
          const converted = convertFunc(angle, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (angle, unit) => {
          return formatLeftFunc(convertFunc(angle, unit, epsilon));
        };
      }
    }
  };
  DmsFormatter2.FORMAT_REGEXP = /({[^{}]*})/;
  DmsFormatter2.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DmsFormatter2.NUM_FRAGMENT_REGEXP = /^(([DMSdms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DmsFormatter2.NUM_FRAGMENT_UNIT_INFO = {
    ["d"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["m"]: { unit: UnitType.ARC_MIN, mod: 60 },
    ["s"]: { unit: UnitType.ARC_SEC, mod: 60 },
    ["D"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["M"]: { unit: UnitType.ARC_MIN, mod: Infinity },
    ["S"]: { unit: UnitType.ARC_SEC, mod: Infinity }
  };
  var DurationFormatter = class {
    static create(format, unit, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format, precision, unit);
      return (duration) => {
        if (isNaN(duration)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration, unit), "");
      };
    }
    static createForNumberUnit(format, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format, precision.number, precision.unit);
      return (duration) => {
        if (duration.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration.number, duration.unit), "");
      };
    }
    static createBuilder(format, precision, precisionUnit) {
      const split = format.split(DurationFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DurationFormatter.FORMAT_REGEXP)) {
          return DurationFormatter.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          posStringMatch,
          negStringMatch
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        unitMatch,
        leftOptionalMatch,
        rightMatch,
        rightForcedMatch,
        rightOptionalMatch
      ] = numericMatch;
      const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (duration, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
      } : (duration, unit, epsilon) => {
        return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(duration), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (duration, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (duration, unit) => {
          const converted = convertFunc(duration, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (duration, unit) => {
          return formatLeftFunc(convertFunc(duration, unit, epsilon));
        };
      }
    }
  };
  DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DurationFormatter.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ["h"]: { unit: UnitType.HOUR, mod: Infinity },
    ["m"]: { unit: UnitType.MINUTE, mod: 60 },
    ["s"]: { unit: UnitType.SECOND, mod: 60 },
    ["H"]: { unit: UnitType.HOUR, mod: Infinity },
    ["M"]: { unit: UnitType.MINUTE, mod: Infinity },
    ["S"]: { unit: UnitType.SECOND, mod: Infinity }
  };
  DurationFormatter.NUM_FRAGMENT_ROUND_FUNCS = {
    ["+"]: Math.ceil,
    ["-"]: Math.floor,
    ["~"]: Math.round
  };
  var DateTimeFormatter = class {
    static create(format, options) {
      const optsToUse = Object.assign({}, DateTimeFormatter.DEFAULT_OPTIONS, options);
      const builder = DateTimeFormatter.createBuilder(format, optsToUse);
      const date = new Date();
      return (time) => {
        if (isNaN(time)) {
          return optsToUse.nanString;
        }
        date.setTime(time);
        return builder.reduce((string, part) => string + part(date), "");
      };
    }
    static createBuilder(format, options) {
      const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
          return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, options) {
      const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
      if (match) {
        if (match[1]) {
          return DateTimeFormatter.parseNumFragment(match);
        } else if (match[4]) {
          return DateTimeFormatter.parseYearFragment(match);
        } else if (match[5]) {
          return DateTimeFormatter.parseMonthFragment(match, options);
        } else if (match[6]) {
          return DateTimeFormatter.parseDayFragment(match, options);
        } else if (match[7]) {
          return DateTimeFormatter.parseAMPMFragment(match);
        }
      }
      return () => "";
    }
    static parseNumFragment(match) {
      const numGetter = DateTimeFormatter.NUM_GETTERS[match[3]];
      const pad = match[2].length;
      return (date) => {
        return numGetter(date).toString().padStart(pad, "0");
      };
    }
    static parseYearFragment(match) {
      if (match[4].length === 2) {
        return (date) => (date.getUTCFullYear() % 100).toString();
      } else {
        return (date) => date.getUTCFullYear().toString();
      }
    }
    static parseMonthFragment(match, options) {
      const isUpperCase = match[5][0] === "M";
      if (match[5].length === 3) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => text[date.getUTCMonth()];
      } else if (match[5].length === 4) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => {
          const month = date.getUTCMonth();
          return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.monthNames.map((str) => str.toUpperCase()) : options.monthNames;
        return (date) => text[date.getUTCMonth()];
      }
    }
    static parseDayFragment(match, options) {
      const isUpperCase = match[6][0] === "D";
      if (match[6] === "dy") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => text[date.getUTCDay()];
      } else if (match[6] === "dy.") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => {
          const day = date.getUTCDay();
          return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.dayNames.map((str) => str.toUpperCase()) : options.dayNames;
        return (date) => text[date.getUTCDay()];
      }
    }
    static parseAMPMFragment(match) {
      const isUpperCase = match[7][0] === "A";
      const usePeriod = match[7].length > 2;
      let text = usePeriod ? ["a.m.", "p.m."] : ["am", "pm"];
      if (isUpperCase) {
        text = text.map((str) => str.toUpperCase());
      }
      return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
  };
  DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DateTimeFormatter.FRAGMENT_REGEXP = /^(?:((([MdwHhms])+))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
  DateTimeFormatter.NUM_GETTERS = {
    ["s"]: (date) => date.getUTCSeconds(),
    ["m"]: (date) => date.getUTCMinutes(),
    ["h"]: (date) => date.getUTCHours() % 12,
    ["H"]: (date) => date.getUTCHours(),
    ["w"]: (date) => date.getUTCDay() + 1,
    ["d"]: (date) => date.getUTCDate(),
    ["M"]: (date) => date.getUTCMonth() + 1
  };
  DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    nanString: "NaN"
  };
  var UserSettingSaveManager = class {
    constructor(settings, bus) {
      this.autoSaveKeys = /* @__PURE__ */ new Set();
      this.isAlive = true;
      const subscriber = bus.getSubscriber();
      this.entries = Array.from(settings, (setting) => {
        const autoSaveDataStoreKeys = [];
        return {
          setting,
          subscription: subscriber.on(setting.definition.name).whenChanged().handle(this.onSettingChanged.bind(this, autoSaveDataStoreKeys), true),
          autoSaveDataStoreKeys
        };
      });
    }
    onSettingChanged(autoSaveDataStoreKeys, value) {
      const len = autoSaveDataStoreKeys.length;
      for (let i = 0; i < len; i++) {
        DataStore.set(autoSaveDataStoreKeys[i], value);
      }
    }
    load(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot load using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        const storedValue = DataStore.get(dataStoreKey);
        if (storedValue !== void 0) {
          entry.setting.value = storedValue;
        }
      }
    }
    save(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot save using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        DataStore.set(dataStoreKey, entry.setting.value);
      }
    }
    startAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot start autosave using a destroyed manager.");
      }
      if (this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.push(UserSettingSaveManager.getDataStoreKey(entry.setting, key));
        if (entry.autoSaveDataStoreKeys.length === 1) {
          entry.subscription.resume();
        }
      }
    }
    stopAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot stop autosave using a destroyed manager.");
      }
      if (!this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.splice(entry.autoSaveDataStoreKeys.indexOf(UserSettingSaveManager.getDataStoreKey(entry.setting, key)), 1);
        if (entry.autoSaveDataStoreKeys.length === 0) {
          entry.subscription.pause();
        }
      }
    }
    destroy() {
      const len = this.entries.length;
      for (let i = 0; i < len; i++) {
        this.entries[i].subscription.destroy();
      }
      this.entries.length = 0;
      this.isAlive = false;
    }
    static getDataStoreKey(setting, saveKey) {
      return `${UserSettingSaveManager.DATASTORE_PREFIX}.${saveKey}.${setting.definition.name}`;
    }
  };
  UserSettingSaveManager.DATASTORE_PREFIX = "persistent-setting";
  var AvionicsSystemState;
  (function(AvionicsSystemState2) {
    AvionicsSystemState2["Off"] = "Off";
    AvionicsSystemState2["Initializing"] = "Initializing";
    AvionicsSystemState2["On"] = "On";
    AvionicsSystemState2["Failed"] = "Failed";
  })(AvionicsSystemState || (AvionicsSystemState = {}));
  var FsBaseInstrument = class extends BaseInstrument {
    connectedCallback() {
      super.connectedCallback();
      this.fsInstrument = this.constructInstrument();
    }
    Update() {
      super.Update();
      if (this.fsInstrument) {
        this.fsInstrument.Update();
      }
    }
    onInteractionEvent(_args) {
      if (this.fsInstrument) {
        this.fsInstrument.onInteractionEvent(_args);
      }
    }
    onGameStateChanged(oldState, newState) {
      super.onGameStateChanged(oldState, newState);
      if (this.fsInstrument) {
        this.fsInstrument.onGameStateChanged(oldState, newState);
      }
    }
    onFlightStart() {
      super.onFlightStart();
      if (this.fsInstrument) {
        this.fsInstrument.onFlightStart();
      }
    }
    onSoundEnd(soundEventId) {
      super.onSoundEnd(soundEventId);
      if (this.fsInstrument) {
        this.fsInstrument.onSoundEnd(soundEventId);
      }
    }
    get isInteractive() {
      return false;
    }
  };

  // src/systems/instruments/src/Clock/shared/ClockSimvarPublisher.tsx
  var _ClockSimvarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(_ClockSimvarPublisher.simvars, bus);
    }
  };
  var ClockSimvarPublisher = _ClockSimvarPublisher;
  ClockSimvarPublisher.simvars = /* @__PURE__ */ new Map([
    ["ltsTest", { name: "L:A32NX_OVHD_INTLT_ANN" /* ltsTest */, type: SimVarValueType.Number }],
    ["dcEssIsPowered", { name: "L:A32NX_ELEC_DC_ESS_BUS_IS_POWERED" /* dcEssIsPowered */, type: SimVarValueType.Bool }],
    ["dcHot1IsPowered", { name: "L:A32NX_ELEC_DC_HOT_1_BUS_IS_POWERED" /* dcHot1IsPowered */, type: SimVarValueType.Bool }],
    ["absTime", { name: "E:ABSOLUTE TIME" /* absTime */, type: SimVarValueType.Number }],
    ["timeOfDay", { name: "E:TIME OF DAY" /* timeOfDay */, type: SimVarValueType.Enum }],
    ["currentUTC", { name: "E:ZULU TIME" /* currentUTC */, type: SimVarValueType.Number }],
    ["dayOfMonth", { name: "E:ZULU DAY OF MONTH" /* dayOfMonth */, type: SimVarValueType.Number }],
    ["monthOfYear", { name: "E:ZULU MONTH OF YEAR" /* monthOfYear */, type: SimVarValueType.Number }],
    ["year", { name: "E:ZULU YEAR" /* year */, type: SimVarValueType.Number }],
    ["elapsedKnobPos", { name: "L:A32NX_CHRONO_ET_SWITCH_POS" /* elapsedKnobPos */, type: SimVarValueType.Number }],
    ["dc2IsPowered", { name: "L:A32NX_ELEC_DC_2_BUS_IS_POWERED" /* dc2IsPowered */, type: SimVarValueType.Bool }]
  ]);

  // src/systems/instruments/src/Clock/shared/Utils.tsx
  var debouncedTimeDelta = (absTimeSeconds, prevTimeSeconds) => {
    const diff = Math.max(absTimeSeconds - prevTimeSeconds, 0);
    return diff < 60 ? diff : 0;
  };

  // src/systems/instruments/src/Clock/Components/Chrono.tsx
  var getDisplayString = (seconds, running, ltsTest) => {
    if (ltsTest) {
      return "88:88";
    }
    if (seconds !== null) {
      return Math.floor(Math.min(seconds, Chrono.MAX_DISPLAYABLE_TIME_SECONDS) / Chrono.SECONDS_PER_MINUTE).toString().padStart(2, "0") + (running ? ":" : " ") + Math.floor(Math.min(seconds, Chrono.MAX_DISPLAYABLE_TIME_SECONDS) % Chrono.SECONDS_PER_MINUTE).toString().padStart(2, "0");
    }
    return "";
  };
  var Chrono = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.chronoText = Subject.create("");
      this.elapsedTime = Subject.create(null);
      this.running = Subject.create(false);
      this.ltsTest = Subject.create(false);
    }
    onAfterRender(node) {
      super.onAfterRender(node);
      const sub = this.props.bus.getSubscriber();
      sub.on("ltsTest").whenChanged().handle((ltsTest) => {
        this.ltsState = ltsTest;
        this.ltsTest.set(ltsTest === 0 && this.dc2IsPowered);
      });
      sub.on("dc2IsPowered").whenChanged().handle((dc2IsPowered) => {
        this.dc2IsPowered = dc2IsPowered;
        this.ltsTest.set(this.ltsState === 0 && dc2IsPowered);
      });
      sub.on("dcHot1IsPowered").whenChanged().handle((dcHot1IsPowered) => {
        if (!dcHot1IsPowered) {
          this.running.set(false);
          this.elapsedTime.set(null);
        }
      });
      sub.on("dcEssIsPowered").whenChanged().handle((dcEssIsPowered) => this.dcEssIsPowered = dcEssIsPowered);
      sub.on("absTime").atFrequency(5).handle((absTime) => {
        if (this.running.get()) {
          const newElapsedTime = (this.elapsedTime.get() || 0) + debouncedTimeDelta(absTime, this.prevTime);
          this.elapsedTime.set(newElapsedTime);
        }
        this.prevTime = absTime;
      });
      const hEventsSub = this.props.bus.getSubscriber();
      hEventsSub.on("hEvent").handle((eventName) => {
        switch (eventName) {
          case "A32NX_CHRONO_RST":
            if (this.dcEssIsPowered) {
              if (this.running.get()) {
                this.elapsedTime.set(0);
              } else {
                this.elapsedTime.set(null);
              }
            }
            break;
          case "A32NX_CHRONO_TOGGLE":
            if (this.dcEssIsPowered) {
              this.running.set(!this.running.get());
            }
            break;
          default:
            break;
        }
      });
      this.elapsedTime.sub((elapsedTime) => SimVar.SetSimVarValue("L:A32NX_CHRONO_ELAPSED_TIME", "number", elapsedTime != null ? elapsedTime : -1));
      [
        this.elapsedTime,
        this.running,
        this.ltsTest
      ].forEach((attr) => attr.sub(() => this.chronoText.set(getDisplayString(this.elapsedTime.get(), this.running.get(), this.ltsTest.get()))));
    }
    render() {
      return /* @__PURE__ */ FSComponent.buildComponent("text", { x: "47", y: "60", class: "fontBig" }, this.chronoText);
    }
  };
  Chrono.SECONDS_PER_MINUTE = 60;
  Chrono.MAX_DISPLAYABLE_TIME_SECONDS = 99 * 60 + 59;

  // src/systems/instruments/src/Clock/Components/Clock.tsx
  var secondsToDisplay = (seconds) => {
    const displayTime = [0, 0, 0];
    displayTime[0 /* Hours */] = Math.floor(seconds / Clock.SECONDS_PER_HOUR);
    displayTime[1 /* Minutes */] = Math.floor(seconds % Clock.SECONDS_PER_HOUR / Clock.SECONDS_PER_MINUTE);
    displayTime[2 /* Seconds */] = Math.floor(seconds % Clock.SECONDS_PER_MINUTE);
    return displayTime;
  };
  var _Clock = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.clockTextBig = Subject.create("");
      this.clockTextSmall = Subject.create("");
      this.ltsTest = Subject.create(false);
      this.dcHot1IsPowered = Subject.create(true);
      this.dateMode = Subject.create(false);
      this.currentUTC = Subject.create(0);
      this.currentDate = Subject.create({ dayOfMonth: 1, monthOfYear: 1, year: 1970 });
    }
    updateClockText() {
      if (!this.dcHot1IsPowered.get()) {
        this.clockTextBig.set("");
        this.clockTextSmall.set("");
        return;
      }
      if (this.ltsTest.get()) {
        this.clockTextBig.set("88:88");
        this.clockTextSmall.set("88");
        return;
      }
      if (!this.dateMode.get()) {
        const displayTime = secondsToDisplay(this.currentUTC.get());
        this.clockTextBig.set(`${displayTime[0 /* Hours */].toString().padStart(2, "0")}:${displayTime[1 /* Minutes */].toString().padStart(2, "0")}`);
        this.clockTextSmall.set(displayTime[2 /* Seconds */].toString().padStart(2, "0"));
      } else {
        this.clockTextBig.set(`${this.currentDate.get().monthOfYear.toString().padStart(2, "0")}:${this.currentDate.get().dayOfMonth.toString().padStart(2, "0")}`);
        this.clockTextSmall.set(this.currentDate.get().year.toString().substring(2, 4));
      }
    }
    onAfterRender(node) {
      super.onAfterRender(node);
      const sub = this.props.bus.getSubscriber();
      sub.on("ltsTest").whenChanged().handle((ltsTest) => {
        this.ltsState = ltsTest;
        this.ltsTest.set(ltsTest === 0 && this.dc2IsPowered);
      });
      sub.on("dc2IsPowered").whenChanged().handle((dc2IsPowered) => {
        this.dc2IsPowered = dc2IsPowered;
        this.ltsTest.set(this.ltsState === 0 && dc2IsPowered);
      });
      sub.on("dcHot1IsPowered").whenChanged().handle((dcHot1IsPowered) => this.dcHot1IsPowered.set(dcHot1IsPowered));
      sub.on("currentUTC").withPrecision(0).handle((currentUTC) => this.currentUTC.set(currentUTC));
      sub.on("dayOfMonth").whenChanged().handle((dayOfMonth) => this.currentDate.set(__spreadProps(__spreadValues({}, this.currentDate.get()), { dayOfMonth })));
      sub.on("monthOfYear").whenChanged().handle((monthOfYear) => this.currentDate.set(__spreadProps(__spreadValues({}, this.currentDate.get()), { monthOfYear })));
      sub.on("year").whenChanged().handle((year) => this.currentDate.set(__spreadProps(__spreadValues({}, this.currentDate.get()), { year })));
      const hEventsSub = this.props.bus.getSubscriber();
      hEventsSub.on("hEvent").handle((eventName) => {
        switch (eventName) {
          case "A32NX_CHRONO_DATE":
            this.dateMode.set(!this.dateMode.get());
            break;
          default:
            break;
        }
      });
      [
        this.ltsTest,
        this.dcHot1IsPowered,
        this.dateMode,
        this.currentUTC
      ].forEach((attr) => attr.sub(() => this.updateClockText()));
    }
    render() {
      return /* @__PURE__ */ FSComponent.buildComponent(FSComponent.Fragment, null, /* @__PURE__ */ FSComponent.buildComponent("text", { x: "6", y: "153", class: "fontBig" }, this.clockTextBig), /* @__PURE__ */ FSComponent.buildComponent("text", { x: "190", y: "147", class: "fontSmall" }, this.clockTextSmall));
    }
  };
  var Clock = _Clock;
  Clock.SECONDS_PER_MINUTE = 60;
  Clock.SECONDS_PER_HOUR = _Clock.SECONDS_PER_MINUTE * 60;

  // src/systems/instruments/src/Clock/Components/ElapsedTime.tsx
  var getDisplayString2 = (seconds, running, ltsTest) => {
    if (ltsTest) {
      return "88:88";
    }
    if (seconds !== null) {
      return Math.floor(Math.min(seconds, ElapsedTime.MAX_DISPLAYABLE_TIME_SECONDS) / ElapsedTime.SECONDS_PER_HOUR).toString().padStart(2, "0") + (running ? ":" : " ") + Math.floor(Math.min(seconds, ElapsedTime.MAX_DISPLAYABLE_TIME_SECONDS) % ElapsedTime.SECONDS_PER_HOUR / ElapsedTime.SECONDS_PER_MINUTE).toString().padStart(2, "0");
    }
    return "";
  };
  var _ElapsedTime = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.timerText = Subject.create("");
      this.elapsedTime = Subject.create(null);
      this.ltsTest = Subject.create(false);
      this.elapsedKnobPos = Subject.create(1);
    }
    onAfterRender(node) {
      super.onAfterRender(node);
      const sub = this.props.bus.getSubscriber();
      sub.on("ltsTest").whenChanged().handle((ltsTest) => {
        this.ltsState = ltsTest;
        this.ltsTest.set(ltsTest === 0 && this.dc2IsPowered);
      });
      sub.on("dc2IsPowered").whenChanged().handle((dc2IsPowered) => {
        this.dc2IsPowered = dc2IsPowered;
        this.ltsTest.set(this.ltsState === 0 && dc2IsPowered);
      });
      sub.on("dcHot1IsPowered").whenChanged().handle((dcHot1IsPowered) => {
        if (!dcHot1IsPowered) {
          this.elapsedTime.set(null);
        }
      });
      sub.on("dcEssIsPowered").whenChanged().handle((dcEssIsPowered) => this.dcEssIsPowered = dcEssIsPowered);
      sub.on("elapsedKnobPos").whenChanged().handle((elapsedKnobPos) => this.elapsedKnobPos.set(elapsedKnobPos));
      sub.on("absTime").atFrequency(5).handle((absTime) => {
        if (this.dcEssIsPowered) {
          if (this.elapsedKnobPos.get() === 0) {
            const newElapsedTime = (this.elapsedTime.get() || 0) + debouncedTimeDelta(absTime, this.prevTime);
            this.elapsedTime.set(newElapsedTime);
          } else if (this.elapsedKnobPos.get() === 2) {
            this.elapsedTime.set(null);
          }
          this.prevTime = absTime;
        }
      });
      this.elapsedTime.sub((elapsedTime) => SimVar.SetSimVarValue("L:A32NX_CHRONO_ET_ELAPSED_TIME", "number", elapsedTime != null ? elapsedTime : -1));
      [
        this.elapsedTime,
        this.ltsTest,
        this.elapsedKnobPos
      ].forEach((attr) => attr.sub(() => this.timerText.set(getDisplayString2(this.elapsedTime.get(), this.elapsedKnobPos.get() === 0, this.ltsTest.get()))));
    }
    render() {
      return /* @__PURE__ */ FSComponent.buildComponent("text", { x: "47", y: "247", class: "fontBig" }, this.timerText);
    }
  };
  var ElapsedTime = _ElapsedTime;
  ElapsedTime.SECONDS_PER_MINUTE = 60;
  ElapsedTime.SECONDS_PER_HOUR = _ElapsedTime.SECONDS_PER_MINUTE * 60;
  ElapsedTime.MAX_DISPLAYABLE_TIME_SECONDS = _ElapsedTime.SECONDS_PER_HOUR * 99 + _ElapsedTime.SECONDS_PER_MINUTE * 59;

  // src/systems/instruments/src/Clock/Clock.tsx
  var ClockRoot = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.gElementRef = FSComponent.createRef();
      this.svgElementRef = FSComponent.createRef();
    }
    onAfterRender(node) {
      super.onAfterRender(node);
      const sub = this.props.bus.getSubscriber();
      sub.on("dcEssIsPowered").whenChanged().handle((dccEssIsPowered) => {
        this.svgElementRef.instance.classList.toggle("powered", dccEssIsPowered);
        this.svgElementRef.instance.classList.toggle("unpowered", !dccEssIsPowered);
      });
      sub.on("timeOfDay").whenChanged().handle((timeOfDay) => {
        this.gElementRef.instance.classList.toggle("day", timeOfDay === 1 || timeOfDay === 2);
        this.gElementRef.instance.classList.toggle("night", !(timeOfDay === 1 || timeOfDay === 2));
      });
    }
    render() {
      return /* @__PURE__ */ FSComponent.buildComponent("svg", { ref: this.svgElementRef, version: "1.1", viewBox: "0 0 256 256", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ FSComponent.buildComponent("g", { ref: this.gElementRef }, /* @__PURE__ */ FSComponent.buildComponent(Chrono, { bus: this.props.bus }), /* @__PURE__ */ FSComponent.buildComponent(Clock, { bus: this.props.bus }), /* @__PURE__ */ FSComponent.buildComponent(ElapsedTime, { bus: this.props.bus })));
    }
  };

  // src/systems/instruments/src/Clock/instrument.tsx
  var A32NX_Clock = class extends BaseInstrument {
    constructor() {
      super();
      this.gameState = 0;
      this.bus = new EventBus();
      this.simVarPublisher = new ClockSimvarPublisher(this.bus);
      this.hEventPublisher = new HEventPublisher(this.bus);
    }
    get templateID() {
      return "A32NX_Clock";
    }
    onInteractionEvent(args) {
      this.hEventPublisher.dispatchHEvent(args[0]);
    }
    connectedCallback() {
      super.connectedCallback();
      this.hEventPublisher.startPublish();
      this.simVarPublisher.subscribe("ltsTest");
      this.simVarPublisher.subscribe("dcEssIsPowered");
      this.simVarPublisher.subscribe("dcHot1IsPowered");
      this.simVarPublisher.subscribe("absTime");
      this.simVarPublisher.subscribe("timeOfDay");
      this.simVarPublisher.subscribe("currentUTC");
      this.simVarPublisher.subscribe("dayOfMonth");
      this.simVarPublisher.subscribe("monthOfYear");
      this.simVarPublisher.subscribe("year");
      this.simVarPublisher.subscribe("elapsedKnobPos");
      this.simVarPublisher.subscribe("dc2IsPowered");
      FSComponent.render(/* @__PURE__ */ FSComponent.buildComponent(ClockRoot, { bus: this.bus }), document.getElementById("Clock_CONTENT"));
      document.getElementById("Clock_CONTENT").querySelector(":scope > h1").remove();
    }
    Update() {
      super.Update();
      if (this.gameState !== 3) {
        const gamestate = this.getGameState();
        if (gamestate === 3) {
          this.simVarPublisher.startPublish();
        }
        this.gameState = gamestate;
      } else {
        this.simVarPublisher.onUpdate();
      }
    }
  };
  registerInstrument("a32nx-clock", A32NX_Clock);
})();
